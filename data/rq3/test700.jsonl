{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix mem leaks in unit test from 776 (#779)\n\nDiff:\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n... [truncated] ...\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n-    if (res) {\n-      // This is already freed in the case of a non-ok error in rcl_parse_yaml_file\n-      rcl_yaml_node_struct_fini(params_hdl);\n-      params_hdl = NULL;\n-    }\n+    (void)res;\n+    rcl_yaml_node_struct_fini(params_hdl);\n+    params_hdl = NULL;\n-    if (res) {\n-      // This is already freed in the case of a non-ok error in rcl_parse_yaml_file\n-      rcl_yaml_node_struct_fini(params_hdl);\n-      params_hdl = NULL;\n-    }\n+    (void)res;\n+    rcl_yaml_node_struct_fini(params_hdl);\n+    params_hdl = NULL;\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd fault-injection unit tests (coverage part 2/3) (#766)\n\nDiff:\n+    target_compile_definitions(test_namespace PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+    target_compile_definitions(test_parser PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+\n+TEST(TestNamespace, replace_ns_maybe_fail) {\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  namespace_tracker_t ns_tracker;\n+  ns_tracker.node_ns = rcutils_strdup(\"node1/node2\", allocator);\n+  ASSERT_STREQ(\"node1/node2\", ns_tracker.node_ns);\n+  ns_tracker.parameter_ns = rcutils_strdup(\"param1.param2\", allocator);\n+  ASSERT_STREQ(\"param1.param2\", ns_tracker.parameter_ns);\n+  ns_tracker.num_node_ns = 2;\n+  ns_tracker.num_parameter_ns = 2;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    allocator.deallocate(ns_tracker.node_ns, allocator.state);\n+    allocator.deallocate(ns_tracker.parameter_ns, allocator.state);\n+  });\n+\n+  char * expected_ns = rcutils_strdup(\"new_ns1/new_ns2/new_ns3\", allocator);\n+  ASSERT_STREQ(\"new_ns1/new_ns2/new_ns3\", expected_ns);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    allocator.deallocate(expected_ns, allocator.state);\n+  });\n+\n... [truncated] ...\n+    allocator.allocate(sizeof(rcutils_string_array_t), allocator.state));\n+  ASSERT_NE(nullptr, src_variant.string_array_value);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_variant_fini(&src_variant, allocator);\n+  });\n+  *src_variant.string_array_value = rcutils_get_zero_initialized_string_array();\n+  ASSERT_EQ(\n+    RCUTILS_RET_OK, rcutils_string_array_init(src_variant.string_array_value, size, &allocator));\n+  src_variant.string_array_value->size = size;\n+  src_variant.string_array_value->data[0] = rcutils_strdup(\"string1\", allocator);\n+  src_variant.string_array_value->data[1] = rcutils_strdup(\"string2\", allocator);\n+  src_variant.string_array_value->data[2] = rcutils_strdup(\"string3\", allocator);\n+  for (size_t i = 0; i < size; ++i) {\n+    ASSERT_NE(nullptr, src_variant.string_array_value->data[i]);\n+  }\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    rcl_variant_t dest_variant{};\n+    rcutils_ret_t ret = rcl_yaml_variant_copy(&dest_variant, &src_variant, allocator);\n+    (void)ret;\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+  });\n+}\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nMake sure to lock the mutex protecting client_endpoints_. (#492)\n\nDiff:\n-    // Check if the guid is still in the map\n-    if (clients_endpoints_.find(guid) == clients_endpoints_.end()) {\n-      // Client is gone\n-      return client_present_t::GONE;\n+    {\n+      std::lock_guard<std::mutex> lock(mutex_);\n+      // Check if the guid is still in the map\n+      if (clients_endpoints_.find(guid) == clients_endpoints_.end()) {\n+        // Client is gone\n+        return client_present_t::GONE;\n+      }\n-  // Accesors\n-  clients_endpoints_map_t & clients_endpoints()\n+  void endpoint_erase_if_exists(const eprosima::fastrtps::rtps::GUID_t & endpointGuid)\n+  {\n+    std::lock_guard<std::mutex> lock(mutex_);\n+    auto endpoint = clients_endpoints_.find(endpointGuid);\n+    if (endpoint != clients_endpoints_.end()) {\n+      clients_endpoints_.erase(endpoint->second);\n+      clients_endpoints_.erase(endpointGuid);\n+    }\n+  }\n+\n+  void endpoint_add_reader_and_writer(\n+    const eprosima::fastrtps::rtps::GUID_t & readerGuid,\n+    const eprosima::fastrtps::rtps::GUID_t & writerGuid)\n-    return clients_endpoints_;\n+    clients_endpoints_.emplace(readerGuid, writerGuid);\n+    clients_endpoints_.emplace(writerGuid, readerGuid);\n-      auto endpoint = info_->pub_listener_->clients_endpoints().find(\n-        matchingInfo.remoteEndpointGuid);\n-      if (endpoint != info_->pub_listener_->clients_endpoints().end()) {\n-        info_->pub_listener_->clients_endpoints().erase(endpoint->second);\n-        info_->pub_listener_->clients_endpoints().erase(matchingInfo.remoteEndpointGuid);\n-      }\n+      info_->pub_listener_->endpoint_erase_if_exists(matchingInfo.remoteEndpointGuid);\n-        info_->pub_listener_->clients_endpoints().emplace(reader_guid, writer_guid);\n-        info_->pub_listener_->clients_endpoints().emplace(writer_guid, reader_guid);\n+        info_->pub_listener_->endpoint_add_reader_and_writer(reader_guid, writer_guid);\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nCheck if the queue is empty before using it\n\nDiff:\n+  if (service_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+\n+  if (client_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nThrow exception if rcl_timer_init fails (#1179)\n\n* Throw exception if rcl_timer_init fails\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add bad-argument tests for GenericTimer\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add comments\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n\nDiff:\n-    if (\n-      rcl_timer_init(\n-        timer_handle_.get(), clock_handle, rcl_context.get(), period.count(), nullptr,\n-        rcl_get_default_allocator()) != RCL_RET_OK)\n-    {\n-      RCUTILS_LOG_ERROR_NAMED(\n-        \"rclcpp\",\n-        \"Couldn't initialize rcl timer handle: %s\\n\", rcl_get_error_string().str);\n-      rcl_reset_error();\n+    rcl_ret_t ret = rcl_timer_init(\n+      timer_handle_.get(), clock_handle, rcl_context.get(), period.count(), nullptr,\n+      rcl_get_default_allocator());\n+    if (ret != RCL_RET_OK) {\n+      rclcpp::exceptions::throw_from_rcl_error(ret, \"Couldn't initialize rcl timer handle\");\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUnit tests for allocator_memory_strategy.hpp (#1197)\n\n* Unit tests for allocator_memory_strategy.hpp\r\n\r\nPart 1 of 2 for this file, but part 2 of 3 for memory strategies\r\noverall\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Remove find_package\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Remove ref to osrf_testing_tools\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n\nDiff:\n+ament_add_gtest(test_allocator_memory_strategy rclcpp/strategies/test_allocator_memory_strategy.cpp)\n+if(TARGET test_allocator_memory_strategy)\n+  ament_target_dependencies(test_allocator_memory_strategy\n+    \"rcl\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_allocator_memory_strategy ${PROJECT_NAME})\n+endif()\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix interoperability errors: Remove buffer roundup at the end of messeage deserialize function\n\nDiff:\n-        ),\n-        false\n+        )\n-      ),\n-      false\n+      )\n-          ),\n-          false\n+          )\n-          ),\n-          false\n+          )\n-      ),\n-      false\n+      )\n-  void deserialize(const MessageMembersT * members, uint8_t * output, bool roundup_)\n+  void deserialize(const MessageMembersT * members, uint8_t * output)\n-\n-    if (roundup_) {\n-      buffer.roundup(4);\n-    }\n-    deserializer.deserialize(members, ros_message, true);\n+    deserializer.deserialize(members, ros_message);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nfix events-executor warm-up bug and add unit-tests (#2591)\n\nDiff:\n-      entities_need_rebuild_ = false;\n+  // If this spin is not exhaustive (e.g. spin_some), we need to explicitly check\n+  // if entities need to be rebuilt here rather than letting the notify waitable event do it.\n+  // A non-exhaustive spin would not check for work a second time, thus delaying the execution\n+  // of some entities to the next invocation of spin.\n+  if (!exhaustive) {\n+    this->handle_updated_entities(false);\n+  }\n+\n+\n+  // Do not rebuild if we don't need to.\n+  // A rebuild event could be generated, but then\n+  // this function could end up being called from somewhere else\n+  // before that event gets processed, for example if\n+  // a node or callback group is manually added to the executor.\n+  const bool notify_waitable_triggered = entities_need_rebuild_.exchange(false);\n+  if (!notify_waitable_triggered && !this->collector_.has_pending()) {\n+    return;\n+  }\n+\n+ament_add_gtest(\n+  test_executors_warmup\n+  executors/test_executors_warmup.cpp\n+  executors/test_waitable.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\"\n... [truncated] ...\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  rclcpp::SubscriptionOptions sub_options;\n+  sub_options.callback_group = callback_group;\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback), sub_options);\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n+  // the new message, no risk of race conditions where spin_some gets called before the\n+  // message has been delivered.\n+  executor.spin_some();\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix the history depth for KEEP_ALL. (#305)\n\nDiff:\n-        qos_policies->depth = (uint32_t) depth;\n+        // When using a policy of KEEP_ALL, the depth is meaningless.\n+        // CycloneDDS reports this as -1, but the rmw_qos_profile_t structure\n+        // expects an unsigned number.  Casting -1 to unsigned would yield\n+        // a value of 2^32 - 1, but unfortunately our XML-RPC connection\n+        // (used for the command-line tools) doesn't understand anything\n+        // larger than 2^31 - 1.  Just set the depth to 0 here instead.\n+        qos_policies->depth = 0;\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate minimum CMake version CMakeLists.txt.em (#969)\n\nDiff:\n-cmake_minimum_required(VERSION 3.8)\n+cmake_minimum_required(VERSION 3.16)\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nEfficiently handle 3-bytes pixel formats (#743)\n\nDiff:\n-  auto w = box.getWidth();\n-  auto h = box.getHeight();\n+  uint32_t w = box.getWidth();\n+  uint32_t h = box.getHeight();\n-  for (uint32_t y = 0; y < h; ++y) {\n-    for (uint32_t x = 0; x < w; ++x) {\n-      uint32_t pos = (x + y * w) * 4;\n-\n-      uint32_t pix_val = *reinterpret_cast<uint32_t *>(static_cast<uint8_t *>(box.data) + pos);\n-      uint32_t handle = colorToHandle(box.format, pix_val);\n-\n-      pixel_buffer_.push_back(handle);\n+  size_t size = Ogre::PixelUtil::getMemorySize(1, 1, 1, box.format);\n+\n+  for (uint32_t y = 0; y < h; y++) {\n+    for (uint32_t x = 0; x < w; x++) {\n+      uint32_t pos = static_cast<uint32_t>((x + y * w) * size);\n+      uint32_t pix_val = 0;\n+      memcpy(\n+        reinterpret_cast<uint8_t *>(&pix_val),\n+        reinterpret_cast<uint8_t *>(box.data + pos),\n+        size);\n+      pixel_buffer_.push_back(colorToHandle(box.format, pix_val));\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\n`WaitForTopics`: get content of messages for each topic (#353)\n\nDiff:\n+from collections import deque\n+            print(wait_for_topics.messages_received('topic_1')) # Should be [message_1, ...]\n-    def __init__(self, topic_tuples, timeout=5.0):\n+    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):\n+        self.messages_received_buffer_length = messages_received_buffer_length\n-        node_name = '_test_node_' +\\\n-            ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))\n-        self.__ros_node = _WaitForTopicsNode(name=node_name, node_context=self.__ros_context)\n+        node_name = '_test_node_' + ''.join(\n+            random.choices(string.ascii_uppercase + string.digits, k=10)\n+        )\n+        self.__ros_node = _WaitForTopicsNode(\n+            name=node_name,\n+            node_context=self.__ros_context,\n+            messages_received_buffer_length=self.messages_received_buffer_length,\n+        )\n+    def received_messages(self, topic_name):\n+        \"\"\"List of received messages of a specific topic.\"\"\"\n+        if topic_name not in self.__ros_node.received_messages_buffer:\n+            raise KeyError('No messages received for topic: ' + topic_name)\n+        return list(self.__ros_node.received_messages_buffer[topic_name])\n+\n-    def __init__(self, name='test_node', node_context=None):\n-        super().__init__(node_name=name, context=node_context)\n+    def __init__(\n... [truncated] ...\n+                        topic_name,\n+                        self.callback_template(topic_name),\n+                        10\n+                    )\n-            )\n-\n+            self.get_logger().debug('Message received for ' + topic_name)\n+            self.received_messages_buffer[topic_name].append(data)\n-                self.get_logger().debug('Message received for ' + topic_name)\n+import re\n+\n+\n+            message_pattern = re.compile(r'Hello World: \\d+')\n-            with WaitForTopics(topic_list, timeout=10.0) as wait_for_node_object_1:\n+            with WaitForTopics(\n+                topic_list, timeout=2.0, messages_received_buffer_length=10\n+            ) as wait_for_node_object_1:\n+                for topic_name, _ in topic_list:\n+                    assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                    message = wait_for_node_object_1.received_messages(topic_name).pop().data\n+                    assert message_pattern.match(message)\n+            for topic_name, _ in topic_list:\n+                assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                message = wait_for_node_object_2.received_messages(topic_name).pop().data\n+                assert message_pattern.match(message)\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nadded pingpong example (#172)\n\nDiff:\n+\n+add_executable(example_pingpong src/example_pingpong.cpp)\n+ament_target_dependencies(example_pingpong rcl rclc std_msgs)\n+\n+  example_pingpong\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include<iostream>\n+#include<functional>\n+#include <stdio.h>\n+#include <std_msgs/msg/string.h>\n+#include <rclc/executor.h>\n+#include <rclc/rclc.h>\n... [truncated] ...\n+    printf(\"Callback: msg NULL\\n\");\n+  } else {\n+    printf(\"Callback: I heard: %s\\n\", msg->data.data);\n+  }\n+}\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include <rcl/rcl.h>\n+#include <rcl/error_handling.h>\n+#include <rclc/rclc.h>\n+#include <std_msgs/msg/string.h>\n+\n+void pong_subscription_callback_on_update(const void * msgin);\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nadd test to ensure binary STL files from SOLIDWORKS get imported without a warning (#917)\n\nDiff:\n-  if (buffer_str.substr(0, 5) == std::string(\"solid\")) {\n-    // file says that it is ascii, but why should we trust it?\n-\n-    // check for \"endsolid\" as well\n-    if (buffer_str.find(\"endsolid\", 5) != std::string::npos) {\n-      RVIZ_RENDERING_LOG_ERROR_STREAM(\n-        \"The STL file '\" << origin << \"' is malformed. It \"\n-          \"starts with the word 'solid' and also contains the \"\n-          \"word 'endsolid', indicating that it's an ASCII STL \"\n-          \"file, but rviz can only load binary STL files so it \"\n-          \"will not be loaded. Please convert it to a \"\n-          \"binary STL file.\");\n-      return false;\n-    }\n-\n-    // chastise the user for malformed files\n-    RVIZ_RENDERING_LOG_WARNING_STREAM(\n-      \"The STL file '\" << origin << \"' is malformed. It starts \"\n-        \"with the word 'solid', indicating that it's an ASCII \"\n-        \"STL file, but it does not contain the word 'endsolid' so \"\n-        \"it is either a malformed ASCII STL file or it is actually \"\n-        \"a binary STL file. Trying to interpret it as a binary \"\n-        \"STL file instead.\");\n+  if (buffer_str.substr(0, 5) == std::string(\"solid\") &&\n+    buffer_str.find(\"endsolid\", 5) != std::string::npos)\n+  {\n+    RVIZ_RENDERING_LOG_ERROR_STREAM(\n+      \"The STL file '\" << origin << \"' is malformed. It \"\n+        \"starts with the word 'solid' and also contains the \"\n+        \"word 'endsolid', indicating that it's an ASCII STL \"\n+        \"file, but rviz can only load binary STL files so it \"\n+        \"will not be loaded. Please convert it to a \"\n+        \"binary STL file.\");\n+    return false;\n+\n+TEST_F(MeshLoaderTestFixture, loading_solidworks_binary_stl) {\n+  // In general, binary STL files should not start with \"solid\" as this hints ASCII STL files.\n+  // Annoyingly, STL files exported from Solidworks don't follow this guideline and contain\n+  // \"solid\" at the start of binary STL files.\n+  // However, they don't finish with \"endsolid\" like ASCII STL files, so we can still detect\n+  // them as binary STL files.\n+  // This test checks that SOLIDWORKS binary STL files get loaded correctly and don't get treated\n+  // as ASCII STL files.\n+  std::string mesh_path = \"package://rviz_rendering_tests/test_meshes/solidworks.stl\";\n+\n+  ASSERT_TRUE(rviz_rendering::loadMeshFromResource(mesh_path));\n+}\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nfix rclc_example: memory leaking in msg.data allocation (backport #386) (#387)\n\nDiff:\n+ * \\param[in] autostart the state of the timer at initialization\n+rclc_timer_init_default2(\n+  rcl_timer_t * timer,\n+  rclc_support_t * support,\n+  const uint64_t timeout_ns,\n+  const rcl_timer_callback_t callback,\n+  bool autostart);\n+\n+/**\n+ * \\deprecated `rclc_timer_init_default` implementation was removed.\n+ *   Refer to `rclc_timer_init_default2`.\n+ */\n+RCL_PUBLIC\n+RCUTILS_DEPRECATED_WITH_MSG(\"Call rclc_timer_init_default2 instead\")\n+rcl_ret_t\n-rclc_timer_init_default(\n+rclc_timer_init_default2(\n-  const rcl_timer_callback_t callback)\n+  const rcl_timer_callback_t callback,\n+  bool autostart)\n-  rcl_ret_t rc = rcl_timer_init(\n+  rcl_ret_t rc = rcl_timer_init2(\n-    (*support->allocator));\n+    (*support->allocator),\n+    autostart);\n... [truncated] ...\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    pong_timer_callback);\n+    pong_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-  pongNode_pong_msg.data.data = (char *) malloc(PUB_MSG_CAPACITY);\n+  pongNode_pong_msg.data.data = (char *) allocator.reallocate(pongNode_pong_msg.data.data, PUB_MSG_CAPACITY, allocator.state);\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    my_timer_callback);\n+    my_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    short_timer_callback);\n+    short_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-    pub_msgs[i].data.data = malloc(PUB_MSG_CAPACITY);\n+    pub_msgs[i].data.data = allocator.reallocate(pub_msgs[i].data.data, PUB_MSG_CAPACITY, allocator.state);\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate packages to use gurumdds-3.0 & Update README\n\nDiff:\n-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+| 3.4.2  or higher         | higher than 3.0.0           |\n-`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n-For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.\n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n-For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n-`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n-If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.\n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.\n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.\n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.\n-~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~  \n+~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~\n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n-This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.\n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.\n-There are three active branches in this project: master, humble and foxy.  \n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n-If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.\n+There are three active branches in this project: master, iron, humble.\n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n+If you want to use this project with ROS2 Rolling Ridley or Iron Irwini, please use master or iron branch, respectively.\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-3.0</build_export_depend>\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nrcl_logging_spdlog: Increased QL to 2 in QD\n\nDiff:\n-The package `rcl_logging_spdlog` claims to be in the **Quality Level 3** category.\n+The package `rcl_logging_spdlog` claims to be in the **Quality Level 2** category.\n-`rcl_logging_spdlog` has a Direct Runtime non-ROS dependenciy the `spdlog` library. It was declared to be Quality Level 4 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).\n+`rcl_logging_spdlog` has a Direct Runtime non-ROS dependenciy the `spdlog` library. It was declared to be Quality Level 1 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate quality declaration document (#225)\n\nDiff:\n-`rmw_implementation` does not expose a public API. There is no need to add documentation to new changes. In the case that this package adds public API features the documentation of new functionality will be required.\n+`rmw_implementation` does not expose a public API.\n+There is no need to add documentation to new changes.\n+In the case that this package adds public API features the documentation of new functionality will be required.\n-Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/master/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/master/test_communication) packages, further extend coverage.\n+Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/rolling/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/rolling/test_communication) packages, further extend coverage.\n-The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/master/rmw_implementation/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n+The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/rolling/rmw_implementation/test/benchmark).\n+The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n- - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n- - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n- - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n+ - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/rolling/rmw/QUALITY_DECLARATION.md)\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nSupport static discovery\n\nDiff:\n+  std::string static_discovery_id;\n+  static_discovery_id += namespace_;\n+  static_discovery_id += name;\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n-    participant = dds_DomainParticipantFactory_create_participant(\n-      factory, domain_id, &participant_qos, nullptr, 0);\n+    dds_StringProperty props[] = {\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n+      {nullptr, nullptr},\n+    };\n+    participant = dds_DomainParticipantFactory_create_participant_w_props(\n+      factory, domain_id, &participant_qos, nullptr, 0, props);\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd rosparam verb load (#590)\n\nDiff:\n+import sys\n+\n+from rcl_interfaces.msg import Parameter\n+from rclpy.parameter import PARAMETER_SEPARATOR_STRING\n+\n+def parse_parameter_dict(*, namespace, parameter_dict):\n+    parameters = []\n+    for param_name, param_value in parameter_dict.items():\n+        full_param_name = namespace + param_name\n+        # Unroll nested parameters\n+        if type(param_value) == dict:\n+            parameters += parse_parameter_dict(\n+                    namespace=full_param_name + PARAMETER_SEPARATOR_STRING,\n+                    parameter_dict=param_value)\n+        else:\n+            parameter = Parameter()\n+            parameter.name = full_param_name\n+            parameter.value = get_parameter_value(string_value=str(param_value))\n+            parameters.append(parameter)\n+    return parameters\n+\n+\n+def load_parameter_dict(*, node, node_name, parameter_dict):\n+\n+    parameters = parse_parameter_dict(namespace='', parameter_dict=parameter_dict)\n... [truncated] ...\n+\n+    def test_verb_load(self):\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            filepath = self._write_param_file(tmpdir, 'params.yaml')\n+            with self.launch_param_load_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', filepath]\n+            ) as param_load_command:\n+                assert param_load_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_load_command.exit_code == launch_testing.asserts.EXIT_OK\n+            assert launch_testing.tools.expect_output(\n+                expected_lines=[''],\n+                text=param_load_command.output,\n+                strict=True\n+            )\n+            # Dump with ros2 param dump and compare that output matches input file\n+            with self.launch_param_dump_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', '--print']\n+            ) as param_dump_command:\n+                assert param_dump_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_dump_command.exit_code == launch_testing.asserts.EXIT_OK\n+            assert launch_testing.tools.expect_output(\n+                expected_text=INPUT_PARAMETER_FILE + '\\n',\n+                text=param_dump_command.output,\n+                strict=True\n+            )\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nRe-order shutdown vs node destruction (#213)\n\nDiff:\n-        self.destroy_node()\n+        self.destroy_node()\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAvoid exception in Node constructor when use override for 'use_sim_time' (#896)\n\nDiff:\n-        # Note: parameter overrides and parameter event publisher need to be ready at this point\n-        # to be able to declare 'use_sim_time' if it was not declared yet.\n-        self._time_source = TimeSource(node=self)\n-        self._time_source.attach_clock(self._clock)\n+        # Init a time source.\n+        # Note: parameter overrides and parameter event publisher need to be ready at this point\n+        # to be able to declare 'use_sim_time' if it was not declared yet.\n+        self._time_source = TimeSource(node=self)\n+        self._time_source.attach_clock(self._clock)\n+\n+from rclpy.parameter import Parameter\n+    def test_create_node_with_parameter_overrides(self):\n+        node_name = 'create_node_with_parameter_overrides_test'\n+        rclpy.create_node(\n+            node_name, context=self.context,\n+            automatically_declare_parameters_from_overrides=True,\n+            parameter_overrides=[\n+                Parameter('use_sim_time', Parameter.Type.BOOL, True)\n+            ]\n+        ).destroy_node()\n+\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd mocking unit tests for rcl_yaml_param_parser (coverage part 3/3) (#772)\n\nDiff:\n-    target_link_libraries(test_parse ${PROJECT_NAME})\n+    target_link_libraries(test_parse ${PROJECT_NAME} mimick)\n-    target_link_libraries(test_parser ${PROJECT_NAME})\n+    target_link_libraries(test_parser ${PROJECT_NAME} mimick)\n+  <test_depend>mimick_vendor</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Original file taken from:\n+// https://github.com/ros2/rcutils/blob/master/test/mocking_utils/patch.hpp\n+\n+#ifndef MOCKING_UTILS__PATCH_HPP_\n+#define MOCKING_UTILS__PATCH_HPP_\n+\n... [truncated] ...\n+\n+  rcl_params_t * params_hdl = rcl_yaml_node_struct_init(allocator);\n+  ASSERT_NE(nullptr, params_hdl);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rcl_yaml_param_parser\", yaml_parser_initialize, false);\n+\n+  EXPECT_FALSE(rcl_parse_yaml_file(path, params_hdl));\n+\n+  constexpr char node_name[] = \"node name\";\n+  constexpr char param_name[] = \"param name\";\n+  constexpr char yaml_value[] = \"true\";\n+\n+  rcl_params_t * params_st = rcl_yaml_node_struct_init(allocator);\n+  ASSERT_NE(params_st, nullptr);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_st);\n+  });\n+  EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n+}\n+\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nDrop build dependency on std_msgs (#314)\n\nDiff:\n-find_package(std_msgs REQUIRED)\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nSet disable loan to on by default. (#1110)\n\nDiff:\n- * - disable_loaned_message = false, true only if ROS_DISABLE_LOANED_MESSAGES=1\n+ * - disable_loaned_message = true, false only if ROS_DISABLE_LOANED_MESSAGES=0\n+#include \"rcutils/env.h\"\n-  bool disable_loaned_message = false;\n-  rcl_ret_t ret = rcl_get_disable_loaned_message(&disable_loaned_message);\n-  if (ret == RCL_RET_OK) {\n-    default_options.disable_loaned_message = disable_loaned_message;\n-  } else {\n+  // TODO(clalancette): This is kind of a copy of rcl_get_disable_loaned_message(), but we need\n+  // more information than that function provides.\n+  default_options.disable_loaned_message = true;\n+\n+  const char * env_val = NULL;\n+  const char * env_error_str = rcutils_get_env(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR, &env_val);\n+  if (NULL != env_error_str) {\n-    RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n-    rcl_reset_error();\n-    default_options.disable_loaned_message = false;\n+    RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+      \"Error getting env var: '\" RCUTILS_STRINGIFY(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR) \"': %s\\n\",\n+      env_error_str);\n+  } else {\n+    default_options.disable_loaned_message = !(strcmp(env_val, \"0\") == 0);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+  }\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix data_available reset for timer (backport #215) (#217)\n\nDiff:\n-      if (wait_set->timers[handle->index]) {\n-        bool timer_is_ready = false;\n-        rc = rcl_timer_is_ready(handle->timer, &timer_is_ready);\n-        if (rc != RCL_RET_OK) {\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_is_ready);\n-          return rc;\n-        }\n-        // actually this is a unnecessary check: if wait_set.timers[i] is true, then also\n-        // rcl_timer_is_ready() should return true.\n-        if (timer_is_ready) {\n-          handle->data_available = true;\n-        } else {\n-          // this should never happen\n-          handle->data_available = false;\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_should_be_ready);\n-          return RCL_RET_ERROR;\n-        }\n-      }\n+      handle->data_available = (NULL != wait_set->timers[handle->index]);\n+// callback for timer\n+static unsigned int _cbt_cnt = 0;\n+    _cbt_cnt++;\n+TEST_F(TestDefaultExecutor, executor_spin_timer) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+  }\n+\n+  EXPECT_EQ(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd tests non-implemented functions + loan bad arguments (#122)\n\nDiff:\n+\n+class CLASSNAME (TestPublisherUseLoan, RMW_IMPLEMENTATION)\n+  : public CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION)\n+{\n+protected:\n+  using Base = CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION);\n+\n+  void SetUp() override\n+  {\n+    Base::SetUp();\n+    // Check if loaning is supported by the implementation\n+    if (!pub->can_loan_messages) {\n+      void * msg_pointer = nullptr;\n+      rmw_publisher_allocation_t * null_allocation{nullptr};\n+      rmw_ret_t ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, msg_pointer);\n+      ret = rmw_return_loaned_message_from_publisher(pub, &msg_pointer);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, msg_pointer);\n+      ret = rmw_publish_loaned_message(pub, &msg_pointer, null_allocation);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n... [truncated] ...\n+  rmw_reset_error();\n+  EXPECT_EQ(nullptr, msg_pointer);\n+\n+  ret = rmw_borrow_loaned_message(pub, ts, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  EXPECT_EQ(nullptr, msg_pointer);\n+\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  // Not null msg_pointer invalid to borrow message\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  ret = rmw_return_loaned_message_from_publisher(pub, msg_pointer);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  msg_pointer = nullptr;\n+  const char * implementation_identifier = pub->implementation_identifier;\n+  pub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  pub->implementation_identifier = implementation_identifier;\n+}\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nConvert Node and Context to use C++ Classes (#771)\n\nDiff:\n-  src/rclpy/_rclpy_action.cpp\n-  src/rclpy/init.cpp\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule,\n+                node.handle,\n-from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_client_names_and_types_by_node(\n-            node_capsule, remote_node_name, remote_node_namespace)\n+    with node.handle:\n+        return node.handle.get_action_client_names_and_types_by_node(\n+            remote_node_name, remote_node_namespace)\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_server_names_and_types_by_node(\n-            node_capsule, remote_node_name, remote_node_namespace)\n+    with node.handle:\n+        return node.handle.get_action_server_names_and_types_by_node(\n+            remote_node_name, remote_node_namespace)\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_names_and_types(node_capsule)\n+    with node.handle:\n+        return node.handle.get_action_names_and_types()\n-        with node.handle as node_capsule, node.get_clock().handle:\n+        with node.handle, node.get_clock().handle:\n... [truncated] ...\n+        msg_type=Empty,\n+        topic=topic_name,\n+        callback=lambda _: None,\n+        qos_profile=10,\n+    )\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptySrv, 'test_client', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptySrv, 'test_client', QoSProfile(depth=10).get_c_qos_profile())\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptySrv, 'test_server', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptySrv, 'test_server', QoSProfile(depth=10).get_c_qos_profile())\n-        with self._clock.handle, node.context.handle as context_capsule:\n+        with self._clock.handle, node.context.handle:\n-                self._clock.handle, context_capsule, period_nanoseconds)\n+                self._clock.handle, node.context.handle, period_nanoseconds)\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptyMsg, 'test_topic', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptyMsg, 'test_topic', QoSProfile(depth=10).get_c_qos_profile())\n-        with node.context.handle as context_capsule:\n-            self.guard_condition = _rclpy.GuardCondition(context_capsule)\n+        with node.context.handle:\n+            self.guard_condition = _rclpy.GuardCondition(node.context.handle)\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nRemove warning in depth_cloud_mld.cpp (#1021)\n\nDiff:\n-        *cloud_data_ptr = *reinterpret_cast<float *>(&color);\n+        float ret;\n+        std::memcpy(&ret, &color, sizeof(float));\n+        *cloud_data_ptr = ret;\n-        *cloud_data_ptr = *reinterpret_cast<float *>(&color);\n+        float ret;\n+        std::memcpy(&ret, &color, sizeof(float));\n+        *cloud_data_ptr = ret;\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nCorrect parameter names to match documentation (#250)\n\nDiff:\n-  bool demangle,\n+  bool no_demangle,\n-  bool demangle,\n+  bool no_demangle,\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate expectations of tests to remain compatible with non-DDS middlewares (#248)\n\nDiff:\n+  // For DDS-based middlewares, the QoS defined above might result in a mismatch while it might not\n+  // for other middlewares. Hence, we rely on rmw_qos_profile_check_compatible to infer whether\n+  // the publisher and subscription will match and accordingly evaluate match counts.\n+  rmw_qos_compatibility_type_t compat;\n+  rmw_ret_t rmw_ret =\n+    rmw_qos_profile_check_compatible(qos_profile, other_qos_profile, &compat, nullptr, 0);\n+  ASSERT_EQ(rmw_ret, RMW_RET_OK);\n+\n-  EXPECT_EQ(0u, subscription_count);\n+  if (compat == RMW_QOS_COMPATIBILITY_OK) {\n+    EXPECT_EQ(1u, subscription_count);\n+  } else {\n+    EXPECT_EQ(0u, subscription_count);\n+  }\n+  // For DDS-based middlewares, the QoS defined above might result in a mismatch while it might not\n+  // for other middlewares. Hence, we rely on rmw_qos_profile_check_compatible to infer whether\n+  // the publisher and subscription will match and accordingly evaluate match counts.\n+  rmw_qos_compatibility_type_t compat;\n+  rmw_ret_t rmw_ret =\n+    rmw_qos_profile_check_compatible(qos_profile, other_qos_profile, &compat, nullptr, 0);\n+  ASSERT_EQ(rmw_ret, RMW_RET_OK);\n+\n-  EXPECT_EQ(0u, publisher_count);\n+  if (compat == RMW_QOS_COMPATIBILITY_OK) {\n+    EXPECT_EQ(1u, publisher_count);\n+  } else {\n+    EXPECT_EQ(0u, publisher_count);\n+  }\n-    rmw_ret_t ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_LIVELINESS_CHANGED);\n+    rmw_ret_t ret = RMW_RET_OK;\n+    // rmw_zenoh does not support RMW_EVENT_LIVELINESS_CHANGED.\n+    // TODO(Yadunund): Rely on API suggested in https://github.com/ros2/rmw/issues/394 instead.\n+    if (std::string(rmw_get_implementation_identifier()).find(\"rmw_zenoh_cpp\") == 0) {\n+      ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_PUBLICATION_MATCHED);\n+    } else {\n+      ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_LIVELINESS_CHANGED);\n+    }\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nMake Axes display use latest transform (#892)\n\nDiff:\n-      frame, context_->getClock()->now(), position, orientation))\n+      frame, position, orientation))\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd test creating two content filter topics with the same topic name (#230) (#233)\n\nDiff:\n+\n+TEST_F(TestContentFilterSubscriptionUse, create_two_filters_with_same_topic_name_and_destroy) {\n+  if (sub->is_cft_enabled) {\n+    auto allocator = rcutils_get_default_allocator();\n+    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n+\n+    rmw_subscription_content_filter_options_t * content_filter_options =\n+      static_cast<rmw_subscription_content_filter_options_t *>(\n+      allocator.allocate(\n+        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      allocator.deallocate(content_filter_options, allocator.state);\n+    });\n+\n+    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters,\n+        &allocator,\n+        content_filter_options));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(content_filter_options, &allocator));\n+    });\n+\n+    options.content_filter_options = content_filter_options;\n+\n+    // Create another subscription with content filter in the same topic\n+    auto sub_2 = rmw_create_subscription(node, ts, topic_name, &qos_profile, &options);\n+    ASSERT_NE(nullptr, sub_2) << rmw_get_error_string().str;\n+\n+    rmw_ret_t ret = rmw_destroy_subscription(node, sub_2);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  }\n+}\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nClarify duration arg description in logging macros (#359)\n\nDiff:\n-    ('duration', 'The duration of the throttle interval'),\n+    ('duration', 'The duration of the throttle interval as an integral value in milliseconds.'),\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nGenerate version header with ament_generate_version_header function (#190)\n\nDiff:\n+ament_generate_version_header(${PROJECT_NAME})\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nYuv to rgb changes (#701)\n\nDiff:\n+  uint32_t stride_;\n+  std::shared_ptr<std::vector<uint8_t>> bufferptr_;\n+#include <memory>\n-  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n-    ImageData(image->encoding, image->data.data(), image->data.size()));\n-\n+  stride_ = image->step;\n+\n+  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n+    ImageData(image->encoding, image->data.data(), image->data.size()));\n+struct yuyv\n+{\n+  uint8_t y0;\n+  uint8_t u;\n+  uint8_t y1;\n+  uint8_t v;\n+};\n+\n+struct uyvy\n+{\n+  uint8_t u;\n+  uint8_t y0;\n+  uint8_t v;\n+  uint8_t y1;\n+};\n... [truncated] ...\n+  } else if ( // NOLINT enforces bracket on the same line, which makes code unreadable\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422 ||\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2)\n+  {\n+    size_t new_size = image_data.size_ * 3 / 2;\n+    if (!bufferptr_) {\n+      bufferptr_ = std::make_shared<std::vector<uint8_t>>(new_size);\n+    } else if (static_cast<size_t>(bufferptr_->size()) != new_size) {\n+      bufferptr_->resize(new_size, 0);\n+    }\n+\n+    if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422) {\n+      imageConvertYUV422ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    } else if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2) {\n+      imageConvertYUV422_YUY2ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    }\n+\n+\n+    image_data.pixel_format_ = Ogre::PF_BYTE_RGB;\n+    image_data.data_ptr_ = bufferptr_->data();\n+    image_data.size_ = new_size;\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate service/client request/response API error returns (#249)\n\nDiff:\n-  RET_NULL(taken);\n-  RET_NULL(ros_data);\n-  RET_NULL(request_header);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(taken, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_data, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n-  RET_NULL(client);\n-  RET_WRONG_IMPLID(client);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(service);\n-  RET_WRONG_IMPLID(service);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(service);\n-  RET_WRONG_IMPLID(service);\n-  RET_NULL(request_header);\n-  RET_NULL(ros_response);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n-  RET_NULL(client);\n-  RET_WRONG_IMPLID(client);\n-  RET_NULL(ros_request);\n-  RET_NULL(sequence_id);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_request, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(sequence_id, RMW_RET_INVALID_ARGUMENT);\n+\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nadd RCL_RET_TIMEOUT to action service response. (#1138)\n\nDiff:\n+ * \\return `RCL_RET_TIMEOUT` if a goal response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a result response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a cancel response reader is not ready yet, or\n-    return RCL_RET_ERROR;  /* error already set */ \\\n+    if (RCL_RET_TIMEOUT == ret) { \\\n+      return RCL_RET_TIMEOUT;  /* error already set */ \\\n+    } else { \\\n+      return RCL_RET_ERROR;  /* error already set */ \\\n+    } \\\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nInclude original exception in ComponentManagerException (#1157)\n\n* Include original exception in ComponentManagerException\r\n\r\nSigned-off-by: Martijn Buijs <martijn.buijs@gmail.com>\r\n\r\n* Update rclcpp_components/src/component_manager.cpp\r\n\r\nCo-authored-by: tomoya <Tomoya.Fujita@sony.com>\r\nSigned-off-by: Martijn Buijs <martijn.buijs@gmail.com>\r\n\r\nCo-authored-by: tomoya <Tomoya.Fujita@sony.com>\n\nDiff:\n+      } catch (const std::exception & ex) {\n+        // In the case that the component constructor throws an exception,\n+        // rethrow into the following catch block.\n+        throw ComponentManagerException(\n+                \"Component constructor threw an exception: \" + std::string(ex.what()));\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdded rmw_publisher_allocation and rmw_subscription_allocation related tests (#137)\n\nDiff:\n+    ament_add_gtest(test_publisher_allocator${target_suffix}\n+      test/test_publisher_allocator.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_publisher_allocator${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_publisher_allocator${target_suffix}\n+      rmw rmw_implementation\n+    )\n+    ament_add_gtest(test_subscription_allocator${target_suffix}\n+      test/test_subscription_allocator.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_subscription_allocator${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_subscription_allocator${target_suffix}\n+      rmw rmw_implementation\n+    )\n+\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n... [truncated] ...\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include <gtest/gtest.h>\n+\n+#include \"rmw/rmw.h\"\n+\n+#ifdef RMW_IMPLEMENTATION\n+# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n+# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n+#else\n+# define CLASSNAME(NAME, SUFFIX) NAME\n+#endif\n+\n+class CLASSNAME (TestSubscriptionAllocator, RMW_IMPLEMENTATION) : public ::testing::Test {};\n+\n+TEST_F(CLASSNAME(TestSubscriptionAllocator, RMW_IMPLEMENTATION), init_fini_subscription_allocation)\n+{\n+  if (rmw_init_subscription_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n+    // Add tests here when the implementation it's supported\n+    GTEST_SKIP();\n+  } else {\n+    rmw_ret_t ret = rmw_fini_subscription_allocation(nullptr);\n+    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n+  }\n+}\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix data race in EventHandlerBase (#2349)\n\nDiff:\n+  ~EventHandler()\n+  {\n+    // Since the rmw event listener holds a reference to the\n+    // \"on ready\" callback, we need to clear it on destruction of this class.\n+    // This clearing is not needed for other rclcpp entities like pub/subs, since\n+    // they do own the underlying rmw entities, which are destroyed\n+    // on their rclcpp destructors, thus no risk of dangling pointers.\n+    clear_on_ready_callback();\n+  }\n+\n-  // Since the rmw event listener holds a reference to\n-  // this callback, we need to clear it on destruction of this class.\n-  // This clearing is not needed for other rclcpp entities like pub/subs, since\n-  // they do own the underlying rmw entities, which are destroyed\n-  // on their rclcpp destructors, thus no risk of dangling pointers.\n-  clear_on_ready_callback();\n-\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd tests type_support module (#1308)\n\n* Add tests getters msg type support\r\n* Add missing fini\r\n* Add tests type_support services\r\n* Reformat to re use test structure\r\n* Remove not needed headers\r\n* Improve teardown test cases\r\n* Add nullptr checks to type_support tests\r\n* Reformat type_support testing\r\n* Replace expect tests with asserts\r\n* \"Improve error msg for rcl_service_ini/fini fail\"\r\n* Improve test readability\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n\nDiff:\n+ament_add_gtest(test_type_support rclcpp/test_type_support.cpp)\n+if(TARGET test_type_support)\n+  ament_target_dependencies(test_type_support\n+    \"rmw\"\n+    \"rosidl_runtime_cpp\"\n+    \"rosidl_typesupport_cpp\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_type_support ${PROJECT_NAME})\n+endif()\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\npublish action goal status once accepted before execution. (#1228)\n\nDiff:\n+        # Publish accepted status before execution\n+        self._handle.publish_status()\n+\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nRemoved unused var in tf2 (#735)\n\nDiff:\n-  std::stringstream mstream;\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nTestClient.test_service_timestamps failing consistently. (#1364)\n\nDiff:\n-                if result is not None:\n+                if result != (None, None):\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd cache_benchmark (#679)\n\nDiff:\n+  find_package(ament_cmake_google_benchmark REQUIRED)\n+  ament_add_google_benchmark(cache_benchmark test/cache_benchmark.cpp)\n+  if(TARGET cache_benchmark)\n+    target_link_libraries(cache_benchmark tf2)\n+  endif()\n+\n+  <test_depend>ament_cmake_google_benchmark</test_depend>\n+// Copyright 2024, Open Source Robotics Foundation, Inc. All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the Open Source Robotics Foundation, Inc. nor the\n+//      names of its contributors may be used to endorse or promote products\n+//      derived from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n... [truncated] ...\n+  // First, fill the cache with max storage amount (the limit).\n+  tf2::TimeCache fill_cache(max_storage_time);\n+  const auto [fill_timestamp, fill_timestep] = insert_data(\n+      fill_cache,\n+      tf2::TimePointZero,\n+      0,\n+      tf2::TimePointZero + max_storage_time);\n+\n+  // Now profile adding new data to the copied cache.\n+  const tf2::TimePoint target_timestamp = fill_timestamp + max_storage_time;\n+  for (auto _ : state) {\n+    // Don't profile construction (copying) of the cache.\n+    state.PauseTiming();\n+    tf2::TimeCache cache(fill_cache);\n+    state.ResumeTiming();\n+\n+    insert_data(\n+        cache,\n+        fill_timestamp,\n+        fill_timestep,\n+        target_timestamp);\n+  }\n+}\n+\n+BENCHMARK(benchmark_insertion);\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix tf2_geometry_msgs_INCLUDE_DIRS. (#729)\n\nDiff:\n+ament_export_include_directories(\"include/${PROJECT_NAME}\")\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUse unique mangled names when creating Content Filter Topics (#762)\n\nDiff:\n+#include <atomic>\n+#include <cstdint>\n-  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX;\n+  static std::atomic<uint32_t> cft_counter{0};\n+  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX + \"_\" +\n+    std::to_string(cft_counter.fetch_add(1));\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nChange syntax __VAR_ARGS__ to __VA_ARGS__ (#376)\n\nDiff:\n-#define my__has_feature(...) __has_feature(__VAR_ARGS__)\n+#define my__has_feature __has_feature\n-#define my__has_feature(...) 0\n+#define my__has_feature(x) 0\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nfix memory leak for remove_all(). (#201)\n\nDiff:\n+#include \"rcpputils/scope_exit.hpp\"\n+  if (dir == nullptr) {\n+    return false;\n+  }\n+  RCPPUTILS_SCOPE_EXIT(closedir(dir));\n-  closedir(dir);\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nfix topic stats test, wait for more messages, only check the ones with samples (#1274)\n\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\n\nDiff:\n-    2);\n+    4);\n-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());\n-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());\n+  bool any_samples = false;\n+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;\n+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";\n-    2);\n+    4);\n-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());\n-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());\n+  bool any_samples = false;\n+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;\n+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nReturn OK when finalizing zero-initialized contexts (#842)\n\nDiff:\n+ * A zero-initialized context that has not been initialized can be finalized.\n- * If context is zero-initialized, then `RCL_RET_INVALID_ARGUMENT` is returned.\n+ * If context is zero-initialized, then `RCL_RET_OK` is returned.\n-  RCL_CHECK_FOR_NULL_WITH_MSG(\n-    context->impl, \"context is zero-initialized\", return RCL_RET_INVALID_ARGUMENT);\n+  if (!context->impl) {\n+    // Context is zero-initialized\n+    return RCL_RET_OK;\n+  }\n+\n+  ret = rcl_context_fini(&context);\n+  EXPECT_EQ(RCL_RET_OK, ret);\n+\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUnit tests for some header-only functions/classes (#1181)\n\n* Unit tests for header-only functions/classes\r\n\r\nAdds coverage for:\r\n  * any_service_callback.hpp\r\n  * any_subscription_callback.hpp\r\n  * create_subscription.hpp\r\n  * create_timer.hpp\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n\nDiff:\n+ament_add_gtest(test_any_service_callback rclcpp/test_any_service_callback.cpp)\n+if(TARGET test_any_service_callback)\n+  ament_target_dependencies(test_any_service_callback\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_any_service_callback ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_any_subscription_callback rclcpp/test_any_subscription_callback.cpp)\n+if(TARGET test_any_subscription_callback)\n+  ament_target_dependencies(test_any_subscription_callback\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_any_subscription_callback ${PROJECT_NAME})\n+endif()\n+endif()\n+ament_add_gtest(test_create_subscription rclcpp/test_create_subscription.cpp)\n+if(TARGET test_create_subscription)\n+  target_link_libraries(test_create_subscription ${PROJECT_NAME})\n+  ament_target_dependencies(test_create_subscription\n+    \"test_msgs\"\n+  )\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\n[TimeCache] Improve performance for insertData() and pruneList() (#680)\n\nDiff:\n+  // In order to minimize the number of times we iterate over this data, we:\n+  // (1) Prune all old data first, regardless if new_data is added,\n+  // (2) We use find_if to scan from newest to oldest, and stop at the first\n+  //     point where the timestamp is equal or older to new_data's.\n+  // (3) From this point, we scan with more expensive full equality checks to\n+  //     ensure we do not reinsert the same exact data.\n+  // (4) If we the data is not duplicated, then we simply insert new_data at\n+  //     the point found in (2).\n+  // (1) Always prune data.\n+  pruneList();\n+\n-  // Find the oldest element in the list before the incoming stamp.\n-  auto last_transform_pos = std::find_if(\n-    storage_.begin(), storage_.end(), [&](const auto & transfrom) {\n-      return transfrom.stamp_ <= new_data.stamp_;\n+  // (2) Find the oldest element in the list before the incoming stamp.\n+  auto insertion_pos = std::find_if(\n+    storage_.begin(), storage_.end(), [&](const auto & transform) {\n+      return transform.stamp_ <= new_data.stamp_;\n-  // Insert elements only if not already present\n-  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n-    storage_.insert(last_transform_pos, new_data);\n+  bool should_insert = true;\n+\n+  // (3) Search along all data with same timestamp (sorted), and see if we have\n+  // an exact duplicate.\n+  auto maybe_same_pos = insertion_pos;\n+  while (maybe_same_pos != storage_.end() && maybe_same_pos->stamp_ == new_data.stamp_) {\n+    if (*maybe_same_pos == new_data) {\n+      should_insert = false;\n+      break;\n+    }\n+    maybe_same_pos++;\n+  }\n+\n+  // (4) Insert elements only if not already present\n+  if (should_insert) {\n+    storage_.insert(insertion_pos, new_data);\n-  pruneList();\n-  storage_.remove_if(\n-    [&](const auto & transform) {\n-      return transform.stamp_ < latest_time - max_storage_time_;\n-    });\n+  while (!storage_.empty() && storage_.back().stamp_ + max_storage_time_ < latest_time) {\n+    storage_.pop_back();\n+  }\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nRemove CODEOWNERS and mirror-rolling-to-master workflow. (#13)\n\nDiff:\n-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @quarkytale\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nMore Helpful Error Messages (#275)\n\nDiff:\n-                yaml_evaluated_value = yaml.safe_load(evaluated_value)\n-                if yaml_evaluated_value is None:\n-                    yaml_evaluated_value = ''\n+\n+                try:\n+                    yaml_evaluated_value = yaml.safe_load(evaluated_value)\n+                except yaml.YAMLError:\n+                    raise TypeError(\n+                        'Unable to parse the value of parameter {} as yaml. '\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(evaluated_name)\n+                    )\n+\n-                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'.format(\n-                            type(yaml_evaluated_value)\n-                        )\n+                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(type(yaml_evaluated_value))\n+from typing import List\n+from launch_ros.parameter_descriptions import ParameterValue\n+\n+    with pytest.raises(TypeError) as exc:\n... [truncated] ...\n+    orig = [{'foo': 1, 'fiz': ParameterValue(TextSubstitution(text='[]'), value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': '[]'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{\n+        'foo': 1,\n+        'fiz': ParameterValue([\n+            [TextSubstitution(text=\"['asd', 'bsd']\")],\n+            [TextSubstitution(text=\"['asd', 'csd']\")]\n+        ], value_type=List[str])\n+    }]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': [\"['asd', 'bsd']\", \"['asd', 'csd']\"]},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{'foo': 1,\n+             'fiz': ParameterValue(TextSubstitution(text='Text That : Cannot Be Parsed As : Yaml'),\n+                                   value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': 'Text That : Cannot Be Parsed As : Yaml'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nUpdate changelogs\n\nDiff:\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nmemmove for overlaping memory (#434)\n\nDiff:\n-    memcpy(dst_ptr, src_ptr, array_list->impl->data_size * copy_count);\n+    // If the size of the list is >1 the regions of memory overlap.\n+    // POSIX and C standards are explicit that employing memcpy() with overlapping\n+    // areas produces undefined behavior. The recomendation is to use memmove.\n+    // Reference: https://man7.org/linux/man-pages/man3/memcpy.3.html\n+    memmove(dst_ptr, src_ptr, array_list->impl->data_size * copy_count);\n+TEST_F(ArrayListPreInitTest, remove_success_removes_from_list_with_multiple_items) {\n+  uint32_t data = 22;\n+  size_t index = 0;\n+  size_t size = 0;\n+  rcutils_ret_t ret = RCUTILS_RET_OK;\n+\n+  // Add a few things first so we know the index isn't out of bounds\n+  for (size_t i = 0; i < 3; ++i) {\n+    ret = rcutils_array_list_add(&list, &data);\n+    ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  }\n+\n+  ret = rcutils_array_list_get_size(&list, &size);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  EXPECT_EQ(size, (size_t)3);\n+\n+  ret = rcutils_array_list_remove(&list, index);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  ret = rcutils_array_list_get_size(&list, &size);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  EXPECT_EQ(size, (size_t)2);\n+}\n+\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd rviz_rendering dependency to rviz_common (#727)\n\nDiff:\n-  rviz_rendering::rviz_rendering\n+  rviz_rendering\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAvoid generating the exception when rcl_send_response times out. (#1136)\n\nDiff:\n-    throw RCLError(\"failed to send response\");\n+    if (RCL_RET_TIMEOUT == ret) {\n+      // Warning should use line number of the current stack frame\n+      int stack_level = 1;\n+      PyErr_WarnFormat(\n+        PyExc_RuntimeWarning, stack_level, \"failed to send response (timeout): %s\",\n+        rcl_get_error_string().str);\n+      rcl_reset_error();\n+    } else {\n+      throw RCLError(\"failed to send response\");\n+    }\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nuse CMake config dirs as hint for header/library search (#56)\n\nDiff:\n-find_path(FastRTPS_INCLUDE_DIR\n-  NAMES fastrtps/)\n-\n+find_path(FastRTPS_INCLUDE_DIR\n+  NAMES fastrtps/\n+  HINTS \"${fastrtps_DIR}/../../../include\")\n+\n-  NAMES fastcdr-${fastcdr_MAJOR_MINOR_VERSION} fastcdr)\n+  NAMES fastcdr-${fastcdr_MAJOR_MINOR_VERSION} fastcdr\n+  HINTS \"${fastcdr_DIR}/../..\")\n-  NAMES fastcdrd-${fastcdr_MAJOR_MINOR_VERSION})\n+  NAMES fastcdrd-${fastcdr_MAJOR_MINOR_VERSION}\n+  HINTS \"${fastcdr_DIR}/../..\")\n-  NAMES fastrtps-${fastrtps_MAJOR_MINOR_VERSION} fastrtps)\n+  NAMES fastrtps-${fastrtps_MAJOR_MINOR_VERSION} fastrtps\n+  HINTS \"${fastrtps_DIR}/../../../lib\")\n-  NAMES fastrtpsd-${fastrtps_MAJOR_MINOR_VERSION})\n+  NAMES fastrtpsd-${fastrtps_MAJOR_MINOR_VERSION}\n+  HINTS \"${fastrtps_DIR}/../../../lib\")\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nCheck rcutils_strdup() outcome immediately. (#768)\n\nDiff:\n+\n+  if (!context->impl->init_options.impl->rmw_init_options.enclave) {\n+    RCL_SET_ERROR_MSG(\"failed to set context name\");\n+    fail_ret = RCL_RET_BAD_ALLOC;\n+    goto fail;\n+  }\n+\n-  if (!context->impl->init_options.impl->rmw_init_options.enclave) {\n-    RCL_SET_ERROR_MSG(\"failed to set context name\");\n-    fail_ret = RCL_RET_BAD_ALLOC;\n-    goto fail;\n-  }\n-\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nExpose VisualizationManager and YamlConfigReader to the public API (#649)\n\nDiff:\n+  include/rviz_common/visualization_manager.hpp\n-  src/rviz_common/visualization_manager.hpp\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"../visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./yaml_config_reader.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./yaml_config_reader.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"\n-#include \"../src/rviz_common/yaml_config_reader.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nuse only True to avoid confusion in autodoc config\n\nDiff:\n-    'members': None,\n-    'undoc-members': True,\n+    'members': True,  # document members\n+    'undoc-members': True,  # also document members without documentation\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nDrop PyKDL dependency in tf2_geometry_msgs (#509)\n\nDiff:\n-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# ament_python_install_package(${PROJECT_NAME}\n-#      PACKAGE_DIR src/${PROJECT_NAME})\n-\n-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# install(PROGRAMS scripts/test.py\n-#    DESTINATION lib/${PROJECT_NAME}\n-# )\n+ament_python_install_package(${PROJECT_NAME}\n+  PACKAGE_DIR src/${PROJECT_NAME})\n+  find_package(ament_cmake_pytest REQUIRED)\n+  ament_add_pytest_test(test_tf2_geometry_msgs_py test/test_tf2_geometry_msgs.py)\n+\n-  <!-- python support not yet ported\n-  <build_depend>python_orocos_kdl</build_depend>\n-\n-  <exec_depend>python_orocos_kdl</exec_depend>\n-  -->\n-\n+  <exec_depend>python3-numpy</exec_depend>\n+  <test_depend>ament_cmake_pytest</test_depend>\n+[pytest]\n+junit_family=xunit2\n-from geometry_msgs.msg import (PointStamped, PoseStamped,\n-                               PoseWithCovarianceStamped, Vector3Stamped)\n... [truncated] ...\n+    :param pose: The pose with covariance stamped\n+    :param transform: The transform\n+    :returns: The transformed pose with covariance stamped\n+    \"\"\"\n-    res.pose.pose.position.x = f.p[0]\n-    res.pose.pose.position.y = f.p[1]\n-    res.pose.pose.position.z = f.p[2]\n-    (res.pose.pose.orientation.x,\n-     res.pose.pose.orientation.y,\n-     res.pose.pose.orientation.z,\n-     res.pose.pose.orientation.w) = f.M.GetQuaternion()\n+    res.pose.pose = do_transform_pose(pose.pose.pose, transform)\n-#!/usr/bin/env python3\n-\n-        self.assertEqual(out.pose.covariance, v.pose.covariance)\n-        self.assertEqual(out.pose.orientation.x, 0)\n-        self.assertEqual(out.pose.orientation.y, 0)\n-        self.assertEqual(out.pose.orientation.z, 0)\n-        self.assertEqual(out.pose.orientation.w, 1)\n+        self.assertEqual(out.pose.pose.orientation.x, 0)\n+        self.assertEqual(out.pose.pose.orientation.y, 0)\n+        self.assertEqual(out.pose.pose.orientation.z, 0)\n+        self.assertEqual(out.pose.pose.orientation.w, 1)\n-    unittest.main()\n+  <exec_depend>sensor_msgs</exec_depend>\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd an option to publish TwistStamped (#42)\n\nDiff:\n+    test/publish_stamped_twist_joy_launch_test.py\n+The message type can be changed to `geometry_msgs/msg/TwistStamped` by the `publish_stamped_twist` parameter.\n-- `cmd_vel (geometry_msgs/msg/Twist)`\n+- `cmd_vel (geometry_msgs/msg/Twist or geometry_msgs/msg/TwistStamped)`\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+\n+- `frame (string, default: 'teleop_twist_joy')`\n+  - Frame name used for the header of TwistStamped messages.\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+    publish_stamped_twist = launch.substitutions.LaunchConfiguration('publish_stamped_twist')\n+        launch.actions.DeclareLaunchArgument('publish_stamped_twist', default_value='false'),\n-            name='teleop_twist_joy_node', parameters=[config_filepath],\n+            name='teleop_twist_joy_node',\n+            parameters=[config_filepath, {'publish_stamped_twist': publish_stamped_twist}],\n+#include <geometry_msgs/msg/twist_stamped.hpp>\n+  void fillCmdVelMsg(\n+    const sensor_msgs::msg::Joy::SharedPtr, const std::string & which_map,\n+    geometry_msgs::msg::Twist * cmd_vel_msg);\n+  rclcpp::Publisher<geometry_msgs::msg::TwistStamped>::SharedPtr cmd_vel_stamped_pub;\n+  rclcpp::Clock::SharedPtr clock;\n+  bool publish_stamped_twist;\n+  std::string frame_id;\n-  pimpl_->cmd_vel_pub = this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n... [truncated] ...\n+\n+    return launch.LaunchDescription([\n+            teleop_node,\n+            launch_testing.actions.ReadyToTest(),\n+        ]), locals()\n+\n+\n+class PublishTwistStamped(test_joy_twist.TestJoyTwist):\n+\n+    def setUp(self):\n+        self.cmd_vel_msg_type = geometry_msgs.msg.TwistStamped\n+        super().setUp()\n+        self.joy_msg['axes'] = [0.3, 0.4]\n+        self.joy_msg['buttons'] = [1]\n+        self.expect_cmd_vel['linear']['x'] = 0.8\n+        self.expect_cmd_vel['angular']['z'] = 0.9\n-        self.sub = self.node.create_subscription(geometry_msgs.msg.Twist,\n+        if not hasattr(self, \"cmd_vel_msg_type\"):\n+            self.cmd_vel_msg_type = geometry_msgs.msg.Twist\n+        self.sub = self.node.create_subscription(self.cmd_vel_msg_type,\n-        self.received_cmd_vel = msg\n+        if self.cmd_vel_msg_type is geometry_msgs.msg.Twist:\n+            self.received_cmd_vel = msg\n+        else:\n+            self.received_cmd_vel = msg.twist\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nEnsure compliant matched pub/sub count API. (#223)\n\nDiff:\n-  RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n+\n-  } else {\n-    *subscription_count = status.current_count;\n-    return RMW_RET_OK;\n+\n+  *subscription_count = status.current_count;\n+  return RMW_RET_OK;\n-  RET_NULL(subscription);\n-  RET_WRONG_IMPLID(subscription);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n+\n-  } else {\n-    *publisher_count = status.current_count;\n-    return RMW_RET_OK;\n+\n+  *publisher_count = status.current_count;\n+  return RMW_RET_OK;\n\nLabel:"}, {"role": "assistant", "content": "NonFunctional Enhancement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nrevert call shutdown in LifecycleNode destructor (#2557)\n\nDiff:\n-  auto current_state = LifecycleNode::get_current_state().id();\n-  // shutdown if necessary to avoid leaving the device in any other primary state\n-  if (current_state < lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    if (node_base_->get_context()->is_valid()) {\n-      auto ret = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n-      auto finalized = LifecycleNode::shutdown(ret);\n-      if (finalized.id() != lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED ||\n-        ret != rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS)\n-      {\n-        RCLCPP_WARN(\n-          rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-          \"Shutdown error in destruction of LifecycleNode: final state(%s)\",\n-          finalized.label().c_str());\n-      }\n-    } else {\n-      // TODO(fujitatomoya): consider when context is gracefully shutdown before.\n-      RCLCPP_DEBUG(\n-        rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-        \"Context invalid error in destruction of LifecycleNode: Node still in transition state(%u)\",\n-        current_state);\n-    }\n-  } else if (current_state > lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    RCLCPP_WARN(\n-      rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-      \"Shutdown error in destruction of LifecycleNode: Node still in transition state(%u)\",\n... [truncated] ...\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-\n-  // PRIMARY_STATE_FINALIZED to shutdown via dtor\n-  shutdown_cb_called = false;\n-  {\n-    auto ret = reset_key;\n-    auto test_node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\"testnode\");\n-    test_node->register_on_shutdown(std::bind(on_shutdown_callback, std::placeholders::_1));\n-    auto configured = test_node->configure(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(configured.id(), State::PRIMARY_STATE_INACTIVE);\n-    ret = reset_key;\n-    auto activated = test_node->activate(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(activated.id(), State::PRIMARY_STATE_ACTIVE);\n-    ret = reset_key;\n-    auto finalized = test_node->shutdown(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(finalized.id(), State::PRIMARY_STATE_FINALIZED);\n-    EXPECT_TRUE(shutdown_cb_called);  // should be called already\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-}\n-\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd time API coverage tests (#1347)\n\n* Change value used as max representation\r\n* Add coverage tests time\r\n* Add call to detach clock\r\n* Add tests time\r\n* Add duration construction tests\r\n* Add const qualifier to constants\r\n* Add check clock stays the same\r\n* Make operator RCLCPP_PUBLIC\r\n* Add tests exceptions duration\r\n* Fix division by 0 on windows\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n\nDiff:\n+RCLCPP_PUBLIC\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdded rmw_event_type_is_supported (#809)\n\nDiff:\n+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::__rmw_event_type_is_supported(rmw_event_type);\n+}\n+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::__rmw_event_type_is_supported(rmw_event_type);\n+}\n+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+bool\n+__rmw_event_type_is_supported(rmw_event_type_t rmw_event_type);\n+\n+bool\n+__rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::internal::is_event_supported(rmw_event_type);\n+}\n+\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nCheck if context is valid when looping in spin_some (#1167)\n\nSigned-off-by: Ivan Santiago Paunovic <ivanpauno@ekumenlabs.com>\n\nDiff:\n-  while (spinning.load() && max_duration_not_elapsed()) {\n+  while (rclcpp::ok(context_) && spinning.load() && max_duration_not_elapsed()) {\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nCorrect the license content (#979)\n\nDiff:\n-# limitations under the License.import time\n+# limitations under the License.\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix tests with get_type_description service and param present (#838)\n\nDiff:\n-            start_parameter_services=False)\n+            start_parameter_services=False,\n+            start_type_description_service=False)\n+        start_type_description_service = getattr(args, 'start_type_description_service', True)\n-                Parameter('use_sim_time', value=use_sim_time)\n+                Parameter('use_sim_time', value=use_sim_time),\n+                Parameter('start_type_description_service', value=start_type_description_service),\n+    '    start_type_description_service: true\\n'\n+                '  start_type_description_service',\n+    '    start_type_description_service: true\\n'\n-import re\n+    expected_builtin_services = {\n+        'describe_parameters': 'rcl_interfaces/srv/DescribeParameters',\n+        'get_parameter_types': 'rcl_interfaces/srv/GetParameterTypes',\n+        'get_parameters': 'rcl_interfaces/srv/GetParameters',\n+        'get_type_description': 'type_description_interfaces/srv/GetTypeDescription',\n+        'list_parameters': 'rcl_interfaces/srv/ListParameters',\n+        'set_parameters': 'rcl_interfaces/srv/SetParameters',\n+        'set_parameters_atomically': 'rcl_interfaces/srv/SetParametersAtomically',\n+    }\n+    builtin_service_count = len(expected_builtin_services)\n+    @classmethod\n+    def get_expected_builtin_services(cls, namespace: str, with_types: bool = False) -> list[str]:\n+        return [\n+            f'{namespace}/{srv_name}' + (f' [{srv_type}]' if with_types else '')\n+            for srv_name, srv_type in cls.expected_builtin_services.items()\n+        ]\n+\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/_hidden_echo_server/.*parameter.*'\n-                ), 6),\n+                self.get_expected_builtin_services('/my_ns/_hidden_echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                    r' \\[rcl_interfaces/srv/.*Parameter.*\\]'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server', with_types=True)\n-        assert int(output_lines[0]) == 7\n+        assert int(output_lines[0]) == self.builtin_service_count + 1\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdd test dependencies for rclc_parameter (#156)\n\nDiff:\n-  \n+  <test_depend>example_interfaces</test_depend>\n+  <test_depend>osrf_testing_tools_cpp</test_depend>\n+  <test_depend>std_msgs</test_depend>\n+\n\nLabel:"}, {"role": "assistant", "content": "Test"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nrcl_send_response returns RCL_RET_TIMEOUT. (#1048)\n\nDiff:\n+ * \\return #RCL_RET_TIMEOUT if a response reader is not ready yet, or\n+  rcl_ret_t ret;\n-  if (rmw_send_response(\n-      service->impl->rmw_handle, request_header, ros_response) != RMW_RET_OK)\n-  {\n+  ret = rmw_send_response(service->impl->rmw_handle, request_header, ros_response);\n+  if (ret != RMW_RET_OK) {\n+    if (ret == RMW_RET_TIMEOUT) {\n+      return RCL_RET_TIMEOUT;\n+    }\n-    rcl_ret_t ret = rcl_send_service_event_message(\n+    ret = rcl_send_service_event_message(\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nchangelogs\n\nDiff:\n+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+\n+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+\n\nLabel:"}, {"role": "assistant", "content": "Documentation"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nAdded rmw_event_type_is_supported (#173)\n\nDiff:\n+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_api_connextdds_event_type_is_supported(rmw_event_type);\n+}\n+\n+RMW_CONNEXTDDS_PUBLIC\n+bool\n+rmw_api_connextdds_event_type_is_supported(rmw_event_type_t rmw_event_type);\n+\n-\n-static bool is_event_supported(const rmw_event_type_t event_type)\n-{\n-  bool invalid = false;\n-  ros_event_to_dds(event_type, &invalid);\n-  return !invalid;\n-}\n-\n-\n-  if (!is_event_supported(event_type)) {\n+  if (!rmw_api_connextdds_event_type_is_supported(event_type)) {\n+bool\n+rmw_api_connextdds_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  bool invalid = false;\n+  ros_event_to_dds(rmw_event_type, &invalid);\n+  return !invalid;\n+}\n+\n+\n-  if (!is_event_supported(event_type)) {\n+  if (!rmw_api_connextdds_event_type_is_supported(event_type)) {\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_api_connextdds_event_type_is_supported(rmw_event_type);\n+}\n+\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nReorganize package\n\nDiff:\n-This project requires `rosidl_typesupport_gurumdds` to be built. For more information, see README.md of the [project](https://github.com/ros2/rosidl_typesupport_gurumdds).\n+| 3.2.0  or higher         | 2.8.3140 or higher          |\n-This project consists of four packages, `rmw_gurumdds_cpp`, `rmw_gurumdds_static_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+This project consists of four packages, `gurumdds_camke_module`, `rmw_gurumdds_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+\n+### gurumdds_cmake_module\n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+```\n+gurumdds\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 include\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcps.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcpsx.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 typesupport.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 xml.h\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n... [truncated] ...\n-      dds_DataReader_get_requested_incompatible_qos_status(topic_reader, &status);\n-    rmw_ret_t rmw_ret = check_dds_ret_code(dds_ret);\n-    if (rmw_ret != RMW_RET_OK) {\n-      return rmw_ret;\n-    }\n-\n-    auto rmw_status = static_cast<rmw_requested_qos_incompatible_event_status_t *>(event);\n-    rmw_status->total_count = status.total_count;\n-    rmw_status->total_count_change = status.total_count_change;\n-    rmw_status->last_policy_kind = convert_qos_policy(status.last_policy_id);\n-  } else {\n-    return RMW_RET_UNSUPPORTED;\n-  }\n-  return RMW_RET_OK;\n-}\n-\n-dds_StatusCondition * GurumddsSubscriberInfo::get_statuscondition()\n-{\n-  return dds_DataReader_get_statuscondition(topic_reader);\n-}\n-\n-dds_StatusMask GurumddsSubscriberInfo::get_status_changes()\n-{\n-  return dds_DataReader_get_status_changes(topic_reader);\n-}\n\nLabel:"}, {"role": "assistant", "content": "Functional Improvement"}]}
{"messages": [{"role": "system", "content": "You are a helpful commit classifier. Given a commit message and diff, classify it into one label."}, {"role": "user", "content": "Commit message:\nFix constantly increasing memory in std::list (#636)\n\nDiff:\n+\n+  ament_add_gtest(test_storage test/test_storage.cpp)\n+  if(TARGET test_storage)\n+    target_link_libraries(test_storage tf2)\n+  endif()\n+  TF2_PUBLIC\n+  bool operator==(const TransformStorage & rhs) const\n+  {\n+    return (this->rotation_ == rhs.rotation_) &&\n+           (this->translation_ == rhs.translation_) &&\n+           (this->stamp_ == rhs.stamp_) &&\n+           (this->frame_id_ == rhs.frame_id_) &&\n+           (this->child_frame_id_ == rhs.child_frame_id_);\n+  }\n+\n+  TF2_PUBLIC\n+  bool operator!=(const TransformStorage & rhs) const\n+  {\n+    return !(*this == rhs);\n+  }\n+\n+#include <algorithm>\n-  storage_.insert(storage_it, new_data);\n+  // Insert elements only if not already present\n+  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n... [truncated] ...\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // TimePoint stamp_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.stamp_ = tf2::TimePoint(tf2::durationFromSec(1.0));\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.frame_id_ = 55;\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID child_frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+}\n\nLabel:"}, {"role": "assistant", "content": "Bug Fix"}]}
