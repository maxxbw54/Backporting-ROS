[
  {
    "Repository": "rmw_fastrtps",
    "SHA": "a7be807c2945e3551f1dcc43f3fce886586256bd",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#520)",
    "Changes": "-`rmw_fastrtps_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw_fastrtps_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw_fastrtps_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rmw_fastrtps_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rmw_fastrtps_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw_fastrtps_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n-`rmw_fastrtps_dynamic_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw_fastrtps_dynamic_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw_fastrtps_dynamic_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rmw_fastrtps_dynamic_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-Check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+Check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-`rmw_fastrtps_dynamic_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw_fastrtps_dynamic_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n-`rmw_fastrtps_shared_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw_fastrtps_shared_cpp` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw_fastrtps_shared_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rmw_fastrtps_shared_cpp` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rmw_fastrtps_shared_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw_fastrtps_shared_cpp` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "630a91631b9c0875c3cee92aaec3e5b585d9ea46",
    "RawMessage": "Remove unused function make_mock_subscription (#809)",
    "Changes": "-def make_mock_subscription(namespace, topic_name, cli_args=None):\n-    node = Node('node_name', namespace=namespace, cli_args=cli_args)\n-    return node.create_subscription(\n-        msg_type=Empty,\n-        topic=topic_name,\n-        callback=lambda _: None,\n-        qos_profile=10,\n-    )\n-\n-",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "7719d6232d4bb489e5e081b909fb35ba60103cdc",
    "RawMessage": "Include required header Scalar.h (#559)",
    "Changes": "+#include \"Scalar.h\"\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "885ba70fc409f3c68d56a05150bc62865798a523",
    "RawMessage": "Do not use assume every RenderPanel has a ViewController. (#613)",
    "Changes": "-  Ogre::Ray mouse_ray = event.panel->getViewController()->getCamera()->getCameraToViewportRay(\n+  Ogre::Ray mouse_ray = viewport->getCamera()->getCameraToViewportRay(\n-  Ogre::Quaternion up_rot(rx, event.panel->getViewController()->getCamera()->getRealUp());\n-  Ogre::Quaternion right_rot(ry, event.panel->getViewController()->getCamera()->getRealRight());\n+  auto viewport =\n+    rviz_rendering::RenderWindowOgreAdapter::getOgreViewport(event.panel->getRenderWindow());\n+  Ogre::Quaternion up_rot(rx, viewport->getCamera()->getRealUp());\n+  Ogre::Quaternion right_rot(ry, viewport->getCamera()->getRealRight());\n-  Ogre::Quaternion rot(rx, event.panel->getViewController()->getCamera()->getRealDirection());\n+  auto viewport =\n+    rviz_rendering::RenderWindowOgreAdapter::getOgreViewport(event.panel->getRenderWindow());\n+  Ogre::Quaternion rot(rx, viewport->getCamera()->getRealDirection());\n+  auto viewport =\n+    rviz_rendering::RenderWindowOgreAdapter::getOgreViewport(event.panel->getRenderWindow());\n-    event.panel->getViewController()->getCamera()->getRealDirection(),\n+    viewport->getCamera()->getRealDirection(),",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "ca135ecfcfff971fd537b0ddb4ebdff3304afc51",
    "RawMessage": "Removed warning when building in release mode (#1057)",
    "Changes": "-  auto num_vertices = internals.rend->getBuffer()->getNumVertices();\n-  auto vertex_size =\n-    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n-\n-\n-    assert(\n-      reinterpret_cast<uint8_t *>(float_buffer) <=\n-      reinterpret_cast<uint8_t *>(float_buffer) + num_vertices * vertex_size);\n+#ifndef NDEBUG\n+  size_t num_vertices = internals.rend->getBuffer()->getNumVertices();\n+  size_t vertex_size =\n+    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n+  assert(\n+    reinterpret_cast<uint8_t *>(float_buffer) <=\n+    reinterpret_cast<uint8_t *>(internals.float_buffer) + num_vertices * vertex_size);\n+#endif\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional "
  },
  {
    "Repository": "rclc",
    "SHA": "49ca20cd968212aef28c2fe766d1e35e716ff715",
    "RawMessage": "Fix data_available reset for timer (backport #215) (#217)",
    "Changes": "-      if (wait_set->timers[handle->index]) {\n-        bool timer_is_ready = false;\n-        rc = rcl_timer_is_ready(handle->timer, &timer_is_ready);\n-        if (rc != RCL_RET_OK) {\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_is_ready);\n-          return rc;\n-        }\n-        // actually this is a unnecessary check: if wait_set.timers[i] is true, then also\n-        // rcl_timer_is_ready() should return true.\n-        if (timer_is_ready) {\n-          handle->data_available = true;\n-        } else {\n-          // this should never happen\n-          handle->data_available = false;\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_should_be_ready);\n-          return RCL_RET_ERROR;\n-        }\n-      }\n+      handle->data_available = (NULL != wait_set->timers[handle->index]);\n+// callback for timer\n+static unsigned int _cbt_cnt = 0;\n+    _cbt_cnt++;\n+TEST_F(TestDefaultExecutor, executor_spin_timer) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+  }\n+\n+  EXPECT_EQ(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "e791b58f8826a31d8ea11f45b7bf3026f26eab8a",
    "RawMessage": "Removed unused var in tf2 (#735)",
    "Changes": "-  std::stringstream mstream;",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "acf7f2542acd6ffcb59ce3ba75b0f5648d2cc910",
    "RawMessage": "Feature request: check for valid ros context in spin_some (#165)",
    "Changes": "+  if (!rcl_context_is_valid(executor->context)) {\n+    PRINT_RCLC_ERROR(rclc_executor_spin_some, rcl_context_not_valid);\n+    return RCL_RET_ERROR;\n+  }\n+\n-  while (rcl_context_is_valid(executor->context) ) {\n+  while (true) {\n-  while (rcl_context_is_valid(executor->context) ) {\n-    rclc_executor_spin_one_period(executor, period);\n+  rcl_ret_t ret;\n+  while (true) {\n+    ret = rclc_executor_spin_one_period(executor, period);\n+    if (!((ret == RCL_RET_OK) || (ret == RCL_RET_TIMEOUT))) {\n+      RCL_SET_ERROR_MSG(\"rclc_executor_spin_one_period error\");\n+      return ret;\n+    }\n-    // Optional prepare for avoiding allocations during spin\n-    rclc_executor_prepare(&executor);\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n-    rclc_executor_spin(&executor);\n+  rclc_executor_spin(&executor);\n-typedef struct {\n+typedef struct\n+{\n... [truncated] ...\n-    {300,\"baz counting from 300\"},\n+  sub_context_t my_contexts[] = {\n+    {0, \"foo counting from zero\"},\n+    {100, \"bar counting from 100\"},\n+    {300, \"baz counting from 300\"},\n-  for(unsigned int i=0; i<n_topics; i++){\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-    std_msgs__msg__String__init( &( pub_msgs[i] ) );\n+    std_msgs__msg__String__init(&( pub_msgs[i] ) );\n-    snprintf(pub_msgs[i].data.data, pub_msgs[i].data.capacity, \"Hello World! on %s\", topic_names[i]);\n+    snprintf(\n+      pub_msgs[i].data.data, pub_msgs[i].data.capacity, \"Hello World! on %s\",\n+      topic_names[i]);\n-    std_msgs__msg__String__init( &( sub_msgs[i] ) );\n+    std_msgs__msg__String__init(&( sub_msgs[i] ) );\n-  for(unsigned int i=0; i<n_topics; i++){\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-    void* context_void_ptr = (void*) context_ptr;\n+    void * context_void_ptr = (void *) context_ptr;\n-    for(unsigned int i=0;i<n_topics; i++) {\n+    for (unsigned int i = 0; i < n_topics; i++) {\n-  for(unsigned int i=0;i<n_topics; i++) {\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-  for(unsigned int i=0;i<n_topics; i++) {\n+  for (unsigned int i = 0; i < n_topics; i++) {",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "287e781937f42570d4c7a14ed24e201c528c20af",
    "RawMessage": "Free with the same allocator in rmw_destroy_node (#355)",
    "Changes": "-  rcutils_allocator_t allocator = context->options.allocator;\n-  allocator.deallocate(const_cast<char *>(node->name), allocator.state);\n-  allocator.deallocate(const_cast<char *>(node->namespace_), allocator.state);\n-  allocator.deallocate(node, allocator.state);\n+  rmw_free(const_cast<char *>(node->name));\n+  rmw_free(const_cast<char *>(node->namespace_));\n+  rmw_node_free(const_cast<rmw_node_t *>(node));",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "0b715cfc2f88be0edb10096a63c56c8b79e8e963",
    "RawMessage": "Integrate rmw_gurumdds_shared_cpp into rmw_gurumdds_cpp",
    "Changes": "-find_package(rmw_gurumdds_shared_cpp REQUIRED)\n+find_package(rmw_dds_common REQUIRED)\n+ament_export_include_directories(include ${GurumDDS_INCLUDE_DIR})\n+include_directories(${GurumDDS_INCLUDE_DIR})\n+link_directories(${GurumDDS_LIBRARY_DIRS})\n+  src/types/custom_listener.cpp\n+  src/demangle.cpp\n+  src/event_converter.cpp\n+  src/get_entities.cpp\n-  src/serialization_format.cpp\n+  src/names_and_types_helpers.cpp\n+  src/namespace_prefix.cpp\n+  src/qos.cpp\n+  src/rmw_features.cpp\n-  src/rmw_node.cpp\n+  src/rmw_node.cpp\n-  src/rmw_service.cpp\n+  src/rmw_service.cpp\n-  src/type_support_common.hpp\n+  src/serialization_format.cpp\n-  src/get_entities.cpp\n-  \"rmw_gurumdds_shared_cpp\"\n+  \"rmw_dds_common\"\n-\n-ament_export_include_directories(include)\n... [truncated] ...\n-\n-  if (wait_set_info->active_conditions != nullptr) {\n-    dds_ConditionSeq_delete(wait_set_info->active_conditions);\n-  }\n-\n-  if (wait_set_info->attached_conditions != nullptr) {\n-    dds_ConditionSeq_delete(wait_set_info->attached_conditions);\n-  }\n-\n-  if (wait_set_info->wait_set != nullptr) {\n-    dds_WaitSet_delete(wait_set_info->wait_set);\n-  }\n-\n-  wait_set_info = nullptr;\n-\n-  if (wait_set->data != nullptr) {\n-    rmw_free(wait_set->data);\n-  }\n-\n-  if (wait_set != nullptr) {\n-    rmw_wait_set_free(wait_set);\n-  }\n-\n-  return RMW_RET_OK;\n-}",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2d125a5105bbfc1d34de17dd70c29905e3ce9732",
    "RawMessage": "`WaitForTopics`: get content of messages for each topic (#353)",
    "Changes": "+from collectioEnhancementns import deque\n+            print(wait_for_topics.messages_received('topic_1')) # Should be [message_1, ...]\n-    def __init__(self, topic_tuples, timeout=5.0):\n+    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):\n+        self.messages_received_buffer_length = messages_received_buffer_length\n-        node_name = '_test_node_' +\\\n-            ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))\n-        self.__ros_node = _WaitForTopicsNode(name=node_name, node_context=self.__ros_context)\n+        node_name = '_test_node_' + ''.join(\n+            random.choices(string.ascii_uppercase + string.digits, k=10)\n+        )\n+        self.__ros_node = _WaitForTopicsNode(\n+            name=node_name,\n+            node_context=self.__ros_context,\n+            messages_received_buffer_length=self.messages_received_buffer_length,\n+        )\n+    def received_messages(self, topic_name):\n+        \"\"\"List of received messages of a specific topic.\"\"\"\n+        if topic_name not in self.__ros_node.received_messages_buffer:\n+            raise KeyError('No messages received for topic: ' + topic_name)\n+        return list(self.__ros_node.received_messages_buffer[topic_name])\n+\n-    def __init__(self, name='test_node', node_context=None):\n-        super().__init__(node_name=name, context=node_context)\n+    def __init__(\n... [truncated] ...\n+                        topic_name,\n+                        self.callback_template(topic_name),\n+                        10\n+                    )\n-            )\n-\n+            self.get_logger().debug('Message received for ' + topic_name)\n+            self.received_messages_buffer[topic_name].append(data)\n-                self.get_logger().debug('Message received for ' + topic_name)\n+import re\n+\n+\n+            message_pattern = re.compile(r'Hello World: \\d+')\n-            with WaitForTopics(topic_list, timeout=10.0) as wait_for_node_object_1:\n+            with WaitForTopics(\n+                topic_list, timeout=2.0, messages_received_buffer_length=10\n+            ) as wait_for_node_object_1:\n+                for topic_name, _ in topic_list:\n+                    assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                    message = wait_for_node_object_1.received_messages(topic_name).pop().data\n+                    assert message_pattern.match(message)\n+            for topic_name, _ in topic_list:\n+                assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                message = wait_for_node_object_2.received_messages(topic_name).pop().data\n+                assert message_pattern.match(message)",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "d07e00a9a5b32d6bd14d611bbd6c280602202dd5",
    "RawMessage": "Update rmw_fastrtps README to use Fast DDS",
    "Changes": "-`rmw_fastrtps_cpp` implements the ROS middleware interface using eProsima FastRTPS static code generation in C++.\n+`rmw_fastrtps_cpp` implements the ROS middleware interface using eProsima Fast DDS static code generation in C++.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d32d820b5cfbfb6eba5a02910f2dd68430a6ba12",
    "RawMessage": "make handles not inheritable to prevent from blocking durning tab-completion (#852)",
    "Changes": "+import os\n+import platform\n+    # During tab completion on the ros2 tooling, we can get here and attempt to spawn a daemon.\n+    # In that scenario, there may be open file descriptors that can prevent us from successfully\n+    # daemonizing, and instead cause the terminal to hang.  Here we mark all file handles except\n+    # for 0, 1, 2, and the server socket as non-inheritable, which will cause daemonize() to close\n+    # those file descriptors.  See https://github.com/ros2/ros2cli/issues/851 for more details.\n+    if platform.system() != 'Windows':\n+        import resource\n+        soft, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n+        for i in range(3, soft):\n+            try:\n+                if i != server.socket.fileno() and os.get_inheritable(i):\n+                    os.set_inheritable(i, False)\n+            except OSError:\n+                # Just in case the file handles might be [3(closed), ..., 8(pipe handle), ...]\n+                continue\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "87390606b218169ab07ca2f99c7c6480d6f8eed5",
    "RawMessage": "Fix executor behavior on shutdown (#574)",
    "Changes": "",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "f7b401ed5d950bb1c19df4417bf77c2ab12515e4",
    "RawMessage": "Return RMW_RET_UNSUPPORTED in rmw_get_serialized_message_size (#250)",
    "Changes": "-  return RMW_RET_ERROR;\n+  return RMW_RET_UNSUPPORTED;",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "eb8e3a6192383a71a6d2347b393998ae24ef97e9",
    "RawMessage": "Add fault injection macros and unit tests to rcl_lifecycle (#731)",
    "Changes": "+if(BUILD_TESTING AND NOT RCUTILS_DISABLE_FAULT_INJECTION)\n+  target_compile_definitions(${PROJECT_NAME} PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+endif()\n+\n+    target_compile_definitions(test_default_state_machine\n+      PUBLIC RCUTILS_ENABLE_FAULT_INJECTION\n+    )\n+    target_compile_definitions(test_rcl_lifecycle\n+      PUBLIC RCUTILS_ENABLE_FAULT_INJECTION\n+    )\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+\n+#include \"rcl/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n+\n+#include \"rcutils/testing/fault_injection.h\"\n+\n+TEST_F(TestDefaultStateMachine, init_fini_maybe_fail) {\n+  rcl_lifecycle_state_machine_t sm = rcl_lifecycle_get_zero_initialized_state_machine();\n+  RCUTILS_FAULT_INJECTION_TEST(\n... [truncated] ...\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(lifecycle_msgs, srv, ChangeState);\n+  const rosidl_service_type_support_t * gs =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(lifecycle_msgs, srv, GetState);\n+  const rosidl_service_type_support_t * gas =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(lifecycle_msgs, srv, GetAvailableStates);\n+  const rosidl_service_type_support_t * gat =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(lifecycle_msgs, srv, GetAvailableTransitions);\n+  const rosidl_service_type_support_t * gtg =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(lifecycle_msgs, srv, GetAvailableTransitions);\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    // Init segfaults if this is not zero initialized\n+    rcl_lifecycle_state_machine_t sm = rcl_lifecycle_get_zero_initialized_state_machine();\n+\n+    ret = rcl_lifecycle_state_machine_init(\n+      &sm, &node, pn, cs, gs, gas, gat, gtg, true, &allocator);\n+    if (RCL_RET_OK == ret) {\n+      ret = rcl_lifecycle_state_machine_fini(&sm, &node, &allocator);\n+      if (RCL_RET_OK != ret) {\n+        EXPECT_EQ(RCL_RET_OK, rcl_lifecycle_state_machine_fini(&sm, &node, &allocator));\n+      }\n+    }\n+  });\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "0cd63d0d19ef765e48a7cf53dbae675246859da6",
    "RawMessage": "Fixed camera default plusin crash (#999)",
    "Changes": "-  ogre_camera_node_->setPosition(vec);\n+  if (ogre_camera_node_ != nullptr) {\n+    ogre_camera_node_->setPosition(vec);\n+  }\n-  ogre_camera_node_->setOrientation(quat);\n+  if (ogre_camera_node_ != nullptr) {\n+    ogre_camera_node_->setOrientation(quat);\n+  }",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "c8ffbfd5713463b314c4b4ea825e139bd29e806d",
    "RawMessage": "Quiet a warning when CONNEXTDDS_DIR or NDDSHOME is not found. (#158)",
    "Changes": "-            message(WARNING \"no CONNEXTDDS_DIR nor NDDSHOME specified\")\n+            message(STATUS \"no CONNEXTDDS_DIR nor NDDSHOME specified\")",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "b4e3b9c4f6456b4cdf957296a1ad27c842bf91da",
    "RawMessage": "updated ros-tooling versions (#407)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.6.3\n+    - uses: ros-tooling/setup-ros@0.7.9\n-    - uses : ros-tooling/action-ros-ci@0.3.5\n+    - uses : ros-tooling/action-ros-ci@0.3.13\n-        void * /* context */) {};\n+      void * /* context */) {};\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclcpp",
    "SHA": "7bf52dd8a63c5202bc08ca31fef6496a6fbbf2cd",
    "RawMessage": "wait for message (#1705)",
    "Changes": "+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__WAIT_FOR_MESSAGE_HPP_\n+#define RCLCPP__WAIT_FOR_MESSAGE_HPP_\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/visibility_control.hpp\"\n+#include \"rclcpp/wait_set.hpp\"\n+\n+namespace rclcpp\n... [truncated] ...\n+  ASSERT_TRUE(received);\n+  EXPECT_EQ(out, *get_messages_strings()[0]);\n+\n+  rclcpp::shutdown();\n+}\n+\n+TEST(TestUtilities, wait_for_message_indefinitely) {\n+  rclcpp::init(0, nullptr);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"wait_for_message_node2\");\n+\n+  using MsgT = test_msgs::msg::Strings;\n+  MsgT out;\n+  auto received = false;\n+  auto wait = std::async(\n+    [&]() {\n+      auto ret = rclcpp::wait_for_message(out, node, \"wait_for_message_topic\" /*, -1 */);\n+      EXPECT_TRUE(ret);\n+      received = true;\n+    });\n+\n+  rclcpp::shutdown();\n+\n+  ASSERT_FALSE(received);\n+}",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "5204835dec4979dc0bb272d72d37cde03a849404",
    "RawMessage": "Check for message_info on take where appropriate. (#245)",
    "Changes": "-  RMW_CHECK_ARGUMENT_FOR_NULL(\n-    message_info, RMW_RET_INVALID_ARGUMENT);\n-\n+  RMW_CHECK_ARGUMENT_FOR_NULL(message_info, RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "5ea1a2a7f3c71fce724fedc6a4f60e2f5c2f1ead",
    "RawMessage": "resolved error in unit test see issue https://github.com/ros2/rclc/issues/230 (#231)",
    "Changes": "-  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);\n+  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);  // input value for context\n+  EXPECT_EQ(srv1_id, (unsigned int) 0);     // output value of context (in callback)\n-  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);  // check context value\n+  EXPECT_EQ(srv1_id, (unsigned int) 42);  // check context value in callback",
    "BackportedTo": "galactic",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "3b4ff9e46ad63ca08a1131760a86b0f42c2bba63",
    "RawMessage": "updating README: updated table of contents and adding missing examples. (#335)",
    "Changes": "-- [example_executor.c](src/example_executor.c) provides the example for the RCLC-Executor with the convenience functions from rclc. It creates one publisher and one subscriber and configures the RCLC-Executor accordingly.\n-- [example_executor_trigger.c](src/example_executor_trigger.c) demonstrates the trigger condition of the RCLC-Executor.\n-- [example_service_node.c](src/example_service_node.c) implements a service node with the RCLC-Executor.\n-- [example_client_node.c](src/example_client_node.c) implements a client node with RCLC-Executor.\n-- [example_executor_only_rcl.c](src/example_executor_only_rcl.c) provides the example for the RCLC-Executor. It creates one publisher and one subscriber and configures the RCLC-Executor using only the RCL API.\n-- [example_short_timer_long_subscription.c](src/example_short_timer_long_subscription.c) demo with high frequency timer and subscription with long processing time with one executor.\n+## Table of contents\n+\n+- [Minimal publisher-subscriber](#minimal-publisher-subscriber)\n+- [Minimal publisher-subscriber only with RCL-API](#minimal-publisher-subscriber-only-with-rcl-api)\n+- [RCLC-Executor with trigger function](#rclc-executor-with-trigger-function)\n+- [Service and client node](#service-and-client-node)\n+- [Action server and client](#action-server-and-client)\n+- [Lifecycle node](#lifecycle-node)\n+- [Parameter server](#parameter-server)\n+- [Subscription callback with C++ class method](#subscription-callback-with-c++-class-method)\n+- [Subscription with context](#subscription-with-context)\n+- [Real-time concurrency with slow timer and long subscription](#real-time-concurrency-with-slow-timer-and-long-subscription)\n+\n+## Minimal publisher-subscriber\n+The example [example_executor.c](src/example_executor.c) demonstrates basic features of the rclc package and the rclc-Executor to setup a publisher and a subscriber. This example uses also the convenience functions to configure rcl objects, like subscriptions, timers, etc. This saves in this case about 24% of lines of code compared the the same application with direct rcl-API, as described in the setup [Minimal publisher-subscriber only with RCL-API](#minimal-publisher-subscriber-only-with-rcl-api).\n-\n-The reduction of code lines for configuring the necessary RCL objects for RCLC-Executor directly with RCL objects compared to using the convenience functions is about 24%:\n-- example_executor.c: 92 LoC (lines 56-148)\n-- example_executor_convenience.c: 70 LoC (line 17 + lines 57-126)\n... [truncated] ...\n-\n-You should see the following output:\n-\n-```C\n-Created timer with timeout 1000 ms.\n-Created subscriber topic_0:\n-Debug: number of DDS handles: 2\n-Published message Hello World!\n-Callback: I heard: Hello World!\n-Published message Hello World!\n-Callback: I heard: Hello World!\n-Published message Hello World!\n-Callback: I heard: Hello World!\n-Published message Hello World!\n-Callback: I heard: Hello World!\n-Published message Hello World!\n-Callback: I heard: Hello World!\n-```\n-## Example real-time concurrency slow timer and long subscription\n-This example demonstrates what happens, if a high frequency timer (every 100ms) and\n-a subscription with a long processing time is managed by one executor. This demo shows,\n-that the timer events are dropped during the long processing time of the subscription and are also not caught-up when there would be sufficient time. \n+## Real-time concurrency with slow timer and long subscription\n+The example [example_short_timer_long_subscription.c](src/example_short_timer_long_subscription.c) demonstrates what happens, if a high frequency timer (every 100ms) and\n+a subscription with a long processing time is managed by one executor. This demo shows, that the timer events are dropped during the long processing time of the subscription and are also not caught-up when there would be sufficient time.",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "af784b2f70d649c45330dc321e6101d84d328ef7",
    "RawMessage": "fix: return text value to avoid exception (#338)",
    "Changes": "-                    return param[1]\n+                    return str(param[1])",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "7fb093ba17daa6fdacb22d383c1e90933b860de9",
    "RawMessage": "Remove `SHARED` (#1305)",
    "Changes": "-pybind11_add_module(_rclpy_pybind11 SHARED\n+pybind11_add_module(_rclpy_pybind11",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "2f3dbef1d3fde22c4cd433ac901085cf6b8e07d2",
    "RawMessage": "Added rmw_event_type_is_supported (#173)",
    "Changes": "+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_api_connextdds_event_type_is_supported(rmw_event_type);\n+}\n+\n+RMW_CONNEXTDDS_PUBLIC\n+bool\n+rmw_api_connextdds_event_type_is_supported(rmw_event_type_t rmw_event_type);\n+\n-\n-static bool is_event_supported(const rmw_event_type_t event_type)\n-{\n-  bool invalid = false;\n-  ros_event_to_dds(event_type, &invalid);\n-  return !invalid;\n-}\n-\n-\n-  if (!is_event_supported(event_type)) {\n+  if (!rmw_api_connextdds_event_type_is_supported(event_type)) {\n+bool\n+rmw_api_connextdds_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  bool invalid = false;\n+  ros_event_to_dds(rmw_event_type, &invalid);\n+  return !invalid;\n+}\n+\n+\n-  if (!is_event_supported(event_type)) {\n+  if (!rmw_api_connextdds_event_type_is_supported(event_type)) {\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_api_connextdds_event_type_is_supported(rmw_event_type);\n+}\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "4a890bccd471fff0e8ac939838cf104d4a64b9a8",
    "RawMessage": "updated QD section 3.i and 3ii and spelling error (#63)",
    "Changes": "-`rcl_logging_spdlog` does not have feature documentation.\n+`rcl_logging_spdlog` has a documented feature list and it is hosted [here](http://docs.ros2.org/latest/api/rcl_logging_spdlog/index.html).\n-`rcl_logging_spdlog` does not have public API documentation.\n+`rcl_logging_spdlog` has documentation of its public API and it is hosted [here](http://docs.ros2.org/latest/api/rcl_logging_spdlog/index.html).\n-`rcl_logging_spdlog` has a Direct Runtime non-ROS dependenciy the `spdlog` library. It was declared to be Quality Level 1 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).\n+`rcl_logging_spdlog` has a Direct Runtime non-ROS dependency on the `spdlog` library. It was declared to be Quality Level 1 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "b6f187aeae25975435a776de0017bf6c704cb591",
    "RawMessage": "More Helpful Error Messages (#275)",
    "Changes": "-                yaml_evaluated_value = yaml.safe_load(evaluated_value)\n-                if yaml_evaluated_value is None:\n-                    yaml_evaluated_value = ''\n+\n+                try:\n+                    yaml_evaluated_value = yaml.safe_load(evaluated_value)\n+                except yaml.YAMLError:\n+                    raise TypeError(\n+                        'Unable to parse the value of parameter {} as yaml. '\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(evaluated_name)\n+                    )\n+\n-                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'.format(\n-                            type(yaml_evaluated_value)\n-                        )\n+                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(type(yaml_evaluated_value))\n+from typing import List\n+from launch_ros.parameter_descriptions import ParameterValue\n+\n+    with pytest.raises(TypeError) as exc:\n... [truncated] ...\n+    orig = [{'foo': 1, 'fiz': ParameterValue(TextSubstitution(text='[]'), value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': '[]'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{\n+        'foo': 1,\n+        'fiz': ParameterValue([\n+            [TextSubstitution(text=\"['asd', 'bsd']\")],\n+            [TextSubstitution(text=\"['asd', 'csd']\")]\n+        ], value_type=List[str])\n+    }]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': [\"['asd', 'bsd']\", \"['asd', 'csd']\"]},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{'foo': 1,\n+             'fiz': ParameterValue(TextSubstitution(text='Text That : Cannot Be Parsed As : Yaml'),\n+                                   value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': 'Text That : Cannot Be Parsed As : Yaml'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "e791b58f8826a31d8ea11f45b7bf3026f26eab8a",
    "RawMessage": "Removed unused var in tf2 (#735)",
    "Changes": "-  std::stringstream mstream;",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "0898d191c14d7b84f438c445d4d92d586bd91225",
    "RawMessage": "Improve error message when create_topic fails (#405)",
    "Changes": "+void set_error_message_from_create_topic(dds_entity_t topic)\n+{\n+  assert(topic < 0);\n+  if (DDS_RETCODE_BAD_PARAMETER == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because the function was given\"\n+      \" invalid parameters\");\n+  } else if (DDS_RETCODE_INCONSISTENT_POLICY == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because it's already in use\"\n+      \" in this context with incompatible QoS settings\");\n+  } else if (DDS_RETCODE_PRECONDITION_NOT_MET == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because it's already in use\"\n+      \" in this context with a different message type\");\n+  } else {\n+    RMW_SET_ERROR_MSG(\"failed to create topic for unknown reasons\");\n+  }\n+}\n+\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(topic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(topic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(pubtopic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(subtopic);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "5339c3ed5441fc207980f4a8be8efd220c0bb2d8",
    "RawMessage": "Check rcutils_strdup() outcome immediately. (#768)",
    "Changes": "+\n+  if (!context->impl->init_options.impl->rmw_init_options.enclave) {\n+    RCL_SET_ERROR_MSG(\"failed to set context name\");\n+    fail_ret = RCL_RET_BAD_ALLOC;\n+    goto fail;\n+  }\n+\n-  if (!context->impl->init_options.impl->rmw_init_options.enclave) {\n-    RCL_SET_ERROR_MSG(\"failed to set context name\");\n-    fail_ret = RCL_RET_BAD_ALLOC;\n-    goto fail;\n-  }\n-",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "44e00ad1af2bcb2b8e36a4e6e7d38da7f827a299",
    "RawMessage": "Add maintainer",
    "Changes": "+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>\n+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>\n+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "3ca50ac6a983dc3cf6fa3690fa93890a7983d580",
    "RawMessage": "Expose VisualizationManager and YamlConfigReader to the public API (#649)",
    "Changes": "+  include/rviz_common/visualization_manager.hpp\n-  src/rviz_common/visualization_manager.hpp\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"../visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./yaml_config_reader.hpp\"\n-#include \"visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./visualization_manager.hpp\"\n+#include \"rviz_common/visualization_manager.hpp\"\n-#include \"./yaml_config_reader.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"\n-#include \"../src/rviz_common/yaml_config_reader.hpp\"\n+#include \"rviz_common/yaml_config_reader.hpp\"",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "9702e9250a8f83a106f7bb830609dd150dbb20d1",
    "RawMessage": "Bump the Quality Declaration for typesupport_fastrtps_c{pp,} to Level 3. (#48)",
    "Changes": "-The package `rosidl_typesupport_fastrtps_c` claims to be in the **Quality Level 4** category.\n+The package `rosidl_typesupport_fastrtps_c` claims to be in the **Quality Level 3** category.\n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Most recent test results can be found [here](http://ci.ros2.org/job/nightly_linux_release/lastBuild/testReport/rosidl_typesupport_fastrtps_c/copyright).\n+\n-Most recent test results can be found [here](http://build.ros2.org/view/Epr/job/Epr__rosidl_typesupport__ubuntu_bionic_amd64/lastBuild/testReport/rosidl_typesupport_fastrtps_c/)\n+Most recent test results can be found [here](http://ci.ros2.org/job/nightly_linux_release/lastBuild/testReport/rosidl_typesupport_fastrtps_c/copyright).\n-There are currently no public features undergoing tests.\n+Each feature in `rosidl_typesupport_fastrtps_c` has corresponding tests which simulate typical usage, and they are located in the [`test`](https://github.com/ros2/rosidl_typesupport_fastrtps/tree/master/rosidl_typesupport_fastrtps_c/test) directory.\n+New features are required to have tests before being added.\n+\n+Currently nightly test results can be seen here:\n+\n+* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rosidl_typesupport_fastrtps_c/)\n+* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rosidl_typesupport_fastrtps_c/)\n+* [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rosidl_typesupport_fastrtps_c/)\n+* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rosidl_typesupport_fastrtps_c/)\n-There are currently no tests for the public API.\n+Each part of the public API has tests, and new additions or changes to the public API require tests before being added.\n+The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n-`rosidl_typesupport_fastrtps_c` does not currently track test coverage.\n+`rosidl_typesupport_fastrtps_c` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+\n+This includes:\n... [truncated] ...\n-There are currently no tests for the public API.\n+Each part of the public API has tests, and new additions or changes to the public API require tests before being added.\n+The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n-`rosidl_typesupport_fastrtps_cpp` does not currently track test coverage.\n+`rosidl_typesupport_fastrtps_cpp` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+\n+This includes:\n+\n+- tracking and reporting line coverage statistics\n+- achieving and maintaining a reasonable branch line coverage (90-100%)\n+- no lines are manually skipped in coverage calculations\n+\n+Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n+\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rosidl_typesupport_fastrtps_rosidl_typesupport_fastrtps_cpp_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n-Results of the linting tests can be found [here](http://build.ros2.org/view/Epr/job/Epr__rosidl_typesupport__ubuntu_bionic_amd64/lastBuild/testReport/rosidl_typesupport_fastrtps_cpp/).\n+Results of the linting tests can be found [here](https://ci.ros2.org/job/nightly_linux_release/lastBuild/testReport/rosidl_typesupport_fastrtps_cpp/).\n+\n-* `rosidl_parser`\n-* `rosidl_typesupport_interface`\n+* `rosidl_typesupport_interface`: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_typesupport_interface/QUALITY_DECLARATION.md)\n-## Vulnerability Disclosure Policy [7.i]\n+## Security [7]\n+\n+### Vulnerability Disclosure Policy [7.i]",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "5eeae5b12e73b17f735ce62630b4ebf15c5f423e",
    "RawMessage": "Update Frame shortcut (#958)",
    "Changes": "+  /// Get the latest transform to the frame and update the scene node. Return true on success.\n+  bool updateFrame(const std::string & frame);\n+\n+  /// Get transform to the frame at the given time and update the scene node. True on success.\n+  bool updateFrame(const std::string & frame, rclcpp::Time time);\n+\n+\n+bool Display::updateFrame(const std::string & frame)\n+{\n+  return updateFrame(frame, rclcpp::Time(0, 0, context_->getClock()->get_clock_type()));\n+}\n+\n+bool Display::updateFrame(const std::string & frame, rclcpp::Time time)\n+{\n+  Ogre::Vector3 position;\n+  Ogre::Quaternion orientation;\n+  if (context_->getFrameManager()->getTransform(frame, time, position, orientation)) {\n+    scene_node_->setPosition(position);\n+    scene_node_->setOrientation(orientation);\n+    return true;\n+  }\n+  return false;\n+}\n+\n-  Ogre::Vector3 position;\n... [truncated] ...\n+  if (!updateFrame(header.frame_id, header.stamp)) {\n-  scene_node_->setPosition(position);\n-  scene_node_->setOrientation(orientation);\n-  Ogre::Quaternion orientation;\n-  Ogre::Vector3 position;\n-  if (!context_->getFrameManager()->getTransform(\n-      msg->header.frame_id, msg->header.stamp, position, orientation))\n-  {\n+  if (!updateFrame(msg->header.frame_id, msg->header.stamp)) {\n-  scene_node_->setPosition(position);\n-  scene_node_->setOrientation(orientation);\n-\n-  Ogre::Vector3 position;\n-  Ogre::Quaternion orientation;\n-  if (!context_->getFrameManager()->getTransform(msg->header, position, orientation)) {\n+  if (!updateFrame(msg->header.frame_id, msg->header.stamp)) {\n-  scene_node_->setPosition(position);\n-  scene_node_->setOrientation(orientation);\n-\n-  Ogre::Vector3 position;\n-  Ogre::Quaternion orientation;\n-  if (!context_->getFrameManager()->getTransform(header, position, orientation)) {\n+  if (!updateFrame(header.frame_id, header.stamp)) {\n-  scene_node_->setPosition(position);\n-  scene_node_->setOrientation(orientation);",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "92f78be1ba8ac9a00ae13659ffd06daad4e6d23e",
    "RawMessage": "Avoid deadlock if graph update fails. (#438)",
    "Changes": "+#include \"rmw_fastrtps_shared_cpp/publisher.hpp\"\n+  auto participant_info =\n+    static_cast<CustomParticipantInfo *>(node->context->impl->participant_info);\n+\n-    static_cast<CustomParticipantInfo *>(node->context->impl->participant_info),\n+    participant_info,\n-      rmw_ret = rmw_fastrtps_shared_cpp::__rmw_destroy_publisher(\n-        eprosima_fastrtps_identifier, node, publisher);\n+      rmw_ret = rmw_fastrtps_shared_cpp::destroy_publisher(\n+        eprosima_fastrtps_identifier, participant_info, publisher);\n+#include \"rmw_fastrtps_shared_cpp/subscription.hpp\"\n-      rmw_ret = rmw_fastrtps_shared_cpp::__rmw_destroy_subscription(\n-        eprosima_fastrtps_identifier, node, subscription);\n+      rmw_ret = rmw_fastrtps_shared_cpp::destroy_subscription(\n+        eprosima_fastrtps_identifier, participant_info, subscription);\n+#include \"rmw_fastrtps_shared_cpp/publisher.hpp\"\n-  auto impl = static_cast<CustomParticipantInfo *>(node->context->impl->participant_info);\n-\n+  auto participant_info =\n+    static_cast<CustomParticipantInfo *>(node->context->impl->participant_info);\n-    impl,\n+    participant_info,\n-      rmw_ret = rmw_fastrtps_shared_cpp::__rmw_destroy_publisher(\n-        eprosima_fastrtps_identifier, node, publisher);\n+      rmw_ret = rmw_fastrtps_shared_cpp::destroy_publisher(\n+        eprosima_fastrtps_identifier, participant_info, publisher);\n+#include \"rmw_fastrtps_shared_cpp/subscription.hpp\"\n-      rmw_ret = rmw_fastrtps_shared_cpp::__rmw_destroy_subscription(\n-        eprosima_fastrtps_identifier, node, subscription);\n+      rmw_ret = rmw_fastrtps_shared_cpp::destroy_subscription(\n+        eprosima_fastrtps_identifier, participant_info, subscription);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "238ab50fec7fd5aaab319fe5ad59de692b3b4b47",
    "RawMessage": "Fix function params indentation (#1426)",
    "Changes": "-            self,\n-            node: Node,\n-            remote_node_name: str,\n-            qos_profile: QoSProfile = qos_profile_services_default,\n-            callback_group: Optional[CallbackGroup] = None):\n+        self,\n+        node: Node,\n+        remote_node_name: str,\n+        qos_profile: QoSProfile = qos_profile_services_default,\n+        callback_group: Optional[CallbackGroup] = None,\n+    ) -> None:\n-            self, *,\n-            seconds: Union[int, float] = 0, nanoseconds: int = 0,\n-            clock_type: Union[ClockType, _rclpy.ClockType] = ClockType.SYSTEM_TIME):\n+        self, *,\n+        seconds: Union[int, float] = 0,\n+        nanoseconds: int = 0,\n+        clock_type: Union[ClockType, _rclpy.ClockType] = ClockType.SYSTEM_TIME,\n+    ) -> None:\n-            self, *,\n-            expected_call_time: int = 0,\n-            actual_call_time: int = 0,\n-            clock_type: Union[ClockType, _rclpy.ClockType] = ClockType.SYSTEM_TIME):\n+        self, *,\n+        expected_call_time: int = 0,\n+        actual_call_time: int = 0,\n+        clock_type: Union[ClockType, _rclpy.ClockType] = ClockType.SYSTEM_TIME,\n+    ) -> None:\n-    ):\n+    ) -> None:\n-    def __init__(self, timer: Timer, *, context: Context):\n+    def __init__(self, timer: Timer, *, context: Context) -> None:",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "dd7073f94d956baa044094e4c3a8acd811c4cecb",
    "RawMessage": "refactor #116 remove callback_type (#154) (#164)",
    "Changes": "-**rclc_executor_add_subscription(rclc_executor_t * executor, rcl_subscription_t * subscription, void * msg, rclc_callback_t callback, rclc_executor_handle_invocation_t invocation)**\n+**rclc_executor_add_subscription(rclc_executor_t * executor, rcl_subscription_t * subscription, void * msg, rclc_subscription_callback_t callback, rclc_executor_handle_invocation_t invocation)**\n-  rclc_callback_t callback,\n+  rclc_subscription_callback_t callback,\n+  SUBSCRIPTION_WITH_CONTEXT,\n+  // TIMER_WITH_CONTEXT,  // TODO\n+  CLIENT_WITH_REQUEST_ID,\n+  // CLIENT_WITH_CONTEXT,  // TODO\n+  SERVICE_WITH_REQUEST_ID,\n+  SERVICE_WITH_CONTEXT,\n+  // GUARD_CONDITION_WITH_CONTEXT,  //TODO\n-typedef enum\n-{\n-  CB_UNDEFINED,\n-  CB_WITHOUT_REQUEST_ID,\n-  CB_WITH_REQUEST_ID,\n-  CB_WITH_CONTEXT,\n-} rclc_executor_handle_callback_type_t;\n-\n-\n-/// Type definition for callback function.\n-typedef void (* rclc_callback_t)(const void *);\n-\n-// typedef void (* rclc_subscription_callback_t)(const void *);\n+typedef void (* rclc_subscription_callback_t)(const void *);\n... [truncated] ...\n+          // rclc_executor_handle_get_ptr returns null for unsupported types\n+          return false;\n+        }\n+        if (obj == handle_obj_ptr) {\n+          return true;\n-  handle->callback = NULL;\n+  handle->subscription_callback = NULL;\n-  handle->callback_type = CB_UNDEFINED;\n+    case SUBSCRIPTION_WITH_CONTEXT:\n+      // case TIMER_WITH_CONTEXT:\n+    case CLIENT_WITH_REQUEST_ID:\n+      // case CLIENT_WITH_CONTEXT:\n+    case SERVICE_WITH_REQUEST_ID:\n+    case SERVICE_WITH_CONTEXT:\n+      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case SUBSCRIPTION_WITH_CONTEXT:\n+      // case TIMER_WITH_CONTEXT:\n+    case CLIENT_WITH_REQUEST_ID:\n+      // case CLIENT_WITH_CONTEXT:\n+    case SERVICE_WITH_REQUEST_ID:\n+    case SERVICE_WITH_CONTEXT:\n+      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case NONE:\n-  EXPECT_EQ(handle.callback, nullptr);\n+  EXPECT_EQ(handle.subscription_callback, nullptr);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d864a364fc1fbcbe602cb73d5c33b2d1456025d1",
    "RawMessage": "bugfix for #563 (#570)",
    "Changes": "-import shlex\n-            args = shlex.split(os.environ['COMP_LINE'])[1:]\n+            from argcomplete import split_line\n+            _, _, _, comp_words, _ = split_line(os.environ['COMP_LINE'])\n+            args = comp_words[1:]",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "62e86b90ad3e67e84c660c11e894fe4ab9b11e41",
    "RawMessage": "Check if the queue is empty before using it",
    "Changes": "+  if (service_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+\n+  if (client_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "9a0c044ff08c89795fdfc66feb6cfe5fd3842f3a",
    "RawMessage": "Adjust topic hz and bw command description. (#987)",
    "Changes": "+        parser.description = (\n+            'Display bandwidth used by topic.\\n\\n'\n+            'note:\\n'\n+            '  This bandwidth reflects the receiving rate on subscription, '\n+            'which might be affected by platform resources and QoS configuration, '\n+            \"and may not exactly match the publisher's bandwidth.\"\n+        )\n-    \"\"\"Print the average publishing rate to screen.\"\"\"\n+    \"\"\"Print the average receiving rate to screen.\"\"\"\n+        parser.description = (\n+            'Print the average receiving rate to screen.\\n\\n'\n+            'note:\\n'\n+            '  This rate reflects the receiving rate on subscription, '\n+            'which might be affected by platform resources and QoS configuration, '\n+            \"and may not exactly match the publisher's rate.\"\n+        )",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "4d519753e8ca8fd016dbb429fee19a4c70d56588",
    "RawMessage": "Merge pull request #62 from ros2/feature/windows_port",
    "Changes": "",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "5e9c24df2ca33cd6eb1c423e68ed6892d1a5396b",
    "RawMessage": "Improve error checking and handling in subscription APIs. (#739)",
    "Changes": "+    subscription->impl = NULL;\n+    subscription->impl = NULL;\n-  // Set the sizes to zero to indicate that there are no valid messages\n-  message_sequence->size = 0u;\n-  message_info_sequence->size = 0u;\n-\n+  // Set the sizes to zero to indicate that there are no valid messages\n+  message_sequence->size = 0u;\n+  message_info_sequence->size = 0u;\n+\n+  RCL_CHECK_ARGUMENT_FOR_NULL(loaned_message, RCL_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "44ea8aed2ac657a17d5f7cc6b9bac66cb20c95af",
    "RawMessage": "Add tests for localhost-only node creation (#150)",
    "Changes": "+\n+class CLASSNAME (TestLocalhostNodeConstructionDestruction,\n+  RMW_IMPLEMENTATION) : public ::testing::Test\n+{\n+protected:\n+  void SetUp() override\n+  {\n+    options = rmw_get_zero_initialized_init_options();\n+    rmw_ret_t ret = rmw_init_options_init(&options, rcutils_get_default_allocator());\n+    ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+    options.enclave = rcutils_strdup(\"/\", rcutils_get_default_allocator());\n+    ASSERT_STREQ(\"/\", options.enclave);\n+    options.localhost_only = RMW_LOCALHOST_ONLY_ENABLED;\n+    context = rmw_get_zero_initialized_context();\n+    ret = rmw_init(&options, &context);\n+    ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  }\n+\n+  void TearDown() override\n+  {\n+    rmw_ret_t ret = rmw_shutdown(&context);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+    ret = rmw_context_fini(&context);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+    ret = rmw_init_options_fini(&options);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  }\n+\n+  rmw_init_options_t options;\n+  rmw_context_t context;\n+};\n+\n+TEST_F(\n+  CLASSNAME(\n+    TestLocalhostNodeConstructionDestruction,\n+    RMW_IMPLEMENTATION), create_and_destroy) {\n+  const char * const node_name = \"my_node\";\n+  const char * const node_namespace = \"/my_ns\";\n+  rmw_node_t * node = rmw_create_node(&context, node_name, node_namespace);\n+  ASSERT_NE(nullptr, node) << rmw_get_error_string().str;\n+  EXPECT_EQ(RMW_RET_OK, rmw_destroy_node(node)) << rmw_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "9157dc8d9fe2ed536a283ce69a614af09596ef96",
    "RawMessage": "Add tests non-implemented functions + loan bad arguments (#122)",
    "Changes": "+\n+class CLASSNAME (TestPublisherUseLoan, RMW_IMPLEMENTATION)\n+  : public CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION)\n+{\n+protected:\n+  using Base = CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION);\n+\n+  void SetUp() override\n+  {\n+    Base::SetUp();\n+    // Check if loaning is supported by the implementation\n+    if (!pub->can_loan_messages) {\n+      void * msg_pointer = nullptr;\n+      rmw_publisher_allocation_t * null_allocation{nullptr};\n+      rmw_ret_t ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, msg_pointer);\n+      ret = rmw_return_loaned_message_from_publisher(pub, &msg_pointer);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, msg_pointer);\n+      ret = rmw_publish_loaned_message(pub, &msg_pointer, null_allocation);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n... [truncated] ...\n+  rmw_reset_error();\n+  EXPECT_EQ(nullptr, msg_pointer);\n+\n+  ret = rmw_borrow_loaned_message(pub, ts, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  EXPECT_EQ(nullptr, msg_pointer);\n+\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  // Not null msg_pointer invalid to borrow message\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  ret = rmw_return_loaned_message_from_publisher(pub, msg_pointer);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  msg_pointer = nullptr;\n+  const char * implementation_identifier = pub->implementation_identifier;\n+  pub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_borrow_loaned_message(pub, ts, &msg_pointer);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  pub->implementation_identifier = implementation_identifier;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "eae50c9ed16c0b2fa4c7ca2c92bb8c30d5f6836f",
    "RawMessage": "fix expired goals capacity of action server (#931)",
    "Changes": "-    if (output_expired && i >= expired_goals_capacity) {\n+    if (output_expired && num_goals_expired >= expired_goals_capacity) {",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "e0252bdb7d86a01688d22d76cdbe6e3d960a6aec",
    "RawMessage": "added pingpong example (#172)",
    "Changes": "+\n+add_executable(example_pingpong src/example_pingpong.cpp)\n+ament_target_dependencies(example_pingpong rcl rclc std_msgs)\n+\n+  example_pingpong\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include<iostream>\n+#include<functional>\n+#include <stdio.h>\n+#include <std_msgs/msg/string.h>\n+#include <rclc/executor.h>\n+#include <rclc/rclc.h>\n... [truncated] ...\n+    printf(\"Callback: msg NULL\\n\");\n+  } else {\n+    printf(\"Callback: I heard: %s\\n\", msg->data.data);\n+  }\n+}\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include <rcl/rcl.h>\n+#include <rcl/error_handling.h>\n+#include <rclc/rclc.h>\n+#include <std_msgs/msg/string.h>\n+\n+void pong_subscription_callback_on_update(const void * msgin);",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "7bcc2939233dca1a04a3702807aac1f6a05014fc",
    "RawMessage": "Fix for incorrect integer value conversion on Windows (#1126)",
    "Changes": "-    ival = strtol(value, &endptr, 0);\n+    ival = strtoll(value, &endptr, 0);\n-      if ((NULL != endptr) && (endptr != value)) {\n+      if (endptr != value) {\n-      id: 11\n+      id: 992147483647\n-    EXPECT_EQ(11, *param_value->integer_value);\n+    // Make sure that we can correctly parse bigger than LONG_MAX = 2147483647 values\n+    EXPECT_EQ(992147483647, *param_value->integer_value);",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcpputils",
    "SHA": "ce44a14cce10132f0eff630e9ae016fbf296ac51",
    "RawMessage": "Add missing cstddef include (#147)",
    "Changes": "+#include <cstddef>",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "58dae834fcb65103e20aaa07795827d051e661d9",
    "RawMessage": "add RCL_RET_TIMEOUT to action service response. (#1138)",
    "Changes": "+ * \\return `RCL_RET_TIMEOUT` if a goal response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a result response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a cancel response reader is not ready yet, or\n-    return RCL_RET_ERROR;  /* error already set */ \\\n+    if (RCL_RET_TIMEOUT == ret) { \\\n+      return RCL_RET_TIMEOUT;  /* error already set */ \\\n+    } else { \\\n+      return RCL_RET_ERROR;  /* error already set */ \\\n+    } \\",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "d700d78611ca2f2a56128ee71dd157961a1f4fb4",
    "RawMessage": "[TimeCache] Improve performance for insertData() and pruneList() (#680)",
    "Changes": "+  // In order to minimize the number of times we iterate over this data, we:\n+  // (1) Prune all old data first, regardless if new_data is added,\n+  // (2) We use find_if to scan from newest to oldest, and stop at the first\n+  //     point where the timestamp is equal or older to new_data's.\n+  // (3) From this point, we scan with more expensive full equality checks to\n+  //     ensure we do not reinsert the same exact data.\n+  // (4) If we the data is not duplicated, then we simply insert new_data at\n+  //     the point found in (2).\n+  // (1) Always prune data.\n+  pruneList();\n+\n-  // Find the oldest element in the list before the incoming stamp.\n-  auto last_transform_pos = std::find_if(\n-    storage_.begin(), storage_.end(), [&](const auto & transfrom) {\n-      return transfrom.stamp_ <= new_data.stamp_;\n+  // (2) Find the oldest element in the list before the incoming stamp.\n+  auto insertion_pos = std::find_if(\n+    storage_.begin(), storage_.end(), [&](const auto & transform) {\n+      return transform.stamp_ <= new_data.stamp_;\n-  // Insert elements only if not already present\n-  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n-    storage_.insert(last_transform_pos, new_data);\n+  bool should_insert = true;\n+\n+  // (3) Search along all data with same timestamp (sorted), and see if we have\n+  // an exact duplicate.\n+  auto maybe_same_pos = insertion_pos;\n+  while (maybe_same_pos != storage_.end() && maybe_same_pos->stamp_ == new_data.stamp_) {\n+    if (*maybe_same_pos == new_data) {\n+      should_insert = false;\n+      break;\n+    }\n+    maybe_same_pos++;\n+  }\n+\n+  // (4) Insert elements only if not already present\n+  if (should_insert) {\n+    storage_.insert(insertion_pos, new_data);\n-  pruneList();\n-  storage_.remove_if(\n-    [&](const auto & transform) {\n-      return transform.stamp_ < latest_time - max_storage_time_;\n-    });\n+  while (!storage_.empty() && storage_.back().stamp_ + max_storage_time_ < latest_time) {\n+    storage_.pop_back();\n+  }",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "df5c8d0f0a697158a10ef57bd3b3074d168961a7",
    "RawMessage": "fix test_info_by_topic flaky. (#859)",
    "Changes": "-    SRCS rcl/test_info_by_topic.cpp\n+    SRCS rcl/test_info_by_topic.cpp rcl/wait_for_entity_helpers.cpp\n+#include \"wait_for_entity_helpers.hpp\"\n+  // Wait until GraphCache publishers are updated\n+  ASSERT_TRUE(wait_for_graph_publication(&this->node, fqdn.c_str(), 1u, 10, 100));\n+  // Wait until GraphCache subcribers are updated\n+  ASSERT_TRUE(wait_for_graph_subscription(&this->node, fqdn.c_str(), 1u, 10, 100));\n+  // Get subscribers info by topic\n+\n+bool\n+wait_for_graph_publication(\n+  const rcl_node_t * node,\n+  const char * topic_name,\n+  size_t count_to_wait,\n+  size_t max_tries,\n+  int64_t period_ms)\n+{\n+  if (count_to_wait == 0) {\n+    return true;  // Nothing to wait\n+  }\n+  size_t iteration = 0;\n+  while (iteration < max_tries) {\n+    ++iteration;\n+    size_t count;\n+    rcl_ret_t ret = rcl_count_publishers(node, topic_name, &count);\n... [truncated] ...\n+    }\n+    std::this_thread::sleep_for(std::chrono::milliseconds(period_ms));\n+  }\n+  return false;\n+}\n+/// Wait for specified number of publication in GraphCache\n+/// by trying at most `max_tries` times with a `period_ms` period.\n+bool\n+wait_for_graph_publication(\n+  const rcl_node_t * node,\n+  const char * topic_name,\n+  size_t count_to_wait,\n+  size_t max_tries,\n+  int64_t period_ms);\n+\n+/// Wait for specified number of subcription in GraphCache\n+/// by trying at most `max_tries` times with a `period_ms` period.\n+bool\n+wait_for_graph_subscription(\n+  const rcl_node_t * node,\n+  const char * topic_name,\n+  size_t count_to_wait,\n+  size_t max_tries,\n+  int64_t period_ms);\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "3bfcebddbaa3e6a3762c8b4f28b384e25c493a18",
    "RawMessage": "Fix byte indexing for depth patch pixels (#661)",
    "Changes": "+  // Assert that depth_pixel_box_ represents each depth pixel using 3 elements of type uint8_t,\n+  // and that the series of pixels in depth_pixel_box_.data is a contiguous array of sets of 3.\n+  // This ensures that the distance value at each pixel is composed using the correct indices.\n+  assert(Ogre::PF_R8G8B8 == depth_pixel_box_.format);\n+\n-    uint8_t a = data_ptr[4 * pixel];\n-    uint8_t b = data_ptr[4 * pixel + 1];\n-    uint8_t c = data_ptr[4 * pixel + 2];\n+    uint8_t a = data_ptr[3 * pixel];\n+    uint8_t b = data_ptr[3 * pixel + 1];\n+    uint8_t c = data_ptr[3 * pixel + 2];",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "de0e6d8f3cbe1ee85375a302de7fafd1baea9ee6",
    "RawMessage": "Updated spdlog QL in QD",
    "Changes": "-It is **Quality Level 3**, see its [Quality Declaration document](https://github.com/ros2/spdlog_vendor/blob/master/QUALITY_DECLARATION.md).\n+It is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/spdlog_vendor/blob/master/QUALITY_DECLARATION.md).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "243ee63ca369f0fb90397ba9ae0ca1283ab16ad3",
    "RawMessage": "Fix parameter change event (#310) (#311)",
    "Changes": "+  parameter->value.bool_value = value;\n+\n-  parameter->value.bool_value = value;\n-\n+  parameter->value.integer_value = value;\n+\n-  parameter->value.integer_value = value;\n-\n+  parameter->value.double_value = value;\n+\n-  parameter->value.double_value = value;\n-",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "2463c7ed500d66c446699b8b7f8536748fdcb669",
    "RawMessage": "Extend publisher API test coverage (#115)",
    "Changes": "+  find_package(test_msgs REQUIRED)\n+\n+    ament_add_gtest(test_publisher${target_suffix}\n+      test/test_publisher.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_publisher${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_publisher${target_suffix}\n+      rcutils rmw rmw_implementation test_msgs\n+    )\n+  <test_depend>test_msgs</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n... [truncated] ...\n+  const rosidl_message_type_support_t * ts{\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n+  const rmw_qos_profile_t * qos_profile{&rmw_qos_profile_default};\n+};\n+\n+TEST_F(CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION), get_actual_qos_with_bad_arguments) {\n+  rmw_qos_profile_t actual_qos_profile = rmw_qos_profile_unknown;\n+  rmw_ret_t ret = rmw_publisher_get_actual_qos(nullptr, &actual_qos_profile);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+\n+  ret = rmw_publisher_get_actual_qos(pub, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+}\n+\n+TEST_F(CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION), get_actual_qos) {\n+  rmw_qos_profile_t actual_qos_profile = rmw_qos_profile_unknown;\n+  rmw_ret_t ret = rmw_publisher_get_actual_qos(pub, &actual_qos_profile);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(rmw_qos_profile_default.history, actual_qos_profile.history);\n+  EXPECT_EQ(rmw_qos_profile_default.depth, actual_qos_profile.depth);\n+  EXPECT_EQ(rmw_qos_profile_default.reliability, actual_qos_profile.reliability);\n+  EXPECT_EQ(rmw_qos_profile_default.durability, actual_qos_profile.durability);\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "50411582ff6f72d1940a52070c26988dff65fee7",
    "RawMessage": "Skip QoS compatibility test on Zenoh (#985)",
    "Changes": "+        # skip zenoh because of the QoS compatibility\n+        if rmw_implementation == 'rmw_zenoh_cpp':\n+            raise unittest.SkipTest()\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "85c9c31592dcc52086b94bd16acb1aad4c0e0333",
    "RawMessage": "Updated rmw_* return codes (#246)",
    "Changes": "-  return RMW_RET_ERROR;\n+  return RMW_RET_UNSUPPORTED;\n-  return RMW_RET_ERROR;\n+  return RMW_RET_UNSUPPORTED;\n-  return RMW_RET_ERROR;\n+  return RMW_RET_UNSUPPORTED;\n-  return RMW_RET_ERROR;\n+  return RMW_RET_UNSUPPORTED;\n-  (void)context;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);\n-  RET_NULL(wait_set);\n+  RET_NULL_X(wait_set, return RMW_RET_INVALID_ARGUMENT);\n+  RET_WRONG_IMPLID(wait_set);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "20df68351e4602c11d5303495aeaaab87118895d",
    "RawMessage": "Change decode error mode to replace (#176)",
    "Changes": "-      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"strict\");\n+      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"replace\");\n-      \"strict\");\n+      \"replace\");",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "00e182217b3d0f668adb639923b6cc4e2ddfda59",
    "RawMessage": "Fix external docs mappings  (#757)",
    "Changes": "-    'http://docs.python.org/': None,\n-    'http://docs.opencv.org/3.0-last-rst/': None,\n-    'http://docs.scipy.org/doc/numpy': None\n+    'python': ('http://docs.python.org/3', None),\n+    'opencv': ('http://docs.opencv.org/3.0-last-rst', None),\n+    'numpy': ('http://docs.scipy.org/doc/numpy', None)\n-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.imgmath', 'sphinx_rtd_theme', 'breathe', 'exhale']\n+extensions = [\n+    'sphinx.ext.autodoc',\n+    'sphinx.ext.doctest',\n+    'sphinx.ext.intersphinx',\n+    'sphinx.ext.todo',\n+    'sphinx.ext.coverage',\n+    'sphinx.ext.mathjax',\n+    'sphinx.ext.ifconfig',\n+    'sphinx.ext.viewcode',\n+    'sphinx.ext.githubpages',\n+]\n+# List of patterns, relative to source directory, that match files and\n+# directories to ignore when looking for source files.\n+# This pattern also affects html_static_path and html_extra_path .\n+exclude_patterns = []\n+\n-project = u'tf'\n+project = u'tf2_ros'\n-    'http://docs.python.org/': None,\n-    'http://docs.opencv.org/3.0-last-rst/': None,\n-    'http://docs.scipy.org/doc/numpy': None\n+    'python': ('http://docs.python.org/3', None),\n+    'opencv': ('http://docs.opencv.org/3.0-last-rst', None),\n+    'numpy': ('http://docs.scipy.org/doc/numpy', None)\n-intersphinx_mapping = {'https://docs.python.org/': None}\n+intersphinx_mapping = {'python': ('https://docs.python.org/3', None)}",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "34d0fd6eb32f4415c52cbf3ffc2d82b64d274715",
    "RawMessage": "Redefine rmw gurumdds identifier",
    "Changes": "-extern const char * const gurum_gurumdds_identifier;\n+extern const char * const RMW_GURUMDDS_ID;\n-        gurum_gurumdds_identifier, RCUTILS_LOG_SEVERITY_DEBUG))\n+        RMW_GURUMDDS_ID, RCUTILS_LOG_SEVERITY_DEBUG))\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-      gurum_gurumdds_identifier,\n+      RMW_GURUMDDS_ID,\n-          gurum_gurumdds_identifier,\n+          RMW_GURUMDDS_ID,\n-      gurum_gurumdds_identifier,\n+      RMW_GURUMDDS_ID,\n-  if (node->implementation_identifier != gurum_gurumdds_identifier) {\n+  if (node->implementation_identifier != RMW_GURUMDDS_ID) {\n-  if (publisher->implementation_identifier != gurum_gurumdds_identifier) {\n... [truncated] ...\n-      \"rmw_gurumdds_cpp\", \"No data on topic %s\", topic_name);\n+      RMW_GURUMDDS_ID, \"No data on topic %s\", topic_name);\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n+    RMW_GURUMDDS_ID, \"Received data on topic %s\", topic_name);\n-          RCUTILS_LOG_WARN_NAMED(\"rmw_gurumdds_cpp\", \"Failed to get publication handle\");\n+          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n-    gurum_gurumdds_identifier, subscription,\n+    RMW_GURUMDDS_ID, subscription,\n-    gurum_gurumdds_identifier, subscription,\n+    RMW_GURUMDDS_ID, subscription,\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-  wait_set->implementation_identifier = gurum_gurumdds_identifier;\n+  wait_set->implementation_identifier = RMW_GURUMDDS_ID;\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-    gurum_gurumdds_identifier, subscriptions, guard_conditions,\n+    RMW_GURUMDDS_ID, subscriptions, guard_conditions,\n+#include \"rmw_gurumdds_cpp/identifier.hpp\"\n-    RCUTILS_LOG_DEBUG_NAMED(\"rmw_gurumdds_cpp\", \"no topics for participant_guid\");\n+    RCUTILS_LOG_DEBUG_NAMED(RMW_GURUMDDS_ID, \"no topics for participant_guid\");\n-    RCUTILS_LOG_DEBUG_NAMED(\"rmw_gurumdds_cpp\", \"no services for participant_guid\");\n+    RCUTILS_LOG_DEBUG_NAMED(RMW_GURUMDDS_ID, \"no services for participant_guid\");",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "11b584536d3b2d19dd281c329316727e7d761907",
    "RawMessage": "Use 10x the intraprocess delay to wait for sent requests. (#148)",
    "Changes": "+#include <chrono>\n+\n-  timeout.sec = 0;\n-  timeout.nsec = rmw_intraprocess_discovery_delay.count() * 1000;\n+  auto rmw_intraprocess_discovery_delay_in_nanoseconds =\n+    std::chrono::duration_cast<std::chrono::nanoseconds>(\n+    rmw_intraprocess_discovery_delay * 10).count();\n+  timeout.sec = rmw_intraprocess_discovery_delay_in_nanoseconds / 1000000000;\n+  timeout.nsec = rmw_intraprocess_discovery_delay_in_nanoseconds % 1000000000;",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "14c2c412522f34114c335d0d760a3f54c0cac656",
    "RawMessage": "rclc_executor: improve enum type names (#379)",
    "Changes": "-/* defines the semantics of data communication\n-   RCLCPP_EXECUTOR - same semantics as in the rclcpp Executor ROS2(Eloquent)\n-   LET             - logical execution time\n+/** Defines the semantics when data is taken from DDS\n+ *  SEMANTICS_RCLCPP_EXECUTOR        - same semantics as in rclcpp Executor. Data of a subscription\n+ *                                     is taken from DDS just before the corresponding callback\n+ *                                     is called by the Executor.\n+ *  SEMANTICS_LOGICAL_EXECUTION_TIME - logical execution time semantics. At one sampling point t\n+ *                                     new data of all ready subscriptions are taken from DDS.\n+ *                                     During (sequential) processing of these callbacks the\n+ *                                     data is used as per sampling point t. If new data arrived\n+ *                                     between the sampling point t and the time point at which\n+ *                                     the callback is called, it would not be considered in this\n+ *                                     `rclc_executor_spin_some` iteration.\n-  RCLCPP_EXECUTOR,\n-  LET\n+  RCLC_SEMANTICS_RCLCPP_EXECUTOR,\n+  RCLC_SEMANTICS_LOGICAL_EXECUTION_TIME\n+/**\n+ * Different types of Executors.\n+*/\n-  NONE,\n-  SINGLE_THREADED,\n-  MULTI_THREADED,\n-  NON_POSIX,\n+  RCLC_EXECUTOR_NOT_INITIALIZED,\n+  RCLC_EXECUTOR_SINGLE_THREADED,\n+  RCLC_EXECUTOR_MULTI_THREADED,\n+  RCLC_EXECUTOR_NON_POSIX,\n-  rclc_executor_set_semantics(executor, RCLCPP_EXECUTOR);\n+  rclc_executor_set_semantics(executor, RCLC_SEMANTICS_RCLCPP_EXECUTOR);\n-    case LET:\n+    case RCLC_SEMANTICS_LOGICAL_EXECUTION_TIME:\n-    case RCLCPP_EXECUTOR:\n+    case RCLC_SEMANTICS_RCLCPP_EXECUTOR:\n-  rclc_executor_set_semantics(&executor, RCLCPP_EXECUTOR);\n+  rclc_executor_set_semantics(&executor, RCLC_SEMANTICS_RCLCPP_EXECUTOR);",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "de026ed2bd70d4fa93855523c773a7cbb9701f8d",
    "RawMessage": "Added rmw_event_type_is_supported (#532)",
    "Changes": "+extern \"C\" bool rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return is_event_supported(rmw_event_type);\n+}\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "3db0cfa7e8a648277986035b8b40050372aa2def",
    "RawMessage": "Add bad_alloc return to topic_endpoint_info functions (#269)",
    "Changes": "+ * \\returns `RMW_RET_BAD_ALLOC` if allocation for string duplication fails, or\n+ * \\returns `RMW_RET_BAD_ALLOC` if allocation for string duplication fails, or\n+ * \\returns `RMW_RET_BAD_ALLOC` if allocation for string duplication fails, or\n+ * \\returns `RMW_RET_BAD_ALLOC` if allocation for string duplication fails, or\n+  if (NULL == *topic_endpoint_info_str) {\n+    return RMW_RET_BAD_ALLOC;\n+  }",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ed8deb81f8c33f351f8335dec3873707863824da",
    "RawMessage": "Fix struct array deserialization",
    "Changes": "-      for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n-        deserialize(\n-          reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n-            member->members_->data\n-          ),\n-          reinterpret_cast<uint8_t *>(\n-            member->get_function(output + member->offset_, j)\n-          )\n-        );\n-      }\n-    } else {\n-      void * tmp = output + member->offset_;\n-      for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n-        deserialize(\n-          reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n-            member->members_->data\n-          ),\n-          reinterpret_cast<uint8_t *>(\n-            member->get_function(&tmp, j)\n-          )\n-        );\n-      }\n+    }\n+    for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n+      deserialize(\n+        reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n+          member->members_->data\n+        ),\n+        reinterpret_cast<uint8_t *>(\n+          member->get_function(output + member->offset_, j)\n+        )\n+      );",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcutils",
    "SHA": "5bd1230eb10595cec30168667adf03f48879b96c",
    "RawMessage": "update cast to modern style (#418)",
    "Changes": "+// This is to avoid compilation warnings in C++ with '-Wold-style-cast'.\n+#ifdef __cplusplus\n+  #define RCUTILS_CAST_DURATION(x) (static_cast < rcutils_duration_value_t > (x))\n+#else\n+  #define RCUTILS_CAST_DURATION(x) ((rcutils_duration_value_t)x)\n+#endif\n+\n-    static rcutils_duration_value_t __rcutils_logging_duration = RCUTILS_MS_TO_NS((rcutils_duration_value_t)duration); \\\n+    static rcutils_duration_value_t __rcutils_logging_duration = RCUTILS_MS_TO_NS(RCUTILS_CAST_DURATION(duration)); \\",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "5c54f57ba409b1a096f9310a9b75d67731137b39",
    "RawMessage": "Make resource file paths relative (#862)",
    "Changes": "-      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff\n+      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff &&\n+      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/relocatable.patch\n+diff -uNr a/CMake/InstallResources.cmake b/CMake/InstallResources.cmake\n+--- a/CMake/InstallResources.cmake\t2022-05-09 17:30:13.273565553 -0700\n+@@ -59,6 +59,20 @@\n+   endif()\n+ endif()\n+ \n++# ensure installation is relocatable\n++if (IS_ABSOLUTE \"${OGRE_MEDIA_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_MEDIA_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_MEDIA_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_TEST_MEDIA_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_TEST_MEDIA_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_TEST_MEDIA_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_PLUGIN_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_PLUGIN_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_PLUGIN_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_SAMPLES_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_SAMPLES_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_SAMPLES_DIR_REL}\")\n++endif ()\n++\n+ # configure plugins.cfg\n+ if (NOT OGRE_BUILD_RENDERSYSTEM_D3D9)\n+   set(OGRE_COMMENT_RENDERSYSTEM_D3D9 \"#\")",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "2c4daff393c238d3f6142806a26e850faa75dc7d",
    "RawMessage": "Apply graph cache (#17)",
    "Changes": "+find_package(rcpputils REQUIRED)\n-  src/types/custom_listener.cpp\n-  src/rmw_request.cpp\n-  src/rmw_response.cpp\n+  src/rmw_context_impl.cpp\n+  src/context_listener_thread.cpp\n+  src/graph_cache.cpp\n+  \"rcpputils\"\n+  rcpputils\n+// Copyright 2022 GurumNetworks, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RMW_GURUMDDS_CPP__CONTEXT_LISTENER_THREAD_HPP_\n+#define RMW_GURUMDDS_CPP__CONTEXT_LISTENER_THREAD_HPP_\n... [truncated] ...\n-  std::lock_guard<std::mutex> lock(mutex_);\n-  const auto & map = topic_cache.get_topic_types_by_guid(participant_guid);\n-  if (map.size() == 0) {\n-    RCUTILS_LOG_DEBUG_NAMED(RMW_GURUMDDS_ID, \"no services for participant_guid\");\n-    return;\n-  }\n-\n-  for (auto & it : map) {\n-    std::string service_name = _demangle_service_from_topic(it.first);\n-    if (service_name.length() == 0) {\n-      continue;\n-    }\n-\n-    if (it.first.rfind(suffix) == std::string::npos) {\n-      continue;\n-    }\n-\n-    for (auto & itt : it.second) {\n-      std::string service_type = _demangle_service_type_only(itt);\n-      if (service_type.length()) {\n-        services[service_name].insert(service_type);\n-      }\n-    }\n-  }\n-}",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "ef60ec6c65e379edfefa8a474461412e19b85ee6",
    "RawMessage": "Add tests service/client request/response with bad arguments (#141)",
    "Changes": "+\n+TEST_F(CLASSNAME(TestClient, RMW_IMPLEMENTATION), send_request_with_bad_arguments) {\n+  constexpr char service_name[] = \"/test\";\n+  const rosidl_service_type_support_t * ts =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n+  test_msgs__srv__BasicTypes_Request client_request;\n+  ASSERT_TRUE(test_msgs__srv__BasicTypes_Request__init(&client_request));\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__srv__BasicTypes_Request__fini(&client_request);\n+  });\n+  client_request.bool_value = false;\n+  client_request.uint8_value = 1;\n+  client_request.uint32_value = 2;\n+  int64_t sequence_number;\n+  rmw_client_t * client =\n+    rmw_create_client(node, ts, service_name, &rmw_qos_profile_default);\n+  ASSERT_NE(nullptr, client) << rmw_get_error_string().str;\n+\n+  rmw_ret_t ret = rmw_send_request(nullptr, &client_request, &sequence_number);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+\n+  ret = rmw_send_request(client, nullptr, &sequence_number);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n... [truncated] ...\n+\n+  bool taken = false;\n+  ret = rmw_take_request(srv, &header, &request, &taken);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  ASSERT_EQ(true, taken);\n+\n+  ret = rmw_send_response(nullptr, &header.request_id, &service_response);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+\n+  ret = rmw_send_response(srv, nullptr, &service_response);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+\n+  ret = rmw_send_response(srv, &header.request_id, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+\n+  const char * implementation_identifier = srv->implementation_identifier;\n+  srv->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_send_response(srv, &header.request_id, &service_response);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  srv->implementation_identifier = implementation_identifier;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "79a2df204ff8f745539d842cf669fadd1dd4ca7e",
    "RawMessage": "Fix rclc lifecyle header (#279) (#281)",
    "Changes": "+#if __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#if __cplusplus\n+}\n+#endif\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "8edb67482dbd96dbdb2919858bdd0dcce4d22bfb",
    "RawMessage": "add test to ensure binary STL files from SOLIDWORKS get imported without a warning (#917)",
    "Changes": "-  if (buffer_str.substr(0, 5) == std::string(\"solid\")) {\n-    // file says that it is ascii, but why should we trust it?\n-\n-    // check for \"endsolid\" as well\n-    if (buffer_str.find(\"endsolid\", 5) != std::string::npos) {\n-      RVIZ_RENDERING_LOG_ERROR_STREAM(\n-        \"The STL file '\" << origin << \"' is malformed. It \"\n-          \"starts with the word 'solid' and also contains the \"\n-          \"word 'endsolid', indicating that it's an ASCII STL \"\n-          \"file, but rviz can only load binary STL files so it \"\n-          \"will not be loaded. Please convert it to a \"\n-          \"binary STL file.\");\n-      return false;\n-    }\n-\n-    // chastise the user for malformed files\n-    RVIZ_RENDERING_LOG_WARNING_STREAM(\n-      \"The STL file '\" << origin << \"' is malformed. It starts \"\n-        \"with the word 'solid', indicating that it's an ASCII \"\n-        \"STL file, but it does not contain the word 'endsolid' so \"\n-        \"it is either a malformed ASCII STL file or it is actually \"\n-        \"a binary STL file. Trying to interpret it as a binary \"\n-        \"STL file instead.\");\n+  if (buffer_str.substr(0, 5) == std::string(\"solid\") &&\n+    buffer_str.find(\"endsolid\", 5) != std::string::npos)\n+  {\n+    RVIZ_RENDERING_LOG_ERROR_STREAM(\n+      \"The STL file '\" << origin << \"' is malformed. It \"\n+        \"starts with the word 'solid' and also contains the \"\n+        \"word 'endsolid', indicating that it's an ASCII STL \"\n+        \"file, but rviz can only load binary STL files so it \"\n+        \"will not be loaded. Please convert it to a \"\n+        \"binary STL file.\");\n+    return false;\n+\n+TEST_F(MeshLoaderTestFixture, loading_solidworks_binary_stl) {\n+  // In general, binary STL files should not start with \"solid\" as this hints ASCII STL files.\n+  // Annoyingly, STL files exported from Solidworks don't follow this guideline and contain\n+  // \"solid\" at the start of binary STL files.\n+  // However, they don't finish with \"endsolid\" like ASCII STL files, so we can still detect\n+  // them as binary STL files.\n+  // This test checks that SOLIDWORKS binary STL files get loaded correctly and don't get treated\n+  // as ASCII STL files.\n+  std::string mesh_path = \"package://rviz_rendering_tests/test_meshes/solidworks.stl\";\n+\n+  ASSERT_TRUE(rviz_rendering::loadMeshFromResource(mesh_path));\n+}",
    "BackportedTo": "galactic",
    "Label": "Test"
  },
  {
    "Repository": "rclpy",
    "SHA": "78f5e14cdabeb047ab39829caef7a4872f3179ff",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#1382)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz @adityapande-1995",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "e12ff1a1be8ded9623ff770a1f4f9e4b51ca8f53",
    "RawMessage": "Add default subscriber profile (#663)",
    "Changes": "+            <!-- Default subscriber profile -->\n+            <subscriber profile_name=\"default subscriber profile\" is_default_profile=\"true\">\n+                <historyMemoryPolicy>PREALLOCATED_WITH_REALLOC</historyMemoryPolicy>\n+            </subscriber>\n+",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "d5b274fae5829ad43b12abbbb1f29f773fa6a6ce",
    "RawMessage": "Fixed screw display (#1093)",
    "Changes": "-  float linear_scale = linear_scale_property_->getFloat();\n-  float angular_scale = angular_scale_property_->getFloat();\n-  float width = width_property_->getFloat();\n-  visual->setLinearScale(linear_scale);\n-  visual->setAngularScale(angular_scale);\n-  visual->setWidth(width);\n-  visual->setScrew(\n-    Ogre::Vector3(linear.x, linear.y, linear.z),\n-    Ogre::Vector3(angular.x, angular.y, angular.z));\n+  visual->setLinearScale(linear_scale_property_->getFloat());\n+  visual->setAngularScale(angular_scale_property_->getFloat());\n+  visual->setWidth(width_property_->getFloat());\n+  visual->setHideSmallValues(hide_small_values_property_->getBool());",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "47346ef9688039b890ae19c499d4b51587a7305b",
    "RawMessage": "Fixes spin_until_future_complete inside callback (#1316)",
    "Changes": "+    node_added = False\n-        executor.add_node(node)\n+        node_added = executor.add_node(node)\n-        executor.remove_node(node)\n+        if node_added:\n+            executor.remove_node(node)",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "388002a9f235ef5ede0fb76b9fb751d6af0b305f",
    "RawMessage": "Only add one done callback to a future (#816)",
    "Changes": "+        # Make sure the future wakes this executor when it is done\n+        future.add_done_callback(lambda x: self.wake())\n+\n-        future.add_done_callback(lambda x: self.wake())",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "954a2110ec271b606f6acaf6d1d72cd2e2ae05ff",
    "RawMessage": "Fix normalize_parameters_dict for multiple nodes in the same namespace (#347)",
    "Changes": "-                # Reset keys in case there are multiple ros__parameter entries\n-                keys = []\n+                # Clean-up keys for the case of multiple nodes/ros__parameter entries\n+                keys.pop()\n+/ns_1:\n+  /node_1:\n+    ros__parameters:\n+      param_1: 11\n+      param_2: 22\n+  node_2:\n+    ros__parameters:\n+      param_3: 33\n+      param_4: 44\n-    # Case 7: node name not found\n+    # Case 7: multiple nodes in one namespace\n+    context = _assert_launch_no_errors([\n+        LoadComposableNodes(  # Load in same action so it happens sequentially\n+            target_container=f'/{TEST_CONTAINER_NAME}',\n+            composable_node_descriptions=[\n+                ComposableNode(\n+                    package='foo_package',\n+                    plugin='bar_plugin',\n+                    name='node_1',\n+                    namespace='ns_1',\n+                    parameters=[\n... [truncated] ...\n+                )\n+            ]\n+        )\n+    ])\n+    request = mock_component_container.requests[-2]\n+    assert get_node_name_count(context, '/ns_1/node_1') == 1\n+    assert request.node_name == 'node_1'\n+    assert request.node_namespace == '/ns_1'\n+    assert len(request.parameters) == 2\n+    assert request.parameters[0].name == 'param_1'\n+    assert request.parameters[0].value.integer_value == 11\n+    assert request.parameters[1].name == 'param_2'\n+    assert request.parameters[1].value.integer_value == 22\n+\n+    request = mock_component_container.requests[-1]\n+    assert get_node_name_count(context, '/ns_1/node_2') == 1\n+    assert request.node_name == 'node_2'\n+    assert request.node_namespace == '/ns_1'\n+    assert len(request.parameters) == 2\n+    assert request.parameters[0].name == 'param_3'\n+    assert request.parameters[0].value.integer_value == 33\n+    assert request.parameters[1].name == 'param_4'\n+    assert request.parameters[1].value.integer_value == 44\n+\n+    # Case 8: node name not found",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "678f2c6030ace92e32c8d25c208559fe67737ba8",
    "RawMessage": "Check that rmw_init() fails if no enclave is given. (#113)",
    "Changes": "+#include \"rcutils/strdup.h\"\n+    options.enclave = rcutils_strdup(\"/\", rcutils_get_default_allocator());\n+    ASSERT_STREQ(\"/\", options.enclave);\n+  char * enclave = options.enclave;\n+  options.enclave = nullptr;\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_init(&options, &context));\n+  options.enclave = enclave;\n+  rcutils_reset_error();\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "dbe513d52e077048065692fa520fa58c492513b8",
    "RawMessage": "fix typo",
    "Changes": "-    dds_InstanceHandleSeq_delete(sub_seq);\n+    dds_InstanceHandleSeq_delete(pub_seq);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "bed714f5c95c06885098989b4107421dc0b60b2a",
    "RawMessage": "Avoid exception in Node constructor when use override for 'use_sim_time' (#896)",
    "Changes": "-        # Note: parameter overrides and parameter event publisher need to be ready at this point\n-        # to be able to declare 'use_sim_time' if it was not declared yet.\n-        self._time_source = TimeSource(node=self)\n-        self._time_source.attach_clock(self._clock)\n+        # Init a time source.\n+        # Note: parameter overrides and parameter event publisher need to be ready at this point\n+        # to be able to declare 'use_sim_time' if it was not declared yet.\n+        self._time_source = TimeSource(node=self)\n+        self._time_source.attach_clock(self._clock)\n+\n+from rclpy.parameter import Parameter\n+    def test_create_node_with_parameter_overrides(self):\n+        node_name = 'create_node_with_parameter_overrides_test'\n+        rclpy.create_node(\n+            node_name, context=self.context,\n+            automatically_declare_parameters_from_overrides=True,\n+            parameter_overrides=[\n+                Parameter('use_sim_time', Parameter.Type.BOOL, True)\n+            ]\n+        ).destroy_node()\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "d5980d5a8fb753d2d7074c635426b9a2805928ba",
    "RawMessage": "Fix the history depth for KEEP_ALL. (#305)",
    "Changes": "-        qos_policies->depth = (uint32_t) depth;\n+        // When using a policy of KEEP_ALL, the depth is meaningless.\n+        // CycloneDDS reports this as -1, but the rmw_qos_profile_t structure\n+        // expects an unsigned number.  Casting -1 to unsigned would yield\n+        // a value of 2^32 - 1, but unfortunately our XML-RPC connection\n+        // (used for the command-line tools) doesn't understand anything\n+        // larger than 2^31 - 1.  Just set the depth to 0 here instead.\n+        qos_policies->depth = 0;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "a8d77e63a9e288eb3172e5e549ce0c097988c97f",
    "RawMessage": "get_type_description service (#1139)",
    "Changes": "+  src/rclpy/type_description_service.cpp\n+from rclpy.type_description_service import TypeDescriptionService\n+        self._type_description_service = TypeDescriptionService(self)\n+\n+        self._type_description_service.destroy()\n+# Copyright 2023 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from rcl_interfaces.msg import ParameterDescriptor\n+from rcl_interfaces.msg import ParameterType\n+\n+from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n+from rclpy.parameter import Parameter\n+from rclpy.qos import qos_profile_services_default\n... [truncated] ...\n+   * \\param[in] node The node that this service belongs to\n+   * \\return response message to send\n+   */\n+  py::object\n+  handle_request(py::object pyrequest, py::object pyresponse_type, Node & node);\n+\n+  /// Force early cleanup of object\n+  void\n+  destroy() override;\n+\n+private:\n+  std::shared_ptr<Service> service_;\n+};\n+\n+/// Define a pybind11 wrapper for an rclpy::TypeDescriptionService\n+void\n+define_type_description_service(py::object module);\n+}  // namespace rclpy\n+\n+#endif  // RCLPY__TYPE_DESCRIPTION_SERVICE_HPP_\n+from rclpy.type_description_service import START_TYPE_DESCRIPTION_SERVICE_PARAM\n-                USE_SIM_TIME_NAME: self.node.get_parameter(USE_SIM_TIME_NAME)\n+                USE_SIM_TIME_NAME: self.node.get_parameter(USE_SIM_TIME_NAME),\n+                START_TYPE_DESCRIPTION_SERVICE_PARAM: self.node.get_parameter(\n+                    START_TYPE_DESCRIPTION_SERVICE_PARAM),",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "db38b6a616957dcd3ad020125c06a2a8ffa1940d",
    "RawMessage": "Update serialization/deserialization API documentation. (#258)",
    "Changes": "- * The serialization format depends on the underlying middleware.\n+ * The serialization format depends on the underlying implementation.\n+ *\n+ * \\pre Given ROS message must be a valid non-null instance, initialized\n+ *   by the caller and matching the provided typesupport.\n+ * \\pre Given typesupport must be a valid non-null instance, as provided\n+ *   by `rosidl` APIs.\n+ * \\pre Given serialized message must be a valid non-null instance, initialized\n+ *   by the caller.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe [1]\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [2]\n+ * Lock-Free          | Maybe [2]\n+ * <i>[1] if the given serialized message does not have enough capacity to hold\n+ *        the ROS message serialization</i>\n+ * <i>[2] rmw implementation defined, check the implementation documentation</i>\n- * The ROS message must already be allocated and initialized, and must match\n- * the given typesupport structure.\n- * underlying middleware.\n+ * underlying implementation.\n+ *\n... [truncated] ...\n+/**\n+ * The internal buffer of the serialized message can be resized dynamically\n+ * if needed.\n+ * If the new size is smaller than the current capacity, then the memory is\n+ * truncated.\n+ *\n+ * \\pre Given serialized message must have been initialized with `rmw_serialized_message_init()`.\n+ *\n+ * \\remarks If serialized message is zero initialized, then `RMW_RET_INVALID_ARGUMENT`\n+ *   is returned.\n+ *\n+ * \\warning Be aware that this might deallocate the memory and therefore\n+ *   invalidate any pointers to the internal buffer.\n+ *\n+ * \\param[inout] serialized_message pointer to the serialized message\n+ *   to be resized\n+ * \\param[in] new_size the new size of the internal buffer\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if serialized_message is invalid\n+ *   or new_size is set to zero, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs\n+ */\n+#define rmw_serialized_message_resize(serialized_message, new_size) \\\n+  rcutils_uint8_array_resize(serialized_message, new_size)",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "7780fa11f126495dd644f02cc8f81fe847abdfd8",
    "RawMessage": "Waitable should check callback_group if it can be executed. (#1001)",
    "Changes": "-                            handler = self._make_handler(\n-                                wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n-                            yielded_work = True\n-                            yield handler, wt, node\n+                            if wt.callback_group.can_execute(wt):\n+                                handler = self._make_handler(\n+                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n+                                yielded_work = True\n+                                yield handler, wt, node",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "2fee2355e3b70e7d821cedb9a27f40767280f5e4",
    "RawMessage": "Update README.md",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](http://www.gurum.cc).\n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n-### rmw_gurumdds_static_cpp\n-`rmw_gurumdds_static_cpp` is another rmw implementation, which uses `rosidl_typesupport_gurumdds`, our own typesupport packages. You can use this rmw implementation with environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_static_cpp`. Other settings and configurations are the same as `rmw_gurumdds_cpp`.  \n+### rmw_gurumdds_static_cpp(deprecated)\n+~~`rmw_gurumdds_static_cpp` is another rmw implementation, which uses `rosidl_typesupport_gurumdds`, our own typesupport packages. You can use this rmw implementation with environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_static_cpp`. Other settings and configurations are the same as `rmw_gurumdds_cpp`.~~\n-There are three active branches in this project: master, galactic and foxy.\n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch, so this branch might be unstable.\n-If you want to use this project with ROS2 Galactic Geochelone, Foxy Fitzroy, please use galactic or foxy branch, respectively.\n+There are four active branches in this project: master, humble, galactic and foxy.\n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n+If you want to use this project with ROS2 Rolling Ridley, Galactic Geochelone or Foxy Fitzroy, please use master, galactic or foxy branch, respectively.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "6ae73ca28e003c547746ad33f30d170625e362ce",
    "RawMessage": "Feature/updated documentation executor (#117)",
    "Changes": "-Therefore at initialization of the RCLC-Executor, the user defines the total number of handles `number_of_handles`.\n-The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase.\n-This makes this Executor static in the sense, that during runtime no additional callbacks can be added.\n+Therefore at initialization of the RCLC-Executor, the user defines the total number of handles `number_of_handles`. A handle is a term for subscriptions, timers, services, clients and guard conditions. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. The corresponding wait-set is allocated in the first execution of the spin-method or in the optional call to `rclc_executor_prepare` .\n+This makes this Executor static in the sense, that during runtime no heap allocations occur. You can add, however, at runtime as many handles, e.g. subscriptions, to the executor until the maximum number of handles is reached.\n+ * As the Executor is intended for embedded controllers, dynamic memory management is crucial.\n+ *  Therefore at initialization of the RCLC-Executor, the user defines the total \\p number_of_handles.\n+ * A handle is a term for subscriptions, timers, services, clients and guard conditions. The\n+ * heap will be allocated only in this phase and no more memory will be allocated in the\n+ * running phase in the executor. However, the heap memory of corresponding wait-set is\n+ * allocated in the first iteration of a spin-method, which calls internally rclc_executor_prepare.\n+ * Optionally, you can also call rclc_executor_prepare before calling any of the spin-methods.\n+ * Then all wait-set related memory allocation will be done in rclc_executor_prepare and not\n+ * in the first iteration of the spin-method.\n+ *\n+ * This makes this Executor static in\n+ * terms of memory allocation, in the sense, that during runtime no heap allocations occur.\n+ * You can add, however, at runtime as many handles, e.g. subscriptions, to the executor\n+ * until the maximum number of handles is reached. In this case, the wait-set needs to be\n+ * updated and rclc_executor_prepare is called again (with dynamic memory allocation in RCL).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "9abac34e6375c3dae0fd2bc9901dbc6a269b7d45",
    "RawMessage": "Updated performance QD section (#153)",
    "Changes": "-`rmw_implementation` does not currently have performance tests.\n+The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/master/rmw_implementation/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n-|4.iv.a| Performance tests (if applicable) | x |\n+|4.iv.a| Performance tests (if applicable) | \u0393\u00a3\u00f4 |",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "ros2cli",
    "SHA": "e875ed0f35213bda9dc9609f4e179af57730f62b",
    "RawMessage": "Shutdown ros2doctor hello when ctrl-c is received (#826)",
    "Changes": "-            executor_thread = threading.Thread(target=executor.spin)\n+            def spin():\n+                try:\n+                    executor.spin()\n+                except rclpy.executors.ExternalShutdownException:\n+                    rclpy.shutdown()\n+\n+            executor_thread = threading.Thread(target=spin)",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "76cd6508a8c4e35d9fe3a6a8968abbe7159ffc08",
    "RawMessage": "Add an option to publish TwistStamped (#42)",
    "Changes": "+    test/publish_stamped_twist_joy_launch_test.py\n+The message type can be changed to `geometry_msgs/msg/TwistStamped` by the `publish_stamped_twist` parameter.\n-- `cmd_vel (geometry_msgs/msg/Twist)`\n+- `cmd_vel (geometry_msgs/msg/Twist or geometry_msgs/msg/TwistStamped)`\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+\n+- `frame (string, default: 'teleop_twist_joy')`\n+  - Frame name used for the header of TwistStamped messages.\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+    publish_stamped_twist = launch.substitutions.LaunchConfiguration('publish_stamped_twist')\n+        launch.actions.DeclareLaunchArgument('publish_stamped_twist', default_value='false'),\n-            name='teleop_twist_joy_node', parameters=[config_filepath],\n+            name='teleop_twist_joy_node',\n+            parameters=[config_filepath, {'publish_stamped_twist': publish_stamped_twist}],\n+#include <geometry_msgs/msg/twist_stamped.hpp>\n+  void fillCmdVelMsg(\n+    const sensor_msgs::msg::Joy::SharedPtr, const std::string & which_map,\n+    geometry_msgs::msg::Twist * cmd_vel_msg);\n+  rclcpp::Publisher<geometry_msgs::msg::TwistStamped>::SharedPtr cmd_vel_stamped_pub;\n+  rclcpp::Clock::SharedPtr clock;\n+  bool publish_stamped_twist;\n+  std::string frame_id;\n-  pimpl_->cmd_vel_pub = this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n... [truncated] ...\n+\n+    return launch.LaunchDescription([\n+            teleop_node,\n+            launch_testing.actions.ReadyToTest(),\n+        ]), locals()\n+\n+\n+class PublishTwistStamped(test_joy_twist.TestJoyTwist):\n+\n+    def setUp(self):\n+        self.cmd_vel_msg_type = geometry_msgs.msg.TwistStamped\n+        super().setUp()\n+        self.joy_msg['axes'] = [0.3, 0.4]\n+        self.joy_msg['buttons'] = [1]\n+        self.expect_cmd_vel['linear']['x'] = 0.8\n+        self.expect_cmd_vel['angular']['z'] = 0.9\n-        self.sub = self.node.create_subscription(geometry_msgs.msg.Twist,\n+        if not hasattr(self, \"cmd_vel_msg_type\"):\n+            self.cmd_vel_msg_type = geometry_msgs.msg.Twist\n+        self.sub = self.node.create_subscription(self.cmd_vel_msg_type,\n-        self.received_cmd_vel = msg\n+        if self.cmd_vel_msg_type is geometry_msgs.msg.Twist:\n+            self.received_cmd_vel = msg\n+        else:\n+            self.received_cmd_vel = msg.twist",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "7a2a6bc2e9cd8df996d7f320ef8c166638691d47",
    "RawMessage": "Fixed AccelStamped, TwistStamped and Wrench icons (#1041)",
    "Changes": "",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "8eeb955f581c9cd24761185557ba7f46ef6e1d4c",
    "RawMessage": "Clarify Data Sharing enabling (#719)",
    "Changes": "-For example, see [ROS 2 QoS policies](https://docs.ros.org/en/foxy/Concepts/About-Quality-of-Service-Settings.html#qos-policies)).\n-In addition to ROS 2 QoS policies, `rmw_fastrtps` sets two more Fast DDS configurable parameters:\n+For example, see [ROS 2 QoS policies](https://docs.ros.org/en/foxy/Concepts/About-Quality-of-Service-Settings.html#qos-policies).\n+In addition to ROS 2 QoS policies, `rmw_fastrtps` sets the following Fast DDS configurable parameters:\n-* Publication mode: `ASYNCHRONOUS_PUBLISH_MODE`\n+* Publication mode: `SYNCHRONOUS_PUBLISH_MODE`\n+* Data Sharing: `OFF`\n+[datasharing]: https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html\n+* [datasharing] : `AUTO`.\n-The following example configures Fast DDS to publish synchronously, and to have a pre-allocated history that can be expanded whenever it gets filled.\n+The following example configures Fast DDS to publish synchronously, to have a pre-allocated history that can be expanded whenever it gets filled, and to use Data Sharing if possible.\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                <qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                </qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                <qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n... [truncated] ...\n+1. To enable Fast DDS Data Sharing delivery mechanism, the following XML profiles need to be loaded, and environment variable `RMW_FASTRTPS_USE_QOS_FROM_XML` needs to be set to 1 (see [Full QoS configuration](#full-qos-configuration))\n+\n+    ```xml\n+    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+    <profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\">\n+\n+    <!-- Default publisher profile -->\n+    <publisher profile_name=\"default publisher profile\" is_default_profile=\"true\">\n+        <qos>\n+        <data_sharing>\n+            <kind>AUTOMATIC</kind>\n+        </data_sharing>\n+        </qos>\n+    </publisher>\n+\n+    <!-- Default subscription profile -->\n+    <subscriber profile_name=\"default subscription profile\" is_default_profile=\"true\">\n+        <qos>\n+        <data_sharing>\n+            <kind>AUTOMATIC</kind>\n+        </data_sharing>\n+        </qos>\n+    </subscriber>\n+    </profiles>\n+    ```",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2e737c8cb0ad7afc436938c30b5e14b4282ff2f7",
    "RawMessage": "mock launch components causing rosdoc2 to fail Python API (#425)",
    "Changes": "+# Copyright 2024 R. Kent James\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+# -- Path setup --------------------------------------------------------------\n+\n+import sys\n+\n+from sphinx.ext.autodoc.mock import mock\n+\n+# -- Project information -----------------------------------------------------\n+\n+copyright = 'The <launch_ros> Contributors. License: Apache License 2.0'  # noqa A001\n+\n+# -- General configuration ---------------------------------------------------\n... [truncated] ...\n+with mock(['launch']):\n+    import launch  # noqa F401\n+    module = sys.modules['launch']\n+sys.modules['launch'] = module\n+\n+with mock(['launch.frontend']):\n+    import launch.frontend  # noqa F401\n+    module = sys.modules['launch.frontend']\n+    # These are dummy decorators\n+    module.expose_action = lambda _: lambda _: _\n+    module.expose_substitution = lambda _: lambda _: _\n+sys.modules['launch.frontend'] = module\n+\n+with mock(['launch.some_substitutions_type']):\n+    import launch.some_substitutions_type  # noqa F401\n+    module = sys.modules['launch.some_substitutions_type']\n+    module.SomeSubstitutionsType_types_tuple = ()\n+sys.modules['launch.some_substitutions_type'] = module\n+\n+# We still want autodoc to mock the base 'launch' module\n+sys.modules.pop('launch')\n+Design Documentation\n+====================\n+\n+See [the design document](https://design.ros2.org/articles/roslaunch.html) for more information on the ros2 launch system.",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcutils",
    "SHA": "c49b41c9b19ae9e76e746db662285fc6c7d3b1af",
    "RawMessage": "Change syntax __VAR_ARGS__ to __VA_ARGS__ (#376)",
    "Changes": "-#define my__has_feature(...) __has_feature(__VAR_ARGS__)\n+#define my__has_feature __has_feature\n-#define my__has_feature(...) 0\n+#define my__has_feature(x) 0",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "8da2aace17bcecad3bdf0bebafe23298602f50c0",
    "RawMessage": "Clarify duration arg description in logging macros (#359)",
    "Changes": "-    ('duration', 'The duration of the throttle interval'),\n+    ('duration', 'The duration of the throttle interval as an integral value in milliseconds.'),",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "4052e51b08dcfeccb40fe5b4cc655e1a07c5aa8c",
    "RawMessage": "use CMake config dirs as hint for header/library search (#56)",
    "Changes": "-find_path(FastRTPS_INCLUDE_DIR\n-  NAMES fastrtps/)\n-\n+find_path(FastRTPS_INCLUDE_DIR\n+  NAMES fastrtps/\n+  HINTS \"${fastrtps_DIR}/../../../include\")\n+\n-  NAMES fastcdr-${fastcdr_MAJOR_MINOR_VERSION} fastcdr)\n+  NAMES fastcdr-${fastcdr_MAJOR_MINOR_VERSION} fastcdr\n+  HINTS \"${fastcdr_DIR}/../..\")\n-  NAMES fastcdrd-${fastcdr_MAJOR_MINOR_VERSION})\n+  NAMES fastcdrd-${fastcdr_MAJOR_MINOR_VERSION}\n+  HINTS \"${fastcdr_DIR}/../..\")\n-  NAMES fastrtps-${fastrtps_MAJOR_MINOR_VERSION} fastrtps)\n+  NAMES fastrtps-${fastrtps_MAJOR_MINOR_VERSION} fastrtps\n+  HINTS \"${fastrtps_DIR}/../../../lib\")\n-  NAMES fastrtpsd-${fastrtps_MAJOR_MINOR_VERSION})\n+  NAMES fastrtpsd-${fastrtps_MAJOR_MINOR_VERSION}\n+  HINTS \"${fastrtps_DIR}/../../../lib\")",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "e18084fa421fa54a3a6793909d128046b2b5a08e",
    "RawMessage": "Revert \"Raise user handler exception in MultiThreadedExecutor. (#984)\" (#1017)",
    "Changes": "-        :raise RuntimeError: Unexpected failure.\n-        :raise RuntimeError: Unexpected failure.\n-            def handler_wrapper(handler):\n-                handler()\n-                if handler.exception() is not None:\n-                    raise handler.exception()\n-            self._executor.submit(handler_wrapper(handler))\n+            self._executor.submit(handler)\n-        :return: ``True`` if successful, ``False`` otherwise.\n+        :return: ``True`` if succesful, ``False`` otherwise.",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b144b3fa899a26e79aab0a2d26cf0f24f79738ee",
    "RawMessage": "Remove dds_typesupport from Publisher/Subscriber Info",
    "Changes": "-  dds_TypeSupport * dds_typesupport;\n-  dds_TypeSupport * dds_typesupport;\n-  publisher_info->dds_typesupport = dds_typesupport;\n+  dds_TypeSupport_delete(dds_typesupport);\n+  dds_typesupport = nullptr;\n+\n-    if (publisher_info->dds_typesupport != nullptr) {\n-      dds_TypeSupport_delete(publisher_info->dds_typesupport);\n-      publisher_info->dds_typesupport = nullptr;\n-    }\n-\n-  subscriber_info->dds_typesupport = dds_typesupport;\n+  dds_TypeSupport_delete(dds_typesupport);\n+  dds_typesupport = nullptr;\n+",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "urdf",
    "SHA": "88bb52e87d82886492cfde10423ad9522fdd7845",
    "RawMessage": "Provide copy and move constructors for `model` (#33)",
    "Changes": "+  URDF_EXPORT Model(const Model & other);\n+  URDF_EXPORT Model & operator=(const Model & other);\n+  URDF_EXPORT Model(Model && other) noexcept;\n+  URDF_EXPORT Model & operator=(Model && other)noexcept;\n+\n+Model::Model(const Model & other)\n+: ModelInterface(other), impl_(new ModelImplementation) {}\n+\n+Model & Model::operator=(const Model & other)\n+{\n+  return *this = Model(other);\n+}\n+\n+Model::Model(Model && other) noexcept\n+: ModelInterface(other), impl_(std::exchange(other.impl_, nullptr)) {}\n+\n+Model & Model::operator=(Model && other) noexcept\n+{\n+  ModelInterface::operator=(std::move(other));\n+  std::swap(impl_, other.impl_);\n+  return *this;\n+}\n+",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "8dc9f8a5f6f39ba0fc9ec784e6d8f93e70d3a9fa",
    "RawMessage": "Make Axes display use latest transform (#892)",
    "Changes": "-      frame, context_->getClock()->now(), position, orientation))\n+      frame, position, orientation))",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "91646cedfc368e29ab7e8f70cbf77aa1e354b5c4",
    "RawMessage": "rmw_cyclonedds_cpp/CMakeLists.txt: add -latomic for RISC-V (#332)",
    "Changes": "+if(CMAKE_GENERATOR_PLATFORM)\n+  set(TARGET_ARCH \"${CMAKE_GENERATOR_PLATFORM}\")\n+else()\n+  set(TARGET_ARCH \"${CMAKE_SYSTEM_PROCESSOR}\")\n+endif()\n+\n+if(CMAKE_COMPILER_IS_GNUCXX AND TARGET_ARCH MATCHES \"^(riscv|RISCV)64$\")\n+  # using GCC, libatomic is not automatically linked for RISC-V\n+  target_link_libraries(rmw_cyclonedds_cpp -latomic)\n+endif()\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "e3b56ed7058502d94fe3d1c27948d4f4e9be58a8",
    "RawMessage": "Added Effort plugin (#990)",
    "Changes": "-| Camera                | Focus Camera  | XY Orbit              | Help            | \n-| Fluid Pressure        | Measure       | First Person          | Selections      |\n-| Grid                  | Select        | Third Person Follower | Time            |\n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Illuminance           | Publish Point |                       | Views           |\n-| Image                 | Initial Pose  |\n-| Interactive Marker    | Interact      |\n+| Camera                | Focus Camera  | XY Orbit              | Help            |\n+| Effort                | Measure       | First Person          | Selections      |\n+| Fluid                 | Select        | Third Person Follower | Time            |\n+| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Grid Cells            | Publish Point |                       | Views           |\n+| Illuminance           | Initial Pose  |\n+| Image                 | Interact      |\n+| Interactive Marker    |\n-| Effort        |\n+  include/rviz_default_plugins/displays/effort/effort_display.hpp\n+  src/rviz_default_plugins/displays/effort/effort_display.cpp\n+  ament_add_gtest(effort_display_visual_test\n+    test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\n+    test/rviz_default_plugins/publishers/effort_publisher.hpp\n+    test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET effort_display_visual_test)\n... [truncated] ...\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setFramePosition(\"joint1\", pos1);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(3.0f, 1.0f, -2.05f)));\n+}\n+\n+TEST_F(EffortVisualTestFixture, setEffort_hides_force_arrow_for_larger_width_than_scale) {\n+  auto scene_manager = Ogre::Root::getSingletonPtr()->createSceneManager();\n+  auto root_node = scene_manager->getRootSceneNode();\n+\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+\n+  effort_visual->setScale(0.7f);\n+  effort_visual->setWidth(5);\n+\n+  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  EXPECT_THAT(arrows, SizeIs(1u));\n+  auto force_arrow = findForceArrow(root_node);\n+  EXPECT_THAT(force_arrow->getScale(), Vector3Eq(Ogre::Vector3(1, 1, 1)));\n+}",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "common_interfaces",
    "SHA": "74137fc6971ac7d6420248b4394cca977fb5a887",
    "RawMessage": "Create new messages with all fields needed to define a velocity and transform it  (#240)",
    "Changes": "+  \"msg/VelocityStamped.msg\"\n+# This expresses the timestamped velocity vector of a frame 'body_frame_id' in the reference frame 'reference_frame_id' expressed from arbitrary observation frame 'header.frame_id'.\n+# - If the 'body_frame_id' and 'header.frame_id' are identical, the velocity is observed and defined in the local coordinates system of the body\n+#   which is the usual use-case in mobile robotics and is also known as a body twist.\n+\n+std_msgs/Header header\n+string body_frame_id\n+string reference_frame_id\n+Twist velocity",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "13504b5003ecf010cf8d3085af6997475f9f83f2",
    "RawMessage": "Fix interoperability errors: Remove buffer roundup at the end of messeage deserialize function",
    "Changes": "-        ),\n-        false\n+        )\n-      ),\n-      false\n+      )\n-          ),\n-          false\n+          )\n-          ),\n-          false\n+          )\n-      ),\n-      false\n+      )\n-  void deserialize(const MessageMembersT * members, uint8_t * output, bool roundup_)\n+  void deserialize(const MessageMembersT * members, uint8_t * output)\n-\n-    if (roundup_) {\n-      buffer.roundup(4);\n-    }\n-    deserializer.deserialize(members, ros_message, true);\n+    deserializer.deserialize(members, ros_message);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "f202dff4251a62b829faba041f7a89f7d04447d8",
    "RawMessage": "Added rmw_event_type_is_supported (#809)",
    "Changes": "+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::__rmw_event_type_is_supported(rmw_event_type);\n+}\n+\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::__rmw_event_type_is_supported(rmw_event_type);\n+}\n+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+bool\n+__rmw_event_type_is_supported(rmw_event_type_t rmw_event_type);\n+\n+bool\n+__rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n+{\n+  return rmw_fastrtps_shared_cpp::internal::is_event_supported(rmw_event_type);\n+}\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "5766d5e629c1f6ad8965b07e65968873e1f796b7",
    "RawMessage": "Generate version header using ament_generate_version_header(..) (#1141)",
    "Changes": "+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "e88b63ba3c153dec6f1e5f0cc76137a728d68e42",
    "RawMessage": "Fix test_rcl_lifecycle (#788)",
    "Changes": "-  EXPECT_EQ(state.id, 0u);\n-  EXPECT_EQ(state.label, nullptr);\n+  EXPECT_EQ(0u, state.id);\n+  EXPECT_EQ(nullptr, state.label);\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(state.id, expected_id);\n-  EXPECT_STREQ(state.label, &expected_label[0]);\n+  EXPECT_EQ(expected_id, state.id);\n+  EXPECT_STREQ(&expected_label[0], state.label);\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-  EXPECT_EQ(transition.id, 0u);\n-  EXPECT_EQ(transition.label, nullptr);\n-  EXPECT_EQ(transition.start, nullptr);\n... [truncated] ...\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-  EXPECT_EQ(ret, RCL_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, ret);\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RCL_RET_OK, rcl_node_options_fini(&options));\n+  });\n+\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(&init_options));\n+  });\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n-\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-  EXPECT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RCL_RET_OK, rcl_node_fini(&node));\n+  });",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "ca59b6f243d76f4e54729610f29fa097a77fe0fa",
    "RawMessage": "Add underscores to material names (#811)",
    "Changes": "-      default_material_->getName() + std::to_string(material_count++) + \"Robot\";\n+      default_material_->getName() + \"_\" + std::to_string(material_count++) + \"Robot\";\n-      default_material_->getName() + std::to_string(material_count++) + \"Robot\";\n+      default_material_->getName() + \"_\" + std::to_string(material_count++) + \"Robot\";\n-        sub_material_name + std::to_string(material_count++) + \"Robot\";\n+        sub_material_name + \"_\" + std::to_string(material_count++) + \"Robot\";",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e308c28a32855e3dffad6c6f18b4c22e01843233",
    "RawMessage": "Update packages to use gurumdds-2.7",
    "Changes": "-The master branch of this project requires GurumDDS 2.6.1875 or higher.\n+Required version of GurumDDS depends on the version of this project.\n+\n+| rmw_gurumdds            | GurumDDS                    |\n+|-------------------------|-----------------------------|\n+| 2.1.0                   | 2.7.x                       |\n+| 2.0.1 or lower          | 2.6.1875 or higher          |\n-  <build_depend>gurumdds-2.6</build_depend>\n+  <build_depend>gurumdds-2.7</build_depend>\n-  <build_export_depend>gurumdds-2.6</build_export_depend>\n+  <build_export_depend>gurumdds-2.7</build_export_depend>\n-  <build_depend>gurumdds-2.6</build_depend>\n+  <build_depend>gurumdds-2.7</build_depend>\n-  <build_export_depend>gurumdds-2.6</build_export_depend>\n+  <build_export_depend>gurumdds-2.7</build_export_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "31e5e119fe7a253b69386d416c9cbe13ff741f69",
    "RawMessage": "update rmw_*_*_allocation returns (#278)",
    "Changes": "+ * \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n+ * \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n+ * \\return `RMW_RET_UNSUPPORTED` if it's unimplemented\n+ * \\return `RMW_RET_UNSUPPORTED` if it's unimplemented",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "eef4b5914a73cdf2e3547cbf201ebd67ad2d64e9",
    "RawMessage": "Ignoring unsuccessful SERVICE_TAKE (#175)",
    "Changes": "+          // invalidate that data is available, because rcl_take failed\n+          if (rc == RCL_RET_SUBSCRIPTION_TAKE_FAILED) {\n+            handle->data_available = false;\n+          }\n+          // invalidate that data is available, because rcl_take failed\n+          if (rc == RCL_RET_SERVICE_TAKE_FAILED) {\n+            handle->data_available = false;\n+          }\n-      if ((rc != RCL_RET_OK) && (rc != RCL_RET_SUBSCRIPTION_TAKE_FAILED)) {\n+      if ((rc != RCL_RET_OK) && (rc != RCL_RET_SUBSCRIPTION_TAKE_FAILED) &&\n+        (rc != RCL_RET_SERVICE_TAKE_FAILED))\n+      {\n-  rclc_executor_spin(&executor);\n+  RCSOFTCHECK(rclc_executor_spin(&executor));",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "f401871f40234613235655445861e6181032a34e",
    "RawMessage": "updated ci versions (#396)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.6.2\n+    - uses: ros-tooling/setup-ros@0.6.3\n-    - uses : ros-tooling/action-ros-ci@0.3.2\n+    - uses : ros-tooling/action-ros-ci@0.3.5",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "76cd6508a8c4e35d9fe3a6a8968abbe7159ffc08",
    "RawMessage": "Add an option to publish TwistStamped (#42)",
    "Changes": "+    test/publish_stamped_twist_joy_launch_test.py\n+The message type can be changed to `geometry_msgs/msg/TwistStamped` by the `publish_stamped_twist` parameter.\n-- `cmd_vel (geometry_msgs/msg/Twist)`\n+- `cmd_vel (geometry_msgs/msg/Twist or geometry_msgs/msg/TwistStamped)`\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+\n+- `frame (string, default: 'teleop_twist_joy')`\n+  - Frame name used for the header of TwistStamped messages.\n+- `publish_stamped_twist (bool, default: false)`\n+  - Whether to publish `geometry_msgs/msg/TwistStamped` for command velocity messages.\n+    publish_stamped_twist = launch.substitutions.LaunchConfiguration('publish_stamped_twist')\n+        launch.actions.DeclareLaunchArgument('publish_stamped_twist', default_value='false'),\n-            name='teleop_twist_joy_node', parameters=[config_filepath],\n+            name='teleop_twist_joy_node',\n+            parameters=[config_filepath, {'publish_stamped_twist': publish_stamped_twist}],\n+#include <geometry_msgs/msg/twist_stamped.hpp>\n+  void fillCmdVelMsg(\n+    const sensor_msgs::msg::Joy::SharedPtr, const std::string & which_map,\n+    geometry_msgs::msg::Twist * cmd_vel_msg);\n+  rclcpp::Publisher<geometry_msgs::msg::TwistStamped>::SharedPtr cmd_vel_stamped_pub;\n+  rclcpp::Clock::SharedPtr clock;\n+  bool publish_stamped_twist;\n+  std::string frame_id;\n-  pimpl_->cmd_vel_pub = this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n... [truncated] ...\n+\n+    return launch.LaunchDescription([\n+            teleop_node,\n+            launch_testing.actions.ReadyToTest(),\n+        ]), locals()\n+\n+\n+class PublishTwistStamped(test_joy_twist.TestJoyTwist):\n+\n+    def setUp(self):\n+        self.cmd_vel_msg_type = geometry_msgs.msg.TwistStamped\n+        super().setUp()\n+        self.joy_msg['axes'] = [0.3, 0.4]\n+        self.joy_msg['buttons'] = [1]\n+        self.expect_cmd_vel['linear']['x'] = 0.8\n+        self.expect_cmd_vel['angular']['z'] = 0.9\n-        self.sub = self.node.create_subscription(geometry_msgs.msg.Twist,\n+        if not hasattr(self, \"cmd_vel_msg_type\"):\n+            self.cmd_vel_msg_type = geometry_msgs.msg.Twist\n+        self.sub = self.node.create_subscription(self.cmd_vel_msg_type,\n-        self.received_cmd_vel = msg\n+        if self.cmd_vel_msg_type is geometry_msgs.msg.Twist:\n+            self.received_cmd_vel = msg\n+        else:\n+            self.received_cmd_vel = msg.twist",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcutils",
    "SHA": "2783b61df5fcf586395cebc779a1ab9267d372ba",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* Cleanup error handling in rcutils. (`#485 <https://github.com/ros2/rcutils/issues/485>`_)\n+* Remove CODEOWNERS and mirror-rolling-to-master workflow. (`#483 <https://github.com/ros2/rcutils/issues/483>`_)\n+* Contributors: Chris Lalancette\n+",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "fd4604e5cc4a35911da8b8c90a9a41cb2abad0c1",
    "RawMessage": "Reorganize package",
    "Changes": "-This project requires `rosidl_typesupport_gurumdds` to be built. For more information, see README.md of the [project](https://github.com/ros2/rosidl_typesupport_gurumdds).\n+| 3.2.0  or higher         | 2.8.3140 or higher          |\n-This project consists of four packages, `rmw_gurumdds_cpp`, `rmw_gurumdds_static_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+This project consists of four packages, `gurumdds_camke_module`, `rmw_gurumdds_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+\n+### gurumdds_cmake_module\n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+```\n+gurumdds\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 include\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcps.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcpsx.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 typesupport.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 xml.h\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n... [truncated] ...\n-      dds_DataReader_get_requested_incompatible_qos_status(topic_reader, &status);\n-    rmw_ret_t rmw_ret = check_dds_ret_code(dds_ret);\n-    if (rmw_ret != RMW_RET_OK) {\n-      return rmw_ret;\n-    }\n-\n-    auto rmw_status = static_cast<rmw_requested_qos_incompatible_event_status_t *>(event);\n-    rmw_status->total_count = status.total_count;\n-    rmw_status->total_count_change = status.total_count_change;\n-    rmw_status->last_policy_kind = convert_qos_policy(status.last_policy_id);\n-  } else {\n-    return RMW_RET_UNSUPPORTED;\n-  }\n-  return RMW_RET_OK;\n-}\n-\n-dds_StatusCondition * GurumddsSubscriberInfo::get_statuscondition()\n-{\n-  return dds_DataReader_get_statuscondition(topic_reader);\n-}\n-\n-dds_StatusMask GurumddsSubscriberInfo::get_status_changes()\n-{\n-  return dds_DataReader_get_status_changes(topic_reader);\n-}",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "c407416261e73e1130ae1b57a0ec00b2ca76df4f",
    "RawMessage": "Add omitted free",
    "Changes": "+    if (rmw_publisher->topic_name != nullptr) {\n+      rmw_free(const_cast<char *>(rmw_publisher->topic_name));\n+    }",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "1128b57d336dfa8bf462a5f9147291f73faa8ed3",
    "RawMessage": "Remove CODEOWNERS amd mirror-rolling-to-master workflow. (#790)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @gbiggs @sloretz",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "126321d4a0dd212df810431cf2fba627c807d69a",
    "RawMessage": "Make sure to call rcl_arguments_fini at the end of the test.",
    "Changes": "+\n+  EXPECT_EQ(RCL_RET_OK, rcl_arguments_fini(&prev_ini_options.arguments));",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "0263722fb48be9bddadef3601c50397c8d71a1d8",
    "RawMessage": "Remove subscription (#106) (#113)",
    "Changes": "+\n+/**\n+ *  Removes a subscription from an executor.\n+ * * An error is returned if {@link rclc_executor_t.handles} array is empty.\n+ * * An error is returned if subscription is not found in {@link rclc_executor_t.handles}.\n+ * * The total number_of_subscriptions field of {@link rclc_executor_t.info}\n+ *   is decremented by one.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param [inout] executor pointer to initialized executor\n+ * \\param [in] subscription pointer to an allocated and initialized subscription previously added to executor\n+ * \\return `RCL_RET_OK` if add-operation was successful\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any parameter is a null pointer\n+ * \\return `RCL_RET_ERROR` if any other error occured\n+ */\n+rcl_ret_t\n+rclc_executor_remove_subscription(\n+  rclc_executor_t * executor,\n... [truncated] ...\n+\n+  rc = rclc_executor_add_guard_condition(&executor, &guard_cond, &gc_callback);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+  EXPECT_EQ(executor.info.number_of_guard_conditions, (size_t) 1);\n+\n+  // test remove guard condition - invalid args\n+  rc = rclc_executor_remove_guard_condition(&executor, NULL);\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+  rc = rclc_executor_remove_guard_condition(NULL, &guard_cond);\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+  // test remove guard condition - valid args\n+  rc = rclc_executor_remove_guard_condition(&executor, &guard_cond);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+  EXPECT_EQ(executor.info.number_of_guard_conditions, (size_t) 0);\n+\n+  // test remove non-existent guard condition\n+  rc = rclc_executor_remove_guard_condition(&executor, &guard_cond);\n+  EXPECT_EQ(RCL_RET_ERROR, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d930a74491b836bea2e6a8223a95259890676adb",
    "RawMessage": "ros2action: add SIGINT handler to manage cancel request. (#956)",
    "Changes": "+import signal\n+\n+        # install signal handler to cancel the goal on SIGINT\n+        def _sigint_cancel_handler(sig, frame):\n+            nonlocal goal_handle\n+            # Cancel the goal if it's still active\n+            if (goal_handle is not None and\n+                (GoalStatus.STATUS_ACCEPTED == goal_handle.status or\n+                 GoalStatus.STATUS_EXECUTING == goal_handle.status)):\n+                print('Canceling goal...')\n+                cancel_future = goal_handle.cancel_goal_async()\n+                rclpy.spin_until_future_complete(node, cancel_future)\n+\n+                cancel_response = cancel_future.result()\n+\n+                if cancel_response is None:\n+                    raise RuntimeError(\n+                        'Exception while canceling goal: {!r}'.format(cancel_future.exception()))\n+\n+                if len(cancel_response.goals_canceling) == 0:\n+                    raise RuntimeError('Failed to cancel goal')\n+                if len(cancel_response.goals_canceling) > 1:\n+                    raise RuntimeError('More than one goal canceled')\n+                if cancel_response.goals_canceling[0].goal_id != goal_handle.goal_id:\n+                    raise RuntimeError('Canceled goal with incorrect goal ID')\n+                print('Goal canceled.')\n+        signal.signal(signal.SIGINT, _sigint_cancel_handler)\n+\n-        # Cancel the goal if it's still active\n-        if (goal_handle is not None and\n-            (GoalStatus.STATUS_ACCEPTED == goal_handle.status or\n-             GoalStatus.STATUS_EXECUTING == goal_handle.status)):\n-            print('Canceling goal...')\n-            cancel_future = goal_handle.cancel_goal_async()\n-            rclpy.spin_until_future_complete(node, cancel_future)\n-\n-            cancel_response = cancel_future.result()\n-\n-            if cancel_response is None:\n-                raise RuntimeError(\n-                    'Exception while canceling goal: {!r}'.format(cancel_future.exception()))\n-\n-            if len(cancel_response.goals_canceling) == 0:\n-                raise RuntimeError('Failed to cancel goal')\n-            if len(cancel_response.goals_canceling) > 1:\n-                raise RuntimeError('More than one goal canceled')\n-            if cancel_response.goals_canceling[0].goal_id != goal_handle.goal_id:\n-                raise RuntimeError('Canceled goal with incorrect goal ID')\n-            print('Goal canceled.')\n-",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "8457daf64b49f503d93015a046349081185191c5",
    "RawMessage": "Update rmw_publish_serialized_message() error returns (#240)",
    "Changes": "-  RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n-  RET_NULL(serialized_message);\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    publisher, \"publisher handle is null\",\n+    return RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    serialized_message, \"serialized message handle is null\",\n+    return RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "fa7d9eea89b813b7580e52c3d3501b270d767843",
    "RawMessage": "Change maintainer",
    "Changes": "-  <maintainer email=\"junho@gurum.cc\">Junho Lee</maintainer>\n+  <maintainer email=\"youngjin@gurum.cc\">Youngjin Yun</maintainer>\n-  <maintainer email=\"junho@gurum.cc\">Junho Lee</maintainer>\n+  <maintainer email=\"youngjin@gurum.cc\">Youngjin Yun</maintainer>\n-  <maintainer email=\"junho@gurum.cc\">Junho Lee</maintainer>\n+  <maintainer email=\"youngjin@gurum.cc\">Youngjin Yun</maintainer>\n-  <maintainer email=\"junho@gurum.cc\">Junho Lee</maintainer>\n+  <maintainer email=\"youngjin@gurum.cc\">Youngjin Yun</maintainer>",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "83659fdba82b85b1ddbdab9ed3a32c155640a14d",
    "RawMessage": "Simplify logic to fix absolute paths (#230)",
    "Changes": "-from ament_index_python.packages import get_package_prefix\n-        mode = 'pkg file'\n-        if args.launch_file_name is None:\n-            # If only one argument passed, use single file mode.\n-            mode = 'single file'\n-        else:\n-            # Test if first argument is a package, and if not change to single\n-            # file mode, but only if the file exists.\n-            try:\n-                get_package_prefix(args.package_name)\n-            except PackageNotFoundError:\n-                if os.path.exists(args.package_name):\n-                    mode = 'single file'\n+        mode = 'single file'\n+        # Test if first argument is a file, and if not change to pkg\n+        # file mode.\n+        if not os.path.isfile(args.package_name):\n+            mode = 'pkg file'",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "af34503b5f635f23749b82bb0d16ad517a41c3e6",
    "RawMessage": "Fix bug: condition of dw/dr seq delete",
    "Changes": "-    if (dds_InstanceHandleSeq_length(dw_seq) > 1) {\n-      dds_InstanceHandleSeq_delete(dw_seq);\n-      continue;\n-    }\n-\n-    dds_DataWriter * dw = reinterpret_cast<dds_DataWriter *>(dds_InstanceHandleSeq_get(dw_seq, 0));\n-    ret = dds_Publisher_delete_datawriter(pub, dw);\n-    if (ret != dds_RETCODE_OK) {\n-      RMW_SET_ERROR_MSG(\"failed to delete datawriter\");\n-      dds_InstanceHandleSeq_delete(dw_seq);\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-      return RMW_RET_ERROR;\n+    for (uint32_t j = 0; j < dds_InstanceHandleSeq_length(dw_seq); j++) {\n+      dds_DataWriter * dw =\n+        reinterpret_cast<dds_DataWriter *>(dds_InstanceHandleSeq_get(dw_seq, j));\n+      ret = dds_Publisher_delete_datawriter(pub, dw);\n+      if (ret != dds_RETCODE_OK) {\n+        RMW_SET_ERROR_MSG(\"failed to delete datawriter\");\n+        dds_InstanceHandleSeq_delete(dw_seq);\n+        dds_InstanceHandleSeq_delete(pub_seq);\n+        dds_InstanceHandleSeq_delete(sub_seq);\n+      }\n-    if (dds_InstanceHandleSeq_length(dr_seq) > 1) {\n-      dds_InstanceHandleSeq_delete(dr_seq);\n-      continue;\n-    }\n-\n-    dds_DataReader * dr = reinterpret_cast<dds_DataReader *>(dds_InstanceHandleSeq_get(dr_seq, 0));\n-    ret = dds_Subscriber_delete_datareader(sub, dr);\n-    if (ret != dds_RETCODE_OK) {\n-      RMW_SET_ERROR_MSG(\"failed to delete datareader\");\n-      dds_InstanceHandleSeq_delete(dr_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-      return RMW_RET_ERROR;\n+    for (uint32_t j = 0; j < dds_InstanceHandleSeq_length(dr_seq); j++) {\n+      dds_DataReader * dr =\n+        reinterpret_cast<dds_DataReader *>(dds_InstanceHandleSeq_get(dr_seq, j));\n+      ret = dds_Subscriber_delete_datareader(sub, dr);\n+      if (ret != dds_RETCODE_OK) {\n+        RMW_SET_ERROR_MSG(\"failed to delete datareader\");\n+        dds_InstanceHandleSeq_delete(dr_seq);\n+        dds_InstanceHandleSeq_delete(sub_seq);\n+        return RMW_RET_ERROR;\n+      }",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "56a3d8bcb81128fc57bbdc688ff69715720426d9",
    "RawMessage": "Add node construction/destruction API test coverage. (#112)",
    "Changes": "+\n+    ament_add_gtest(test_create_destroy_node${target_suffix}\n+      test/test_create_destroy_node.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_create_destroy_node${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_create_destroy_node${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation\n+    )\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n... [truncated] ...\n+  rmw_reset_error();\n+\n+  const char * const node_name = \"my_node\";\n+  const char * const node_namespace = \"/my_ns\";\n+  rmw_node_t * node = rmw_create_node(&context, node_name, node_namespace);\n+  ASSERT_NE(nullptr, node) << rmw_get_error_string().str;\n+\n+  const char * implementation_identifier = node->implementation_identifier;\n+  node->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_destroy_node(node);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n+  rmw_reset_error();\n+  node->implementation_identifier = implementation_identifier;\n+\n+  ret = rmw_destroy_node(node);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestNodeConstructionDestruction, RMW_IMPLEMENTATION), create_and_destroy) {\n+  const char * const node_name = \"my_node\";\n+  const char * const node_namespace = \"/my_ns\";\n+  rmw_node_t * node = rmw_create_node(&context, node_name, node_namespace);\n+  ASSERT_NE(nullptr, node) << rmw_get_error_string().str;\n+  EXPECT_EQ(RMW_RET_OK, rmw_destroy_node(node)) << rmw_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "b2b57d90ad3ecf96e6f5a459a48c61caa0390188",
    "RawMessage": "Complete rcl enclave validation API coverage. (#751)",
    "Changes": "-  LIBRARIES ${PROJECT_NAME}\n+  LIBRARIES ${PROJECT_NAME} mimick\n+#include \"rcutils/snprintf.h\"\n+\n+#include \"rmw/validate_namespace.h\"\n+\n+#include \"../mocking_utils/patch.hpp\"\n+\n+\n+  {\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_validate_namespace_with_size,\n+      [&](auto, auto, int * result, size_t * index) {\n+        if (index) {\n+          *index = 0u;\n+        }\n+        *result = RMW_NAMESPACE_INVALID_TOO_LONG;\n+        return RMW_RET_OK;\n+      });\n+\n+    // When applying RMW namespace validation rules, an enclave name may be too\n+    // long for an RMW namespace but not necessarily for an enclave name.\n+    EXPECT_EQ(\n+      RCL_RET_OK,\n+      rcl_validate_enclave_name(\"/foo/baz\", &validation_result, &invalid_index));\n... [truncated] ...\n+\n+    EXPECT_EQ(\n+      RCL_RET_ERROR,\n+      rcl_validate_enclave_name(\"/foo\", &validation_result, &invalid_index));\n+    EXPECT_TRUE(rcl_error_is_set());\n+    rcl_reset_error();\n+  }\n+\n+  {\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_validate_namespace_with_size,\n+      [&](auto, auto, int * result, size_t * index) {\n+        if (index) {\n+          *index = 0u;\n+        }\n+        *result = -1;\n+        return RMW_RET_OK;\n+      });\n+\n+    EXPECT_EQ(\n+      RCL_RET_ERROR,\n+      rcl_validate_enclave_name(\"/foo\", &validation_result, &invalid_index));\n+    EXPECT_TRUE(rcl_error_is_set());\n+    rcl_reset_error();\n+  }",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e59034d3671b178aa2861a9300a097436a92696c",
    "RawMessage": "Add missing guid comparison conditional statement",
    "Changes": "-      request_header->source_timestamp =\n-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      request_header->received_timestamp = 0;\n-      request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+        request_header->source_timestamp =\n+          sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+          sample_info->source_timestamp.nanosec;\n+        // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+        request_header->received_timestamp = 0;\n+        request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n+        memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      }",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "b29efa999e838acd1ec92b5547905969338393e2",
    "RawMessage": "Drop build dependency on std_msgs (#314)",
    "Changes": "-find_package(std_msgs REQUIRED)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "a7e3ceb23765b00a8cb444c76042e48a0a6170d3",
    "RawMessage": "Fix interface link libraries in ogre vendor (#761)",
    "Changes": "-    set_target_properties(rviz_ogre_vendor::OgreMain\n-      PROPERTIES\n-        \"INTERFACE_LINK_LIBRARIES\" \"${_extra_interface_link_libraries}\"\n+    target_link_libraries(rviz_ogre_vendor::OgreMain\n+      INTERFACE\n+      ${_extra_interface_link_libraries}",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "56ee3c12187043443b72f412c7fa90c714784fd9",
    "RawMessage": "rclc_parameter: Fix rcl return values (#270)",
    "Changes": "-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-    ret &= rclc_publisher_init(\n+    ret |= rclc_publisher_init(\n-  ret &= rcl_service_fini(&parameter_server->list_service, node);\n-  ret &= rcl_service_fini(&parameter_server->set_service, node);\n-  ret &= rcl_service_fini(&parameter_server->get_service, node);\n-  ret &= rcl_service_fini(&parameter_server->get_types_service, node);\n-  ret &= rcl_service_fini(&parameter_server->describe_service, node);\n+  ret |= rcl_service_fini(&parameter_server->list_service, node);\n+  ret |= rcl_service_fini(&parameter_server->set_service, node);\n+  ret |= rcl_service_fini(&parameter_server->get_service, node);\n+  ret |= rcl_service_fini(&parameter_server->get_types_service, node);\n+  ret |= rcl_service_fini(&parameter_server->describe_service, node);\n-    ret &= rcl_publisher_fini(&parameter_server->event_publisher, node);\n+    ret |= rcl_publisher_fini(&parameter_server->event_publisher, node);\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rcutils_system_time_now(&now);\n+  ret |= rcutils_system_time_now(&now);\n-  ret &= rcl_publish(\n+  ret |= rcl_publish(",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "e63b644f37bcfb1378afa3b44372b814d936298d",
    "RawMessage": "updated documentation (#332)",
    "Changes": "-add_executable(example_executor_convenience src/example_executor_convenience.c)\n-ament_target_dependencies(example_executor_convenience rcl rclc std_msgs)\n+add_executable(example_executor_only_rcl src/example_executor_only_rcl.c)\n+ament_target_dependencies(example_executor_only_rcl rcl rclc std_msgs)\n-  example_executor_convenience\n+  example_executor_only_rcl\n-The rclc_examples package provides examples for using the RCLC-Exector and convenience functions.\n-- [example_executor.c](src/example_executor.c) provides the example for the RCLC-Executor. It creates one publisher and one subscriber and configures the RCLC-Executor accordingly. Then the spin_some() function is demonstrated.\n-- [example_executor_convenience.c](src/example_executor_convenience.c) provides the example for the RCLC-Executor with the convenience functions from rclc. It creates one publisher and one subscriber and configures the RCLC-Executor accordingly. Then the spin_some() function is demonstrated.\n+The rclc_examples package provides examples for using the RCLC-Exector and convenience functions for creating RCL objects like subscriptions and timers. \n+\n+- [example_executor.c](src/example_executor.c) provides the example for the RCLC-Executor with the convenience functions from rclc. It creates one publisher and one subscriber and configures the RCLC-Executor accordingly.\n-- [example_short_timer_long_subscription.c](src/example_client_node.c) demo with high frequency timer and subscription with long processing time with one executor.\n+- [example_executor_only_rcl.c](src/example_executor_only_rcl.c) provides the example for the RCLC-Executor. It creates one publisher and one subscriber and configures the RCLC-Executor using only the RCL API.\n+- [example_short_timer_long_subscription.c](src/example_short_timer_long_subscription.c) demo with high frequency timer and subscription with long processing time with one executor.\n+\n-## Example RCLC-Executor using RCL objects directly\n+## Example RCLC-Executor\n-~$ source /opt/ros/$ROSDISTRO/setup.bash\n+~$ source /opt/ros/ROSDISTRO/setup.bash\n-Download and build the the packages `rclc` and `rclc_examples` in a workspace (for example `ros2_ws`). Then source the workspace:\n+Download and build the rclc repository in a workspace (for example `ros2_ws`). Then source the workspace:\n-It should build these packages:\n-- rcl_yaml_param_parser\n-- rcl\n... [truncated] ...\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init() \n+  // for more details. \n-  rclc_executor_init(&executor, &support.context, num_handles, &allocator);\n+  rclc_executor_init(&executor, &context, num_handles, &allocator);\n+\n+  // set timeout for rcl_wait()\n+  unsigned int rcl_wait_timeout = 1000;   // in ms\n+  rc = rclc_executor_set_timeout(&executor, RCL_MS_TO_NS(rcl_wait_timeout));\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error in rclc_executor_set_timeout.\");\n+  }\n-  // Optional prepare for avoiding allocations during spin\n-  rclc_executor_prepare(&executor);\n+  rclc_executor_spin(&executor);\n-  for (unsigned int i = 0; i < 10; i++) {\n-    // timeout specified in nanoseconds (here 1s)\n-    rclc_executor_spin_some(&executor, 1000 * (1000 * 1000));\n-  }\n-\n-  // clean up\n+  // clean up (never reached)\n-  rc += rclc_support_fini(&support);\n-\n+  rc += rcl_init_options_fini(&init_options);",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "220ba6fc20496c902804f7589455477dfd21705c",
    "RawMessage": "ament_export_dependencies any package with targets we linked against (#89)",
    "Changes": "-# Export rcl_logging_interface to give downstream packages access to it's headers\n+ament_export_dependencies(rcpputils)\n+ament_export_dependencies(rcutils)\n+ament_export_dependencies(spdlog_vendor)\n+ament_export_dependencies(spdlog)",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "2052e4888799efe5c552a8a002b4e7aadef6d090",
    "RawMessage": "Re-implemented setName for tools (#989)",
    "Changes": "+  /// Emitted when name property has been changed.\n+  void nameChanged(const QString & name);\n+  /// React to name changes of a tool, updating the name of the associated QAction\n+  void onToolNameChanged(const QString & name);\n+\n+\n+  Q_EMIT nameChanged(name_);\n+\n+  QObject::connect(\n+    tool, &Tool::nameChanged, this,\n+    &VisualizationFrame::VisualizationFrame::onToolNameChanged);\n+}\n+\n+void VisualizationFrame::onToolNameChanged(const QString & name)\n+{\n+  // Early return if the tool is not present\n+  auto it = tool_to_action_map_.find(qobject_cast<Tool *>(sender()));\n+  if (it == tool_to_action_map_.end()) {\n+    return;\n+  }\n+\n+  // Change the name of the action\n+  it->second->setIconText(name);",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "ad0c2a881c42e12840eaff337a5ca9db5bca3b47",
    "RawMessage": "resolve #790 (#801)",
    "Changes": "-from setuptools import setup\n+from setuptools import find_packages, setup\n-    packages=[package_name],\n+    packages=find_packages(exclude=['test']),",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "b56a55864a6ec714baa2a9d23269063a3680b20f",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#73)",
    "Changes": "-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories) of the ROS2 developer guide.\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html) of the ROS2 developer guide.\n-`rcl_logging_spdlog` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rcl_logging_spdlog` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rcl_logging_spdlog` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n+`rcl_logging_spdlog` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process).\n-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-Following the recommended guidelines in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) all pull requests must have at least 1 peer review.\n+Following the recommended guidelines in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) all pull requests must have at least 1 peer review.\n-`rcl_logging_spdlog` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcl_logging_spdlog` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_logging_rcl_logging_spdlog_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_logging_rcl_logging_spdlog_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcl_logging_spdlog` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcl_logging_spdlog` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcl_logging_spdlog` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n+`rcl_logging_spdlog` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "2052e4888799efe5c552a8a002b4e7aadef6d090",
    "RawMessage": "Re-implemented setName for tools (#989)",
    "Changes": "+  /// Emitted when name property has been changed.\n+  void nameChanged(const QString & name);\n+  /// React to name changes of a tool, updating the name of the associated QAction\n+  void onToolNameChanged(const QString & name);\n+\n+\n+  Q_EMIT nameChanged(name_);\n+\n+  QObject::connect(\n+    tool, &Tool::nameChanged, this,\n+    &VisualizationFrame::VisualizationFrame::onToolNameChanged);\n+}\n+\n+void VisualizationFrame::onToolNameChanged(const QString & name)\n+{\n+  // Early return if the tool is not present\n+  auto it = tool_to_action_map_.find(qobject_cast<Tool *>(sender()));\n+  if (it == tool_to_action_map_.end()) {\n+    return;\n+  }\n+\n+  // Change the name of the action\n+  it->second->setIconText(name);",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "289d7d32117c7ba9d7f2fec58f53f3ee2ed9cf2a",
    "RawMessage": "Bugfix/duration to msg precision (#876)",
    "Changes": "+from rclpy.constants import S_TO_NS\n+    \"\"\"A period between two time points, with nanosecond precision.\"\"\"\n-        total_nanoseconds = int(seconds * 1e9)\n+        \"\"\"\n+        Create an instance of :class:`Duration`, combined from given seconds and nanoseconds.\n+\n+        :param seconds: Time span seconds, if any, fractional part will be included.\n+        :param nanoseconds: Time span nanoseconds, if any, fractional part will be discarded.\n+        \"\"\"\n+        total_nanoseconds = int(seconds * S_TO_NS)\n-        seconds = int(self.nanoseconds * 1e-9)\n-        nanoseconds = int(self.nanoseconds % 1e9)\n+        \"\"\"\n+        Get duration as :class:`builtin_interfaces.msg.Duration`.\n+\n+        :returns: duration as message\n+        :rtype: builtin_interfaces.msg.Duration\n+        \"\"\"\n+        seconds, nanoseconds = divmod(self.nanoseconds, S_TO_NS)\n+        \"\"\"\n+        Create an instance of :class:`Duration` from a duration message.\n+\n+        :param msg: An instance of :class:`builtin_interfaces.msg.Duration`.\n+        \"\"\"",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "c7d3204aad16b6d9f10d2b2dd26a04d5d88f6b23",
    "RawMessage": "XMLRPC server accepts request from all local IP addresses. (#729)",
    "Changes": "+import netifaces\n+\n+\n+def get_local_ipaddrs():\n+    iplist = []\n+    interfaces = netifaces.interfaces()\n+    for interface in interfaces:\n+        addrs = netifaces.ifaddresses(interface)\n+        if netifaces.AF_INET in addrs.keys():\n+            for value in addrs[netifaces.AF_INET]:\n+                iplist.append(value['addr'])\n+    return iplist\n+\n-        if client_address[0] != '127.0.0.1':\n+        if client_address[0] not in get_local_ipaddrs():",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "4d97b4ecf0ae5ae42a4ed7e41cffcacb51a85219",
    "RawMessage": "Fix automatically declared parameters descriptor type. (#853)",
    "Changes": "-        if automatically_declare_parameters_from_overrides:\n-            self._parameters.update(self._parameter_overrides)\n-            self._descriptors.update({p: ParameterDescriptor() for p in self._parameters})\n-\n+        if automatically_declare_parameters_from_overrides:\n+            self.declare_parameters(\n+                '',\n+                [\n+                    (name, param.value, ParameterDescriptor())\n+                    for name, param in self._parameter_overrides.items()],\n+                ignore_override=True,\n+            )\n+\n-                    raise TypeError('The given value is not a list of one of the allowed types.')\n+                    raise TypeError(\n+                        'The given value is not a list of one of the allowed types'\n+                        f\" '{parameter_value}'.\")\n-                raise TypeError('The given value is not one of the allowed types.')\n+                raise TypeError(\n+                    f\"The given value is not one of the allowed types '{parameter_value}'.\")",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "ca59b6f243d76f4e54729610f29fa097a77fe0fa",
    "RawMessage": "Add underscores to material names (#811)",
    "Changes": "-      default_material_->getName() + std::to_string(material_count++) + \"Robot\";\n+      default_material_->getName() + \"_\" + std::to_string(material_count++) + \"Robot\";\n-      default_material_->getName() + std::to_string(material_count++) + \"Robot\";\n+      default_material_->getName() + \"_\" + std::to_string(material_count++) + \"Robot\";\n-        sub_material_name + std::to_string(material_count++) + \"Robot\";\n+        sub_material_name + \"_\" + std::to_string(material_count++) + \"Robot\";",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_dynamic_typesupport",
    "SHA": "88e2d7dd2e357283ffbaf3184786281bbca4af4b",
    "RawMessage": "uchar: use __has_include(..) on separate line (#8)",
    "Changes": "-#elif defined(__has_include) && __has_include(<uchar.h>)\n+#elif defined(__has_include)\n+#  if __has_include(<uchar.h>)\n-#  include <uchar.h>\n+#    include <uchar.h>\n+#  endif",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "64f1fd960a09f812280afafa2bcd8cd82f9b94f1",
    "RawMessage": "Bump graph API test coverage. (#132)",
    "Changes": "+\n+    ament_add_gtest(test_graph_api${target_suffix}\n+      test/test_graph_api.cpp\n+      ENV ${rmw_implementation_env_var}\n+      TIMEOUT 120\n+    )\n+    target_compile_definitions(test_graph_api${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_graph_api${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation\n+    )\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n... [truncated] ...\n+\n+  // A null node is an invalid argument.\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_count_subscribers(nullptr, topic_name, &count));\n+  rmw_reset_error();\n+\n+  // A node from a different implementation cannot be used to query.\n+  const char * implementation_identifier = node->implementation_identifier;\n+  node->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, rmw_count_subscribers(node, topic_name, &count));\n+  node->implementation_identifier = implementation_identifier;\n+  rmw_reset_error();\n+\n+  // A null topic name is an invalid argument.\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_count_subscribers(node, nullptr, &count));\n+  rmw_reset_error();\n+\n+  // An invalid topic name is an invalid argument.\n+  constexpr char invalid_topic_name[] = \"not a valid topic name !\";\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_count_subscribers(node, invalid_topic_name, &count));\n+  rmw_reset_error();\n+\n+  // A null count is an invalid argument.\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_count_subscribers(node, topic_name, nullptr));\n+  rmw_reset_error();\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "1760f4adad4d3b3cb3173ec951c5324def833c16",
    "RawMessage": "Correct the license content (#979)",
    "Changes": "-# limitations under the License.import time\n+# limitations under the License.",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "geometry2",
    "SHA": "a17a2bf8297052d2c6a404f9799bfe3b81040482",
    "RawMessage": "[cache_unittest] Add direct implementation testing on ordering, pruning (#678)",
    "Changes": "-/** \\brief A class to keep a sorted linked list in time\n+/** \\brief A class to keep a sorted linked list in time (newest first, oldest\n+ * last).\n-  /// Maximum length of linked list, to make sure not to be able to use unlimited memory.\n-  TF2_PUBLIC\n-  static const unsigned int MAX_LENGTH_LINKED_LIST = 1000000;\n+protected:\n+  // (Internal) Return a reference to the internal list of tf2 frames, which\n+  // are sorted in timestamp order.\n+  // Any items with the same timestamp will be in reverse order of insertion.\n+  TF2_PUBLIC\n+  const std::list<TransformStorage> & getAllItems() const;\n+\n+#include <list>\n+const std::list<TransformStorage> & TimeCache::getAllItems() const\n+{\n+  return storage_;\n+}\n+\n+#include <sstream>\n+class TimeCacheInternal : public tf2::TimeCache\n+{\n+public:\n+  using tf2::TimeCache::TimeCache;\n+  using tf2::TimeCache::getAllItems;\n... [truncated] ...\n+\n+  cache.insertData(item_h);\n+  cache.insertData(item_i);\n+  cache.insertData(item_j);\n+\n+  const std::list<tf2::TransformStorage> & storage_expected_new{\n+    item_h,\n+    item_b,\n+    item_g,\n+    item_f,\n+    item_e,\n+    item_j,\n+    item_c};\n+  // item_a, item_d, and item_i are pruned.\n+  const std::list<tf2::TransformStorage> storage_new = cache.getAllItems();\n+  EXPECT_EQ(storage_new, storage_expected_new)\n+    << \"storage_new: \" << listToMakeItemStrings(storage_new) << \"\\n\"\n+    << \"storage_expected_new: \" << listToMakeItemStrings(storage_expected_new) << \"\\n\";\n+}\n+\n+  EXPECT_EQ(cache.getListLength(), runs - 1);\n+  EXPECT_EQ(cache.getListLength(), runs);\n+  EXPECT_EQ(cache.getListLength(), 1);\n+  // Exact repeated element, should not grow in length.\n+  EXPECT_EQ(cache.getListLength(), 1);",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "652df5a3bc8bb281c305228eff343574bd1d4287",
    "RawMessage": "Adjust minimum dds version",
    "Changes": "-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "35a13206dbaf1b69ea89f562970481723244642c",
    "RawMessage": "Revise for lint",
    "Changes": "-  \n+\n-  dds_ReturnCode_t ret = dds_DataWriter_wait_for_acknowledgments(publisher_info->topic_writer, &timeout);\n+  dds_ReturnCode_t ret = dds_DataWriter_wait_for_acknowledgments(\n+    publisher_info->topic_writer, &timeout);\n-  if (ret == dds_RETCODE_OK)\n+  if (ret == dds_RETCODE_OK) {\n-  else if (ret == dds_RETCODE_TIMEOUT)\n+  } else if (ret == dds_RETCODE_TIMEOUT) {\n-  else\n+  } else {\n+  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "1ea3e191b7fd284718412d97c6ffe34f4bd79fbd",
    "RawMessage": "Enhanced rpc with sampleinfoex",
    "Changes": "-  uint64_t guid_temp = 0;\n+  uint8_t client_guid[16] = {0};\n-  // Random values are required for GUID\n-  std::random_device rd;\n-  std::default_random_engine dre(rd());\n-  std::uniform_int_distribution<uint64_t> uniform_dist(\n-    (std::numeric_limits<uint64_t>::min)(),\n-    (std::numeric_limits<uint64_t>::max)());\n-\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid, &guid_temp, sizeof(guid_temp));\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid + sizeof(guid_temp), &guid_temp, sizeof(guid_temp));\n+  dds_DataWriter_get_guid(request_writer, client_guid);\n+  memcpy(client_info->writer_guid, client_guid, sizeof(client_guid));\n+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+\n-  void * dds_request = allocate_request(\n... [truncated] ...\n+ros_guid_to_dds_guid(int8_t * guid_ros, int8_t * guid_dds)\n+{\n+  memcpy(guid_dds, guid_ros, 12);\n+  memcpy(&guid_dds[12], &guid_ros[12], 4);\n+}\n+\n+inline void\n+dds_guid_to_ros_guid(int8_t * guid_dds, int8_t * guid_ros)\n+{\n+  memcpy(guid_ros, guid_dds, 12);\n+  memcpy(&guid_ros[12], &guid_dds[12], 4);\n+}\n+\n+inline void\n+ros_sn_to_dds_sn(int64_t sn_ros, uint64_t * sn_dds)\n+{\n+  *sn_dds = ((sn_ros) & 0xFFFFFFFF00000000LL) >> 32;\n+  *sn_dds = *sn_dds | ((sn_ros & 0x00000000FFFFFFFFLL) << 32);\n+}\n+\n+inline void\n+dds_sn_to_ros_sn(uint64_t sn_dds, int64_t * sn_ros)\n+{\n+  *sn_ros = ((sn_dds & 0x00000000FFFFFFFF) << 32) | ((sn_dds & 0xFFFFFFFF00000000) >> 32);\n+}",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "9138ad7a62cb3719f1d988987386660a9eccde46",
    "RawMessage": "Modify unnecessary code",
    "Changes": "+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-\n-  bool ignore_sample = false;\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  if (!sample_info->valid_data) {\n-    ignore_sample = true;\n-  }\n+  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (!ignore_sample) {\n+  if (sample_info->valid_data) {\n+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n... [truncated] ...\n-      ignore_sample = true;\n-    }\n-\n-    if (!ignore_sample) {\n+    if (sample_info->valid_data) {\n+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-\n-  bool ignore_sample = false;\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  if (!sample_info->valid_data) {\n-    ignore_sample = true;\n-  }\n+  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (!ignore_sample) {\n+  if (sample_info->valid_data) {",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "c7b394a061a99b2f8ba7c8438e3dd39b488ddc6f",
    "RawMessage": "rcl_send_response returns RCL_RET_TIMEOUT. (#1048)",
    "Changes": "+ * \\return #RCL_RET_TIMEOUT if a response reader is not ready yet, or\n+  rcl_ret_t ret;\n-  if (rmw_send_response(\n-      service->impl->rmw_handle, request_header, ros_response) != RMW_RET_OK)\n-  {\n+  ret = rmw_send_response(service->impl->rmw_handle, request_header, ros_response);\n+  if (ret != RMW_RET_OK) {\n+    if (ret == RMW_RET_TIMEOUT) {\n+      return RCL_RET_TIMEOUT;\n+    }\n-    rcl_ret_t ret = rcl_send_service_event_message(\n+    ret = rcl_send_service_event_message(",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "a17a2bf8297052d2c6a404f9799bfe3b81040482",
    "RawMessage": "[cache_unittest] Add direct implementation testing on ordering, pruning (#678)",
    "Changes": "-/** \\brief A class to keep a sorted linked list in time\n+/** \\brief A class to keep a sorted linked list in time (newest first, oldest\n+ * last).\n-  /// Maximum length of linked list, to make sure not to be able to use unlimited memory.\n-  TF2_PUBLIC\n-  static const unsigned int MAX_LENGTH_LINKED_LIST = 1000000;\n+protected:\n+  // (Internal) Return a reference to the internal list of tf2 frames, which\n+  // are sorted in timestamp order.\n+  // Any items with the same timestamp will be in reverse order of insertion.\n+  TF2_PUBLIC\n+  const std::list<TransformStorage> & getAllItems() const;\n+\n+#include <list>\n+const std::list<TransformStorage> & TimeCache::getAllItems() const\n+{\n+  return storage_;\n+}\n+\n+#include <sstream>\n+class TimeCacheInternal : public tf2::TimeCache\n+{\n+public:\n+  using tf2::TimeCache::TimeCache;\n+  using tf2::TimeCache::getAllItems;\n... [truncated] ...\n+\n+  cache.insertData(item_h);\n+  cache.insertData(item_i);\n+  cache.insertData(item_j);\n+\n+  const std::list<tf2::TransformStorage> & storage_expected_new{\n+    item_h,\n+    item_b,\n+    item_g,\n+    item_f,\n+    item_e,\n+    item_j,\n+    item_c};\n+  // item_a, item_d, and item_i are pruned.\n+  const std::list<tf2::TransformStorage> storage_new = cache.getAllItems();\n+  EXPECT_EQ(storage_new, storage_expected_new)\n+    << \"storage_new: \" << listToMakeItemStrings(storage_new) << \"\\n\"\n+    << \"storage_expected_new: \" << listToMakeItemStrings(storage_expected_new) << \"\\n\";\n+}\n+\n+  EXPECT_EQ(cache.getListLength(), runs - 1);\n+  EXPECT_EQ(cache.getListLength(), runs);\n+  EXPECT_EQ(cache.getListLength(), 1);\n+  // Exact repeated element, should not grow in length.\n+  EXPECT_EQ(cache.getListLength(), 1);",
    "BackportedTo": "iron",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "dcbcdd6cf483acf7682414f25cbad32670622dfc",
    "RawMessage": "fix: add rclcpp::shutdown (#1343)",
    "Changes": "-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "9a0c044ff08c89795fdfc66feb6cfe5fd3842f3a",
    "RawMessage": "Adjust topic hz and bw command description. (#987)",
    "Changes": "+        parser.description = (\n+            'Display bandwidth used by topic.\\n\\n'\n+            'note:\\n'\n+            '  This bandwidth reflects the receiving rate on subscription, '\n+            'which might be affected by platform resources and QoS configuration, '\n+            \"and may not exactly match the publisher's bandwidth.\"\n+        )\n-    \"\"\"Print the average publishing rate to screen.\"\"\"\n+    \"\"\"Print the average receiving rate to screen.\"\"\"\n+        parser.description = (\n+            'Print the average receiving rate to screen.\\n\\n'\n+            'note:\\n'\n+            '  This rate reflects the receiving rate on subscription, '\n+            'which might be affected by platform resources and QoS configuration, '\n+            \"and may not exactly match the publisher's rate.\"\n+        )",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "geometry2",
    "SHA": "62322b8fa74c90d144dfe32294f6670bf6cfe786",
    "RawMessage": "Enable Twist interpolator (#646)",
    "Changes": "+#include \"geometry_msgs/msg/velocity_stamped.hpp\"\n+  TF2_PUBLIC\n+  geometry_msgs::msg::VelocityStamped lookupVelocity(\n+    const std::string & tracking_frame, const std::string & observation_frame,\n+    const TimePoint & time, const tf2::Duration & averaging_interval) const;\n+\n+  /** \\brief Lookup the velocity of the moving_frame in the reference_frame\n+   * \\param reference_frame The frame in which to track\n+   * \\param moving_frame The frame to track\n+   * \\param time The time at which to get the velocity\n+   * \\param duration The period over which to average\n+   * \\param velocity The velocity output\n+   *\n+   * Possible exceptions TransformReference::LookupException, TransformReference::ConnectivityException,\n+   * TransformReference::MaxDepthException\n+   */\n+  TF2_PUBLIC\n+  geometry_msgs::msg::VelocityStamped lookupVelocity(\n+    const std::string & tracking_frame, const std::string & observation_frame,\n+    const std::string & reference_frame, const tf2::Vector3 & reference_point,\n+    const std::string & reference_point_frame,\n+    const TimePoint & time, const tf2::Duration & duration) const;\n+\n+#include <iostream>\n+\n... [truncated] ...\n+    EXPECT_NEAR(twist.velocity.linear.z, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.x, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.y, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.z, 1.0, epsilon);\n+\n+    check_time = tf2::timeFromSec(tf2::timeToSec(tf2_time_) + 5.5);\n+    twist = buffer_->lookupVelocity(\n+      \"bar\", \"stationary_offset_parent\", check_time, tf2::durationFromSec(\n+        0.1));\n+    EXPECT_NEAR(twist.velocity.linear.x, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.linear.y, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.linear.z, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.x, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.y, 0.0, epsilon);\n+    EXPECT_NEAR(twist.velocity.angular.z, -1.0, epsilon);\n+  } catch (tf2::TransformException & ex) {\n+    EXPECT_STREQ(\"\", ex.what());\n+  }\n+}\n+\n+int main(int argc, char ** argv)\n+{\n+  testing::InitGoogleTest(&argc, argv);\n+  return RUN_ALL_TESTS();\n+}",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "7780fa11f126495dd644f02cc8f81fe847abdfd8",
    "RawMessage": "Waitable should check callback_group if it can be executed. (#1001)",
    "Changes": "-                            handler = self._make_handler(\n-                                wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n-                            yielded_work = True\n-                            yield handler, wt, node\n+                            if wt.callback_group.can_execute(wt):\n+                                handler = self._make_handler(\n+                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n+                                yielded_work = True\n+                                yield handler, wt, node",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "ffcfda18db7aa9ad7c01ebdd26ae7bdd73c8206a",
    "RawMessage": "Improve wait sets test coverage. (#683)",
    "Changes": "+#include \"./allocator_testing_utils.h\"\n+\n+#ifndef _WIN32\n+#else\n+#define TOLERANCE RCL_MS_TO_NS(15)\n+#endif\n+TEST_F(CLASSNAME(WaitSetTestFixture, RMW_IMPLEMENTATION), test_failed_resize) {\n+  // Initialize a wait set with a subscription and then resize it to zero.\n+  rcl_allocator_t allocator = get_failing_allocator();\n+  rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();\n+  set_failing_allocator_is_failing(allocator, false);\n+  rcl_ret_t ret =\n+    rcl_wait_set_init(&wait_set, 1, 1, 1, 1, 1, 0, context_ptr, allocator);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  set_failing_allocator_is_failing(allocator, true);\n+  ret = rcl_wait_set_resize(&wait_set, 0, 1, 0, 0, 0, 0);\n+  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret);\n+  rcl_reset_error();\n+\n+  set_failing_allocator_is_failing(allocator, false);\n+  ret = rcl_wait_set_fini(&wait_set);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+}\n+\n... [truncated] ...\n+  });\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  rcl_timer_t timer = rcl_get_zero_initialized_timer();\n+  ret = rcl_timer_init(\n+    &timer, &clock, this->context_ptr, 0, nullptr, rcl_get_default_allocator());\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    ret = rcl_timer_fini(&timer);\n+    EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  });\n+  ret = rcl_wait_set_add_timer(&wait_set, &timer, NULL);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  // Time spent during wait should be negligible, definitely less than the given timeout\n+  std::chrono::steady_clock::time_point before_sc = std::chrono::steady_clock::now();\n+  ret = rcl_wait(&wait_set, RCL_MS_TO_NS(100));\n+  std::chrono::steady_clock::time_point after_sc = std::chrono::steady_clock::now();\n+  // We don't expect a timeout here (since the guard condition had already been triggered)\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  int64_t diff = std::chrono::duration_cast<std::chrono::nanoseconds>(after_sc - before_sc).count();\n+  EXPECT_LE(diff, RCL_MS_TO_NS(50));\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "65c9cba19438b67f86c0a2a475fb881410e01006",
    "RawMessage": "Add tests for non-implemented rmw_take_* functions (#131)",
    "Changes": "+\n+class CLASSNAME (TestSubscriptionUseLoan, RMW_IMPLEMENTATION)\n+  : public CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION)\n+{\n+protected:\n+  using Base = CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION);\n+\n+  void SetUp() override\n+  {\n+    Base::SetUp();\n+    // Check if loaning is supported by the implementation\n+    if (!sub->can_loan_messages) {\n+      bool taken = false;\n+      void * loaned_message = nullptr;\n+      rmw_message_info_t message_info = rmw_get_zero_initialized_message_info();\n+      rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n+      rmw_ret_t ret = rmw_take_loaned_message(sub, &loaned_message, &taken, null_allocation);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, loaned_message);\n+      ret = rmw_take_loaned_message_with_info(\n+        sub, &loaned_message, &taken, &message_info, null_allocation);\n+      EXPECT_EQ(RMW_RET_UNSUPPORTED, ret) << rmw_get_error_string().str;\n+      rmw_reset_error();\n+      EXPECT_EQ(nullptr, loaned_message);\n... [truncated] ...\n+  void TearDown() override\n+  {\n+    Base::TearDown();\n+  }\n+};\n+\n+TEST_F(CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION), rmw_take_loaned_message) {\n+  // TODO(lobotuerk): add tests for rmw_take_loaned_message() when we have an implementation.\n+  FAIL() << \"Not implemented\";\n+}\n+\n+TEST_F(\n+  CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION), rmw_take_loaned_message_with_info) {\n+  // TODO(lobotuerk): add tests for rmw_take_loaned_message_with_info()\n+  // when we have an implementation.\n+  FAIL() << \"Not implemented\";\n+}\n+\n+TEST_F(\n+  CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION),\n+  rmw_return_loaned_message_from_subscription) {\n+  // TODO(lobotuerk): add tests for rmw_return_loaned_message_from_subscription()\n+  // when we have an implementation.\n+  FAIL() << \"Not implemented\";\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "launch_ros",
    "SHA": "3569f0d76c68884ca8796c0134bad29e8732d868",
    "RawMessage": "Autostarting lifecycle nodes and example launch file demo (#430)",
    "Changes": "+# Copyright 2024 Open Navigation LLC\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Launch a lifecycle talker and a lifecycle listener.\"\"\"\n+\n+import os\n+import sys\n+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))  # noqa\n+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'launch'))  # noqa\n+\n+import launch  # noqa: E402\n+import launch.actions  # noqa: E402\n+import launch.events  # noqa: E402\n+\n... [truncated] ...\n+\n+        # Create a subscription to monitor the state changes of the subprocess.\n+        self.__rclpy_subscription = node.create_subscription(\n+            lifecycle_msgs.msg.TransitionEvent,\n+            '{}/transition_event'.format(self.node_name),\n+            functools.partial(self._on_transition_event, context),\n+            10)\n+\n+        # Create a service client to change state on demand.\n+        self.__rclpy_change_state_client = node.create_client(\n+            lifecycle_msgs.srv.ChangeState,\n+            '{}/change_state'.format(self.node_name))\n+\n+        # Register an event handler to change states on a ChangeState lifecycle event.\n+        context.register_event_handler(launch.EventHandler(\n+            matcher=lambda event: isinstance(event, ChangeState),\n+            entities=[launch.actions.OpaqueFunction(function=self._on_change_state_event)],\n+        ))\n+    LifecycleNode(\n+        package='asd',\n+        executable='bsd',\n+        name='my_node',\n+        namespace='my_ns',\n+        autostart=True,\n+    )",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "211e7af5e4ec86daca7fd2cf5fbd6821e26ca2d9",
    "RawMessage": "Update return value",
    "Changes": "-  if (node == nullptr) {\n-    RMW_SET_ERROR_MSG(\"node handle is null\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (client == nullptr) {\n-    RMW_SET_ERROR_MSG(\"client handle is null\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node handle,\n+    node->implementation_identifier,\n+    gurum_gurumdds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n-    client->implementation_identifier, gurum_gurumdds_identifier,\n-    return RMW_RET_ERROR)\n+    client->implementation_identifier,\n+    gurum_gurumdds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-    return RMW_RET_ERROR)\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-    return RMW_RET_ERROR)\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n... [truncated] ...\n-  }\n-  if (node == nullptr) {\n-    RMW_SET_ERROR_MSG(\"node handle is nulll\");\n-    return RMW_RET_INVALID_ARGUMENT;\n-  }\n-  if (node->implementation_identifier != implementation_identifier) {\n-    RMW_SET_ERROR_MSG(\"node handle is not from this rmw implementation\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n+    allocator, \"allocator argument is invalid\", return RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    implementation_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  if (wait_set == nullptr) {\n-    RMW_SET_ERROR_MSG(\"wait set handle is null\");\n-    return RMW_RET_ERROR;\n-  }\n-\n+  RMW_CHECK_ARGUMENT_FOR_NULL(wait_set, RMW_RET_ERROR);\n-    implementation_identifier, return RMW_RET_ERROR);\n+    implementation_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "e06969487b81d97745f7c2da16372075ef153c1f",
    "RawMessage": "Set error status when duplicate markers are in the same MarkerArray (#891)",
    "Changes": "+#include <set>\n+#include <sstream>\n+  using ns_type = decltype(visualization_msgs::msg::Marker::ns);\n+  using id_type = decltype(visualization_msgs::msg::Marker::id);\n+  using pair_type = std::pair<id_type, const ns_type &>;\n+\n+  // Keep track of unique markers\n+  std::set<pair_type> unique_markers;\n+  bool found_duplicate = false;\n+  std::string offending_ns;\n+  id_type offending_id = 0;\n+\n+    if (!found_duplicate) {\n+      pair_type pair(marker.id, marker.ns);\n+      found_duplicate = !unique_markers.insert(pair).second;\n+      if (found_duplicate) {\n+        offending_ns = marker.ns;\n+        offending_id = marker.id;\n+      }\n+    }\n+\n+  // Can't use setMarkerStatus on individual markers because processAdd would clear it.\n+  const char * kDuplicateStatus = \"Duplicate Marker Check\";\n+  if (found_duplicate) {\n+    std::stringstream error_stream;\n+    error_stream << \"Multiple Markers in the same MarkerArray message had the same ns and id: \";\n+    error_stream << \"(\" << offending_ns << \", \" << offending_id << \")\";\n+    display_->setStatusStd(\n+      rviz_common::properties::StatusProperty::Error,\n+      kDuplicateStatus,\n+      error_stream.str());\n+  } else {\n+    display_->deleteStatusStd(kDuplicateStatus);\n+  }",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "58dae834fcb65103e20aaa07795827d051e661d9",
    "RawMessage": "add RCL_RET_TIMEOUT to action service response. (#1138)",
    "Changes": "+ * \\return `RCL_RET_TIMEOUT` if a goal response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a result response reader is not ready yet, or\n+ * \\return `RCL_RET_TIMEOUT` if a cancel response reader is not ready yet, or\n-    return RCL_RET_ERROR;  /* error already set */ \\\n+    if (RCL_RET_TIMEOUT == ret) { \\\n+      return RCL_RET_TIMEOUT;  /* error already set */ \\\n+    } else { \\\n+      return RCL_RET_ERROR;  /* error already set */ \\\n+    } \\",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "163f0700d0df30b58c95a300d255f834a3805b8c",
    "RawMessage": "Update publisher creation/destruction API documentation. (#252)",
    "Changes": "-/// Create and return an rmw publisher.\n+/// Create a publisher and return a handle to that publisher.\n- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n+ * This function can fail, and therefore return `NULL`, if:\n+ *   - node is not a valid non-null handle for this rmw implementation,\n+ *     as returned by `rmw_create_node()`\n+ *   - type_support is a not valid non-null message type support, as returned by\n+ *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n+ *   - topic_name is not a valid non-null topic name, according to\n+ *     `rmw_validate_full_topic_name()`\n+ *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n+ *   - publisher_options is not a valid non-null option set, as returned by\n+ *     `rmw_get_default_publisher_options()`\n+ *   - memory allocation fails during publisher creation\n+ *   - an unspecified error occurs\n- * The argument `publisher_options` must not be nullptr.\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n... [truncated] ...\n+/**\n+ * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.\n+ * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n+ * the publisher handle. Usage of a deallocated publisher handle is undefined behavior.\n+ *\n+ * \\pre Given node must be the one the publisher was registered with.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\param[in] node Handle to node with which the given publisher is registered\n+ * \\param[in] publisher Handle to publisher to be finalized\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher\n+ *   implementation identifier does not match, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs.\n+ */",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "b1ec23e69566f9451b629019bdaf4582db52a8cb",
    "RawMessage": "Add tests for rcl package (#668)",
    "Changes": "+rcl_add_custom_gtest(test_domain_id\n+  SRCS rcl/test_domain_id.cpp\n+  APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n+  LIBRARIES ${PROJECT_NAME}\n+)\n+\n+rcl_add_custom_gtest(test_localhost\n+  SRCS rcl/test_localhost.cpp\n+  APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n+  LIBRARIES ${PROJECT_NAME}\n+)\n+\n+rcl_add_custom_gtest(test_common\n+  SRCS rcl/test_common.cpp ${CMAKE_CURRENT_SOURCE_DIR}/../src/rcl/common.c\n+  APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n+  INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/../src/rcl/\n+  LIBRARIES ${PROJECT_NAME}\n+)\n+\n-/* Basic nominal test of a client.\n+/* Basic nominal test of a client. Complete functionality tested at test_service.cpp\n+  // Test access to client options\n+  const rcl_client_options_t * client_internal_options = rcl_client_get_options(&client);\n+  EXPECT_TRUE(rcutils_allocator_is_valid(&(client_internal_options->allocator)));\n+  EXPECT_EQ(rmw_qos_profile_services_default.reliability, client_internal_options->qos.reliability);\n... [truncated] ...\n+  rcl_allocator_t allocator_returned;\n+  rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();\n+\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_wait_set_get_allocator(nullptr, &allocator_returned)) << rcl_get_error_string().str;\n+  rcl_reset_error();\n+  EXPECT_EQ(\n+    RCL_RET_WAIT_SET_INVALID,\n+    rcl_wait_set_get_allocator(&wait_set, &allocator_returned)) << rcl_get_error_string().str;\n+  rcl_reset_error();\n+\n+  rcl_ret_t ret =\n+    rcl_wait_set_init(&wait_set, 1, 1, 1, 1, 1, 0, context_ptr, rcl_get_default_allocator());\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_wait_set_get_allocator(&wait_set, nullptr)) << rcl_get_error_string().str;\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_OK, rcl_wait_set_get_allocator(&wait_set, &allocator_returned));\n+  EXPECT_TRUE(rcutils_allocator_is_valid(&allocator_returned));\n+\n+  ret = rcl_wait_set_fini(&wait_set);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "b29efa999e838acd1ec92b5547905969338393e2",
    "RawMessage": "Drop build dependency on std_msgs (#314)",
    "Changes": "-find_package(std_msgs REQUIRED)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "87fbec0d6bbfda968d14689c977e9a6bdaa48886",
    "RawMessage": "publish action goal status once accepted before execution. (#1228)",
    "Changes": "+        # Publish accepted status before execution\n+        self._handle.publish_status()\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "ae8c885ada6a6497ea59c9a18fb4adb36746439e",
    "RawMessage": "Fix typo (#1104)",
    "Changes": "-          \"The link \" << link->name << \" is has unrealistic \"\n+          \"The link \" << link->name << \" has unrealistic \"",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "2653cc44304eb760e5d7222ee50b3362c1a1ab1a",
    "RawMessage": "Improve clock test coverage. (#685)",
    "Changes": "+#include \"./allocator_testing_utils.h\"\n+\n-  rcl_allocator_t allocator = rcl_get_default_allocator();\n-  auto * ros_clock =\n-    static_cast<rcl_clock_t *>(allocator.allocate(sizeof(rcl_clock_t), allocator.state));\n-  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-  {\n-    allocator.deallocate(ros_clock, allocator.state);\n-  });\n-  rcl_ret_t retval = rcl_ros_clock_init(ros_clock, &allocator);\n-  ASSERT_EQ(retval, RCL_RET_OK) << rcl_get_error_string().str;\n-  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-  {\n-    EXPECT_EQ(RCL_RET_OK, rcl_ros_clock_fini(ros_clock)) << rcl_get_error_string().str;\n-  });\n-  EXPECT_TRUE(ros_clock != nullptr);\n-  EXPECT_TRUE(ros_clock->data != nullptr);\n-  EXPECT_EQ(ros_clock->type, RCL_ROS_TIME);\n-\n+  rcl_reset_error();\n-  rcl_allocator_t allocator = rcl_get_default_allocator();\n-  auto * ros_clock =\n-    static_cast<rcl_clock_t *>(allocator.allocate(sizeof(rcl_clock_t), allocator.state));\n-  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-  {\n... [truncated] ...\n-    RCL_RET_OK, rcl_clock_init(\n-      RCL_CLOCK_UNINITIALIZED, &ros_clock, &allocator)) << rcl_get_error_string().str;\n+\n+  rcl_clock_t ros_clock;\n+  rcl_allocator_t allocator = rcl_get_default_allocator();\n+  rcl_ret_t ret = rcl_clock_init(RCL_CLOCK_UNINITIALIZED, &ros_clock, &allocator);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_enable_ros_time_override(&ros_clock));\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_disable_ros_time_override(&ros_clock));\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_is_enabled_ros_time_override(&ros_clock, &result));\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_set_ros_time_override(&ros_clock, set_point));\n+  rcl_reset_error();\n+\n+  ret = rcl_clock_init(RCL_ROS_TIME, &ros_clock, &allocator);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  ret = rcl_clock_fini(&ros_clock);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  rcl_reset_error();\n+  rcl_reset_error();\n+  rcl_reset_error();\n+  rcl_reset_error();",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "6040298b429784ca9eb4d0404543d6211fd5f81d",
    "RawMessage": "Fix mem leaks in unit test from 776 (#779)",
    "Changes": "+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n... [truncated] ...\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n-  // No cleanup, rcl_parse_yaml_file takes care of that if it fails.\n-    if (res) {\n-      // This is already freed in the case of a non-ok error in rcl_parse_yaml_file\n-      rcl_yaml_node_struct_fini(params_hdl);\n-      params_hdl = NULL;\n-    }\n+    (void)res;\n+    rcl_yaml_node_struct_fini(params_hdl);\n+    params_hdl = NULL;\n-    if (res) {\n-      // This is already freed in the case of a non-ok error in rcl_parse_yaml_file\n-      rcl_yaml_node_struct_fini(params_hdl);\n-      params_hdl = NULL;\n-    }\n+    (void)res;\n+    rcl_yaml_node_struct_fini(params_hdl);\n+    params_hdl = NULL;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "56ee3c12187043443b72f412c7fa90c714784fd9",
    "RawMessage": "rclc_parameter: Fix rcl return values (#270)",
    "Changes": "-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-  ret &= rclc_parameter_server_init_service(\n+  ret |= rclc_parameter_server_init_service(\n-    ret &= rclc_publisher_init(\n+    ret |= rclc_publisher_init(\n-  ret &= rcl_service_fini(&parameter_server->list_service, node);\n-  ret &= rcl_service_fini(&parameter_server->set_service, node);\n-  ret &= rcl_service_fini(&parameter_server->get_service, node);\n-  ret &= rcl_service_fini(&parameter_server->get_types_service, node);\n-  ret &= rcl_service_fini(&parameter_server->describe_service, node);\n+  ret |= rcl_service_fini(&parameter_server->list_service, node);\n+  ret |= rcl_service_fini(&parameter_server->set_service, node);\n+  ret |= rcl_service_fini(&parameter_server->get_service, node);\n+  ret |= rcl_service_fini(&parameter_server->get_types_service, node);\n+  ret |= rcl_service_fini(&parameter_server->describe_service, node);\n-    ret &= rcl_publisher_fini(&parameter_server->event_publisher, node);\n+    ret |= rcl_publisher_fini(&parameter_server->event_publisher, node);\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rclc_executor_add_service_with_context(\n+  ret |= rclc_executor_add_service_with_context(\n-  ret &= rcutils_system_time_now(&now);\n+  ret |= rcutils_system_time_now(&now);\n-  ret &= rcl_publish(\n+  ret |= rcl_publish(",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw",
    "SHA": "518716cf1047ee15d46be119b1c23e797d7056ee",
    "RawMessage": "Add fault injection macros for use in other packages (#254)",
    "Changes": "+\n+if(BUILD_TESTING AND NOT RCUTILS_DISABLE_FAULT_INJECTION)\n+  target_compile_definitions(${PROJECT_NAME} PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+endif()\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_BAD_ALLOC);\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_BAD_ALLOC);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RMW_RET_INVALID_ARGUMENT);\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "51e576c5289a5d231f89c7593ded84c6ddade22f",
    "RawMessage": "Initialize more of the visualization_manager members. (#1090)",
    "Changes": "+  wall_clock_elapsed_(0),\n+  ros_time_elapsed_(0),",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "64d216cb8fafef83d046b79ee6294afb06b7c595",
    "RawMessage": "ros2cli.node.daemon : try getting fdsize from /proc for open fd limit (#888)",
    "Changes": "-        import resource\n-        soft, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n-        for i in range(3, soft):\n+        # Some unices have a high soft_limit; read fdsize if available.\n+        fdlimit = None\n+        try:\n+            string_to_find = 'FDSize:'\n+            with open('/proc/self/status', 'r') as f:\n+                for line in f:\n+                    if line.startswith(string_to_find):\n+                        fdlimit = int(line.removeprefix(string_to_find).strip())\n+                        break\n+        except (FileNotFoundError, ValueError):\n+            pass\n+        # The soft limit might be quite high on some systems.\n+        if fdlimit is None:\n+            import resource\n+            fdlimit, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n+        for i in range(3, fdlimit):",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "72b54facd486eb9feb790ba9a997b05019b08eda",
    "RawMessage": "Add time jump handler (#752) (#791)",
    "Changes": "-  /// Resets the wall and ROS elapsed time to zero and calls resetDisplays().\n-  void resetTime();\n-\n+public Q_SLOTS:\n+  /// Resets the wall and ROS elapsed time to zero and calls resetDisplays().\n+  void resetTime();\n+\n+  /// Emitted after time jump was detected.\n+  void timeJumped();\n+\n+  /// Called when ROS detects a time jump.\n+  void onTimeJump(const rcl_time_jump_t & time_jump);\n+\n+  rclcpp::JumpHandler::SharedPtr clock_jump_handler_;\n+  rcl_jump_threshold_t jump_threshold;\n+  jump_threshold.on_clock_change = true;\n+  // Disable forward jump callbacks\n+  jump_threshold.min_forward.nanoseconds = 0;\n+  // Anything backwards is a jump\n+  jump_threshold.min_backward.nanoseconds = -1;\n+  clock_jump_handler_ = clock_->create_jump_callback(\n+    nullptr, std::bind(\n+      &VisualizationManager::onTimeJump, this,\n+      std::placeholders::_1), jump_threshold);\n+\n+  connect(this, SIGNAL(timeJumped()), this, SLOT(resetTime()));\n+\n+void VisualizationManager::onTimeJump(const rcl_time_jump_t & jump)\n+{\n+  if (jump.clock_change == RCL_ROS_TIME_ACTIVATED ||\n+    jump.clock_change == RCL_ROS_TIME_DEACTIVATED)\n+  {\n+    RVIZ_COMMON_LOG_WARNING(\"Detected time source change. Resetting RViz.\");\n+    Q_EMIT timeJumped();\n+  } else if (jump.delta.nanoseconds < 0) {\n+    RVIZ_COMMON_LOG_WARNING_STREAM(\n+      \"Detected jump back in time. Resetting RViz.\");\n+    Q_EMIT timeJumped();\n+  }\n+}\n+",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "ce4296879a08794ff701978fac45eb885ab9e40c",
    "RawMessage": "Fix enum naming for avoid collision (#242)",
    "Changes": "-  SUBSCRIPTION,\n-  SUBSCRIPTION_WITH_CONTEXT,\n-  TIMER,\n-  // TIMER_WITH_CONTEXT,  // TODO\n-  CLIENT,\n-  CLIENT_WITH_REQUEST_ID,\n-  // CLIENT_WITH_CONTEXT,  // TODO\n-  SERVICE,\n-  SERVICE_WITH_REQUEST_ID,\n-  SERVICE_WITH_CONTEXT,\n-  ACTION_CLIENT,\n-  ACTION_SERVER,\n-  GUARD_CONDITION,\n-  // GUARD_CONDITION_WITH_CONTEXT,  //TODO\n-  NONE\n+  RCLC_SUBSCRIPTION,\n+  RCLC_SUBSCRIPTION_WITH_CONTEXT,\n+  RCLC_TIMER,\n+  // RCLC_TIMER_WITH_CONTEXT,  // TODO\n+  RCLC_CLIENT,\n+  RCLC_CLIENT_WITH_REQUEST_ID,\n+  // RCLC_CLIENT_WITH_CONTEXT,  // TODO\n+  RCLC_SERVICE,\n+  RCLC_SERVICE_WITH_REQUEST_ID,\n+  RCLC_SERVICE_WITH_CONTEXT,\n... [truncated] ...\n+      // case RCLC_CLIENT_WITH_CONTEXT:\n-    case SERVICE:\n-    case SERVICE_WITH_REQUEST_ID:\n-    case SERVICE_WITH_CONTEXT:\n+    case RCLC_SERVICE:\n+    case RCLC_SERVICE_WITH_REQUEST_ID:\n+    case RCLC_SERVICE_WITH_CONTEXT:\n-    case GUARD_CONDITION:\n-      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case RCLC_GUARD_CONDITION:\n+      // case RCLC_GUARD_CONDITION_WITH_CONTEXT:\n-    case NONE:\n+    case RCLC_NONE:\n-  EXPECT_EQ(handle.type, NONE);\n+  EXPECT_EQ(handle.type, RCLC_NONE);\n-  handle.type = SUBSCRIPTION;\n+  handle.type = RCLC_SUBSCRIPTION;\n-  handle.type = TIMER;\n+  handle.type = RCLC_TIMER;\n-  handle.type = CLIENT;\n+  handle.type = RCLC_CLIENT;\n-  handle.type = SERVICE;\n+  handle.type = RCLC_SERVICE;\n-  handle.type = GUARD_CONDITION;\n+  handle.type = RCLC_GUARD_CONDITION;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "04f56a8867271c16cb52502ff2c792b56c13de39",
    "RawMessage": "Remove unused headers MessageTypeSupport.hpp and ServiceTypeSupport.hpp (#481)",
    "Changes": "-// Copyright 2016-2018 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#ifndef RMW_FASTRTPS_SHARED_CPP__MESSAGETYPESUPPORT_HPP_\n-#define RMW_FASTRTPS_SHARED_CPP__MESSAGETYPESUPPORT_HPP_\n-\n-#include <fastcdr/FastBuffer.h>\n-#include <fastcdr/Cdr.h>\n-\n-#include <cassert>\n-#include <memory>\n-\n-#include \"rmw_fastrtps_shared_cpp/TypeSupport.hpp\"\n-\n... [truncated] ...\n-\n-template<typename MembersType>\n-class ServiceTypeSupport : public TypeSupport<MembersType>\n-{\n-protected:\n-  ServiceTypeSupport();\n-};\n-\n-template<typename ServiceMembersType, typename MessageMembersType>\n-class RequestTypeSupport : public ServiceTypeSupport<MessageMembersType>\n-{\n-public:\n-  explicit RequestTypeSupport(const ServiceMembersType * members);\n-};\n-\n-template<typename ServiceMembersType, typename MessageMembersType>\n-class ResponseTypeSupport : public ServiceTypeSupport<MessageMembersType>\n-{\n-public:\n-  explicit ResponseTypeSupport(const ServiceMembersType * members);\n-};\n-\n-}  // namespace rmw_fastrtps_shared_cpp\n-\n-#endif  // RMW_FASTRTPS_SHARED_CPP__SERVICETYPESUPPORT_HPP_",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "7fa69bc5a66c9c81d6d839dfa4078beeae4c1762",
    "RawMessage": "Load composable nodes in sequence (#315)",
    "Changes": "-        _load_composable_node(\n-            package='foo_package',\n-            plugin='bar_plugin',\n-            name='node_1',\n-            namespace='ns_1',\n-            parameters=[\n-                parameters_file_dir / 'example_parameters_multiple_entries.yaml'\n-            ],\n-        ),\n-        _load_composable_node(\n-            package='foo_package',\n-            plugin='bar_plugin',\n-            name='node_2',\n-            namespace='ns_2',\n-            parameters=[\n-                parameters_file_dir / 'example_parameters_multiple_entries.yaml'\n-            ],\n+        LoadComposableNodes(  # Load in same action so it happens sequentially\n+            target_container=f'/{TEST_CONTAINER_NAME}',\n+            composable_node_descriptions=[\n+                ComposableNode(\n+                    package='foo_package',\n+                    plugin='bar_plugin',\n+                    name='node_1',\n+                    namespace='ns_1',\n+                    parameters=[\n+                        parameters_file_dir / 'example_parameters_multiple_entries.yaml'\n+                    ]\n+                ),\n+                ComposableNode(\n+                    package='foo_package',\n+                    plugin='bar_plugin',\n+                    name='node_2',\n+                    namespace='ns_2',\n+                    parameters=[\n+                        parameters_file_dir / 'example_parameters_multiple_entries.yaml'\n+                    ]\n+                )\n+            ]",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "d37bbc53f4fb6c9d207af0bc5f194b31bb8a3183",
    "RawMessage": "Disable a Windows platform warning. (#311)",
    "Changes": "+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+\n+#pragma warning(push)\n+#pragma warning(disable : 5105)\n+#pragma warning(pop)\n+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)\n+#pragma warning(pop)\n+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n... [truncated] ...\n+#pragma warning(push)\n+#pragma warning(disable : 5105)\n+#pragma warning(pop)\n+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)\n+#pragma warning(pop)\n+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)\n+#pragma warning(pop)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "27b4d4fc30149339da50376acd08893141748aa5",
    "RawMessage": "executor ignore canceled timers (#220)",
    "Changes": "+\n+        // cancled timer are not handled, return success\n+        if (rc == RCL_RET_TIMER_CANCELED) {\n+          rc = RCL_RET_OK;\n+          break;\n+        }\n+\n+TEST_F(TestDefaultExecutor, executor_spin_publisher_timer_cancelled) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  unsigned int expected_msg;\n+\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  _executor_results_init();\n+\n+  rc = rclc_executor_add_subscription(\n+    &executor, &this->sub1, &this->sub1_msg,\n+    &CALLBACK_1, ON_NEW_DATA);\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+\n+  for (unsigned int i = 0; i < TC_SPIN_SOME_PUBLISHED_MSGS; i++) {\n+    rc = rcl_publish(&this->pub1, &this->pub1_msg, nullptr);\n... [truncated] ...\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+    if (i > spin_repeat / 2) {\n+      rc = rcl_timer_cancel(&this->timer1);\n+      EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+    }\n+  }\n+\n+  EXPECT_LT(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "4848995faa921ea8599de908469d66f1d1c4420b",
    "RawMessage": "Add wildcard loading to ros2 param load (#602)",
    "Changes": "-def load_parameter_file(*, node, node_name, parameter_file):\n+def load_parameter_file(*, node, node_name, parameter_file, use_wildcard):\n-        if node_name not in param_file:\n+        param_keys = []\n+        if use_wildcard and '/**' in param_file:\n+            param_keys.append('/**')\n+        if node_name in param_file:\n+            param_keys.append(node_name)\n+\n+        if param_keys == []:\n-\n-        value = param_file[node_name]\n-        if type(value) != dict or 'ros__parameters' not in value:\n-            raise RuntimeError('Invalid structure of parameter file for node {}'\n-                               'expected same format as provided by ros2 param dump'\n-                               .format(node_name))\n-        load_parameter_dict(node=node, node_name=node_name,\n-                            parameter_dict=value['ros__parameters'])\n+        param_dict = {}\n+        for k in param_keys:\n+            value = param_file[k]\n+            if type(value) != dict or 'ros__parameters' not in value:\n+                raise RuntimeError('Invalid structure of parameter file for node {}'\n+                                   'expected same format as provided by ros2 param dump'\n+                                   .format(k))\n... [truncated] ...\n+            loaded_params = yaml.safe_load(param_dump_command.output)\n+            params = loaded_params[f'{TEST_NAMESPACE}/{TEST_NODE}']['ros__parameters']\n+            assert params['str_param'] == 'Wildcard'\n+            assert params['int_param'] == 12345\n+\n+            # Concatenate wildcard + some overlays\n+            filepath = self._write_param_file(tmpdir, 'params.yaml',\n+                                              INPUT_WILDCARD_PARAMETER_FILE + '\\n' +\n+                                              INPUT_NODE_OVERLAY_PARAMETER_FILE)\n+            with self.launch_param_load_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', filepath]\n+            ) as param_load_command:\n+                assert param_load_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_load_command.exit_code == launch_testing.asserts.EXIT_OK\n+\n+            # Dump and check that wildcard parameters were overriden if in node namespace\n+            with self.launch_param_dump_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', '--print']\n+            ) as param_dump_command:\n+                assert param_dump_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_dump_command.exit_code == launch_testing.asserts.EXIT_OK\n+            loaded_params = yaml.safe_load(param_dump_command.output)\n+            params = loaded_params[f'{TEST_NAMESPACE}/{TEST_NODE}']['ros__parameters']\n+            assert params['str_param'] == 'Override'  # Overriden\n+            assert params['int_param'] == 12345  # Wildcard namespace",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "361fcdf6574eefb61ec82e50a7b82231394c3e41",
    "RawMessage": "removed build status for Galactic in README (EOL November 2022) (#321)",
    "Changes": "-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) |\n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary/) |",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "cc0510b9003f2184146c0a094545451ce14ec72f",
    "RawMessage": "Remove all GitHub CI jobs (#414)",
    "Changes": "-definitions:\n-  - &empty_repo\n-    type: zip\n-    url: data:application/zip;base64,UEsFBgAAAAAAAAAAAAAAAAAAAAAAAA==\n-\n-repositories:\n-  ros2/rmw_connextdds/COLCON_IGNORE: *empty_repo\n-\n-  ros2/rosidl_typesupport_fastrtps/COLCON_IGNORE: *empty_repo\n-  ros2/rmw_fastrtps/COLCON_IGNORE: *empty_repo\n-name: ROS 2 CI\n-on:\n-  push:\n-    paths-ignore: ['**.md', '**.rst']\n-  pull_request:\n-    paths-ignore: ['**.md', '**.rst']\n-jobs:\n-  build:\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-          rosdistro: [rolling]\n-          os: [ubuntu-20.04, macOS-latest, windows-latest]\n-          include:\n-          - rosdistro: rolling\n... [truncated] ...\n-      with:\n-        path: ${{env.TEMP}}/chocolatey\n-        key: ${{matrix.os}}-chocolatey-${{github.job_id}}\n-        restore-keys: ${{matrix.os}}-chocolatey-\n-    - if: runner.os == 'Linux'\n-      # azure ubuntu repo can be flaky so add an alternate source\n-      run: sed -e 's/azure.archive.ubuntu.com/us.archive.ubuntu.com/g' -e t -e d /etc/apt/sources.list | sudo tee /etc/apt/sources.list.d/nonazure.list\n-    - name: Acquire ROS dependencies\n-      uses: ros-tooling/setup-ros@master\n-      with:\n-        # Install to avoid getting stuck on the license agreement prompt\n-        install-connext: true\n-    - name: Set up git to see all pull requests\n-      run: git config --global --add remote.origin.fetch '+refs/pull/*:refs/remotes/origin/pull/*'\n-    - name: Build and test ROS\n-      id: ros_ci\n-      uses: ros-tooling/action-ros-ci@v0.2\n-      with:\n-        package-name: >\n-          rmw_cyclonedds_cpp\n-          rmw_implementation\n-        target-ros2-distro: ${{matrix.rosdistro}}\n-        vcs-repo-file-url: >\n-          https://raw.githubusercontent.com/ros2/ros2/${{ matrix.repos_branch }}/ros2.repos\n-          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/local.repos",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "aeff3ca28cfe51c522b04592ec3c7e7077bf2531",
    "RawMessage": "Fix function params indentation (#446)",
    "Changes": "-    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):\n+    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10) -> None:\n-            self, name='test_node', node_context=None, messages_received_buffer_length=None\n-    ):\n+        self, name='test_node', node_context=None, messages_received_buffer_length=None\n+    ) -> None:",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "e18084fa421fa54a3a6793909d128046b2b5a08e",
    "RawMessage": "Revert \"Raise user handler exception in MultiThreadedExecutor. (#984)\" (#1017)",
    "Changes": "-        :raise RuntimeError: Unexpected failure.\n-        :raise RuntimeError: Unexpected failure.\n-            def handler_wrapper(handler):\n-                handler()\n-                if handler.exception() is not None:\n-                    raise handler.exception()\n-            self._executor.submit(handler_wrapper(handler))\n+            self._executor.submit(handler)\n-        :return: ``True`` if successful, ``False`` otherwise.\n+        :return: ``True`` if succesful, ``False`` otherwise.",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcutils",
    "SHA": "b6ba6a1f1ef243bcb8a418ddfa7aaf09b92564d1",
    "RawMessage": "Fix if(TARGET ...) condition for test (#447)",
    "Changes": "-  if(TARGET test_shared_library_in_load_paths)\n+  if(TARGET test_shared_library_preloaded)",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "launch_ros",
    "SHA": "476ff34b4152c56d5e6c8ce56bf18ccd109cc5dc",
    "RawMessage": "Handle empty strings when evaluating parameters (#300)",
    "Changes": "+                # Handle special case where yaml.safe_load will return None given an empty string\n+                if len(evaluated_value) == 0:\n+                    evaluated_value = \"''\"\n+\n+\n+\n+def test_empty_string_evalutates_to_empty_string():\n+    # Regression test for https://github.com/ros2/launch_ros/pull/289#discussion_r818070166\n+    orig = [{'foo': TextSubstitution(text='')}]\n+    norm = normalize_parameters(orig)\n+    expected = ({'foo': ''},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "509947378c418c0266d043cf2a266a7daefc458e",
    "RawMessage": "Added build status of bloom-releases for Humble distribution (#291)",
    "Changes": "-Bloom release status of rclc packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic and Rolling.\n+Bloom release status of the packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic, Humble and Rolling.\n-| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Gpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_jammy_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_jammy_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary/)|  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary/) |",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "a41e97abfd23f193d8841611f1f5d56870031b15",
    "RawMessage": "Add publisher/subscription matched count API test coverage. (#119)",
    "Changes": "-      rcutils rmw rmw_implementation test_msgs\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n-      rcutils rmw rmw_implementation test_msgs\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef CONFIG_HPP_\n+#define CONFIG_HPP_\n+\n+#include <chrono>\n+\n+namespace\n+{\n... [truncated] ...\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef TESTING_MACROS_HPP_\n+#define TESTING_MACROS_HPP_\n+\n+#include <chrono>\n+#include <thread>\n+\n+/// Retry until `timeout` expires, sleeping for `delay` in between attempts.\n+/*\n+ * \\note Time is measured against OS provided steady clock.\n+ */\n+#define SLEEP_AND_RETRY_UNTIL(delay, timeout) for ( \\\n+    auto loop_start_time = std::chrono::steady_clock::now(); \\\n+    std::chrono::steady_clock::now() - loop_start_time < timeout; \\\n+    std::this_thread::sleep_for(delay))\n+\n+#endif  // TESTING_MACROS_HPP_",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "8eeb955f581c9cd24761185557ba7f46ef6e1d4c",
    "RawMessage": "Clarify Data Sharing enabling (#719)",
    "Changes": "-For example, see [ROS 2 QoS policies](https://docs.ros.org/en/foxy/Concepts/About-Quality-of-Service-Settings.html#qos-policies)).\n-In addition to ROS 2 QoS policies, `rmw_fastrtps` sets two more Fast DDS configurable parameters:\n+For example, see [ROS 2 QoS policies](https://docs.ros.org/en/foxy/Concepts/About-Quality-of-Service-Settings.html#qos-policies).\n+In addition to ROS 2 QoS policies, `rmw_fastrtps` sets the following Fast DDS configurable parameters:\n-* Publication mode: `ASYNCHRONOUS_PUBLISH_MODE`\n+* Publication mode: `SYNCHRONOUS_PUBLISH_MODE`\n+* Data Sharing: `OFF`\n+[datasharing]: https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html\n+* [datasharing] : `AUTO`.\n-The following example configures Fast DDS to publish synchronously, and to have a pre-allocated history that can be expanded whenever it gets filled.\n+The following example configures Fast DDS to publish synchronously, to have a pre-allocated history that can be expanded whenever it gets filled, and to use Data Sharing if possible.\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                <qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                </qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n+                    </data_sharing>\n+                <qos>\n+                    <data_sharing>\n+                        <kind>AUTOMATIC</kind>\n... [truncated] ...\n+1. To enable Fast DDS Data Sharing delivery mechanism, the following XML profiles need to be loaded, and environment variable `RMW_FASTRTPS_USE_QOS_FROM_XML` needs to be set to 1 (see [Full QoS configuration](#full-qos-configuration))\n+\n+    ```xml\n+    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+    <profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\">\n+\n+    <!-- Default publisher profile -->\n+    <publisher profile_name=\"default publisher profile\" is_default_profile=\"true\">\n+        <qos>\n+        <data_sharing>\n+            <kind>AUTOMATIC</kind>\n+        </data_sharing>\n+        </qos>\n+    </publisher>\n+\n+    <!-- Default subscription profile -->\n+    <subscriber profile_name=\"default subscription profile\" is_default_profile=\"true\">\n+        <qos>\n+        <data_sharing>\n+            <kind>AUTOMATIC</kind>\n+        </data_sharing>\n+        </qos>\n+    </subscriber>\n+    </profiles>\n+    ```",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "ca135ecfcfff971fd537b0ddb4ebdff3304afc51",
    "RawMessage": "Removed warning when building in release mode (#1057)",
    "Changes": "-  auto num_vertices = internals.rend->getBuffer()->getNumVertices();\n-  auto vertex_size =\n-    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n-\n-\n-    assert(\n-      reinterpret_cast<uint8_t *>(float_buffer) <=\n-      reinterpret_cast<uint8_t *>(float_buffer) + num_vertices * vertex_size);\n+#ifndef NDEBUG\n+  size_t num_vertices = internals.rend->getBuffer()->getNumVertices();\n+  size_t vertex_size =\n+    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n+  assert(\n+    reinterpret_cast<uint8_t *>(float_buffer) <=\n+    reinterpret_cast<uint8_t *>(internals.float_buffer) + num_vertices * vertex_size);\n+#endif\n+",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "74bd075495a25286839881f5f500e1c9b9926f4c",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#243)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @wjwwood",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d32d820b5cfbfb6eba5a02910f2dd68430a6ba12",
    "RawMessage": "make handles not inheritable to prevent from blocking durning tab-completion (#852)",
    "Changes": "+import os\n+import platform\n+    # During tab completion on the ros2 tooling, we can get here and attempt to spawn a daemon.\n+    # In that scenario, there may be open file descriptors that can prevent us from successfully\n+    # daemonizing, and instead cause the terminal to hang.  Here we mark all file handles except\n+    # for 0, 1, 2, and the server socket as non-inheritable, which will cause daemonize() to close\n+    # those file descriptors.  See https://github.com/ros2/ros2cli/issues/851 for more details.\n+    if platform.system() != 'Windows':\n+        import resource\n+        soft, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n+        for i in range(3, soft):\n+            try:\n+                if i != server.socket.fileno() and os.get_inheritable(i):\n+                    os.set_inheritable(i, False)\n+            except OSError:\n+                # Just in case the file handles might be [3(closed), ..., 8(pipe handle), ...]\n+                continue\n+",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "305ef763b83e42ebddc4802ac788869d178b6e93",
    "RawMessage": "call get_action_interfaces() properly. (#898)",
    "Changes": "-    for package_name, action_names in get_action_interfaces.items():\n+    for package_name, action_names in get_action_interfaces().items():",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "4acc8fc6098f9fd1f0172c42d9422d35527b411c",
    "RawMessage": "Removes erroneous unmatched closing parenthesis (#125)",
    "Changes": "+      msg/BuiltinTypeSequencesIdl.idl\n+module rosidl_generator_py {\n+    module msg {\n+        struct BuiltinTypeSequencesIdl {\n+            // Unbounded sequences\n+            sequence<char> char_sequence_unbounded;\n+        };\n+    };\n+};\n-                 all(val >= 0 and val) < 256 for val in value)), \\\n+                 all(ord(val) >= 0 and ord(val) < 256 for val in value)), \\\n+from rosidl_generator_py.msg import BuiltinTypeSequencesIdl\n+\n+\n+def test_builtin_sequence_slot_attributes():\n+    msg = BuiltinTypeSequencesIdl()\n+    assert hasattr(msg, 'get_fields_and_field_types')\n+    assert hasattr(msg, '__slots__')\n+    builtin_sequence_slot_types_dict = getattr(msg, 'get_fields_and_field_types')()\n+    builtin_sequence_slots = getattr(msg, '__slots__')\n+    assert len(builtin_sequence_slot_types_dict) == len(builtin_sequence_slots)",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw",
    "SHA": "0c65580410e765d05e39efeebfd5bac70fef5d6a",
    "RawMessage": "Update service server/client creation/destruction API documentation. (#276)",
    "Changes": "-/// Create an rmw client to communicate with the specified service\n+/// Create a service client that can send requests to and receive replies from a service server.\n- * \\param[in] node Handle to node with which to register this client\n- * \\param[in] type_support The type_support of this rosidl service\n- * \\param[in] service_name The name of the ROS 2 service to connect with\n- * \\param[in] qos_policies The QoS profile policies to utilize for this connection\n- * \\return The initialized client if successful, `nullptr` if not\n+ * This function can fail, and therefore return `NULL`, if:\n+ *   - `node` is `NULL`, or\n+ *   - `node` does not belong to this implementation\n+ *      i.e. it does not have a matching implementation identifier, or\n+ *   - `type_support` is `NULL`, or\n+ *   - `service_name` is `NULL`, or\n+ *   - `service_name` is an empty string, or\n+ *   - (if ROS namespace conventions apply) `service_name` is invalid by\n+ *     rmw_validate_full_topic_name() definition, or\n+ *   - `qos_profile` is `NULL`, or\n+ *   - `qos_profile` has invalid or unknown policies, or\n+ *   - memory allocation fails during service client creation, or\n+ *   - an unspecified error occurs.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n... [truncated] ...\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged.\n+ * Otherwise, it will proceed despite errors.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\pre Given `node` must be the one the service server was registered with.\n+ * \\pre Given `service` must be a valid service server, as returned by rmw_create_service().\n+ *\n+ * \\param[in] node Node with which the given service server is registered.\n+ * \\param[in] service Service server to be destroyed.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`\n+ *   implementation identifier does not match this implementation, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`\n+ *   implementation identifier does not match this implementation, or\n+ * \\return `RMW_RET_ERROR` if an unspecified error occurs.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "7a2a6bc2e9cd8df996d7f320ef8c166638691d47",
    "RawMessage": "Fixed AccelStamped, TwistStamped and Wrench icons (#1041)",
    "Changes": "",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "94f42b6b16de00f1b0543a793c6cd614843ea69e",
    "RawMessage": "Check parameter callback signature during registration. (#1425)",
    "Changes": "+                if not isinstance(result, SetParametersResult):\n+                    warnings.warn(\n+                        'Callback returned an invalid type, it should return SetParameterResult.')\n+                    result = SetParametersResult(\n+                        successful=False, reason='Callback returned an invalid type')\n+        if not callable(callback):\n+            raise TypeError('Callback must be callable, got {}', type(callback))\n+        if not callable(callback):\n+            raise TypeError('Callback must be callable, got {}', type(callback))\n+    def return_none_parameter_callback(self, parameter_list):\n+        return None\n+\n+    def test_node_set_parameters_return_none(self) -> None:\n+        # Declare a new parameter and set a callback that returns None.\n+        parameter_tuple = (\n+            'test_param',\n+            True,\n+            ParameterDescriptor()\n+        )\n+        self.node.declare_parameter(*parameter_tuple)\n+        # Tries to set the parameter with a callback that returns None.\n+        self.node.add_on_set_parameters_callback(self.return_none_parameter_callback)\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter('always', category=UserWarning)\n+            result = self.node.set_parameters(\n+                [\n+                    Parameter(\n+                        name=parameter_tuple[0],\n+                        value=parameter_tuple[1]\n+                    )\n+                ]\n+            )\n+            assert len(w) == 1, f'Expected 1 warning, but got {len(w)}'\n+            assert issubclass(w[0].category, UserWarning)\n+            assert 'Callback returned an invalid type, it should return SetParameterResult.' \\\n+                in str(w[0].message)\n+            self.assertIsInstance(result, list)\n+            self.assertIsInstance(result[0], SetParametersResult)\n+            self.assertFalse(result[0].successful)\n+            self.assertEqual(result[0].reason, 'Callback returned an invalid type')\n+",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "168ea9bb18507999c7011faaf8f3e527d69419f0",
    "RawMessage": "Relieve timer test period not to miss the cycle. (#1209)",
    "Changes": "-  int64_t period = RCL_MS_TO_NS(10);\n+  int64_t period = RCL_MS_TO_NS(100);\n-  int64_t period = RCL_MS_TO_NS(10);\n+  int64_t period = RCL_MS_TO_NS(100);",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "d263be2057e39f1f702f014548c60f06b5a51333",
    "RawMessage": "fix rclc_example: memory leaking in msg.data allocation (backport #386) (#387)",
    "Changes": "+ * \\param[in] autostart the state of the timer at initialization\n+rclc_timer_init_default2(\n+  rcl_timer_t * timer,\n+  rclc_support_t * support,\n+  const uint64_t timeout_ns,\n+  const rcl_timer_callback_t callback,\n+  bool autostart);\n+\n+/**\n+ * \\deprecated `rclc_timer_init_default` implementation was removed.\n+ *   Refer to `rclc_timer_init_default2`.\n+ */\n+RCL_PUBLIC\n+RCUTILS_DEPRECATED_WITH_MSG(\"Call rclc_timer_init_default2 instead\")\n+rcl_ret_t\n-rclc_timer_init_default(\n+rclc_timer_init_default2(\n-  const rcl_timer_callback_t callback)\n+  const rcl_timer_callback_t callback,\n+  bool autostart)\n-  rcl_ret_t rc = rcl_timer_init(\n+  rcl_ret_t rc = rcl_timer_init2(\n-    (*support->allocator));\n+    (*support->allocator),\n+    autostart);\n... [truncated] ...\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    pong_timer_callback);\n+    pong_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-  pongNode_pong_msg.data.data = (char *) malloc(PUB_MSG_CAPACITY);\n+  pongNode_pong_msg.data.data = (char *) allocator.reallocate(pongNode_pong_msg.data.data, PUB_MSG_CAPACITY, allocator.state);\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    my_timer_callback);\n+    my_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-  rc = rclc_timer_init_default(\n+  rc = rclc_timer_init_default2(\n-    short_timer_callback);\n+    short_timer_callback,\n+    true);\n-    printf(\"Error in rcl_timer_init_default.\\n\");\n+    printf(\"Error in rclc_timer_init_default2.\\n\");\n-    pub_msgs[i].data.data = malloc(PUB_MSG_CAPACITY);\n+    pub_msgs[i].data.data = allocator.reallocate(pub_msgs[i].data.data, PUB_MSG_CAPACITY, allocator.state);",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "2daa408ea46bb2a4305a6221d73ea400e4c02d62",
    "RawMessage": "Cleanup rcl_get_secure_root() implementation. (#762)",
    "Changes": "+static const char *\n+dupenv(const char * name, const rcl_allocator_t * allocator, char ** value)\n+{\n+  const char * buffer = NULL;\n+  const char * error = rcutils_get_env(name, &buffer);\n+  if (NULL != error) {\n+    return error;\n+  }\n+  *value = NULL;\n+  if (0 != strcmp(\"\", buffer)) {\n+    *value = rcutils_strdup(buffer, *allocator);\n+    if (NULL == *value) {\n+      return \"string duplication failed\";\n+    }\n+  }\n+  return NULL;\n+}\n+\n-  bool ros_secure_enclave_override = true;\n+  RCL_CHECK_ARGUMENT_FOR_NULL(name, NULL);\n+  RCL_CHECK_ALLOCATOR_WITH_MSG(allocator, \"allocator is invalid\", return NULL);\n-  // find out if either of the configuration environment variables are set\n-  const char * env_buf = NULL;\n-  if (NULL == name) {\n-    return NULL;\n... [truncated] ...\n-    if (NULL == secure_root) {\n-      RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n-        \"SECURITY ERROR: unable to find a folder matching the name '%s' in '%s'. \",\n-        name, ros_secure_keystore_env);\n-    } else {\n-      RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n-        \"SECURITY ERROR: directory '%s' does not exist.\", secure_root);\n-    }\n-    allocator->deallocate(ros_secure_enclave_override_env, allocator->state);\n-    allocator->deallocate(ros_secure_keystore_env, allocator->state);\n+  if (NULL == secure_root) {\n+    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"SECURITY ERROR: unable to find a folder matching the name '%s' in '%s'. \",\n+      name, ros_secure_keystore_env);\n+    goto leave_rcl_get_secure_root;\n+  }\n+\n+  if (!rcutils_is_directory(secure_root)) {\n+    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"SECURITY ERROR: directory '%s' does not exist.\", secure_root);\n-    return NULL;\n+    secure_root = NULL;\n+\n+leave_rcl_get_secure_root:\n+  allocator->deallocate(ros_secure_enclave_override_env, allocator->state);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "4ec4f9684d03a903da951ab6d4d08cbc87de49ee",
    "RawMessage": "fix: add `rclcpp::shutdown` (#762)",
    "Changes": "-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n+  rclcpp::shutdown();\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n... [truncated] ...\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;\n-  return RUN_ALL_TESTS();\n+  auto ret = RUN_ALL_TESTS();\n+  rclcpp::shutdown();\n+  return ret;",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "fd648d98f17891420679f8d613f8771f5e446390",
    "RawMessage": "Example real-time concurreny timer and subscription (#329)",
    "Changes": "+add_executable(example_short_timer_long_subscription src/example_short_timer_long_subscription.c)\n+ament_target_dependencies(example_short_timer_long_subscription rcl rclc std_msgs)\n+\n+  example_short_timer_long_subscription\n+- [example_short_timer_long_subscription.c](src/example_client_node.c) demo with high frequency timer and subscription with long processing time with one executor.\n+## Example real-time concurrency slow timer and long subscription\n+This example demonstrates what happens, if a high frequency timer (every 100ms) and\n+a subscription with a long processing time is managed by one executor. This demo shows,\n+that the timer events are dropped during the long processing time of the subscription and are also not caught-up when there would be sufficient time. \n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <stdio.h>\n... [truncated] ...\n+  rclc_executor_add_timer(&executor, &short_timer);\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error in rclc_executor_add_timer.\\n\");\n+  }\n+\n+  rclc_executor_spin(&executor);\n+\n+\n+  // clean up\n+  rc = rclc_executor_fini(&executor);\n+  rc += rcl_publisher_fini(&my_pub, &my_node);\n+  rc += rcl_timer_fini(&my_timer);\n+  rc += rcl_subscription_fini(&my_sub, &my_node);\n+  rc += rcl_node_fini(&my_node);\n+  rc += rclc_support_fini(&support);\n+\n+  std_msgs__msg__Int32__fini(&pub_msg);\n+  std_msgs__msg__Int32__fini(&sub_msg);\n+\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error while cleaning up!\\n\");\n+    return -1;\n+  }\n+  return 0;\n+}",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw",
    "SHA": "6d3f68af511bb17dfdc9eef3dc345469e8042162",
    "RawMessage": "Do not link against pthread on Android (#259) (#267)",
    "Changes": "-  if(UNIX AND NOT APPLE)\n+  if(UNIX AND NOT APPLE AND NOT ANDROID)",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw",
    "SHA": "f48ebcf0abc9e27f90733046bbffffb18d5e0638",
    "RawMessage": "Update gid API documentation. (#274)",
    "Changes": "-/// Get the unique identifier of the publisher\n+/// Get the unique identifier (gid) of a publisher.\n- * \\param[in] publisher The publisher to get the gid of\n- * \\param[out] gid The resulting gid\n- * \\return RMW_RET_OK if successful, otherwise an appropriate error code\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Thread-safety\n+ *   Publishers are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to get the unique identifier from the same publisher concurrently.\n+ *   However, access to the gid is not synchronized.\n+ *   It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it.\n+ *\n+ * \\pre Given `publisher` must be a valid subscription, as returned by rmw_create_publisher().\n+ *\n+ * \\param[in] publisher Publisher to get a gid from.\n... [truncated] ...\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Thread-safety\n+ *   Unique identifier comparison is a reentrant function, but:\n+ *   - Access to both gids is read-only but it is not synchronized.\n+ *     Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not.\n+ *   - Access to primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `result` while rmw_compare_gids_equal() uses it.\n+ *\n+ * \\param[in] gid1 First unique identifier to compare.\n+ * \\param[in] gid2 Second unique identifier to compare.\n+ * \\param[out] bool true if both gids are equal, false otherwise.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n+ *   identifier of `gid1` or `gid2` does not match this implementation, or\n+ * \\return `RMW_RET_ERROR` if an unspecified error occurs.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "912394c12b5419087c14b43b5f26172fb901727a",
    "RawMessage": "Make sure to check the return value of rcl APIs. (#838)",
    "Changes": "+    if (ret != RCL_RET_OK) {\n+      RCUTILS_LOG_ERROR_NAMED(\n+        ROS_PACKAGE_NAME, \"Error in options fini: %s\", rcl_get_error_string().str);\n+      return -1;\n+    }\n+    if (ret != RCL_RET_OK) {\n+      RCUTILS_LOG_ERROR_NAMED(\n+        ROS_PACKAGE_NAME, \"Error in options fini: %s\", rcl_get_error_string().str);\n+      return -1;\n+    }\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  if (ret != RCL_RET_OK) {\n+    return ret;\n+  }\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-  ret = RCL_RET_OK;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n... [truncated] ...\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  ASSERT_EQ(RCL_RET_OK, ret);\n-  original_size = transition_map.transitions_size;\n-  original_size = transition_map.transitions_size;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "d700d78611ca2f2a56128ee71dd157961a1f4fb4",
    "RawMessage": "[TimeCache] Improve performance for insertData() and pruneList() (#680)",
    "Changes": "+  // In order to minimize the number of times we iterate over this data, we:\n+  // (1) Prune all old data first, regardless if new_data is added,\n+  // (2) We use find_if to scan from newest to oldest, and stop at the first\n+  //     point where the timestamp is equal or older to new_data's.\n+  // (3) From this point, we scan with more expensive full equality checks to\n+  //     ensure we do not reinsert the same exact data.\n+  // (4) If we the data is not duplicated, then we simply insert new_data at\n+  //     the point found in (2).\n+  // (1) Always prune data.\n+  pruneList();\n+\n-  // Find the oldest element in the list before the incoming stamp.\n-  auto last_transform_pos = std::find_if(\n-    storage_.begin(), storage_.end(), [&](const auto & transfrom) {\n-      return transfrom.stamp_ <= new_data.stamp_;\n+  // (2) Find the oldest element in the list before the incoming stamp.\n+  auto insertion_pos = std::find_if(\n+    storage_.begin(), storage_.end(), [&](const auto & transform) {\n+      return transform.stamp_ <= new_data.stamp_;\n-  // Insert elements only if not already present\n-  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n-    storage_.insert(last_transform_pos, new_data);\n+  bool should_insert = true;\n+\n+  // (3) Search along all data with same timestamp (sorted), and see if we have\n+  // an exact duplicate.\n+  auto maybe_same_pos = insertion_pos;\n+  while (maybe_same_pos != storage_.end() && maybe_same_pos->stamp_ == new_data.stamp_) {\n+    if (*maybe_same_pos == new_data) {\n+      should_insert = false;\n+      break;\n+    }\n+    maybe_same_pos++;\n+  }\n+\n+  // (4) Insert elements only if not already present\n+  if (should_insert) {\n+    storage_.insert(insertion_pos, new_data);\n-  pruneList();\n-  storage_.remove_if(\n-    [&](const auto & transform) {\n-      return transform.stamp_ < latest_time - max_storage_time_;\n-    });\n+  while (!storage_.empty() && storage_.back().stamp_ + max_storage_time_ < latest_time) {\n+    storage_.pop_back();\n+  }",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "ce4296879a08794ff701978fac45eb885ab9e40c",
    "RawMessage": "Fix enum naming for avoid collision (#242)",
    "Changes": "-  SUBSCRIPTION,\n-  SUBSCRIPTION_WITH_CONTEXT,\n-  TIMER,\n-  // TIMER_WITH_CONTEXT,  // TODO\n-  CLIENT,\n-  CLIENT_WITH_REQUEST_ID,\n-  // CLIENT_WITH_CONTEXT,  // TODO\n-  SERVICE,\n-  SERVICE_WITH_REQUEST_ID,\n-  SERVICE_WITH_CONTEXT,\n-  ACTION_CLIENT,\n-  ACTION_SERVER,\n-  GUARD_CONDITION,\n-  // GUARD_CONDITION_WITH_CONTEXT,  //TODO\n-  NONE\n+  RCLC_SUBSCRIPTION,\n+  RCLC_SUBSCRIPTION_WITH_CONTEXT,\n+  RCLC_TIMER,\n+  // RCLC_TIMER_WITH_CONTEXT,  // TODO\n+  RCLC_CLIENT,\n+  RCLC_CLIENT_WITH_REQUEST_ID,\n+  // RCLC_CLIENT_WITH_CONTEXT,  // TODO\n+  RCLC_SERVICE,\n+  RCLC_SERVICE_WITH_REQUEST_ID,\n+  RCLC_SERVICE_WITH_CONTEXT,\n... [truncated] ...\n+      // case RCLC_CLIENT_WITH_CONTEXT:\n-    case SERVICE:\n-    case SERVICE_WITH_REQUEST_ID:\n-    case SERVICE_WITH_CONTEXT:\n+    case RCLC_SERVICE:\n+    case RCLC_SERVICE_WITH_REQUEST_ID:\n+    case RCLC_SERVICE_WITH_CONTEXT:\n-    case GUARD_CONDITION:\n-      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case RCLC_GUARD_CONDITION:\n+      // case RCLC_GUARD_CONDITION_WITH_CONTEXT:\n-    case NONE:\n+    case RCLC_NONE:\n-  EXPECT_EQ(handle.type, NONE);\n+  EXPECT_EQ(handle.type, RCLC_NONE);\n-  handle.type = SUBSCRIPTION;\n+  handle.type = RCLC_SUBSCRIPTION;\n-  handle.type = TIMER;\n+  handle.type = RCLC_TIMER;\n-  handle.type = CLIENT;\n+  handle.type = RCLC_CLIENT;\n-  handle.type = SERVICE;\n+  handle.type = RCLC_SERVICE;\n-  handle.type = GUARD_CONDITION;\n+  handle.type = RCLC_GUARD_CONDITION;",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "f90c01c19212cf5d8a0dd4fdeb966c5a9910518e",
    "RawMessage": "Set transition_map->states/transition size to 0 on fini (#729)",
    "Changes": "+  transition_map->states_size = 0;\n+  transition_map->transitions_size = 0;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "4cc5f2ef82bbb259cb9b10b55729462bf14892c5",
    "RawMessage": "Clean up rcl_expand_topic_name() implementation. (#757)",
    "Changes": "-    switch (rmw_ret) {\n-      case RMW_RET_INVALID_ARGUMENT:\n-        return RCL_RET_INVALID_ARGUMENT;\n-      case RMW_RET_ERROR:\n-      // fall through on purpose\n-      default:\n-        return RCL_RET_ERROR;\n-    }\n+    return rcl_convert_rmw_ret_to_rcl_ret(rmw_ret);\n-    switch (rmw_ret) {\n-      case RMW_RET_INVALID_ARGUMENT:\n-        return RCL_RET_INVALID_ARGUMENT;\n-      case RMW_RET_ERROR:\n-      // fall through on purpose\n-      default:\n-        return RCL_RET_ERROR;\n-    }\n+    return rcl_convert_rmw_ret_to_rcl_ret(rmw_ret);\n-  // if the original input_topic_name has not yet be copied into new memory, strdup it now\n-  if (!local_output) {\n-    local_output = rcutils_strdup(input_topic_name, allocator);\n-    if (!local_output) {\n-      *output_topic_name = NULL;\n-      RCL_SET_ERROR_MSG(\"failed to allocate memory for output topic\");\n-      return RCL_RET_BAD_ALLOC;\n-    }\n-  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "8e46bf2608d04e81a3d088ccc5087dbde9f3e32f",
    "RawMessage": "cosmetic fixes for ros2param dump command. (#933)",
    "Changes": "-    @staticmethod\n-    def get_parameter_values(node, node_name, params):\n-        response = call_get_parameters(\n-            node=node, node_name=node_name,\n-            parameter_names=params)\n-\n-        # requested parameter not set\n-        if not response.values:\n-            return None\n-\n-        # extract type specific value\n-        return [get_value(parameter_value=i) for i in response.values]\n-\n-            # retrieve values\n+            # retrieve parameter names\n-\n-            response = response.result().result.names\n-            response = sorted(response)\n-            parameter_values = self.get_parameter_values(node, absolute_node_name, response)\n-            if parameter_values is None:\n+            parameter_names = sorted(response.result().result.names)\n+\n+            # retrieve parameter values\n+            response = None\n+            try:\n+                response = call_get_parameters(\n+                    node=node, node_name=absolute_node_name, parameter_names=parameter_names)\n+            except RuntimeError as e:\n-\n-            for param_name, pval in zip(response, parameter_values):\n+            if response.values is None:\n+                # pass through here, no parameters are available with this node.\n+                # since this is not failure, it proceeds to print the yaml as consistent behavior.\n+                pass\n+            parameter_values = [get_value(parameter_value=i) for i in response.values]\n+\n+            # create dictionary with parameter names and values\n+            for param_name, pval in zip(parameter_names, parameter_values):",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "34d0fd6eb32f4415c52cbf3ffc2d82b64d274715",
    "RawMessage": "Redefine rmw gurumdds identifier",
    "Changes": "-extern const char * const gurum_gurumdds_identifier;\n+extern const char * const RMW_GURUMDDS_ID;\n-        gurum_gurumdds_identifier, RCUTILS_LOG_SEVERITY_DEBUG))\n+        RMW_GURUMDDS_ID, RCUTILS_LOG_SEVERITY_DEBUG))\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-        gurum_gurumdds_identifier,\n+        RMW_GURUMDDS_ID,\n-      gurum_gurumdds_identifier,\n+      RMW_GURUMDDS_ID,\n-          gurum_gurumdds_identifier,\n+          RMW_GURUMDDS_ID,\n-      gurum_gurumdds_identifier,\n+      RMW_GURUMDDS_ID,\n-  if (node->implementation_identifier != gurum_gurumdds_identifier) {\n+  if (node->implementation_identifier != RMW_GURUMDDS_ID) {\n-  if (publisher->implementation_identifier != gurum_gurumdds_identifier) {\n... [truncated] ...\n-      \"rmw_gurumdds_cpp\", \"No data on topic %s\", topic_name);\n+      RMW_GURUMDDS_ID, \"No data on topic %s\", topic_name);\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n+    RMW_GURUMDDS_ID, \"Received data on topic %s\", topic_name);\n-          RCUTILS_LOG_WARN_NAMED(\"rmw_gurumdds_cpp\", \"Failed to get publication handle\");\n+          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n-    gurum_gurumdds_identifier, subscription,\n+    RMW_GURUMDDS_ID, subscription,\n-    gurum_gurumdds_identifier, subscription,\n+    RMW_GURUMDDS_ID, subscription,\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-  wait_set->implementation_identifier = gurum_gurumdds_identifier;\n+  wait_set->implementation_identifier = RMW_GURUMDDS_ID;\n-    gurum_gurumdds_identifier,\n+    RMW_GURUMDDS_ID,\n-    gurum_gurumdds_identifier, subscriptions, guard_conditions,\n+    RMW_GURUMDDS_ID, subscriptions, guard_conditions,\n+#include \"rmw_gurumdds_cpp/identifier.hpp\"\n-    RCUTILS_LOG_DEBUG_NAMED(\"rmw_gurumdds_cpp\", \"no topics for participant_guid\");\n+    RCUTILS_LOG_DEBUG_NAMED(RMW_GURUMDDS_ID, \"no topics for participant_guid\");\n-    RCUTILS_LOG_DEBUG_NAMED(\"rmw_gurumdds_cpp\", \"no services for participant_guid\");\n+    RCUTILS_LOG_DEBUG_NAMED(RMW_GURUMDDS_ID, \"no services for participant_guid\");",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "9a144bf040fb8c74058c6b4fd9830fd0e0e3594e",
    "RawMessage": "Check if Task(Future) is canceled. (#1377)",
    "Changes": "-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):\n-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):\n+                    # Get rid of any tasks that are cancelled\n+                    self._tasks = list(filter(lambda t_e_n: not t_e_n[0].cancelled(), self._tasks))\n+from enum import Enum\n+class FutureState(Enum):\n+    \"\"\"States defining the lifecycle of a future.\"\"\"\n+\n+    PENDING = 'PENDING'\n+    CANCELLED = 'CANCELLED'\n+    FINISHED = 'FINISHED'\n+\n+\n... [truncated] ...\n+\n+    def test_set_result_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertFalse(f.done())\n+        f.set_result(None)\n+        self.assertTrue(f.done())\n+\n+    def test_set_exception_on_done_future_without_exception(self) -> None:\n+        f = Future()\n+        f.set_result(None)\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        f.set_result(None)\n+        self.assertIsNotNone(f.exception())\n+\n+    def test_set_exception_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        self.assertIsNotNone(f.exception())\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "383fb7112e2fbae4267579a485bd88ec643b619b",
    "RawMessage": "Adds a context pointer to subscriptions (backport #107) (#121)",
    "Changes": "+\n+Brett Downing <brettrd@brettrd.com>\n+/**\n+ *  Adds a subscription to an executor.\n+ * * An error is returned, if {@link rclc_executor_t.handles} array is full.\n+ * * The total number_of_subscriptions field of {@link rclc_executor_t.info}\n+ *   is incremented by one.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param [inout] executor pointer to initialized executor\n+ * \\param [in] subscription pointer to an allocated subscription\n+ * \\param [in] msg pointer to an allocated message\n+ * \\param [in] callback    function pointer to a callback\n+ * \\param [in] context     type-erased ptr to additional callback context\n+ * \\param [in] invocation  invocation type for the callback (ALWAYS or only ON_NEW_DATA)\n+ * \\return `RCL_RET_OK` if add-operation was successful\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any parameter is a null pointer (NULL context is ignored)\n+ * \\return `RCL_RET_ERROR` if any other error occured\n... [truncated] ...\n+      rc = rclc_executor_spin_some(&executor, 1000 * (1000 * 1000));\n+    }\n+  }\n+\n+  // clean up\n+  rc = rclc_executor_fini(&executor);\n+\n+  for(unsigned int i=0;i<n_topics; i++) {\n+    rc += rcl_publisher_fini(&(my_pubs[i]), &my_node);\n+    rc += rcl_subscription_fini(&(my_subs[i]), &my_node);\n+  }\n+  rc += rcl_node_fini(&my_node);\n+  rc += rclc_support_fini(&support);\n+\n+  for(unsigned int i=0;i<n_topics; i++) {\n+    std_msgs__msg__String__fini(&(pub_msgs[i]));\n+    std_msgs__msg__String__fini(&(sub_msgs[i]));\n+  }\n+\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error while cleaning up!\\n\");\n+    return -1;\n+  }\n+  return 0;\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "1d31f436592a778158d5b800c1854adcf8ddc798",
    "RawMessage": "Update documentation about number_of_handles (#326)",
    "Changes": "-As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.\n+As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added. \n+\n+Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See [Memory Management Tutorial](https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation) for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.\n- * running phase in the executor. However, the heap memory of corresponding wait-set is\n+ * running phase in the executor.\n+ *\n+ * Also in the XRCE-DDS middleware the maximum number are configured. See [Memory Management Tutorial](https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation)\n+ * for the default values. If you need larger values, you need to update your colcon.meta\n+ * configuration file and rebuild. To make sure that the changes were applied, you can check\n+ * the defined values in the following library include file:\n+ * build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h\n+ *\n+ * The heap memory of corresponding wait-set is",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "7bf58ecd9038310d744e2c39281f06abf0f48afa",
    "RawMessage": "Update graph API return codes. (#243)",
    "Changes": "-  RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n-  if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_names) ||\n-    RMW_RET_OK != rmw_check_zero_rmw_string_array(node_namespaces))\n-  {\n-    return RMW_RET_ERROR;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_names)) {\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+  if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_namespaces)) {\n+    return RMW_RET_INVALID_ARGUMENT;\n-  RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n-  if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_names) ||\n-    RMW_RET_OK != rmw_check_zero_rmw_string_array(node_namespaces))\n-  {\n-    return RMW_RET_ERROR;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n... [truncated] ...\n+  RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n+    allocator, \"allocator argument is invalid\", return RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);\n+  if (RMW_RET_OK != rmw_topic_endpoint_info_array_check_zero(publishers_info)) {\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+\n-  RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n-  RET_NULL(allocator);\n-  RET_NULL(topic_name);\n-  RET_NULL(subscriptions_info);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n+    allocator, \"allocator argument is invalid\", return RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);\n+  if (RMW_RET_OK != rmw_topic_endpoint_info_array_check_zero(subscriptions_info)) {\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "urdf",
    "SHA": "dcdd0d805ec6ba8c63c26e30d1f6485cfed34077",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-ros2 workflow. (#42)",
    "Changes": "-name: Mirror rolling to ros2\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-ros2:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: ros2\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @ahcorde @clalancette",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "20df68351e4602c11d5303495aeaaab87118895d",
    "RawMessage": "Change decode error mode to replace (#176)",
    "Changes": "-      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"strict\");\n+      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"replace\");\n-      \"strict\");\n+      \"replace\");",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "899bbdf73fb57c8f5926b31e9570f017b8c2fdb9",
    "RawMessage": "Fix the triggering of guard conditions. (#504)",
    "Changes": "+          trig_idx++;",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclcpp",
    "SHA": "56f68f9c44f26a4bd07d45caf39aad5d9945939c",
    "RawMessage": "Fix destruction order in lifecycle benchmark (#1675)",
    "Changes": "-    lifecycle_node.reset();\n+    executor.reset();\n+    lifecycle_node.reset();",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "a49fc7c352578307aa48b849875e980cb9650222",
    "RawMessage": "Prevent rviz_rendering::AssimpLoader from loading materials twice. (#622)",
    "Changes": "-    Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingleton().create(\n+    auto result = Ogre::MaterialManager::getSingleton().createOrRetrieve(\n+    Ogre::MaterialPtr mat = std::static_pointer_cast<Ogre::Material>(result.first);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "98952b58d570cde78d8cfec8c8d697f331b8c982",
    "RawMessage": "Fixing lifecycle node autostart issue #445 (#449)",
    "Changes": "-                    transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE]\n-                ),\n-                LifecycleTransition(\n-                    lifecycle_node_names=[self.node_name],\n-                    transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE]\n+                    transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE,\n+                                    lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE]\n-                        transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE]\n+                        transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE,\n+                                        lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE]\n-                autostart_actions.append(\n-                    LifecycleTransition(\n-                        lifecycle_node_names=[complete_node_name],\n-                        transition_ids=[lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE]\n-                    ),\n-                )",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "1961b81ecc1210441d523fe5638045998d9f812c",
    "RawMessage": "point_marker: fix bug where the number of rendered points accumulates over time (#949)",
    "Changes": "-  setRenderModeAndDimensions(new_message, scale);\n+  points_->clearAndRemoveAllPoints();\n-  points_->clear();\n+  setRenderModeAndDimensions(new_message, scale);",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2961f750b25171bd19ad23221a57ca32a0d2cc2d",
    "RawMessage": "Update service/client request/response API error returns (#249)",
    "Changes": "-  RET_NULL(taken);\n-  RET_NULL(ros_data);\n-  RET_NULL(request_header);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(taken, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_data, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n-  RET_NULL(client);\n-  RET_WRONG_IMPLID(client);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(service);\n-  RET_WRONG_IMPLID(service);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(service);\n-  RET_WRONG_IMPLID(service);\n-  RET_NULL(request_header);\n-  RET_NULL(ros_response);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n-  RET_NULL(client);\n-  RET_WRONG_IMPLID(client);\n-  RET_NULL(ros_request);\n-  RET_NULL(sequence_id);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_request, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(sequence_id, RMW_RET_INVALID_ARGUMENT);\n+",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "9599dd488d543671121c40df9aec5533064e86fb",
    "RawMessage": "Added TwistStamped and AccelStamped default plugins (#991)",
    "Changes": "+  include/rviz_default_plugins/displays/accel/accel_display.hpp\n+  include/rviz_default_plugins/displays/screw/screw_display.hpp\n+  include/rviz_default_plugins/displays/twist/twist_display.hpp\n+  src/rviz_default_plugins/displays/accel/accel_display.cpp\n+  src/rviz_default_plugins/displays/screw/screw_display.cpp\n+  src/rviz_default_plugins/displays/twist/twist_display.cpp\n+  ament_add_gtest(accel_display_visual_test\n+    test/rviz_default_plugins/displays/accel/accel_display_visual_test.cpp\n+    test/rviz_default_plugins/page_objects/accel_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET accel_display_visual_test)\n+    target_include_directories(accel_display_visual_test PRIVATE test)\n+    target_link_libraries(accel_display_visual_test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ${geometry_msgs_TARGETS}\n+      ${std_msgs_TARGETS}\n+      rclcpp::rclcpp\n+    )\n+  endif()\n+\n+  ament_add_gtest(twist_display_visual_test\n+    test/rviz_default_plugins/displays/twist/twist_display_visual_test.cpp\n+    test/rviz_default_plugins/page_objects/twist_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n... [truncated] ...\n+    arrows[1]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(0, 0, 0)));\n+  EXPECT_THAT(\n+    arrows[2]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(0, 0, 0)));\n+\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+  EXPECT_THAT(\n+    arrows[1]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+  EXPECT_THAT(\n+    arrows[2]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+\n+  screw_visual->setLinearScale(1);\n+  screw_visual->setAngularScale(2);\n+  screw_visual->setScrew(Ogre::Vector3(1, 1, 1), Ogre::Vector3(1, 1, 1));\n+  linear_arrow = findLinearArrow(root_node);\n+  EXPECT_THAT(linear_arrow->getScale(), Vector3Eq(Ogre::Vector3(0.0f, 1.73205f, 0.0f)));\n+\n+  angular_arrow = findAngularArrow(root_node);\n+  EXPECT_THAT(angular_arrow->getScale(), Vector3Eq(Ogre::Vector3(0.0f, 3.4641f, 0.0f)));\n+}",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "1e57ddf1047e57327743840976c2c86f8e534bf8",
    "RawMessage": "sorting after conversion",
    "Changes": "-            for idl_stem in sorted(modules[subfolder]):\n-                module_name = '_' + \\\n+            module_names = {}\n+            for idl_stem in modules[subfolder]:\n+                module_names[idl_stem] = '_' + \\\n+            # sorting after lower case conversion to get true order\n+            for module_name, idl_stem in \\\n+                sorted((value, key) for (key,value) in module_names.items()):",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "6cab7e3f5c55a2ce2e78e72ac9a280d347e9a145",
    "RawMessage": "Avoid generating the exception when rcl_send_response times out. (#1136)",
    "Changes": "-    throw RCLError(\"failed to send response\");\n+    if (RCL_RET_TIMEOUT == ret) {\n+      // Warning should use line number of the current stack frame\n+      int stack_level = 1;\n+      PyErr_WarnFormat(\n+        PyExc_RuntimeWarning, stack_level, \"failed to send response (timeout): %s\",\n+        rcl_get_error_string().str);\n+      rcl_reset_error();\n+    } else {\n+      throw RCLError(\"failed to send response\");\n+    }",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "df27babd11d1a655d60ce9c5a4363f79ea8d6cf5",
    "RawMessage": "Makes topic_name a const ref",
    "Changes": "-void set_error_message_from_create_topic(dds_entity_t topic, std::string topic_name)\n+void set_error_message_from_create_topic(dds_entity_t topic, const std::string & topic_name)\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";\n+    const std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "97edce2df1030e63c9b9c50040d3fa6b4a49578c",
    "RawMessage": "Use unique mangled names when creating Content Filter Topics (#762)",
    "Changes": "+#include <atomic>\n+#include <cstdint>\n-  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX;\n+  static std::atomic<uint32_t> cft_counter{0};\n+  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX + \"_\" +\n+    std::to_string(cft_counter.fetch_add(1));",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "94f42b6b16de00f1b0543a793c6cd614843ea69e",
    "RawMessage": "Check parameter callback signature during registration. (#1425)",
    "Changes": "+                if not isinstance(result, SetParametersResult):\n+                    warnings.warn(\n+                        'Callback returned an invalid type, it should return SetParameterResult.')\n+                    result = SetParametersResult(\n+                        successful=False, reason='Callback returned an invalid type')\n+        if not callable(callback):\n+            raise TypeError('Callback must be callable, got {}', type(callback))\n+        if not callable(callback):\n+            raise TypeError('Callback must be callable, got {}', type(callback))\n+    def return_none_parameter_callback(self, parameter_list):\n+        return None\n+\n+    def test_node_set_parameters_return_none(self) -> None:\n+        # Declare a new parameter and set a callback that returns None.\n+        parameter_tuple = (\n+            'test_param',\n+            True,\n+            ParameterDescriptor()\n+        )\n+        self.node.declare_parameter(*parameter_tuple)\n+        # Tries to set the parameter with a callback that returns None.\n+        self.node.add_on_set_parameters_callback(self.return_none_parameter_callback)\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter('always', category=UserWarning)\n+            result = self.node.set_parameters(\n+                [\n+                    Parameter(\n+                        name=parameter_tuple[0],\n+                        value=parameter_tuple[1]\n+                    )\n+                ]\n+            )\n+            assert len(w) == 1, f'Expected 1 warning, but got {len(w)}'\n+            assert issubclass(w[0].category, UserWarning)\n+            assert 'Callback returned an invalid type, it should return SetParameterResult.' \\\n+                in str(w[0].message)\n+            self.assertIsInstance(result, list)\n+            self.assertIsInstance(result[0], SetParametersResult)\n+            self.assertFalse(result[0].successful)\n+            self.assertEqual(result[0].reason, 'Callback returned an invalid type')\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "3683c6f8a457de9d4e996196b0aa990420a5e087",
    "RawMessage": "Add fault injection macros and unit tests to rcl_action (#730)",
    "Changes": "+    TIMEOUT 360\n+    target_compile_definitions(test_action_client PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n-      TIMEOUT 60\n+      TIMEOUT 180\n+        target_compile_definitions(${target}${target_suffix}\n+          PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+    TIMEOUT 120\n+    target_compile_definitions(test_action_server PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ALREADY_INIT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ACTION_GOAL_HANDLE_INVALID);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ACTION_GOAL_HANDLE_INVALID);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ALREADY_INIT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n+\n+#include <string>\n+\n... [truncated] ...\n+        EXPECT_TRUE(rcutils_error_is_set());\n+        rcutils_reset_error();\n+        EXPECT_EQ(RCL_RET_OK, rcl_names_and_types_fini(&nat));\n+      }\n+    }\n+  });\n+}\n+\n+TEST_F(TestActionGraphMultiNodeFixture, rcl_get_server_names_and_types_by_node_maybe_fail)\n+{\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    rcl_names_and_types_t nat = rcl_get_zero_initialized_names_and_types();\n+    rcl_ret_t ret = rcl_action_get_server_names_and_types_by_node(\n+      &this->node, &this->allocator, this->test_graph_node_name, \"\", &nat);\n+    if (RCL_RET_OK == ret) {\n+      ret = rcl_names_and_types_fini(&nat);\n+      if (ret != RCL_RET_OK) {\n+        EXPECT_TRUE(rcutils_error_is_set());\n+        rcutils_reset_error();\n+        EXPECT_EQ(RCL_RET_OK, rcl_names_and_types_fini(&nat));\n+      }\n+    }\n+  });\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "cf43e92fb17b5e51c95406f01fa63aeb65adf75f",
    "RawMessage": "Fix tests with get_type_description service and param present (#838)",
    "Changes": "-            start_parameter_services=False)\n+            start_parameter_services=False,\n+            start_type_description_service=False)\n+        start_type_description_service = getattr(args, 'start_type_description_service', True)\n-                Parameter('use_sim_time', value=use_sim_time)\n+                Parameter('use_sim_time', value=use_sim_time),\n+                Parameter('start_type_description_service', value=start_type_description_service),\n+    '    start_type_description_service: true\\n'\n+                '  start_type_description_service',\n+    '    start_type_description_service: true\\n'\n-import re\n+    expected_builtin_services = {\n+        'describe_parameters': 'rcl_interfaces/srv/DescribeParameters',\n+        'get_parameter_types': 'rcl_interfaces/srv/GetParameterTypes',\n+        'get_parameters': 'rcl_interfaces/srv/GetParameters',\n+        'get_type_description': 'type_description_interfaces/srv/GetTypeDescription',\n+        'list_parameters': 'rcl_interfaces/srv/ListParameters',\n+        'set_parameters': 'rcl_interfaces/srv/SetParameters',\n+        'set_parameters_atomically': 'rcl_interfaces/srv/SetParametersAtomically',\n+    }\n+    builtin_service_count = len(expected_builtin_services)\n+    @classmethod\n+    def get_expected_builtin_services(cls, namespace: str, with_types: bool = False) -> list[str]:\n+        return [\n+            f'{namespace}/{srv_name}' + (f' [{srv_type}]' if with_types else '')\n+            for srv_name, srv_type in cls.expected_builtin_services.items()\n+        ]\n+\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/_hidden_echo_server/.*parameter.*'\n-                ), 6),\n+                self.get_expected_builtin_services('/my_ns/_hidden_echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server'),\n-                itertools.repeat(re.compile(\n-                    r'/my_ns/echo_server/.*parameter.*'\n-                    r' \\[rcl_interfaces/srv/.*Parameter.*\\]'\n-                ), 6)\n+                self.get_expected_builtin_services('/my_ns/echo_server', with_types=True)\n-        assert int(output_lines[0]) == 7\n+        assert int(output_lines[0]) == self.builtin_service_count + 1",
    "BackportedTo": "iron",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "8f2e17e441399974ebd465a2d2ef0a3529f57f23",
    "RawMessage": "Added DepthCloud default plugin (#996)",
    "Changes": "-| Effort                | Measure       | First Person          | Selections      |\n-| Fluid                 | Select        | Third Person Follower | Time            |\n-| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Grid Cells            | Publish Point |                       | Views           |\n-| Illuminance           | Initial Pose  |\n-| Image                 | Interact      |\n+| DepthCloud            | Measure       | First Person          | Selections      |\n+| Effort                | Select        | Third Person Follower | Time            |\n+| Fluid                 | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Grid                  | Publish Point |                       | Views           |\n+| Grid Cells            | Initial Pose  |\n+| Illuminance           | Interact      |\n+| Image                 |\n-These features have not been ported to `ros2/rviz` yet.\n-\n-| Displays      |\n-| ------------- |\n-| DepthCloud    |\n-\n+  src/rviz_common/depth_cloud_mld.cpp\n+/*\n+ * Copyright (c) 2012, Willow Garage, Inc.\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n... [truncated] ...\n+class DepthCloudDisplayPageObject : public BasePageObject\n+{\n+public:\n+  DepthCloudDisplayPageObject();\n+\n+  void setTopicFilter(bool visibility);\n+  void setDepthMapTopic(QString topic);\n+  void setDepthMapTransport(QString type);\n+  void setImageMapTopic(QString topic);\n+  void setImageMapTransport(QString type);\n+  void setQueueSize(int size);\n+  void setOclusionCompensation(bool visibility);\n+  void setSelectable(bool selectable);\n+  void setStyle(QString points);\n+  void setSize(int size);\n+  void setAlpha(float size);\n+  void setDecay(int size);\n+};\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__DEPTH_CLOUD_PAGE_OBJECT_HPP_\n+#include <string>\n-  ImagePublisher()\n+  explicit ImagePublisher(const std::string & topic_name = \"image\")\n-    publisher = this->create_publisher<sensor_msgs::msg::Image>(\"image\", 10);\n+    publisher = this->create_publisher<sensor_msgs::msg::Image>(topic_name, 10);",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "7fb093ba17daa6fdacb22d383c1e90933b860de9",
    "RawMessage": "Remove `SHARED` (#1305)",
    "Changes": "-pybind11_add_module(_rclpy_pybind11 SHARED\n+pybind11_add_module(_rclpy_pybind11",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "bfe00f71b7056bb64b27a8d5f5bacefe0564c43e",
    "RawMessage": "Properly initialize the char array used in type hash calculations. (#1182)",
    "Changes": "+#include \"./common.h\"\n+\n+  rcl_allocator_t allocator = rcl_get_default_allocator();\n-  msg_repr.allocator = rcl_get_default_allocator();\n+  rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+  if (rcutils_result != RCL_RET_OK) {\n+    // rcutils_char_array_init already set the error\n+    return rcl_convert_rcutils_ret_to_rcl_ret(rcutils_result);\n+  }\n-    msg_repr.allocator = rcl_get_default_allocator();\n+    rcl_allocator_t allocator = rcl_get_default_allocator();\n+    rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+    ASSERT_EQ(rcutils_result, RCL_RET_OK);\n-    msg_repr.allocator = rcl_get_default_allocator();\n+    rcl_allocator_t allocator = rcl_get_default_allocator();\n+    rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+    ASSERT_EQ(rcutils_result, RCL_RET_OK);",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "c9c13dc40333772dd9bb059e1f8e4535a6a12218",
    "RawMessage": "Added benchmark test to rmw_implementation (#127)",
    "Changes": "+\n+    find_package(performance_test_fixture REQUIRED)\n+    # Give cppcheck hints about macro definitions coming from outside this package\n+    get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n+\n+    macro(benchmark_rmws)\n+      find_package(${rmw_implementation} REQUIRED)\n+      message(STATUS \"Creating API tests for '${rmw_implementation}'\")\n+      set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n+\n+      add_performance_test(benchmark_symbols${target_suffix} test/benchmark/benchmark_symbols.cpp\n+        ENV ${rmw_implementation_env_var})\n+      if(TARGET benchmark_symbols${target_suffix})\n+        target_link_libraries(benchmark_symbols${target_suffix} ${PROJECT_NAME})\n+      endif()\n+    endmacro()\n+    call_for_each_rmw_implementation(benchmark_rmws)\n+  <test_depend>performance_test_fixture</test_depend>\n+static std::shared_ptr<rcpputils::SharedLibrary> g_rmw_lib = nullptr;\n+\n-  static std::shared_ptr<rcpputils::SharedLibrary> lib;\n-  if (!lib) {\n-    lib = load_library();\n+  if (!g_rmw_lib) {\n+    g_rmw_lib = load_library();\n... [truncated] ...\n+// limitations under the License.\n+\n+#include <memory>\n+\n+#include \"performance_test_fixture/performance_test_fixture.hpp\"\n+\n+#include \"../../src/functions.hpp\"\n+\n+using performance_test_fixture::PerformanceTest;\n+\n+BENCHMARK_F(PerformanceTest, prefetch_symbols)(benchmark::State & st)\n+{\n+  for (auto _ : st) {\n+    prefetch_symbols();\n+    unload_library();\n+  }\n+}\n+\n+BENCHMARK_F(PerformanceTest, lookup_symbol)(benchmark::State & st)\n+{\n+  for (auto _ : st) {\n+    std::shared_ptr<rcpputils::SharedLibrary> lib = load_library();\n+    lookup_symbol(lib, \"rmw_init\");\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "72263582894a45c0f4d07ab53450823a44622c4f",
    "RawMessage": "Efficiently handle 3-bytes pixel formats (#743)",
    "Changes": "-  auto w = box.getWidth();\n-  auto h = box.getHeight();\n+  uint32_t w = box.getWidth();\n+  uint32_t h = box.getHeight();\n-  for (uint32_t y = 0; y < h; ++y) {\n-    for (uint32_t x = 0; x < w; ++x) {\n-      uint32_t pos = (x + y * w) * 4;\n-\n-      uint32_t pix_val = *reinterpret_cast<uint32_t *>(static_cast<uint8_t *>(box.data) + pos);\n-      uint32_t handle = colorToHandle(box.format, pix_val);\n-\n-      pixel_buffer_.push_back(handle);\n+  size_t size = Ogre::PixelUtil::getMemorySize(1, 1, 1, box.format);\n+\n+  for (uint32_t y = 0; y < h; y++) {\n+    for (uint32_t x = 0; x < w; x++) {\n+      uint32_t pos = static_cast<uint32_t>((x + y * w) * size);\n+      uint32_t pix_val = 0;\n+      memcpy(\n+        reinterpret_cast<uint8_t *>(&pix_val),\n+        reinterpret_cast<uint8_t *>(box.data + pos),\n+        size);\n+      pixel_buffer_.push_back(colorToHandle(box.format, pix_val));",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "93d4074a8bfd4d584cf5fdef22a88121e15e0352",
    "RawMessage": "remove feedback callback when the goal has been completed. (#927)",
    "Changes": "-        self._sequence_number_to_goal_id = {}\n+        self._goal_sequence_number_to_goal_id = {}\n+        # key: result request sequence_number, value: UUID\n+        self._result_sequence_number_to_goal_id = {}\n-        if seq in self._sequence_number_to_goal_id:\n-            del self._sequence_number_to_goal_id[seq]\n+        if seq in self._goal_sequence_number_to_goal_id:\n+            del self._goal_sequence_number_to_goal_id[seq]\n-        self._remove_pending_request(future, self._pending_result_requests)\n+        seq = self._remove_pending_request(future, self._pending_result_requests)\n+        if seq in self._result_sequence_number_to_goal_id:\n+            goal_uuid = bytes(self._result_sequence_number_to_goal_id[seq].uuid)\n+            del self._result_sequence_number_to_goal_id[seq]\n+            # remove feeback_callback if user is aware of result and it's been received\n+            if goal_uuid in self._feedback_callbacks:\n+                del self._feedback_callbacks[goal_uuid]\n-            if sequence_number in self._sequence_number_to_goal_id:\n+            if sequence_number in self._goal_sequence_number_to_goal_id:\n-                    self._sequence_number_to_goal_id[sequence_number],\n+                    self._goal_sequence_number_to_goal_id[sequence_number],\n-        self._sequence_number_to_goal_id[sequence_number] = request.goal_id\n+        self._goal_sequence_number_to_goal_id[sequence_number] = request.goal_id\n+        self._result_sequence_number_to_goal_id[sequence_number] = result_request.goal_id\n+    def test_send_goal_async_with_feedback_after_goal_result_requested(self):\n+        ac = ActionClient(self.node, Fibonacci, 'fibonacci')\n+        try:\n+            self.assertTrue(ac.wait_for_server(timeout_sec=2.0))\n+\n+            # Send a goal and wait for completion\n+            goal_uuid = UUID(uuid=list(uuid.uuid4().bytes))\n+            goal_future = ac.send_goal_async(\n+                Fibonacci.Goal(),\n+                feedback_callback=self.feedback_callback,\n+                goal_uuid=goal_uuid)\n+            rclpy.spin_until_future_complete(self.node, goal_future, self.executor)\n+            self.assertTrue(goal_future.done())\n+            # Then request result\n+            goal_handle = goal_future.result()\n+            result_future = goal_handle.get_result_async()\n+            rclpy.spin_until_future_complete(self.node, result_future, self.executor)\n+            self.assertTrue(result_future.done())\n+\n+            # Publish feedback after goal result is requested\n+            self.mock_action_server.publish_feedback(goal_uuid)\n+            self.timed_spin(1.0)\n+            self.assertEqual(self.feedback, None)\n+        finally:\n+            ac.destroy()\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "7bcc2939233dca1a04a3702807aac1f6a05014fc",
    "RawMessage": "Fix for incorrect integer value conversion on Windows (#1126)",
    "Changes": "-    ival = strtol(value, &endptr, 0);\n+    ival = strtoll(value, &endptr, 0);\n-      if ((NULL != endptr) && (endptr != value)) {\n+      if (endptr != value) {\n-      id: 11\n+      id: 992147483647\n-    EXPECT_EQ(11, *param_value->integer_value);\n+    // Make sure that we can correctly parse bigger than LONG_MAX = 2147483647 values\n+    EXPECT_EQ(992147483647, *param_value->integer_value);",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "bd54a040ac1b043474ede4c12af7c867d9143008",
    "RawMessage": "Add a SetParameter action that sets a parameter to all nodes in the same scope (#158)",
    "Changes": "+from .set_parameter import SetParameter\n+    'SetParameter',\n+from ..utilities.normalize_parameters import normalize_parameter_dict\n-        request = composition_interfaces.srv.LoadNode.Request()\n-        request.package_name = perform_substitutions(\n-            context, composable_node_description.package\n-        )\n-        request.plugin_name = perform_substitutions(\n-            context, composable_node_description.node_plugin\n-        )\n-        if composable_node_description.node_name is not None:\n-            request.node_name = perform_substitutions(\n-                context, composable_node_description.node_name\n-            )\n-        if composable_node_description.node_namespace is not None:\n-            request.node_namespace = perform_substitutions(\n-                context, composable_node_description.node_namespace\n-            )\n-        # request.log_level = perform_substitutions(context, node_description.log_level)\n-        if composable_node_description.remappings is not None:\n-            for from_, to in composable_node_description.remappings:\n-                request.remap_rules.append('{}:={}'.format(\n-                    perform_substitutions(context, list(from_)),\n-                    perform_substitutions(context, list(to)),\n-                ))\n... [truncated] ...\n+    set_param_2.execute(lc)\n+    request = get_composable_node_load_request(node_description, lc)\n+    parameters = request.parameters\n+    assert len(parameters) == 3\n+    assert parameters[0].name == 'my_param'\n+    assert parameters[0].value.string_value == 'my_value'\n+    assert parameters[1].name == 'asd'\n+    assert parameters[1].value.string_value == 'csd'\n+    assert parameters[2].name == 'asd'\n+    assert parameters[2].value.string_value == 'bsd'\n+\n+    lc = MockContext()\n+    node_description = ComposableNode(\n+        package='asd',\n+        plugin='my_plugin',\n+        name='my_node',\n+        namespace='my_ns',\n+    )\n+    set_param = SetParameter(name='my_param', value='my_value')\n+    set_param.execute(lc)\n+    request = get_composable_node_load_request(node_description, lc)\n+    parameters = request.parameters\n+    assert len(parameters) == 1\n+    assert parameters[0].name == 'my_param'\n+    assert parameters[0].value.string_value == 'my_value'",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "f2e8d1ce785e06815fb499cd5fbe69ed8438febe",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#909)",
    "Changes": "-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n-`rcl` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rcl` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-All changes will occur through a pull request, check the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All changes will occur through a pull request, check the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-All pull requests will be peer-reviewed, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All pull requests will be peer-reviewed, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-`rcl` provides the main elements of its API listed using doxygen. Refer to the [ROS2 concepts](https://index.ros.org/doc/ros2/Concepts/) and [ROS2 Client Libraries](https://index.ros.org/doc/ros2/Concepts/ROS-2-Client-Libraries/) pages for reference of elements covered by this package.\n+`rcl` provides the main elements of its API listed using doxygen. Refer to the [ROS2 concepts](https://docs.ros.org/en/rolling/Concepts.html) and [ROS2 Client Libraries](https://docs.ros.org/en/rolling/Concepts/About-ROS-2-Client-Libraries.html) pages for reference of elements covered by this package.\n-`rcl` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcl` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_src_rcl/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_src_rcl/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcl` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcl` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcl` uses and passes all the ROS2 standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n+`rcl` uses and passes all the ROS2 standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n-`rcl_action` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rcl_action` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rcl_action` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rcl_action` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-`rcl_action` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n... [truncated] ...\n+`rcl_lifecycle` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rcl_lifecycle` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rcl_lifecycle` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-`rcl_lifecycle` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcl_lifecycle` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_lifecycle_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_lifecycle_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcl_lifecycle` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcl_lifecycle` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcl_lifecycle` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rcl_lifecycle` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n-`rcl_yaml_param_parser` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rcl_yaml_param_parser` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rcl_yaml_param_parser` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rcl_yaml_param_parser` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-`rcl_yaml_param_parser` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcl_yaml_param_parser` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_yaml_param_parser_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_yaml_param_parser_src/). A description of how coverage statistics are calculated is summarized in this page [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcl_yaml_param_parser` follows the recommendations for performance testing of C/C++ code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcl_yaml_param_parser` follows the recommendations for performance testing of C/C++ code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcl_yaml_param_parser` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rcl_yaml_param_parser` uses and passes all the standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "4a4da3e2950dfbd5cd4b348e1959558f77e3ac1d",
    "RawMessage": "Add rviz_rendering dependency to rviz_common (#727)",
    "Changes": "-  rviz_rendering::rviz_rendering\n+  rviz_rendering",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "263bf9d7f8b528865401d63818d32317e1f36f2f",
    "RawMessage": "Set yaml_variant values to NULL on finalization (#765)",
    "Changes": "+    param_var->bool_value = NULL;\n+    param_var->integer_value = NULL;\n+    param_var->double_value = NULL;\n+    param_var->string_value = NULL;\n+    param_var->bool_array_value = NULL;\n+    param_var->integer_array_value = NULL;\n+    param_var->double_array_value = NULL;\n+    param_var->string_array_value = NULL;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "5328e9db40a10cc0f5353509322bb9282a9812ea",
    "RawMessage": "Remove minimum dds version as raw typesupport removed",
    "Changes": "-  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-2.8</build_export_depend>\n-  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-2.8</build_export_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "add6b0a0c4565fe7ba0ef8da36018c8f2b84b019",
    "RawMessage": "Yuv to rgb changes (#701)",
    "Changes": "+  uint32_t stride_;\n+  std::shared_ptr<std::vector<uint8_t>> bufferptr_;\n+#include <memory>\n-  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n-    ImageData(image->encoding, image->data.data(), image->data.size()));\n-\n+  stride_ = image->step;\n+\n+  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n+    ImageData(image->encoding, image->data.data(), image->data.size()));\n+struct yuyv\n+{\n+  uint8_t y0;\n+  uint8_t u;\n+  uint8_t y1;\n+  uint8_t v;\n+};\n+\n+struct uyvy\n+{\n+  uint8_t u;\n+  uint8_t y0;\n+  uint8_t v;\n+  uint8_t y1;\n+};\n... [truncated] ...\n+  } else if ( // NOLINT enforces bracket on the same line, which makes code unreadable\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422 ||\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2)\n+  {\n+    size_t new_size = image_data.size_ * 3 / 2;\n+    if (!bufferptr_) {\n+      bufferptr_ = std::make_shared<std::vector<uint8_t>>(new_size);\n+    } else if (static_cast<size_t>(bufferptr_->size()) != new_size) {\n+      bufferptr_->resize(new_size, 0);\n+    }\n+\n+    if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422) {\n+      imageConvertYUV422ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    } else if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2) {\n+      imageConvertYUV422_YUY2ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    }\n+\n+\n+    image_data.pixel_format_ = Ogre::PF_BYTE_RGB;\n+    image_data.data_ptr_ = bufferptr_->data();\n+    image_data.size_ = new_size;",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "5b67ae471ba81560b51bac6b1dacfbf271e0dd22",
    "RawMessage": "Export CycloneDDS dependency (#424)",
    "Changes": "+if(_cyclonedds_has_shm)\n+  ament_export_dependencies(iceoryx_binding_c)\n+endif()\n+ament_export_dependencies(CycloneDDS)\n+ament_export_dependencies(tracetools)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "068054a54ba7d0bd2d7bb61dc9d98da990129d63",
    "RawMessage": "Add gid API test coverage. (#134)",
    "Changes": "+\n+    ament_add_gtest(test_unique_identifiers${target_suffix}\n+      test/test_unique_identifiers.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_unique_identifiers${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_unique_identifiers${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n+    )\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n... [truncated] ...\n+\n+TEST_F(CLASSNAME(TestUniqueIdentifiersForMultiplePublishers, RMW_IMPLEMENTATION), different_pubs) {\n+  rmw_gid_t gid_of_pub_for_topic0{};\n+  rmw_ret_t ret = rmw_get_gid_for_publisher(pub_for_topic0, &gid_of_pub_for_topic0);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  rmw_gid_t gid_of_first_pub_for_topic1{};\n+  ret = rmw_get_gid_for_publisher(first_pub_for_topic1, &gid_of_first_pub_for_topic1);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  rmw_gid_t gid_of_second_pub_for_topic1{};\n+  ret = rmw_get_gid_for_publisher(second_pub_for_topic1, &gid_of_second_pub_for_topic1);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  bool are_equal = true;\n+  ret = rmw_compare_gids_equal(&gid_of_pub_for_topic0, &gid_of_first_pub_for_topic1, &are_equal);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_FALSE(are_equal);\n+\n+  are_equal = true;\n+  ret = rmw_compare_gids_equal(\n+    &gid_of_first_pub_for_topic1, &gid_of_second_pub_for_topic1, &are_equal);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_FALSE(are_equal);\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw",
    "SHA": "679ca7d24cb8be205959f07a7e2018ba880ef94b",
    "RawMessage": "Update rmw_get_serialized_message_size docblock (#281)",
    "Changes": "+ * \\return `RMW_RET_UNSUPPORTED` if it's unimplemented, or",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "fc1e85e22a31545adf6c47dd732226b9f012f25e",
    "RawMessage": "Add fault injection macros to rcl functions (#727)",
    "Changes": "+if(BUILD_TESTING AND NOT RCUTILS_DISABLE_FAULT_INJECTION)\n+  target_compile_definitions(${PROJECT_NAME} PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+endif()\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID);\n+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ALREADY_INIT);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n+  RCUTILS_CAN_RETURN_WITH_ERROR_OF(RCL_RET_TOPIC_NAME_INVALID);\n+\n... [truncated] ...\n+{\n+  const rosidl_message_type_support_t * ts =\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n+  constexpr char topic[] = \"chatter\";\n+  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n+  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    rcl_ret_t ret = rcl_subscription_init(\n+      &subscription, this->node_ptr, ts, topic, &subscription_options);\n+\n+    if (RCL_RET_OK == ret) {\n+      EXPECT_TRUE(rcl_subscription_is_valid(&subscription));\n+      ret = rcl_subscription_fini(&subscription, this->node_ptr);\n+      if (RCL_RET_OK != ret) {\n+        // If fault injection caused fini to fail, we should try it again.\n+        EXPECT_EQ(RCL_RET_OK, rcl_subscription_fini(&subscription, this->node_ptr));\n+      }\n+    } else {\n+      EXPECT_TRUE(rcl_error_is_set());\n+      rcl_reset_error();\n+    }\n+  });\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "1ed02409a2a31ebdf9bbbae881ca4e71ce5ca375",
    "RawMessage": "update codecov to ignore rclc_examples and all test folders (#145)",
    "Changes": "-  - \"rclc_examples\"\n-  - \"rclc/test\"\n-  - \"rclc_lifecycle/test\"\n+  - \"rclc_examples/**/*\"\n+  - \"rclc/test/**/*\"\n+  - \"rclc_lifecycle/test/**/*\"\n+  - \"rclc_parameter/test/**/*\"",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "c5edc37c45777f5b2a4001e0628036dea06b9585",
    "RawMessage": "Use gurumdds-3.1",
    "Changes": "+| 3.6.0  or higher         | higher than 3.1.0           |\n-  <build_depend>gurumdds-3.0</build_depend>\n+  <build_depend>gurumdds-3.1</build_depend>\n-  <build_depend>gurumdds-3.0</build_depend>\n+  <build_depend>gurumdds-3.1</build_depend>\n-  <build_export_depend>gurumdds-3.0</build_export_depend>\n+  <build_export_depend>gurumdds-3.1</build_export_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclcpp",
    "SHA": "5d6e5fa766b9ec1237a698b1eefa2733bcdeb506",
    "RawMessage": "associated clocks should be protected by mutex. (#2255)",
    "Changes": "-    for (auto it = associated_clocks_.begin(); it != associated_clocks_.end(); ++it) {\n-      set_clock(last_time_msg_, true, *it);\n-    }\n+    set_all_clocks(last_time_msg_, true);\n-    std::lock_guard<std::mutex> guard(clock_list_lock_);\n-    for (auto it = associated_clocks_.begin(); it != associated_clocks_.end(); ++it) {\n-      auto msg = std::make_shared<builtin_interfaces::msg::Time>();\n-      set_clock(msg, false, *it);\n-    }\n+    auto msg = std::make_shared<builtin_interfaces::msg::Time>();\n+    set_all_clocks(msg, false);",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "a4633b83fa45eead06a43e83c7bce34224c70faf",
    "RawMessage": "Add `~/get_type_description` service (rep2011) (#1052)",
    "Changes": "+  src/rcl/node_type_cache.c\n+  src/rcl/type_description_conversions.c\n+#include \"type_description_interfaces/srv/get_type_description.h\"\n+\n+typedef struct rcl_service_s rcl_service_t;\n+/// Initialize the node's ~/get_type_description service.\n+/**\n+ * This function initializes the node's ~/get_type_description service\n+ * which can be used to retrieve information about types used by the node's\n+ * publishers, subscribers, services or actions.\n+ *\n+ * Note that this will not register any callback for the service, client-level code\n+ * must register rcl_node_type_description_service_handle_request or a custom callback\n+ * to handle incoming requests, via that client's executor/waitset capabilities.\n+ *\n+ * This will initialize the node's type cache, if it has not been initialized already.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n... [truncated] ...\n+  action_client->impl->type_hash = *type_support->get_type_hash_func(type_support);\n+\n+  rosidl_type_hash_t type_hash;\n+#include \"rcl/node_type_cache.h\"\n+  action_server->impl->type_hash = rosidl_get_zero_initialized_type_hash();\n+\n+  // Store type hash\n+  if (RCL_RET_OK != rcl_node_type_cache_register_type(\n+      node, type_support->get_type_hash_func(type_support),\n+      type_support->get_type_description_func(type_support),\n+      type_support->get_type_description_sources_func(type_support)))\n+  {\n+    rcutils_reset_error();\n+    RCL_SET_ERROR_MSG(\"Failed to register type for action\");\n+    goto fail;\n+  }\n+  action_server->impl->type_hash = *type_support->get_type_hash_func(type_support);\n+\n+    if (\n+      ROSIDL_TYPE_HASH_VERSION_UNSET != action_server->impl->type_hash.version &&\n+      RCL_RET_OK != rcl_node_type_cache_unregister_type(node, &action_server->impl->type_hash))\n+    {\n+      ret = RCL_RET_ERROR;\n+    }\n+  rosidl_type_hash_t type_hash;",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "705efff90be1ed31cf51b3f6e4ae4744b365c6ba",
    "RawMessage": "Add test dependencies for rclc_parameter (#156)",
    "Changes": "-  \n+  <test_depend>example_interfaces</test_depend>\n+  <test_depend>osrf_testing_tools_cpp</test_depend>\n+  <test_depend>std_msgs</test_depend>\n+",
    "BackportedTo": "galactic",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "384d9c60def93e38ac4c01ddbed17a4731bc4424",
    "RawMessage": "Remove unused LineEditWithButton::simulateReturnPressed() (#1040)",
    "Changes": "-  /** @brief Send key events to mimic the \"return\" key being pressed and\n-   * released.  Useful ending an edit session and sending the data on\n-   * out. */\n-  void simulateReturnPressed();\n-\n-\n-void LineEditWithButton::simulateReturnPressed()\n-{\n-  // I couldn't find a way to directly tell the editor that I was\n-  // done with it here.  \"Q_EMIT returnPressed()\", \"Q_EMIT\n-  // editingFinished()\" etc did nothing.  So instead, here I\n-  // simulate the user pressing and releasing the \"Return\" key,\n-  // which does indeed make it act like I want: when you select a\n-  // topic from the dialog and the dialog closes, the property's\n-  // Setter is called and this editor closes.\n-  QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier);\n-  QApplication::postEvent(this, event);\n-  event = new QKeyEvent(QEvent::KeyRelease, Qt::Key_Return, Qt::NoModifier);\n-  QApplication::postEvent(this, event);\n-}\n-",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "392f0d3ae6a29d4b88689b954b14f19716e44233",
    "RawMessage": "Fix buffer overflow in argument parsing caused by lexer returning length beyond length of string (#979)",
    "Changes": "+ * It will never be longer than the length of the string.\n-    // Move the lexer to another character in the string\n-      // Go forwards 1 char\n-      ++(*length);\n+      if ('\\0' != current_char) {\n+        // Go forwards 1 char as long as the end hasn't been reached\n+        ++(*length);\n+      }\n+  if (RCL_LEXEME_NONE == *next_type1 || RCL_LEXEME_EOF == *next_type1) {\n+    // No need to peek further\n+    *next_type2 = *next_type1;\n+    return ret;\n+  }\n+\n-    std::string actual_text(text, length); \\\n+    std::string actual_text(text, 0u, length); \\\n+    EXPECT_EQ(length, actual_text.size()); \\\n+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_no_lexeme)\n+{\n+  rcl_ret_t ret;\n+  rcl_lexer_lookahead2_t buffer;\n+  SCOPE_LOOKAHEAD2(buffer, \"~foo\");\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n... [truncated] ...\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n+\n+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme1);\n+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme2);\n+}\n+\n+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_eof)\n+{\n+  rcl_ret_t ret;\n+  rcl_lexer_lookahead2_t buffer;\n+  SCOPE_LOOKAHEAD2(buffer, \"\");\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n+\n+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme1);\n+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme2);\n+}\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "875ec1a06ecfcce9d4f261e261c562e14eaf4fac",
    "RawMessage": "Add null handling",
    "Changes": "+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "6ae73ca28e003c547746ad33f30d170625e362ce",
    "RawMessage": "Feature/updated documentation executor (#117)",
    "Changes": "-Therefore at initialization of the RCLC-Executor, the user defines the total number of handles `number_of_handles`.\n-The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase.\n-This makes this Executor static in the sense, that during runtime no additional callbacks can be added.\n+Therefore at initialization of the RCLC-Executor, the user defines the total number of handles `number_of_handles`. A handle is a term for subscriptions, timers, services, clients and guard conditions. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. The corresponding wait-set is allocated in the first execution of the spin-method or in the optional call to `rclc_executor_prepare` .\n+This makes this Executor static in the sense, that during runtime no heap allocations occur. You can add, however, at runtime as many handles, e.g. subscriptions, to the executor until the maximum number of handles is reached.\n+ * As the Executor is intended for embedded controllers, dynamic memory management is crucial.\n+ *  Therefore at initialization of the RCLC-Executor, the user defines the total \\p number_of_handles.\n+ * A handle is a term for subscriptions, timers, services, clients and guard conditions. The\n+ * heap will be allocated only in this phase and no more memory will be allocated in the\n+ * running phase in the executor. However, the heap memory of corresponding wait-set is\n+ * allocated in the first iteration of a spin-method, which calls internally rclc_executor_prepare.\n+ * Optionally, you can also call rclc_executor_prepare before calling any of the spin-methods.\n+ * Then all wait-set related memory allocation will be done in rclc_executor_prepare and not\n+ * in the first iteration of the spin-method.\n+ *\n+ * This makes this Executor static in\n+ * terms of memory allocation, in the sense, that during runtime no heap allocations occur.\n+ * You can add, however, at runtime as many handles, e.g. subscriptions, to the executor\n+ * until the maximum number of handles is reached. In this case, the wait-set needs to be\n+ * updated and rclc_executor_prepare is called again (with dynamic memory allocation in RCL).",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "635ba7c7b9a42f17cdb090d391dcea4dcccb8adb",
    "RawMessage": "Handle null string",
    "Changes": "-      throw std::runtime_error(\"Invalid string value\");\n+      dst = std::string(\"\");\n+      return;\n-      throw std::runtime_error(\"Invalid wstring value\");\n+      dst = std::u16string(u\"\");\n+      return;\n-        throw std::runtime_error(\"Invalid string value\");\n+        dst.data[0] = '\\0';\n+        dst.size = 0;\n+        dst.capacity = 1;\n+        return;\n-        throw std::runtime_error(\"Invalid wstring value\");\n+        dst.data[0] = u'\\0';\n+        dst.size = 0;\n+        dst.capacity = 1;\n+        return;",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b85657b2b52852accbdea1feb4f951f62c67a1be",
    "RawMessage": "Remove sleep from entity creation",
    "Changes": "-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "5cf8420511fbf64a741e94c493445adccf05e272",
    "RawMessage": "Added rmw_event_type_is_supported (#395)",
    "Changes": "+\n+/// Check if an event type is supported by the RMW implementation.\n+/*\n+ * \\param[in] rmw_event_type to check\n+ * \\return True if the event is supported false otherwise.\n+ */\n+RMW_PUBLIC\n+RMW_WARN_UNUSED\n+bool\n+rmw_event_type_is_supported(rmw_event_type_t rmw_event_type);\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "0c51ac895eebaf5a0b1ee0358649af941d1b9d70",
    "RawMessage": "Updated error returns on rmw_take_serialized and with_message_info (#242)",
    "Changes": "-  RET_NULL(taken);\n-  RET_NULL(serialized_message);\n-  RET_NULL(subscription);\n-  RET_WRONG_IMPLID(subscription);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    serialized_message, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_info, RMW_RET_INVALID_ARGUMENT);\n+",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "5ee7ad4e7811902af7e07f515904e02e811f230a",
    "RawMessage": "Handle take failure in wait_for_message (#1172)",
    "Changes": "-            return (True, msg_info[0])\n+            if msg_info is not None:\n+                return (True, msg_info[0])",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "159ced49bb904511154d9f6e595b64e1f5c0d8c0",
    "RawMessage": "Fix an inherent race in execution vs. destruction. (#1150)",
    "Changes": "-        with tmr.handle:\n-            tmr.handle.call_timer()\n-        return ()\n+        try:\n+            with tmr.handle:\n+                tmr.handle.call_timer()\n+\n+                async def _execute():\n+                    await await_or_execute(tmr.callback)\n+                return _execute\n+        except InvalidHandle:\n+            # Timer is a Destroyable, which means that on __enter__ it can throw an\n+            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n+            # by just returning an empty argument, which means we will skip doing any real work\n+            # in _execute_timer below\n+            pass\n-    async def _execute_timer(self, tmr):\n-        await await_or_execute(tmr.callback)\n+        return None\n-        with sub.handle:\n-            msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n-            if msg_info is not None:\n+        try:\n+            with sub.handle:\n+                msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n... [truncated] ...\n+                # The take_from_wait_list method here is expected to return either an async def\n+                # method or None if there is no work to do.\n+                call_coroutine = take_from_wait_list(entity)\n-                    await call_coroutine(entity, *arg)\n+                    if call_coroutine is not None:\n+                        await call_coroutine()\n-                                handler = self._make_handler(\n-                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n+                                handler = self._make_handler(wt, node, self._take_waitable)\n-                                handler = self._make_handler(\n-                                    tmr, node, self._take_timer, self._execute_timer)\n+                                handler = self._make_handler(tmr, node, self._take_timer)\n-                            handler = self._make_handler(\n-                                sub, node, self._take_subscription, self._execute_subscription)\n+                            handler = self._make_handler(sub, node, self._take_subscription)\n-                            handler = self._make_handler(\n-                                gc, node, self._take_guard_condition,\n-                                self._execute_guard_condition)\n+                            handler = self._make_handler(gc, node, self._take_guard_condition)\n-                            handler = self._make_handler(\n-                                client, node, self._take_client, self._execute_client)\n+                            handler = self._make_handler(client, node, self._take_client)\n-                            handler = self._make_handler(\n-                                srv, node, self._take_service, self._execute_service)\n+                            handler = self._make_handler(srv, node, self._take_service)",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "e8746fe7b92ae1f5744e7c8d86bdb70e44220f82",
    "RawMessage": "Added rmw_service_server_is_available tests (#140)",
    "Changes": "+      TIMEOUT 120\n+#include \"rcutils/testing/fault_injection.h\"\n-    constexpr char service_name[] = \"/test\";\n-    const rosidl_service_type_support_t * ts =\n-      ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n-    client = rmw_create_client(node, ts, service_name, &rmw_qos_profile_default);\n+    client = rmw_create_client(node, ts, service_name, &qos_profile);\n+  const char * const service_name = \"/test\";\n+  const rosidl_service_type_support_t * ts{\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes)};\n+  rmw_qos_profile_t qos_profile{rmw_qos_profile_default};\n+\n+TEST_F(CLASSNAME(TestClientUse, RMW_IMPLEMENTATION), service_server_is_available_bad_args)\n+{\n+  bool is_available;\n+  rmw_ret_t ret = rmw_service_server_is_available(nullptr, client, &is_available);\n+  EXPECT_EQ(ret, RMW_RET_ERROR) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_service_server_is_available(node, nullptr, &is_available);\n+  EXPECT_EQ(ret, RMW_RET_ERROR) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_service_server_is_available(node, client, nullptr);\n+  EXPECT_EQ(ret, RMW_RET_ERROR) << rmw_get_error_string().str;\n... [truncated] ...\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestClient, RMW_IMPLEMENTATION), create_client_with_internal_errors)\n+{\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    const rosidl_service_type_support_t * ts = ROSIDL_GET_SRV_TYPE_SUPPORT(\n+      test_msgs, srv, BasicTypes);\n+    rmw_client_t * client_fault = rmw_create_client(\n+      node, ts, \"/service_name_test\",\n+      &rmw_qos_profile_default);\n+\n+    int64_t count = rcutils_fault_injection_get_count();\n+    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n+\n+    if (client_fault != nullptr) {\n+      rmw_ret_t ret = rmw_destroy_client(node, client_fault);\n+      EXPECT_EQ(ret, RMW_RET_OK) << rcutils_get_error_string().str;\n+    } else {\n+      rmw_reset_error();\n+    }\n+    rcutils_fault_injection_set_count(count);\n+  });\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "6cbe07025506233120703bc88e6a2123615e2e97",
    "RawMessage": "Fix flaky ros2 param list (#656)",
    "Changes": "-        with DirectNode(args) as node:\n+        with NodeStrategy(args) as node:\n+        with DirectNode(args) as node:\n+    @launch_testing.markers.retry_on_failure(times=5, delay=1)",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "common_interfaces",
    "SHA": "f22c4360b5bbd59c6780b9ba155eaaa20da1adc1",
    "RawMessage": "Add equidistant distortion model (#160)",
    "Changes": "+const char EQUIDISTANT[] = \"equidistant\";",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "8f2e17e441399974ebd465a2d2ef0a3529f57f23",
    "RawMessage": "Added DepthCloud default plugin (#996)",
    "Changes": "-| Effort                | Measure       | First Person          | Selections      |\n-| Fluid                 | Select        | Third Person Follower | Time            |\n-| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Grid Cells            | Publish Point |                       | Views           |\n-| Illuminance           | Initial Pose  |\n-| Image                 | Interact      |\n+| DepthCloud            | Measure       | First Person          | Selections      |\n+| Effort                | Select        | Third Person Follower | Time            |\n+| Fluid                 | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Grid                  | Publish Point |                       | Views           |\n+| Grid Cells            | Initial Pose  |\n+| Illuminance           | Interact      |\n+| Image                 |\n-These features have not been ported to `ros2/rviz` yet.\n-\n-| Displays      |\n-| ------------- |\n-| DepthCloud    |\n-\n+  src/rviz_common/depth_cloud_mld.cpp\n+/*\n+ * Copyright (c) 2012, Willow Garage, Inc.\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n... [truncated] ...\n+class DepthCloudDisplayPageObject : public BasePageObject\n+{\n+public:\n+  DepthCloudDisplayPageObject();\n+\n+  void setTopicFilter(bool visibility);\n+  void setDepthMapTopic(QString topic);\n+  void setDepthMapTransport(QString type);\n+  void setImageMapTopic(QString topic);\n+  void setImageMapTransport(QString type);\n+  void setQueueSize(int size);\n+  void setOclusionCompensation(bool visibility);\n+  void setSelectable(bool selectable);\n+  void setStyle(QString points);\n+  void setSize(int size);\n+  void setAlpha(float size);\n+  void setDecay(int size);\n+};\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__DEPTH_CLOUD_PAGE_OBJECT_HPP_\n+#include <string>\n-  ImagePublisher()\n+  explicit ImagePublisher(const std::string & topic_name = \"image\")\n-    publisher = this->create_publisher<sensor_msgs::msg::Image>(\"image\", 10);\n+    publisher = this->create_publisher<sensor_msgs::msg::Image>(topic_name, 10);",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "1b01127ae2b9bcec4fef7c733fc7f680aacf5c7f",
    "RawMessage": "Set disable loan to on by default. (#1110)",
    "Changes": "- * - disable_loaned_message = false, true only if ROS_DISABLE_LOANED_MESSAGES=1\n+ * - disable_loaned_message = true, false only if ROS_DISABLE_LOANED_MESSAGES=0\n+#include \"rcutils/env.h\"\n-  bool disable_loaned_message = false;\n-  rcl_ret_t ret = rcl_get_disable_loaned_message(&disable_loaned_message);\n-  if (ret == RCL_RET_OK) {\n-    default_options.disable_loaned_message = disable_loaned_message;\n-  } else {\n+  // TODO(clalancette): This is kind of a copy of rcl_get_disable_loaned_message(), but we need\n+  // more information than that function provides.\n+  default_options.disable_loaned_message = true;\n+\n+  const char * env_val = NULL;\n+  const char * env_error_str = rcutils_get_env(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR, &env_val);\n+  if (NULL != env_error_str) {\n-    RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n-    rcl_reset_error();\n-    default_options.disable_loaned_message = false;\n+    RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+      \"Error getting env var: '\" RCUTILS_STRINGIFY(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR) \"': %s\\n\",\n+      env_error_str);\n+  } else {\n+    default_options.disable_loaned_message = !(strcmp(env_val, \"0\") == 0);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+  }\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "a7ea3df669cce90383f823945fb8d2623d7f2aa9",
    "RawMessage": "Remove unnecessary operation",
    "Changes": "-  void operator<<(std::string src)\n+  void operator<<(const std::string & src)\n-  void operator<<(std::u16string src)\n+  void operator<<(const std::u16string & src)\n-    *this << static_cast<uint32_t>(src.size() + 1);\n-    align(4);  // align of wchar\n+    *this << static_cast<uint32_t>(src.size());\n+    align(2);  // align of wchar\n-      if (offset + ((src.size() + 1) * 4) > size) {\n+      if (offset + (src.size() * 2) > size) {\n-      auto dst = reinterpret_cast<uint32_t *>(buf + offset);\n+      auto dst = reinterpret_cast<uint16_t *>(buf + offset);\n-        *(dst + i) = static_cast<uint32_t>(src[i]);\n+        *(dst + i) = static_cast<uint16_t>(src[i]);\n-    advance((src.size() + 1) * 4);\n+    advance(src.size() * 2);\n-  void operator<<(rosidl_runtime_c__String src)\n+  void operator<<(const rosidl_runtime_c__String & src)\n-  void operator<<(rosidl_runtime_c__U16String src)\n+  void operator<<(const rosidl_runtime_c__U16String & src)\n-    *this << static_cast<uint32_t>(src.size + 1);\n-    align(4);  // align of wchar\n+    *this << static_cast<uint32_t>(src.size);\n+    align(2);  // align of wchar\n-      if (offset + (src.size + 1) * 4 > size) {\n... [truncated] ...\n+  auto & suffix = suffixes[prefix];\n-  auto suffixes = {\n+  static const std::string suffixes[] = {\n-  for (auto suffix : suffixes) {\n+  for (const auto & suffix : suffixes) {\n-  std::string node_user_data =\n-    std::string(\"name=\") + std::string(name) + std::string(\";namespace=\") +\n-    std::string(namespace_) + std::string(\";securitycontext=\") +\n-    std::string(context->options.enclave) + std::string(\";\");\n+  std::string node_user_data;\n+  node_user_data.reserve(256);\n+  node_user_data += \"name=\";\n+  node_user_data += name;\n+  node_user_data += \";namespace=\";\n+  node_user_data += namespace_;\n+  node_user_data += \";securitycontext=\";\n+  node_user_data += context->options.enclave;\n+  node_user_data += \";\";\n+\n-    [&](auto tnt) -> bool {\n+    [&](auto & tnt) -> bool {\n-  for (auto it : topic_cache.get_entity_guid_to_info()) {\n+  for (auto & it : topic_cache.get_entity_guid_to_info()) {\n-  for (auto it : topic_cache.get_entity_guid_to_info()) {\n+  for (auto & it : topic_cache.get_entity_guid_to_info()) {",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "99f6b140d4e8ac029f5cfc78ae5e684a04d02e13",
    "RawMessage": "Update wait and wait sets' API documentation. (#275)",
    "Changes": "-/// Create a wait set to store conditions that the middleware will block on.\n+/// Create a wait set to store conditions that the middleware can wait on.\n- *   - context is invalid\n+ *   - context is zero initialized, as provided by rmw_get_zero_initialized_context()\n+ *   - context does not belong to this implementation i.e. does not have a matching\n+ *     implementation identifier\n- * If `max_conditions` is `0`, the wait set can store an unbounded number of\n- * conditions to wait on.\n- * If `max_conditions` is greater than `0`, the number of conditions that can\n- * be attached to the wait set is bounded at `max_conditions`.\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\par Thread-safety\n+ *   Contexts are thread-safe objects, and so are all operations on them except for finalization.\n+ *   Therefore, it is safe to create multiple wait sets in the same context concurrently.\n- * \\param[in] context init context that this node should be associated with\n+ * \\pre Given `context` must be a valid context, initialized by rmw_init().\n+ *\n... [truncated] ...\n+ * \\pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().\n+ * \\pre All given entities must be associated with nodes that, in turn, were registered\n+ *   with the same context the given `wait_set` was registered with on creation.\n+ *\n+ * \\param[inout] subscriptions Array of subscriptions to wait on.\n+ *   Can be `NULL` if there are no subscriptions to wait on.\n+ * \\param[inout] guard_conditions Array of guard conditions to wait on\n+ *   Can be `NULL` if there are no guard conditions to wait on.\n+ * \\param[inout] services Array of services to wait on.\n+ *   Can be `NULL` if there are no services to wait on.\n+ * \\param[inout] clients Array of clients to wait on.\n+ *   Can be `NULL` if there are no clients to wait on.\n+ * \\param[inout] events Array of events to wait on.\n+ *   Can be `NULL` if there are no events to wait on.\n+ * \\param[in] wait_set Wait set to use for waiting.\n+ * \\param[in] wait_timeout If `NULL`, block indefinitely until an entity becomes ready.\n+ *   If zero, do not block -- check only for immediately available entities.\n+ *   Else, this represents the maximum amount of time to wait for an entity to become ready.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_TIMEOUT` if wait timed out, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation\n+ *   identifier does not match this implementation, or\n+ * \\return `RMW_RET_ERROR` if an unspecified error occurs.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "7ab18b710461e0cd3d1ef34b23dc542dd7d4ff4b",
    "RawMessage": "Update Quality Declaration to QL2. (#151)",
    "Changes": "-The package `rmw_implementation` claims to be in the **Quality Level 3** category.\n+The package `rmw_implementation` claims to be in the **Quality Level 2** category.\n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 2 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n-`rmw_implementation` features enable ROS middleware configuration. Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/master/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/master/test_communication) packages, provide coverage.\n+`rmw_implementation` features enable ROS middleware configuration and dynamic loading.\n+Unit tests for these features are located in the test directory.\n+Most recent test results can be found [here](https://ci.ros2.org/job/nightly_linux_release/lastBuild/testReport/rmw_implementation).\n+\n+Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/master/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/master/test_communication) packages, further extend coverage.\n-`rmw_implementation` does not currently track test coverage.\n+`rmw_implementation` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+\n+This includes:\n+\n+- tracking and reporting line coverage statistics\n+- achieving and maintaining a reasonable branch line coverage (90-100%)\n+- no lines are manually skipped in coverage calculations\n+\n+Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n+\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/).\n+A description of how coverage statistics are summarized from this page, can be found in the [ROS 2 Onboarding Guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n-|4.i| Feature items tests | None |\n+|4.i| Feature items tests | \u0393\u00a3\u00f4 |\n-|4.iii.a| Using coverage | None |\n-|4.iii.a| Coverage policy | None |\n+|4.iii.a| Using coverage | \u0393\u00a3\u00f4 |\n+|4.iii.a| Coverage policy | \u0393\u00a3\u00f4 |",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "7780fa11f126495dd644f02cc8f81fe847abdfd8",
    "RawMessage": "Waitable should check callback_group if it can be executed. (#1001)",
    "Changes": "-                            handler = self._make_handler(\n-                                wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n-                            yielded_work = True\n-                            yield handler, wt, node\n+                            if wt.callback_group.can_execute(wt):\n+                                handler = self._make_handler(\n+                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n+                                yielded_work = True\n+                                yield handler, wt, node",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "0763473917ae6b49720df5cada89b39a4367222a",
    "RawMessage": "Convert Node and Context to use C++ Classes (#771)",
    "Changes": "-  src/rclpy/_rclpy_action.cpp\n-  src/rclpy/init.cpp\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule,\n+                node.handle,\n-from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_client_names_and_types_by_node(\n-            node_capsule, remote_node_name, remote_node_namespace)\n+    with node.handle:\n+        return node.handle.get_action_client_names_and_types_by_node(\n+            remote_node_name, remote_node_namespace)\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_server_names_and_types_by_node(\n-            node_capsule, remote_node_name, remote_node_namespace)\n+    with node.handle:\n+        return node.handle.get_action_server_names_and_types_by_node(\n+            remote_node_name, remote_node_namespace)\n-    with node.handle as node_capsule:\n-        return _rclpy.rclpy_action_get_names_and_types(node_capsule)\n+    with node.handle:\n+        return node.handle.get_action_names_and_types()\n-        with node.handle as node_capsule, node.get_clock().handle:\n+        with node.handle, node.get_clock().handle:\n... [truncated] ...\n+        msg_type=Empty,\n+        topic=topic_name,\n+        callback=lambda _: None,\n+        qos_profile=10,\n+    )\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptySrv, 'test_client', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptySrv, 'test_client', QoSProfile(depth=10).get_c_qos_profile())\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptySrv, 'test_server', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptySrv, 'test_server', QoSProfile(depth=10).get_c_qos_profile())\n-        with self._clock.handle, node.context.handle as context_capsule:\n+        with self._clock.handle, node.context.handle:\n-                self._clock.handle, context_capsule, period_nanoseconds)\n+                self._clock.handle, node.context.handle, period_nanoseconds)\n-        with node.handle as node_capsule:\n+        with node.handle:\n-                node_capsule, EmptyMsg, 'test_topic', QoSProfile(depth=10).get_c_qos_profile())\n+                node.handle, EmptyMsg, 'test_topic', QoSProfile(depth=10).get_c_qos_profile())\n-        with node.context.handle as context_capsule:\n-            self.guard_condition = _rclpy.GuardCondition(context_capsule)\n+        with node.context.handle:\n+            self.guard_condition = _rclpy.GuardCondition(node.context.handle)",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "5b71d97926cf71e8a3f5a7d4d5e767b860e40722",
    "RawMessage": "Remove deprecated functions benchmark tests (#122)",
    "Changes": "-  add_performance_test(benchmark_string_conversions test/benchmark/benchmark_string_conversions.cpp)\n-  if(TARGET benchmark_string_conversions)\n-    target_link_libraries(benchmark_string_conversions ${PROJECT_NAME})\n-  endif()\n-\n-// Copyright 2020 Open Source Robotics Foundation, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#include <string>\n-\n-#include \"fastcdr/Cdr.h\"\n-#include \"rcutils/macros.h\"\n-\n-#include \"rosidl_runtime_c/string_functions.h\"\n... [truncated] ...\n-    RCUTILS_UNUSED(_);\n-    std::u16string u16string;\n-    cdr.reset();\n-    rosidl_typesupport_fastrtps_cpp::cdr_deserialize(cdr, u16string);\n-  }\n-}\n-\n-BENCHMARK_F(PerformanceTest, u16string_to_wstring)(benchmark::State & st)\n-{\n-  namespace fastcdr = eprosima::fastcdr;\n-\n-  std::u16string u16string(kSize, '*');\n-  char raw_buffer[kSize * 4 + 4];  // 4 bytes per character + 4 bytes for the length\n-  fastcdr::FastBuffer buffer(raw_buffer, sizeof(raw_buffer));\n-  fastcdr::Cdr cdr(buffer, fastcdr::Cdr::DEFAULT_ENDIAN, fastcdr::CdrVersion::XCDRv1);\n-  cdr.set_encoding_flag(fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);\n-\n-  reset_heap_counters();\n-\n-  for (auto _ : st) {\n-    RCUTILS_UNUSED(_);\n-    cdr.reset();\n-    rosidl_typesupport_fastrtps_cpp::cdr_serialize(cdr, u16string);\n-  }\n-}",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "20df68351e4602c11d5303495aeaaab87118895d",
    "RawMessage": "Change decode error mode to replace (#176)",
    "Changes": "-      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"strict\");\n+      PyObject * decoded_item = PyUnicode_DecodeUTF8(src[i].data, strlen(src[i].data), \"replace\");\n-      \"strict\");\n+      \"replace\");",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "972167c5741b4412f80263a6ca5932b06037f7a1",
    "RawMessage": "Call callbacks only if unread count > 0 (#634)",
    "Changes": "-        callback(user_data, liveliness_lost_status_.total_count_change);\n-        liveliness_lost_status_.total_count_change = 0;\n+\n+        if (liveliness_lost_status_.total_count_change > 0) {\n+          callback(user_data, liveliness_lost_status_.total_count_change);\n+          liveliness_lost_status_.total_count_change = 0;\n+        }\n-        callback(\n-          user_data,\n-          offered_deadline_missed_status_.total_count_change);\n-        offered_deadline_missed_status_.total_count_change = 0;\n+\n+        if (offered_deadline_missed_status_.total_count_change > 0) {\n+          callback(user_data, offered_deadline_missed_status_.total_count_change);\n+          offered_deadline_missed_status_.total_count_change = 0;\n+        }\n-        callback(\n-          user_data,\n-          incompatible_qos_status_.total_count_change);\n-        incompatible_qos_status_.total_count_change = 0;\n+\n+        if (incompatible_qos_status_.total_count_change > 0) {\n+          callback(user_data, incompatible_qos_status_.total_count_change);\n+          incompatible_qos_status_.total_count_change = 0;\n+        }\n... [truncated] ...\n-            requested_deadline_missed_status_.total_count_change);\n-          requested_deadline_missed_status_.total_count_change = 0;\n+\n+          if (requested_deadline_missed_status_.total_count_change > 0) {\n+            callback(user_data, requested_deadline_missed_status_.total_count_change);\n+            requested_deadline_missed_status_.total_count_change = 0;\n+          }\n-          callback(\n-            user_data,\n-            sample_lost_status_.total_count_change);\n-          sample_lost_status_.total_count_change = 0;\n+\n+          if (sample_lost_status_.total_count_change > 0) {\n+            callback(user_data, sample_lost_status_.total_count_change);\n+            sample_lost_status_.total_count_change = 0;\n+          }\n-          callback(\n-            user_data,\n-            incompatible_qos_status_.total_count_change);\n-          incompatible_qos_status_.total_count_change = 0;\n+\n+          if (incompatible_qos_status_.total_count_change > 0) {\n+            callback(user_data, incompatible_qos_status_.total_count_change);\n+            incompatible_qos_status_.total_count_change = 0;\n+          }",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "071adba7fca13da7f6ba77c26e2d9cf989308ca2",
    "RawMessage": "Don't pass screw_display.hpp to the moc generator. (#1018)",
    "Changes": "-  include/rviz_default_plugins/displays/screw/screw_display.hpp",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcpputils",
    "SHA": "c730cb7bcb50a7583b8502aa0e3edbb0028a476d",
    "RawMessage": "Add clamp header (#85)",
    "Changes": "+\n+  ament_add_gtest(test_clamp test/test_clamp.cpp)\n+// Copyright 2020 PAL Robotics S.L.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*! \\file clamp.hpp\n+ * \\brief Restrict a value between two bounds\n+ */\n+\n+#ifndef RCPPMATH__CLAMP_HPP_\n+#define RCPPMATH__CLAMP_HPP_\n+\n+#include <cassert>\n+\n... [truncated] ...\n+\n+TEST(test_clamp, test_cmp) {\n+  auto cmp = [](const int & a, const int & b)\n+    {\n+      return a < b;\n+    };\n+  EXPECT_EQ(rcppmath::clamp(1, 2, 5, cmp), 2);\n+  EXPECT_EQ(rcppmath::clamp(2, 2, 5, cmp), 2);\n+  EXPECT_EQ(rcppmath::clamp(5, 2, 5, cmp), 5);\n+  EXPECT_EQ(rcppmath::clamp(6, 2, 5, cmp), 5);\n+  EXPECT_EQ(rcppmath::clamp(3, 2, 5, cmp), 3);\n+  EXPECT_EQ(rcppmath::clamp(4, 2, 5, cmp), 4);\n+}\n+TEST(test_clamp, test_limits) {\n+  EXPECT_EQ(rcppmath::clamp(std::numeric_limits<double>::infinity(), 0.0, 1.0), 1.0);\n+  EXPECT_EQ(rcppmath::clamp(-std::numeric_limits<double>::infinity(), 0.0, 1.0), 0.0);\n+\n+  // Nan's are not limited by clamp, and return a nan, which is not comparable to itself\n+  EXPECT_NE(rcppmath::clamp(std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0), 0.0);\n+  EXPECT_NE(rcppmath::clamp(std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0), 1.0);\n+  EXPECT_NE(\n+    rcppmath::clamp(\n+      std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0),\n+    std::numeric_limits<double>::quiet_NaN());\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "c49b41c9b19ae9e76e746db662285fc6c7d3b1af",
    "RawMessage": "Change syntax __VAR_ARGS__ to __VA_ARGS__ (#376)",
    "Changes": "-#define my__has_feature(...) __has_feature(__VAR_ARGS__)\n+#define my__has_feature __has_feature\n-#define my__has_feature(...) 0\n+#define my__has_feature(x) 0",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "263df6d96b79da983e86d637d644fc99e0cd2315",
    "RawMessage": "fix moved troubleshooting url (#579)",
    "Changes": "-                (e.path, 'https://index.ros.org/doc/ros2/Troubleshooting/'\n+                (e.path, 'https://index.ros.org/doc/ros2/Troubleshooting/Installation-Troubleshooting/'",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "091fe27d43c0ba93c1bd79c630173ce2c3b39891",
    "RawMessage": "Don't crash the action server if the client goes away. (#1114)",
    "Changes": "-        self._handle.send_goal_response(request_header, response_msg)\n+\n+        try:\n+            # If the client goes away anytime before this, sending the goal response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_goal_response(request_header, response_msg)\n+        except RCLError:\n+            self._logger.warn('Failed to send goal response (the client may have gone away)')\n+            return\n-        self._handle.send_result_response(request_header, future.result())\n+        try:\n+            # If the client goes away anytime before this, sending the result response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_result_response(request_header, future.result())\n+        except RCLError:\n+            self._logger.warn('Failed to send result response (the client may have gone away)')",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "16e14d15e210672fbfe0beb1f57effbd8d1233b0",
    "RawMessage": "Add test creating two content filter topics with the same topic name (#230) (#233)",
    "Changes": "+\n+TEST_F(TestContentFilterSubscriptionUse, create_two_filters_with_same_topic_name_and_destroy) {\n+  if (sub->is_cft_enabled) {\n+    auto allocator = rcutils_get_default_allocator();\n+    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n+\n+    rmw_subscription_content_filter_options_t * content_filter_options =\n+      static_cast<rmw_subscription_content_filter_options_t *>(\n+      allocator.allocate(\n+        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      allocator.deallocate(content_filter_options, allocator.state);\n+    });\n+\n+    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters,\n+        &allocator,\n+        content_filter_options));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(content_filter_options, &allocator));\n+    });\n+\n+    options.content_filter_options = content_filter_options;\n+\n+    // Create another subscription with content filter in the same topic\n+    auto sub_2 = rmw_create_subscription(node, ts, topic_name, &qos_profile, &options);\n+    ASSERT_NE(nullptr, sub_2) << rmw_get_error_string().str;\n+\n+    rmw_ret_t ret = rmw_destroy_subscription(node, sub_2);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  }\n+}",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "a38a28d748e436e51540c567f506bb59f7577248",
    "RawMessage": "Adds topic name to error msg when create_topic fails",
    "Changes": "-void set_error_message_from_create_topic(dds_entity_t topic)\n+void set_error_message_from_create_topic(dds_entity_t topic, std::string topic_name)\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because the function was given\"\n-      \" invalid parameters\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because the function was given invalid parameters\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because it's already in use\"\n-      \" in this context with incompatible QoS settings\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because it's already in use in this context with incompatible QoS settings\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because it's already in use\"\n-      \" in this context with a different message type\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because it's already in use in this context with a different message type\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\"failed to create topic for unknown reasons\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    set_error_message_from_create_topic(topic);\n+    set_error_message_from_create_topic(topic, fqtopic_name);\n-    set_error_message_from_create_topic(topic);\n+    set_error_message_from_create_topic(topic, fqtopic_name);\n-    set_error_message_from_create_topic(pubtopic);\n+    set_error_message_from_create_topic(pubtopic, pubtopic_name);\n-    set_error_message_from_create_topic(subtopic);\n+    set_error_message_from_create_topic(subtopic, subtopic_name);",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "c7b394a061a99b2f8ba7c8438e3dd39b488ddc6f",
    "RawMessage": "rcl_send_response returns RCL_RET_TIMEOUT. (#1048)",
    "Changes": "+ * \\return #RCL_RET_TIMEOUT if a response reader is not ready yet, or\n+  rcl_ret_t ret;\n-  if (rmw_send_response(\n-      service->impl->rmw_handle, request_header, ros_response) != RMW_RET_OK)\n-  {\n+  ret = rmw_send_response(service->impl->rmw_handle, request_header, ros_response);\n+  if (ret != RMW_RET_OK) {\n+    if (ret == RMW_RET_TIMEOUT) {\n+      return RCL_RET_TIMEOUT;\n+    }\n-    rcl_ret_t ret = rcl_send_service_event_message(\n+    ret = rcl_send_service_event_message(",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "dff2aaf7e6914044cbd98a54c0def3d885d093ff",
    "RawMessage": "Add QoS entity creation API (#119)",
    "Changes": "+/**\n+ *  Creates an rcl client with defined QoS\n+ *\n+ *  * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes (in RCL)\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param[inout] client pointer to zero_initialized rcl_client_t\n+ * \\param[in] node pointer to an initialized rcl node\n+ * \\param[in] type_support the message data type\n+ * \\param[in] service_name the name of service topic\n+ * \\param[in] qos_profile the qos of the topic\n+ * \\return `RCL_RET_OK` if successful\n+ * \\return `RCL_ERROR` (or other error code) if an error has occurred\n+ */\n+RCLC_PUBLIC\n+rcl_ret_t\n+rclc_client_init(\n+  rcl_client_t * client,\n+  const rcl_node_t * node,\n+  const rosidl_service_type_support_t * type_support,\n... [truncated] ...\n-    // clean up\n-    rc = rclc_executor_fini(&executor);\n-    rc += rclc_parameter_server_fini(&param_server, &node);\n-    rc += rcl_node_fini(&node);\n+  // clean up\n+  rc = rclc_executor_fini(&executor);\n+  rc += rclc_parameter_server_fini(&param_server, &node);\n+  rc += rcl_node_fini(&node);\n-    if (rc != RCL_RET_OK) {\n-        printf(\"Error while cleaning up!\\n\");\n-        return -1;\n-    }\n-    return 0;\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error while cleaning up!\\n\");\n+    return -1;\n+  }\n+  return 0;\n-    ret &= rclc_publisher_init_default(\n+    ret &= rclc_publisher_init(\n-      \"/parameter_events\");\n+      \"/parameter_events\",\n+      &rmw_qos_profile_parameter_events);\n-  return rclc_service_init_default(service, node, srv_type, get_service_name);\n+  return rclc_service_init(service, node, srv_type, get_service_name, &rmw_qos_profile_parameters);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "63b5c6db91f2fbff2efe3ceceead5c0b456756cb",
    "RawMessage": "Update node creation/destruction API documentation. (#249)",
    "Changes": "- *   - context, name, namespace_, or security_options is `NULL`\n- *   - context, security_options is invalid\n+ *   - name is not a valid non-null node name\n+ *   - namespace_ is not a valid non-null namespace\n+ *   - context is not valid i.e. it is zero-initialized, or\n+ *     its implementation identifier does not match that of\n+ *     this API implementation, or has been invalidated by\n+ *     `rmw_shutdown()`\n- * The context must be non-null and valid, i.e. it has been initialized\n- * by `rmw_init()` and has not been finalized by `rmw_shutdown()`.\n- *\n- * The name and namespace_ should be valid node name and namespace,\n- * and this should be asserted by the caller (e.g. `rcl`).\n- *\n- * The domain ID should be used to physically separate nodes at the\n- * communication graph level by the middleware.\n- * For RTPS/DDS this maps naturally to their concept of domain id.\n- *\n- * The security options should always be non-null and encapsulate the\n- * essential security configurations for the node and its entities.\n- *\n- * \\param[in] domain_id the id of the domain that the node should join\n- * \\param[in] security_options the security configurations for the node\n- * \\param[in] localhost_only whenever to use loopback only for communication or default\n- * network interfaces.\n- * \\return rmw node handle or `NULL` if there was an error\n+ * \\return rmw node handle, or `NULL` if there was an error\n- * The method may assume - but should verify - that all publishers, subscribers,\n- * services, and clients created from this node have already been destroyed.\n- * If the rmw implementation chooses to verify instead of assume, it should\n- * return `RMW_RET_ERROR` and set a human readable error message if any entity\n- * created from this node has not yet been destroyed.\n+ * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged.\n+ * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n+ * the node handle. Usage of a deallocated node handle is undefined behavior.\n+ *\n+ * \\pre All publishers, subscribers, services, and clients created from this node must\n+ *   have been destroyed prior to this call. Some rmw implementations may verify this,\n+ *   returning `RMW_RET_ERROR` and setting a human readable error message if any entity\n+ *   created from this node has not yet been destroyed. However, this is not guaranteed\n+ *   and so callers should ensure that this is the case before calling this function.\n- * \\return `RMW_RET_INVALID_ARGUMENT` if node is null, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if node is invalid, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n+ *   identifier does not match, or",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "7f9a307a9d232445928d04f50add7c0b3995fe22",
    "RawMessage": "TestClient.test_service_timestamps failing consistently. (#1364)",
    "Changes": "-                if result is not None:\n+                if result != (None, None):",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "56cac62cfe40a527e93aee7c51b53b12925d6bd4",
    "RawMessage": "Discriminate when the Client has gone from when the Client has not completely matched (#467)",
    "Changes": "-  info->pub_listener_ = new (std::nothrow) ServicePubListener();\n+  info->pub_listener_ = new (std::nothrow) ServicePubListener(info);\n-  info->pub_listener_ = new ServicePubListener();\n+  info->pub_listener_ = new ServicePubListener(info);\n+#include <unordered_map>\n+enum class client_present_t\n+{\n+  FAILURE,  // an error occurred when checking\n+  MAYBE,    // reader not matched, writer still present\n+  YES,      // reader matched\n+  GONE      // neither reader nor writer\n+};\n+\n+class ServicePubListener : public eprosima::fastrtps::PublisherListener\n+{\n+  using subscriptions_set_t =\n+    std::unordered_set<eprosima::fastrtps::rtps::GUID_t,\n+      rmw_fastrtps_shared_cpp::hash_fastrtps_guid>;\n+  using clients_endpoints_map_t =\n+    std::unordered_map<eprosima::fastrtps::rtps::GUID_t,\n+      eprosima::fastrtps::rtps::GUID_t,\n+      rmw_fastrtps_shared_cpp::hash_fastrtps_guid>;\n+\n+public:\n+  explicit ServicePubListener(CustomServiceInfo * info)\n... [truncated] ...\n-    } else if (eprosima::fastrtps::rtps::REMOVED_MATCHING == matchingInfo.status) {\n-      subscriptions_.erase(matchingInfo.remoteEndpointGuid);\n-    } else {\n-      return;\n-    }\n-    cv_.notify_all();\n-  }\n-\n-private:\n-  using subscriptions_set_t =\n-    std::unordered_set<eprosima::fastrtps::rtps::GUID_t,\n-      rmw_fastrtps_shared_cpp::hash_fastrtps_guid>;\n-\n-  std::mutex mutex_;\n-  subscriptions_set_t subscriptions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n-  std::condition_variable cv_;\n-};\n-\n-    if (!listener->wait_for_subscription(related_guid, std::chrono::milliseconds(100))) {\n+    client_present_t ret = listener->check_for_subscription(related_guid);\n+    if (ret == client_present_t::GONE) {\n+      return RMW_RET_OK;\n+    } else if (ret == client_present_t::MAYBE) {\n-      return RMW_RET_ERROR;\n+      return RMW_RET_TIMEOUT;",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "0084d12983f0e1632d85d8936e8a210e0cfd826c",
    "RawMessage": "catch ExternalShutdownException ros2cli main. (#854)",
    "Changes": "+from rclpy.executors import ExternalShutdownException\n+\n+    except ExternalShutdownException:\n+        rc = signal.SIGTERM",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "11652db13a0af843b4e6cca12659d07959a9dd24",
    "RawMessage": "Build-time RMW selection does not need ament_index_cpp (#210)",
    "Changes": "-find_package(ament_index_cpp REQUIRED)\n+  find_package(ament_index_cpp REQUIRED)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "19f0456d8c2e728751ec70a46f846d8037be515e",
    "RawMessage": "Fix init options handling (#202) (#205)",
    "Changes": "+  if (rcl_init_options_fini(&init_options) != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(rclc_support_init, rcl_init_options_fini);\n+  }\n-  memcpy(&support->init_options, init_options, sizeof(rcl_init_options_t));\n+  support->init_options = rcl_get_zero_initialized_init_options();\n+  rc = rcl_init_options_copy(init_options, &support->init_options);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(rclc_init, rcl_init_options_copy);\n+    return rc;\n+  }",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "2a78b2c57d66ad95e038a93694942ba8f6db55b7",
    "RawMessage": "fix flake",
    "Changes": "-                sorted((value, key) for (key,value) in module_names.items()):\n+                    sorted((value, key) for (key, value) in module_names.items()):",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "e9f60082b76e0621629c146d160b72bdac82ae45",
    "RawMessage": "Make sure to find_package(rmw) in rmw_implementation. (#242)",
    "Changes": "+find_package(rmw REQUIRED)",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "875ec1a06ecfcce9d4f261e261c562e14eaf4fac",
    "RawMessage": "Add null handling",
    "Changes": "+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "287e781937f42570d4c7a14ed24e201c528c20af",
    "RawMessage": "Free with the same allocator in rmw_destroy_node (#355)",
    "Changes": "-  rcutils_allocator_t allocator = context->options.allocator;\n-  allocator.deallocate(const_cast<char *>(node->name), allocator.state);\n-  allocator.deallocate(const_cast<char *>(node->namespace_), allocator.state);\n-  allocator.deallocate(node, allocator.state);\n+  rmw_free(const_cast<char *>(node->name));\n+  rmw_free(const_cast<char *>(node->namespace_));\n+  rmw_node_free(const_cast<rmw_node_t *>(node));",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "7e4b0d5f8fb7f7f16fe80419c50c488ca0ab7df6",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#382)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @methylDragon @ivanpauno @wjwwood",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "28742f605e119a19006cbf2e402475f2a3e59ded",
    "RawMessage": "wrap lines to shorten line length (#586)",
    "Changes": "-        # Since Python 3.8, on Windows we should ensure DLL directories are explicitly added\n-        # to the search path.\n+        # Since Python 3.8, on Windows we should ensure DLL directories are\n+        # explicitly added to the search path.\n-                \"\\nThe C extension '%s' failed to be imported while being present on the system.\" \\\n-                \" Please refer to '%s' for possible solutions\" % \\\n-                (e.path, 'https://index.ros.org/doc/ros2/Troubleshooting/Installation-Troubleshooting/'\n-                         '#import-failing-even-with-library-present-on-the-system')\n+                f\"\\nThe C extension '{e.path}' failed to be imported while \" \\\n+                \"being present on the system. Please refer to 'https://\" \\\n+                'index.ros.org/doc/ros2/Troubleshooting/Installation-' \\\n+                'Troubleshooting/#import-failing-even-with-library-present-' \\\n+                \"on-the-system' for possible solutions\"",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "94a51147f8509cdf9408a88b9f9023d3653b40da",
    "RawMessage": "Account for alignment on is_plain calculations. (#716)",
    "Changes": "+  size_t last_member_size = 0;\n+    last_member_size = 0;\n+        last_member_size = array_size * sizeof(int8_t);\n+        last_member_size = array_size * sizeof(uint16_t);\n+        last_member_size = array_size * sizeof(uint32_t);\n+        last_member_size = array_size * sizeof(uint64_t);\n-            current_alignment += calculateMaxSerializedSize(sub_members, current_alignment);\n+            size_t curr = calculateMaxSerializedSize(sub_members, current_alignment);\n+            current_alignment += curr;\n+            last_member_size += curr;\n-  return current_alignment - initial_alignment;\n+  size_t ret_val = current_alignment - initial_alignment;\n+  if (last_member_size > 0) {\n+    if (this->is_plain_) {\n+      const auto * last_member = members->members_ + (members->member_count_ - 1);\n+      this->is_plain_ = (last_member->offset_ + last_member_size) == ret_val;\n+    }\n+  }\n+\n+  return ret_val;",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "a91bbc1b25d1d45e727d430a86d9f05646e71288",
    "RawMessage": "Update minimum CMake version CMakeLists.txt.em (#969)",
    "Changes": "-cmake_minimum_required(VERSION 3.8)\n+cmake_minimum_required(VERSION 3.16)",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "a08a9506f5192ea06a0bf021cec21836f271ae17",
    "RawMessage": "improve error message if rclpy C extensions are not found (#580)",
    "Changes": "+from pathlib import Path\n+        if e.path is None:\n+            import sysconfig\n+            expected_path = Path(__file__).parents[1] / (\n+                name[1:] + sysconfig.get_config_var('EXT_SUFFIX'))\n+            assert not expected_path.is_file()\n+            e.msg += \\\n+                f\"\\nThe C extension '{expected_path}' isn't present on the \" \\\n+                \"system. Please refer to 'https://index.ros.org/doc/ros2/\" \\\n+                'Troubleshooting/Installation-Troubleshooting/#import-' \\\n+                \"failing-without-library-present-on-the-system' for \" \\\n+                'possible solutions'",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "47346ef9688039b890ae19c499d4b51587a7305b",
    "RawMessage": "Fixes spin_until_future_complete inside callback (#1316)",
    "Changes": "+    node_added = False\n-        executor.add_node(node)\n+        node_added = executor.add_node(node)\n-        executor.remove_node(node)\n+        if node_added:\n+            executor.remove_node(node)",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "6c8687eb852d773c17d13cd4428e07f0bea22b75",
    "RawMessage": "Fix memory leak in rcl_subscription_init()/rcl_publisher_init() (#794)",
    "Changes": "+    if (publisher->impl->rmw_handle) {\n+      rmw_ret_t rmw_fail_ret = rmw_destroy_publisher(\n+        rcl_node_get_rmw_handle(node), publisher->impl->rmw_handle);\n+      if (RMW_RET_OK != rmw_fail_ret) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+          \"%s, at %s:%d\\n\", rmw_get_error_string().str, __FILE__, __LINE__);\n+      }\n+    }\n+\n+    if (subscription->impl->rmw_handle) {\n+      rmw_ret_t rmw_fail_ret = rmw_destroy_subscription(\n+        rcl_node_get_rmw_handle(node), subscription->impl->rmw_handle);\n+      if (RMW_RET_OK != rmw_fail_ret) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+          \"%s, at %s:%d\\n\", rmw_get_error_string().str, __FILE__, __LINE__);\n+      }\n+    }\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "14eb345688213c3547c7c859511b8cd2c271738b",
    "RawMessage": "Add rosparam verb load (#590)",
    "Changes": "+import sys\n+\n+from rcl_interfaces.msg import Parameter\n+from rclpy.parameter import PARAMETER_SEPARATOR_STRING\n+\n+def parse_parameter_dict(*, namespace, parameter_dict):\n+    parameters = []\n+    for param_name, param_value in parameter_dict.items():\n+        full_param_name = namespace + param_name\n+        # Unroll nested parameters\n+        if type(param_value) == dict:\n+            parameters += parse_parameter_dict(\n+                    namespace=full_param_name + PARAMETER_SEPARATOR_STRING,\n+                    parameter_dict=param_value)\n+        else:\n+            parameter = Parameter()\n+            parameter.name = full_param_name\n+            parameter.value = get_parameter_value(string_value=str(param_value))\n+            parameters.append(parameter)\n+    return parameters\n+\n+\n+def load_parameter_dict(*, node, node_name, parameter_dict):\n+\n+    parameters = parse_parameter_dict(namespace='', parameter_dict=parameter_dict)\n... [truncated] ...\n+\n+    def test_verb_load(self):\n+        with tempfile.TemporaryDirectory() as tmpdir:\n+            filepath = self._write_param_file(tmpdir, 'params.yaml')\n+            with self.launch_param_load_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', filepath]\n+            ) as param_load_command:\n+                assert param_load_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_load_command.exit_code == launch_testing.asserts.EXIT_OK\n+            assert launch_testing.tools.expect_output(\n+                expected_lines=[''],\n+                text=param_load_command.output,\n+                strict=True\n+            )\n+            # Dump with ros2 param dump and compare that output matches input file\n+            with self.launch_param_dump_command(\n+                arguments=[f'{TEST_NAMESPACE}/{TEST_NODE}', '--print']\n+            ) as param_dump_command:\n+                assert param_dump_command.wait_for_shutdown(timeout=TEST_TIMEOUT)\n+            assert param_dump_command.exit_code == launch_testing.asserts.EXIT_OK\n+            assert launch_testing.tools.expect_output(\n+                expected_text=INPUT_PARAMETER_FILE + '\\n',\n+                text=param_dump_command.output,\n+                strict=True\n+            )",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "4b5dfcf87c7a60539b2be21c08feda46df34c79c",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#220)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @quarkytale @sloretz",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "cd63e71f9d0a1f9c303c42c8c0f609882d4906d8",
    "RawMessage": "reset current line width when calculating text width (#655)",
    "Changes": "+      current_width = 0;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "911088d8cb6ecba14290c399cc65f86adc3e3bf7",
    "RawMessage": "Remove std::cout line from test_rcl_lifecycle.cpp (#773)",
    "Changes": "-  std::cout << \"state_machine: \" << __LINE__ << std::endl;",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcutils",
    "SHA": "8da2aace17bcecad3bdf0bebafe23298602f50c0",
    "RawMessage": "Clarify duration arg description in logging macros (#359)",
    "Changes": "-    ('duration', 'The duration of the throttle interval'),\n+    ('duration', 'The duration of the throttle interval as an integral value in milliseconds.'),",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "32796eef9b3f6054cc8545fa9dfb369548ff7de8",
    "RawMessage": "Use unified approach for checking the existence of environment variables (#105)",
    "Changes": "-  if(ENV{CONNEXTDDS_ARCH})\n+  if(NOT \"$ENV{CONNEXTDDS_ARCH}\" STREQUAL \"\")",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "1de5341620d82edca803892becfffa98ba467ce4",
    "RawMessage": "Add serialize/deserialize API test coverage. (#118)",
    "Changes": "+\n+    ament_add_gtest(test_serialize_deserialize${target_suffix}\n+      test/test_serialize_deserialize.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_serialize_deserialize${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_serialize_deserialize${target_suffix}\n+      rcutils rmw rmw_implementation test_msgs\n+    )\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n... [truncated] ...\n+  test_msgs::msg::BasicTypes input_message{};\n+  test_msgs::msg::BasicTypes output_message{};\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n+\n+  // Make input_message not equal to output_message.\n+  input_message.bool_value = !output_message.bool_value;\n+  input_message.int16_value = output_message.int16_value - 1;\n+  input_message.uint32_value = output_message.uint32_value + 1000000;\n+\n+  rmw_ret_t ret = rmw_serialize(&input_message, ts, &serialized_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_NE(nullptr, serialized_message.buffer);\n+  EXPECT_GT(serialized_message.buffer_length, 0lu);\n+\n+  ret = rmw_deserialize(&serialized_message, ts, &output_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(input_message, output_message);\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) <<\n+    rmw_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "eac6a8daab60c9f9bdf6715b241312fb8f170739",
    "RawMessage": "[rolling] updated ros-tooling versions (#289)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.3.0\n+    - uses: ros-tooling/setup-ros@0.3.3\n-    - uses : ros-tooling/action-ros-ci@0.2.4\n+    - uses : ros-tooling/action-ros-ci@0.2.5",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "020bcd022456ab148dc80bc6b9f30b7d55e1eb65",
    "RawMessage": "Revert raw typesupport patch",
    "Changes": "-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "2ec6797b6f12fe7e7fa6b00a48d44d9315275f80",
    "RawMessage": "update RCL_RET_TIMEOUT error handling with action service response. (#1258)",
    "Changes": "-        self._handle.send_cancel_response(request_header, cancel_response)\n+        try:\n+            # If the client goes away anytime before this, sending the goal response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_cancel_response(request_header, cancel_response)\n+        except RCLError:\n+            self._logger.warn('Failed to send cancel response (the client may have gone away)')\n-    throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n+    if (RCL_RET_TIMEOUT == ret) { \\\n+      int stack_level = 1; \\\n+      PyErr_WarnFormat( \\\n+        PyExc_RuntimeWarning, stack_level, \"failed to send response (timeout): %s\", \\\n+        rcl_get_error_string().str); \\\n+      rcl_reset_error(); \\\n+    } else { \\\n+      throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n+    } \\",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "81619d3d6c2afe4b82a8f5163558cf12d64e20d2",
    "RawMessage": "Removed traces in renderPanel (#777)",
    "Changes": "-  printf(\"in RenderPanel::mouseMoveEvent()\\n\");\n-  printf(\"in RenderPanel::mousePressEvent()\\n\");\n-  printf(\"in RenderPanel::mouseReleaseEvent()\\n\");\n-  printf(\"in RenderPanel::mouseDoubleClickEvent()\\n\");",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "eae50c9ed16c0b2fa4c7ca2c92bb8c30d5f6836f",
    "RawMessage": "fix expired goals capacity of action server (#931)",
    "Changes": "-    if (output_expired && i >= expired_goals_capacity) {\n+    if (output_expired && num_goals_expired >= expired_goals_capacity) {",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "64d216cb8fafef83d046b79ee6294afb06b7c595",
    "RawMessage": "ros2cli.node.daemon : try getting fdsize from /proc for open fd limit (#888)",
    "Changes": "-        import resource\n-        soft, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n-        for i in range(3, soft):\n+        # Some unices have a high soft_limit; read fdsize if available.\n+        fdlimit = None\n+        try:\n+            string_to_find = 'FDSize:'\n+            with open('/proc/self/status', 'r') as f:\n+                for line in f:\n+                    if line.startswith(string_to_find):\n+                        fdlimit = int(line.removeprefix(string_to_find).strip())\n+                        break\n+        except (FileNotFoundError, ValueError):\n+            pass\n+        # The soft limit might be quite high on some systems.\n+        if fdlimit is None:\n+            import resource\n+            fdlimit, _ = resource.getrlimit(resource.RLIMIT_NOFILE)\n+        for i in range(3, fdlimit):",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "2d6ea694baec1ce5a941a7fb8e39b12bd59eb583",
    "RawMessage": "Update publishing API documentation. (#270)",
    "Changes": "-/// Borrow a loaned message.\n+/// Borrow a loaned ROS message.\n- * The memory allocated for the ros message belongs to the middleware and must not be deallocated.\n- * A call to \\sa rmw_publish_loned_message as well as \\sa rmw_return_loaned_message_from_publisher`\n- * will return ownership of the loaned message back to the middleware.\n- *\n- * In order to react to failures, the ros message is passed by pointer as an output parameter.\n- * Therefore, the pointer to the ros message has to be `null` and not previously allocated or\n- * else that memory is lost.\n- *\n- * \\param[in] publisher Publisher to which the allocated message is associated.\n- * \\param[in] type_support Typesupport to which the internal ros message is allocated.\n- * \\param[out] ros_message The pointer to be filled with a valid ros message by the middleware.\n- * \\return `RMW_RET_OK` if the ros message was correctly initialized, or\n- * \\return `RMW_RET_INVALID_ARGUMENT` if an argument other than the ros message is null, or\n- * \\return `RMW_RET_BAD_ALLOC` if the ros message could not be correctly created, or\n- * \\return `RMW_RET_UNSUPPORTED` if the rmw_implementation does not support loaned_message, or\n+ * This ROS message is owned by the middleware, that will keep it alive (i.e. in valid\n+ * memory space) until the caller publishes it using rmw_publish_loaned_message() or\n+ * returns it using rmw_return_loaned_message_from_publisher().\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n... [truncated] ...\n+ *   Publishers are thread-safe objects, and so are all operations on them except for finalization.\n+ *   Therefore, it is safe to publish using the same publisher concurrently.\n+ *   However, when publishing serialized ROS messages:\n+ *   - Access to the byte stream is read-only but it is not synchronized.\n+ *     Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not.\n+ *   - Access to the publisher allocation is not synchronized, unless specifically stated\n+ *     otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.\n+ *     Check the implementation documentation to learn about publisher allocations' thread-safety.\n+ *\n+ * \\pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().\n+ * \\pre Given `serialized_message` must be a valid serialized message, initialized by\n+ *   rmw_serialized_message_init() and containing the serialization of a ROS message whose\n+ *   type matches the message type support the `publisher` was registered with on creation.\n+ * \\pre If not NULL, given `allocation` must be a valid publisher allocation, initialized\n+ *   with rmw_publisher_allocation_init() with a message type support that matches the\n+ *   one registered with `publisher` on creation.\n+ *\n+ * \\param[in] publisher Publisher to be used to send message.\n+ * \\param[in] ros_message Serialized ROS message to be sent.\n+ * \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation\n+ *   identifier does not match this implementation, or",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2e737c8cb0ad7afc436938c30b5e14b4282ff2f7",
    "RawMessage": "mock launch components causing rosdoc2 to fail Python API (#425)",
    "Changes": "+# Copyright 2024 R. Kent James\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+# -- Path setup --------------------------------------------------------------\n+\n+import sys\n+\n+from sphinx.ext.autodoc.mock import mock\n+\n+# -- Project information -----------------------------------------------------\n+\n+copyright = 'The <launch_ros> Contributors. License: Apache License 2.0'  # noqa A001\n+\n+# -- General configuration ---------------------------------------------------\n... [truncated] ...\n+with mock(['launch']):\n+    import launch  # noqa F401\n+    module = sys.modules['launch']\n+sys.modules['launch'] = module\n+\n+with mock(['launch.frontend']):\n+    import launch.frontend  # noqa F401\n+    module = sys.modules['launch.frontend']\n+    # These are dummy decorators\n+    module.expose_action = lambda _: lambda _: _\n+    module.expose_substitution = lambda _: lambda _: _\n+sys.modules['launch.frontend'] = module\n+\n+with mock(['launch.some_substitutions_type']):\n+    import launch.some_substitutions_type  # noqa F401\n+    module = sys.modules['launch.some_substitutions_type']\n+    module.SomeSubstitutionsType_types_tuple = ()\n+sys.modules['launch.some_substitutions_type'] = module\n+\n+# We still want autodoc to mock the base 'launch' module\n+sys.modules.pop('launch')\n+Design Documentation\n+====================\n+\n+See [the design document](https://design.ros2.org/articles/roslaunch.html) for more information on the ros2 launch system.",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "f2287ea61c42a587b90cb92030e81cbfa06ae2d2",
    "RawMessage": "Update service/client request/response API error returns (#450)",
    "Changes": "+#include \"rmw/impl/cpp/macros.hpp\"\n-  assert(client);\n-  assert(ros_request);\n-  assert(sequence_id);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_request, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(sequence_id, RMW_RET_INVALID_ARGUMENT);\n-  if (client->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"node handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  assert(service);\n-  assert(request_header);\n-  assert(ros_request);\n-  assert(taken);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n... [truncated] ...\n+    client->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(taken, RMW_RET_INVALID_ARGUMENT);\n-  if (client->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"service handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  assert(service);\n-  assert(request_header);\n-  assert(ros_response);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n-  if (service->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"service handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "0c41714f7ac90a5962ee7eddca54f4f147c1dbd3",
    "RawMessage": "Fix tolerance calculation precision (#934)",
    "Changes": "-  rclcpp::Duration tolerance(static_cast<int32_t>(static_cast<rcl_duration_value_t>(\n-      scan->time_increment * scan->ranges.size())), 0);\n+  rclcpp::Duration tolerance =\n+    rclcpp::Duration::from_seconds(\n+    static_cast<double>(scan->ranges.size() - 1) *\n+    static_cast<double>(scan->time_increment));\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "4f7c1afafc43114d19a2c133ce5fe1ee54be80f1",
    "RawMessage": "unregister_sigterm_signal_handler should be called. (#1170)",
    "Changes": "-    unregister_sigint_signal_handler();\n+    unregister_sigterm_signal_handler();",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "edad1bcc0e8d0a5988ceaad0dc9e76a658ba1f43",
    "RawMessage": "Enable StaticTransformBroadcaster in Intra-process enabled components (#607)",
    "Changes": "+      /*\n+        This flag disables intra-process communication while publishing to\n+        /tf_static topic, when the StaticTransformBroadcaster is constructed\n+        using an existing node handle which happens to be a component\n+        (in rclcpp terminology).\n+        Required until rclcpp intra-process communication supports\n+        transient_local QoS durability.\n+      */\n+      options.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;\n+      /*\n+        This flag disables intra-process communication while publishing to\n+        /tf_static topic, when the StaticTransformBroadcaster is constructed\n+        using an existing node handle which happens to be a component\n+        (in rclcpp terminology).\n+        Required until rclcpp intra-process communication supports\n+        transient_local QoS durability.\n+      */\n+      options.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;\n+class CustomComposableNode : public rclcpp::Node\n+{\n+public:\n+  explicit CustomComposableNode(const rclcpp::NodeOptions & options)\n+  : rclcpp::Node(\"tf2_ros_test_static_transform_broadcaster_composable_node\", options)\n+  {}\n+\n+  void init_tf_broadcaster()\n+  {\n+    tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(shared_from_this());\n+  }\n+\n+private:\n+  std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_broadcaster_;\n+};\n+\n+TEST(tf2_test_static_transform_broadcaster, transform_broadcaster_with_intraprocess)\n+{\n+  rclcpp::executors::SingleThreadedExecutor exec;\n+  rclcpp::NodeOptions options;\n+  options = options.use_intra_process_comms(true);\n+  auto custom_node = std::make_shared<CustomComposableNode>(options);\n+  custom_node->init_tf_broadcaster();\n+}\n+",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "c7bf4c99b5f888d2dc200041994ed5c8fe16d3ce",
    "RawMessage": "Fix camera display overlay (#1151)",
    "Changes": "-\n+    rviz_rendering::RenderWindowOgreAdapter::setSceneNodeCamera(render_window_, camera_node);\n+  static\n+  void\n+  setSceneNodeCamera(RenderWindow * render_window, Ogre::SceneNode * ogre_camera);\n+\n+void RenderWindowImpl::setSceneNodeCamera(Ogre::SceneNode * ogre_camera)\n+{\n+  if (ogre_camera) {\n+    ogre_camera_node_ = ogre_camera;\n+  }\n+}\n+\n+  void setSceneNodeCamera(Ogre::SceneNode * ogre_camera);\n+\n+void\n+RenderWindowOgreAdapter::setSceneNodeCamera(\n+  RenderWindow * render_window,\n+  Ogre::SceneNode * ogre_camera)\n+{\n+  render_window->impl_->setSceneNodeCamera(ogre_camera);\n+}\n+",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "35860092a77b16332e5172304ab765c8454ca952",
    "RawMessage": "support wildcard matching for params file (#987)",
    "Changes": "+#include <regex>\n+#include <rcpputils/find_and_replace.hpp>\n+ * \\param[in] node_fqn the FQN of node\n-  py::object pyparameter_type_cls, py::dict pynode_params)\n+  py::object pyparameter_type_cls, py::dict pynode_params,\n+  const char * node_fqn)\n+\n+    if (node_fqn) {\n+      // Update the regular expression [\"/*\" -> \"(/\\\\w+)\" and \"/**\" -> \"(/\\\\w+)*\"]\n+      std::string regex = rcpputils::find_and_replace(node_name, \"/*\", \"(/\\\\w+)\");\n+      if (!std::regex_match(node_fqn, std::regex(regex))) {\n+        // No need to parse the items because the user just care about node_fqn\n+        continue;\n+      }\n+\n+      node_name = node_fqn;\n+    }\n+\n+ * \\param[in] node_fqn the FQN of node\n-  py::object pyparameter_type_cls, py::dict pyparams_by_node_name)\n+  py::object pyparameter_type_cls, py::dict pyparams_by_node_name,\n+  const char * node_fqn)\n-      params, pyparameter_cls, pyparameter_type_cls, pyparams_by_node_name);\n+      params, pyparameter_cls, pyparameter_type_cls, pyparams_by_node_name, node_fqn);\n+  const char * node_fqn = rcl_node_get_fully_qualified_name(rcl_node_.get());\n... [truncated] ...\n+            'node2',\n+            namespace='/ns',\n+            cli_args=[\n+                '--ros-args',\n+                '--params-file', str(TEST_RESOURCES_DIR / 'params_by_order.yaml')\n+            ],\n+            automatically_declare_parameters_from_overrides=True)\n+        self.assertEqual('last_one_win', node.get_parameter('a_value').value)\n+        self.assertEqual('foo', node.get_parameter('foo').value)\n+        self.assertEqual('bar', node.get_parameter('bar').value)\n+\n+    def test_node_ns_params_file_with_complicated_wildcards(self):\n+        # regex matched: /**/foo/*/bar\n+        node = rclpy.create_node(\n+            'node2',\n+            namespace='/a/b/c/foo/d/bar',\n+            cli_args=[\n+                '--ros-args',\n+                '--params-file', str(TEST_RESOURCES_DIR / 'complicated_wildcards.yaml')\n+            ],\n+            automatically_declare_parameters_from_overrides=True)\n+        self.assertEqual('foo', node.get_parameter('foo').value)\n+        self.assertEqual('bar', node.get_parameter('bar').value)\n+\n+",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "db21393bcee06ffbcb8171e7e7731abeccec9879",
    "RawMessage": "Add unit tests for set_root_path",
    "Changes": "+\n+#include \"rmw/error_handling.h\"\n+\n+TEST(rmw_security_options, security_root_path) {\n+  rmw_security_options_t options = rmw_get_default_security_options();\n+  EXPECT_EQ(options.enforce_security, RMW_SECURITY_ENFORCEMENT_PERMISSIVE);\n+  EXPECT_EQ(options.security_root_path, nullptr);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_set_root_path(nullptr, &allocator, &options));\n+  EXPECT_EQ(options.security_root_path, nullptr);\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_set_root_path(\"root_path\", nullptr, &options));\n+  EXPECT_EQ(options.security_root_path, nullptr);\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_set_root_path(\"root_path\", &allocator, nullptr));\n+  EXPECT_EQ(options.security_root_path, nullptr);\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_set_root_path(\"root_path\", &allocator, &options));\n+  EXPECT_STREQ(options.security_root_path, \"root_path\");\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(&options, &allocator));\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "071adba7fca13da7f6ba77c26e2d9cf989308ca2",
    "RawMessage": "Don't pass screw_display.hpp to the moc generator. (#1018)",
    "Changes": "-  include/rviz_default_plugins/displays/screw/screw_display.hpp",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "6c1f36a2d34759ad2432c829389884a683e73756",
    "RawMessage": "Avoid using a wildcard to specify parameters if possible (#154)",
    "Changes": "-            # TODO(dhood): clean up generated parameter files.\n-            param_dict = {'/**': {'ros__parameters': params}}\n+            param_dict = {\n+                self.node_name if self.is_node_name_fully_specified() else '/**':\n+                {'ros__parameters': params}\n+            }\n-                '/**': {\n+                '/my_ns/my_node': {",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "a0e9788df53204a6a0d409b073ef7b8e1ff37ae2",
    "RawMessage": "rmw_send_reqponse returns RMW_RET_TIMEOUT. (#350)",
    "Changes": "+ * \\return `RMW_RET_TIMEOUT` if a response reader is not ready yet, or",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclcpp",
    "SHA": "945d254e321381ecb618c680015ba2b38ce898eb",
    "RawMessage": "Switch lifecycle to use the RCLCPP macros. (#2233)",
    "Changes": "-  impl_(new LifecycleNodeInterfaceImpl(node_base_, node_services_))\n+  impl_(new LifecycleNodeInterfaceImpl(node_base_, node_services_, node_logging_))\n+#include \"rclcpp/node_interfaces/node_logging_interface.hpp\"\n-  std::shared_ptr<rclcpp::node_interfaces::NodeServicesInterface> node_services_interface)\n+  std::shared_ptr<rclcpp::node_interfaces::NodeServicesInterface> node_services_interface,\n+  std::shared_ptr<rclcpp::node_interfaces::NodeLoggingInterface> node_logging_interface)\n-  node_services_interface_(node_services_interface)\n+  node_services_interface_(node_services_interface),\n+  node_logging_interface_(node_logging_interface)\n-    RCUTILS_LOG_FATAL_NAMED(\n-      \"rclcpp_lifecycle\",\n+    RCLCPP_FATAL(\n+      node_logging_interface_->get_logger(),\n-      RCUTILS_LOG_ERROR(\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n-      RCUTILS_LOG_ERROR(\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n-      RCUTILS_LOG_ERROR(\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n-    RCUTILS_LOG_WARN(\"Error occurred while doing error handling.\");\n+    RCLCPP_WARN(\n+      node_logging_interface_->get_logger(),\n+      \"Error occurred while doing error handling.\");\n-      RCUTILS_LOG_ERROR(\"Failed to call cleanup on error state: %s\", rcl_get_error_string().str);\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n+        \"Failed to call cleanup on error state: %s\", rcl_get_error_string().str);\n-      RCUTILS_LOG_ERROR(\"Caught exception in callback for transition %d\", it->first);\n-      RCUTILS_LOG_ERROR(\"Original error: %s\", e.what());\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n+        \"Caught exception in callback for transition %d\", it->first);\n+      RCLCPP_ERROR(\n+        node_logging_interface_->get_logger(),\n+        \"Original error: %s\", e.what());\n+#include \"rclcpp/node_interfaces/node_logging_interface.hpp\"\n-    std::shared_ptr<rclcpp::node_interfaces::NodeServicesInterface> node_services_interface);\n+    std::shared_ptr<rclcpp::node_interfaces::NodeServicesInterface> node_services_interface,\n+    std::shared_ptr<rclcpp::node_interfaces::NodeLoggingInterface> node_logging_interface);\n+  using NodeLoggingPtr = std::shared_ptr<rclcpp::node_interfaces::NodeLoggingInterface>;\n+  NodeLoggingPtr node_logging_interface_;",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "9c09ae86f04f061efa776c881e8bc19228ad83bf",
    "RawMessage": "Avoid redundant declarations in generated code for services and actions (#102)",
    "Changes": "-  set(_target_compile_flags -Wall -Wextra -Wpedantic)\n+  set(_target_compile_flags -Wall -Wextra -Wpedantic -Wredundant-decls)\n+forward_declared_types = set()\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-        include_directives=include_directives)\n+        include_directives=include_directives,\n+        forward_declared_types=forward_declared_types)\n-@[    for ns in type_.namespaces]@\n+@[    if type_.namespaced_name() in forward_declared_types]@\n+// functions for @('::'.join(type_.namespaced_name())) already declared above\n+@[    else]@\n+@{forward_declared_types.add(type_.namespaced_name())}@\n+@[      for ns in type_.namespaces]@\n-@[    end for]@\n+@[      end for]@\n-@[    for ns in reversed(type_.namespaces)]@\n+@[      for ns in reversed(type_.namespaces)]@\n-@[    end for]@\n+@[      end for]@\n+@[    end if]@\n+@{forward_declared_types.add(message.structure.namespaced_type.namespaced_name())}@\n-    include_directives=include_directives)\n+    include_directives=include_directives,\n+    forward_declared_types=forward_declared_types)\n-    include_directives=include_directives)\n+    include_directives=include_directives,\n+    forward_declared_types=forward_declared_types)\n-    include_directives=include_directives)\n+    include_directives=include_directives,\n+    forward_declared_types=forward_declared_types)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "fc281947ac2368a2a324cb1c76338908d4c81d2b",
    "RawMessage": "Remove the loading_ascii_stl_files_fail (#1125)",
    "Changes": "-solid ascii.stl\n-\n-facet normal 0.648000e-001 0.648000e-002 0.648000e-003\n-  outer loop\n-    vertex 1.648000e-001 2.648000e-002 3.648000e-003\n-    vertex 4.648000e-001 5.648000e-002 6.648000e-003\n-    vertex 7.648000e-001 8.648000e-002 9.648000e-003\n-  end loop\n-end facet\n-\n-facet normal 4.648000e-001 4.648000e-002 4.648000e-003\n-  outer loop\n-    vertex 10.648000e-001 11.648000e-002 12.648000e-003\n-    vertex 13.648000e-001 14.648000e-002 15.648000e-003\n-    vertex 16.648000e-001 17.648000e-002 18.648000e-003\n-  end loop\n-end facet\n-\n-endsolid ascii.stl\n-TEST_F(MeshLoaderTestFixture, loading_ascii_stl_files_fail) {\n-  /// Load an ascii STL file. Note that only binary STL files are supported.\n-  std::string mesh_path = \"package://rviz_rendering_tests/test_meshes/ascii.stl\";\n-\n-  ASSERT_FALSE(rviz_rendering::loadMeshFromResource(mesh_path));\n-}\n-",
    "BackportedTo": "iron",
    "Label": "Test"
  },
  {
    "Repository": "rclpy",
    "SHA": "79ec70656c1f11d131b4e4bfea039c5dd88d053a",
    "RawMessage": "ServerGoalHandle should be destroyed before removing. (#1113)",
    "Changes": "-        self._result_future = Future()\n-        action_server.add_future(self._result_future)\n-        self._action_server.remove_future(self._result_future)\n-\n+        # key: UUID in bytes, value: Future\n+        self._result_futures = {}\n+\n+                self._result_futures[bytes(goal_uuid.uuid)] = Future()\n+                self.add_future(self._result_futures[bytes(goal_uuid.uuid)])\n-        goal_handle._result_future.set_result(result_response)\n+        self._result_futures[bytes(goal_uuid)].set_result(result_response)\n-        self._goal_handles[bytes(goal_uuid)]._result_future.add_done_callback(\n+        self._result_futures[bytes(goal_uuid)].add_done_callback(\n+            self._goal_handles[goal_uuid].destroy()\n+            self.remove_future(self._result_futures[goal_uuid])\n+            del self._result_futures[goal_uuid]\n+        \"\"\"Remove the underlying result future.\"\"\"\n+        for result_future in self._result_futures.values():\n+            self.remove_future(result_future)\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "8b18525a77c177ad19716ff96e4a7f9c26856015",
    "RawMessage": "remove debugging statements. (#755)",
    "Changes": "-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);\n-  fprintf(stderr, \"%s\\n\", rcutils_get_error_string().str);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "91646cedfc368e29ab7e8f70cbf77aa1e354b5c4",
    "RawMessage": "rmw_cyclonedds_cpp/CMakeLists.txt: add -latomic for RISC-V (#332)",
    "Changes": "+if(CMAKE_GENERATOR_PLATFORM)\n+  set(TARGET_ARCH \"${CMAKE_GENERATOR_PLATFORM}\")\n+else()\n+  set(TARGET_ARCH \"${CMAKE_SYSTEM_PROCESSOR}\")\n+endif()\n+\n+if(CMAKE_COMPILER_IS_GNUCXX AND TARGET_ARCH MATCHES \"^(riscv|RISCV)64$\")\n+  # using GCC, libatomic is not automatically linked for RISC-V\n+  target_link_libraries(rmw_cyclonedds_cpp -latomic)\n+endif()\n+",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "f03bee27c06f5b2ed310d6e32616e92401e759ac",
    "RawMessage": "Added rmw_logging tests (#442)",
    "Changes": "+\n+  ament_add_gtest(test_logging test/test_logging.cpp)\n+  ament_target_dependencies(test_logging rmw)\n+  target_link_libraries(test_logging rmw_fastrtps_cpp)\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"fastrtps/log/Log.h\"\n+\n+#include \"rmw/rmw.h\"\n+#include \"rmw/error_handling.h\"\n+\n... [truncated] ...\n+TEST(TestLogging, rmw_logging)\n+{\n+  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(RMW_LOG_SEVERITY_DEBUG);\n+  EXPECT_EQ(ret, RMW_RET_OK);\n+  EXPECT_EQ(eprosima::fastrtps::Log::Kind::Info, eprosima::fastrtps::Log::GetVerbosity());\n+  ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(RMW_LOG_SEVERITY_INFO);\n+  EXPECT_EQ(ret, RMW_RET_OK);\n+  EXPECT_EQ(eprosima::fastrtps::Log::Kind::Info, eprosima::fastrtps::Log::GetVerbosity());\n+  ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(RMW_LOG_SEVERITY_WARN);\n+  EXPECT_EQ(ret, RMW_RET_OK);\n+  EXPECT_EQ(eprosima::fastrtps::Log::Kind::Warning, eprosima::fastrtps::Log::GetVerbosity());\n+  ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(RMW_LOG_SEVERITY_ERROR);\n+  EXPECT_EQ(ret, RMW_RET_OK);\n+  EXPECT_EQ(eprosima::fastrtps::Log::Kind::Error, eprosima::fastrtps::Log::GetVerbosity());\n+  ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(RMW_LOG_SEVERITY_FATAL);\n+  EXPECT_EQ(ret, RMW_RET_OK);\n+  EXPECT_EQ(eprosima::fastrtps::Log::Kind::Error, eprosima::fastrtps::Log::GetVerbosity());\n+}\n+\n+TEST(TestLogging, rmw_logging_bad_verbosity)\n+{\n+  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_set_log_severity(\n+    static_cast<rmw_log_severity_t>(RMW_LOG_SEVERITY_FATAL + 1));\n+  EXPECT_EQ(ret, RMW_RET_ERROR);\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "615efe639fd83940c9a44356684f0e5a9c5e09a0",
    "RawMessage": "Extend timeout to shutdown the command line process. (#783)",
    "Changes": "-                assert command.wait_for_shutdown(timeout=1)\n+                assert command.wait_for_shutdown(timeout=5)",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw",
    "SHA": "8a29332a3b6f8f3de6809426ef22e327c7927589",
    "RawMessage": "Update service request/response API documentation. (#279)",
    "Changes": "-/// Send a service request to the rmw server\n+/// Send a ROS service request.\n- * \\param[in] client The connected client over which to send this request\n- * \\param[in] ros_request the request message to send to the server\n- * \\param[out] sequence_id A unique identification value to identify this request\n- * \\return RMW_RET_OK if successful, otherwise an appropriate error code\n+ * Send a ROS service request to one or more service servers, with matching QoS policies,\n+ * using the given client.\n+ *\n+ * \\note It is implementation defined how many service servers may get, and potentially react to,\n+ *   the same request, considering there may be more than one server for the same service\n+ *   in the ROS graph.\n+ *\n+ * On success, this function will return a sequence number.\n+ * It is up to callers to save the returned sequence number to pair the ROS service request\n+ * just sent with future ROS service responses (taken using rmw_take_response()).\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n... [truncated] ...\n+ *   Therefore, it is safe to send responses using the same service server concurrently.\n+ *   However:\n+ *   - Access to the given ROS service request header is read-only but it is not synchronized.\n+ *     Concurrent `request_header` reads are safe, but concurrent reads and writes are not.\n+ *   - Access to the given ROS service response is read-only but it is not synchronized.\n+ *     Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.\n+ *\n+ * \\pre Given `service` must be a valid service server, as returned by rmw_create_service().\n+ * \\pre Given `request_header` must be the one previously taken along with the ROS service\n+ *   request to which we reply.\n+ * \\pre Given `ros_response` must be a valid service response, whose type matches the\n+ *   service type support registered with the `service` on creation.\n+ *\n+ * \\param[in] client Service server to send a response with.\n+ * \\param[in] request_header Service response header, same as the one taken\n+ *   with the corresponding ROS service request.\n+ * \\param[in] ros_response ROS service response to be sent.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`\n+ *   implementation identifier does not match this implementation, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "e9abdc4c28aa12269dfc76986ff0cda81b64f00e",
    "RawMessage": "Take all available samples on service/client on_data_available. (#616)",
    "Changes": "-    if (reader->take_next_sample(&data, &response.sample_info_) == ReturnCode_t::RETCODE_OK) {\n+    while (reader->take_next_sample(&data, &response.sample_info_) == ReturnCode_t::RETCODE_OK) {\n-    if (reader->take_next_sample(&data, &request.sample_info_) == ReturnCode_t::RETCODE_OK) {\n+    while (reader->take_next_sample(&data, &request.sample_info_) == ReturnCode_t::RETCODE_OK) {",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "d0b29f1e180ab08fdbd9870e29c9382f3aaff130",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#46)",
    "Changes": "-`rmw_dds_common` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw_dds_common` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw_dds_common` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rmw_dds_common` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rmw_dds_common` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rmw_dds_common` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rmw_dds_common` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw_dds_common` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "4d0be32e6c455edbf708003dffb67b11d512c5a6",
    "RawMessage": "Capture `std::bad_alloc` on deserializeROSmessage. (#665)",
    "Changes": "+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;\n+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "6b18a40056708c6f3acaafc08352b14554e33962",
    "RawMessage": "Drop PyKDL dependency in tf2_geometry_msgs (#509)",
    "Changes": "-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# ament_python_install_package(${PROJECT_NAME}\n-#      PACKAGE_DIR src/${PROJECT_NAME})\n-\n-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# install(PROGRAMS scripts/test.py\n-#    DESTINATION lib/${PROJECT_NAME}\n-# )\n+ament_python_install_package(${PROJECT_NAME}\n+  PACKAGE_DIR src/${PROJECT_NAME})\n+  find_package(ament_cmake_pytest REQUIRED)\n+  ament_add_pytest_test(test_tf2_geometry_msgs_py test/test_tf2_geometry_msgs.py)\n+\n-  <!-- python support not yet ported\n-  <build_depend>python_orocos_kdl</build_depend>\n-\n-  <exec_depend>python_orocos_kdl</exec_depend>\n-  -->\n-\n+  <exec_depend>python3-numpy</exec_depend>\n+  <test_depend>ament_cmake_pytest</test_depend>\n+[pytest]\n+junit_family=xunit2\n-from geometry_msgs.msg import (PointStamped, PoseStamped,\n-                               PoseWithCovarianceStamped, Vector3Stamped)\n... [truncated] ...\n+    :param pose: The pose with covariance stamped\n+    :param transform: The transform\n+    :returns: The transformed pose with covariance stamped\n+    \"\"\"\n-    res.pose.pose.position.x = f.p[0]\n-    res.pose.pose.position.y = f.p[1]\n-    res.pose.pose.position.z = f.p[2]\n-    (res.pose.pose.orientation.x,\n-     res.pose.pose.orientation.y,\n-     res.pose.pose.orientation.z,\n-     res.pose.pose.orientation.w) = f.M.GetQuaternion()\n+    res.pose.pose = do_transform_pose(pose.pose.pose, transform)\n-#!/usr/bin/env python3\n-\n-        self.assertEqual(out.pose.covariance, v.pose.covariance)\n-        self.assertEqual(out.pose.orientation.x, 0)\n-        self.assertEqual(out.pose.orientation.y, 0)\n-        self.assertEqual(out.pose.orientation.z, 0)\n-        self.assertEqual(out.pose.orientation.w, 1)\n+        self.assertEqual(out.pose.pose.orientation.x, 0)\n+        self.assertEqual(out.pose.pose.orientation.y, 0)\n+        self.assertEqual(out.pose.pose.orientation.z, 0)\n+        self.assertEqual(out.pose.pose.orientation.w, 1)\n-    unittest.main()\n+  <exec_depend>sensor_msgs</exec_depend>",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "066d8fe40601d3c37e8f1b7d1858e2d856487140",
    "RawMessage": "Asynchronously wait for load node service response (#174)",
    "Changes": "+import threading\n+\n+\n+        # Asynchronously wait on service call so that we can periodically check for shutdown\n+        event = threading.Event()\n+\n+        def unblock(future):\n+            nonlocal event\n+            event.set()\n+\n-        response = self.__rclpy_load_node_client.call(request)\n+\n+        response_future = self.__rclpy_load_node_client.call_async(request)\n+        response_future.add_done_callback(unblock)\n+\n+        while not event.wait(1.0):\n+            if context.is_shutdown:\n+                self.__logger.warning(\n+                    \"Abandoning wait for the '{}' service response, due to shutdown.\".format(\n+                        self.__rclpy_load_node_client.srv_name),\n+                )\n+                response_future.cancel()\n+                return\n+\n+        # Get response\n+        if response_future.exception() is not None:\n+            raise response_future.exception()\n+        response = response_future.result()\n+\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "7f9a307a9d232445928d04f50add7c0b3995fe22",
    "RawMessage": "TestClient.test_service_timestamps failing consistently. (#1364)",
    "Changes": "-                if result is not None:\n+                if result != (None, None):",
    "BackportedTo": "iron",
    "Label": "Test"
  },
  
  {
    "Repository": "ros2cli",
    "SHA": "e9789d44268fa04e98eaffab0789b6c6bbc5add4",
    "RawMessage": "Fix the component load help to mention load, not unload. (#756)",
    "Changes": "-            'container_node_name', help='Container node name to unload component from'\n+            'container_node_name', help='Container node name to load component into'",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "fc3807d20aa0603f78293e11635e90ececd0d1fa",
    "RawMessage": "Support zero copy API",
    "Changes": "-  rmw_publisher->can_loan_messages = false;\n+  rmw_publisher->can_loan_messages = dds_TypeSupport_is_plain(dds_typesupport) &&\n+    dds_DataWriter_is_data_sharing_enabled(topic_writer);\n-  (void)publisher;\n-  (void)ros_message;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(ros_message, RMW_RET_INVALID_ARGUMENT);\n-  RMW_SET_ERROR_MSG(\"rmw_publish_loaned_message is not supported\");\n-  return RMW_RET_UNSUPPORTED;\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    RMW_GURUMDDS_ID,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+\n+  if (!publisher->can_loan_messages) {\n+    RMW_SET_ERROR_MSG(\"Loaning is not supported\");\n+    return RMW_RET_UNSUPPORTED;\n+  }\n+\n+  auto publisher_info = static_cast<GurumddsPublisherInfo *>(publisher->data);\n+  RCUTILS_CHECK_ARGUMENT_FOR_NULL(publisher_info, RMW_RET_ERROR);\n+\n+  dds_DataWriter * topic_writer = publisher_info->topic_writer;\n+  RCUTILS_CHECK_ARGUMENT_FOR_NULL(topic_writer, RMW_RET_ERROR);\n... [truncated] ...\n+  if (!subscription->can_loan_messages) {\n+    RMW_SET_ERROR_MSG(\"Loaning is not supported\");\n+    return RMW_RET_UNSUPPORTED;\n+  }\n+\n+  return _take_serialized(\n+    RMW_GURUMDDS_ID,\n+    subscription,\n+    loaned_message,\n+    taken,\n+    message_info,\n+    allocation,\n+    true);\n-  (void)subscription;\n-  (void)loaned_message;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(loaned_message, RMW_RET_INVALID_ARGUMENT);\n-  RMW_SET_ERROR_MSG(\"rmw_return_loaned_message_from_subscription is not supported\");\n-  return RMW_RET_UNSUPPORTED;\n+  if (!subscription->can_loan_messages) {\n+    RMW_SET_ERROR_MSG(\"Loaning is not supported\");\n+    return RMW_RET_UNSUPPORTED;\n+  }\n+\n+  return RMW_RET_OK;",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "d5b274fae5829ad43b12abbbb1f29f773fa6a6ce",
    "RawMessage": "Fixed screw display (#1093)",
    "Changes": "-  float linear_scale = linear_scale_property_->getFloat();\n-  float angular_scale = angular_scale_property_->getFloat();\n-  float width = width_property_->getFloat();\n-  visual->setLinearScale(linear_scale);\n-  visual->setAngularScale(angular_scale);\n-  visual->setWidth(width);\n-  visual->setScrew(\n-    Ogre::Vector3(linear.x, linear.y, linear.z),\n-    Ogre::Vector3(angular.x, angular.y, angular.z));\n+  visual->setLinearScale(linear_scale_property_->getFloat());\n+  visual->setAngularScale(angular_scale_property_->getFloat());\n+  visual->setWidth(width_property_->getFloat());\n+  visual->setHideSmallValues(hide_small_values_property_->getBool());",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "2da35a4f1c7d056f3852411469bc017c19191664",
    "RawMessage": "decorator should not be callable. (#1050)",
    "Changes": "-        value = value.nanoseconds()\n+        value = value.nanoseconds\n+from rclpy.duration import Duration\n+from rclpy.qos import QoSDurabilityPolicy\n+from rclpy.qos import QoSHistoryPolicy\n+from rclpy.qos import QoSLivelinessPolicy\n+from rclpy.qos import QoSReliabilityPolicy\n+from rclpy.qos_overriding_options import _get_qos_policy_parameter\n+from rclpy.qos_overriding_options import QoSPolicyKind\n+def test_get_qos_policy_parameter():\n+    qos = QoSProfile(\n+        history=QoSHistoryPolicy.KEEP_LAST,\n+        depth=10,\n+        reliability=QoSReliabilityPolicy.RELIABLE,\n+        durability=QoSDurabilityPolicy.VOLATILE,\n+        lifespan=Duration(nanoseconds=1e3),\n+        deadline=Duration(nanoseconds=1e6),\n+        liveliness=QoSLivelinessPolicy.SYSTEM_DEFAULT,\n+        liveliness_lease_duration=Duration(nanoseconds=1e9)\n+        )\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.HISTORY)\n+    assert value == 'keep_last'\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.DEPTH)\n+    assert value == qos.depth\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.RELIABILITY)\n+    assert value == 'reliable'\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.DURABILITY)\n+    assert value == 'volatile'\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.LIFESPAN)\n+    assert value == qos.lifespan.nanoseconds\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.DEADLINE)\n+    assert value == qos.deadline.nanoseconds\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.LIVELINESS)\n+    assert value == 'system_default'\n+    value = _get_qos_policy_parameter(qos, QoSPolicyKind.LIVELINESS_LEASE_DURATION)\n+    assert value == qos.liveliness_lease_duration.nanoseconds\n+\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "add6b0a0c4565fe7ba0ef8da36018c8f2b84b019",
    "RawMessage": "Yuv to rgb changes (#701)",
    "Changes": "+  uint32_t stride_;\n+  std::shared_ptr<std::vector<uint8_t>> bufferptr_;\n+#include <memory>\n-  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n-    ImageData(image->encoding, image->data.data(), image->data.size()));\n-\n+  stride_ = image->step;\n+\n+  ImageData image_data = setFormatAndNormalizeDataIfNecessary(\n+    ImageData(image->encoding, image->data.data(), image->data.size()));\n+struct yuyv\n+{\n+  uint8_t y0;\n+  uint8_t u;\n+  uint8_t y1;\n+  uint8_t v;\n+};\n+\n+struct uyvy\n+{\n+  uint8_t u;\n+  uint8_t y0;\n+  uint8_t v;\n+  uint8_t y1;\n+};\n... [truncated] ...\n+  } else if ( // NOLINT enforces bracket on the same line, which makes code unreadable\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422 ||\n+    image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2)\n+  {\n+    size_t new_size = image_data.size_ * 3 / 2;\n+    if (!bufferptr_) {\n+      bufferptr_ = std::make_shared<std::vector<uint8_t>>(new_size);\n+    } else if (static_cast<size_t>(bufferptr_->size()) != new_size) {\n+      bufferptr_->resize(new_size, 0);\n+    }\n+\n+    if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422) {\n+      imageConvertYUV422ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    } else if (image_data.encoding_ == sensor_msgs::image_encodings::YUV422_YUY2) {\n+      imageConvertYUV422_YUY2ToRGB(\n+        bufferptr_->data(), const_cast<uint8_t *>(image_data.data_ptr_),\n+        0, height_, width_, stride_);\n+    }\n+\n+\n+    image_data.pixel_format_ = Ogre::PF_BYTE_RGB;\n+    image_data.data_ptr_ = bufferptr_->data();\n+    image_data.size_ = new_size;",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "e4856e4afeda704547bdb43edc29d008b07f15d9",
    "RawMessage": "Update the launch file to work with modern joy. (#52)",
    "Changes": "-================\n+=====================\n-The purpose of this package is to provide a generic facility for tele-operating Twist-based ROS2 robots with a standard joystick. \n+The purpose of this package is to provide a generic facility for tele-operating Twist-based ROS 2 robots with a standard joystick.\n-This node provides no rate limiting or autorepeat functionality. It is expected that you take advantage of the features built into [joy](https://index.ros.org/p/joy/github-ros-drivers-joystick_drivers/#foxy) for this.\n+This node provides no rate limiting or autorepeat functionality.\n+It is expected that you take advantage of the features built into [joy](https://index.ros.org/p/joy/github-ros-drivers-joystick_drivers) for this.\n-To configure the node to match your joystick a config file can be used. \n-There are several common ones provided in this package (atk3, ps3-holonomic, ps3, xbox, xd3), located here: https://github.com/ros2/teleop_twist_joy/tree/eloquent/config.\n+To configure the node to match your joystick a config file can be used.\n+There are several common ones provided in this package (atk3, ps3-holonomic, ps3, xbox, xd3), located here: https://github.com/ros2/teleop_twist_joy/tree/rolling/config.\n-- `joy_dev (string, default: 'dev/input/js0')`\n+- `joy_dev (string, default: '0')`\n-        launch.actions.DeclareLaunchArgument('joy_dev', default_value='/dev/input/js0'),\n+        launch.actions.DeclareLaunchArgument('joy_dev', default_value='0'),\n-                'dev': joy_dev,\n+                'device_id': joy_dev,",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "ab20449f19ea90670dc4419e9806e0c1b7b07d2d",
    "RawMessage": "Improve rcl timer test coverage. (#680)",
    "Changes": "+  # TODO(hidmic): re-enable timer tests against RTI Connext once\n+  #               https://github.com/ros2/rcl/issues/687 is resolved\n+  set(AMENT_GTEST_ARGS \"\")\n+  if(rmw_implementation STREQUAL \"rmw_connext_cpp\")\n+    message(STATUS \"Skipping test_timer${target_suffix} test.\")\n+    set(AMENT_GTEST_ARGS \"SKIP_TEST\")\n+  endif()\n+\n+  rcl_add_custom_gtest(test_timer${target_suffix}\n+    SRCS rcl/test_timer.cpp\n+    ENV ${rmw_implementation_env_var}\n+    APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n+    LIBRARIES ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools\n+    AMENT_DEPENDENCIES ${rmw_implementation}\n+    ${AMENT_GTEST_ARGS}\n+  )\n+\n-rcl_add_custom_gtest(test_timer${target_suffix}\n-  SRCS rcl/test_timer.cpp\n-  APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-  LIBRARIES ${PROJECT_NAME}\n-  AMENT_DEPENDENCIES \"osrf_testing_tools_cpp\"\n-)\n-\n+TEST_F(TestTimerFixture, test_timer_init_with_invalid_arguments) {\n... [truncated] ...\n+\n+  int64_t time_until_next_call = 0;\n+  ret = rcl_timer_get_time_until_next_call(&timer, &time_until_next_call);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_LE(time_until_next_call, 0);\n+\n+  EXPECT_EQ(RCL_RET_OK, rcl_timer_call(&timer)) << rcl_get_error_string().str;\n+}\n+\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_OK, rcl_enable_ros_time_override(&this->clock)) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_RET_OK, rcl_set_ros_time_override(&this->clock, -1)) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_timer_call(&timer));\n+  rcl_reset_error();\n+  EXPECT_EQ(times_called, 4);\n+\n+  rcl_reset_error();\n+  rcl_reset_error();\n+  rcl_reset_error();\n-  EXPECT_EQ(RCL_RET_OK, rcl_timer_fini(nullptr));\n+  EXPECT_EQ(RCL_RET_OK, rcl_timer_fini(nullptr)) << rcl_get_error_string().str;\n+  rcl_reset_error();\n+  rcl_reset_error();\n+  // Cope with coarse system time resolution.\n+  std::this_thread::sleep_for(std::chrono::milliseconds(1));",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "2c2287af3a4ed14eeeb50244a4faa8ebba20d8c7",
    "RawMessage": "Fix: printf in executor spin (#195)",
    "Changes": "-  printf(\"INFO: rcl_wait timeout %ld ms\\n\", ((executor->timeout_ns / 1000) / 1000));\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    ROS_PACKAGE_NAME,\n+    \"INFO: rcl_wait timeout %ld ms\",\n+    ((executor->timeout_ns / 1000) / 1000));",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "b03ad4d9af032d834206e9fe344c8c5f535d3da3",
    "RawMessage": "Added rmw_publisher_allocation and rmw_subscription_allocation related tests (#137)",
    "Changes": "+    ament_add_gtest(test_publisher_allocator${target_suffix}\n+      test/test_publisher_allocator.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_publisher_allocator${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_publisher_allocator${target_suffix}\n+      rmw rmw_implementation\n+    )\n+    ament_add_gtest(test_subscription_allocator${target_suffix}\n+      test/test_subscription_allocator.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_subscription_allocator${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_subscription_allocator${target_suffix}\n+      rmw rmw_implementation\n+    )\n+\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n... [truncated] ...\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include <gtest/gtest.h>\n+\n+#include \"rmw/rmw.h\"\n+\n+#ifdef RMW_IMPLEMENTATION\n+# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n+# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n+#else\n+# define CLASSNAME(NAME, SUFFIX) NAME\n+#endif\n+\n+class CLASSNAME (TestSubscriptionAllocator, RMW_IMPLEMENTATION) : public ::testing::Test {};\n+\n+TEST_F(CLASSNAME(TestSubscriptionAllocator, RMW_IMPLEMENTATION), init_fini_subscription_allocation)\n+{\n+  if (rmw_init_subscription_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n+    // Add tests here when the implementation it's supported\n+    GTEST_SKIP();\n+  } else {\n+    rmw_ret_t ret = rmw_fini_subscription_allocation(nullptr);\n+    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "1ea3e191b7fd284718412d97c6ffe34f4bd79fbd",
    "RawMessage": "Enhanced rpc with sampleinfoex",
    "Changes": "-  uint64_t guid_temp = 0;\n+  uint8_t client_guid[16] = {0};\n-  // Random values are required for GUID\n-  std::random_device rd;\n-  std::default_random_engine dre(rd());\n-  std::uniform_int_distribution<uint64_t> uniform_dist(\n-    (std::numeric_limits<uint64_t>::min)(),\n-    (std::numeric_limits<uint64_t>::max)());\n-\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid, &guid_temp, sizeof(guid_temp));\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid + sizeof(guid_temp), &guid_temp, sizeof(guid_temp));\n+  dds_DataWriter_get_guid(request_writer, client_guid);\n+  memcpy(client_info->writer_guid, client_guid, sizeof(client_guid));\n+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+\n-  void * dds_request = allocate_request(\n... [truncated] ...\n+ros_guid_to_dds_guid(int8_t * guid_ros, int8_t * guid_dds)\n+{\n+  memcpy(guid_dds, guid_ros, 12);\n+  memcpy(&guid_dds[12], &guid_ros[12], 4);\n+}\n+\n+inline void\n+dds_guid_to_ros_guid(int8_t * guid_dds, int8_t * guid_ros)\n+{\n+  memcpy(guid_ros, guid_dds, 12);\n+  memcpy(&guid_ros[12], &guid_dds[12], 4);\n+}\n+\n+inline void\n+ros_sn_to_dds_sn(int64_t sn_ros, uint64_t * sn_dds)\n+{\n+  *sn_dds = ((sn_ros) & 0xFFFFFFFF00000000LL) >> 32;\n+  *sn_dds = *sn_dds | ((sn_ros & 0x00000000FFFFFFFFLL) << 32);\n+}\n+\n+inline void\n+dds_sn_to_ros_sn(uint64_t sn_dds, int64_t * sn_ros)\n+{\n+  *sn_ros = ((sn_dds & 0x00000000FFFFFFFF) << 32) | ((sn_dds & 0xFFFFFFFF00000000) >> 32);\n+}",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "1d31f436592a778158d5b800c1854adcf8ddc798",
    "RawMessage": "Update documentation about number_of_handles (#326)",
    "Changes": "-As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.\n+As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added. \n+\n+Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See [Memory Management Tutorial](https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation) for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.\n- * running phase in the executor. However, the heap memory of corresponding wait-set is\n+ * running phase in the executor.\n+ *\n+ * Also in the XRCE-DDS middleware the maximum number are configured. See [Memory Management Tutorial](https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation)\n+ * for the default values. If you need larger values, you need to update your colcon.meta\n+ * configuration file and rebuild. To make sure that the changes were applied, you can check\n+ * the defined values in the following library include file:\n+ * build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h\n+ *\n+ * The heap memory of corresponding wait-set is",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "1ed02409a2a31ebdf9bbbae881ca4e71ce5ca375",
    "RawMessage": "update codecov to ignore rclc_examples and all test folders (#145)",
    "Changes": "-  - \"rclc_examples\"\n-  - \"rclc/test\"\n-  - \"rclc_lifecycle/test\"\n+  - \"rclc_examples/**/*\"\n+  - \"rclc/test/**/*\"\n+  - \"rclc_lifecycle/test/**/*\"\n+  - \"rclc_parameter/test/**/*\"",
    "BackportedTo": "galactic",
    "Label": "Test"
  },
  {
    "Repository": "rmw",
    "SHA": "c00d3655bb708dd8e3d5134281555aa73006c43c",
    "RawMessage": "Correct parameter names to match documentation (#250)",
    "Changes": "-  bool demangle,\n+  bool no_demangle,\n-  bool demangle,\n+  bool no_demangle,",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rviz",
    "SHA": "384d9c60def93e38ac4c01ddbed17a4731bc4424",
    "RawMessage": "Remove unused LineEditWithButton::simulateReturnPressed() (#1040)",
    "Changes": "-  /** @brief Send key events to mimic the \"return\" key being pressed and\n-   * released.  Useful ending an edit session and sending the data on\n-   * out. */\n-  void simulateReturnPressed();\n-\n-\n-void LineEditWithButton::simulateReturnPressed()\n-{\n-  // I couldn't find a way to directly tell the editor that I was\n-  // done with it here.  \"Q_EMIT returnPressed()\", \"Q_EMIT\n-  // editingFinished()\" etc did nothing.  So instead, here I\n-  // simulate the user pressing and releasing the \"Return\" key,\n-  // which does indeed make it act like I want: when you select a\n-  // topic from the dialog and the dialog closes, the property's\n-  // Setter is called and this editor closes.\n-  QKeyEvent * event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier);\n-  QApplication::postEvent(this, event);\n-  event = new QKeyEvent(QEvent::KeyRelease, Qt::Key_Return, Qt::NoModifier);\n-  QApplication::postEvent(this, event);\n-}\n-",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "359c265def31369c822d83cc96825a3247b344e5",
    "RawMessage": "Fix codecov to ignore unit tests and rclc_examples package (#155)",
    "Changes": "+fixes:\n+  - \"ros_ws/src/*/rclc::\"\n-  - \"rclc_examples/**/*\"\n-  - \"rclc_lifecycle/test/**/*\"\n+  - \"rclc_examples/**/*\"\n+  - \"rclc_lifecycle/test/*\"",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "2c2287af3a4ed14eeeb50244a4faa8ebba20d8c7",
    "RawMessage": "Fix: printf in executor spin (#195)",
    "Changes": "-  printf(\"INFO: rcl_wait timeout %ld ms\\n\", ((executor->timeout_ns / 1000) / 1000));\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    ROS_PACKAGE_NAME,\n+    \"INFO: rcl_wait timeout %ld ms\",\n+    ((executor->timeout_ns / 1000) / 1000));",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "07bdde07a704450b0d3278ebeb2bbfea1729106c",
    "RawMessage": "Add tests take sequence + take sequence with bad arguments (#128)",
    "Changes": "+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_sequence) {\n+  size_t count = 1u;\n+  size_t taken = 10u;  // Non-zero value to check variable update\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rmw_message_sequence_t sequence = rmw_get_zero_initialized_message_sequence();\n+  rmw_ret_t ret = rmw_message_sequence_init(&sequence, count, &allocator);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  rmw_message_info_sequence_t info_sequence = rmw_get_zero_initialized_message_info_sequence();\n+  ret = rmw_message_info_sequence_init(&info_sequence, count, &allocator);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n+\n+  ret = rmw_take_sequence(sub, count, &sequence, &info_sequence, &taken, null_allocation);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(taken, 0u);\n+\n+  ret = rmw_message_sequence_fini(&sequence);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  ret = rmw_message_info_sequence_fini(&info_sequence);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_sequence_with_bad_args) {\n+  size_t count = 1u;\n... [truncated] ...\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  const char * implementation_identifier = sub->implementation_identifier;\n+  sub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_take_sequence(sub, count, &sequence, &info_sequence, &taken, null_allocation);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(sequence.size, original_sequence.size);\n+  EXPECT_EQ(info_sequence.size, original_info.size);\n+  EXPECT_EQ(taken, 0u);\n+  rmw_reset_error();\n+  sub->implementation_identifier = implementation_identifier;\n+\n+  ret = rmw_message_sequence_fini(&sequence);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  ret = rmw_message_sequence_fini(&original_sequence);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  ret = rmw_message_info_sequence_fini(&info_sequence);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  ret = rmw_message_info_sequence_fini(&original_info);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "launch_ros",
    "SHA": "e181799a2938d9e0a0388ea1b0bf5376b9de934f",
    "RawMessage": "Fix race with launch context changes when loading composable nodes (#166)",
    "Changes": "-        composable_node_description: ComposableNode,\n+        request: composition_interfaces.srv.LoadNode.Request,\n-        :param composable_node_description: description of composable node to be loaded\n+        :param request: service request to load a node\n-        request = get_composable_node_load_request(composable_node_description, context)\n+        self.__logger.debug(\n+            \"Calling the '{}' service with request '{}'\".format(\n+                self.__rclpy_load_node_client.srv_name, request\n+            )\n+        )\n+        self.__logger.debug(\"Received response '{}'\".format(response))\n-        composable_node_descriptions: List[ComposableNode],\n+        load_node_requests: List[composition_interfaces.srv.LoadNode.Request],\n-        next_composable_node_description = composable_node_descriptions[0]\n-        composable_node_descriptions = composable_node_descriptions[1:]\n-        self._load_node(next_composable_node_description, context)\n-        if len(composable_node_descriptions) > 0:\n+        next_load_node_request = load_node_requests[0]\n+        load_node_requests = load_node_requests[1:]\n+        self._load_node(next_load_node_request, context)\n+        if len(load_node_requests) > 0:\n-                    None, self._load_in_sequence, composable_node_descriptions, context\n+                    None, self._load_in_sequence, load_node_requests, context\n+        # Generate load requests before execute() exits to avoid race with context changing\n+        # due to scope change (e.g. if loading nodes from within a GroupAction).\n... [truncated] ...\n+                PushRosNamespace('foo'),\n+                _load_composable_node(\n+                    package='foo_package',\n+                    plugin='bar_plugin',\n+                    name='test_node_name',\n+                    namespace='test_node_namespace'\n+                ),\n+            ],\n+            scoped=True,\n+        ),\n+    ])\n+\n+    # Check that launch is aware of loaded component\n+    assert get_node_name_count(context, '/foo/test_node_namespace/test_node_name') == 1\n+\n+    # Check that container recieved correct request\n+    assert len(mock_component_container.requests) == 1\n+    request = mock_component_container.requests[0]\n+    assert request.package_name == 'foo_package'\n+    assert request.plugin_name == 'bar_plugin'\n+    assert request.node_name == 'test_node_name'\n+    assert request.node_namespace == '/foo/test_node_namespace'\n+    assert len(request.remap_rules) == 0\n+    assert len(request.parameters) == 0\n+    assert len(request.extra_arguments) == 0",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "1760f4adad4d3b3cb3173ec951c5324def833c16",
    "RawMessage": "Correct the license content (#979)",
    "Changes": "-# limitations under the License.import time\n+# limitations under the License.",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "df27babd11d1a655d60ce9c5a4363f79ea8d6cf5",
    "RawMessage": "Makes topic_name a const ref",
    "Changes": "-void set_error_message_from_create_topic(dds_entity_t topic, std::string topic_name)\n+void set_error_message_from_create_topic(dds_entity_t topic, const std::string & topic_name)\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";\n+    const std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "476ff34b4152c56d5e6c8ce56bf18ccd109cc5dc",
    "RawMessage": "Handle empty strings when evaluating parameters (#300)",
    "Changes": "+                # Handle special case where yaml.safe_load will return None given an empty string\n+                if len(evaluated_value) == 0:\n+                    evaluated_value = \"''\"\n+\n+\n+\n+def test_empty_string_evalutates_to_empty_string():\n+    # Regression test for https://github.com/ros2/launch_ros/pull/289#discussion_r818070166\n+    orig = [{'foo': TextSubstitution(text='')}]\n+    norm = normalize_parameters(orig)\n+    expected = ({'foo': ''},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "common_interfaces",
    "SHA": "010889cc49dc035305adac4308a8f79483515c24",
    "RawMessage": "Fix path to CONTRIBUTING.md (#251)",
    "Changes": "-For how to contribute see [CONTRIBUTING.md](CONTRIBUTING.md)\n+For how to contribute see [CONTRIBUTING.md](common_interfaces/CONTRIBUTING.md)",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rosidl_defaults",
    "SHA": "bab051de528d6246ec38493d27e9996aadda3673",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#18)",
    "Changes": "-`rosidl_default_runtime` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rosidl_default_runtime` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rosidl_default_runtime` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rosidl_default_runtime` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-`rmw` uses and passes all the standard linters and static analysis tools for a CMake package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw` uses and passes all the standard linters and static analysis tools for a CMake package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "87fbec0d6bbfda968d14689c977e9a6bdaa48886",
    "RawMessage": "publish action goal status once accepted before execution. (#1228)",
    "Changes": "+        # Publish accepted status before execution\n+        self._handle.publish_status()\n+",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "93d4074a8bfd4d584cf5fdef22a88121e15e0352",
    "RawMessage": "remove feedback callback when the goal has been completed. (#927)",
    "Changes": "-        self._sequence_number_to_goal_id = {}\n+        self._goal_sequence_number_to_goal_id = {}\n+        # key: result request sequence_number, value: UUID\n+        self._result_sequence_number_to_goal_id = {}\n-        if seq in self._sequence_number_to_goal_id:\n-            del self._sequence_number_to_goal_id[seq]\n+        if seq in self._goal_sequence_number_to_goal_id:\n+            del self._goal_sequence_number_to_goal_id[seq]\n-        self._remove_pending_request(future, self._pending_result_requests)\n+        seq = self._remove_pending_request(future, self._pending_result_requests)\n+        if seq in self._result_sequence_number_to_goal_id:\n+            goal_uuid = bytes(self._result_sequence_number_to_goal_id[seq].uuid)\n+            del self._result_sequence_number_to_goal_id[seq]\n+            # remove feeback_callback if user is aware of result and it's been received\n+            if goal_uuid in self._feedback_callbacks:\n+                del self._feedback_callbacks[goal_uuid]\n-            if sequence_number in self._sequence_number_to_goal_id:\n+            if sequence_number in self._goal_sequence_number_to_goal_id:\n-                    self._sequence_number_to_goal_id[sequence_number],\n+                    self._goal_sequence_number_to_goal_id[sequence_number],\n-        self._sequence_number_to_goal_id[sequence_number] = request.goal_id\n+        self._goal_sequence_number_to_goal_id[sequence_number] = request.goal_id\n+        self._result_sequence_number_to_goal_id[sequence_number] = result_request.goal_id\n+    def test_send_goal_async_with_feedback_after_goal_result_requested(self):\n+        ac = ActionClient(self.node, Fibonacci, 'fibonacci')\n+        try:\n+            self.assertTrue(ac.wait_for_server(timeout_sec=2.0))\n+\n+            # Send a goal and wait for completion\n+            goal_uuid = UUID(uuid=list(uuid.uuid4().bytes))\n+            goal_future = ac.send_goal_async(\n+                Fibonacci.Goal(),\n+                feedback_callback=self.feedback_callback,\n+                goal_uuid=goal_uuid)\n+            rclpy.spin_until_future_complete(self.node, goal_future, self.executor)\n+            self.assertTrue(goal_future.done())\n+            # Then request result\n+            goal_handle = goal_future.result()\n+            result_future = goal_handle.get_result_async()\n+            rclpy.spin_until_future_complete(self.node, result_future, self.executor)\n+            self.assertTrue(result_future.done())\n+\n+            # Publish feedback after goal result is requested\n+            self.mock_action_server.publish_feedback(goal_uuid)\n+            self.timed_spin(1.0)\n+            self.assertEqual(self.feedback, None)\n+        finally:\n+            ac.destroy()\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "e442ad2278687a2d5994e580309fe31a435b6421",
    "RawMessage": "Deal with ParameterUninitializedException for parameter service (#1033)",
    "Changes": "+      test/test_parameter_client.py\n-from rclpy.exceptions import ParameterNotDeclaredException\n+from rclpy.exceptions import ParameterNotDeclaredException, ParameterUninitializedException\n-            except ParameterNotDeclaredException:\n+            except (ParameterNotDeclaredException, ParameterUninitializedException):\n+\n+    def test_get_uninitialized_parameter(self):\n+        self.target_node.declare_parameter('uninitialized_parameter', Parameter.Type.STRING)\n+\n+        # The type in description should be STRING\n+        future = self.client.describe_parameters(['uninitialized_parameter'])\n+        self.executor.spin_until_future_complete(future)\n+        results = future.result()\n+        assert results is not None\n+        assert len(results.descriptors) == 1\n+        assert results.descriptors[0].type == ParameterType.PARAMETER_STRING\n+        assert results.descriptors[0].name == 'uninitialized_parameter'\n+\n+        # The value should be empty\n+        future = self.client.get_parameters(['uninitialized_parameter'])\n+        self.executor.spin_until_future_complete(future)\n+        results = future.result()\n+        assert results is not None\n+        assert results.values == []\n+\n+        self.target_node.undeclare_parameter('uninitialized_parameter')",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7734acbeaca4e86aaddb91fb23f725a9ffcd4361",
    "RawMessage": "Update README.md",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+[Installation guide](https://docs.ros.org/en/humble/Installation/DDS-Implementations/Working-with-GurumNetworks-GurumDDS.html) is available.\n-For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+If GurumDDS is normally installed through the debian package, `GURUMDDS_HOME` will be set automatically.\n+For example, if `GURUMDDS_HOME=~/gurumdds` is set, the directory `~/gurumdds` will be:\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dds.h\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n-\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n-    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumidl\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation. For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=$GURUMDDS_HOME/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`. If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`. This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n-There are four active branches in this project: master, humble, galactic and foxy.\n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n-If you want to use this project with ROS2 Rolling Ridley, Galactic Geochelone or Foxy Fitzroy, please use master, galactic or foxy branch, respectively.\n+There are three active branches in this project: master, humble and foxy.  \n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n+If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "6c81f549919e99bd12cdb49da6ffa264a69623aa",
    "RawMessage": "Update expectations of tests to remain compatible with non-DDS middlewares (#248)",
    "Changes": "+  // For DDS-based middlewares, the QoS defined above might result in a mismatch while it might not\n+  // for other middlewares. Hence, we rely on rmw_qos_profile_check_compatible to infer whether\n+  // the publisher and subscription will match and accordingly evaluate match counts.\n+  rmw_qos_compatibility_type_t compat;\n+  rmw_ret_t rmw_ret =\n+    rmw_qos_profile_check_compatible(qos_profile, other_qos_profile, &compat, nullptr, 0);\n+  ASSERT_EQ(rmw_ret, RMW_RET_OK);\n+\n-  EXPECT_EQ(0u, subscription_count);\n+  if (compat == RMW_QOS_COMPATIBILITY_OK) {\n+    EXPECT_EQ(1u, subscription_count);\n+  } else {\n+    EXPECT_EQ(0u, subscription_count);\n+  }\n+  // For DDS-based middlewares, the QoS defined above might result in a mismatch while it might not\n+  // for other middlewares. Hence, we rely on rmw_qos_profile_check_compatible to infer whether\n+  // the publisher and subscription will match and accordingly evaluate match counts.\n+  rmw_qos_compatibility_type_t compat;\n+  rmw_ret_t rmw_ret =\n+    rmw_qos_profile_check_compatible(qos_profile, other_qos_profile, &compat, nullptr, 0);\n+  ASSERT_EQ(rmw_ret, RMW_RET_OK);\n+\n-  EXPECT_EQ(0u, publisher_count);\n+  if (compat == RMW_QOS_COMPATIBILITY_OK) {\n+    EXPECT_EQ(1u, publisher_count);\n+  } else {\n+    EXPECT_EQ(0u, publisher_count);\n+  }\n-    rmw_ret_t ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_LIVELINESS_CHANGED);\n+    rmw_ret_t ret = RMW_RET_OK;\n+    // rmw_zenoh does not support RMW_EVENT_LIVELINESS_CHANGED.\n+    // TODO(Yadunund): Rely on API suggested in https://github.com/ros2/rmw/issues/394 instead.\n+    if (std::string(rmw_get_implementation_identifier()).find(\"rmw_zenoh_cpp\") == 0) {\n+      ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_PUBLICATION_MATCHED);\n+    } else {\n+      ret = rmw_subscription_event_init(&event, sub, RMW_EVENT_LIVELINESS_CHANGED);\n+    }",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "eef4b5914a73cdf2e3547cbf201ebd67ad2d64e9",
    "RawMessage": "Ignoring unsuccessful SERVICE_TAKE (#175)",
    "Changes": "+          // invalidate that data is available, because rcl_take failed\n+          if (rc == RCL_RET_SUBSCRIPTION_TAKE_FAILED) {\n+            handle->data_available = false;\n+          }\n+          // invalidate that data is available, because rcl_take failed\n+          if (rc == RCL_RET_SERVICE_TAKE_FAILED) {\n+            handle->data_available = false;\n+          }\n-      if ((rc != RCL_RET_OK) && (rc != RCL_RET_SUBSCRIPTION_TAKE_FAILED)) {\n+      if ((rc != RCL_RET_OK) && (rc != RCL_RET_SUBSCRIPTION_TAKE_FAILED) &&\n+        (rc != RCL_RET_SERVICE_TAKE_FAILED))\n+      {\n-  rclc_executor_spin(&executor);\n+  RCSOFTCHECK(rclc_executor_spin(&executor));",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "2ec6797b6f12fe7e7fa6b00a48d44d9315275f80",
    "RawMessage": "update RCL_RET_TIMEOUT error handling with action service response. (#1258)",
    "Changes": "-        self._handle.send_cancel_response(request_header, cancel_response)\n+        try:\n+            # If the client goes away anytime before this, sending the goal response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_cancel_response(request_header, cancel_response)\n+        except RCLError:\n+            self._logger.warn('Failed to send cancel response (the client may have gone away)')\n-    throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n+    if (RCL_RET_TIMEOUT == ret) { \\\n+      int stack_level = 1; \\\n+      PyErr_WarnFormat( \\\n+        PyExc_RuntimeWarning, stack_level, \"failed to send response (timeout): %s\", \\\n+        rcl_get_error_string().str); \\\n+      rcl_reset_error(); \\\n+    } else { \\\n+      throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n+    } \\",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "e0f67db05c9579adec02be5546b07362b0dc24f8",
    "RawMessage": "rcl_logging_spdlog: Increased QL to 2 in QD",
    "Changes": "-The package `rcl_logging_spdlog` claims to be in the **Quality Level 3** category.\n+The package `rcl_logging_spdlog` claims to be in the **Quality Level 2** category.\n-`rcl_logging_spdlog` has a Direct Runtime non-ROS dependenciy the `spdlog` library. It was declared to be Quality Level 4 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).\n+`rcl_logging_spdlog` has a Direct Runtime non-ROS dependenciy the `spdlog` library. It was declared to be Quality Level 1 [here](https://github.com/ros2/spdlog_vendor/blob/master/SPDLOG_QUALITY_DECLARATION.md).\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "a7e3ceb23765b00a8cb444c76042e48a0a6170d3",
    "RawMessage": "Fix interface link libraries in ogre vendor (#761)",
    "Changes": "-    set_target_properties(rviz_ogre_vendor::OgreMain\n-      PROPERTIES\n-        \"INTERFACE_LINK_LIBRARIES\" \"${_extra_interface_link_libraries}\"\n+    target_link_libraries(rviz_ogre_vendor::OgreMain\n+      INTERFACE\n+      ${_extra_interface_link_libraries}",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "25511c38b2aeebb10de052e84e2600428255e67d",
    "RawMessage": "Use raw typesupport instead of typesupport",
    "Changes": "-  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n+  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n+  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n+  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n+  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n+  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n+  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n+  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n+  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "88ed960a2f6862c12c55674114fc64ee49fd8882",
    "RawMessage": "Add fault-injection unit tests (coverage part 2/3) (#766)",
    "Changes": "+    target_compile_definitions(test_namespace PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+    target_compile_definitions(test_parser PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+\n+TEST(TestNamespace, replace_ns_maybe_fail) {\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  namespace_tracker_t ns_tracker;\n+  ns_tracker.node_ns = rcutils_strdup(\"node1/node2\", allocator);\n+  ASSERT_STREQ(\"node1/node2\", ns_tracker.node_ns);\n+  ns_tracker.parameter_ns = rcutils_strdup(\"param1.param2\", allocator);\n+  ASSERT_STREQ(\"param1.param2\", ns_tracker.parameter_ns);\n+  ns_tracker.num_node_ns = 2;\n+  ns_tracker.num_parameter_ns = 2;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    allocator.deallocate(ns_tracker.node_ns, allocator.state);\n+    allocator.deallocate(ns_tracker.parameter_ns, allocator.state);\n+  });\n+\n+  char * expected_ns = rcutils_strdup(\"new_ns1/new_ns2/new_ns3\", allocator);\n+  ASSERT_STREQ(\"new_ns1/new_ns2/new_ns3\", expected_ns);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    allocator.deallocate(expected_ns, allocator.state);\n+  });\n+\n... [truncated] ...\n+    allocator.allocate(sizeof(rcutils_string_array_t), allocator.state));\n+  ASSERT_NE(nullptr, src_variant.string_array_value);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_variant_fini(&src_variant, allocator);\n+  });\n+  *src_variant.string_array_value = rcutils_get_zero_initialized_string_array();\n+  ASSERT_EQ(\n+    RCUTILS_RET_OK, rcutils_string_array_init(src_variant.string_array_value, size, &allocator));\n+  src_variant.string_array_value->size = size;\n+  src_variant.string_array_value->data[0] = rcutils_strdup(\"string1\", allocator);\n+  src_variant.string_array_value->data[1] = rcutils_strdup(\"string2\", allocator);\n+  src_variant.string_array_value->data[2] = rcutils_strdup(\"string3\", allocator);\n+  for (size_t i = 0; i < size; ++i) {\n+    ASSERT_NE(nullptr, src_variant.string_array_value->data[i]);\n+  }\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    rcl_variant_t dest_variant{};\n+    rcutils_ret_t ret = rcl_yaml_variant_copy(&dest_variant, &src_variant, allocator);\n+    (void)ret;\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+  });\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "c3837902230d6fe004b69b4fbcce8b229e4001ff",
    "RawMessage": "Update quality declaration document (#225)",
    "Changes": "-`rmw_implementation` does not expose a public API. There is no need to add documentation to new changes. In the case that this package adds public API features the documentation of new functionality will be required.\n+`rmw_implementation` does not expose a public API.\n+There is no need to add documentation to new changes.\n+In the case that this package adds public API features the documentation of new functionality will be required.\n-Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/master/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/master/test_communication) packages, further extend coverage.\n+Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/rolling/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/rolling/test_communication) packages, further extend coverage.\n-The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/master/rmw_implementation/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n+The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/rolling/rmw_implementation/test/benchmark).\n+The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n- - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n- - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n- - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n+ - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/rolling/rmw/QUALITY_DECLARATION.md)",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "cc0510b9003f2184146c0a094545451ce14ec72f",
    "RawMessage": "Remove all GitHub CI jobs (#414)",
    "Changes": "-definitions:\n-  - &empty_repo\n-    type: zip\n-    url: data:application/zip;base64,UEsFBgAAAAAAAAAAAAAAAAAAAAAAAA==\n-\n-repositories:\n-  ros2/rmw_connextdds/COLCON_IGNORE: *empty_repo\n-\n-  ros2/rosidl_typesupport_fastrtps/COLCON_IGNORE: *empty_repo\n-  ros2/rmw_fastrtps/COLCON_IGNORE: *empty_repo\n-name: ROS 2 CI\n-on:\n-  push:\n-    paths-ignore: ['**.md', '**.rst']\n-  pull_request:\n-    paths-ignore: ['**.md', '**.rst']\n-jobs:\n-  build:\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-          rosdistro: [rolling]\n-          os: [ubuntu-20.04, macOS-latest, windows-latest]\n-          include:\n-          - rosdistro: rolling\n... [truncated] ...\n-      with:\n-        path: ${{env.TEMP}}/chocolatey\n-        key: ${{matrix.os}}-chocolatey-${{github.job_id}}\n-        restore-keys: ${{matrix.os}}-chocolatey-\n-    - if: runner.os == 'Linux'\n-      # azure ubuntu repo can be flaky so add an alternate source\n-      run: sed -e 's/azure.archive.ubuntu.com/us.archive.ubuntu.com/g' -e t -e d /etc/apt/sources.list | sudo tee /etc/apt/sources.list.d/nonazure.list\n-    - name: Acquire ROS dependencies\n-      uses: ros-tooling/setup-ros@master\n-      with:\n-        # Install to avoid getting stuck on the license agreement prompt\n-        install-connext: true\n-    - name: Set up git to see all pull requests\n-      run: git config --global --add remote.origin.fetch '+refs/pull/*:refs/remotes/origin/pull/*'\n-    - name: Build and test ROS\n-      id: ros_ci\n-      uses: ros-tooling/action-ros-ci@v0.2\n-      with:\n-        package-name: >\n-          rmw_cyclonedds_cpp\n-          rmw_implementation\n-        target-ros2-distro: ${{matrix.rosdistro}}\n-        vcs-repo-file-url: >\n-          https://raw.githubusercontent.com/ros2/ros2/${{ matrix.repos_branch }}/ros2.repos\n-          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/local.repos",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "865b02bee84e75bde175515a2c71b667617187d1",
    "RawMessage": "Provide lifecycle services in the rclc lifecycle nodes (#51)",
    "Changes": "-  message(STATUS \"Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\")\n+  message(STATUS\n+    \"Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\")\n-  message(STATUS \"Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\")\n+  message(STATUS\n+    \"Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\")\n-  target_sources(${PROJECT_NAME} PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)\n+  target_sources(${PROJECT_NAME}\n+    PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)\n-  set(ament_cmake_copyright_FOUND TRUE) # No copyright header check since link to NOTICE file is not recognized properly.\n+  # No copyright header check since link to NOTICE file is not recognized properly.\n+  set(ament_cmake_copyright_FOUND TRUE)\n+\n-  rcl_node_t node = rcl_get_zero_initialized_node();\n+  rcl_node_t node;\n+#include <rclc/executor.h>\n+\n+#define RCCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n+        \"Failed status on line %d: %d. Aborting.\\n\", __LINE__, (int)temp_rc); return 1;}}\n+#define RCSOFTCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n+        \"Failed status on line %d: %d. Continuing.\\n\", __LINE__, (int)temp_rc);}}\n+\n-  rcl_node_t my_node = rcl_get_zero_initialized_node();\n+  rcl_node_t my_node;\n-  printf(\"make it a lifecycle node...\\n\");\n... [truncated] ...\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_get_available_states_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_ERROR, res);\n+\n+  // Now with correct number of handles\n+  rclc_executor_init(\n+    &executor,\n+    &context,\n+    3,  // 1 for each lifecycle service\n+    &allocator);\n+  res = rclc_lifecycle_init_get_state_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_get_available_states_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_change_state_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+\n+  // Cleanup\n+  res = rclc_lifecycle_node_fini(&lifecycle_node, &allocator);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rcl_node_fini(&my_node);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+}",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "ad389c6e750cddc317bb0230d38094d92deb2910",
    "RawMessage": "Avoid causing infinite loop when message is empty (#935)",
    "Changes": "-            cycle_count = 0\n-            while cycle_count < 5:\n+            for i in range(5):\n-                    time.sleep(0.1)\n+                    time.sleep(0.2)\n-        cycle_count = 0\n-        while cycle_count < 5:\n+        for i in range(5):\n-                time.sleep(0.1)\n+                time.sleep(0.2)",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "9abb3be6c9b482bb9945d9204a0427c7b3c0f450",
    "RawMessage": "Change docstring markdown code blocks to RST (#450)",
    "Changes": "-    e.g.:\n-    ```python3\n+\n+    For example:\n+\n+    .. code-block:: python\n+\n-                    Node(...),  // the param will be passed to this node\n+                    Node(...),  # the param will be passed to this node\n-            Node(...),  // here it won't be passed, as it's not in the same scope\n+            Node(...),  # here it won't be passed, as it's not in the same scope\n-    ```\n-    e.g.\n-    ```python3\n+    For example:\n+\n+    .. code-block:: python\n+\n-                    Node(...),  // the params will be passed to this node\n+                    Node(...),  # the params will be passed to this node\n-            Node(...),  // here it won't be passed, as it's not in the same scope\n+            Node(...),  # here it won't be passed, as it's not in the same scope\n-    ```\n-    ```xml\n-    <launch>\n... [truncated] ...\n+    For example:\n-    ```python3\n-    combined_ns = prefix_namespace('my_ns', 'original_ns')\n-    assert combined_ns == 'my_ns/original_ns'\n+    .. code-block:: python\n-    combined_ns = prefix_namespace('/my_ns', 'original_ns')\n-    assert combined_ns == '/my_ns/original_ns'\n+        combined_ns = prefix_namespace('my_ns', 'original_ns')\n+        assert combined_ns == 'my_ns/original_ns'\n-    combined_ns = prefix_namespace('my_ns', '/original_ns')\n-    assert combined_ns == '/original_ns'\n+        combined_ns = prefix_namespace('/my_ns', 'original_ns')\n+        assert combined_ns == '/my_ns/original_ns'\n-    combined_ns = prefix_namespace(None, 'original_ns')\n-    assert combined_ns == 'original_ns'\n+        combined_ns = prefix_namespace('my_ns', '/original_ns')\n+        assert combined_ns == '/original_ns'\n-    combined_ns = prefix_namespace('my_ns', None)\n-    assert combined_ns == 'my_ns'\n-    ```\n+        combined_ns = prefix_namespace(None, 'original_ns')\n+        assert combined_ns == 'original_ns'\n+\n+        combined_ns = prefix_namespace('my_ns', None)\n+        assert combined_ns == 'my_ns'",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "9918c61248381174ac93ed5735f0e4d95eb3806f",
    "RawMessage": "Fix unbounded sequence size",
    "Changes": "-        metastring << \"<(name=\" << member->name_ << \"_,maximum=128)\";\n+        metastring << \"<(name=\" << member->name_ << \"_)\";",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcutils",
    "SHA": "f662ccae73e367d8074a481f854adfb5d6541c53",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#483)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @ahcorde @clalancette @wjwwood",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "9ad5d5c649129e412d4eccf8f670f2bd97d53f3e",
    "RawMessage": "Several memory-related fixes for rcl_variant_t benchmarks (#813)",
    "Changes": "+    rcl_yaml_variant_fini(&dest_variant, allocator);\n-  rcl_yaml_variant_fini(&dest_variant, allocator);\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n-  rcl_yaml_variant_fini(&dest_variant, allocator);\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n-  rcl_yaml_variant_fini(&dest_variant, allocator);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_variant_fini(&src_variant, allocator);\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+  });\n-  src_variant.string_value = nullptr;\n-    src_variant.bool_array_value = nullptr;\n-    dest_variant.bool_array_value = nullptr;\n-    dest_variant.double_array_value = nullptr;\n-    src_variant.integer_array_value = nullptr;\n-    dest_variant.integer_array_value = nullptr;\n-    dest_variant.double_array_value = nullptr;\n-    src_variant.double_array_value = nullptr;\n-    dest_variant.double_array_value = nullptr;\n-    dest_variant.double_array_value = nullptr;\n-  src_variant.string_array_value->size = kSize;\n-    dest_variant.double_array_value = nullptr;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcpputils",
    "SHA": "ce124919e98c8747d80eb0af245670e62afa07e4",
    "RawMessage": "Fix possible race condition in create_directories() (#162)",
    "Changes": "+      if (status == -1 && errno == EEXIST) {\n+        status = 0;\n+      }",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "0263722fb48be9bddadef3601c50397c8d71a1d8",
    "RawMessage": "Remove subscription (#106) (#113)",
    "Changes": "+\n+/**\n+ *  Removes a subscription from an executor.\n+ * * An error is returned if {@link rclc_executor_t.handles} array is empty.\n+ * * An error is returned if subscription is not found in {@link rclc_executor_t.handles}.\n+ * * The total number_of_subscriptions field of {@link rclc_executor_t.info}\n+ *   is decremented by one.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param [inout] executor pointer to initialized executor\n+ * \\param [in] subscription pointer to an allocated and initialized subscription previously added to executor\n+ * \\return `RCL_RET_OK` if add-operation was successful\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any parameter is a null pointer\n+ * \\return `RCL_RET_ERROR` if any other error occured\n+ */\n+rcl_ret_t\n+rclc_executor_remove_subscription(\n+  rclc_executor_t * executor,\n... [truncated] ...\n+\n+  rc = rclc_executor_add_guard_condition(&executor, &guard_cond, &gc_callback);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+  EXPECT_EQ(executor.info.number_of_guard_conditions, (size_t) 1);\n+\n+  // test remove guard condition - invalid args\n+  rc = rclc_executor_remove_guard_condition(&executor, NULL);\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+  rc = rclc_executor_remove_guard_condition(NULL, &guard_cond);\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+  // test remove guard condition - valid args\n+  rc = rclc_executor_remove_guard_condition(&executor, &guard_cond);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+  EXPECT_EQ(executor.info.number_of_guard_conditions, (size_t) 0);\n+\n+  // test remove non-existent guard condition\n+  rc = rclc_executor_remove_guard_condition(&executor, &guard_cond);\n+  EXPECT_EQ(RCL_RET_ERROR, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "a9f9470800ca344a57a0a116b8fa8f914759d906",
    "RawMessage": "Make sure to always check return values. (#840)",
    "Changes": "-    (void)fini_ret;  // Error already set\n+    if (RCL_RET_OK != fini_ret) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\n+        \"Freeing names and types failed while handling a previous error. Leaking memory!\\n\");\n+    }\n+    if (RCL_RET_OK != ret) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\n+        \"Freeing names and types failed while handling a previous error. Leaking memory!\\n\");\n+    }\n+    if (RCL_RET_OK != ret) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\n+        \"Freeing names and types failed while handling a previous error. Leaking memory!\\n\");\n+    }\n+\n+    if (RCL_RET_OK != ret) {\n+      RCUTILS_SET_ERROR_MSG(\n+        \"Freeing names and types failed while handling a previous error. Leaking memory!\\n\");\n+    }\n+      if (ret != RCL_RET_OK) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\n+          \"Freeing state machine failed while handling a previous error. Leaking memory!\\n\");\n+      }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "51e576c5289a5d231f89c7593ded84c6ddade22f",
    "RawMessage": "Initialize more of the visualization_manager members. (#1090)",
    "Changes": "+  wall_clock_elapsed_(0),\n+  ros_time_elapsed_(0),",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "b4e3b9c4f6456b4cdf957296a1ad27c842bf91da",
    "RawMessage": "updated ros-tooling versions (#407)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.6.3\n+    - uses: ros-tooling/setup-ros@0.7.9\n-    - uses : ros-tooling/action-ros-ci@0.3.5\n+    - uses : ros-tooling/action-ros-ci@0.3.13\n-        void * /* context */) {};\n+      void * /* context */) {};\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      void * /* context */) {\n+    void * /* context */) {\n-      std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n+    std::shared_ptr<const Fibonacci::Goal> goal) -> rclcpp_action::GoalResponse {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n-      const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {\n+    const std::shared_ptr<const Fibonacci::Feedback> feedback) -> void {",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "a80e55b58cd25889fe2e2cea502a174aa9b4ef7f",
    "RawMessage": "Add mocking unit tests for rcl_yaml_param_parser (coverage part 3/3) (#772)",
    "Changes": "-    target_link_libraries(test_parse ${PROJECT_NAME})\n+    target_link_libraries(test_parse ${PROJECT_NAME} mimick)\n-    target_link_libraries(test_parser ${PROJECT_NAME})\n+    target_link_libraries(test_parser ${PROJECT_NAME} mimick)\n+  <test_depend>mimick_vendor</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Original file taken from:\n+// https://github.com/ros2/rcutils/blob/master/test/mocking_utils/patch.hpp\n+\n+#ifndef MOCKING_UTILS__PATCH_HPP_\n+#define MOCKING_UTILS__PATCH_HPP_\n+\n... [truncated] ...\n+\n+  rcl_params_t * params_hdl = rcl_yaml_node_struct_init(allocator);\n+  ASSERT_NE(nullptr, params_hdl);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rcl_yaml_param_parser\", yaml_parser_initialize, false);\n+\n+  EXPECT_FALSE(rcl_parse_yaml_file(path, params_hdl));\n+\n+  constexpr char node_name[] = \"node name\";\n+  constexpr char param_name[] = \"param name\";\n+  constexpr char yaml_value[] = \"true\";\n+\n+  rcl_params_t * params_st = rcl_yaml_node_struct_init(allocator);\n+  ASSERT_NE(params_st, nullptr);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_node_struct_fini(params_st);\n+  });\n+  EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "509947378c418c0266d043cf2a266a7daefc458e",
    "RawMessage": "Added build status of bloom-releases for Humble distribution (#291)",
    "Changes": "-Bloom release status of rclc packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic and Rolling.\n+Bloom release status of the packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic, Humble and Rolling.\n-| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Gpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_jammy_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_jammy_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary/)|  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary/) |",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "16e14d15e210672fbfe0beb1f57effbd8d1233b0",
    "RawMessage": "Add test creating two content filter topics with the same topic name (#230) (#233)",
    "Changes": "+\n+TEST_F(TestContentFilterSubscriptionUse, create_two_filters_with_same_topic_name_and_destroy) {\n+  if (sub->is_cft_enabled) {\n+    auto allocator = rcutils_get_default_allocator();\n+    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n+\n+    rmw_subscription_content_filter_options_t * content_filter_options =\n+      static_cast<rmw_subscription_content_filter_options_t *>(\n+      allocator.allocate(\n+        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      allocator.deallocate(content_filter_options, allocator.state);\n+    });\n+\n+    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters,\n+        &allocator,\n+        content_filter_options));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(content_filter_options, &allocator));\n+    });\n+\n+    options.content_filter_options = content_filter_options;\n+\n+    // Create another subscription with content filter in the same topic\n+    auto sub_2 = rmw_create_subscription(node, ts, topic_name, &qos_profile, &options);\n+    ASSERT_NE(nullptr, sub_2) << rmw_get_error_string().str;\n+\n+    rmw_ret_t ret = rmw_destroy_subscription(node, sub_2);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  }\n+}",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "c5edc37c45777f5b2a4001e0628036dea06b9585",
    "RawMessage": "Use gurumdds-3.1",
    "Changes": "+| 3.6.0  or higher         | higher than 3.1.0           |\n-  <build_depend>gurumdds-3.0</build_depend>\n+  <build_depend>gurumdds-3.1</build_depend>\n-  <build_depend>gurumdds-3.0</build_depend>\n+  <build_depend>gurumdds-3.1</build_depend>\n-  <build_export_depend>gurumdds-3.0</build_export_depend>\n+  <build_export_depend>gurumdds-3.1</build_export_depend>",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7b292c8a3b0782f37cb9051e3c2063055a3a0c4f",
    "RawMessage": "Remove datareader listener patch",
    "Changes": "-#include <queue>\n-\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n+  dds_ReadCondition * read_condition;\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n-\n+  dds_ReadCondition * read_condition;\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n-\n+  dds_ReadCondition * read_condition;\n-  dds_DataReaderListener datareader_listener = {};\n-  dds_GuardCondition * queue_guard_condition = nullptr;\n+  dds_ReadCondition * read_condition = nullptr;\n-  datareader_listener.on_data_available = reader_on_data_available<GurumddsClientInfo>;\n-\n-    dds_subscriber, response_topic, &datareader_qos, &datareader_listener,\n-    dds_DATA_AVAILABLE_STATUS);\n+    dds_subscriber, response_topic, &datareader_qos, nullptr, 0);\n-  dds_DataReader_set_listener_context(client_info->response_reader, client_info);\n... [truncated] ...\n-    }\n-    dds_DataSeq_delete(sample_seq);\n-    dds_SampleInfoSeq_delete(info_seq);\n-    dds_UnsignedLongSeq_delete(size_seq);\n-    return;\n-  }\n-\n-  subscriber_info->queue_mutex.lock();\n-  dds_GuardCondition_set_trigger_value(subscriber_info->queue_guard_condition, true);\n-  for (uint32_t i = 0; i < dds_DataSeq_length(sample_seq); i++) {\n-    GurumddsMessage msg;\n-    msg.sample = dds_DataSeq_get(sample_seq, i);\n-    msg.info = dds_SampleInfoSeq_get(info_seq, i);\n-    msg.size = dds_UnsignedLongSeq_get(size_seq, i);\n-    subscriber_info->message_queue.push(std::move(msg));\n-  }\n-  subscriber_info->queue_mutex.unlock();\n-\n-  // return loan manually after deserialization\n-  // or before destruction of the queue using free()\n-  dds_DataSeq_delete(sample_seq);\n-  dds_SampleInfoSeq_delete(info_seq);\n-  dds_UnsignedLongSeq_delete(size_seq);\n-}\n-",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "e0252bdb7d86a01688d22d76cdbe6e3d960a6aec",
    "RawMessage": "added pingpong example (#172)",
    "Changes": "+\n+add_executable(example_pingpong src/example_pingpong.cpp)\n+ament_target_dependencies(example_pingpong rcl rclc std_msgs)\n+\n+  example_pingpong\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include<iostream>\n+#include<functional>\n+#include <stdio.h>\n+#include <std_msgs/msg/string.h>\n+#include <rclc/executor.h>\n+#include <rclc/rclc.h>\n... [truncated] ...\n+    printf(\"Callback: msg NULL\\n\");\n+  } else {\n+    printf(\"Callback: I heard: %s\\n\", msg->data.data);\n+  }\n+}\n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+#include <rcl/rcl.h>\n+#include <rcl/error_handling.h>\n+#include <rclc/rclc.h>\n+#include <std_msgs/msg/string.h>\n+\n+void pong_subscription_callback_on_update(const void * msgin);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "c49991e8bfe3cfff15f87da2f04d3ada2c70d58c",
    "RawMessage": "Use DataWriter Qos to configure max_blocking_time on rmw_send_response (#704)",
    "Changes": "+  template<class Rep, class Period>\n-    const eprosima::fastrtps::rtps::GUID_t & guid)\n+    const eprosima::fastrtps::rtps::GUID_t & guid,\n+    const std::chrono::duration<Rep, Period> & max_blocking_time)\n-    if (!wait_for_subscription(guid, std::chrono::milliseconds(100))) {\n+    if (!wait_for_subscription(guid, max_blocking_time)) {\n-    client_present_t ret = listener->check_for_subscription(related_guid);\n+    auto writer_max_blocking_time =\n+      info->response_writer_->get_qos().reliability().max_blocking_time;\n+    auto max_blocking_time =\n+      std::chrono::seconds(writer_max_blocking_time.seconds) +\n+      std::chrono::nanoseconds(writer_max_blocking_time.nanosec);\n+    client_present_t ret = listener->check_for_subscription(related_guid, max_blocking_time);",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "dbc240db0b648be0d6b9d1981d9a0b43dcc58067",
    "RawMessage": "Delete frame_locked_markers when reusing marker (#907)",
    "Changes": "+    frame_locked_markers_.erase(marker);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_defaults",
    "SHA": "25d6e3bc29ffd4fb6fd04b120198fe4510e096a5",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#28)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "bf5888e5f67df382590d6ee05ea2175500ee8b9f",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#185)",
    "Changes": "-`rmw_implementation` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw_implementation` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw_implementation` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n+`rmw_implementation` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process).\n-All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-`rmw_implementation` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rmw_implementation` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-A description of how coverage statistics are summarized from this page, can be found in the [ROS 2 Onboarding Guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A description of how coverage statistics are summarized from this page, can be found in the [ROS 2 Onboarding Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rmw_implementation` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis).\n+`rmw_implementation` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "810afe1b84e0bc4ac397662694a1b27ae13d81b7",
    "RawMessage": "added documentation about number_of_handles in all examples. (#341)",
    "Changes": "+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n-  // Optional prepare for avoiding allocations during spin\n-  rclc_executor_prepare(&executor);\n-\n+  // Start Executor\n-  // If you need more than the default number of publisher/subscribers, etc., you \n+  // If you need more than the default number of publisher/subscribers, etc., you\n-  // See documentation in the executor.h at the function rclc_executor_init() \n-  // for more details. \n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n... [truncated] ...\n+    // See documentation in the executor.h at the function rclc_executor_init()\n+    // for more details.\n-  \n-    // Optional prepare for avoiding allocations during spin\n+    // Optional: prepare for avoiding allocations during spin\n-    // rclc_executor_spin(&executor ); end less loop\n-\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n-\n+  // Start Executor\n-\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "020bcd022456ab148dc80bc6b9f30b7d55e1eb65",
    "RawMessage": "Revert raw typesupport patch",
    "Changes": "-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "bc4bbacb22c618d79aff747707bd757e3f973884",
    "RawMessage": "Fix yaml parser error when meets .nan (refactor on #754) (#781)",
    "Changes": "+#include <ctype.h>\n+#include <stdlib.h>\n+#include <string.h>\n-    dval = strtod(value, &endptr);\n+    const char * iter_ptr = NULL;\n+    if ((0 == strcmp(value, \".nan\")) ||\n+      (0 == strcmp(value, \".NaN\")) ||\n+      (0 == strcmp(value, \".NAN\")) ||\n+      (0 == strcmp(value, \".inf\")) ||\n+      (0 == strcmp(value, \".Inf\")) ||\n+      (0 == strcmp(value, \".INF\")) ||\n+      (0 == strcmp(value, \"+.inf\")) ||\n+      (0 == strcmp(value, \"+.Inf\")) ||\n+      (0 == strcmp(value, \"+.INF\")) ||\n+      (0 == strcmp(value, \"-.inf\")) ||\n+      (0 == strcmp(value, \"-.Inf\")) ||\n+      (0 == strcmp(value, \"-.INF\")))\n+    {\n+      for (iter_ptr = value; !isalpha(*iter_ptr); ) {\n+        iter_ptr += 1;\n+      }\n+      dval = strtod(iter_ptr, &endptr);\n+      if (*value == '-') {\n+        dval = -dval;\n+      }\n... [truncated] ...\n+    rcl_yaml_node_struct_fini(params_hdl);\n+  });\n+\n+  bool res = rcl_parse_yaml_file(path, params_hdl);\n+  EXPECT_TRUE(res) << rcutils_get_error_string().str;\n+  rcl_variant_t * param_value = rcl_yaml_node_struct_get(\"test_node\", \"isstring\", params_hdl);\n+  ASSERT_TRUE(NULL != param_value) << rcutils_get_error_string().str;\n+  ASSERT_TRUE(NULL != param_value->string_array_value);\n+  EXPECT_STREQ(\".nananan\", param_value->string_array_value->data[1]);\n+  EXPECT_STREQ(\".nAN\", param_value->string_array_value->data[2]);\n+  EXPECT_STREQ(\".infinf\", param_value->string_array_value->data[4]);\n+  EXPECT_STREQ(\".INf\", param_value->string_array_value->data[5]);\n+  param_value = rcl_yaml_node_struct_get(\n+    \"test_node\", \"nan_inf\", params_hdl);\n+  ASSERT_TRUE(NULL != param_value) << rcutils_get_error_string().str;\n+  ASSERT_TRUE(NULL != param_value->double_array_value);\n+  ASSERT_EQ(7U, param_value->double_array_value->size);\n+  EXPECT_FALSE(std::isnan(param_value->double_array_value->values[1]));\n+  EXPECT_TRUE(std::isnan(param_value->double_array_value->values[2]));\n+  EXPECT_TRUE(std::isnan(param_value->double_array_value->values[3]));\n+  EXPECT_TRUE(std::isinf(param_value->double_array_value->values[4]));\n+  EXPECT_TRUE(std::isinf(param_value->double_array_value->values[5]));\n+  EXPECT_TRUE(std::isinf(param_value->double_array_value->values[6]));\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "0f6b3ad9c78c97d702f8f52b31e7cb46a64b8d35",
    "RawMessage": "Fixed low FPS when sending point markers (#1049)",
    "Changes": "+  auto num_vertices = internals.rend->getBuffer()->getNumVertices();\n+  auto vertex_size =\n+    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n+\n-      reinterpret_cast<uint8_t *>(float_buffer) +\n-      internals.rend->getBuffer()->getNumVertices() *\n-      internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0));\n+      reinterpret_cast<uint8_t *>(float_buffer) + num_vertices * vertex_size);",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "966efa3c49258cd011bbe2e78ebd718308bcb615",
    "RawMessage": "Add remap needed null check (#711)",
    "Changes": "+  RCL_CHECK_ARGUMENT_FOR_NULL(rule->impl, RCL_RET_INVALID_ARGUMENT);\n+  // Not valid null ptrs\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_remap_copy(nullptr, &remap_dst));\n+  rcl_reset_error();\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_remap_copy(parsed_args.impl->remap_rules, nullptr));\n+  rcl_reset_error();\n+\n+  // Not valid empty source\n+  rcl_remap_t remap_empty = rcl_get_zero_initialized_remap();\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_remap_copy(&remap_empty, &remap_dst));\n+  rcl_reset_error();\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rosidl_python",
    "SHA": "4acc8fc6098f9fd1f0172c42d9422d35527b411c",
    "RawMessage": "Removes erroneous unmatched closing parenthesis (#125)",
    "Changes": "+      msg/BuiltinTypeSequencesIdl.idl\n+module rosidl_generator_py {\n+    module msg {\n+        struct BuiltinTypeSequencesIdl {\n+            // Unbounded sequences\n+            sequence<char> char_sequence_unbounded;\n+        };\n+    };\n+};\n-                 all(val >= 0 and val) < 256 for val in value)), \\\n+                 all(ord(val) >= 0 and ord(val) < 256 for val in value)), \\\n+from rosidl_generator_py.msg import BuiltinTypeSequencesIdl\n+\n+\n+def test_builtin_sequence_slot_attributes():\n+    msg = BuiltinTypeSequencesIdl()\n+    assert hasattr(msg, 'get_fields_and_field_types')\n+    assert hasattr(msg, '__slots__')\n+    builtin_sequence_slot_types_dict = getattr(msg, 'get_fields_and_field_types')()\n+    builtin_sequence_slots = getattr(msg, '__slots__')\n+    assert len(builtin_sequence_slot_types_dict) == len(builtin_sequence_slots)",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclcpp",
    "SHA": "e7f06398dbcc5ef59362f416535f9e7acb0899ff",
    "RawMessage": "add logger level service to lifecycle node. (#2277)",
    "Changes": "+\n+  if (options.enable_logger_service()) {\n+    node_logging_->create_logger_services(node_services_);\n+  }\n+#include \"rcl_interfaces/srv/get_logger_levels.hpp\"\n+#include \"rcl_interfaces/srv/set_logger_levels.hpp\"\n+using namespace std::chrono_literals;\n+\n+TEST_F(TestDefaultStateMachine, check_logger_services_exist) {\n+  // Logger level services are disabled\n+  {\n+    rclcpp::NodeOptions options = rclcpp::NodeOptions();\n+    options.enable_logger_service(false);\n+    auto node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\n+      \"test_logger_service\", \"/test\", options);\n+    auto get_client = node->create_client<rcl_interfaces::srv::GetLoggerLevels>(\n+      \"/test/test_logger_service/get_logger_levels\");\n+    ASSERT_FALSE(get_client->wait_for_service(2s));\n+    auto set_client = node->create_client<rcl_interfaces::srv::SetLoggerLevels>(\n+      \"/test/test_logger_service/set_logger_levels\");\n+    ASSERT_FALSE(set_client->wait_for_service(2s));\n+  }\n+  // Logger level services are enabled\n+  {\n+    rclcpp::NodeOptions options = rclcpp::NodeOptions();\n+    options.enable_logger_service(true);\n+    auto node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\n+      \"test_logger_service\", \"/test\", options);\n+    auto get_client = node->create_client<rcl_interfaces::srv::GetLoggerLevels>(\n+      \"/test/test_logger_service/get_logger_levels\");\n+    ASSERT_TRUE(get_client->wait_for_service(2s));\n+    auto set_client = node->create_client<rcl_interfaces::srv::SetLoggerLevels>(\n+      \"/test/test_logger_service/set_logger_levels\");\n+    ASSERT_TRUE(set_client->wait_for_service(2s));\n+  }\n+}\n+",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "243f52119ac99f7d6b3c6e73713f7b79791681b8",
    "RawMessage": "Update gid API return codes. (#244)",
    "Changes": "-  RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n-  RET_NULL(gid);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(gid, RMW_RET_INVALID_ARGUMENT);\n-  RET_NULL(pub);\n-  RET_NULL(gid1);\n-  RET_WRONG_IMPLID(gid1);\n-  RET_NULL(gid2);\n-  RET_WRONG_IMPLID(gid2);\n-  RET_NULL(result);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(gid1, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    gid1,\n+    gid1->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(gid2, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    gid2,\n+    gid2->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(result, RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "fd648d98f17891420679f8d613f8771f5e446390",
    "RawMessage": "Example real-time concurreny timer and subscription (#329)",
    "Changes": "+add_executable(example_short_timer_long_subscription src/example_short_timer_long_subscription.c)\n+ament_target_dependencies(example_short_timer_long_subscription rcl rclc std_msgs)\n+\n+  example_short_timer_long_subscription\n+- [example_short_timer_long_subscription.c](src/example_client_node.c) demo with high frequency timer and subscription with long processing time with one executor.\n+## Example real-time concurrency slow timer and long subscription\n+This example demonstrates what happens, if a high frequency timer (every 100ms) and\n+a subscription with a long processing time is managed by one executor. This demo shows,\n+that the timer events are dropped during the long processing time of the subscription and are also not caught-up when there would be sufficient time. \n+// Copyright (c) 2020 - for information on the respective copyright owner\n+// see the NOTICE file and/or the repository https://github.com/ros2/rclc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <stdio.h>\n... [truncated] ...\n+  rclc_executor_add_timer(&executor, &short_timer);\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error in rclc_executor_add_timer.\\n\");\n+  }\n+\n+  rclc_executor_spin(&executor);\n+\n+\n+  // clean up\n+  rc = rclc_executor_fini(&executor);\n+  rc += rcl_publisher_fini(&my_pub, &my_node);\n+  rc += rcl_timer_fini(&my_timer);\n+  rc += rcl_subscription_fini(&my_sub, &my_node);\n+  rc += rcl_node_fini(&my_node);\n+  rc += rclc_support_fini(&support);\n+\n+  std_msgs__msg__Int32__fini(&pub_msg);\n+  std_msgs__msg__Int32__fini(&sub_msg);\n+\n+  if (rc != RCL_RET_OK) {\n+    printf(\"Error while cleaning up!\\n\");\n+    return -1;\n+  }\n+  return 0;\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "eea784efb4e2ac1728f7f458a890afde7accada7",
    "RawMessage": "Update gid API return codes. (#440)",
    "Changes": "-#include \"rmw/rmw.h\"\n+#include \"rmw/impl/cpp/macros.hpp\"\n+#include \"rmw/rmw.h\"\n-  if (!gid1) {\n-    RMW_SET_ERROR_MSG(\"gid1 is null\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (gid1->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"guid1 handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (!gid2) {\n-    RMW_SET_ERROR_MSG(\"gid2 is null\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (gid2->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"gid2 handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (!result) {\n-    RMW_SET_ERROR_MSG(\"result is null\");\n... [truncated] ...\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (publisher->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"publisher handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (!gid) {\n-    RMW_SET_ERROR_MSG(\"gid is null\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(gid, RMW_RET_INVALID_ARGUMENT);\n-\n-  if (!info) {\n-    RMW_SET_ERROR_MSG(\"publisher info handle is null\");\n-    return RMW_RET_ERROR;\n-  }\n-",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "0bd27f13b02e3b037a1acbf8c1917d9188ec6d77",
    "RawMessage": "Add ommited memory manage code",
    "Changes": "+      dds_TopicQos_finalize(&topic_qos);\n+      dds_TopicQos_finalize(&topic_qos);\n+    dds_DataWriterQos_finalize(&datawriter_qos);\n+    dds_DataReaderQos_finalize(&datareader_qos);\n+  if (request_topic != nullptr) {\n+    dds_DomainParticipant_delete_topic(participant, request_topic);\n+  }\n+\n+  if (response_topic != nullptr) {\n+    dds_DomainParticipant_delete_topic(participant, response_topic);\n+  }\n+\n+  if (request_typesupport != nullptr) {\n+    dds_TypeSupport_delete(request_typesupport);\n+  }\n+\n+  if (response_typesupport != nullptr) {\n+    dds_TypeSupport_delete(response_typesupport);\n+  }\n+\n+  if (node_info == nullptr) {\n+    RMW_SET_ERROR_MSG(\"node info handle is null\");\n+    return RMW_RET_ERROR;\n+  }\n+      dds_TopicQos_finalize(&topic_qos);\n... [truncated] ...\n+    dds_DataReaderQos_finalize(&datareader_qos);\n+    dds_DataWriterQos_finalize(&datawriter_qos);\n+  if (request_topic != nullptr) {\n+    dds_DomainParticipant_delete_topic(participant, request_topic);\n+  }\n+\n+  if (response_topic != nullptr) {\n+    dds_DomainParticipant_delete_topic(participant, response_topic);\n+  }\n+\n+  if (node_info == nullptr) {\n+    RMW_SET_ERROR_MSG(\"node info handle is null\");\n+    return RMW_RET_ERROR;\n+  }\n+      dds_TopicQos_finalize(&topic_qos);\n+    dds_DataReaderQos_finalize(&datareader_qos);\n+  if (topic != nullptr) {\n+    dds_DomainParticipant_delete_topic(participant, topic);\n+  }\n+\n+  ret = dds_DataReaderQos_finalize(&dds_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datareader qos\");\n+    return RMW_RET_ERROR;\n+  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "2a8f23ed1b52ea2355658cce09d7045b955f417a",
    "RawMessage": "Fix a bad bug in fetching the lifecycle transitions. (#1321)",
    "Changes": "+      test/test_lifecycle.py\n-    for (size_t i = 0; i <= state_machine_->transition_map.states_size; ++i) {\n+    for (size_t i = 0; i < state_machine_->transition_map.states_size; ++i) {\n-        'shuttingdown', 'activating', 'deactivating', 'errorprocessing', ''\n+        'shuttingdown', 'activating', 'deactivating', 'errorprocessing'",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "25511c38b2aeebb10de052e84e2600428255e67d",
    "RawMessage": "Use raw typesupport instead of typesupport",
    "Changes": "-  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n+  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n+  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n+  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n+  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n+  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n+  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n+  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n-  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n+  uint8_t typehash[16];\n+  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n+  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "97edce2df1030e63c9b9c50040d3fa6b4a49578c",
    "RawMessage": "Use unique mangled names when creating Content Filter Topics (#762)",
    "Changes": "+#include <atomic>\n+#include <cstdint>\n-  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX;\n+  static std::atomic<uint32_t> cft_counter{0};\n+  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX + \"_\" +\n+    std::to_string(cft_counter.fetch_add(1));",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7b292c8a3b0782f37cb9051e3c2063055a3a0c4f",
    "RawMessage": "Remove datareader listener patch",
    "Changes": "-#include <queue>\n-\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n+  dds_ReadCondition * read_condition;\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n-\n+  dds_ReadCondition * read_condition;\n-  std::queue<GurumddsMessage> message_queue;\n-  dds_GuardCondition * queue_guard_condition;\n-  std::mutex queue_mutex;\n-\n+  dds_ReadCondition * read_condition;\n-  dds_DataReaderListener datareader_listener = {};\n-  dds_GuardCondition * queue_guard_condition = nullptr;\n+  dds_ReadCondition * read_condition = nullptr;\n-  datareader_listener.on_data_available = reader_on_data_available<GurumddsClientInfo>;\n-\n-    dds_subscriber, response_topic, &datareader_qos, &datareader_listener,\n-    dds_DATA_AVAILABLE_STATUS);\n+    dds_subscriber, response_topic, &datareader_qos, nullptr, 0);\n-  dds_DataReader_set_listener_context(client_info->response_reader, client_info);\n... [truncated] ...\n-    }\n-    dds_DataSeq_delete(sample_seq);\n-    dds_SampleInfoSeq_delete(info_seq);\n-    dds_UnsignedLongSeq_delete(size_seq);\n-    return;\n-  }\n-\n-  subscriber_info->queue_mutex.lock();\n-  dds_GuardCondition_set_trigger_value(subscriber_info->queue_guard_condition, true);\n-  for (uint32_t i = 0; i < dds_DataSeq_length(sample_seq); i++) {\n-    GurumddsMessage msg;\n-    msg.sample = dds_DataSeq_get(sample_seq, i);\n-    msg.info = dds_SampleInfoSeq_get(info_seq, i);\n-    msg.size = dds_UnsignedLongSeq_get(size_seq, i);\n-    subscriber_info->message_queue.push(std::move(msg));\n-  }\n-  subscriber_info->queue_mutex.unlock();\n-\n-  // return loan manually after deserialization\n-  // or before destruction of the queue using free()\n-  dds_DataSeq_delete(sample_seq);\n-  dds_SampleInfoSeq_delete(info_seq);\n-  dds_UnsignedLongSeq_delete(size_seq);\n-}\n-",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b9a187db38a55045777ce60f48a89c64af587fd7",
    "RawMessage": "Update code about build error on windows",
    "Changes": "+#if defined(_MSC_VER)\n+#include <BaseTsd.h>\n+typedef SSIZE_T ssize_t;\n+#endif\n+\n+RMW_GURUMDDS_SHARED_CPP_PUBLIC\n+RMW_GURUMDDS_SHARED_CPP_PUBLIC",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "894ab122f63123e40a0df8d643cbcde6835ccfde",
    "RawMessage": "tf2_kdl: add python_orocos_kdl_vendor dependency (#745)",
    "Changes": "-  find_package(tf2_msgs REQUIRED)\n+  <exec_depend>python_orocos_kdl_vendor</exec_depend>\n-  <test_depend>tf2_msgs</test_depend>",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "250a221b8996277aa91966cde2b6cfbe8429634a",
    "RawMessage": "Add tests take serialized with info bad arguments (#130)",
    "Changes": "+      TIMEOUT 80\n+TEST_F(\n+  CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION),\n+  take_serialized_with_info_with_bad_args) {\n+  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  bool taken = false;\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  rmw_message_info_t message_info = rmw_get_zero_initialized_message_info();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n+\n+  rmw_ret_t ret = rmw_take_serialized_message_with_info(\n+    nullptr, &serialized_message, &taken,\n+    &message_info, null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_take_serialized_message_with_info(\n+    sub, nullptr, &taken, &message_info,\n+    null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_take_serialized_message_with_info(\n+    sub, &serialized_message, nullptr, &message_info,\n+    null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_take_serialized_message_with_info(\n+    sub, &serialized_message, &taken, nullptr,\n+    null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  const char * implementation_identifier = sub->implementation_identifier;\n+  sub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_take_serialized_message_with_info(\n+    sub, &serialized_message, &taken, &message_info,\n+    null_allocation);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  sub->implementation_identifier = implementation_identifier;\n+\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) << rmw_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclcpp",
    "SHA": "07b6ea0ff4f2e5c29dab9b068814576343122f56",
    "RawMessage": "Declare parameters uninitialized (#1673)",
    "Changes": "-/// Thrown when a parameter override wasn't provided and one was required.\n-class NoParameterOverrideProvided : public std::runtime_error\n+/// Thrown when an uninitialized parameter is accessed.\n+class ParameterUninitializedException : public std::runtime_error\n-  explicit NoParameterOverrideProvided(const std::string & name)\n-  : std::runtime_error(\"parameter '\" + name + \"' requires an user provided parameter override\")\n+  explicit ParameterUninitializedException(const std::string & name)\n+  : std::runtime_error(\"parameter '\" + name + \"' is not initialized\")\n+  // If there is no initial value, then skip initialization\n+  if (initial_value->get_type() == rclcpp::PARAMETER_NOT_SET) {\n+    // Add declared parameters to storage (without a value)\n+    parameter_infos[name].descriptor.name = name;\n+    if (parameter_descriptor.dynamic_typing) {\n+      parameter_infos[name].descriptor.type = rclcpp::PARAMETER_NOT_SET;\n+    } else {\n+      parameter_infos[name].descriptor.type = parameter_descriptor.type;\n+    }\n+    parameters_out[name] = parameter_infos.at(name);\n+    rcl_interfaces::msg::SetParametersResult result;\n+    result.successful = true;\n+    return result;\n+  }\n+\n-  if (\n-    rclcpp::PARAMETER_NOT_SET == default_value.get_type() &&\n... [truncated] ...\n+  } else if (parameters_.end() == param_iter) {\n+  } else {\n+    throw rclcpp::exceptions::ParameterUninitializedException(name);\n+    const std::string parameter_name = \"parameter\"_unq;\n-      \"parameter\"_unq, rclcpp::ParameterValue{}, descriptor);\n+      parameter_name, rclcpp::ParameterValue{}, descriptor);\n+    // Does not throw if unset before access\n+    EXPECT_EQ(\n+      rclcpp::PARAMETER_NOT_SET,\n+      node->get_parameter(parameter_name).get_parameter_value().get_type());\n+    auto param = node->declare_parameter(\"integer_override_not_given\", rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n+    // Throws if not set before access\n-      node->declare_parameter(\"integer_override_not_given\", rclcpp::PARAMETER_INTEGER),\n-      rclcpp::exceptions::NoParameterOverrideProvided);\n+      node->get_parameter(\"integer_override_not_given\"),\n+      rclcpp::exceptions::ParameterUninitializedException);\n+  }\n+  {\n+    auto param = node->declare_parameter(\"integer_set_after_declare\", rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n+    auto result = node->set_parameter(rclcpp::Parameter{\"integer_set_after_declare\", 44});\n+    ASSERT_TRUE(result.successful) << result.reason;\n+    auto get_param = node->get_parameter(\"integer_set_after_declare\");\n+    EXPECT_EQ(44, get_param.as_int());",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "0898d191c14d7b84f438c445d4d92d586bd91225",
    "RawMessage": "Improve error message when create_topic fails (#405)",
    "Changes": "+void set_error_message_from_create_topic(dds_entity_t topic)\n+{\n+  assert(topic < 0);\n+  if (DDS_RETCODE_BAD_PARAMETER == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because the function was given\"\n+      \" invalid parameters\");\n+  } else if (DDS_RETCODE_INCONSISTENT_POLICY == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because it's already in use\"\n+      \" in this context with incompatible QoS settings\");\n+  } else if (DDS_RETCODE_PRECONDITION_NOT_MET == topic) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to create topic because it's already in use\"\n+      \" in this context with a different message type\");\n+  } else {\n+    RMW_SET_ERROR_MSG(\"failed to create topic for unknown reasons\");\n+  }\n+}\n+\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(topic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(topic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(pubtopic);\n-    RMW_SET_ERROR_MSG(\"failed to create topic\");\n+    set_error_message_from_create_topic(subtopic);",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "edb63764c39993645fd6bc7e0fc31ed7316f0b45",
    "RawMessage": "Fix url in setup.py (#413)",
    "Changes": "-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch/tree/master/ros2launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7734acbeaca4e86aaddb91fb23f725a9ffcd4361",
    "RawMessage": "Update README.md",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+[Installation guide](https://docs.ros.org/en/humble/Installation/DDS-Implementations/Working-with-GurumNetworks-GurumDDS.html) is available.\n-For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+If GurumDDS is normally installed through the debian package, `GURUMDDS_HOME` will be set automatically.\n+For example, if `GURUMDDS_HOME=~/gurumdds` is set, the directory `~/gurumdds` will be:\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dds.h\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n-\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n-    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumidl\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation. For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=$GURUMDDS_HOME/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`. If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`. This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n-There are four active branches in this project: master, humble, galactic and foxy.\n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n-If you want to use this project with ROS2 Rolling Ridley, Galactic Geochelone or Foxy Fitzroy, please use master, galactic or foxy branch, respectively.\n+There are three active branches in this project: master, humble and foxy.  \n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n+If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "28b1c293ff7d9667e23e9789bb1caf3bd06a751b",
    "RawMessage": "Zero initialize events an size_of_events members of rcl_wait_set_t (#841)",
    "Changes": "+    .events = NULL,\n+    .size_of_events = 0,",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "c8ffbfd5713463b314c4b4ea825e139bd29e806d",
    "RawMessage": "Quiet a warning when CONNEXTDDS_DIR or NDDSHOME is not found. (#158)",
    "Changes": "-            message(WARNING \"no CONNEXTDDS_DIR nor NDDSHOME specified\")\n+            message(STATUS \"no CONNEXTDDS_DIR nor NDDSHOME specified\")",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "5c1f0d9f4512eba3d074c94972ae3ca7294dc7ea",
    "RawMessage": "Fixed crash when changing rendering parameters for pointcloud2 while 'Selectable' box is unchecked (#768)",
    "Changes": "-    cloud_info->selection_handler_->setBoxSize(getSelectionBoxSize());\n+    if (cloud_info->selection_handler_) {\n+      cloud_info->selection_handler_->setBoxSize(getSelectionBoxSize());\n+    }",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw",
    "SHA": "c71e97a670717cbf755627723a6d7ef5d756c4f4",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#307)",
    "Changes": "-`rmw` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rmw` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rmw` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rmw` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-`rmw` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rmw` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-A description of how coverage statistics are summarized from this page can be found in the [ROS 2 On-boarding Guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A description of how coverage statistics are summarized from this page can be found in the [ROS 2 On-boarding Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rmw` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rmw` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rmw` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rmw` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "fd4604e5cc4a35911da8b8c90a9a41cb2abad0c1",
    "RawMessage": "Reorganize package",
    "Changes": "-This project requires `rosidl_typesupport_gurumdds` to be built. For more information, see README.md of the [project](https://github.com/ros2/rosidl_typesupport_gurumdds).\n+| 3.2.0  or higher         | 2.8.3140 or higher          |\n-This project consists of four packages, `rmw_gurumdds_cpp`, `rmw_gurumdds_static_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+This project consists of four packages, `gurumdds_camke_module`, `rmw_gurumdds_cpp`, `rmw_gurumdds_shared_cpp` and `demo_nodes_cpp_native_gurumdds`.\n+\n+### gurumdds_cmake_module\n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+```\n+gurumdds\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 include\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcps.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dcpsx.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 typesupport.h\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 xml.h\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n+\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n... [truncated] ...\n-      dds_DataReader_get_requested_incompatible_qos_status(topic_reader, &status);\n-    rmw_ret_t rmw_ret = check_dds_ret_code(dds_ret);\n-    if (rmw_ret != RMW_RET_OK) {\n-      return rmw_ret;\n-    }\n-\n-    auto rmw_status = static_cast<rmw_requested_qos_incompatible_event_status_t *>(event);\n-    rmw_status->total_count = status.total_count;\n-    rmw_status->total_count_change = status.total_count_change;\n-    rmw_status->last_policy_kind = convert_qos_policy(status.last_policy_id);\n-  } else {\n-    return RMW_RET_UNSUPPORTED;\n-  }\n-  return RMW_RET_OK;\n-}\n-\n-dds_StatusCondition * GurumddsSubscriberInfo::get_statuscondition()\n-{\n-  return dds_DataReader_get_statuscondition(topic_reader);\n-}\n-\n-dds_StatusMask GurumddsSubscriberInfo::get_status_changes()\n-{\n-  return dds_DataReader_get_status_changes(topic_reader);\n-}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "74b3fbfcc01209ab099caf2811a20da639525bbc",
    "RawMessage": "Do not use event handler for loading composable nodes (#170)",
    "Changes": "-from launch.actions import RegisterEventHandler\n-from launch.event_handlers.on_process_start import OnProcessStart\n-                RegisterEventHandler(\n-                    event_handler=OnProcessStart(\n-                        target_action=self,\n-                        on_start=[\n-                            LoadComposableNodes(\n-                                composable_node_descriptions=self.__composable_node_descriptions,\n-                                target_container=self\n-                            )\n-                        ]\n-                    )\n+                LoadComposableNodes(\n+                    composable_node_descriptions=self.__composable_node_descriptions,\n+                    target_container=self\n+# Copyright 2020 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n... [truncated] ...\n+    \"\"\"\n+    actions = [\n+        GroupAction([\n+            DeclareLaunchArgument(name='test_arg', default_value='True'),\n+            ComposableNodeContainer(\n+                package='rclcpp_components',\n+                executable='component_container',\n+                name=TEST_CONTAINER_NAME,\n+                namespace=TEST_CONTAINER_NAMESPACE,\n+                composable_node_descriptions=[\n+                    ComposableNode(\n+                        package='composition',\n+                        plugin='composition::Listener',\n+                        name=TEST_NODE_NAME,\n+                        namespace=TEST_NODE_NAMESPACE,\n+                        parameters=[{'use_sim_time': LaunchConfiguration('test_arg')}],\n+                    )\n+                ],\n+            ),\n+        ], scoped=True),\n+    ]\n+\n+    context = _assert_launch_no_errors(actions)\n+    assert get_node_name_count(context, f'/{TEST_CONTAINER_NAMESPACE}/{TEST_CONTAINER_NAME}') == 1\n+    assert get_node_name_count(context, f'/{TEST_NODE_NAMESPACE}/{TEST_NODE_NAME}') == 1",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "9517aaca9e8cc4aa8fa0e34aa302d36f67073121",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#523)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @eboasson @ivanpauno",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "dd7073f94d956baa044094e4c3a8acd811c4cecb",
    "RawMessage": "refactor #116 remove callback_type (#154) (#164)",
    "Changes": "-**rclc_executor_add_subscription(rclc_executor_t * executor, rcl_subscription_t * subscription, void * msg, rclc_callback_t callback, rclc_executor_handle_invocation_t invocation)**\n+**rclc_executor_add_subscription(rclc_executor_t * executor, rcl_subscription_t * subscription, void * msg, rclc_subscription_callback_t callback, rclc_executor_handle_invocation_t invocation)**\n-  rclc_callback_t callback,\n+  rclc_subscription_callback_t callback,\n+  SUBSCRIPTION_WITH_CONTEXT,\n+  // TIMER_WITH_CONTEXT,  // TODO\n+  CLIENT_WITH_REQUEST_ID,\n+  // CLIENT_WITH_CONTEXT,  // TODO\n+  SERVICE_WITH_REQUEST_ID,\n+  SERVICE_WITH_CONTEXT,\n+  // GUARD_CONDITION_WITH_CONTEXT,  //TODO\n-typedef enum\n-{\n-  CB_UNDEFINED,\n-  CB_WITHOUT_REQUEST_ID,\n-  CB_WITH_REQUEST_ID,\n-  CB_WITH_CONTEXT,\n-} rclc_executor_handle_callback_type_t;\n-\n-\n-/// Type definition for callback function.\n-typedef void (* rclc_callback_t)(const void *);\n-\n-// typedef void (* rclc_subscription_callback_t)(const void *);\n+typedef void (* rclc_subscription_callback_t)(const void *);\n... [truncated] ...\n+          // rclc_executor_handle_get_ptr returns null for unsupported types\n+          return false;\n+        }\n+        if (obj == handle_obj_ptr) {\n+          return true;\n-  handle->callback = NULL;\n+  handle->subscription_callback = NULL;\n-  handle->callback_type = CB_UNDEFINED;\n+    case SUBSCRIPTION_WITH_CONTEXT:\n+      // case TIMER_WITH_CONTEXT:\n+    case CLIENT_WITH_REQUEST_ID:\n+      // case CLIENT_WITH_CONTEXT:\n+    case SERVICE_WITH_REQUEST_ID:\n+    case SERVICE_WITH_CONTEXT:\n+      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case SUBSCRIPTION_WITH_CONTEXT:\n+      // case TIMER_WITH_CONTEXT:\n+    case CLIENT_WITH_REQUEST_ID:\n+      // case CLIENT_WITH_CONTEXT:\n+    case SERVICE_WITH_REQUEST_ID:\n+    case SERVICE_WITH_CONTEXT:\n+      // case GUARD_CONDITION_WITH_CONTEXT:\n+    case NONE:\n-  EXPECT_EQ(handle.callback, nullptr);\n+  EXPECT_EQ(handle.subscription_callback, nullptr);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "403bef46b2e91936d454ad79718417085cd0319a",
    "RawMessage": "Fix use of deprecated is_loan_available (#336)",
    "Changes": "-    is_fixed_type && is_loan_available(pub->enth);\n+    is_fixed_type && dds_is_loan_available(pub->enth);\n-    is_fixed_type && is_loan_available(sub->enth);\n+    is_fixed_type && dds_is_loan_available(sub->enth);",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "01c90fa5ca46e941e246876fdbabd10b7b100af7",
    "RawMessage": "Better document parameter handling in Node (#234)",
    "Changes": "-        Multiple dictionaries/files can be passed: each file path will be\n-        passed in in order to the node (where the last definition of a\n-        parameter takes effect).\n+        Multiple parameter dictionaries/files can be passed: each file path\n+        will be passed in in order to the node (where the last definition of\n+        a parameter takes effect).\n+        However, fully qualified node names override wildcards even when\n+        specified earlier.\n+        If `namespace` is not specified, dictionaries are prefixed by a\n+        wildcard namespace (`/**`) and other specific parameter declarations\n+        may overwrite it.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rcutils",
    "SHA": "c49b41c9b19ae9e76e746db662285fc6c7d3b1af",
    "RawMessage": "Change syntax __VAR_ARGS__ to __VA_ARGS__ (#376)",
    "Changes": "-#define my__has_feature(...) __has_feature(__VAR_ARGS__)\n+#define my__has_feature __has_feature\n-#define my__has_feature(...) 0\n+#define my__has_feature(x) 0",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "4b8483886bd3aaf798fcdadf140ff5e9e5165070",
    "RawMessage": "Remove 'efficient copy' prints (#625)",
    "Changes": "-        print(\"efficient copy\")\n-            print(\"deep copy\")\n-        print(\"message copy\")",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b144b3fa899a26e79aab0a2d26cf0f24f79738ee",
    "RawMessage": "Remove dds_typesupport from Publisher/Subscriber Info",
    "Changes": "-  dds_TypeSupport * dds_typesupport;\n-  dds_TypeSupport * dds_typesupport;\n-  publisher_info->dds_typesupport = dds_typesupport;\n+  dds_TypeSupport_delete(dds_typesupport);\n+  dds_typesupport = nullptr;\n+\n-    if (publisher_info->dds_typesupport != nullptr) {\n-      dds_TypeSupport_delete(publisher_info->dds_typesupport);\n-      publisher_info->dds_typesupport = nullptr;\n-    }\n-\n-  subscriber_info->dds_typesupport = dds_typesupport;\n+  dds_TypeSupport_delete(dds_typesupport);\n+  dds_typesupport = nullptr;\n+",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "1b522035780abf6568070c4a3dca9efc3ca49d45",
    "RawMessage": "use only True to avoid confusion in autodoc config",
    "Changes": "-    'members': None,\n-    'undoc-members': True,\n+    'members': True,  # document members\n+    'undoc-members': True,  # also document members without documentation",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "9a144bf040fb8c74058c6b4fd9830fd0e0e3594e",
    "RawMessage": "Check if Task(Future) is canceled. (#1377)",
    "Changes": "-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):\n-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):\n+                    # Get rid of any tasks that are cancelled\n+                    self._tasks = list(filter(lambda t_e_n: not t_e_n[0].cancelled(), self._tasks))\n+from enum import Enum\n+class FutureState(Enum):\n+    \"\"\"States defining the lifecycle of a future.\"\"\"\n+\n+    PENDING = 'PENDING'\n+    CANCELLED = 'CANCELLED'\n+    FINISHED = 'FINISHED'\n+\n+\n... [truncated] ...\n+\n+    def test_set_result_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertFalse(f.done())\n+        f.set_result(None)\n+        self.assertTrue(f.done())\n+\n+    def test_set_exception_on_done_future_without_exception(self) -> None:\n+        f = Future()\n+        f.set_result(None)\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        f.set_result(None)\n+        self.assertIsNotNone(f.exception())\n+\n+    def test_set_exception_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        self.assertIsNotNone(f.exception())\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "9599dd488d543671121c40df9aec5533064e86fb",
    "RawMessage": "Added TwistStamped and AccelStamped default plugins (#991)",
    "Changes": "+  include/rviz_default_plugins/displays/accel/accel_display.hpp\n+  include/rviz_default_plugins/displays/screw/screw_display.hpp\n+  include/rviz_default_plugins/displays/twist/twist_display.hpp\n+  src/rviz_default_plugins/displays/accel/accel_display.cpp\n+  src/rviz_default_plugins/displays/screw/screw_display.cpp\n+  src/rviz_default_plugins/displays/twist/twist_display.cpp\n+  ament_add_gtest(accel_display_visual_test\n+    test/rviz_default_plugins/displays/accel/accel_display_visual_test.cpp\n+    test/rviz_default_plugins/page_objects/accel_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET accel_display_visual_test)\n+    target_include_directories(accel_display_visual_test PRIVATE test)\n+    target_link_libraries(accel_display_visual_test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ${geometry_msgs_TARGETS}\n+      ${std_msgs_TARGETS}\n+      rclcpp::rclcpp\n+    )\n+  endif()\n+\n+  ament_add_gtest(twist_display_visual_test\n+    test/rviz_default_plugins/displays/twist/twist_display_visual_test.cpp\n+    test/rviz_default_plugins/page_objects/twist_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n... [truncated] ...\n+    arrows[1]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(0, 0, 0)));\n+  EXPECT_THAT(\n+    arrows[2]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(0, 0, 0)));\n+\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+  EXPECT_THAT(\n+    arrows[1]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+  EXPECT_THAT(\n+    arrows[2]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.707107f, 0.707107f, 0.0f, 0.0f)));\n+\n+  screw_visual->setLinearScale(1);\n+  screw_visual->setAngularScale(2);\n+  screw_visual->setScrew(Ogre::Vector3(1, 1, 1), Ogre::Vector3(1, 1, 1));\n+  linear_arrow = findLinearArrow(root_node);\n+  EXPECT_THAT(linear_arrow->getScale(), Vector3Eq(Ogre::Vector3(0.0f, 1.73205f, 0.0f)));\n+\n+  angular_arrow = findAngularArrow(root_node);\n+  EXPECT_THAT(angular_arrow->getScale(), Vector3Eq(Ogre::Vector3(0.0f, 3.4641f, 0.0f)));\n+}",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "23bb3671f6ccfeb28a1e34badbc64aba0d5f636e",
    "RawMessage": "Make the types explicit in quaternion_helper.hpp. (#625)",
    "Changes": "-#include <algorithm>\n-  auto product = first * Ogre::Quaternion(second.w, -second.x, -second.y, -second.z);\n-  auto imaginary_norm = sqrt(pow(product.x, 2) + pow(product.y, 2) + pow(product.z, 2));\n+  Ogre::Quaternion product = first * Ogre::Quaternion(second.w, -second.x, -second.y, -second.z);\n+  float imaginary_norm =\n+    sqrtf(powf(product.x, 2.0f) + powf(product.y, 2.0f) + powf(product.z, 2.0f));\n-  return 2 * atan2(imaginary_norm, sqrt(pow(product.w, 2)));\n+  return 2.0f * atan2f(imaginary_norm, sqrtf(powf(product.w, 2.0f)));",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "dbc240db0b648be0d6b9d1981d9a0b43dcc58067",
    "RawMessage": "Delete frame_locked_markers when reusing marker (#907)",
    "Changes": "+    frame_locked_markers_.erase(marker);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "04fc1d0b27de1209449fe07b8851aec4292a8093",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#124)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "common_interfaces",
    "SHA": "74137fc6971ac7d6420248b4394cca977fb5a887",
    "RawMessage": "Create new messages with all fields needed to define a velocity and transform it  (#240)",
    "Changes": "+  \"msg/VelocityStamped.msg\"\n+# This expresses the timestamped velocity vector of a frame 'body_frame_id' in the reference frame 'reference_frame_id' expressed from arbitrary observation frame 'header.frame_id'.\n+# - If the 'body_frame_id' and 'header.frame_id' are identical, the velocity is observed and defined in the local coordinates system of the body\n+#   which is the usual use-case in mobile robotics and is also known as a body twist.\n+\n+std_msgs/Header header\n+string body_frame_id\n+string reference_frame_id\n+Twist velocity",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "18a7ff0015b90e4297aeadd6881f41f41e506c46",
    "RawMessage": "Add service/client construction/destruction API test coverage. (#138)",
    "Changes": "+\n+    ament_add_gtest(test_service${target_suffix}\n+      test/test_service.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_service${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_service${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n+    )\n+\n+    ament_add_gtest(test_client${target_suffix}\n+      test/test_client.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_client${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_client${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n+    )\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n... [truncated] ...\n+}\n+\n+TEST_F(CLASSNAME(TestServiceUse, RMW_IMPLEMENTATION), destroy_null_service) {\n+  rmw_ret_t ret = rmw_destroy_service(node, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rmw_reset_error();\n+}\n+\n+TEST_F(CLASSNAME(TestServiceUse, RMW_IMPLEMENTATION), destroy_with_node_of_another_impl) {\n+  const char * implementation_identifier = node->implementation_identifier;\n+  node->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  rmw_ret_t ret = rmw_destroy_service(node, srv);\n+  node->implementation_identifier = implementation_identifier;\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n+  rmw_reset_error();\n+}\n+\n+TEST_F(CLASSNAME(TestServiceUse, RMW_IMPLEMENTATION), destroy_service_of_another_impl) {\n+  const char * implementation_identifier = srv->implementation_identifier;\n+  srv->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  rmw_ret_t ret = rmw_destroy_service(node, srv);\n+  srv->implementation_identifier = implementation_identifier;\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n+  rmw_reset_error();\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "da37756ac24abc071784e3095e3611ee0fce5a9e",
    "RawMessage": "Add tests bad type_support implementation (#152)",
    "Changes": "+  rosidl_service_type_support_t * non_const_ts =\n+    const_cast<rosidl_service_type_support_t *>(ts);\n+  const char * typesupport_identifier = non_const_ts->typesupport_identifier;\n+  non_const_ts->typesupport_identifier = \"not-a-typesupport-identifier\";\n+  client = rmw_create_client(node, non_const_ts, service_name, &rmw_qos_profile_default);\n+  EXPECT_EQ(nullptr, client);\n+  rmw_reset_error();\n+  non_const_ts->typesupport_identifier = typesupport_identifier;\n+\n+  rosidl_message_type_support_t * non_const_ts =\n+    const_cast<rosidl_message_type_support_t *>(ts);\n+  const char * typesupport_identifier = non_const_ts->typesupport_identifier;\n+  non_const_ts->typesupport_identifier = \"not-a-typesupport-identifier\";\n+  pub = rmw_create_publisher(node, non_const_ts, topic_name, &rmw_qos_profile_default, &options);\n+  EXPECT_EQ(nullptr, pub);\n+  rmw_reset_error();\n+  non_const_ts->typesupport_identifier = typesupport_identifier;\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) <<\n+    rmw_get_error_string().str;\n+\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n... [truncated] ...\n+  EXPECT_NE(RMW_RET_OK, rmw_serialize(&input_message, non_const_ts, &serialized_message));\n+  rmw_reset_error();\n+\n+  non_const_ts->typesupport_identifier = typesupport_identifier;\n+\n+  rosidl_service_type_support_t * non_const_ts =\n+    const_cast<rosidl_service_type_support_t *>(ts);\n+  const char * typesupport_identifier = non_const_ts->typesupport_identifier;\n+  non_const_ts->typesupport_identifier = \"not-a-typesupport-identifier\";\n+  srv = rmw_create_service(node, non_const_ts, service_name, &rmw_qos_profile_default);\n+  EXPECT_EQ(nullptr, srv);\n+  rmw_reset_error();\n+  non_const_ts->typesupport_identifier = typesupport_identifier;\n+\n+  rosidl_message_type_support_t * non_const_ts =\n+    const_cast<rosidl_message_type_support_t *>(ts);\n+  const char * typesupport_identifier = non_const_ts->typesupport_identifier;\n+  non_const_ts->typesupport_identifier = \"not-a-typesupport-identifier\";\n+  sub = rmw_create_subscription(\n+    node, non_const_ts, topic_name,\n+    &rmw_qos_profile_default, &options);\n+  EXPECT_EQ(nullptr, sub);\n+  rmw_reset_error();\n+  non_const_ts->typesupport_identifier = typesupport_identifier;\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "1c0ea5af6c1d5b3715af9a8029de2e5b03821b03",
    "RawMessage": "added documentation (#301)",
    "Changes": "+# All settings not listed here will use the Doxygen default values.\n+\n+PROJECT_NAME           = \"rclc\"\n+PROJECT_NUMBER         = master\n+PROJECT_BRIEF          = \"RCLC API - C language frontend with convenience functions and Executor based on RCL\"\n+\n+INPUT                  = ./include\n+RECURSIVE              = YES\n+OUTPUT_DIRECTORY       = doc_output\n+\n+SORT_MEMBER_DOCS       = NO\n+\n+GENERATE_LATEX         = NO\n+\n+ENABLE_PREPROCESSING   = YES\n+MACRO_EXPANSION        = YES\n+EXPAND_ONLY_PREDEF     = YES\n+PREDEFINED             += RCLC_PUBLIC=\n+\n+# Tag files that do not exist will produce a warning and cross-project linking will not work.\n+TAGFILES += \"../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/\"\n+# Consider changing \"latest\" to the version you want to reference (e.g. beta1 or 1.0.0)\n+TAGFILES += \"../../../../doxygen_tag_files/rcl.tag=http://docs.ros2.org/latest/api/rcl/\"\n+TAGFILES += \"../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/\"\n+# Uncomment to generate tag files for cross-project linking.\n... [truncated] ...\n+\n+PROJECT_NAME           = \"rclc_parameter\"\n+PROJECT_NUMBER         = master\n+PROJECT_BRIEF          = \"RCLC API - C language frontend for rcl parameters\"\n+\n+INPUT                  = ./include\n+RECURSIVE              = YES\n+OUTPUT_DIRECTORY       = doc_output\n+\n+SORT_MEMBER_DOCS       = NO\n+\n+GENERATE_LATEX         = NO\n+\n+ENABLE_PREPROCESSING   = YES\n+MACRO_EXPANSION        = YES\n+EXPAND_ONLY_PREDEF     = YES\n+PREDEFINED             += RCLC_PARAMETER_PUBLIC=\n+\n+# Tag files that do not exist will produce a warning and cross-project linking will not work.\n+TAGFILES += \"../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/\"\n+# Consider changing \"latest\" to the version you want to reference (e.g. beta1 or 1.0.0)\n+TAGFILES += \"../../../../doxygen_tag_files/rcl.tag=http://docs.ros2.org/latest/api/rcl/\"\n+TAGFILES += \"../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/\"\n+# Uncomment to generate tag files for cross-project linking.\n+GENERATE_TAGFILE = \"../../../../doxygen_tag_files/rclc_parameter.tag\"",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "geometry2",
    "SHA": "eaaa2d6e7859302d0e7f2fd25bd981f5dcdb26ff",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-ros2 action. (#738)",
    "Changes": "-name: Mirror rolling to ros2\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-ros2:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: ros2\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @ahcorde @clalancette",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "47346ef9688039b890ae19c499d4b51587a7305b",
    "RawMessage": "Fixes spin_until_future_complete inside callback (#1316)",
    "Changes": "+    node_added = False\n-        executor.add_node(node)\n+        node_added = executor.add_node(node)\n-        executor.remove_node(node)\n+        if node_added:\n+            executor.remove_node(node)",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "5c1f0d9f4512eba3d074c94972ae3ca7294dc7ea",
    "RawMessage": "Fixed crash when changing rendering parameters for pointcloud2 while 'Selectable' box is unchecked (#768)",
    "Changes": "-    cloud_info->selection_handler_->setBoxSize(getSelectionBoxSize());\n+    if (cloud_info->selection_handler_) {\n+      cloud_info->selection_handler_->setBoxSize(getSelectionBoxSize());\n+    }",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "5007fb592e3b205858b042d0fd63a7ed858fad45",
    "RawMessage": "Duplicated code RobotJoint (#702)",
    "Changes": "+#include \"rviz_default_plugins/robot/robot_link.hpp\"\n-    bool recursive) const;              // True: all descendant links.\n+    bool recursive);              // True: all descendant links.\n+  RobotLink * links_checked_and_unchecked(\n+    int & links_with_geom_checked,\n+    int & links_with_geom_unchecked);\n+  int links_with_geom(\n+    RobotLink * link, int & links_with_geom_checked,\n+    int & links_with_geom_unchecked, int n_args, ...);\n+\n-#include \"rviz_default_plugins/robot/robot_link.hpp\"\n+int RobotJoint::links_with_geom(\n+  RobotLink * link, int & links_with_geom_checked,\n+  int & links_with_geom_unchecked, int n_args, ...)\n+{\n+  va_list arg_ptr;\n+  va_start(arg_ptr, n_args);\n+\n+  for (auto & child_joint_name : link->getChildJointNames()) {\n+    RobotJoint * child_joint = robot_->getJoint(child_joint_name);\n+    if (child_joint) {\n+      int child_links_with_geom;\n+      int child_links_with_geom_checked;\n+      int child_links_with_geom_unchecked;\n+      if (n_args == 1) {\n... [truncated] ...\n+  int & links_with_geom,\n+  int & links_with_geom_checked,\n+  int & links_with_geom_unchecked,\n+  bool recursive)\n+{\n+  links_with_geom = 0;\n+  RobotLink * link = this->links_checked_and_unchecked(\n+    links_with_geom_checked, links_with_geom_unchecked);\n+  if (!link) {\n+    return;\n+  }\n-    for (auto & child_joint_name : link->getChildJointNames()) {\n-      RobotJoint * child_joint = robot_->getJoint(child_joint_name);\n-      if (child_joint) {\n-        int child_links_with_geom;\n-        int child_links_with_geom_checked;\n-        int child_links_with_geom_unchecked;\n-        child_joint->getChildLinkState(\n-          child_links_with_geom, child_links_with_geom_checked,\n-          child_links_with_geom_unchecked, recursive);\n-        links_with_geom_checked += child_links_with_geom_checked;\n-        links_with_geom_unchecked += child_links_with_geom_unchecked;\n-      }\n-    }\n+    this->links_with_geom(link, links_with_geom_checked, links_with_geom_unchecked, 1, recursive);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "bfc0da993048ac81f2e1536d5e00a14722a4f0b9",
    "RawMessage": "Removed doxygen warnings (#712)",
    "Changes": "-EXTRACT_ALL            = YES\n+  /// Pointer to the client implementation\n+  /// Pointer to the event implementation\n+  /// Pointer to the guard condition implementation\n+  /// Pointer to the lexer look ahead2 implementation\n+  /// Pointer to the publisher implementation\n+  /// Pointer to the service implementation\n+  /// Pointer to the subscription implementation\n+  /// Duration in nanoseconds and its source.\n+  /// Callback to fucntion.\n+  /// Threshold to decide when to call the callback.\n+  /// Pointer passed to the callback.\n+  /// Clock type\n+  /// Pointer to get_now function\n+  /// Clock storage\n+  /// Custom allocator used for internal allocations.\n+  /// Nanoseconds of the point in time\n+  /// Clock type of the point in time\n+  /// Number of subscriptions\n+  /// Number of guard_conditions\n+  /// Number of timers\n+  /// Number of clients\n+  /// Number of services\n+  /// Number of events\n-EXTRACT_ALL            = YES\n... [truncated] ...\n+/*\n+ * \\typedef rcl_byte_array_t\n+ */\n+  /// Array with uint8_t values\n+  /// Number of values in the array\n-/// \\typedef rcl_variant_t\n-/// \\brief variant_t stores the value of a parameter\n-/// Only one pointer in this struct will store the value\n+/// variant_t stores the value of a parameter\n+/*\n+ * Only one pointer in this struct will store the value\n+ * \\typedef rcl_variant_t\n+ */\n-/// \\typedef rcl_node_params_t\n-/// \\brief node_params_t stores all the parameters(key:value) of a single node\n+/// node_params_t stores all the parameters(key:value) of a single node\n+/*\n+* \\typedef rcl_node_params_t\n+*/\n-/// \\typedef rcl_params_t\n-/// \\brief params_t stores all the parameters of all nodes of a process\n+/// stores all the parameters of all nodes of a process\n+/*\n+* \\typedef rcl_params_t\n+*/",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "f6a79f63d1c809ee48fa7c995ffd2b02d23944a7",
    "RawMessage": "Update rmw_service_server_is_available doc (#280)",
    "Changes": "+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation\n+ *   identifier does not match this implementation, or",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7734acbeaca4e86aaddb91fb23f725a9ffcd4361",
    "RawMessage": "Update README.md",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+[Installation guide](https://docs.ros.org/en/humble/Installation/DDS-Implementations/Working-with-GurumNetworks-GurumDDS.html) is available.\n-For example, if you set `GURUMDDS_HOME=~/gurumdds`, the directory `~/gurumdds` should look like this:\n+If GurumDDS is normally installed through the debian package, `GURUMDDS_HOME` will be set automatically.\n+For example, if `GURUMDDS_HOME=~/gurumdds` is set, the directory `~/gurumdds` will be:\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.lic\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumdds.yaml\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 examples\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 ...\n+\u0393\u00f6\u00e9       \u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 dds.h\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n-\u0393\u00f6\u00e9   \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-\u0393\u00f6\u00a3\u0393\u00f6\u00c7\u0393\u00f6\u00c7 Makefile\n-\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 tool\n-    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 gurumidl\n+\u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 lib\n+    \u0393\u00f6\u00f6\u0393\u00f6\u00c7\u0393\u00f6\u00c7 libgurumdds.so\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation. For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=$GURUMDDS_HOME/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`. If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`. This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n-There are four active branches in this project: master, humble, galactic and foxy.\n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n-If you want to use this project with ROS2 Rolling Ridley, Galactic Geochelone or Foxy Fitzroy, please use master, galactic or foxy branch, respectively.\n+There are three active branches in this project: master, humble and foxy.  \n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n+If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "565c5080fb2ebd20623f265f8915c7419382a986",
    "RawMessage": "Use timeout object to avoid callback losing in wait_for_ready_callbacks (#1165)",
    "Changes": "+class TimeoutObject:\n+    \"\"\"Use timeout object to save timeout.\"\"\"\n+\n+    def __init__(self, timeout: float):\n+        self._timeout = timeout\n+\n+    @property\n+    def timeout(self):\n+        return self._timeout\n+\n+    @timeout.setter\n+    def timeout(self, timeout):\n+        self._timeout = timeout\n+\n+\n-            timeout_left = timeout_sec\n+            timeout_left = TimeoutObject(timeout_sec)\n-                timeout_left = end - now\n+                timeout_left.timeout = end - now\n-        timeout_sec: Optional[float] = None\n+        timeout_sec: Optional[Union[float, TimeoutObject]] = None\n-        timeout_sec: Optional[float] = None,\n+        timeout_sec: Optional[Union[float, TimeoutObject]] = None,\n-        timeout_nsec = timeout_sec_to_nsec(timeout_sec)\n+        timeout_nsec = timeout_sec_to_nsec(\n... [truncated] ...\n+\n+        async def timer1_callback():\n+            timer1.cancel()\n+            await cli.call_async(Empty.Request())\n+\n+        timer1 = self.node.create_timer(0.5, timer1_callback, callback_group)\n+\n+        count = 0\n+\n+        def timer2_callback():\n+            nonlocal count\n+            count += 1\n+        timer2 = self.node.create_timer(1.5, timer2_callback, callback_group)\n+\n+        executor.add_node(self.node)\n+        future = Future(executor=executor)\n+        executor.spin_until_future_complete(future, 4)\n+\n+        assert count == 2\n+\n+        executor.shutdown()\n+        timer2.destroy()\n+        timer1.destroy()\n+        cli.destroy()\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "fb4b0239954ee9cfe2b757df40fb4ab39fbe6567",
    "RawMessage": "Fix wait allocation cleanup (#770)",
    "Changes": "-__wait_set_clean_up(rcl_wait_set_t * wait_set, rcl_allocator_t allocator)\n+__wait_set_clean_up(rcl_wait_set_t * wait_set)\n-    allocator.deallocate(wait_set->impl, allocator.state);\n+    wait_set->impl->allocator.deallocate(wait_set->impl, wait_set->impl->allocator.state);\n+  // Set context.\n+  wait_set->impl->context = context;\n+  // Set allocator.\n+  wait_set->impl->allocator = allocator;\n-  // Set context.\n-  wait_set->impl->context = context;\n-  // Set allocator.\n-  wait_set->impl->allocator = allocator;\n-  __wait_set_clean_up(wait_set, allocator);\n+  __wait_set_clean_up(wait_set);\n-    __wait_set_clean_up(wait_set, wait_set->impl->allocator);\n+    __wait_set_clean_up(wait_set);\n+    wait_set->Type ## s = NULL; \\",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "8e8a2d9b6b56e232f8b2cf524d11d804ae3a8b7c",
    "RawMessage": "updated table of bloom releases (removed dashing, inserted galactic) (#147)",
    "Changes": "-|Package | Release | amd64 | arm64 | armhf |\n-|:--     |  :--    |  :--  |  :--  | :--   |\n-| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Dashing | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dpr__rclc__ubuntu_bionic_amd64)](https://build.ros2.org/job/Dpr__rclc__ubuntu_bionic_amd64/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc__ubuntu_bionic_arm64__binary)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc__ubuntu_bionic_arm64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc__ubuntu_bionic_armhf__binary/)|\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | |\n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | |\n-|     |     |   |   |    |\n-| [rclc_examples](https://github.com/ros2/rclc/tree/master/rclc_examples) |  Dashing | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_uB64__rclc_examples__ubuntu_bionic_amd64__binary)](https://build.ros2.org/job/Dbin_uB64__rclc_examples__ubuntu_bionic_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc_examples__ubuntu_bionic_arm64__binary&build=8)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc_examples__ubuntu_bionic_arm64__binary/8/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc_examples__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc_examples__ubuntu_bionic_armhf__binary/) |\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | |\n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | |\n-|     |     |   |   |    |\n-| [rclc_lifecycle](https://github.com/ros2/rclc/tree/master/rclc_lifecycle) | Dashing |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary)](https://build.ros2.org/job/Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary/) |\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n-| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n+|Package | Release | amd64 | arm64 | \n+|:--     |  :--    |  :--  |  :--  | \n+| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Gpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n+| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+|     |     |   |   |    \n+| [rclc_examples](https://github.com/ros2/rclc/tree/master/rclc_examples)  \n+| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n+| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n+|     |     |   |   |    \n+| [rclc_lifecycle](https://github.com/ros2/rclc/tree/master/rclc_lifecycle) \n+| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | \n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) |\n+| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | \n+|     |     |   |   |    \n+| [rclc_parameter](https://github.com/ros2/rclc/tree/master/rclc_parameter) \n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary/) |\n+| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary/)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "0084d12983f0e1632d85d8936e8a210e0cfd826c",
    "RawMessage": "catch ExternalShutdownException ros2cli main. (#854)",
    "Changes": "+from rclpy.executors import ExternalShutdownException\n+\n+    except ExternalShutdownException:\n+        rc = signal.SIGTERM",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "c3af8a72fa1f81e5dcd384a9d2912ea244950cfb",
    "RawMessage": "Fix incorrect comparsion on whether parameter type is NOT_SET (#1032)",
    "Changes": "-                if second_arg.value == Parameter.Type.NOT_SET:\n+                if second_arg == Parameter.Type.NOT_SET:\n+        # Declare a parameter with parameter type 'Not Set'\n+        with self.assertRaises(ValueError):\n+            self.node.declare_parameter(\n+                'wrong_parameter_value_type_not_set', Parameter.Type.NOT_SET)\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "eac6a8daab60c9f9bdf6715b241312fb8f170739",
    "RawMessage": "[rolling] updated ros-tooling versions (#289)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.3.0\n+    - uses: ros-tooling/setup-ros@0.3.3\n-    - uses : ros-tooling/action-ros-ci@0.2.4\n+    - uses : ros-tooling/action-ros-ci@0.2.5",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "0e75d8767dd45f8d9c174e1ddb26dda02e1d403f",
    "RawMessage": "Make sure to catch the ROSInterruptException when calling rate.sleep.",
    "Changes": "+            raise ROSInterruptException()\n+def sleep_check_exception(rate):\n+    try:\n+        rate.sleep()\n+    except ROSInterruptException:\n+        # rate.sleep() can raise ROSInterruptException if the context is\n+        # shutdown while it is sleeping.  Just ignore it here.\n+        pass\n+\n+\n-    _thread = threading.Thread(target=rate.sleep, daemon=True)\n+    _thread = threading.Thread(target=sleep_check_exception, args=rate, daemon=True)",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "936a5a045de0fb635d8023f198c44baba3f4058e",
    "RawMessage": "add doc section for Zero Copy Data Sharing. (#718)",
    "Changes": "+* [Enable Zero Copy Data Sharing](#enable-zero-copy-data-sharing)\n+### Enable Zero Copy Data Sharing\n+\n+ROS 2 provides [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) that allows the user application to loan the message memory from the RMW implementation to eliminate the copy between the ROS 2 application and RMW implementation.\n+And Fast DDS `rmw_fastrtps_cpp` provides [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) features to speed up the localhost communication.\n+Taking advantage of these features all together, it provides significant performance improvement to ROS 2 application.\n+\n+By default, `rmw_fastrtps_cpp` tries to use [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) for localhost communication along with network communication if the message data type is a bounded type (a fixed sized data object).\n+\n+To enable [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) with `rmw_fastrtps_cpp`, [Plain Old Data](https://en.wikipedia.org/wiki/Passive_data_structure) is the only requirement to `Iron Irwini` or later.\n+For `Humble Hawksbill`, the following XML file needs to be applied to set Fast-DDS `data_sharing` is explicitly enabled. (see more details for https://github.com/ros2/rmw_fastrtps/pull/568)\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\">\n+\n+  <!-- Default publisher profile -->\n+  <data_writer profile_name=\"default publisher profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_writer>\n+\n+  <data_reader profile_name=\"default subscription profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_reader>\n+</profiles>\n+```\n+",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rcl",
    "SHA": "191d8e5b930ffe6460494362ec7fbddcecf81d67",
    "RawMessage": "Add basic unit tests for refactored functions in rcl_yaml_param_parser (coverage part 1/3) (#771)",
    "Changes": "+  ament_add_gtest(test_namespace\n+    test/test_namespace.cpp\n+    WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\n+  )\n+  if(TARGET test_namespace)\n+    ament_target_dependencies(test_namespace\n+      \"rcutils\"\n+      \"osrf_testing_tools_cpp\"\n+    )\n+    target_link_libraries(test_namespace ${PROJECT_NAME})\n+  endif()\n+\n+  ament_add_gtest(test_node_params\n+    test/test_node_params.cpp\n+    WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\n+  )\n+  if(TARGET test_node_params)\n+    ament_target_dependencies(test_node_params\n+      \"rcutils\"\n+      \"osrf_testing_tools_cpp\"\n+    )\n+    target_link_libraries(test_node_params ${PROJECT_NAME})\n+  endif()\n+\n+  ament_add_gtest(test_parse\n... [truncated] ...\n+  ASSERT_NE(nullptr, src_variant.string_array_value);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_yaml_variant_fini(&src_variant, allocator);\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+  });\n+  *src_variant.string_array_value = rcutils_get_zero_initialized_string_array();\n+  ASSERT_EQ(\n+    RCUTILS_RET_OK, rcutils_string_array_init(src_variant.string_array_value, size, &allocator));\n+  src_variant.string_array_value->size = size;\n+  src_variant.string_array_value->data[0] = rcutils_strdup(\"string1\", allocator);\n+  src_variant.string_array_value->data[1] = rcutils_strdup(\"string2\", allocator);\n+  src_variant.string_array_value->data[2] = rcutils_strdup(\"string3\", allocator);\n+  for (size_t i = 0; i < size; ++i) {\n+    ASSERT_NE(nullptr, src_variant.string_array_value->data[i]);\n+  }\n+  EXPECT_TRUE(rcl_yaml_variant_copy(&dest_variant, &src_variant, allocator));\n+  ASSERT_NE(nullptr, dest_variant.string_array_value);\n+  ASSERT_NE(nullptr, dest_variant.string_array_value->data);\n+  for (size_t i = 0; i < size; ++i) {\n+    SCOPED_TRACE(i);\n+    EXPECT_STREQ(\n+      src_variant.string_array_value->data[i], dest_variant.string_array_value->data[i]);\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "63646690365e8c4a6385be8188a0e9bd2da4513b",
    "RawMessage": "added CI status for iron builds (#377)",
    "Changes": "+| | Iron | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ipr__rclc__ubuntu_jammy_amd64)](https://build.ros2.org/job/Ipr__rclc__ubuntu_jammy_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Ibin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/)|\n+| | Iron | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Ibin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Ibin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary/)  |\n+| | Iron | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Ibin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Ibin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary/)  |\n+| | Iron | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Ibin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Ibin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Ibin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary/)  |",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "abea0e92e3eabfaa1079752d9ac6da352bc590d2",
    "RawMessage": "Fix tf2_geometry_msgs_INCLUDE_DIRS. (#729)",
    "Changes": "+ament_export_include_directories(\"include/${PROJECT_NAME}\")",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "0cfd51c5e677b54c4f46963b37292fb474adc940",
    "RawMessage": "Change to delete only the entities created by the user",
    "Changes": "+  node_info->pub_list.push_back(dds_publisher);\n+\n+    node_info->pub_list.remove(dds_publisher);\n+      node_info->pub_list.remove(dds_publisher);\n+  node_info->sub_list.push_back(dds_subscriber);\n+\n+    node_info->sub_list.remove(dds_subscriber);\n+      node_info->sub_list.remove(dds_subscriber);\n+  std::list<dds_Publisher *> pub_list;\n+  std::list<dds_Subscriber *> sub_list;\n+#include <list>\n+  std::list<dds_Publisher *> publisher_list;\n+  std::list<dds_Subscriber *> subscription_list;\n+  node_info->pub_list = publisher_list;\n+  node_info->sub_list = subscription_list;\n-  dds_ReturnCode_t ret =\n-    dds_DomainParticipant_get_contained_entities(participant, pub_seq, sub_seq, NULL, NULL);\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to get contained entities of the domain participant\");\n-    dds_InstanceHandleSeq_delete(pub_seq);\n-    dds_InstanceHandleSeq_delete(sub_seq);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  int32_t cnt = static_cast<int32_t>(dds_InstanceHandleSeq_length(pub_seq));\n... [truncated] ...\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+      RMW_SET_ERROR_MSG(\"failed to create datawriter sequence\");\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-        dds_InstanceHandleSeq_delete(pub_seq);\n-        dds_InstanceHandleSeq_delete(sub_seq);\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+    node_info->pub_list.pop_front();\n-  dds_InstanceHandleSeq_delete(pub_seq);\n-  cnt = static_cast<int32_t>(dds_InstanceHandleSeq_length(sub_seq));\n-  for (int32_t i = cnt - 1; i >= 0; i--) {\n-    dds_Subscriber * sub =\n-      reinterpret_cast<dds_Subscriber *>(dds_InstanceHandleSeq_remove(sub_seq, i));\n+  while (!node_info->sub_list.empty()) {\n+    dds_Subscriber * sub = node_info->sub_list.front();\n-      RMW_SET_ERROR_MSG(\"failed to create instance handle sequence\");\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+      RMW_SET_ERROR_MSG(\"failed to create datareader sequence\");\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-        dds_InstanceHandleSeq_delete(sub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+    node_info->sub_list.pop_front();\n-  dds_InstanceHandleSeq_delete(sub_seq);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b45b1f7f9c77a2c511a9ef59b9f87c2bcab4cefc",
    "RawMessage": "Support static discovery",
    "Changes": "+  std::string static_discovery_id;\n+  static_discovery_id += namespace_;\n+  static_discovery_id += name;\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n-    participant = dds_DomainParticipantFactory_create_participant(\n-      factory, domain_id, &participant_qos, nullptr, 0);\n+    dds_StringProperty props[] = {\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n+      {nullptr, nullptr},\n+    };\n+    participant = dds_DomainParticipantFactory_create_participant_w_props(\n+      factory, domain_id, &participant_qos, nullptr, 0, props);",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "acf7f2542acd6ffcb59ce3ba75b0f5648d2cc910",
    "RawMessage": "Feature request: check for valid ros context in spin_some (#165)",
    "Changes": "+  if (!rcl_context_is_valid(executor->context)) {\n+    PRINT_RCLC_ERROR(rclc_executor_spin_some, rcl_context_not_valid);\n+    return RCL_RET_ERROR;\n+  }\n+\n-  while (rcl_context_is_valid(executor->context) ) {\n+  while (true) {\n-  while (rcl_context_is_valid(executor->context) ) {\n-    rclc_executor_spin_one_period(executor, period);\n+  rcl_ret_t ret;\n+  while (true) {\n+    ret = rclc_executor_spin_one_period(executor, period);\n+    if (!((ret == RCL_RET_OK) || (ret == RCL_RET_TIMEOUT))) {\n+      RCL_SET_ERROR_MSG(\"rclc_executor_spin_one_period error\");\n+      return ret;\n+    }\n-    // Optional prepare for avoiding allocations during spin\n-    rclc_executor_prepare(&executor);\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n-    rclc_executor_spin(&executor);\n+  rclc_executor_spin(&executor);\n-typedef struct {\n+typedef struct\n+{\n... [truncated] ...\n-    {300,\"baz counting from 300\"},\n+  sub_context_t my_contexts[] = {\n+    {0, \"foo counting from zero\"},\n+    {100, \"bar counting from 100\"},\n+    {300, \"baz counting from 300\"},\n-  for(unsigned int i=0; i<n_topics; i++){\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-    std_msgs__msg__String__init( &( pub_msgs[i] ) );\n+    std_msgs__msg__String__init(&( pub_msgs[i] ) );\n-    snprintf(pub_msgs[i].data.data, pub_msgs[i].data.capacity, \"Hello World! on %s\", topic_names[i]);\n+    snprintf(\n+      pub_msgs[i].data.data, pub_msgs[i].data.capacity, \"Hello World! on %s\",\n+      topic_names[i]);\n-    std_msgs__msg__String__init( &( sub_msgs[i] ) );\n+    std_msgs__msg__String__init(&( sub_msgs[i] ) );\n-  for(unsigned int i=0; i<n_topics; i++){\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-    void* context_void_ptr = (void*) context_ptr;\n+    void * context_void_ptr = (void *) context_ptr;\n-    for(unsigned int i=0;i<n_topics; i++) {\n+    for (unsigned int i = 0; i < n_topics; i++) {\n-  for(unsigned int i=0;i<n_topics; i++) {\n+  for (unsigned int i = 0; i < n_topics; i++) {\n-  for(unsigned int i=0;i<n_topics; i++) {\n+  for (unsigned int i = 0; i < n_topics; i++) {",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcutils",
    "SHA": "5d3cecc8af601c10561f7c17d76eab740bb540ce",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#335)",
    "Changes": "-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories) of the ROS2 developer guide.\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html) of the ROS2 developer guide.\n-`rcutils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning)\n+`rcutils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning)\n-`rcutils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n+`rcutils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process).\n-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n-`rcutils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcutils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcutils` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcutils` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcutils` uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n+`rcutils` uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "62e86b90ad3e67e84c660c11e894fe4ab9b11e41",
    "RawMessage": "Check if the queue is empty before using it",
    "Changes": "+  if (service_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+\n+  if (client_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "c49991e8bfe3cfff15f87da2f04d3ada2c70d58c",
    "RawMessage": "Use DataWriter Qos to configure max_blocking_time on rmw_send_response (#704)",
    "Changes": "+  template<class Rep, class Period>\n-    const eprosima::fastrtps::rtps::GUID_t & guid)\n+    const eprosima::fastrtps::rtps::GUID_t & guid,\n+    const std::chrono::duration<Rep, Period> & max_blocking_time)\n-    if (!wait_for_subscription(guid, std::chrono::milliseconds(100))) {\n+    if (!wait_for_subscription(guid, max_blocking_time)) {\n-    client_present_t ret = listener->check_for_subscription(related_guid);\n+    auto writer_max_blocking_time =\n+      info->response_writer_->get_qos().reliability().max_blocking_time;\n+    auto max_blocking_time =\n+      std::chrono::seconds(writer_max_blocking_time.seconds) +\n+      std::chrono::nanoseconds(writer_max_blocking_time.nanosec);\n+    client_present_t ret = listener->check_for_subscription(related_guid, max_blocking_time);",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "e56a5cc3bdd637af52fae961990f0b9cf3a32839",
    "RawMessage": "Add QD links for dependencies to rmw_fastrtps_dynamic_cpp QD",
    "Changes": "+Check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n-* `fastrtps_cmake_module`\n-* `rcpputils`\n-* `rcutils`\n-* `rmw`\n-* `rmw_dds_common`\n-* `rmw_fastrtps_shared_cpp`\n-* `rosidl_runtime_c`\n-* `rosidl_typesupport_fastrtps_c`\n-* `rosidl_typesupport_fastrtps_cpp`\n+* `fastrtps_cmake_module`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/fastrtps_cmake_module/QUALITY_DECLARATION.md)\n+* `rcpputils`: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n+* `rcutils`: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n+* `rmw`: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n+* `rmw_dds_common`: [QUALITY DECLARATION](https://github.com/ros2/rmw_dds_common/blob/master/rmw_dds_common/QUALITY_DECLARATION.md)\n+* `rmw_fastrtps_shared_cpp`: [QUALITY DECLARATION](https://github.com/ros2/rmw_fastrtps/blob/master/rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md)\n+* `rosidl_runtime_c`: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_runtime_c/QUALITY_DECLARATION.md)\n+* `rosidl_typesupport_fastrtps_c`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_c/QUALITY_DECLARATION.md)\n+* `rosidl_typesupport_fastrtps_cpp`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_cpp/QUALITY_DECLARATION.md)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "e17f2ea368eeeec7211a050b02b208b9a2b8c349",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#169)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @gbiggs",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "5af8896a30311e4b8171864391d3bc2d8b81b611",
    "RawMessage": "Improve the compilation time of rviz_default_plugins (#1007)",
    "Changes": "+  ${geometry_msgs_TARGETS}\n+  image_transport::image_transport\n+  interactive_markers::interactive_markers\n+  laser_geometry::laser_geometry\n+  ${map_msgs_TARGETS}\n+  ${nav_msgs_TARGETS}\n+  rclcpp::rclcpp\n+  rviz_common::rviz_common\n+  rviz_rendering::rviz_rendering\n+  ${sensor_msgs_TARGETS}\n+  tf2::tf2\n+  ${tf2_geometry_msgs_TARGETS}\n+  tf2_ros::tf2_ros\n+  urdf::urdf\n+  ${visualization_msgs_TARGETS}\n+  resource_retriever::resource_retriever\n-ament_target_dependencies(rviz_default_plugins\n-  PUBLIC\n-  geometry_msgs\n-  image_transport\n-  interactive_markers\n-  laser_geometry\n-  map_msgs\n-  nav_msgs\n-  rclcpp\n... [truncated] ...\n-target_link_libraries(rviz_visual_testing_framework\n-  ${visual_tests_target_libaries})\n+target_link_libraries(rviz_visual_testing_framework PUBLIC\n+  ${geometry_msgs_TARGETS}\n+  Qt5::Test\n+  Qt5::Widgets\n+  rclcpp::rclcpp\n+  rcutils::rcutils\n+  rviz_common::rviz_common\n+  rviz_ogre_vendor::OgreMain\n+  rviz_rendering::rviz_rendering\n+  ${std_msgs_TARGETS}\n+  tf2::tf2\n+  tf2_ros::tf2_ros\n+)\n-ament_export_dependencies(Qt5)\n-ament_export_dependencies(rviz_common)\n+ament_export_dependencies(geometry_msgs Qt5 rclcpp rcutils rviz_common rviz_ogre_vendor rviz_rendering std_msgs tf2 tf2_ros)\n+  <depend>geometry_msgs</depend>\n+  <depend>rclcpp</depend>\n+  <depend>rviz_ogre_vendor</depend>\n+  <depend>rviz_rendering</depend>\n+  <depend>std_msgs</depend>\n+  <depend>tf2</depend>\n+  <depend>tf2_ros</depend>",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "44e00ad1af2bcb2b8e36a4e6e7d38da7f827a299",
    "RawMessage": "Add maintainer",
    "Changes": "+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>\n+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>\n+  <maintainer email=\"donghee@gurum.cc\">Donghee Lee</maintainer>",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "49ca20cd968212aef28c2fe766d1e35e716ff715",
    "RawMessage": "Fix data_available reset for timer (backport #215) (#217)",
    "Changes": "-      if (wait_set->timers[handle->index]) {\n-        bool timer_is_ready = false;\n-        rc = rcl_timer_is_ready(handle->timer, &timer_is_ready);\n-        if (rc != RCL_RET_OK) {\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_is_ready);\n-          return rc;\n-        }\n-        // actually this is a unnecessary check: if wait_set.timers[i] is true, then also\n-        // rcl_timer_is_ready() should return true.\n-        if (timer_is_ready) {\n-          handle->data_available = true;\n-        } else {\n-          // this should never happen\n-          handle->data_available = false;\n-          PRINT_RCLC_ERROR(rclc_read_input_data, rcl_timer_should_be_ready);\n-          return RCL_RET_ERROR;\n-        }\n-      }\n+      handle->data_available = (NULL != wait_set->timers[handle->index]);\n+// callback for timer\n+static unsigned int _cbt_cnt = 0;\n+    _cbt_cnt++;\n+TEST_F(TestDefaultExecutor, executor_spin_timer) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+  }\n+\n+  EXPECT_EQ(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "272b79f615322e5e848c68880c2031ec481d656e",
    "RawMessage": "Apply loop to take sequence",
    "Changes": "+  *taken = 0;\n+\n+  // Reset length of output sequences\n+  message_sequence->size = 0;\n+  message_info_sequence->size = 0;\n+\n-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      RMW_GURUMDDS_ID, \"No data on topic %s\", subscription->topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n... [truncated] ...\n-      message_info->received_timestamp = 0;\n-      message_info->publication_sequence_number = sequence_number;\n-      message_info->reception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n-      rmw_gid_t * sender_gid = &message_info->publisher_gid;\n-      sender_gid->implementation_identifier = RMW_GURUMDDS_ID;\n-      memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info->publication_handle, sender_gid->data);\n-      if (ret != dds_RETCODE_OK) {\n-        if (ret == dds_RETCODE_ERROR) {\n-          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+        dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n+          topic_reader, sample_info->publication_handle, sender_gid->data);\n+        if (ret != dds_RETCODE_OK) {\n+          if (ret == dds_RETCODE_ERROR) {\n+            RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+          }\n+          memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      }\n-      (*taken)++;\n+        (*taken)++;\n+      }\n+    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "2a8f23ed1b52ea2355658cce09d7045b955f417a",
    "RawMessage": "Fix a bad bug in fetching the lifecycle transitions. (#1321)",
    "Changes": "+      test/test_lifecycle.py\n-    for (size_t i = 0; i <= state_machine_->transition_map.states_size; ++i) {\n+    for (size_t i = 0; i < state_machine_->transition_map.states_size; ++i) {\n-        'shuttingdown', 'activating', 'deactivating', 'errorprocessing', ''\n+        'shuttingdown', 'activating', 'deactivating', 'errorprocessing'",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "df27babd11d1a655d60ce9c5a4363f79ea8d6cf5",
    "RawMessage": "Makes topic_name a const ref",
    "Changes": "-void set_error_message_from_create_topic(dds_entity_t topic, std::string topic_name)\n+void set_error_message_from_create_topic(dds_entity_t topic, const std::string & topic_name)\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name +\n+    const std::string error_msg = \"failed to create topic [\" + topic_name +\n-    std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";\n+    const std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ab0c67990ea04c68dd18329c0f754ad9e72abd34",
    "RawMessage": "Basic rpc",
    "Changes": "-    int64_t sequence_number = 0;\n+    int32_t sn_high = 0;\n+    uint32_t sn_low = 0;\n-      &sequence_number,\n+      &sn_high,\n+      &sn_low,\n-    request_header->request_id.sequence_number = sequence_number;\n+    request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-    int64_t sequence_number = 0;\n+    int32_t sn_high = 0;\n+    uint32_t sn_low = 0;\n-      &sequence_number,\n+      &sn_high,\n+      &sn_low,\n-      request_header->request_id.sequence_number = sequence_number;\n+      request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-      \"l(name=gurumdds__sequence_number_)\" <<\n-      \"L(name=gurumdds__client_guid_1_)\";\n+      \"L(name=gurumdds__client_guid_1_)\" <<\n+      \"l(name=gurumdds__sequence_number_)\";\n-    buffer << dummy;  // suquence_number\n+    buffer << dummy;  // sequence_number\n+    buffer << dummy;  // padding\n-  const int8_t * client_guid)\n+  const int8_t * client_guid,\n... [truncated] ...\n+  uint32_t * sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-  int64_t * sequence_number,\n+  int32_t * sn_high,\n+  uint32_t * sn_low,\n-    sequence_number,\n-    client_guid\n+    sn_high,\n+    sn_low,\n+    client_guid,\n+    false\n-  int64_t * sequence_number,\n+  int32_t * sn_high,\n+  uint32_t * sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2d3b021246c48ddf6cb642f5466ec173196a5b4b",
    "RawMessage": "Validate complex attributes of 'node' action (#198)",
    "Changes": "+                param.assert_entity_completely_parsed()\n+                param.assert_entity_completely_parsed()\n+            for remap in remappings:\n+                remap.assert_entity_completely_parsed()",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "81619d3d6c2afe4b82a8f5163558cf12d64e20d2",
    "RawMessage": "Removed traces in renderPanel (#777)",
    "Changes": "-  printf(\"in RenderPanel::mouseMoveEvent()\\n\");\n-  printf(\"in RenderPanel::mousePressEvent()\\n\");\n-  printf(\"in RenderPanel::mouseReleaseEvent()\\n\");\n-  printf(\"in RenderPanel::mouseDoubleClickEvent()\\n\");",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e2706c653913179ef1cc6d2ecc783b131320aa78",
    "RawMessage": "Ignore rmw_gurumdds_static_cpp and demo_nodes_cpp_native_gurumdds",
    "Changes": "",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "4d0be32e6c455edbf708003dffb67b11d512c5a6",
    "RawMessage": "Capture `std::bad_alloc` on deserializeROSmessage. (#665)",
    "Changes": "+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;\n+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "3e5e219ebb5f2c7b3da74f5838349a7969676c81",
    "RawMessage": "Parameters fini memory (#253)",
    "Changes": "+  rosidl_runtime_c__String__fini(&parameter_server->event_list.node);\n+\n+  for (size_t i = 0; i < parameter_server->describe_request.names.capacity; i++) {\n+    rosidl_runtime_c__String__fini(&parameter_server->describe_request.names.data[i]);\n+    rosidl_runtime_c__String__fini(&parameter_server->describe_response.descriptors.data[i].name);\n+  }\n+\n+  rcl_interfaces__msg__ParameterDescriptor__Sequence__fini(\n+    &parameter_server->describe_response.descriptors);\n+  rosidl_runtime_c__String__Sequence__fini(&parameter_server->describe_request.names);\n+  rcl_interfaces__srv__DescribeParameters_Response__fini(&parameter_server->describe_response);\n+  rcl_interfaces__srv__DescribeParameters_Request__fini(&parameter_server->describe_request);\n+\n+  for (size_t i = 0; i < parameter_server->get_types_request.names.capacity; i++) {\n+    rosidl_runtime_c__String__fini(&parameter_server->get_types_request.names.data[i]);\n+  }\n+\n+  rosidl_runtime_c__uint8__Sequence__fini(&parameter_server->get_types_response.types);\n+  rosidl_runtime_c__String__Sequence__fini(&parameter_server->get_types_request.names);\n+  rcl_interfaces__srv__GetParameterTypes_Response__fini(&parameter_server->get_types_response);\n+  rcl_interfaces__srv__GetParameterTypes_Request__fini(&parameter_server->get_types_request);\n+\n+  for (size_t i = 0; i < parameter_server->set_request.parameters.capacity; i++) {\n+    rosidl_runtime_c__String__fini(&parameter_server->set_request.parameters.data[i].name);\n+    rosidl_runtime_c__String__fini(&parameter_server->set_response.results.data[i].reason);\n... [truncated] ...\n+    rosidl_runtime_c__String__fini(&parameter_server->get_request.names.data[i]);\n+  }\n+\n+  rcl_interfaces__msg__ParameterValue__Sequence__fini(&parameter_server->get_response.values);\n+  rosidl_runtime_c__String__Sequence__fini(&parameter_server->get_request.names);\n+  rcl_interfaces__srv__GetParameters_Response__fini(&parameter_server->get_response);\n+  rcl_interfaces__srv__GetParameters_Request__fini(&parameter_server->get_request);\n+\n+  for (size_t i = 0; i < parameter_server->list_response.result.names.capacity; i++) {\n+    rosidl_runtime_c__String__fini(&parameter_server->list_response.result.names.data[i]);\n+  }\n+\n+  rosidl_runtime_c__String__Sequence__fini(&parameter_server->list_response.result.names);\n+  rcl_interfaces__srv__ListParameters_Response__fini(&parameter_server->list_response);\n+  rcl_interfaces__srv__ListParameters_Request__fini(&parameter_server->list_request);\n+\n+  for (size_t i = 0; i < parameter_server->parameter_list.capacity; i++) {\n+    rosidl_runtime_c__String__fini(&parameter_server->parameter_list.data[i].name);\n+  }\n+\n+  rcl_interfaces__msg__Parameter__Sequence__fini(&parameter_server->parameter_list);\n+\n+\n+  // Destroy parameter server\n+  ASSERT_EQ(rclc_parameter_server_fini(&param_server, &node), RCL_RET_OK);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "6f9f9f4a97c844e681bbb8b222e44d8f969b9b39",
    "RawMessage": "Add rclc_parameter Quality Declaration (#144)",
    "Changes": "+RCLC_PUBLIC\n+RCLC_PUBLIC\n+RCLC_PUBLIC\n+RCLC_PUBLIC\n+RCLC_PUBLIC\n+RCLC_PUBLIC\n-  printf(\"expected  'spin_period' : %ld ns\\n\", spin_period);\n-  printf(\"actual (%d iterations) : %ld ns\\n\", TC_SPIN_PERIOD_MAX_INVOCATIONS, duration);\n+  printf(\"expected  'spin_period' : %lu ns\\n\", spin_period);\n+  printf(\"actual (%d iterations) : %lu ns\\n\", TC_SPIN_PERIOD_MAX_INVOCATIONS, duration);\n+\n+\n-  PRIVATE \"RCLC_BUILDING_LIBRARY\")\n+  PUBLIC \"RCLC_PARAMETER_BUILDING_LIBRARY\")\n+# this alternative would also work\n+#add_definitions(-DRCLC_PARAMETER_BUILDING_LIBRARY)\n+    rclc\n+This document is a declaration of software quality for the `rclc_parameter` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n+# `rclc_parameter` Quality Declaration\n+\n+The package `rclc_parameter` claims to be in the **Quality Level 2** category when it is used with a **Quality Level 2** middleware.\n+\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n... [truncated] ...\n+|2.v| Documentation policy for change requests | \u0393\u00a3\u00f4 |\n+|3| **Documentation** | --- |\n+|3.i| Per feature documentation | \u0393\u00a3\u00f4 |\n+|3.ii| Per public API item documentation | \u0393\u00a3\u00f4 |\n+|3.iii| Declared License(s) | \u0393\u00a3\u00f4 |\n+|3.iv| Copyright in source files| \u0393\u00a3\u00f4 |\n+|3.v.a| Quality declaration linked to README | \u0393\u00a3\u00f4 |\n+|3.v.b| Centralized declaration available for peer review |\u0393\u00a3\u00f4|\n+|4| Testing | --- |\n+|4.i| Feature items tests | \u0393\u00a3\u00f4 |\n+|4.ii| Public API tests | \u0393\u00a3\u00f4 |\n+|4.iii.a| Using coverage | \u0393\u00a3\u00f4 |\n+|4.iii.a| Coverage policy | \u0393\u00a3\u00f4 |\n+|4.iv.a| Performance tests (if applicable) | x |\n+|4.iv.b| Performance tests policy| x |\n+|4.v.a| Code style enforcement (linters)| \u0393\u00a3\u00f4 |\n+|4.v.b| Use of static analysis tools | \u0393\u00a3\u00f4 |\n+|5| Dependencies | --- |\n+|5.i| Must not have ROS lower level dependencies | \u0393\u00a3\u00f4 |\n+|5.ii| Optional ROS lower level dependencies| \u0393\u00a3\u00f4 |\n+|5.iii| Justifies quality use of non-ROS dependencies |\u0393\u00a3\u00f4|\n+|6| Platform support | --- |\n+|6.i| Support targets Tier1 ROS platforms| \u0393\u00a3\u00f4 |\n+|7| Security | --- |\n+|7.i| Vulnerability Disclosure Policy | \u0393\u00a3\u00f4 |",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "d7748d8cdf1739f635ee14274dfac18b1d1eaf61",
    "RawMessage": "Update service/client construction/destruction API return codes. (#247)",
    "Changes": "-  RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n-  RET_NULL_OR_EMPTYSTR(service_name);\n-  RET_NULL(qos_policies);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(type_supports, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n+  if (0 == strlen(service_name)) {\n+    RMW_SET_ERROR_MSG(\"service_name argument is an empty string\");\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+  RMW_CHECK_ARGUMENT_FOR_NULL(qos_policies, RMW_RET_INVALID_ARGUMENT);\n+  if (!qos_policies->avoid_ros_namespace_conventions) {\n+    int validation_result = RMW_TOPIC_VALID;\n+    rmw_ret_t ret = rmw_validate_full_topic_name(service_name, &validation_result, nullptr);\n+    if (RMW_RET_OK != ret) {\n+      return ret;\n+    }\n+    if (RMW_TOPIC_VALID != validation_result) {\n+      const char * reason = rmw_full_topic_name_validation_result_string(validation_result);\n... [truncated] ...\n+    node->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client,\n+    client->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n-  RET_NULL(service);\n-  RET_WRONG_IMPLID(service);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    service,\n+    service->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "39a2bc39da4f46f8b225bf159ef9c8cad396ba07",
    "RawMessage": "Add nominal test for symbol prefetch() and unload. (#145)",
    "Changes": "+\n+TEST(Functions, nominal_prefetch_and_unload) {\n+  prefetch_symbols();\n+  unload_library();\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclpy",
    "SHA": "2a8f23ed1b52ea2355658cce09d7045b955f417a",
    "RawMessage": "Fix a bad bug in fetching the lifecycle transitions. (#1321)",
    "Changes": "+      test/test_lifecycle.py\n-    for (size_t i = 0; i <= state_machine_->transition_map.states_size; ++i) {\n+    for (size_t i = 0; i < state_machine_->transition_map.states_size; ++i) {\n-        'shuttingdown', 'activating', 'deactivating', 'errorprocessing', ''\n+        'shuttingdown', 'activating', 'deactivating', 'errorprocessing'",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "9250313932c2c7477a982ef0c0cfe5124d3cfddf",
    "RawMessage": "Fix problems when parsing a `Command` `Substitution` as a parameter value (#137)",
    "Changes": "+from typing import TYPE_CHECKING\n+from launch.frontend.type_utils import get_data_type_from_identifier\n+\n-from launch.substitutions import TextSubstitution\n+if TYPE_CHECKING:\n+    from ..descriptions import Parameter\n+\n+\n-        self.__expanded_parameter_files = None  # type: Optional[List[Text]]\n+        self.__expanded_parameter_arguments = None  # type: Optional[List[Tuple[Text, bool]]]\n+        from ..descriptions import ParameterValue\n+\n-                value = param.get_attr('value', data_type=None, optional=True)\n+                type_identifier = param.get_attr('type', data_type=None, optional=True)\n+                data_type = None\n+                if type_identifier is not None:\n+                    data_type = get_data_type_from_identifier(type_identifier)\n+                value = param.get_attr('value', data_type=data_type, optional=True)\n-                    raise RuntimeError('param and value attributes are mutually exclusive')\n+                    raise RuntimeError(\n+                        'nested parameters and value attributes are mutually exclusive')\n+                if data_type is not None and nested_params:\n+                    raise RuntimeError(\n+                        'nested parameters and type attributes are mutually exclusive')\n-                    def normalize_scalar_value(value):\n... [truncated] ...\n+    assert 'param_group1.param14' in param_dict\n+    assert 'param_group1.param15' in param_dict\n-    assert param_dict['param_group1.param3'] == (2, 5, 8)\n-    assert param_dict['param_group1.param4'] == (2, 5, 8)\n+    assert param_dict['param_group1.param3'] == [2, 5, 8]\n+    assert param_dict['param_group1.param4'] == [2, 5, 8]\n-    assert param_dict['param_group1.param6'] == (2., 5., 8.)\n-    assert param_dict['param_group1.param7'] == ('2', '5', '8')\n-    assert param_dict['param_group1.param8'] == (\"'2'\", \"'5'\", \"'8'\")\n-    assert param_dict['param_group1.param9'] == (\"'2'\", \"'5'\", \"'8'\")\n-    assert param_dict['param_group1.param10'] == (\"'asd'\", \"'bsd'\", \"'csd'\")\n-    assert param_dict['param_group1.param11'] == ('asd', 'bsd', 'csd')\n+    assert param_dict['param_group1.param6'] == [2., 5., 8.]\n+    assert param_dict['param_group1.param7'] == ['2', '5', '8']\n+    assert param_dict['param_group1.param8'] == [\"'2'\", \"'5'\", \"'8'\"]\n+    assert param_dict['param_group1.param9'] == [\"'2'\", \"'5'\", \"'8'\"]\n+    assert param_dict['param_group1.param10'] == [\"'asd'\", \"'bsd'\", \"'csd'\"]\n+    assert param_dict['param_group1.param11'] == ['asd', 'bsd', 'csd']\n+    assert param_dict['param_group1.param13'] == '100'\n+    assert param_dict['param_group1.param14'] == [\"'2'\", \"'5'\", \"'8'\"]\n+    assert param_dict['param_group1.param15'] == ['2', '5', '8']\n-    remappings = ld.describe_sub_entities()[2]._Node__remappings\n+    remappings = ld.describe_sub_entities()[3]._Node__remappings\n-    listener_node_action = ld.describe_sub_entities()[3]\n+    listener_node_action = ld.describe_sub_entities()[4]",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "af34503b5f635f23749b82bb0d16ad517a41c3e6",
    "RawMessage": "Fix bug: condition of dw/dr seq delete",
    "Changes": "-    if (dds_InstanceHandleSeq_length(dw_seq) > 1) {\n-      dds_InstanceHandleSeq_delete(dw_seq);\n-      continue;\n-    }\n-\n-    dds_DataWriter * dw = reinterpret_cast<dds_DataWriter *>(dds_InstanceHandleSeq_get(dw_seq, 0));\n-    ret = dds_Publisher_delete_datawriter(pub, dw);\n-    if (ret != dds_RETCODE_OK) {\n-      RMW_SET_ERROR_MSG(\"failed to delete datawriter\");\n-      dds_InstanceHandleSeq_delete(dw_seq);\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-      return RMW_RET_ERROR;\n+    for (uint32_t j = 0; j < dds_InstanceHandleSeq_length(dw_seq); j++) {\n+      dds_DataWriter * dw =\n+        reinterpret_cast<dds_DataWriter *>(dds_InstanceHandleSeq_get(dw_seq, j));\n+      ret = dds_Publisher_delete_datawriter(pub, dw);\n+      if (ret != dds_RETCODE_OK) {\n+        RMW_SET_ERROR_MSG(\"failed to delete datawriter\");\n+        dds_InstanceHandleSeq_delete(dw_seq);\n+        dds_InstanceHandleSeq_delete(pub_seq);\n+        dds_InstanceHandleSeq_delete(sub_seq);\n+      }\n-    if (dds_InstanceHandleSeq_length(dr_seq) > 1) {\n-      dds_InstanceHandleSeq_delete(dr_seq);\n-      continue;\n-    }\n-\n-    dds_DataReader * dr = reinterpret_cast<dds_DataReader *>(dds_InstanceHandleSeq_get(dr_seq, 0));\n-    ret = dds_Subscriber_delete_datareader(sub, dr);\n-    if (ret != dds_RETCODE_OK) {\n-      RMW_SET_ERROR_MSG(\"failed to delete datareader\");\n-      dds_InstanceHandleSeq_delete(dr_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-      return RMW_RET_ERROR;\n+    for (uint32_t j = 0; j < dds_InstanceHandleSeq_length(dr_seq); j++) {\n+      dds_DataReader * dr =\n+        reinterpret_cast<dds_DataReader *>(dds_InstanceHandleSeq_get(dr_seq, j));\n+      ret = dds_Subscriber_delete_datareader(sub, dr);\n+      if (ret != dds_RETCODE_OK) {\n+        RMW_SET_ERROR_MSG(\"failed to delete datareader\");\n+        dds_InstanceHandleSeq_delete(dr_seq);\n+        dds_InstanceHandleSeq_delete(sub_seq);\n+        return RMW_RET_ERROR;\n+      }",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "7723308e7c7f7515590bd709525fd840b4aed254",
    "RawMessage": "Fixed doxygen warnings (#677)",
    "Changes": "- * \\param[out] output_unparsed_indices An allocated array of indices into the original argv array.\n+ * \\param[out] output_unparsed_ros_indices An allocated array of indices into the original argv array.\n- * \\param[in] event_handle event object to take from\n+ * \\param[in] event event object to take from\n- * \\param[out] node_namesspaces struct storing discovered node namespaces\n+ * \\param[out] node_namespaces struct storing discovered node namespaces\n- * \\param[out] node_namesspaces struct storing discovered node namespaces\n+ * \\param[out] node_namespaces struct storing discovered node namespaces\n- * \\param[in] log_str The string to be logged\n+ * \\param[in] format The list of arguments to insert into the formatted log message\n+ * \\param[in] args argument for the string format\n- * \\param[inout] node_options object to be finalized\n+ * \\param[inout] options object to be finalized\n- * \\param[in] args The structure to be deallocated.\n+ * \\param[in] remap The structure to be deallocated.\n+ * \\param[in] topic_name the topic name to be validated, must be null terminated\n+ * \\param[out] validation_result the reason for validation failure, if any\n+ * \\param[out] invalid_index index of violation if the input topic is invalid\n+ * \\param[in] params points to the populated parameter struct\n- * \\param[out] ros_result_response preallocated, zero-initialized, struct where the ROS\n+ * \\param[out] ros_result preallocated, zero-initialized, struct where the ROS\n- * \\param[out] request_header pointer to the cancel response header\n+ * \\param[out] response_header pointer to the cancel response header\n- * \\param[out] cancel_reponse a zero-initialized cancel response struct\n+ * \\param[out] cancel_response a zero-initialized cancel response struct\n+ * \\param[in] wait_set struct where action server services are to be stored\n- * \\param[out] is_status_message `true` if there is a status message ready to take,\n+ * \\param[out] is_status_ready `true` if there is a status message ready to take,\n+ * \\param[in] wait_set struct where action server services are to be stored",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "620912fb31716cd62f8f51d8ad249a576166ad07",
    "RawMessage": "Added benchmark test to rosidl_typesupport_fastrtps_c/cpp (#52)",
    "Changes": "+  find_package(performance_test_fixture REQUIRED)\n+\n+  # Give cppcheck hints about macro definitions coming from outside this package\n+  get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS\n+    performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n+\n+\n+  add_performance_test(benchmark_string_conversions test/benchmark/benchmark_string_conversions.cpp)\n+  if(TARGET benchmark_string_conversions)\n+    target_link_libraries(benchmark_string_conversions ${PROJECT_NAME})\n+  endif()\n+  <test_depend>performance_test_fixture</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n... [truncated] ...\n+}\n+\n+BENCHMARK_F(PerformanceTest, wstring_to_u16string)(benchmark::State & st)\n+{\n+  std::wstring wstring(kSize, '*');\n+\n+  reset_heap_counters();\n+\n+  for (auto _ : st) {\n+    std::u16string u16string;\n+    rosidl_typesupport_fastrtps_cpp::wstring_to_u16string(wstring, u16string);\n+  }\n+}\n+\n+BENCHMARK_F(PerformanceTest, u16string_to_wstring)(benchmark::State & st)\n+{\n+  std::u16string u16string(kSize, '*');\n+\n+  reset_heap_counters();\n+\n+  for (auto _ : st) {\n+    std::wstring wstring;\n+    rosidl_typesupport_fastrtps_cpp::u16string_to_wstring(u16string, wstring);\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "509947378c418c0266d043cf2a266a7daefc458e",
    "RawMessage": "Added build status of bloom-releases for Humble distribution (#291)",
    "Changes": "-Bloom release status of rclc packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic and Rolling.\n+Bloom release status of the packages in [github.com/ros2/rclc/](https://github.com/ros2/rclc) for amd64 and arm64 architectures and ROS 2 distributions Foxy, Galactic, Humble and Rolling.\n-| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Gpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_jammy_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_jammy_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Rbin_uJ64__rclc__ubuntu_jammy_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Rbin_ujv8_uJv8__rclc__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_examples__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_examples__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_lifecycle__ubuntu_jammy_amd64__binary/)|  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_lifecycle__ubuntu_jammy_arm64__binary/) |\n+| | Humble | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary)](https://build.ros2.org/job/Hbin_uJ64__rclc_parameter__ubuntu_jammy_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary)](https://build.ros2.org/job/Hbin_ujv8_uJv8__rclc_parameter__ubuntu_jammy_arm64__binary/) |",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "8dc9f8a5f6f39ba0fc9ec784e6d8f93e70d3a9fa",
    "RawMessage": "Make Axes display use latest transform (#892)",
    "Changes": "-      frame, context_->getClock()->now(), position, orientation))\n+      frame, position, orientation))",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2a1f8ef89daceb85239d1af5664318d176a318c8",
    "RawMessage": "Update rmw_publish() error returns (#239)",
    "Changes": "-  RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n-  RET_NULL(ros_message);\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    publisher, \"publisher handle is null\",\n+    return RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    ros_message, \"ros message handle is null\",\n+    return RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "beeeb3e187414f34d9e91898acf258d7a71e56b5",
    "RawMessage": "Add mock tests, publisher 95% coverage (#732)",
    "Changes": "+  <test_depend>mimick_vendor</test_depend>\n+find_package(mimick_vendor REQUIRED)\n+\n-    LIBRARIES ${PROJECT_NAME}\n+    LIBRARIES ${PROJECT_NAME} mimick\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Original file taken from:\n+// https://github.com/ros2/rcutils/blob/master/test/mocking_utils/patch.hpp\n+\n+#ifndef MOCKING_UTILS__PATCH_HPP_\n+#define MOCKING_UTILS__PATCH_HPP_\n+\n... [truncated] ...\n+        *result = RMW_TOPIC_INVALID_NOT_ABSOLUTE;\n+        return RMW_RET_OK;\n+      });\n+    ret = rcl_publisher_init(&publisher, this->node_ptr, ts, topic_name, &publisher_options);\n+    EXPECT_EQ(RCL_RET_TOPIC_NAME_INVALID, ret) << rcl_get_error_string().str;\n+    rcl_reset_error();\n+  }\n+}\n+\n+// Test mocked fail fini publisher\n+TEST_F(CLASSNAME(TestPublisherFixture, RMW_IMPLEMENTATION), test_mock_publisher_fini_fail) {\n+  rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n+  const rosidl_message_type_support_t * ts =\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n+  constexpr char topic_name[] = \"chatter\";\n+  rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n+  rcl_ret_t ret = rcl_publisher_init(\n+    &publisher, this->node_ptr, ts, topic_name, &publisher_options);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  // Internal rmw failure destroying publisher\n+  auto mock = mocking_utils::patch_and_return(\"lib:rcl\", rmw_destroy_publisher, RMW_RET_ERROR);\n+  ret = rcl_publisher_fini(&publisher, this->node_ptr);\n+  EXPECT_EQ(RCL_RET_ERROR, ret) << rcl_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "geometry2",
    "SHA": "31c537f27dfffc6ebbacb0d03648e73a47ee1e07",
    "RawMessage": "Don't install python tf2_geometry_msgs (#299)",
    "Changes": "-ament_python_install_package(${PROJECT_NAME}\n-     PACKAGE_DIR src/${PROJECT_NAME})\n+# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n+# ament_python_install_package(${PROJECT_NAME}\n+#      PACKAGE_DIR src/${PROJECT_NAME})\n-# TODO (ahcorde) Port python once https://github.com/ros2/orocos_kinematics_dynamics/pull/4 is merged\n+# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2",
    "BackportedTo": "foxy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "5766d5e629c1f6ad8965b07e65968873e1f796b7",
    "RawMessage": "Generate version header using ament_generate_version_header(..) (#1141)",
    "Changes": "+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>\n+find_package(ament_cmake_gen_version_h REQUIRED)\n+ament_generate_version_header(${PROJECT_NAME})\n+\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "cd5ae492e8c5c350e75f2d04fcafc782b232395d",
    "RawMessage": "Add tests take sequence serialized with bad arguments (#129)",
    "Changes": "+#include \"osrf_testing_tools_cpp/scope_exit.hpp\"\n+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_serialized_with_bad_args) {\n+  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  bool taken = false;\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  rmw_serialized_message_t original_message = serialized_message;\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 1lu, &default_allocator)) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) << rmw_get_error_string().str;\n+  });\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &original_message, 1lu, &default_allocator)) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_serialized_message_fini(&original_message)) << rmw_get_error_string().str;\n+  });\n+\n+  rmw_ret_t ret =\n... [truncated] ...\n+  ret = rmw_take_serialized_message(sub, nullptr, &taken, null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(taken, false);\n+  rmw_reset_error();\n+\n+  ret = rmw_take_serialized_message(sub, &serialized_message, nullptr, null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(serialized_message.buffer_length, original_message.buffer_length);\n+  rmw_reset_error();\n+\n+  const char * implementation_identifier = sub->implementation_identifier;\n+  sub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_take_serialized_message(sub, &serialized_message, &taken, null_allocation);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(serialized_message.buffer_length, original_message.buffer_length);\n+  EXPECT_EQ(taken, false);\n+  rmw_reset_error();\n+  sub->implementation_identifier = implementation_identifier;\n+\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) << rmw_get_error_string().str;\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_fini(&original_message)) << rmw_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d930a74491b836bea2e6a8223a95259890676adb",
    "RawMessage": "ros2action: add SIGINT handler to manage cancel request. (#956)",
    "Changes": "+import signal\n+\n+        # install signal handler to cancel the goal on SIGINT\n+        def _sigint_cancel_handler(sig, frame):\n+            nonlocal goal_handle\n+            # Cancel the goal if it's still active\n+            if (goal_handle is not None and\n+                (GoalStatus.STATUS_ACCEPTED == goal_handle.status or\n+                 GoalStatus.STATUS_EXECUTING == goal_handle.status)):\n+                print('Canceling goal...')\n+                cancel_future = goal_handle.cancel_goal_async()\n+                rclpy.spin_until_future_complete(node, cancel_future)\n+\n+                cancel_response = cancel_future.result()\n+\n+                if cancel_response is None:\n+                    raise RuntimeError(\n+                        'Exception while canceling goal: {!r}'.format(cancel_future.exception()))\n+\n+                if len(cancel_response.goals_canceling) == 0:\n+                    raise RuntimeError('Failed to cancel goal')\n+                if len(cancel_response.goals_canceling) > 1:\n+                    raise RuntimeError('More than one goal canceled')\n+                if cancel_response.goals_canceling[0].goal_id != goal_handle.goal_id:\n+                    raise RuntimeError('Canceled goal with incorrect goal ID')\n+                print('Goal canceled.')\n+        signal.signal(signal.SIGINT, _sigint_cancel_handler)\n+\n-        # Cancel the goal if it's still active\n-        if (goal_handle is not None and\n-            (GoalStatus.STATUS_ACCEPTED == goal_handle.status or\n-             GoalStatus.STATUS_EXECUTING == goal_handle.status)):\n-            print('Canceling goal...')\n-            cancel_future = goal_handle.cancel_goal_async()\n-            rclpy.spin_until_future_complete(node, cancel_future)\n-\n-            cancel_response = cancel_future.result()\n-\n-            if cancel_response is None:\n-                raise RuntimeError(\n-                    'Exception while canceling goal: {!r}'.format(cancel_future.exception()))\n-\n-            if len(cancel_response.goals_canceling) == 0:\n-                raise RuntimeError('Failed to cancel goal')\n-            if len(cancel_response.goals_canceling) > 1:\n-                raise RuntimeError('More than one goal canceled')\n-            if cancel_response.goals_canceling[0].goal_id != goal_handle.goal_id:\n-                raise RuntimeError('Canceled goal with incorrect goal ID')\n-            print('Goal canceled.')\n-",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "305ef763b83e42ebddc4802ac788869d178b6e93",
    "RawMessage": "call get_action_interfaces() properly. (#898)",
    "Changes": "-    for package_name, action_names in get_action_interfaces.items():\n+    for package_name, action_names in get_action_interfaces().items():",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "f137db8d5680f11246654474f36be4b408d5d56b",
    "RawMessage": "Fix context cleanup. (#227)",
    "Changes": "+    common.graph_guard_condition = nullptr;\n+    common.pub = nullptr;\n+    common.sub = nullptr;\n+  ppant = 0;\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "a3198b80f8a993ac01501d8e3fbdd76e7aaf92dc",
    "RawMessage": "New flag and code update for its use (#942)",
    "Changes": "+Run `ros2 doctor -ep/--exclude-packages` to exclude package checks or report.\n+\n+\n-def run_checks(*, include_warnings=False) -> Tuple[Set[str], int, int]:\n+def run_checks(*, include_warnings=False, exclude_packages=False) -> Tuple[Set[str], int, int]:\n+\n+    if exclude_packages:\n+        groups = [ep for ep in groups if ep.name != 'PackageCheck']\n+\n-def generate_reports(*, categories=None) -> List[Report]:\n+def generate_reports(*, categories=None, exclude_packages=False) -> List[Report]:\n+\n+    if exclude_packages:\n+        groups = [ep for ep in groups if ep.name != 'PackageReport']\n+\n+        parser.add_argument(\n+            '--exclude-packages', '-ep', action='store_true',\n+            help='Exclude package checks or report.'\n+        )\n+        # Local Variables to reduce code length\n+        iw, ep = (args.include_warnings, args.exclude_packages)\n-            all_reports = generate_reports()\n+            all_reports = generate_reports(exclude_packages=ep)\n-        fail_category, fail, total = run_checks(include_warnings=args.include_warnings)\n+\n+        fail_category, fail, total = run_checks(include_warnings=iw, exclude_packages=ep)",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "a83d8195a16cdcdbd417938cb8d3a30b4c826b12",
    "RawMessage": "Handle missing effort limit in URDF (#1084)",
    "Changes": "+#include <rclcpp/logging.hpp>\n-      joints_[joint_name] = std::make_shared<JointInfo>(joint_name, joints_category_);\n-      joints_[joint_name]->setMaxEffort(limit->effort);\n+      if (limit) {\n+        joints_[joint_name] = std::make_shared<JointInfo>(joint_name, joints_category_);\n+        joints_[joint_name]->setMaxEffort(limit->effort);\n+      } else {\n+        RCLCPP_WARN(\n+          context_->getRosNodeAbstraction().lock()->get_raw_node()->get_logger(),\n+          \"Joint '%s' has no <limit> tag in URDF. Effort plugin needs to know the effort \"\n+          \"limit to determine the size of the corresponding visual marker. \"\n+          \"Effort display for this joint will be inhibited.\", joint_name.c_str());\n+      }",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "ea3675f63b0ce95dc81dc4a4aa3e263a75615c22",
    "RawMessage": "Add new API to set envar while specifying overwrite (#473)",
    "Changes": "+/// Set or un-set a process-scoped environment variable while specifying overwrite behavior.\n+/**\n+ * This function modifies the environment variables for the current process by\n+ * copying given string values into the process' global environment variable\n+ * store.\n+ *\n+ * \\par Thread Safety:\n+ * This function is not thread-safe. Take care not to modify the environment variables while\n+ * another thread might be reading or writing environment variables.\n+ *\n+ * \\par Platform Consistency:\n+ * The behavior when setting a variable to an empty string (`\"\"`) differs\n+ * between platforms. On Windows, the variable is un-set (as if \\p env_value was\n+ * `NULL`), while on other platforms the variable is set to an empty string as\n+ * expected.\n+ *\n+ * \\param[in] env_name Name of the environment variable to modify.\n+ * \\param[in] env_value Value to set the environment variable to, or `NULL` to\n+ *   un-set.\n+ * \\param[in] overwrite If true, the environemnt variable value will not be overwritten\n+ *   if previously set.\n+ * \\return `true` if success, or\n+ * \\return `false` if env_name is invalid or NULL, or\n+ * \\return `false` on failure.\n+ */\n... [truncated] ...\n+ *\n+ * Expected environment variables must be set by the calling code:\n+ *\n+ *   - EMPTY_TEST=\n+ *   - NORMAL_TEST=foo\n+ *\n+ * These are set in the call to `ament_add_gtest()` in the `CMakeLists.txt`.\n+ */\n+TEST(TestEnv, test_set_env_overwrite) {\n+  const char * env;\n+  const char * ret;\n+\n+  // Do not overwrite environment variable if preset if overwrite is set false.\n+  EXPECT_TRUE(rcutils_set_env_overwrite(\"NORMAL_TEST\", \"NewEnvValue\", false));\n+  ret = rcutils_get_env(\"NORMAL_TEST\", &env);\n+  EXPECT_TRUE(NULL == ret);\n+  EXPECT_STREQ(\"foo\", env);\n+\n+  // Overwrite environment variable if present if overwrite is set true.\n+  EXPECT_TRUE(rcutils_set_env_overwrite(\"NORMAL_TEST\", \"NewEnvValue\", true));\n+  ret = rcutils_get_env(\"NORMAL_TEST\", &env);\n+  EXPECT_TRUE(NULL == ret);\n+  EXPECT_STREQ(\"NewEnvValue\", env);\n+}\n+",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "1b4795f57731495c1f69bcb6354bdc36161496d2",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2bbc260b987523b131fd8f5bbc002d5fc9801e0b",
    "RawMessage": "Handle allocation errors during message deserialization (#313)",
    "Changes": "+inline void resize_field(\n+  const rosidl_typesupport_introspection_cpp::MessageMember * member,\n+  void * field,\n+  size_t size)\n+{\n+  if (!member->resize_function) {\n+    throw std::runtime_error(\"unexpected error: resize function is null\");\n+  }\n+\n+  member->resize_function(field, size);\n+}\n+\n+inline void resize_field(\n+  const rosidl_typesupport_introspection_c__MessageMember * member,\n+  void * field,\n+  size_t size)\n+{\n+  if (!member->resize_function) {\n+    throw std::runtime_error(\"unexpected error: resize function is null\");\n+  }\n+\n+  if (!member->resize_function(field, size)) {\n+    throw std::runtime_error(\"unable to resize field\");\n+  }\n+}\n+\n-      member->resize_function(field, size);\n+      resize_field(member, field, size);\n-    GenericCSequence<T>::init(&data, dsize);\n+    if (!GenericCSequence<T>::init(&data, dsize)) {\n+      throw std::runtime_error(\"unable initialize generic sequence\");\n+    }\n-              if (!member->resize_function) {\n-                RMW_SET_ERROR_MSG(\"unexpected error: resize function is null\");\n-                return false;\n-              }\n-              member->resize_function(field, array_size);\n+              resize_field(member, field, array_size);\n+  } catch (std::runtime_error & e) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"rmw_serialize: %s\", e.what());\n+    ok = false;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "7719d6232d4bb489e5e081b909fb35ba60103cdc",
    "RawMessage": "Include required header Scalar.h (#559)",
    "Changes": "+#include \"Scalar.h\"\n+",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b85657b2b52852accbdea1feb4f951f62c67a1be",
    "RawMessage": "Remove sleep from entity creation",
    "Changes": "-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-\n-  std::this_thread::sleep_for(std::chrono::milliseconds(3));\n-",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "ae30f0ba0cea64a13347a90ce4945e4452d7cf37",
    "RawMessage": "`tf2_geometry_msgs`: Fixing covariance transformation in `doTransform<PoseWithCovarianceStamped, TransformStamped>` (#430)",
    "Changes": "+#include <geometry_msgs/msg/transform.hpp>\n+#include <geometry_msgs/msg/pose_with_covariance.hpp>\n+/** \\brief Transform the covariance matrix of a PoseWithCovariance message to a new frame.\n+ * \\param cov_in The covariance matrix to transform.\n+ * \\param transform The transform to apply, as a tf2::Transform structure.\n+ * \\return The transformed covariance matrix.\n+ */\n+inline\n+geometry_msgs::msg::PoseWithCovariance::_covariance_type transformCovariance(\n+  const geometry_msgs::msg::PoseWithCovariance::_covariance_type & cov_in,\n+  const tf2::Transform & transform)\n+{\n+    /**\n+     * To transform a covariance matrix:\n+     * \n+     * \\verbatim[R 0] COVARIANCE [R' 0 ]\n+      [0 R]            [0  R']\\endverbatim\n+     * \n+     * Where:\n+     *         R is the rotation matrix (3x3).\n+     *         R' is the transpose of the rotation matrix.\n+     *         COVARIANCE is the 6x6 covariance matrix to be transformed.\n+     *\n+     * Reference:\n+     *         A. L. Garcia, \u0393\u00c7\u00a3Linear Transformations of Random Vectors,\u0393\u00c7\u00a5 in Probability,\n... [truncated] ...\n+    \n+    return cov_out;\n+}\n+\n+// Forward declaration\n+void fromMsg(const geometry_msgs::msg::Transform& in, tf2::Transform& out);\n+\n-    t_out.pose.covariance = t_in.pose.covariance;\n+\n+    tf2::Transform tf_transform;\n+    fromMsg(transform.transform, tf_transform);\n+    t_out.pose.covariance = transformCovariance(t_in.pose.covariance, tf_transform);\n+  geometry_msgs::msg::PoseWithCovariance::_covariance_type v1_expected_covariance = {\n+    1.0, -2.0, -3.0, 4.0, -5.0, -6.0,\n+    -1.0, 2.0, 3.0, -4.0, 5.0, 6.0,\n+    -1.0, 2.0, 3.0, -4.0, 5.0, 6.0,\n+    1.0, -2.0, -3.0, 4.0, -5.0, -6.0,\n+    -1.0, 2.0, 3.0, -4.0, 5.0, 6.0,\n+    -1.0, 2.0, 3.0, -4.0, 5.0, 6.0\n+  };\n+\n-  EXPECT_EQ(v_simple.pose.covariance, v1.pose.covariance);\n+  EXPECT_EQ(v_simple.pose.covariance, v1_expected_covariance);\n-  EXPECT_EQ(v_advanced.pose.covariance, v1.pose.covariance);\n+  EXPECT_EQ(v_advanced.pose.covariance, v1_expected_covariance);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "e18084fa421fa54a3a6793909d128046b2b5a08e",
    "RawMessage": "Revert \"Raise user handler exception in MultiThreadedExecutor. (#984)\" (#1017)",
    "Changes": "-        :raise RuntimeError: Unexpected failure.\n-        :raise RuntimeError: Unexpected failure.\n-            def handler_wrapper(handler):\n-                handler()\n-                if handler.exception() is not None:\n-                    raise handler.exception()\n-            self._executor.submit(handler_wrapper(handler))\n+            self._executor.submit(handler)\n-        :return: ``True`` if successful, ``False`` otherwise.\n+        :return: ``True`` if succesful, ``False`` otherwise.",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "2d7e96b8e2574faa22085c782e223a054de13e3e",
    "RawMessage": "Tweaks to client.c and subscription.c for cleaner init/fini (#728)",
    "Changes": "+    client->impl = NULL;\n+    client->impl = NULL;\n+    publisher->impl = NULL;\n+    service->impl = NULL;\n+    service->impl = NULL;",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "27b4d4fc30149339da50376acd08893141748aa5",
    "RawMessage": "executor ignore canceled timers (#220)",
    "Changes": "+\n+        // cancled timer are not handled, return success\n+        if (rc == RCL_RET_TIMER_CANCELED) {\n+          rc = RCL_RET_OK;\n+          break;\n+        }\n+\n+TEST_F(TestDefaultExecutor, executor_spin_publisher_timer_cancelled) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  unsigned int expected_msg;\n+\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  _executor_results_init();\n+\n+  rc = rclc_executor_add_subscription(\n+    &executor, &this->sub1, &this->sub1_msg,\n+    &CALLBACK_1, ON_NEW_DATA);\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+\n+  for (unsigned int i = 0; i < TC_SPIN_SOME_PUBLISHED_MSGS; i++) {\n+    rc = rcl_publish(&this->pub1, &this->pub1_msg, nullptr);\n... [truncated] ...\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+    if (i > spin_repeat / 2) {\n+      rc = rcl_timer_cancel(&this->timer1);\n+      EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+    }\n+  }\n+\n+  EXPECT_LT(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "749e5ad831ce0a9ec324b426fa2df24be13d94a4",
    "RawMessage": "Added benchmark test to rcl_logging_spdlog (#52)",
    "Changes": "+  find_package(performance_test_fixture REQUIRED)\n+  # Give cppcheck hints about macro definitions coming from outside this package\n+  get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS\n+    performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n+\n+  add_performance_test(benchmark_logging_interface test/benchmark/benchmark_logging_interface.cpp)\n+  if(TARGET benchmark_logging_interface)\n+    target_link_libraries(benchmark_logging_interface ${PROJECT_NAME})\n+  endif()\n+  <test_depend>performance_test_fixture</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+\n... [truncated] ...\n+    if (ret != RCL_LOGGING_RET_OK) {\n+      st.SkipWithError(rcutils_get_error_string().str);\n+    }\n+  }\n+\n+  ret = rcl_logging_external_shutdown();\n+  if (ret != RCL_LOGGING_RET_OK) {\n+    st.SkipWithError(rcutils_get_error_string().str);\n+  }\n+}\n+\n+BENCHMARK_F(PerformanceTest, logging_initialize_shutdown)(benchmark::State & st)\n+{\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  for (auto _ : st) {\n+    rcl_logging_ret_t ret = rcl_logging_external_initialize(nullptr, allocator);\n+    if (ret != RCL_LOGGING_RET_OK) {\n+      st.SkipWithError(rcutils_get_error_string().str);\n+    }\n+    ret = rcl_logging_external_shutdown();\n+    if (ret != RCL_LOGGING_RET_OK) {\n+      st.SkipWithError(rcutils_get_error_string().str);\n+    }\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "ros2cli",
    "SHA": "d3cfbd7612b5d2707b16da1b900dc772dd88a61c",
    "RawMessage": "ros2 param dump should handle empty list as exception. (#881)",
    "Changes": "+import sys\n+\n-            return '# Parameter not set'\n+            return None\n-                raise RuntimeError(\n+                print(\n-                    f'parameter services for node {node_name.full_name}')\n+                    f'parameter services for node {node_name.full_name}', file=sys.stderr)\n+                return\n-                raise RuntimeError(\n-                    'Exception while calling service of node '\n-                    f\"'{node_name.full_name}': {e}\")\n+                print(\n+                    'Exception while calling list_parameters service of node '\n+                    f\"'{node_name.full_name}': {e}\", file=sys.stderr)\n+                return\n+            if parameter_values is None:\n+                print(\n+                    'Exception while calling get_parameters service of node '\n+                    f\"'{node_name.full_name}': {e}\", file=sys.stderr)\n+                return",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "cb0791d107c3ea12b48b1b996af81172ad034c99",
    "RawMessage": "changelogs",
    "Changes": "+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* Updated a hack to avoid CMake warning with assimp 5.0.1 and older, applying it cross platforms (`#565 <https://github.com/ros2/rviz/issues/565>`_)\n+* Contributors: Dirk Thomas\n+\n+Forthcoming\n+-----------\n+* Changed to not install test header files in rviz_rendering. (`#564 <https://github.com/ros2/rviz/issues/564>`_)\n+* Fixed alphabetical include order (`#563 <https://github.com/ros2/rviz/issues/563>`_)\n+* Changed to avoid trying to moc generate ``env_config.hpp`` file. (`#550 <https://github.com/ros2/rviz/issues/550>`_)\n+* Contributors: Chris Lalancette, Karsten Knese\n+\n+Forthcoming\n+-----------\n+* Changed to not install test header files in rviz_rendering. (`#564 <https://github.com/ros2/rviz/issues/564>`_)\n+* Changed to use a dedicated TransformListener thread. (`#551 <https://github.com/ros2/rviz/issues/551>`_)\n+* Suppressed warnings when building with older Qt versions. (`#562 <https://github.com/ros2/rviz/issues/562>`_)\n+* Restored compatibility with older Qt versions (`#561 <https://github.com/ros2/rviz/issues/561>`_)\n+* Contributors: Chris Lalancette, Dirk Thomas, ymd-stella\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* Changed to not install test header files in rviz_rendering. (`#564 <https://github.com/ros2/rviz/issues/564>`_)\n+* Contributors: Chris Lalancette\n+\n+Forthcoming\n+-----------\n+* Changed to not install test header files in rviz_rendering. (`#564 <https://github.com/ros2/rviz/issues/564>`_)\n+* Contributors: Chris Lalancette\n+\n+Forthcoming\n+-----------\n+",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "d855c90c4b2a9ce63ed0117000aab12b9b12b373",
    "RawMessage": "Handle RMW_DEFAULT_DOMAIN_ID. (#394)",
    "Changes": "+  // No custom handling of RMW_DEFAULT_DOMAIN_ID. Simply use a reasonable domain id.\n-  participantAttrs.rtps.builtin.domainId = static_cast<uint32_t>(domain_id);\n+  participantAttrs.rtps.builtin.domainId =\n+    static_cast<uint32_t>(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);\n-  participantAttrs.domainId = static_cast<uint32_t>(domain_id);\n+  participantAttrs.domainId =\n+    static_cast<uint32_t>(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "5ea1a2a7f3c71fce724fedc6a4f60e2f5c2f1ead",
    "RawMessage": "resolved error in unit test see issue https://github.com/ros2/rclc/issues/230 (#231)",
    "Changes": "-  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);\n+  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);  // input value for context\n+  EXPECT_EQ(srv1_id, (unsigned int) 0);     // output value of context (in callback)\n-  EXPECT_EQ(srv1_ctxt, (unsigned int) 42);  // check context value\n+  EXPECT_EQ(srv1_id, (unsigned int) 42);  // check context value in callback",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "5832b4820f839172d4760f6773919de3cf81574e",
    "RawMessage": "Add rmw_get_serialization_format() smoke test. (#133)",
    "Changes": "+TEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), get_serialization_format) {\n+  const char * serialization_format = rmw_get_serialization_format();\n+  EXPECT_NE(nullptr, serialization_format);\n+  EXPECT_STREQ(serialization_format, rmw_get_serialization_format());\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "94a51147f8509cdf9408a88b9f9023d3653b40da",
    "RawMessage": "Account for alignment on is_plain calculations. (#716)",
    "Changes": "+  size_t last_member_size = 0;\n+    last_member_size = 0;\n+        last_member_size = array_size * sizeof(int8_t);\n+        last_member_size = array_size * sizeof(uint16_t);\n+        last_member_size = array_size * sizeof(uint32_t);\n+        last_member_size = array_size * sizeof(uint64_t);\n-            current_alignment += calculateMaxSerializedSize(sub_members, current_alignment);\n+            size_t curr = calculateMaxSerializedSize(sub_members, current_alignment);\n+            current_alignment += curr;\n+            last_member_size += curr;\n-  return current_alignment - initial_alignment;\n+  size_t ret_val = current_alignment - initial_alignment;\n+  if (last_member_size > 0) {\n+    if (this->is_plain_) {\n+      const auto * last_member = members->members_ + (members->member_count_ - 1);\n+      this->is_plain_ = (last_member->offset_ + last_member_size) == ret_val;\n+    }\n+  }\n+\n+  return ret_val;",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "9138ad7a62cb3719f1d988987386660a9eccde46",
    "RawMessage": "Modify unnecessary code",
    "Changes": "+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-\n-  bool ignore_sample = false;\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  if (!sample_info->valid_data) {\n-    ignore_sample = true;\n-  }\n+  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (!ignore_sample) {\n+  if (sample_info->valid_data) {\n+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n... [truncated] ...\n-      ignore_sample = true;\n-    }\n-\n-    if (!ignore_sample) {\n+    if (sample_info->valid_data) {\n+  const char * topic_name =\n+    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n+\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-\n-  bool ignore_sample = false;\n+  RCUTILS_LOG_DEBUG_NAMED(\n+    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-  if (!sample_info->valid_data) {\n-    ignore_sample = true;\n-  }\n+  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (!ignore_sample) {\n+  if (sample_info->valid_data) {",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "5b99aad816d5e49db22c29e11588fafa4e7365f7",
    "RawMessage": "memmove for overlaping memory (#434)",
    "Changes": "-    memcpy(dst_ptr, src_ptr, array_list->impl->data_size * copy_count);\n+    // If the size of the list is >1 the regions of memory overlap.\n+    // POSIX and C standards are explicit that employing memcpy() with overlapping\n+    // areas produces undefined behavior. The recomendation is to use memmove.\n+    // Reference: https://man7.org/linux/man-pages/man3/memcpy.3.html\n+    memmove(dst_ptr, src_ptr, array_list->impl->data_size * copy_count);\n+TEST_F(ArrayListPreInitTest, remove_success_removes_from_list_with_multiple_items) {\n+  uint32_t data = 22;\n+  size_t index = 0;\n+  size_t size = 0;\n+  rcutils_ret_t ret = RCUTILS_RET_OK;\n+\n+  // Add a few things first so we know the index isn't out of bounds\n+  for (size_t i = 0; i < 3; ++i) {\n+    ret = rcutils_array_list_add(&list, &data);\n+    ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  }\n+\n+  ret = rcutils_array_list_get_size(&list, &size);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  EXPECT_EQ(size, (size_t)3);\n+\n+  ret = rcutils_array_list_remove(&list, index);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  ret = rcutils_array_list_get_size(&list, &size);\n+  ASSERT_EQ(RCUTILS_RET_OK, ret) << rcutils_get_error_string().str;\n+  EXPECT_EQ(size, (size_t)2);\n+}\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "c407416261e73e1130ae1b57a0ec00b2ca76df4f",
    "RawMessage": "Add omitted free",
    "Changes": "+    if (rmw_publisher->topic_name != nullptr) {\n+      rmw_free(const_cast<char *>(rmw_publisher->topic_name));\n+    }",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "05d524a2fe7cbf2a20745dac21f5c5cb2f80e16b",
    "RawMessage": "Add message lost subscription event",
    "Changes": "+    {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "289d7d32117c7ba9d7f2fec58f53f3ee2ed9cf2a",
    "RawMessage": "Bugfix/duration to msg precision (#876)",
    "Changes": "+from rclpy.constants import S_TO_NS\n+    \"\"\"A period between two time points, with nanosecond precision.\"\"\"\n-        total_nanoseconds = int(seconds * 1e9)\n+        \"\"\"\n+        Create an instance of :class:`Duration`, combined from given seconds and nanoseconds.\n+\n+        :param seconds: Time span seconds, if any, fractional part will be included.\n+        :param nanoseconds: Time span nanoseconds, if any, fractional part will be discarded.\n+        \"\"\"\n+        total_nanoseconds = int(seconds * S_TO_NS)\n-        seconds = int(self.nanoseconds * 1e-9)\n-        nanoseconds = int(self.nanoseconds % 1e9)\n+        \"\"\"\n+        Get duration as :class:`builtin_interfaces.msg.Duration`.\n+\n+        :returns: duration as message\n+        :rtype: builtin_interfaces.msg.Duration\n+        \"\"\"\n+        seconds, nanoseconds = divmod(self.nanoseconds, S_TO_NS)\n+        \"\"\"\n+        Create an instance of :class:`Duration` from a duration message.\n+\n+        :param msg: An instance of :class:`builtin_interfaces.msg.Duration`.\n+        \"\"\"",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "08fdf987a6554e5f396b0871bbf94b24c5760e13",
    "RawMessage": "Set automatically_declare_parameters_from_overrides in DirectNode. (#813)",
    "Changes": "-            ])\n+            ], automatically_declare_parameters_from_overrides=True)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "ef5d8116a4899b069b0cb444b1fdf8e3b1b7b6d4",
    "RawMessage": "Update ros2 param dump dosctring. (#837)",
    "Changes": "-    \"\"\"Dump the parameters of a node to a yaml file.\"\"\"\n+    \"\"\"Show all of the parameters of a node in a YAML file format.\"\"\"",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "2c9c1933af37ae8a502a1c3abf2acf4ea810dc9e",
    "RawMessage": "start the simulation from 1 second for the test. (#975)",
    "Changes": "+import time\n+    def wait_for_command_online(self):\n+        max_seconds_to_wait = 5\n+        end_time = time.time() + max_seconds_to_wait\n+        while self.publisher.get_subscription_count() < 1:\n+            time.sleep(0.1)\n+            assert time.time() <= end_time  # timeout waiting for command online\n+        assert self.publisher.get_subscription_count() >= 1\n+\n-        self.clock_sec = 0\n+\n+        # Start the timer from 1 second, so that 1st message fires event.\n+        self.clock_sec = 1\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "511fc40ca305fe075cd53e0b97176cc7be272d69",
    "RawMessage": "Fix that not to deallocate event impl in some failure case (#790)",
    "Changes": "-  rcl_ret_t ret = RCL_RET_OK;\n-\n-  // Allocate space for the implementation struct.\n-  event->impl = (rcl_event_impl_t *) allocator->allocate(\n-    sizeof(rcl_event_impl_t), allocator->state);\n-  RCL_CHECK_FOR_NULL_WITH_MSG(\n-    event->impl, \"allocating memory failed\", ret = RCL_RET_BAD_ALLOC; return ret);\n-\n-  event->impl->rmw_handle = rmw_get_zero_initialized_event();\n-  event->impl->allocator = *allocator;\n-\n-  return rmw_publisher_event_init(\n+\n+  // Allocate space for the implementation struct.\n+  event->impl = (rcl_event_impl_t *) allocator->allocate(\n+    sizeof(rcl_event_impl_t), allocator->state);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    event->impl, \"allocating memory failed\", return RCL_RET_BAD_ALLOC);\n+\n+  event->impl->rmw_handle = rmw_get_zero_initialized_event();\n+  event->impl->allocator = *allocator;\n+\n+  rmw_ret_t ret = rmw_publisher_event_init(\n+  if (ret != RMW_RET_OK) {\n+    goto fail;\n... [truncated] ...\n-\n-  event->impl->rmw_handle = rmw_get_zero_initialized_event();\n-  event->impl->allocator = *allocator;\n-\n-  return rmw_subscription_event_init(\n+\n+  // Allocate space for the implementation struct.\n+  event->impl = (rcl_event_impl_t *) allocator->allocate(\n+    sizeof(rcl_event_impl_t), allocator->state);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    event->impl, \"allocating memory failed\", return RCL_RET_BAD_ALLOC);\n+\n+  event->impl->rmw_handle = rmw_get_zero_initialized_event();\n+  event->impl->allocator = *allocator;\n+\n+  rmw_ret_t ret = rmw_subscription_event_init(\n+  if (ret != RMW_RET_OK) {\n+    goto fail;\n+  }\n+\n+  return RCL_RET_OK;\n+fail:\n+  allocator->deallocate(event->impl, allocator->state);\n+  event->impl = NULL;\n+  return rcl_convert_rmw_ret_to_rcl_ret(ret);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcutils",
    "SHA": "ea3675f63b0ce95dc81dc4a4aa3e263a75615c22",
    "RawMessage": "Add new API to set envar while specifying overwrite (#473)",
    "Changes": "+/// Set or un-set a process-scoped environment variable while specifying overwrite behavior.\n+/**\n+ * This function modifies the environment variables for the current process by\n+ * copying given string values into the process' global environment variable\n+ * store.\n+ *\n+ * \\par Thread Safety:\n+ * This function is not thread-safe. Take care not to modify the environment variables while\n+ * another thread might be reading or writing environment variables.\n+ *\n+ * \\par Platform Consistency:\n+ * The behavior when setting a variable to an empty string (`\"\"`) differs\n+ * between platforms. On Windows, the variable is un-set (as if \\p env_value was\n+ * `NULL`), while on other platforms the variable is set to an empty string as\n+ * expected.\n+ *\n+ * \\param[in] env_name Name of the environment variable to modify.\n+ * \\param[in] env_value Value to set the environment variable to, or `NULL` to\n+ *   un-set.\n+ * \\param[in] overwrite If true, the environemnt variable value will not be overwritten\n+ *   if previously set.\n+ * \\return `true` if success, or\n+ * \\return `false` if env_name is invalid or NULL, or\n+ * \\return `false` on failure.\n+ */\n... [truncated] ...\n+ *\n+ * Expected environment variables must be set by the calling code:\n+ *\n+ *   - EMPTY_TEST=\n+ *   - NORMAL_TEST=foo\n+ *\n+ * These are set in the call to `ament_add_gtest()` in the `CMakeLists.txt`.\n+ */\n+TEST(TestEnv, test_set_env_overwrite) {\n+  const char * env;\n+  const char * ret;\n+\n+  // Do not overwrite environment variable if preset if overwrite is set false.\n+  EXPECT_TRUE(rcutils_set_env_overwrite(\"NORMAL_TEST\", \"NewEnvValue\", false));\n+  ret = rcutils_get_env(\"NORMAL_TEST\", &env);\n+  EXPECT_TRUE(NULL == ret);\n+  EXPECT_STREQ(\"foo\", env);\n+\n+  // Overwrite environment variable if present if overwrite is set true.\n+  EXPECT_TRUE(rcutils_set_env_overwrite(\"NORMAL_TEST\", \"NewEnvValue\", true));\n+  ret = rcutils_get_env(\"NORMAL_TEST\", &env);\n+  EXPECT_TRUE(NULL == ret);\n+  EXPECT_STREQ(\"NewEnvValue\", env);\n+}\n+",
    "BackportedTo": "jazzy",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclc",
    "SHA": "1c0ea5af6c1d5b3715af9a8029de2e5b03821b03",
    "RawMessage": "added documentation (#301)",
    "Changes": "+# All settings not listed here will use the Doxygen default values.\n+\n+PROJECT_NAME           = \"rclc\"\n+PROJECT_NUMBER         = master\n+PROJECT_BRIEF          = \"RCLC API - C language frontend with convenience functions and Executor based on RCL\"\n+\n+INPUT                  = ./include\n+RECURSIVE              = YES\n+OUTPUT_DIRECTORY       = doc_output\n+\n+SORT_MEMBER_DOCS       = NO\n+\n+GENERATE_LATEX         = NO\n+\n+ENABLE_PREPROCESSING   = YES\n+MACRO_EXPANSION        = YES\n+EXPAND_ONLY_PREDEF     = YES\n+PREDEFINED             += RCLC_PUBLIC=\n+\n+# Tag files that do not exist will produce a warning and cross-project linking will not work.\n+TAGFILES += \"../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/\"\n+# Consider changing \"latest\" to the version you want to reference (e.g. beta1 or 1.0.0)\n+TAGFILES += \"../../../../doxygen_tag_files/rcl.tag=http://docs.ros2.org/latest/api/rcl/\"\n+TAGFILES += \"../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/\"\n+# Uncomment to generate tag files for cross-project linking.\n... [truncated] ...\n+\n+PROJECT_NAME           = \"rclc_parameter\"\n+PROJECT_NUMBER         = master\n+PROJECT_BRIEF          = \"RCLC API - C language frontend for rcl parameters\"\n+\n+INPUT                  = ./include\n+RECURSIVE              = YES\n+OUTPUT_DIRECTORY       = doc_output\n+\n+SORT_MEMBER_DOCS       = NO\n+\n+GENERATE_LATEX         = NO\n+\n+ENABLE_PREPROCESSING   = YES\n+MACRO_EXPANSION        = YES\n+EXPAND_ONLY_PREDEF     = YES\n+PREDEFINED             += RCLC_PARAMETER_PUBLIC=\n+\n+# Tag files that do not exist will produce a warning and cross-project linking will not work.\n+TAGFILES += \"../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/\"\n+# Consider changing \"latest\" to the version you want to reference (e.g. beta1 or 1.0.0)\n+TAGFILES += \"../../../../doxygen_tag_files/rcl.tag=http://docs.ros2.org/latest/api/rcl/\"\n+TAGFILES += \"../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/\"\n+# Uncomment to generate tag files for cross-project linking.\n+GENERATE_TAGFILE = \"../../../../doxygen_tag_files/rclc_parameter.tag\"",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e7bc3bc868e0bc09e6b4225cd1f121e978c26986",
    "RawMessage": "Wrap up unordered_map with shared_ptr",
    "Changes": "+#include <memory>\n-static const std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> mask_map = {\n-  {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n-  {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n-  {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n-  {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n-  {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n-  {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n-  {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n-};\n+static std::shared_ptr<std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>>>\n+g_mask_map_ptr {new std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> {\n+    {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n+    {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n+    {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n+    {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n+    {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n+    {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n+  }};\n-  return mask_map.at(event_t);\n+  auto mask_map_ptr{g_mask_map_ptr};\n+  if (mask_map_ptr == nullptr) {\n+    return 0;\n+  }\n+  return mask_map_ptr->at(event_t);\n-  return mask_map.count(event_t) > 0;\n+  auto mask_map_ptr{g_mask_map_ptr};\n+  if (mask_map_ptr == nullptr) {\n+    return false;\n+  }\n+  return mask_map_ptr->count(event_t) > 0;",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "2c1d4bbec7c51d0c0aa633d52e903d3a89d7f51a",
    "RawMessage": "Add tests publish serialized bad arguments (#124)",
    "Changes": "+TEST_F(\n+  CLASSNAME(TestPublisherUse, RMW_IMPLEMENTATION),\n+  publish_serialized_message_with_bad_arguments) {\n+  rmw_publisher_allocation_t * null_allocation{nullptr};  // still valid allocation\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n+\n+  rmw_ret_t ret = rmw_publish_serialized_message(nullptr, &serialized_message, null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  ret = rmw_publish_serialized_message(pub, nullptr, null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  const char * implementation_identifier = pub->implementation_identifier;\n+  pub->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_publish_serialized_message(pub, &serialized_message, null_allocation);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+  pub->implementation_identifier = implementation_identifier;\n+\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) << rmw_get_error_string().str;\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "c1b3ff72d3d106e322661db3a2702b476eedfe27",
    "RawMessage": "Fix memory leak because of mock test (#800)",
    "Changes": "+  auto mock_ok = mocking_utils::inject_on_return(\"lib:rcl\", rmw_init_options_fini, RMW_RET_OK);\n+  EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(&init_options));\n+  auto mock_ok = mocking_utils::inject_on_return(\"lib:rcl\", rmw_init_options_fini, RMW_RET_OK);\n+  EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(&init_options_dst));\n+    auto mock_ok = mocking_utils::patch_and_return(\"lib:rcl\", rmw_init_options_fini, RMW_RET_OK);\n+    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(&init_options_dst)) << rcl_get_error_string().str;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "f401871f40234613235655445861e6181032a34e",
    "RawMessage": "updated ci versions (#396)",
    "Changes": "-    - uses: ros-tooling/setup-ros@0.6.2\n+    - uses: ros-tooling/setup-ros@0.6.3\n-    - uses : ros-tooling/action-ros-ci@0.3.2\n+    - uses : ros-tooling/action-ros-ci@0.3.5",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ee11c579c03e13ae463618594888a382113afc40",
    "RawMessage": "Use dds_free instead of free for dll library",
    "Changes": "-        free(msg.sample);\n+        dds_free(msg.sample);\n-        free(msg.info);\n+        dds_free(msg.info);\n-      free(msg.info);\n+      dds_free(msg.info);\n-      free(msg.sample);\n-      free(msg.info);\n+      dds_free(msg.sample);\n+      dds_free(msg.info);\n-    free(msg.sample);\n+    dds_free(msg.sample);\n-    free(msg.info);\n+    dds_free(msg.info);\n-      free(msg.info);\n+      dds_free(msg.info);\n-      free(msg.sample);\n-      free(msg.info);\n+      dds_free(msg.sample);\n+      dds_free(msg.info);\n-    free(msg.sample);\n+    dds_free(msg.sample);\n-    free(msg.info);\n+    dds_free(msg.info);\n-        free(msg.sample);\n... [truncated] ...\n+      dds_free(msg.info);\n-    free(msg.sample);\n+    dds_free(msg.sample);\n-    free(msg.info);\n+    dds_free(msg.info);\n-        free(msg.info);\n+        dds_free(msg.info);\n-        free(msg.sample);\n-        free(msg.info);\n+        dds_free(msg.sample);\n+        dds_free(msg.info);\n-      free(msg.sample);\n+      dds_free(msg.sample);\n-      free(msg.info);\n+      dds_free(msg.info);\n-      free(msg.info);\n+      dds_free(msg.info);\n-        free(msg.sample);\n-        free(msg.info);\n+        dds_free(msg.sample);\n+        dds_free(msg.info);\n-    free(msg.sample);\n+    dds_free(msg.sample);\n-    free(msg.info);\n+    dds_free(msg.info);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "1bdd3cea03c5d24a227ac3de7e96b8b8ea5da8e3",
    "RawMessage": "Use absolute parameter events topic name (#612)",
    "Changes": "-            ParameterEvent, 'parameter_events', qos_profile_parameter_events)\n+            ParameterEvent, '/parameter_events', qos_profile_parameter_events)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclc",
    "SHA": "810afe1b84e0bc4ac397662694a1b27ae13d81b7",
    "RawMessage": "added documentation about number_of_handles in all examples. (#341)",
    "Changes": "+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n-  // Optional prepare for avoiding allocations during spin\n-  rclc_executor_prepare(&executor);\n-\n+  // Start Executor\n-  // If you need more than the default number of publisher/subscribers, etc., you \n+  // If you need more than the default number of publisher/subscribers, etc., you\n-  // See documentation in the executor.h at the function rclc_executor_init() \n-  // for more details. \n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n... [truncated] ...\n+    // See documentation in the executor.h at the function rclc_executor_init()\n+    // for more details.\n-  \n-    // Optional prepare for avoiding allocations during spin\n+    // Optional: prepare for avoiding allocations during spin\n-    // rclc_executor_spin(&executor ); end less loop\n-\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.\n-\n+  // Start Executor\n-\n+  // Note:\n+  // If you need more than the default number of publisher/subscribers, etc., you\n+  // need to configure the micro-ROS middleware also!\n+  // See documentation in the executor.h at the function rclc_executor_init()\n+  // for more details.",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "ros2cli",
    "SHA": "a91bbc1b25d1d45e727d430a86d9f05646e71288",
    "RawMessage": "Update minimum CMake version CMakeLists.txt.em (#969)",
    "Changes": "-cmake_minimum_required(VERSION 3.8)\n+cmake_minimum_required(VERSION 3.16)",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl_logging",
    "SHA": "0724aeb90f5d4efd23a75b1a97a4429ec6911a60",
    "RawMessage": "rcl_logging_interface is only valid path with build environment. (#122)",
    "Changes": "-\n+ament_export_dependencies(rcl_logging_interface)\n+ament_export_dependencies(rcl_logging_interface)",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "31d814d1c9e7cbe1bab9180ffb5f101707e02df4",
    "RawMessage": "Adapt tests to Zenoh (#988)",
    "Changes": "+from rclpy.qos import qos_check_compatible\n+from rclpy.qos import QoSCompatibility\n+                        # This QoS profile matched with the extra options defined above\n+                        rostopic_qos_profile = QoSProfile(\n+                            depth=10,\n+                            reliability=ReliabilityPolicy.RELIABLE,\n+                            durability=DurabilityPolicy.TRANSIENT_LOCAL)\n+                        # Skip this test if the QoS between the publisher and subscription\n+                        # are compatible according to the underlying middleware.\n+                        comp, reason = qos_check_compatible(\n+                            rostopic_qos_profile, publisher_qos_profile)\n+                        if comp == QoSCompatibility.OK or comp == QoSCompatibility.WARNING:\n+                            raise unittest.SkipTest()\n+\n+import re\n+from rclpy.qos import qos_check_compatible\n+from rclpy.qos import QoSCompatibility\n+                        # This QoS profile matched with the extra options defined above\n+                        rostopic_qos_profile = QoSProfile(\n+                            depth=10,\n+                            reliability=ReliabilityPolicy.BEST_EFFORT,\n+                            durability=DurabilityPolicy.VOLATILE)\n+                        # Skip this test if the QoS between the publisher and subscription\n+                        # are compatible according to the underlying middleware.\n+                        comp, reason = qos_check_compatible(\n+                            rostopic_qos_profile, subscription_qos_profile)\n+                        if comp == QoSCompatibility.OK:\n+                            raise unittest.SkipTest()\n+                        # This QoS profile matched with the extra options defined above\n+                        rostopic_qos_profile = QoSProfile(\n+                            depth=10,\n+                            reliability=ReliabilityPolicy.RELIABLE,\n+                            durability=DurabilityPolicy.TRANSIENT_LOCAL)\n+                        # Skip this test if the QoS between the publisher and subscription\n+                        # are compatible according to the underlying middleware.\n+                        comp, reason = qos_check_compatible(\n+                            rostopic_qos_profile, publisher_qos_profile)\n+                        if comp == QoSCompatibility.OK or comp == QoSCompatibility.WARNING:\n+                            raise unittest.SkipTest()\n-                        \"b'\\\\x00\\\\x01\\\\x00\\\\x00\\\\x06\\\\x00\\\\x00\\\\x00hello\\\\x00\\\\x00\\\\x00'\",\n-                        '---',\n-                    ], strict=True\n+                        re.compile(r\"^b'\\\\x00\\\\x01\\\\x00\\\\x00\\\\x06\\\\x00\\\\x00\\\\x00hello(\\\\x00)*'$\"),\n+                        re.compile(r'^---$'),\n+                    ], strict=False\n-                        re.compile(r'\\s*Message size mean: 16 B min: 16 B max: 16 B')\n+                        re.compile(\n+                            r'\\s*Message size mean: (14|16) B min: (14|16) B max: (14|16) B')",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "79a2df204ff8f745539d842cf669fadd1dd4ca7e",
    "RawMessage": "Fix rclc lifecyle header (#279) (#281)",
    "Changes": "+#if __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#if __cplusplus\n+}\n+#endif\n+",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "0cfd51c5e677b54c4f46963b37292fb474adc940",
    "RawMessage": "Change to delete only the entities created by the user",
    "Changes": "+  node_info->pub_list.push_back(dds_publisher);\n+\n+    node_info->pub_list.remove(dds_publisher);\n+      node_info->pub_list.remove(dds_publisher);\n+  node_info->sub_list.push_back(dds_subscriber);\n+\n+    node_info->sub_list.remove(dds_subscriber);\n+      node_info->sub_list.remove(dds_subscriber);\n+  std::list<dds_Publisher *> pub_list;\n+  std::list<dds_Subscriber *> sub_list;\n+#include <list>\n+  std::list<dds_Publisher *> publisher_list;\n+  std::list<dds_Subscriber *> subscription_list;\n+  node_info->pub_list = publisher_list;\n+  node_info->sub_list = subscription_list;\n-  dds_ReturnCode_t ret =\n-    dds_DomainParticipant_get_contained_entities(participant, pub_seq, sub_seq, NULL, NULL);\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to get contained entities of the domain participant\");\n-    dds_InstanceHandleSeq_delete(pub_seq);\n-    dds_InstanceHandleSeq_delete(sub_seq);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  int32_t cnt = static_cast<int32_t>(dds_InstanceHandleSeq_length(pub_seq));\n... [truncated] ...\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+      RMW_SET_ERROR_MSG(\"failed to create datawriter sequence\");\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-        dds_InstanceHandleSeq_delete(pub_seq);\n-        dds_InstanceHandleSeq_delete(sub_seq);\n-      dds_InstanceHandleSeq_delete(pub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+    node_info->pub_list.pop_front();\n-  dds_InstanceHandleSeq_delete(pub_seq);\n-  cnt = static_cast<int32_t>(dds_InstanceHandleSeq_length(sub_seq));\n-  for (int32_t i = cnt - 1; i >= 0; i--) {\n-    dds_Subscriber * sub =\n-      reinterpret_cast<dds_Subscriber *>(dds_InstanceHandleSeq_remove(sub_seq, i));\n+  while (!node_info->sub_list.empty()) {\n+    dds_Subscriber * sub = node_info->sub_list.front();\n-      RMW_SET_ERROR_MSG(\"failed to create instance handle sequence\");\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+      RMW_SET_ERROR_MSG(\"failed to create datareader sequence\");\n-      dds_InstanceHandleSeq_delete(sub_seq);\n-        dds_InstanceHandleSeq_delete(sub_seq);\n-      dds_InstanceHandleSeq_delete(sub_seq);\n+    node_info->sub_list.pop_front();\n-  dds_InstanceHandleSeq_delete(sub_seq);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "a38a28d748e436e51540c567f506bb59f7577248",
    "RawMessage": "Adds topic name to error msg when create_topic fails",
    "Changes": "-void set_error_message_from_create_topic(dds_entity_t topic)\n+void set_error_message_from_create_topic(dds_entity_t topic, std::string topic_name)\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because the function was given\"\n-      \" invalid parameters\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because the function was given invalid parameters\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because it's already in use\"\n-      \" in this context with incompatible QoS settings\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because it's already in use in this context with incompatible QoS settings\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\n-      \"failed to create topic because it's already in use\"\n-      \" in this context with a different message type\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name +\n+      \"] because it's already in use in this context with a different message type\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    RMW_SET_ERROR_MSG(\"failed to create topic for unknown reasons\");\n+    std::string error_msg = \"failed to create topic [\" + topic_name + \"] for unknown reasons\";\n+    RMW_SET_ERROR_MSG(error_msg.c_str());\n-    set_error_message_from_create_topic(topic);\n+    set_error_message_from_create_topic(topic, fqtopic_name);\n-    set_error_message_from_create_topic(topic);\n+    set_error_message_from_create_topic(topic, fqtopic_name);\n-    set_error_message_from_create_topic(pubtopic);\n+    set_error_message_from_create_topic(pubtopic, pubtopic_name);\n-    set_error_message_from_create_topic(subtopic);\n+    set_error_message_from_create_topic(subtopic, subtopic_name);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "bfe00f71b7056bb64b27a8d5f5bacefe0564c43e",
    "RawMessage": "Properly initialize the char array used in type hash calculations. (#1182)",
    "Changes": "+#include \"./common.h\"\n+\n+  rcl_allocator_t allocator = rcl_get_default_allocator();\n-  msg_repr.allocator = rcl_get_default_allocator();\n+  rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+  if (rcutils_result != RCL_RET_OK) {\n+    // rcutils_char_array_init already set the error\n+    return rcl_convert_rcutils_ret_to_rcl_ret(rcutils_result);\n+  }\n-    msg_repr.allocator = rcl_get_default_allocator();\n+    rcl_allocator_t allocator = rcl_get_default_allocator();\n+    rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+    ASSERT_EQ(rcutils_result, RCL_RET_OK);\n-    msg_repr.allocator = rcl_get_default_allocator();\n+    rcl_allocator_t allocator = rcl_get_default_allocator();\n+    rcutils_ret_t rcutils_result = rcutils_char_array_init(&msg_repr, 0, &allocator);\n+    ASSERT_EQ(rcutils_result, RCL_RET_OK);",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "cf2f2ff164505f8f45f9a39347f7d2ebecffb9c1",
    "RawMessage": "Change g_mask_map_ptr type to array of dds_StatusKind",
    "Changes": "-#include <unordered_map>\n-#include <memory>\n-static std::shared_ptr<std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>>>\n-g_mask_map_ptr {new std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> {\n-    {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n-    {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n-    {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n-    {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n-    {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n-  }};\n+static const dds_StatusKind g_mask_map[] {\n+  dds_LIVELINESS_CHANGED_STATUS,  // RMW_EVENT_LIVELINESS_CHANGED\n+  dds_REQUESTED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_REQUESTED_DEADLINE_MISSED\n+  dds_REQUESTED_INCOMPATIBLE_QOS_STATUS,  // RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE\n+  dds_SAMPLE_LOST_STATUS,  // RMW_EVENT_MESSAGE_LOST\n+  dds_LIVELINESS_LOST_STATUS,  // RMW_EVENT_LIVELINESS_LOST\n+  dds_OFFERED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_OFFERED_DEADLINE_MISSED\n+  dds_OFFERED_INCOMPATIBLE_QOS_STATUS  // RMW_EVENT_OFFERED_QOS_INCOMPATIBLE\n+};\n-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n+  if (!is_event_supported(event_t)) {\n-  return mask_map_ptr->at(event_t);\n+\n+  return g_mask_map[static_cast<int>(event_t)];\n-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n-    return false;\n-  }\n-  return mask_map_ptr->count(event_t) > 0;\n+  return 0 <= event_t && event_t < RMW_EVENT_INVALID;",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "3f8a661fad7e0cc9d83e518d02b632d349d71336",
    "RawMessage": "Convert ActionClient to use C++ classes (#759)",
    "Changes": "+  src/rclpy/action_client.cpp\n-            self._client_handle = _rclpy.rclpy_action_create_client(\n+            self._client_handle = _rclpy.ActionClient(\n-        ready_entities = _rclpy.rclpy_action_wait_set_is_ready(\n-            self._client_handle,\n-            wait_set)\n+        ready_entities = self._client_handle.is_ready(wait_set)\n-            taken_data = _rclpy.rclpy_action_take_goal_response(\n-                self._client_handle, self._action_type.Impl.SendGoalService.Response)\n+            taken_data = self._client_handle.take_goal_response(\n+                self._action_type.Impl.SendGoalService.Response)\n-            taken_data = _rclpy.rclpy_action_take_cancel_response(\n-                self._client_handle, self._action_type.Impl.CancelGoalService.Response)\n+            taken_data = self._client_handle.take_cancel_response(\n+                self._action_type.Impl.CancelGoalService.Response)\n-            taken_data = _rclpy.rclpy_action_take_result_response(\n-                self._client_handle, self._action_type.Impl.GetResultService.Response)\n+            taken_data = self._client_handle.take_result_response(\n+                self._action_type.Impl.GetResultService.Response)\n-            taken_data = _rclpy.rclpy_action_take_feedback(\n-                self._client_handle, self._action_type.Impl.FeedbackMessage)\n+            taken_data = self._client_handle.take_feedback(\n+                self._action_type.Impl.FeedbackMessage)\n-            taken_data = _rclpy.rclpy_action_take_status(\n-                self._client_handle, self._action_type.Impl.GoalStatusMessage)\n... [truncated] ...\n+  auto capsule_ptr = static_cast<void *>(\n+    pymetaclass.attr(\"_CONVERT_FROM_PY\").cast<py::capsule>());\n+  auto convert =\n+    reinterpret_cast<convert_from_py_signature *>(capsule_ptr);\n+  if (!convert) {\n+    throw py::error_already_set();\n+  }\n+\n+  if (!convert(pymessage.ptr(), message.get())) {\n+    throw py::error_already_set();\n+  }\n+\n+  return message;\n+}\n+\n+/// Convert a ROS message from a Python type to a C type.\n+/**\n+ * Raises AttributeError if the Python message type is missing a required attribute.\n+ *\n+ * \\param[in] pyclass ROS message Python type to extract data from.\n+ * \\return unique pointer with the C version of the input ROS message.\n+ */\n+std::unique_ptr<void, destroy_ros_message_function *>\n+convert_from_py(py::object pyclass);\n+",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "d4113906c9c95f141f200bfcdfad77f3f8b53972",
    "RawMessage": "Update rmw_fastrtps_cpp QD: Fast DDS & unit test",
    "Changes": "-Much of Fast RTPS itself has feature documentation [hosted publicly](https://fast-rtps.docs.eprosima.com/en/latest).\n+Much of Fast DDS itself has feature documentation [hosted publicly](https://fast-dds.docs.eprosima.com/en/latest/).\n-The justification is that the only uncovered lines have to do with system resource exhaustion and Fast-DDS internal failure.\n+The justification is that the only uncovered lines have to do with system resource exhaustion and Fast DDS internal failure.\n-|4.ii| Public API tests | None |\n+|4.ii| Public API tests | * |",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "a7b8784884fe35720b41ae3c2e703aac28de8832",
    "RawMessage": "Add a libqt5-svg dependency to rviz_common. (#992)",
    "Changes": "+  <build_depend>libqt5-svg-dev</build_depend>\n+  <exec_depend>libqt5-svg</exec_depend>",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "635ba7c7b9a42f17cdb090d391dcea4dcccb8adb",
    "RawMessage": "Handle null string",
    "Changes": "-      throw std::runtime_error(\"Invalid string value\");\n+      dst = std::string(\"\");\n+      return;\n-      throw std::runtime_error(\"Invalid wstring value\");\n+      dst = std::u16string(u\"\");\n+      return;\n-        throw std::runtime_error(\"Invalid string value\");\n+        dst.data[0] = '\\0';\n+        dst.size = 0;\n+        dst.capacity = 1;\n+        return;\n-        throw std::runtime_error(\"Invalid wstring value\");\n+        dst.data[0] = u'\\0';\n+        dst.size = 0;\n+        dst.capacity = 1;\n+        return;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "a75529d598171f2c742812703e6d2a8407d20777",
    "RawMessage": "Add __enter__ and __exit__ to Waitable (#761)",
    "Changes": "-            for waitable in waitables:\n-                entity_count += waitable.get_num_entities()\n-\n+                for waitable in waitables:\n+                    try:\n+                        context_stack.enter_context(waitable)\n+                        entity_count += waitable.get_num_entities()\n+                    except InvalidHandle:\n+                        pass\n+\n+    def __enter__(self):\n+        \"\"\"Mark event as in-use to prevent destruction while waiting on it.\"\"\"\n+        self.__event.__enter__()\n+\n+    def __exit__(self, t, v, tb):\n+        \"\"\"Mark event as not-in-use to allow destruction after waiting on it.\"\"\"\n+        self.__event.__exit__(t, v, tb)\n+\n+    def __enter__(self):\n+        \"\"\"Implement to mark entities as in-use to prevent destruction while waiting on them.\"\"\"\n+        pass\n+\n+    def __exit__(self, t, v, tb):\n+        \"\"\"Implement to mark entities as not-in-use to allow destruction after waiting on them.\"\"\"\n+        pass\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "57d7b74a16c70954100b198226f9c6e12f42fb1f",
    "RawMessage": "rcl_action: address various clang static analysis fixes (#864)",
    "Changes": "-  ret_final = _recalculate_expire_timer(\n+  rcl_ret_t expire_timer_ret = _recalculate_expire_timer(\n+  if (RCL_RET_OK != expire_timer_ret) {\n+    ret_final = expire_timer_ret;\n+  }\n+\n+    } else {\n+      ret_final = RCL_RET_ERROR;  // error already set\n-    ret_final = RCL_RET_ERROR;  // error already set\n-  EXPECT_TRUE(uuidcmp(goal_info_out->goal_id.uuid, goal_info_in.goal_id.uuid));\n+\n+  // Passing this array by pointer can confuse scan-build into thinking the pointer is\n+  // not checked for null. Passing by reference works fine\n+  const auto & goal_info_out_uuid = goal_info_out->goal_id.uuid;\n+  EXPECT_TRUE(uuidcmp(goal_info_out_uuid, goal_info_in.goal_id.uuid));\n-    EXPECT_TRUE(uuidcmp(goal_info->goal_id.uuid, cancel_request.goal_info.goal_id.uuid));\n+\n+    // Passing this array by pointer can confuse scan-build into thinking the pointer is\n+    // not checked for null. Passing by reference works fine\n+    const auto & goal_info_uuid = goal_info->goal_id.uuid;\n+    EXPECT_TRUE(uuidcmp(goal_info_uuid, cancel_request.goal_info.goal_id.uuid));\n+  ASSERT_EQ(ret, RCL_RET_OK) << rcl_get_error_string().str;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "76808250140f35dcb3e7f21d6bb13d95eff0e537",
    "RawMessage": "Move handle sequence delete into right place",
    "Changes": "-        dds_InstanceHandleSeq_delete(handle_seq);\n+\n+    dds_InstanceHandleSeq_delete(handle_seq);\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "1b01127ae2b9bcec4fef7c733fc7f680aacf5c7f",
    "RawMessage": "Set disable loan to on by default. (#1110)",
    "Changes": "- * - disable_loaned_message = false, true only if ROS_DISABLE_LOANED_MESSAGES=1\n+ * - disable_loaned_message = true, false only if ROS_DISABLE_LOANED_MESSAGES=0\n+#include \"rcutils/env.h\"\n-  bool disable_loaned_message = false;\n-  rcl_ret_t ret = rcl_get_disable_loaned_message(&disable_loaned_message);\n-  if (ret == RCL_RET_OK) {\n-    default_options.disable_loaned_message = disable_loaned_message;\n-  } else {\n+  // TODO(clalancette): This is kind of a copy of rcl_get_disable_loaned_message(), but we need\n+  // more information than that function provides.\n+  default_options.disable_loaned_message = true;\n+\n+  const char * env_val = NULL;\n+  const char * env_error_str = rcutils_get_env(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR, &env_val);\n+  if (NULL != env_error_str) {\n-    RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n-    rcl_reset_error();\n-    default_options.disable_loaned_message = false;\n+    RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+      \"Error getting env var: '\" RCUTILS_STRINGIFY(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR) \"': %s\\n\",\n+      env_error_str);\n+  } else {\n+    default_options.disable_loaned_message = !(strcmp(env_val, \"0\") == 0);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n-    EXPECT_FALSE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+    EXPECT_TRUE(subscription_options.disable_loaned_message);\n+  }\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "1db1f16a49378f4693b74296449ee920ff53cffe",
    "RawMessage": "avoid unnecessary copy for rcutils_char_array_vsprintf. (#412)",
    "Changes": "-    va_list args_clone;\n-    va_copy(args_clone, *args);\n-    status = rcutils_char_array_vsprintf(&msg_array, format, args_clone);\n+    status = rcutils_char_array_vsprintf(&msg_array, format, *args);\n-    va_end(args_clone);",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "ae6f0652ae5d4aba89fb2cfe83d8105bde89d6d3",
    "RawMessage": "Account for alignment on `is_plain` calculations (#108)",
    "Changes": "+  size_t last_member_size = 0;\n+  (void)last_member_size;\n+@{\n+last_member_name_ = None\n+}@\n+@{\n+last_member_name_ = member.name\n+}@\n+    last_member_size = array_size * sizeof(uint8_t);\n+    last_member_size = array_size * sizeof(uint16_t);\n+    last_member_size = array_size * sizeof(uint32_t);\n+    last_member_size = array_size * sizeof(uint64_t);\n+    last_member_size = array_size * sizeof(long double);\n+    last_member_size = 0;\n-      current_alignment +=\n+      size_t inner_size;\n+      inner_size =\n+      last_member_size += inner_size;\n+      current_alignment += inner_size;\n-  return current_alignment - initial_alignment;\n+  size_t ret_val = current_alignment - initial_alignment;\n+@[if last_member_name_ is not None]@\n+  if (is_plain) {\n+    // All members are plain, and type is not empty.\n+    // We still need to check that the in-memory alignment\n... [truncated] ...\n+    last_member_size = array_size * sizeof(uint32_t);\n+    last_member_size = array_size * sizeof(uint64_t);\n+    last_member_size = array_size * sizeof(long double);\n+    last_member_size = 0;\n-      current_alignment +=\n+      size_t inner_size =\n+      last_member_size += inner_size;\n+      current_alignment += inner_size;\n-  return current_alignment - initial_alignment;\n+  size_t ret_val = current_alignment - initial_alignment;\n+@[if last_member_name_ is not None]@\n+  if (is_plain) {\n+    // All members are plain, and type is not empty.\n+    // We still need to check that the in-memory alignment\n+    // is the same as the CDR mandated alignment.\n+    using DataType = @('::'.join([package_name] + list(interface_path.parents[0].parts) + [message.structure.namespaced_type.name]));\n+    is_plain =\n+      (\n+      offsetof(DataType, @(last_member_name_)) +\n+      last_member_size\n+      ) == ret_val;\n+  }\n+\n+@[end if]@\n+  return ret_val;",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "d746cfbcdade8cd6d627bd35281b6eba4211d1d2",
    "RawMessage": "Add a semicolon to RCUTILS_LOGGING_AUTOINIT. (#816)",
    "Changes": "-  RCUTILS_LOGGING_AUTOINIT\n-    g_logging_allocator = *allocator;\n+  RCUTILS_LOGGING_AUTOINIT;\n+  g_logging_allocator = *allocator;",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "565c5080fb2ebd20623f265f8915c7419382a986",
    "RawMessage": "Use timeout object to avoid callback losing in wait_for_ready_callbacks (#1165)",
    "Changes": "+class TimeoutObject:\n+    \"\"\"Use timeout object to save timeout.\"\"\"\n+\n+    def __init__(self, timeout: float):\n+        self._timeout = timeout\n+\n+    @property\n+    def timeout(self):\n+        return self._timeout\n+\n+    @timeout.setter\n+    def timeout(self, timeout):\n+        self._timeout = timeout\n+\n+\n-            timeout_left = timeout_sec\n+            timeout_left = TimeoutObject(timeout_sec)\n-                timeout_left = end - now\n+                timeout_left.timeout = end - now\n-        timeout_sec: Optional[float] = None\n+        timeout_sec: Optional[Union[float, TimeoutObject]] = None\n-        timeout_sec: Optional[float] = None,\n+        timeout_sec: Optional[Union[float, TimeoutObject]] = None,\n-        timeout_nsec = timeout_sec_to_nsec(timeout_sec)\n+        timeout_nsec = timeout_sec_to_nsec(\n... [truncated] ...\n+\n+        async def timer1_callback():\n+            timer1.cancel()\n+            await cli.call_async(Empty.Request())\n+\n+        timer1 = self.node.create_timer(0.5, timer1_callback, callback_group)\n+\n+        count = 0\n+\n+        def timer2_callback():\n+            nonlocal count\n+            count += 1\n+        timer2 = self.node.create_timer(1.5, timer2_callback, callback_group)\n+\n+        executor.add_node(self.node)\n+        future = Future(executor=executor)\n+        executor.spin_until_future_complete(future, 4)\n+\n+        assert count == 2\n+\n+        executor.shutdown()\n+        timer2.destroy()\n+        timer1.destroy()\n+        cli.destroy()\n+",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw",
    "SHA": "0176872b10ff502ae34fa3eef5e900145f18b0b3",
    "RawMessage": "Update subscription API documentation (#256)",
    "Changes": "-/// Create and return an rmw subscription.\n+/// Create a subscription and return a handle to that subscription.\n- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n+ * This function can fail, and therefore return `NULL`, if:\n+ *   - node is not a valid non-null handle for this rmw implementation,\n+ *     as returned by `rmw_create_node()`\n+ *   - type_support is a not valid non-null message type support, as returned by\n+ *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n+ *   - topic_name is not a valid non-null topic name, according to\n+ *     `rmw_validate_full_topic_name()` if ROS namespace conventions apply\n+ *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n+ *   - subscription_options is not a valid non-null option set, such as the one\n+ *     returned by `rmw_get_default_subscription_options()`\n+ *   - memory allocation fails during subscription creation\n+ *   - an unspecified error occurs\n- * The argument `subscription_options` must not be nullptr.\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n... [truncated] ...\n+ * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n+ * the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription\n+ * handle is undefined behavior.\n+ *\n+ * \\pre Given node must be the one the subscription was registered with.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\param[in] node Handle to node with which the given subscription is registered\n+ * \\param[in] subscription Handle to subscription to be finalized\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription\n+ *   implementation identifier does not match, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs.\n+ */\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription\n+ *   implementation identifier does not match, or",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "091fe27d43c0ba93c1bd79c630173ce2c3b39891",
    "RawMessage": "Don't crash the action server if the client goes away. (#1114)",
    "Changes": "-        self._handle.send_goal_response(request_header, response_msg)\n+\n+        try:\n+            # If the client goes away anytime before this, sending the goal response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_goal_response(request_header, response_msg)\n+        except RCLError:\n+            self._logger.warn('Failed to send goal response (the client may have gone away)')\n+            return\n-        self._handle.send_result_response(request_header, future.result())\n+        try:\n+            # If the client goes away anytime before this, sending the result response may fail.\n+            # Catch the exception here and go on so we don't crash.\n+            self._handle.send_result_response(request_header, future.result())\n+        except RCLError:\n+            self._logger.warn('Failed to send result response (the client may have gone away)')",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "4df5aa3938c919f197993e1390096dd45c53c888",
    "RawMessage": "Show link names in inertia error message (#874)",
    "Changes": "-      RVIZ_COMMON_LOG_ERROR_STREAM(\n-        \"The link is static or has unrealistic \"\n-        \"inertia, so the equivalent inertia box will not be shown.\\n\");\n+      if (link->parent_joint && link->parent_joint->type != urdf::Joint::FIXED) {\n+        // Do not show error message for base link or static links\n+        RVIZ_COMMON_LOG_ERROR_STREAM(\n+          \"The link \" << link->name << \" is has unrealistic \"\n+            \"inertia, so the equivalent inertia box will not be shown.\\n\");\n+      }",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "geometry2",
    "SHA": "49d4be4e8dd08282fc3bf5238459ce41d6befe6f",
    "RawMessage": "add torque due to force offset (#538)",
    "Changes": "+  // add additional torque created by translating the force\n+  Vector3 offset = {transform.transform.translation.x, transform.transform.translation.y,\n+    transform.transform.translation.z};\n+  auto added_torque = offset.cross({t_out.force.x, t_out.force.y, t_out.force.z});\n+  t_out.torque.x += added_torque.getX();\n+  t_out.torque.y += added_torque.getY();\n+  t_out.torque.z += added_torque.getZ();\n-  trafo.transform.translation.x = -1;\n-  trafo.transform.translation.y = 2;\n-  trafo.transform.translation.z = -3;\n+  trafo.transform.translation.x = 0;\n+  trafo.transform.translation.y = -2;\n+  trafo.transform.translation.z = 0;\n-  EXPECT_NEAR(res.torque.x, 1, EPS);\n+  EXPECT_NEAR(res.torque.x, -5, EPS);\n-  EXPECT_NEAR(res.torque.z, 3, EPS);\n+  EXPECT_NEAR(res.torque.z, 5, EPS);",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "54bd8aac170b462ae7150f3c4f2b2e61d1888c22",
    "RawMessage": "Ensure compliant matched pub/sub count API. (#223)",
    "Changes": "-  RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n+\n-  } else {\n-    *subscription_count = status.current_count;\n-    return RMW_RET_OK;\n+\n+  *subscription_count = status.current_count;\n+  return RMW_RET_OK;\n-  RET_NULL(subscription);\n-  RET_WRONG_IMPLID(subscription);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n+\n-  } else {\n-    *publisher_count = status.current_count;\n-    return RMW_RET_OK;\n+\n+  *publisher_count = status.current_count;\n+  return RMW_RET_OK;",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "ba7c99158dcf57867c0a79665f80a85b48adc934",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* add QoS Profile/Depth support to Node. (`#1376 <https://github.com/ros2/rclpy/issues/1376>`_)\n+* Various typing fixes (`#1402 <https://github.com/ros2/rclpy/issues/1402>`_)\n+* Add types to Action with rhel roscli fix (`#1361 <https://github.com/ros2/rclpy/issues/1361>`_)\n+* Check if Task(Future) is canceled. (`#1377 <https://github.com/ros2/rclpy/issues/1377>`_)\n+* Executors types (`#1370 <https://github.com/ros2/rclpy/issues/1370>`_)\n+* event_handler.py types (`#1340 <https://github.com/ros2/rclpy/issues/1340>`_)\n+* Contributors: Michael Carlstrom, Nadav Elkabets, Tomoya Fujita\n+",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "40054baf84ca440e4fb94c43e6145dbf2f89e41c",
    "RawMessage": "Add parallel callback test (#1044)",
    "Changes": "+import time\n-from test_msgs.msg import BasicTypes\n+from rclpy.executors import MultiThreadedExecutor\n+from rclpy.task import Future\n+from test_msgs.msg import BasicTypes, Empty\n+    def test_reentrant_group_not_blocking(self):\n+        self.assertIsNotNone(self.node.handle)\n+        # Create multithreaded executor needed for parallel callback handling\n+        executor = MultiThreadedExecutor(num_threads=2, context=self.context)\n+        executor.add_node(self.node)\n+        try:\n+            # Setup flags for different scopes,\n+            # which indicate that the short callback has been called\n+            got_short_callback = False\n+            received_short_callback_in_long_callback = False\n+\n+            # Setup two future objects that control the executor\n+            future_up = Future()\n+            future_down = Future()\n+\n+            # This callback is used to check if a callback can be received while another\n+            # long running callback is being executed\n+            def short_callback(msg):\n+                nonlocal got_short_callback\n+                # Set flag so signal that the callback has been received\n... [truncated] ...\n+                1,\n+                callback_group=group)\n+            self.node.create_subscription(\n+                Empty,\n+                'trigger_short',\n+                short_callback,\n+                1,\n+                callback_group=group)\n+            # Create publishers to trigger both callbacks\n+            pub_trigger_long = self.node.create_publisher(Empty, 'trigger_long', 1)\n+            pub_trigger_short = self.node.create_publisher(Empty, 'trigger_short', 1)\n+            # Start the long running callback\n+            pub_trigger_long.publish(Empty())\n+            # Spin until we are sure that the long running callback is running\n+            executor.spin_until_future_complete(future_up)\n+            # Publish the short callback\n+            pub_trigger_short.publish(Empty())\n+            # Wait until the long running callback ends\n+            # (due to the signal from the short one or a timeout)\n+            executor.spin_until_future_complete(future_down)\n+            # Check if we were able to receive the short callback during the long running one\n+            self.assertTrue(received_short_callback_in_long_callback)\n+        finally:\n+            executor.shutdown()\n+",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "e3b56ed7058502d94fe3d1c27948d4f4e9be58a8",
    "RawMessage": "Added Effort plugin (#990)",
    "Changes": "-| Camera                | Focus Camera  | XY Orbit              | Help            | \n-| Fluid Pressure        | Measure       | First Person          | Selections      |\n-| Grid                  | Select        | Third Person Follower | Time            |\n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Illuminance           | Publish Point |                       | Views           |\n-| Image                 | Initial Pose  |\n-| Interactive Marker    | Interact      |\n+| Camera                | Focus Camera  | XY Orbit              | Help            |\n+| Effort                | Measure       | First Person          | Selections      |\n+| Fluid                 | Select        | Third Person Follower | Time            |\n+| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Grid Cells            | Publish Point |                       | Views           |\n+| Illuminance           | Initial Pose  |\n+| Image                 | Interact      |\n+| Interactive Marker    |\n-| Effort        |\n+  include/rviz_default_plugins/displays/effort/effort_display.hpp\n+  src/rviz_default_plugins/displays/effort/effort_display.cpp\n+  ament_add_gtest(effort_display_visual_test\n+    test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\n+    test/rviz_default_plugins/publishers/effort_publisher.hpp\n+    test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET effort_display_visual_test)\n... [truncated] ...\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setFramePosition(\"joint1\", pos1);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(3.0f, 1.0f, -2.05f)));\n+}\n+\n+TEST_F(EffortVisualTestFixture, setEffort_hides_force_arrow_for_larger_width_than_scale) {\n+  auto scene_manager = Ogre::Root::getSingletonPtr()->createSceneManager();\n+  auto root_node = scene_manager->getRootSceneNode();\n+\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+\n+  effort_visual->setScale(0.7f);\n+  effort_visual->setWidth(5);\n+\n+  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  EXPECT_THAT(arrows, SizeIs(1u));\n+  auto force_arrow = findForceArrow(root_node);\n+  EXPECT_THAT(force_arrow->getScale(), Vector3Eq(Ogre::Vector3(1, 1, 1)));\n+}",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rclpy",
    "SHA": "bbf05d5ca0976f966bbb8cc24b43206903a6cea8",
    "RawMessage": "Pybind11 actionserver nitpicks and docblock improvements (#774)",
    "Changes": "-#include \"action_client.hpp\"\n-#include \"action_goal_handle.hpp\"\n-#include \"action_server.hpp\"\n-#include \"clock.hpp\"\n-\n-  define_action_goal_handle(m);\n-  define_action_server(m);\n-\n-  rclpy::define_action_client(m);\n+#include \"action_client.hpp\"\n+#include \"action_goal_handle.hpp\"\n+#include \"action_server.hpp\"\n+  rclpy::define_action_client(m);\n+  rclpy::define_action_goal_handle(m);\n+  rclpy::define_action_server(m);\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_action_client_t pointer\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n+    throw py::value_error(append_rcl_error(error_text));\n-    std::string error_text{\"Failed to create action server: \"};\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n... [truncated] ...\n+          rcl_get_error_string().str);\n+        rcl_reset_error();\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_action_server_t pointer\n-  /// Get rcl_client_t pointer\n-  std::shared_ptr<rcl_action_server_t>\n-  get_rcl_shared_ptr()\n-  {\n-    return rcl_action_server_;\n-  }\n-\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_clock_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_guard_condition_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_publisher_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_service_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_subscription_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_timer_t pointer\n-  /// Get rcl_client_t pointer\n+  /// Get rcl_wait_set_t pointer",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "0707355430b5a1c915c8a57961099155bb40cef8",
    "RawMessage": "Fix flags for both clang and gcc. (#1219)",
    "Changes": "-  set(OGRE_CXX_FLAGS \"-Wno-implicit-const-int-float-conversion ${OGRE_CXX_FLAGS}\")\n-  if(NOT CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n+  if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n+    set(OGRE_CXX_FLAGS \"-Wno-implicit-const-int-float-conversion ${OGRE_CXX_FLAGS}\")\n+  else()\n+    set(OGRE_CXX_FLAGS \"-Wno-stringop-overflow ${OGRE_CXX_FLAGS}\")",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "6681aa366781fed79a70940a7056ed7b2e1afda9",
    "RawMessage": "Add another reference for twist transformation. Comment correction. (#620)",
    "Changes": "- * Twist: (trans. vel. x, trans. vel. y, trans. vel. z, ang. vel. x, ang. vel. y, ang. vel. z)\n+ * Twist: (ang. vel. x, ang. vel. y, ang. vel. z, trans. vel. x, trans. vel. y, trans. vel. z)\n-  // https://core.ac.uk/download/pdf/154240607.pdf, https://www.seas.upenn.edu/~meam520/notes02/Forces8.pdf\n+  // https://core.ac.uk/download/pdf/154240607.pdf\n+  // http://hades.mech.northwestern.edu/images/7/7f/MR.pdf Eq'n 3.83",
    "BackportedTo": "humble",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "3cd75159b8162dac3101b65a092e598b31f4f8a7",
    "RawMessage": "Re-order shutdown vs node destruction (#213)",
    "Changes": "-        self.destroy_node()\n+        self.destroy_node()",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "2a72dbaaf09458a998fad39d898adc9b8a60565a",
    "RawMessage": "Remove CODEOWNERS and the rolling-to-master job. (#1199)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @audrow @ivanpauno @wjwwood",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "13504b5003ecf010cf8d3085af6997475f9f83f2",
    "RawMessage": "Fix interoperability errors: Remove buffer roundup at the end of messeage deserialize function",
    "Changes": "-        ),\n-        false\n+        )\n-      ),\n-      false\n+      )\n-          ),\n-          false\n+          )\n-          ),\n-          false\n+          )\n-      ),\n-      false\n+      )\n-  void deserialize(const MessageMembersT * members, uint8_t * output, bool roundup_)\n+  void deserialize(const MessageMembersT * members, uint8_t * output)\n-\n-    if (roundup_) {\n-      buffer.roundup(4);\n-    }\n-    deserializer.deserialize(members, ros_message, true);\n+    deserializer.deserialize(members, ros_message);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);\n-    deserializer.deserialize(members, ros_service, true);\n+    deserializer.deserialize(members, ros_service);",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "6f9225a4f90fb298aff053075aa14555b54a2b67",
    "RawMessage": "Fix typo",
    "Changes": "-get_response_data_writer(rmw_client_t * client)\n+get_response_data_reader(rmw_client_t * client)\n-    RMW_SET_ERROR_MSG(\"subscription internal data writer is invalid\");\n+    RMW_SET_ERROR_MSG(\"subscription internal data reader is invalid\");\n-  if (sample_infos == nullptr) {\n+  if (sample_sizes == nullptr) {\n-  if (sample_infos == nullptr) {\n+  if (sample_sizes == nullptr) {\n-  if (sample_infos == nullptr) {\n+  if (sample_sizes == nullptr) {",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "2a5f3e4f776869ae1e981f3ca1877cdf10318f37",
    "RawMessage": "add inverted reverse param (#35)",
    "Changes": "-  \n+\n-  \n+\n-  \n+\n-    \n-  \n+- `inverted_reverse (bool, default: false)`\n+  - Whether to invert turning left-right while reversing (useful for differential wheeled robots).\n+\n+  bool inverted_reverse;\n+\n+  pimpl_->inverted_reverse = this->declare_parameter(\"inverted_reverse\", false);\n+\n+  ROS_INFO_COND_NAMED(\n+    pimpl_->inverted_reverse, \"TeleopTwistJoy\", \"%s\", \"Teleop enable inverted reverse.\");\n+        } else if (parameter.get_name() == \"inverted_reverse\") {\n+          this->pimpl_->inverted_reverse = parameter.get_value<rclcpp::PARAMETER_BOOL>();\n-  cmd_vel_msg->linear.x = getVal(joy_msg, axis_linear_map, scale_linear_map[which_map], \"x\");\n+  double lin_x = getVal(joy_msg, axis_linear_map, scale_linear_map[which_map], \"x\");\n+  double ang_z = getVal(joy_msg, axis_angular_map, scale_angular_map[which_map], \"yaw\");\n+\n+  cmd_vel_msg->linear.x = lin_x;\n-  cmd_vel_msg->angular.z = getVal(joy_msg, axis_angular_map, scale_angular_map[which_map], \"yaw\");\n+  cmd_vel_msg->angular.z = (lin_x < 0.0 && inverted_reverse) ? -ang_z : ang_z;",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "933ec536fd04e4617b9cc32626e338edc5cb0f5a",
    "RawMessage": "Fix #983 by saving future and checking for + raising any exceptions (#1073)",
    "Changes": "+        self._futures = []\n+            self._futures.append(handler)\n+            for future in self._futures:  # check for any exceptions\n+                if future.done():\n+                    self._futures.remove(future)\n+                    future.result()",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2f09c6414c58f0a4a34305bd44be30b850af2b60",
    "RawMessage": "Support non-interactive ros2 launch executions (#210)",
    "Changes": "-def launch_a_launch_file(*, launch_file_path, launch_file_arguments, debug=False):\n+def launch_a_launch_file(\n+    *,\n+    launch_file_path,\n+    launch_file_arguments,\n+    noninteractive=False,\n+    debug=False\n+):\n-    launch_service = launch.LaunchService(argv=launch_file_arguments, debug=debug)\n+    launch_service = launch.LaunchService(\n+        argv=launch_file_arguments,\n+        noninteractive=noninteractive,\n+        debug=debug)\n+import sys\n+        parser.add_argument(\n+            '-n', '--noninteractive', default=not sys.stdin.isatty(), action='store_true',\n+            help='Run the launch system non-interactively, with no terminal associated')\n+                noninteractive=args.noninteractive,",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "e9789d44268fa04e98eaffab0789b6c6bbc5add4",
    "RawMessage": "Fix the component load help to mention load, not unload. (#756)",
    "Changes": "-            'container_node_name', help='Container node name to unload component from'\n+            'container_node_name', help='Container node name to load component into'",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "63c72e9ffb16dbb5bba0dd100f2a6dbb35e6ed57",
    "RawMessage": "Fix rcl_parse_yaml_file() error handling. (#776)",
    "Changes": "-/// \\brief Parse the YAML file, initialize and populate params_st\n+/// \\brief Parse the YAML file and populate \\p params_st\n+/// \\pre Given \\p params_st must be a valid parameter struct\n+///   as returned by `rcl_yaml_node_struct_init()`\n-/// \\param[inout] params_st points to the populated parameter struct\n+/// \\param[inout] params_st points to the struct to be populated\n-  if (RCUTILS_RET_OK != ret) {\n-    rcl_yaml_node_struct_fini(params_st);\n-    return false;\n-  }\n-\n-  return true;\n+  return RCUTILS_RET_OK == ret;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rpyutils",
    "SHA": "824efd64f86b1a6d18d7429a4cd212f9c6594a7e",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#13)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @quarkytale",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "ros2cli",
    "SHA": "acefd9c0d773e7a067a6c458455eebaa2fbc6751",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#949)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @audrow @gbiggs",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "2eaab2584ed6b6635a34f47df46d73bb717dee2a",
    "RawMessage": "Fix invalid timer handle exception (#474)",
    "Changes": "+      timer_to_request_map_.erase(timer_handle);\n+      timer_interface_->remove(timer_handle);\n-    timer_to_request_map_.erase(timer_handle);\n-    timer_interface_->remove(timer_handle);\n+#include \"tf2_ros/create_timer_ros.h\"\n+class MockCreateTimerROS final : public tf2_ros::CreateTimerROS\n+{\n+public:\n+  MockCreateTimerROS(\n+    rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base,\n+    rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers)\n+  : CreateTimerROS(node_base, node_timers), next_timer_handle_index_(0)\n+  {\n+  }\n+\n+  tf2_ros::TimerHandle\n+  createTimer(\n+    rclcpp::Clock::SharedPtr clock,\n+    const tf2::Duration & period,\n+    tf2_ros::TimerCallbackType callback) override\n+  {\n+    auto timer_handle_index = next_timer_handle_index_++;\n+    auto timer_callback = std::bind(\n+      &MockCreateTimerROS::timerCallback, this, timer_handle_index,\n+      callback);\n... [truncated] ...\n+        callback_timeout = true;\n+      }\n+    });\n+\n+  auto status = future.wait_for(std::chrono::milliseconds(1));\n+  EXPECT_EQ(status, std::future_status::timeout);\n+\n+  // Set the valid transform during the timeout\n+  geometry_msgs::msg::TransformStamped transform;\n+  transform.header.frame_id = \"foo\";\n+  transform.header.stamp = builtin_interfaces::msg::Time(rclcpp_time);\n+  transform.child_frame_id = \"bar\";\n+  transform.transform.rotation.w = 1.0;\n+  EXPECT_TRUE(buffer.setTransform(transform, \"unittest\"));\n+\n+  // Fake a time out (race with setTransform above)\n+  EXPECT_NO_THROW(mock_create_timer_ros->execute_timers());\n+\n+  EXPECT_TRUE(buffer.canTransform(\"bar\", \"foo\", tf2_time));\n+  EXPECT_TRUE(buffer.canTransform(\"bar\", \"foo\", rclcpp_time));\n+  status = future.wait_for(std::chrono::milliseconds(1));\n+  EXPECT_EQ(status, std::future_status::ready);\n+  EXPECT_FALSE(callback_timeout);\n+}\n+",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "efc784597ccbd8d246794e72b20358deab4ab114",
    "RawMessage": "Fix the time_jump_callback signature. (#711)",
    "Changes": "-    def time_jump_callback(time_jump: TimeJump):\n+    def time_jump_callback(self, time_jump: TimeJump):",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "04e75b82aa2c931ee51bb7eeec895d1dbcf413a0",
    "RawMessage": "Added shared memory support usage description",
    "Changes": "+# Using Shared Memory with ROS2\n+\n+This rmw_cyclonedds implementation uses [cyclonedds](https://projects.eclipse.org/projects/iot.cyclonedds) which includes support for fast Shared Memory data transfer based on [iceoryx](https://projects.eclipse.org/projects/technology.iceoryx). Since this feature is still in an experimental stage, it is disabled by default but can be enabled easily in a cyclonedds.xml configuration file.\n+\n+## Requirements\n+\n+Currently Shared Memory transport is only supported on Linux. It is available in the rmw_cyclonedds implementation used by the ROS2 Rolling or Galactic Geochelone distribution.\n+\n+## Installation\n+\n+ROS2 needs to be installed as described in [Installing ROS2](https://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Binary.html).\n+\n+It can also be build from sources directly [Building ROS2](https://docs.ros.org/en/rolling/Installation/Ubuntu-Development-Setup.html).\n+\n+In both cases rmw_cyclonedds is build with Shared Memory support by default.\n+\n+## Configuration\n+\n+In your ROS2 workspace `ros2_rolling` create a configuration file `cyclonedds.xml` with the following content.\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<CycloneDDS xmlns=\"https://cdds.io/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"https://cdds.io/config https://raw.githubusercontent.com/eclipse-cyclonedds/cyclonedds/iceoryx/etc/cyclonedds.xsd\">\n+    <Domain id=\"any\">\n+        <SharedMemory>\n... [truncated] ...\n+2. Deadline: Infinity (0)\n+3. Reliability: Reliable\n+    - may be extended to Best Effort as well, but Shared Memory transfer is always reliable\n+4. Durability: Volatile\n+5. History: Keep Last\n+    - with history depth no larger than PubHistoryCapacity (in the configuration file)\n+\n+These settings are used by default and applicable to a large class of applications.\n+\n+### Number of subscriptions per Process\n+\n+Currently a process can only have up to 127 subscriptions when Shared Memory is enabled.\n+\n+### Number of active Loans\n+\n+A single publisher can only hold up to 8 loaned messages simultaneously.\n+To obtain more loaned messages, it needs to publish some of the loaned messages.\n+\n+### Iceoryx Shared Memory Configuration\n+\n+Iceoryx uses configurable memory pools to define different sizes of memory chunks that will be used to store messages in Shared Memory. These will be obtained when data is send via iceoryx, either when explicitly requested with the [Loan API](#Loan-API) or implicitly by the [Regular Publish API](#Regular-Publish-API).\n+\n+Depending on the size and frequency of messages send, the default configuration may not be sufficient to guarantee that memory can be loaned and hence the data send. In this case it might help to use a custom configuration for the shared memory pools to increase the available Shared Memory. The configuration options are described in the [iceoryx configuration guide](https://github.com/eclipse-iceoryx/iceoryx/blob/master/doc/website/advanced/configuration-guide.md).\n+\n+Note that currently the internal loan call is blocking, which means if no memory is available it will not return (this will change in the future). This may happen if the configured memory is not sufficient for the overall system load, i.e. the memory needed was not available in the first place or is used by other samples which are currently read or written.",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b38a872913a2fbad69188d3f012dd204d97446ff",
    "RawMessage": "Change the return time when destroying entities",
    "Changes": "-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-              rmw_ret = RMW_RET_ERROR;\n+              return RMW_RET_ERROR;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-              rmw_ret = RMW_RET_ERROR;\n+              return RMW_RET_ERROR;\n-            rmw_ret = RMW_RET_ERROR;\n... [truncated] ...\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n-    }\n-\n-    if (subscriber_info->dds_typesupport != nullptr) {\n-      dds_TypeSupport_delete(subscriber_info->dds_typesupport);\n-      subscriber_info->dds_typesupport = nullptr;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "7f9a307a9d232445928d04f50add7c0b3995fe22",
    "RawMessage": "TestClient.test_service_timestamps failing consistently. (#1364)",
    "Changes": "-                if result is not None:\n+                if result != (None, None):",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "5328e9db40a10cc0f5353509322bb9282a9812ea",
    "RawMessage": "Remove minimum dds version as raw typesupport removed",
    "Changes": "-  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-2.8</build_export_depend>\n-  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-2.8</build_export_depend>",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclcpp",
    "SHA": "6e1fea14e1fdab856f31bba6c4030c321afa86f7",
    "RawMessage": "Fix race condition in events-executor (#2177)",
    "Changes": "+  /// Utility to add the notify waitable to an entities collection\n+  void\n+  add_notify_waitable_to_collection(\n+    rclcpp::executors::ExecutorEntitiesCollection::WaitableCollection & collection);\n+\n+  this->current_entities_collection_ =\n+    std::make_shared<rclcpp::executors::ExecutorEntitiesCollection>();\n+\n+  // Make sure that the notify waitable is immediately added to the collection\n+  // to avoid missing events\n+  this->add_notify_waitable_to_collection(current_entities_collection_->waitables);\n+\n-\n-  this->current_entities_collection_ =\n-    std::make_shared<rclcpp::executors::ExecutorEntitiesCollection>();\n-  rclcpp::CallbackGroup::WeakPtr weak_group_ptr;\n-  new_collection.waitables.insert(\n-  {\n-    this->notify_waitable_.get(),\n-    {this->notify_waitable_, weak_group_ptr}\n-  });\n-\n-  this->current_entities_collection_->waitables.insert(\n-  {\n-    this->notify_waitable_.get(),\n... [truncated] ...\n+  auto executor_thread = std::thread(\n+    [executor]() {\n+      executor->spin();\n+    });\n+  // Add a node to the executor\n+  executor->add_node(this->node);\n+\n+  // Cancel the executor (make sure that it's already spinning first)\n+  while (!executor->is_spinning() && rclcpp::ok()) {\n+    continue;\n+  }\n+  executor->cancel();\n+\n+  // Try to join the thread after cancelling the executor\n+  // This is the \"test\". We want to make sure that we can still cancel the executor\n+  // regardless of the presence of race conditions\n+  executor_thread.join();\n+\n+  // The test is now completed: we can join the stress threads\n+  should_cancel = true;\n+  for (auto & t : stress_threads) {\n+    t.join();\n+  }\n+}\n+",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "5274760f2515a96d99ef3b55d34b11e9e5dcab66",
    "RawMessage": "Use interface whitelist for localhost only (#476)",
    "Changes": "+#include <memory>\n+#include \"fastrtps/transport/UDPv4TransportDescriptor.h\"\n+using UDPv4TransportDescriptor = eprosima::fastrtps::rtps::UDPv4TransportDescriptor;\n+\n+#if FASTRTPS_VERSION_MAJOR >= 2\n+#include \"fastdds/rtps/transport/shared_mem/SharedMemTransportDescriptor.h\"\n+using SharedMemTransportDescriptor = eprosima::fastdds::rtps::SharedMemTransportDescriptor;\n+#endif\n-    Locator_t local_network_interface_locator;\n-    static const std::string local_ip_name(\"127.0.0.1\");\n-    local_network_interface_locator.kind = 1;\n-    local_network_interface_locator.port = 0;\n-    IPLocator::setIPv4(local_network_interface_locator, local_ip_name);\n-    participantAttrs.rtps.builtin.metatrafficUnicastLocatorList.push_back(\n-      local_network_interface_locator);\n-    participantAttrs.rtps.builtin.initialPeersList.push_back(local_network_interface_locator);\n+    // In order to use the interface white list, we need to disable the default transport config\n+    participantAttrs.rtps.useBuiltinTransports = false;\n+\n+    // Add a UDPv4 transport with only localhost enabled\n+    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();\n+    udp_transport->interfaceWhiteList.emplace_back(\"127.0.0.1\");\n+    participantAttrs.rtps.userTransports.push_back(udp_transport);\n+\n+    // Add SHM transport if available\n+#if FASTRTPS_VERSION_MAJOR >= 2\n+    auto shm_transport = std::make_shared<SharedMemTransportDescriptor>();\n+    participantAttrs.rtps.userTransports.push_back(shm_transport);\n+#endif",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b38a872913a2fbad69188d3f012dd204d97446ff",
    "RawMessage": "Change the return time when destroying entities",
    "Changes": "-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-              rmw_ret = RMW_RET_ERROR;\n+              return RMW_RET_ERROR;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-              rmw_ret = RMW_RET_ERROR;\n+              return RMW_RET_ERROR;\n-            rmw_ret = RMW_RET_ERROR;\n... [truncated] ...\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n-            rmw_ret = RMW_RET_ERROR;\n+            return RMW_RET_ERROR;\n-          rmw_ret = RMW_RET_ERROR;\n+          return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-        rmw_ret = RMW_RET_ERROR;\n+        return RMW_RET_ERROR;\n-      rmw_ret = RMW_RET_ERROR;\n-    }\n-\n-    if (subscriber_info->dds_typesupport != nullptr) {\n-      dds_TypeSupport_delete(subscriber_info->dds_typesupport);\n-      subscriber_info->dds_typesupport = nullptr;\n+      return RMW_RET_ERROR;\n-  rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);\n+  rmw_ret_t rmw_ret = rmw_trigger_guard_condition(node_info->graph_guard_condition);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "f142fd335eaa19a54a449b38c929d3cd37075c63",
    "RawMessage": "Inherit markers from generate_test_description (#330)",
    "Changes": "+import pytest\n+\n-        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n+        module = LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n+        for mark in marks:\n+            decorator = getattr(pytest.mark, mark.name)\n+            decorator = decorator.with_args(*mark.args, **mark.kwargs)\n+            module.add_marker(decorator)\n+        return module",
    "BackportedTo": "galactic",
    "Label": "Test"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "936a5a045de0fb635d8023f198c44baba3f4058e",
    "RawMessage": "add doc section for Zero Copy Data Sharing. (#718)",
    "Changes": "+* [Enable Zero Copy Data Sharing](#enable-zero-copy-data-sharing)\n+### Enable Zero Copy Data Sharing\n+\n+ROS 2 provides [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) that allows the user application to loan the message memory from the RMW implementation to eliminate the copy between the ROS 2 application and RMW implementation.\n+And Fast DDS `rmw_fastrtps_cpp` provides [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) features to speed up the localhost communication.\n+Taking advantage of these features all together, it provides significant performance improvement to ROS 2 application.\n+\n+By default, `rmw_fastrtps_cpp` tries to use [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) for localhost communication along with network communication if the message data type is a bounded type (a fixed sized data object).\n+\n+To enable [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) with `rmw_fastrtps_cpp`, [Plain Old Data](https://en.wikipedia.org/wiki/Passive_data_structure) is the only requirement to `Iron Irwini` or later.\n+For `Humble Hawksbill`, the following XML file needs to be applied to set Fast-DDS `data_sharing` is explicitly enabled. (see more details for https://github.com/ros2/rmw_fastrtps/pull/568)\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\">\n+\n+  <!-- Default publisher profile -->\n+  <data_writer profile_name=\"default publisher profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_writer>\n+\n+  <data_reader profile_name=\"default subscription profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_reader>\n+</profiles>\n+```\n+",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "ros2cli",
    "SHA": "8e46bf2608d04e81a3d088ccc5087dbde9f3e32f",
    "RawMessage": "cosmetic fixes for ros2param dump command. (#933)",
    "Changes": "-    @staticmethod\n-    def get_parameter_values(node, node_name, params):\n-        response = call_get_parameters(\n-            node=node, node_name=node_name,\n-            parameter_names=params)\n-\n-        # requested parameter not set\n-        if not response.values:\n-            return None\n-\n-        # extract type specific value\n-        return [get_value(parameter_value=i) for i in response.values]\n-\n-            # retrieve values\n+            # retrieve parameter names\n-\n-            response = response.result().result.names\n-            response = sorted(response)\n-            parameter_values = self.get_parameter_values(node, absolute_node_name, response)\n-            if parameter_values is None:\n+            parameter_names = sorted(response.result().result.names)\n+\n+            # retrieve parameter values\n+            response = None\n+            try:\n+                response = call_get_parameters(\n+                    node=node, node_name=absolute_node_name, parameter_names=parameter_names)\n+            except RuntimeError as e:\n-\n-            for param_name, pval in zip(response, parameter_values):\n+            if response.values is None:\n+                # pass through here, no parameters are available with this node.\n+                # since this is not failure, it proceeds to print the yaml as consistent behavior.\n+                pass\n+            parameter_values = [get_value(parameter_value=i) for i in response.values]\n+\n+            # create dictionary with parameter names and values\n+            for param_name, pval in zip(parameter_names, parameter_values):",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "5b16dc99f45a85961fb86190629eeec3d9037086",
    "RawMessage": "Added benchmark test to rcl_yaml_param_parser (#803)",
    "Changes": "+  find_package(performance_test_fixture REQUIRED)\n+  # Give cppcheck hints about macro definitions coming from outside this package\n+  get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS\n+    performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n+\n+  add_performance_test(benchmark_parse_yaml test/benchmark/benchmark_parse_yaml.cpp\n+    WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\")\n+  if(TARGET benchmark_parse_yaml)\n+    target_link_libraries(benchmark_parse_yaml ${PROJECT_NAME})\n+    ament_target_dependencies(benchmark_parse_yaml\n+      \"rcpputils\"\n+      \"rcutils\"\n+    )\n+  endif()\n+\n+  add_performance_test(benchmark_variant test/benchmark/benchmark_variant.cpp)\n+  if(TARGET benchmark_variant)\n+    target_link_libraries(benchmark_variant ${PROJECT_NAME})\n+    ament_target_dependencies(benchmark_variant\n+      \"rcutils\"\n+    )\n+  endif()\n+  <test_depend>performance_test_fixture</test_depend>\n+  <test_depend>rcpputils</test_depend>\n+# config/test_yaml\n... [truncated] ...\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+  });\n+  *src_variant.string_array_value = rcutils_get_zero_initialized_string_array();\n+  if (rcutils_string_array_init(src_variant.string_array_value, kSize, &allocator) !=\n+    RCUTILS_RET_OK)\n+  {\n+    st.SkipWithError(rcutils_get_error_string().str);\n+  }\n+  src_variant.string_array_value->size = kSize;\n+  for (size_t i = 0; i < kSize; i++) {\n+    src_variant.string_array_value->data[i] = rcutils_strdup(\"string\", allocator);\n+    if (src_variant.string_array_value->data[i] == NULL) {\n+      st.SkipWithError(rcutils_get_error_string().str);\n+    }\n+  }\n+  reset_heap_counters();\n+\n+  for (auto _ : st) {\n+    if (!rcl_yaml_variant_copy(&dest_variant, &src_variant, allocator)) {\n+      st.SkipWithError(rcutils_get_error_string().str);\n+    }\n+    rcl_yaml_variant_fini(&dest_variant, allocator);\n+    dest_variant.double_array_value = nullptr;\n+  }\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw",
    "SHA": "95ac9726e5fea128d9e825775d3e5eccaf0a0713",
    "RawMessage": "a couple of typo fixes for doc section. (#391)",
    "Changes": "- * \\return RMW_RET_INVALID_ARUGMENT if src and dst are the same object.\n+ * \\return RMW_RET_INVALID_ARGUMENT if src and dst are the same object.\n- * \\param[in] allocator to be used for destruction.",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "41d29851ae06c676a43dba3c3fd27c92089cd6ae",
    "RawMessage": "Executor prepare API (#118)",
    "Changes": "+**rclc_executor_prepare(rclc_executor_t * executor)**\n+\n+The function `rclc_executor_prepare` prepares the internal RCL wait set allocating the required dynamic memory. Its use is optional becouse it also will be checked in the spin functions. If used and no entities are added to the executor during running phase, no dynamic allocations are guaranteed during the running phase.\n-rcl_context_t context;   \n+rcl_context_t context;\n+/**\n+ *  The executor prepare function prepare the waitset of the executor if\n+ *  it is invalid. Does nothing if a valid waitset is already prepared.\n+ *\n+ * Memory is dynamically allocated within rcl-layer, when DDS queue is accessed with rcl_wait_set_init()\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ *\n+ * \\param [inout] executor pointer to initialized executor\n+ * \\return `RCL_RET_OK` if executor prepare operation was successful\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any parameter is a null pointer\n+ * \\return `RCL_RET_ERROR` if any other error occured\n+ */\n... [truncated] ...\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin once\n+  rclc_executor_spin_some(&executor, rclc_test_timeout_ns);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+    // Optional prepare for avoiding allocations during spin\n+    rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "2a760acf6bc774e315aa46c8d80a3b33084fc801",
    "RawMessage": "Update packages to use gurumdds-3.0 & Update README",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+| 3.4.2  or higher         | higher than 3.0.0           |\n-`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n-For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.\n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n-For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n-`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n-If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.\n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.\n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.\n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.\n-~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~  \n+~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~\n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n-This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.\n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.\n-There are three active branches in this project: master, humble and foxy.  \n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n-If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.\n+There are three active branches in this project: master, iron, humble.\n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n+If you want to use this project with ROS2 Rolling Ridley or Iron Irwini, please use master or iron branch, respectively.\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-3.0</build_export_depend>",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rclc",
    "SHA": "41d29851ae06c676a43dba3c3fd27c92089cd6ae",
    "RawMessage": "Executor prepare API (#118)",
    "Changes": "+**rclc_executor_prepare(rclc_executor_t * executor)**\n+\n+The function `rclc_executor_prepare` prepares the internal RCL wait set allocating the required dynamic memory. Its use is optional becouse it also will be checked in the spin functions. If used and no entities are added to the executor during running phase, no dynamic allocations are guaranteed during the running phase.\n-rcl_context_t context;   \n+rcl_context_t context;\n+/**\n+ *  The executor prepare function prepare the waitset of the executor if\n+ *  it is invalid. Does nothing if a valid waitset is already prepared.\n+ *\n+ * Memory is dynamically allocated within rcl-layer, when DDS queue is accessed with rcl_wait_set_init()\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ *\n+ * \\param [inout] executor pointer to initialized executor\n+ * \\return `RCL_RET_OK` if executor prepare operation was successful\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any parameter is a null pointer\n+ * \\return `RCL_RET_ERROR` if any other error occured\n+ */\n... [truncated] ...\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin once\n+  rclc_executor_spin_some(&executor, rclc_test_timeout_ns);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+\n+    // Optional prepare for avoiding allocations during spin\n+    rclc_executor_prepare(&executor);\n+\n+  // Optional prepare for avoiding allocations during spin\n+  rclc_executor_prepare(&executor);\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "c749682ca675be90d81d6f5c6bc58680f46dca5d",
    "RawMessage": "Complete subscription API test coverage (#734)",
    "Changes": "-  <test_depend>mimick_vendor</test_depend>\n-  <test_depend>rcpputils</test_depend>\n-  <test_depend>rmw</test_depend>\n-  <test_depend>rmw_implementation_cmake</test_depend>\n+  <test_depend>mimick_vendor</test_depend>\n+  <test_depend>rcpputils</test_depend>\n+  <test_depend>rmw</test_depend>\n+  <test_depend>rmw_implementation_cmake</test_depend>\n+find_package(mimick_vendor REQUIRED)\n-    LIBRARIES ${PROJECT_NAME}\n+    LIBRARIES ${PROJECT_NAME} mimick\n-  : proxy_(proxy)\n+  : target_(target), proxy_(proxy)\n-    auto MMK_MANGLE(mock_type, create) =\n-      PatchTraits<ID, ReturnT(ArgTs...)>::MMK_MANGLE(mock_type, create);\n-    mock_ = mmk_mock(target.c_str(), mock_type);\n-    auto type_erased_trampoline =\n-      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n-    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+    replace_with(replacement);\n-    auto type_erased_trampoline =\n-      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n-    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+    replace_with(replacement);\n-  mock_type mock_;\n... [truncated] ...\n+  rcl_reset_error();\n+\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID,\n+    rcl_subscription_get_publisher_count(&subscription_zero_init, &publisher_count));\n+  rcl_reset_error();\n-    RCL_RET_SUBSCRIPTION_INVALID, rcl_subscription_get_publisher_count(nullptr, &pub_count));\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_subscription_get_publisher_count(&subscription, nullptr));\n+\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rcl\", rmw_subscription_count_matched_publishers, RMW_RET_ERROR);\n+  EXPECT_EQ(\n+    RCL_RET_ERROR,\n+    rcl_subscription_get_publisher_count(&subscription, &publisher_count));\n+  rcl_reset_error();\n+}\n+\n+/* Using bad arguments subscription methods\n+ */\n+TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscription_bad_argument) {\n-  EXPECT_EQ(\n-    RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_subscription_get_publisher_count(&subscription_zero_init, &pub_count));\n-  rcl_reset_error();",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7d66e479f8717df0fbfac67951c4e2dfdcb25e92",
    "RawMessage": "Remove dead store",
    "Changes": "-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  rmw_ret_t fail_ret = RMW_RET_ERROR;\n+  rmw_ret_t fail_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-\n-  ret = dds_DomainParticipant_get_qos(participant, &qos);\n+  dds_ReturnCode_t ret = dds_DomainParticipant_get_qos(participant, &qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"Can't get domainparticipant qos policies\");\n+    return RMW_RET_ERROR;\n+  }",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "da0133b9b4b148f167617d61fa0115b72beaedf0",
    "RawMessage": "Fix FindGurumDDS.cmake by adding `/usr/lib` path to find_package",
    "Changes": "-    find_package(gurumdds QUIET PATHS /usr /usr/local)\n+    find_package(gurumdds QUIET PATHS /usr /usr/lib /usr/local)",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "0f6b3ad9c78c97d702f8f52b31e7cb46a64b8d35",
    "RawMessage": "Fixed low FPS when sending point markers (#1049)",
    "Changes": "+  auto num_vertices = internals.rend->getBuffer()->getNumVertices();\n+  auto vertex_size =\n+    internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0);\n+\n-      reinterpret_cast<uint8_t *>(float_buffer) +\n-      internals.rend->getBuffer()->getNumVertices() *\n-      internals.rend->getRenderOperation()->vertexData->vertexDeclaration->getVertexSize(0));\n+      reinterpret_cast<uint8_t *>(float_buffer) + num_vertices * vertex_size);",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclc",
    "SHA": "f79db48d62f6f3fa7c706d0f49dedabfa5f9374d",
    "RawMessage": "updating README.md see https://github.com/micro-ROS/micro-ROS.github.io/pull/356 and https://github.com/micro-ROS/micro-ROS.github.io/pull/357",
    "Changes": "-## Table of Contents\n+## Table of contents\n-[Overview](#overview)\n+*   [Introduction](#introduction)\n-[RCLC-Executor](#rclc-executor)\n-  * [Requirement Analysis](#requirement-analysis)\n-    * [Real-time embedded application use-case](#real-time-embedded-application-use-case)\n-    * [Sense-plan-act pipeline in mobile robotics](#sense-plan-act-pipeline-in-mobile-robotics)\n+*   [Analysis of rclcpp standard Executor](#analysis-of-rclcpp-standard-executor)\n+    * [Architecture](#architecture)\n+    * [Scheduling Semantics](#scheduling-semantics)\n+\n+*   [Analysis of processing patterns](#analysis-of-processing-patterns)\n+    * [Sense-plan-act pipeline in robotics](#sense-plan-act-pipeline-in-robotics)\n-  * [Features](#features)\n-    * [Sequential execution](#sequential-execution)\n-    * [Trigger condition](#trigger-condition)\n-    * [LET-Semantics](#let-semantics)\n-  * [Executor API](#executor-api)\n-    * [Configuration](#configuration-phase)\n-    * [Running](#running-phase)\n-    * [Clean-Up](#clean-up)\n-  * [Examples RCLC-Executor](#examples-rclc-executor)\n-    * [Example real-time embedded application use-case](#example-real-time-embedded-application-use-case)\n-    * [Example sense-plan-act pipeline in mobile robotics](#example-sense-plan-act-pipeline-in-mobile-robotics)\n... [truncated] ...\n-## Example RCLC-Executor with convenience functions\n+* [SLD2021]<a name=\"SLD2021\"></a> J. Staschulat, R. Lange and D. N. Dasari, \"Budget-based real-time Executor for Micro-ROS\", arXiv Pre-Print, May 2021. [[paper](https://arxiv.org/abs/2105.05590)] \n+\n+* [L2020]<a name=\"L2020\"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 [[Slides]](https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf)\n+\n+* [SLL2020]<a name=\"SLL2020\"></a> J. Staschulat, I. L\u251c\u255dtkebohle and R. Lange, \"The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress,\" 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. [[Paper]](https://ieeexplore.ieee.org/document/9244014) [[Video]](https://whova.com/embedded/session/eswe_202009/1145800/)\n+\n+* [CB2019]<a name=\"CB2019\"> </a> D. Casini, T. Bla\u251c\u0192, I. L\u251c\u255dtkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. [[Paper]](http://drops.dagstuhl.de/opus/volltexte/2019/10743/) [[slides]](https://t-blass.de/talks/ECRTS2019.pdf)\n+\n+* [L2018]<a name=\"L2018\"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. [[Slides]](https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf) [[Video]](https://vimeo.com/292707644)\n+\n+* [EK2018]<a name=\"EK2018\"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). [[Paper]](http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf)\n+\n+* [NSP2018]<a name=\"NSP2018\"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,\n+Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.\n+\n+* [BP2017]<a name=\"BP2017\"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.[[Paper]](https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf)\n+\n+* [KZH2015]<a name=\"KZH2015\"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.\n+\n+* [HHK2001]<a name=\"HHK2001\"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg\n-An example, how to use the LET Executor with rclc convenience functions is given in the file\n-`example_executor_convenience.c` in the package:\n-[rclc_examples](../rclc_examples).\n+* [LL1973]<a name=\"LL1973\"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 46\u0393\u00c7\u00f461, 1973.",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "abea0e92e3eabfaa1079752d9ac6da352bc590d2",
    "RawMessage": "Fix tf2_geometry_msgs_INCLUDE_DIRS. (#729)",
    "Changes": "+ament_export_include_directories(\"include/${PROJECT_NAME}\")",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "8edb67482dbd96dbdb2919858bdd0dcce4d22bfb",
    "RawMessage": "add test to ensure binary STL files from SOLIDWORKS get imported without a warning (#917)",
    "Changes": "-  if (buffer_str.substr(0, 5) == std::string(\"solid\")) {\n-    // file says that it is ascii, but why should we trust it?\n-\n-    // check for \"endsolid\" as well\n-    if (buffer_str.find(\"endsolid\", 5) != std::string::npos) {\n-      RVIZ_RENDERING_LOG_ERROR_STREAM(\n-        \"The STL file '\" << origin << \"' is malformed. It \"\n-          \"starts with the word 'solid' and also contains the \"\n-          \"word 'endsolid', indicating that it's an ASCII STL \"\n-          \"file, but rviz can only load binary STL files so it \"\n-          \"will not be loaded. Please convert it to a \"\n-          \"binary STL file.\");\n-      return false;\n-    }\n-\n-    // chastise the user for malformed files\n-    RVIZ_RENDERING_LOG_WARNING_STREAM(\n-      \"The STL file '\" << origin << \"' is malformed. It starts \"\n-        \"with the word 'solid', indicating that it's an ASCII \"\n-        \"STL file, but it does not contain the word 'endsolid' so \"\n-        \"it is either a malformed ASCII STL file or it is actually \"\n-        \"a binary STL file. Trying to interpret it as a binary \"\n-        \"STL file instead.\");\n+  if (buffer_str.substr(0, 5) == std::string(\"solid\") &&\n+    buffer_str.find(\"endsolid\", 5) != std::string::npos)\n+  {\n+    RVIZ_RENDERING_LOG_ERROR_STREAM(\n+      \"The STL file '\" << origin << \"' is malformed. It \"\n+        \"starts with the word 'solid' and also contains the \"\n+        \"word 'endsolid', indicating that it's an ASCII STL \"\n+        \"file, but rviz can only load binary STL files so it \"\n+        \"will not be loaded. Please convert it to a \"\n+        \"binary STL file.\");\n+    return false;\n+\n+TEST_F(MeshLoaderTestFixture, loading_solidworks_binary_stl) {\n+  // In general, binary STL files should not start with \"solid\" as this hints ASCII STL files.\n+  // Annoyingly, STL files exported from Solidworks don't follow this guideline and contain\n+  // \"solid\" at the start of binary STL files.\n+  // However, they don't finish with \"endsolid\" like ASCII STL files, so we can still detect\n+  // them as binary STL files.\n+  // This test checks that SOLIDWORKS binary STL files get loaded correctly and don't get treated\n+  // as ASCII STL files.\n+  std::string mesh_path = \"package://rviz_rendering_tests/test_meshes/solidworks.stl\";\n+\n+  ASSERT_TRUE(rviz_rendering::loadMeshFromResource(mesh_path));\n+}",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rcutils",
    "SHA": "2783b61df5fcf586395cebc779a1ab9267d372ba",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* Cleanup error handling in rcutils. (`#485 <https://github.com/ros2/rcutils/issues/485>`_)\n+* Remove CODEOWNERS and mirror-rolling-to-master workflow. (`#483 <https://github.com/ros2/rcutils/issues/483>`_)\n+* Contributors: Chris Lalancette\n+",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "6d3a10a660fac7073bdf24ca37c7d4d21ddd434d",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#75)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @ivanpauno",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcutils",
    "SHA": "b6ba6a1f1ef243bcb8a418ddfa7aaf09b92564d1",
    "RawMessage": "Fix if(TARGET ...) condition for test (#447)",
    "Changes": "-  if(TARGET test_shared_library_in_load_paths)\n+  if(TARGET test_shared_library_preloaded)",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "geometry2",
    "SHA": "381d381739d008f83c2ebdf39034d46a19ea364e",
    "RawMessage": "Add cache_benchmark (#679)",
    "Changes": "+  find_package(ament_cmake_google_benchmark REQUIRED)\n+  ament_add_google_benchmark(cache_benchmark test/cache_benchmark.cpp)\n+  if(TARGET cache_benchmark)\n+    target_link_libraries(cache_benchmark tf2)\n+  endif()\n+\n+  <test_depend>ament_cmake_google_benchmark</test_depend>\n+// Copyright 2024, Open Source Robotics Foundation, Inc. All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the Open Source Robotics Foundation, Inc. nor the\n+//      names of its contributors may be used to endorse or promote products\n+//      derived from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n... [truncated] ...\n+  // First, fill the cache with max storage amount (the limit).\n+  tf2::TimeCache fill_cache(max_storage_time);\n+  const auto [fill_timestamp, fill_timestep] = insert_data(\n+      fill_cache,\n+      tf2::TimePointZero,\n+      0,\n+      tf2::TimePointZero + max_storage_time);\n+\n+  // Now profile adding new data to the copied cache.\n+  const tf2::TimePoint target_timestamp = fill_timestamp + max_storage_time;\n+  for (auto _ : state) {\n+    // Don't profile construction (copying) of the cache.\n+    state.PauseTiming();\n+    tf2::TimeCache cache(fill_cache);\n+    state.ResumeTiming();\n+\n+    insert_data(\n+        cache,\n+        fill_timestamp,\n+        fill_timestep,\n+        target_timestamp);\n+  }\n+}\n+\n+BENCHMARK(benchmark_insertion);",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "geometry2",
    "SHA": "6b18a40056708c6f3acaafc08352b14554e33962",
    "RawMessage": "Drop PyKDL dependency in tf2_geometry_msgs (#509)",
    "Changes": "-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# ament_python_install_package(${PROJECT_NAME}\n-#      PACKAGE_DIR src/${PROJECT_NAME})\n-\n-# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n-# install(PROGRAMS scripts/test.py\n-#    DESTINATION lib/${PROJECT_NAME}\n-# )\n+ament_python_install_package(${PROJECT_NAME}\n+  PACKAGE_DIR src/${PROJECT_NAME})\n+  find_package(ament_cmake_pytest REQUIRED)\n+  ament_add_pytest_test(test_tf2_geometry_msgs_py test/test_tf2_geometry_msgs.py)\n+\n-  <!-- python support not yet ported\n-  <build_depend>python_orocos_kdl</build_depend>\n-\n-  <exec_depend>python_orocos_kdl</exec_depend>\n-  -->\n-\n+  <exec_depend>python3-numpy</exec_depend>\n+  <test_depend>ament_cmake_pytest</test_depend>\n+[pytest]\n+junit_family=xunit2\n-from geometry_msgs.msg import (PointStamped, PoseStamped,\n-                               PoseWithCovarianceStamped, Vector3Stamped)\n... [truncated] ...\n+    :param pose: The pose with covariance stamped\n+    :param transform: The transform\n+    :returns: The transformed pose with covariance stamped\n+    \"\"\"\n-    res.pose.pose.position.x = f.p[0]\n-    res.pose.pose.position.y = f.p[1]\n-    res.pose.pose.position.z = f.p[2]\n-    (res.pose.pose.orientation.x,\n-     res.pose.pose.orientation.y,\n-     res.pose.pose.orientation.z,\n-     res.pose.pose.orientation.w) = f.M.GetQuaternion()\n+    res.pose.pose = do_transform_pose(pose.pose.pose, transform)\n-#!/usr/bin/env python3\n-\n-        self.assertEqual(out.pose.covariance, v.pose.covariance)\n-        self.assertEqual(out.pose.orientation.x, 0)\n-        self.assertEqual(out.pose.orientation.y, 0)\n-        self.assertEqual(out.pose.orientation.z, 0)\n-        self.assertEqual(out.pose.orientation.w, 1)\n+        self.assertEqual(out.pose.pose.orientation.x, 0)\n+        self.assertEqual(out.pose.pose.orientation.y, 0)\n+        self.assertEqual(out.pose.pose.orientation.z, 0)\n+        self.assertEqual(out.pose.pose.orientation.w, 1)\n-    unittest.main()\n+  <exec_depend>sensor_msgs</exec_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "e06969487b81d97745f7c2da16372075ef153c1f",
    "RawMessage": "Set error status when duplicate markers are in the same MarkerArray (#891)",
    "Changes": "+#include <set>\n+#include <sstream>\n+  using ns_type = decltype(visualization_msgs::msg::Marker::ns);\n+  using id_type = decltype(visualization_msgs::msg::Marker::id);\n+  using pair_type = std::pair<id_type, const ns_type &>;\n+\n+  // Keep track of unique markers\n+  std::set<pair_type> unique_markers;\n+  bool found_duplicate = false;\n+  std::string offending_ns;\n+  id_type offending_id = 0;\n+\n+    if (!found_duplicate) {\n+      pair_type pair(marker.id, marker.ns);\n+      found_duplicate = !unique_markers.insert(pair).second;\n+      if (found_duplicate) {\n+        offending_ns = marker.ns;\n+        offending_id = marker.id;\n+      }\n+    }\n+\n+  // Can't use setMarkerStatus on individual markers because processAdd would clear it.\n+  const char * kDuplicateStatus = \"Duplicate Marker Check\";\n+  if (found_duplicate) {\n+    std::stringstream error_stream;\n+    error_stream << \"Multiple Markers in the same MarkerArray message had the same ns and id: \";\n+    error_stream << \"(\" << offending_ns << \", \" << offending_id << \")\";\n+    display_->setStatusStd(\n+      rviz_common::properties::StatusProperty::Error,\n+      kDuplicateStatus,\n+      error_stream.str());\n+  } else {\n+    display_->deleteStatusStd(kDuplicateStatus);\n+  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "392f0d3ae6a29d4b88689b954b14f19716e44233",
    "RawMessage": "Fix buffer overflow in argument parsing caused by lexer returning length beyond length of string (#979)",
    "Changes": "+ * It will never be longer than the length of the string.\n-    // Move the lexer to another character in the string\n-      // Go forwards 1 char\n-      ++(*length);\n+      if ('\\0' != current_char) {\n+        // Go forwards 1 char as long as the end hasn't been reached\n+        ++(*length);\n+      }\n+  if (RCL_LEXEME_NONE == *next_type1 || RCL_LEXEME_EOF == *next_type1) {\n+    // No need to peek further\n+    *next_type2 = *next_type1;\n+    return ret;\n+  }\n+\n-    std::string actual_text(text, length); \\\n+    std::string actual_text(text, 0u, length); \\\n+    EXPECT_EQ(length, actual_text.size()); \\\n+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_no_lexeme)\n+{\n+  rcl_ret_t ret;\n+  rcl_lexer_lookahead2_t buffer;\n+  SCOPE_LOOKAHEAD2(buffer, \"~foo\");\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n... [truncated] ...\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n+\n+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme1);\n+  EXPECT_EQ(RCL_LEXEME_NONE, lexeme2);\n+}\n+\n+TEST_F(CLASSNAME(TestLexerLookaheadFixture, RMW_IMPLEMENTATION), test_peek2_eof)\n+{\n+  rcl_ret_t ret;\n+  rcl_lexer_lookahead2_t buffer;\n+  SCOPE_LOOKAHEAD2(buffer, \"\");\n+\n+  rcl_lexeme_t lexeme1 = RCL_LEXEME_NONE;\n+  rcl_lexeme_t lexeme2 = RCL_LEXEME_NONE;\n+\n+  ret = rcl_lexer_lookahead2_peek2(&buffer, &lexeme1, &lexeme2);\n+  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme1);\n+  EXPECT_EQ(RCL_LEXEME_EOF, lexeme2);\n+}\n+",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "94b1784388c554d1fc4258328a98ea6b65df5309",
    "RawMessage": "Updated error returns on rmw_take (#432)",
    "Changes": "-  if (subscription->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"publisher handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n-  if (subscription->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"publisher handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    subscription, \"subscription pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    ros_message, \"ros_message pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(taken, \"boolean flag for taken is null\", return RMW_RET_ERROR);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n... [truncated] ...\n+    RMW_SET_ERROR_MSG(\"count cannot be 0\");\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n-    return RMW_RET_ERROR;\n+    return RMW_RET_INVALID_ARGUMENT;\n-    return RMW_RET_ERROR;\n+    return RMW_RET_INVALID_ARGUMENT;\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    subscription, \"subscription pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    ros_message, \"ros_message pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(taken, \"boolean flag for taken is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    message_info, \"message info pointer is null\", return RMW_RET_ERROR);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_info, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    ros_message, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "e4b02b0759e98d4a788ceb6632729f1b3d47257d",
    "RawMessage": "Update graph API return codes. (#436)",
    "Changes": "+#include \"rmw/impl/cpp/macros.hpp\"\n+#include \"rmw/validate_full_topic_name.h\"\n-  if (!node) {\n-    RMW_SET_ERROR_MSG(\"null node handle\");\n-    return RMW_RET_INVALID_ARGUMENT;\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);\n+  int validation_result = RMW_TOPIC_VALID;\n+  rmw_ret_t ret = rmw_validate_full_topic_name(topic_name, &validation_result, nullptr);\n+  if (RMW_RET_OK != ret) {\n+    return ret;\n-  if (node->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"node handle not from this implementation\");\n+  if (RMW_TOPIC_VALID != validation_result) {\n+    const char * reason = rmw_full_topic_name_validation_result_string(validation_result);\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"topic_name argument is invalid: %s\", reason);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);\n-  if (!node) {\n-    RMW_SET_ERROR_MSG(\"null node handle\");\n-    return RMW_RET_INVALID_ARGUMENT;\n... [truncated] ...\n-    return RMW_RET_ERROR;\n-  }\n-  if (!allocator) {\n-    RMW_SET_ERROR_MSG(\"allocator is null\");\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n+    allocator, \"allocator argument is invalid\", return RMW_RET_INVALID_ARGUMENT);\n+  if (RMW_RET_OK != rmw_names_and_types_check_zero(topic_names_and_types)) {\n-  if (!node) {\n-    RMW_SET_ERROR_MSG(\"null node handle\");\n-    return RMW_RET_INVALID_ARGUMENT;\n-  }\n-  rmw_ret_t ret = rmw_names_and_types_check_zero(topic_names_and_types);\n-  if (ret != RMW_RET_OK) {\n-    return ret;\n-  }\n-  if (node->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"node handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "c624e5b4ce88f401c3d7b4636b6f6bb8565142ec",
    "RawMessage": "Remove unnecessary includes (#487)",
    "Changes": "-#include \"fastrtps/rtps/RTPSDomain.h\"\n-#include \"fastrtps/rtps/builtin/discovery/endpoint/EDPSimple.h\"\n-#include \"fastrtps/rtps/reader/ReaderListener.h\"\n-#include \"fastrtps/rtps/reader/RTPSReader.h\"\n-#include \"fastrtps/rtps/reader/StatefulReader.h\"\n-using StatefulReader = eprosima::fastrtps::rtps::StatefulReader;\n-  ParticipantAttributes participantAttrs,\n+  const ParticipantAttributes & participantAttrs,",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "8edb67482dbd96dbdb2919858bdd0dcce4d22bfb",
    "RawMessage": "add test to ensure binary STL files from SOLIDWORKS get imported without a warning (#917)",
    "Changes": "-  if (buffer_str.substr(0, 5) == std::string(\"solid\")) {\n-    // file says that it is ascii, but why should we trust it?\n-\n-    // check for \"endsolid\" as well\n-    if (buffer_str.find(\"endsolid\", 5) != std::string::npos) {\n-      RVIZ_RENDERING_LOG_ERROR_STREAM(\n-        \"The STL file '\" << origin << \"' is malformed. It \"\n-          \"starts with the word 'solid' and also contains the \"\n-          \"word 'endsolid', indicating that it's an ASCII STL \"\n-          \"file, but rviz can only load binary STL files so it \"\n-          \"will not be loaded. Please convert it to a \"\n-          \"binary STL file.\");\n-      return false;\n-    }\n-\n-    // chastise the user for malformed files\n-    RVIZ_RENDERING_LOG_WARNING_STREAM(\n-      \"The STL file '\" << origin << \"' is malformed. It starts \"\n-        \"with the word 'solid', indicating that it's an ASCII \"\n-        \"STL file, but it does not contain the word 'endsolid' so \"\n-        \"it is either a malformed ASCII STL file or it is actually \"\n-        \"a binary STL file. Trying to interpret it as a binary \"\n-        \"STL file instead.\");\n+  if (buffer_str.substr(0, 5) == std::string(\"solid\") &&\n+    buffer_str.find(\"endsolid\", 5) != std::string::npos)\n+  {\n+    RVIZ_RENDERING_LOG_ERROR_STREAM(\n+      \"The STL file '\" << origin << \"' is malformed. It \"\n+        \"starts with the word 'solid' and also contains the \"\n+        \"word 'endsolid', indicating that it's an ASCII STL \"\n+        \"file, but rviz can only load binary STL files so it \"\n+        \"will not be loaded. Please convert it to a \"\n+        \"binary STL file.\");\n+    return false;\n+\n+TEST_F(MeshLoaderTestFixture, loading_solidworks_binary_stl) {\n+  // In general, binary STL files should not start with \"solid\" as this hints ASCII STL files.\n+  // Annoyingly, STL files exported from Solidworks don't follow this guideline and contain\n+  // \"solid\" at the start of binary STL files.\n+  // However, they don't finish with \"endsolid\" like ASCII STL files, so we can still detect\n+  // them as binary STL files.\n+  // This test checks that SOLIDWORKS binary STL files get loaded correctly and don't get treated\n+  // as ASCII STL files.\n+  std::string mesh_path = \"package://rviz_rendering_tests/test_meshes/solidworks.stl\";\n+\n+  ASSERT_TRUE(rviz_rendering::loadMeshFromResource(mesh_path));\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "af438bcca1ffb69714c0b225ba0f80aceab04906",
    "RawMessage": "Reformat rmw_impl_id_check to call a testable function (#725)",
    "Changes": "+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCL__RMW_IMPLEMENTATION_IDENTIFIER_CHECK_H_\n+#define RCL__RMW_IMPLEMENTATION_IDENTIFIER_CHECK_H_\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"rcl/visibility_control.h\"\n+\n+#define RMW_IMPLEMENTATION_ENV_VAR_NAME \"RMW_IMPLEMENTATION\"\n... [truncated] ...\n+  // Fail test case, reason: RMW_IMPLEMENTATION_ENV_VAR_NAME set, not matching rmw impl\n+  EXPECT_TRUE(rcutils_set_env(RMW_IMPLEMENTATION_ENV_VAR_NAME, \"\"));\n+  EXPECT_TRUE(rcutils_set_env(RCL_ASSERT_RMW_ID_MATCHES_ENV_VAR_NAME, \"some_random_name\"));\n+  EXPECT_EQ(RCL_RET_MISMATCHED_RMW_ID, rcl_rmw_implementation_identifier_check());\n+  EXPECT_TRUE(rcl_error_is_set());\n+  rcl_reset_error();\n+\n+  // Fail test case, reason: env variables not equal\n+  EXPECT_TRUE(rcutils_set_env(RMW_IMPLEMENTATION_ENV_VAR_NAME, \"some_random_name\"));\n+  EXPECT_TRUE(rcutils_set_env(RCL_ASSERT_RMW_ID_MATCHES_ENV_VAR_NAME, \"diff_random\"));\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_rmw_implementation_identifier_check());\n+  EXPECT_TRUE(rcl_error_is_set());\n+  rcl_reset_error();\n+\n+  // Fail test case, reason: equal env variables do not match rmw impl\n+  EXPECT_TRUE(rcutils_set_env(RCL_ASSERT_RMW_ID_MATCHES_ENV_VAR_NAME, \"some_random_name\"));\n+  EXPECT_TRUE(rcutils_set_env(RCL_ASSERT_RMW_ID_MATCHES_ENV_VAR_NAME, \"some_random_name\"));\n+  EXPECT_EQ(RCL_RET_MISMATCHED_RMW_ID, rcl_rmw_implementation_identifier_check());\n+  EXPECT_TRUE(rcl_error_is_set());\n+  rcl_reset_error();\n+\n+  // Restore env variables set in the test\n+  EXPECT_TRUE(rcutils_set_env(RMW_IMPLEMENTATION_ENV_VAR_NAME, get_env_var_name));\n+  EXPECT_TRUE(rcutils_set_env(RCL_ASSERT_RMW_ID_MATCHES_ENV_VAR_NAME, get_env_id_matches_name));\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "realtime_support",
    "SHA": "9390dd1a81a4c4299a57cfe01b8ac33bc77352ca",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#127)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @methylDragon",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rclpy",
    "SHA": "ba7c99158dcf57867c0a79665f80a85b48adc934",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* add QoS Profile/Depth support to Node. (`#1376 <https://github.com/ros2/rclpy/issues/1376>`_)\n+* Various typing fixes (`#1402 <https://github.com/ros2/rclpy/issues/1402>`_)\n+* Add types to Action with rhel roscli fix (`#1361 <https://github.com/ros2/rclpy/issues/1361>`_)\n+* Check if Task(Future) is canceled. (`#1377 <https://github.com/ros2/rclpy/issues/1377>`_)\n+* Executors types (`#1370 <https://github.com/ros2/rclpy/issues/1370>`_)\n+* event_handler.py types (`#1340 <https://github.com/ros2/rclpy/issues/1340>`_)\n+* Contributors: Michael Carlstrom, Nadav Elkabets, Tomoya Fujita\n+",
    "BackportedTo": "foxy",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "2a760acf6bc774e315aa46c8d80a3b33084fc801",
    "RawMessage": "Update packages to use gurumdds-3.0 & Update README",
    "Changes": "-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n+Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n+| 3.4.2  or higher         | higher than 3.0.0           |\n-`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.  \n-For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.  \n+`gurumdds_cmake_module` looks for GurumDDS, and provides the information to other packages.\n+For `gurumdds_cmake_module` to work properly, you need to set `GURUMDDS_HOME` environment variable to where GurumDDS is located.\n-`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.  \n-For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.   \n-`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.  \n-If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n+`rmw_gurumdds_cpp` is the rmw implementation. You can use this rmw implementation by setting environment variable `RMW_IMPLEMENTATION=rmw_gurumdds_cpp` after installation.\n+For `rmw_gurumdds_cpp` to work properly, make sure to set environment variable `GURUMDDS_CONFIG=~/gurumdds.yaml` and set `allow_loopback` variable in `gurumdds.yaml` to `true`.\n+`gurumdds.yaml` will be located in `/etc/gurumnet/gurumdds` if gurumdds is installed through the debian package.\n+If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.\n-~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~  \n+~~`rmw_gurumdds_shared_cpp` contains some functions used by `rmw_gurumdds_cpp`.~~\n-`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.  \n-This demo shows how to access the native handles of `rmw_gurumdds_cpp`.  \n+`demo_nodes_cpp_natvie_gurumdds` is similar to `demo_nodes_cpp_native` from ROS2 `demos`.\n+This demo shows how to access the native handles of `rmw_gurumdds_cpp`.\n-There are three active branches in this project: master, humble and foxy.  \n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n-If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.\n+There are three active branches in this project: master, iron, humble.\n+New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n+If you want to use this project with ROS2 Rolling Ridley or Iron Irwini, please use master or iron branch, respectively.\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_depend>gurumdds-2.8</build_depend>\n+  <build_depend>gurumdds-3.0</build_depend>\n-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend>gurumdds-3.0</build_export_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "ed449a5813cedd26d0d23b819be7aa489c982418",
    "RawMessage": "Fix bug error handling get_param_files (#743)",
    "Changes": "-        if (NULL == (*parameter_files[r])) {\n-          break;\n-        }\n-        allocator.deallocate((*parameter_files[r]), allocator.state);\n+        allocator.deallocate((*parameter_files)[r], allocator.state);\n+typedef struct time_bomb_allocator_state\n+{\n+  int count_until_failure;\n+} time_bomb_allocator_state;\n+\n+static void * time_bomb_malloc(size_t size, void * state)\n+{\n+  time_bomb_allocator_state * time_bomb_state = (time_bomb_allocator_state *)state;\n+  if (time_bomb_state->count_until_failure >= 0 &&\n+    time_bomb_state->count_until_failure-- == 0)\n+  {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().allocate(size, rcutils_get_default_allocator().state);\n+}\n+\n+static void *\n+time_bomb_realloc(void * pointer, size_t size, void * state)\n+{\n+  time_bomb_allocator_state * time_bomb_state = (time_bomb_allocator_state *)state;\n... [truncated] ...\n+  rcl_ret_t ret = rcl_parse_arguments(argc, argv, rcl_get_default_allocator(), &parsed_args);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RCL_RET_OK, rcl_arguments_fini(&parsed_args));\n+  });\n+\n+  int parameter_filecount = rcl_arguments_get_param_files_count(&parsed_args);\n+  EXPECT_EQ(2, parameter_filecount);\n+\n+  // Configure allocator to fail at different points of the code\n+  rcl_allocator_t bomb_alloc = get_time_bombed_allocator();\n+  set_time_bombed_allocator_count(bomb_alloc, 0);\n+  char ** parameter_files = NULL;\n+  ret = rcl_arguments_get_param_files(&parsed_args, bomb_alloc, &parameter_files);\n+  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret) << rcl_get_error_string().str;\n+\n+  set_time_bombed_allocator_count(bomb_alloc, 1);\n+  ret = rcl_arguments_get_param_files(&parsed_args, bomb_alloc, &parameter_files);\n+  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret) << rcl_get_error_string().str;\n+\n+  set_time_bombed_allocator_count(bomb_alloc, 2);\n+  ret = rcl_arguments_get_param_files(&parsed_args, bomb_alloc, &parameter_files);\n+  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret) << rcl_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "1b4795f57731495c1f69bcb6354bdc36161496d2",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+\n+Forthcoming\n+-----------\n+* Add deprecation warning for FASTRTPS_DEFAULT_PROFILES_FILE (`#806 <https://github.com/ros2/rmw_fastrtps/issues/806>`_)\n+* Contributors: Carlos Espinoza Curto\n+",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "launch_ros",
    "SHA": "f9ab9371824d470bca47602bc7d277eb2217c90d",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#426)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @adityapande-1995 @methylDragon",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "092e3efef2f907549976ffd101e5ad8100cbea3f",
    "RawMessage": "Remove warning in depth_cloud_mld.cpp (#1021)",
    "Changes": "-        *cloud_data_ptr = *reinterpret_cast<float *>(&color);\n+        float ret;\n+        std::memcpy(&ret, &color, sizeof(float));\n+        *cloud_data_ptr = ret;\n-        *cloud_data_ptr = *reinterpret_cast<float *>(&color);\n+        float ret;\n+        std::memcpy(&ret, &color, sizeof(float));\n+        *cloud_data_ptr = ret;",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "edb63764c39993645fd6bc7e0fc31ed7316f0b45",
    "RawMessage": "Fix url in setup.py (#413)",
    "Changes": "-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch/tree/master/ros2launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b9930c17d63328ed38554b0a19950adafde8e510",
    "RawMessage": "Fix rclcpp test(test_serialized_message) failure",
    "Changes": "+    serialized_message->buffer_capacity = size;",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "22297618b040a20ec496a06247b855714a4e01f6",
    "RawMessage": "Remove sleep before fill tnat",
    "Changes": "-#include <chrono>\n-#include <thread>\n-  std::this_thread::sleep_for(std::chrono::microseconds(100));",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "7d66e479f8717df0fbfac67951c4e2dfdcb25e92",
    "RawMessage": "Remove dead store",
    "Changes": "-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-  rmw_ret_t rmw_ret = RMW_RET_OK;\n+  dds_ReturnCode_t ret;\n+  rmw_ret_t rmw_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n+  dds_ReturnCode_t ret;\n-  rmw_ret_t fail_ret = RMW_RET_ERROR;\n+  rmw_ret_t fail_ret;\n-  dds_ReturnCode_t ret = dds_RETCODE_OK;\n-\n-  ret = dds_DomainParticipant_get_qos(participant, &qos);\n+  dds_ReturnCode_t ret = dds_DomainParticipant_get_qos(participant, &qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"Can't get domainparticipant qos policies\");\n+    return RMW_RET_ERROR;\n+  }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "8dc9f8a5f6f39ba0fc9ec784e6d8f93e70d3a9fa",
    "RawMessage": "Make Axes display use latest transform (#892)",
    "Changes": "-      frame, context_->getClock()->now(), position, orientation))\n+      frame, position, orientation))",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "ebf54352606df837715bc4992c502449a1596efa",
    "RawMessage": "Fix the flakey rviz_rendering tests (#1026)",
    "Changes": "+    visual->setWidth(width_property_->getFloat());\n+    visual->setScale(scale_property_->getFloat());\n-      context_->getSceneManager(), scene_node_);\n+      context_->getSceneManager(), scene_node_,\n+      width_property_->getFloat(), scale_property_->getFloat());\n-  visual->setWidth(width_property_->getFloat());\n-  visual->setScale(scale_property_->getFloat());\n+#include <memory>\n-  EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node);\n+  EffortVisual(\n+    Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node, float width, float scale);\n-  std::map<std::string, rviz_rendering::BillboardLine *> effort_circle_;\n-  std::map<std::string, rviz_rendering::Arrow *> effort_arrow_;\n+  std::map<std::string, std::unique_ptr<rviz_rendering::BillboardLine>> effort_circle_;\n+  std::map<std::string, std::unique_ptr<rviz_rendering::Arrow>> effort_arrow_;\n- #define _USE_MATH_DEFINES\n+#define _USE_MATH_DEFINES\n-EffortVisual::EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node)\n-: scene_manager_(scene_manager), parent_node_(parent_node)\n+EffortVisual::EffortVisual(\n+  Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node, float width, float scale)\n+: scene_manager_(scene_manager), parent_node_(parent_node), width_(width), scale_(scale)\n-  if (effort_circle_.find(joint_name) != effort_circle_.end() && !enabled) {  // enable->disable\n-    delete (effort_circle_[joint_name]);\n-    delete (effort_arrow_[joint_name]);\n... [truncated] ...\n+  for (Ogre::SceneNode * arrow : arrows) {\n-\n-  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(\n+    scene_manager, root_node, 0.0f, 0.0f);\n+  ASSERT_NE(nullptr, effort_visual);\n+  effort_visual->setFramePosition(\"joint1\", Ogre::Vector3(0, 0, 0));\n+  effort_visual->setFrameOrientation(\"joint1\", Ogre::Quaternion());\n-  effort_visual->setFramePosition(\"joint1\", Ogre::Vector3());\n-  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  std::vector<Ogre::SceneNode *> arrows = rviz_rendering::findAllArrows(root_node);\n-  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(\n+    scene_manager, root_node, 5.0f, 0.7f);\n+  ASSERT_NE(nullptr, effort_visual);\n-  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setFramePosition(\"joint1\", Ogre::Vector3(0, 0, 0));\n+  effort_visual->setFrameOrientation(\"joint1\", Ogre::Quaternion());\n-  effort_visual->setScale(0.7f);\n-  effort_visual->setWidth(5);\n-\n-  EXPECT_NE(nullptr, screw_visual);\n+  ASSERT_NE(nullptr, screw_visual);\n-  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  std::vector<Ogre::SceneNode *> arrows = rviz_rendering::findAllArrows(root_node);",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "10eeb04321ffc391df6b35e9ceed55a49f391a1f",
    "RawMessage": "Add test to check rmw_send_response when the client is gone (#162)",
    "Changes": "+\n+TEST_F(CLASSNAME(TestService, RMW_IMPLEMENTATION), send_reponse_with_client_gone) {\n+  constexpr char service_name[] = \"/test\";\n+  const rosidl_service_type_support_t * ts =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n+  test_msgs__srv__BasicTypes_Response service_response;\n+  ASSERT_TRUE(test_msgs__srv__BasicTypes_Response__init(&service_response));\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__srv__BasicTypes_Response__fini(&service_response);\n+  });\n+  service_response.bool_value = false;\n+  service_response.uint8_value = 1;\n+  service_response.uint32_value = 2;\n+  test_msgs__srv__BasicTypes_Request request;\n+  ASSERT_TRUE(test_msgs__srv__BasicTypes_Request__init(&request));\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__srv__BasicTypes_Request__fini(&request);\n+  });\n+  request.bool_value = false;\n+  request.uint8_value = 1;\n+  request.uint32_value = 2;\n+  int64_t sequence_number;\n+  rmw_service_info_t header;\n... [truncated] ...\n+  srv_array.service_count = 1u;\n+  srv_array.services = array;\n+  rmw_time_t timeout;\n+  auto rmw_intraprocess_discovery_delay_in_nanoseconds =\n+    std::chrono::duration_cast<std::chrono::nanoseconds>(\n+    rmw_intraprocess_discovery_delay * 10).count();\n+  timeout.sec = rmw_intraprocess_discovery_delay_in_nanoseconds / 1000000000;\n+  timeout.nsec = rmw_intraprocess_discovery_delay_in_nanoseconds % 1000000000;\n+  ret = rmw_wait(nullptr, nullptr, &srv_array, nullptr, nullptr, wait_set, &timeout);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  ASSERT_NE(nullptr, srv_array.services[0]);\n+\n+  bool taken = false;\n+  ret = rmw_take_request(srv, &header, &request, &taken);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  ASSERT_EQ(true, taken);\n+\n+  // Remove client\n+  ret = rmw_destroy_client(node, client);\n+  destroy_client = false;\n+\n+  // RMW_RET_OK is returned even if the client is gone\n+  ret = rmw_send_response(srv, &header.request_id, &service_response);\n+  EXPECT_EQ(RMW_RET_OK, ret);\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "19f0456d8c2e728751ec70a46f846d8037be515e",
    "RawMessage": "Fix init options handling (#202) (#205)",
    "Changes": "+  if (rcl_init_options_fini(&init_options) != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(rclc_support_init, rcl_init_options_fini);\n+  }\n-  memcpy(&support->init_options, init_options, sizeof(rcl_init_options_t));\n+  support->init_options = rcl_get_zero_initialized_init_options();\n+  rc = rcl_init_options_copy(init_options, &support->init_options);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(rclc_init, rcl_init_options_copy);\n+    return rc;\n+  }",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "933ec536fd04e4617b9cc32626e338edc5cb0f5a",
    "RawMessage": "Fix #983 by saving future and checking for + raising any exceptions (#1073)",
    "Changes": "+        self._futures = []\n+            self._futures.append(handler)\n+            for future in self._futures:  # check for any exceptions\n+                if future.done():\n+                    self._futures.remove(future)\n+                    future.result()",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "35d6abd50a55181099aab82134fc507d8fd162bd",
    "RawMessage": "replace removeprefix with string slicing. (#953)",
    "Changes": "-                        fdlimit = int(line.removeprefix(string_to_find).strip())\n+                        fdlimit = int(line[len(string_to_find):].strip())",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "c15ad3c8a6f1095f2a60d2d943b8e0f50b30c179",
    "RawMessage": "Add tests take with info bad arguments (#126)",
    "Changes": "+  find_package(rmw_dds_common REQUIRED)\n-      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation test_msgs rmw_dds_common\n+  <test_depend>rmw_dds_common</test_depend>\n-\n+#include \"rmw_dds_common/gid_utils.hpp\"\n+\n+using rmw_dds_common::operator==;\n+\n+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_with_info_with_bad_args) {\n+  bool taken = false;\n+  test_msgs__msg__BasicTypes output_message{};\n+  output_message.bool_value = true;\n+  output_message.char_value = 'a';\n+  output_message.float32_value = 0.42f;\n+  test_msgs__msg__BasicTypes original_message = output_message;\n+  rmw_message_info_t message_info = rmw_get_zero_initialized_message_info();\n+  rmw_message_info_t original_info = rmw_get_zero_initialized_message_info();\n+  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n+\n+  rmw_ret_t ret = rmw_take_with_info(\n+    nullptr, &output_message, &taken, &message_info,\n+    null_allocation);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(output_message, original_message);\n... [truncated] ...\n+\n+bool operator==(const test_msgs__msg__BasicTypes & m1, const test_msgs__msg__BasicTypes & m2)\n+{\n+  return m1.bool_value == m2.bool_value &&\n+         m1.byte_value == m2.byte_value &&\n+         m1.char_value == m2.char_value &&\n+         m1.float32_value == m2.float32_value &&\n+         m1.float64_value == m2.float64_value &&\n+         m1.int8_value == m2.int8_value &&\n+         m1.uint8_value == m2.uint8_value &&\n+         m1.int16_value == m2.int16_value &&\n+         m1.uint16_value == m2.uint16_value &&\n+         m1.int32_value == m2.int32_value &&\n+         m1.uint32_value == m2.uint32_value &&\n+         m1.int64_value == m2.int64_value &&\n+         m1.uint64_value == m2.uint64_value;\n+}\n+\n+bool operator==(const rmw_message_info_t & m1, const rmw_message_info_t & m2)\n+{\n+  return m1.publisher_gid == m2.publisher_gid &&\n+         m1.source_timestamp == m2.source_timestamp &&\n+         m1.received_timestamp == m2.received_timestamp &&\n+         m1.from_intra_process == m2.from_intra_process;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "67ecc85f2d55a4b4ea1c7a038063913067ad9b8b",
    "RawMessage": "Move rcl_remap_copy to public header (#709)",
    "Changes": "+/// Copy one remap structure into another.\n+/**\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param[in] rule The structure to be copied.\n+ *  Its allocator is used to copy memory into the new structure.\n+ * \\param[out] rule_out A zero-initialized rcl_remap_t structure to be copied into.\n+ * \\return `RCL_RET_OK` if the structure was copied successfully, or\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or\n+ * \\return `RCL_RET_BAD_ALLOC` if allocating memory failed, or\n+ * \\return `RCL_RET_ERROR` if an unspecified error occurs.\n+ */\n+RCL_PUBLIC\n+RCL_WARN_UNUSED\n+rcl_ret_t\n+rcl_remap_copy(\n+  const rcl_remap_t * rule,\n+  rcl_remap_t * rule_out);\n+\n... [truncated] ...\n+  });\n+\n+  // Bad alloc\n+  rcl_remap_t remap_dst = rcl_get_zero_initialized_remap();\n+  parsed_args.impl->remap_rules->impl->allocator = get_failing_allocator();\n+  EXPECT_EQ(RCL_RET_BAD_ALLOC, rcl_remap_copy(parsed_args.impl->remap_rules, &remap_dst));\n+  parsed_args.impl->remap_rules->impl->allocator = alloc;\n+\n+  // Expected usage\n+  EXPECT_EQ(RCL_RET_OK, rcl_remap_copy(parsed_args.impl->remap_rules, &remap_dst));\n+\n+  // Copy twice\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_remap_copy(parsed_args.impl->remap_rules, &remap_dst));\n+  rcl_reset_error();\n+\n+  // Fini\n+  EXPECT_EQ(RCL_RET_OK, rcl_remap_fini(&remap_dst));\n+\n+  // Fini twice\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_remap_fini(&remap_dst));\n+  rcl_reset_error();\n+\n+  // Bad fini\n+  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_remap_fini(nullptr));\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e59034d3671b178aa2861a9300a097436a92696c",
    "RawMessage": "Add missing guid comparison conditional statement",
    "Changes": "-      request_header->source_timestamp =\n-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      request_header->received_timestamp = 0;\n-      request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+        request_header->source_timestamp =\n+          sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+          sample_info->source_timestamp.nanosec;\n+        // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+        request_header->received_timestamp = 0;\n+        request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n+        memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "01c311e50a61cf3c8bbb069ae7c9fd0251ae31ae",
    "RawMessage": "Added rmw_wait, rmw_create_wait_set, and rmw_destroy_wait_set tests (#139)",
    "Changes": "+    ament_add_gtest(test_wait_set${target_suffix}\n+      test/test_wait_set.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_wait_set${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_wait_set${target_suffix}\n+      rmw rmw_implementation rcutils osrf_testing_tools_cpp test_msgs\n+    )\n+\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n... [truncated] ...\n+{\n+  // Try to destroy a nullptr\n+  rmw_ret_t ret = rmw_destroy_wait_set(nullptr);\n+  EXPECT_EQ(ret, RMW_RET_ERROR) << rcutils_get_error_string().str;\n+  rmw_reset_error();\n+\n+  // Created a valid wait set\n+  rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+  ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+  rmw_reset_error();\n+\n+  // Keep the implementation_identifier\n+  const char * implementation_identifier = wait_set->implementation_identifier;\n+\n+  // Use a invalid implementation_identifier\n+  wait_set->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_destroy_wait_set(wait_set);\n+  wait_set->implementation_identifier = implementation_identifier;\n+  EXPECT_EQ(ret, RMW_RET_INCORRECT_RMW_IMPLEMENTATION) << rcutils_get_error_string().str;\n+  rmw_reset_error();\n+\n+  // Restored the identifier and destroy the wait_set\n+  ret = rmw_destroy_wait_set(wait_set);\n+  EXPECT_EQ(ret, RMW_RET_OK) << rcutils_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "c3837902230d6fe004b69b4fbcce8b229e4001ff",
    "RawMessage": "Update quality declaration document (#225)",
    "Changes": "-`rmw_implementation` does not expose a public API. There is no need to add documentation to new changes. In the case that this package adds public API features the documentation of new functionality will be required.\n+`rmw_implementation` does not expose a public API.\n+There is no need to add documentation to new changes.\n+In the case that this package adds public API features the documentation of new functionality will be required.\n-Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/master/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/master/test_communication) packages, further extend coverage.\n+Integration and system tests against available `rmw` implementations up the stack, such as those found in [`test_rclcpp`](https://github.com/ros2/system_tests/tree/rolling/test_rclcpp) and [`test_communication`](https://github.com/ros2/system_tests/tree/rolling/test_communication) packages, further extend coverage.\n-The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/master/rmw_implementation/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n+The performance tests of `rmw_implementation` are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/rolling/rmw_implementation/test/benchmark).\n+The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n- - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n- - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n- - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n+ - rcpputils: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rcutils: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/rolling/QUALITY_DECLARATION.md)\n+ - rmw: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/rolling/rmw/QUALITY_DECLARATION.md)",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "8e20755361cd6f425f42d79c2e52c1772edb4c29",
    "RawMessage": "Remove attached waitset conditions on destructor",
    "Changes": "+\n+      while (dds_ConditionSeq_length(attached_conditions) > 0) {\n+        dds_ConditionSeq_remove(attached_conditions, 0);\n+      }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "652df5a3bc8bb281c305228eff343574bd1d4287",
    "RawMessage": "Adjust minimum dds version",
    "Changes": "-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>\n-  <build_export_depend>gurumdds-2.8</build_export_depend>\n+  <build_export_depend version_gte=\"2.8.3069\">gurumdds-2.8</build_export_depend>",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "b6f187aeae25975435a776de0017bf6c704cb591",
    "RawMessage": "More Helpful Error Messages (#275)",
    "Changes": "-                yaml_evaluated_value = yaml.safe_load(evaluated_value)\n-                if yaml_evaluated_value is None:\n-                    yaml_evaluated_value = ''\n+\n+                try:\n+                    yaml_evaluated_value = yaml.safe_load(evaluated_value)\n+                except yaml.YAMLError:\n+                    raise TypeError(\n+                        'Unable to parse the value of parameter {} as yaml. '\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(evaluated_name)\n+                    )\n+\n-                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'.format(\n-                            type(yaml_evaluated_value)\n-                        )\n+                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'\n+                        'If the parameter is meant to be a string, try wrapping it in '\n+                        'launch_ros.parameter_descriptions.ParameterValue'\n+                        '(value, value_type=str)'.format(type(yaml_evaluated_value))\n+from typing import List\n+from launch_ros.parameter_descriptions import ParameterValue\n+\n+    with pytest.raises(TypeError) as exc:\n... [truncated] ...\n+    orig = [{'foo': 1, 'fiz': ParameterValue(TextSubstitution(text='[]'), value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': '[]'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{\n+        'foo': 1,\n+        'fiz': ParameterValue([\n+            [TextSubstitution(text=\"['asd', 'bsd']\")],\n+            [TextSubstitution(text=\"['asd', 'csd']\")]\n+        ], value_type=List[str])\n+    }]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': [\"['asd', 'bsd']\", \"['asd', 'csd']\"]},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected\n+\n+    orig = [{'foo': 1,\n+             'fiz': ParameterValue(TextSubstitution(text='Text That : Cannot Be Parsed As : Yaml'),\n+                                   value_type=str)}]\n+    norm = normalize_parameters(orig)\n+    evaluate_parameters(LaunchContext(), norm)\n+    expected = ({'foo': 1, 'fiz': 'Text That : Cannot Be Parsed As : Yaml'},)\n+    assert evaluate_parameters(LaunchContext(), norm) == expected",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rcl",
    "SHA": "6074814b13039cb137fca76ac10ee01d88279418",
    "RawMessage": "Improved rcl_yaml_param_parser benchmark test (#810)",
    "Changes": "+  reset_heap_counters();\n+\n+  reset_heap_counters();\n+\n-  bool bool_arry[kSize];\n-  for (size_t i = 0; i < kSize; ++i) {\n-    src_variant.bool_array_value->values[i] = bool_arry[i];\n-  }\n-  int int_arry[kSize];\n-  for (size_t i = 0; i < kSize; ++i) {\n-    src_variant.integer_array_value->values[i] = int_arry[i];\n-  }\n-  double double_arry[kSize];\n-  for (size_t i = 0; i < kSize; ++i) {\n-    src_variant.double_array_value->values[i] = double_arry[i];\n-  }\n+\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rviz",
    "SHA": "72263582894a45c0f4d07ab53450823a44622c4f",
    "RawMessage": "Efficiently handle 3-bytes pixel formats (#743)",
    "Changes": "-  auto w = box.getWidth();\n-  auto h = box.getHeight();\n+  uint32_t w = box.getWidth();\n+  uint32_t h = box.getHeight();\n-  for (uint32_t y = 0; y < h; ++y) {\n-    for (uint32_t x = 0; x < w; ++x) {\n-      uint32_t pos = (x + y * w) * 4;\n-\n-      uint32_t pix_val = *reinterpret_cast<uint32_t *>(static_cast<uint8_t *>(box.data) + pos);\n-      uint32_t handle = colorToHandle(box.format, pix_val);\n-\n-      pixel_buffer_.push_back(handle);\n+  size_t size = Ogre::PixelUtil::getMemorySize(1, 1, 1, box.format);\n+\n+  for (uint32_t y = 0; y < h; y++) {\n+    for (uint32_t x = 0; x < w; x++) {\n+      uint32_t pos = static_cast<uint32_t>((x + y * w) * size);\n+      uint32_t pix_val = 0;\n+      memcpy(\n+        reinterpret_cast<uint8_t *>(&pix_val),\n+        reinterpret_cast<uint8_t *>(box.data + pos),\n+        size);\n+      pixel_buffer_.push_back(colorToHandle(box.format, pix_val));",
    "BackportedTo": "galactic",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "f142fd335eaa19a54a449b38c929d3cd37075c63",
    "RawMessage": "Inherit markers from generate_test_description (#330)",
    "Changes": "+import pytest\n+\n-        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n+        module = LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n+        for mark in marks:\n+            decorator = getattr(pytest.mark, mark.name)\n+            decorator = decorator.with_args(*mark.args, **mark.kwargs)\n+            module.add_marker(decorator)\n+        return module",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rclc",
    "SHA": "f79db48d62f6f3fa7c706d0f49dedabfa5f9374d",
    "RawMessage": "updating README.md see https://github.com/micro-ROS/micro-ROS.github.io/pull/356 and https://github.com/micro-ROS/micro-ROS.github.io/pull/357",
    "Changes": "-## Table of Contents\n+## Table of contents\n-[Overview](#overview)\n+*   [Introduction](#introduction)\n-[RCLC-Executor](#rclc-executor)\n-  * [Requirement Analysis](#requirement-analysis)\n-    * [Real-time embedded application use-case](#real-time-embedded-application-use-case)\n-    * [Sense-plan-act pipeline in mobile robotics](#sense-plan-act-pipeline-in-mobile-robotics)\n+*   [Analysis of rclcpp standard Executor](#analysis-of-rclcpp-standard-executor)\n+    * [Architecture](#architecture)\n+    * [Scheduling Semantics](#scheduling-semantics)\n+\n+*   [Analysis of processing patterns](#analysis-of-processing-patterns)\n+    * [Sense-plan-act pipeline in robotics](#sense-plan-act-pipeline-in-robotics)\n-  * [Features](#features)\n-    * [Sequential execution](#sequential-execution)\n-    * [Trigger condition](#trigger-condition)\n-    * [LET-Semantics](#let-semantics)\n-  * [Executor API](#executor-api)\n-    * [Configuration](#configuration-phase)\n-    * [Running](#running-phase)\n-    * [Clean-Up](#clean-up)\n-  * [Examples RCLC-Executor](#examples-rclc-executor)\n-    * [Example real-time embedded application use-case](#example-real-time-embedded-application-use-case)\n-    * [Example sense-plan-act pipeline in mobile robotics](#example-sense-plan-act-pipeline-in-mobile-robotics)\n... [truncated] ...\n-## Example RCLC-Executor with convenience functions\n+* [SLD2021]<a name=\"SLD2021\"></a> J. Staschulat, R. Lange and D. N. Dasari, \"Budget-based real-time Executor for Micro-ROS\", arXiv Pre-Print, May 2021. [[paper](https://arxiv.org/abs/2105.05590)] \n+\n+* [L2020]<a name=\"L2020\"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 [[Slides]](https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf)\n+\n+* [SLL2020]<a name=\"SLL2020\"></a> J. Staschulat, I. L\u251c\u255dtkebohle and R. Lange, \"The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress,\" 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. [[Paper]](https://ieeexplore.ieee.org/document/9244014) [[Video]](https://whova.com/embedded/session/eswe_202009/1145800/)\n+\n+* [CB2019]<a name=\"CB2019\"> </a> D. Casini, T. Bla\u251c\u0192, I. L\u251c\u255dtkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. [[Paper]](http://drops.dagstuhl.de/opus/volltexte/2019/10743/) [[slides]](https://t-blass.de/talks/ECRTS2019.pdf)\n+\n+* [L2018]<a name=\"L2018\"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. [[Slides]](https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf) [[Video]](https://vimeo.com/292707644)\n+\n+* [EK2018]<a name=\"EK2018\"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). [[Paper]](http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf)\n+\n+* [NSP2018]<a name=\"NSP2018\"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,\n+Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.\n+\n+* [BP2017]<a name=\"BP2017\"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.[[Paper]](https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf)\n+\n+* [KZH2015]<a name=\"KZH2015\"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.\n+\n+* [HHK2001]<a name=\"HHK2001\"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg\n-An example, how to use the LET Executor with rclc convenience functions is given in the file\n-`example_executor_convenience.c` in the package:\n-[rclc_examples](../rclc_examples).\n+* [LL1973]<a name=\"LL1973\"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 46\u0393\u00c7\u00f461, 1973.",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "4204ed5fcc2e2df7c2707d9d4f896cfced5318ea",
    "RawMessage": "Add fault injection tests to construction/destroy APIs.  (#144)",
    "Changes": "-      TIMEOUT 80\n+      TIMEOUT 120\n+TEST_F(CLASSNAME(TestClient, RMW_IMPLEMENTATION), create_with_internal_errors) {\n+  constexpr char service_name[] = \"/test\";\n+  const rosidl_service_type_support_t * ts =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    rmw_client_t * client =\n+    rmw_create_client(node, ts, service_name, &rmw_qos_profile_default);\n+    if (client) {\n+      RCUTILS_NO_FAULT_INJECTION(\n+      {\n+        rmw_ret_t ret = rmw_destroy_client(node, client);\n+        EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+      });\n+    } else {\n+      rmw_reset_error();\n+    }\n+  });\n+}\n+\n+TEST_F(CLASSNAME(TestClient, RMW_IMPLEMENTATION), destroy_with_internal_errors) {\n+  constexpr char service_name[] = \"/test\";\n+  const rosidl_service_type_support_t * ts =\n... [truncated] ...\n+    }\n+  });\n+}\n+\n-    int64_t count = rcutils_fault_injection_get_count();\n-    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n-\n-    if (wait_set != nullptr) {\n-      ret = rmw_destroy_wait_set(wait_set);\n-      EXPECT_EQ(ret, RMW_RET_OK) << rcutils_get_error_string().str;\n+    if (wait_set) {\n+      RCUTILS_NO_FAULT_INJECTION(\n+      {\n+        ret = rmw_destroy_wait_set(wait_set);\n+        EXPECT_EQ(ret, RMW_RET_OK) << rcutils_get_error_string().str;\n+      });\n-    rcutils_fault_injection_set_count(count);\n-\n+    EXPECT_NE(RMW_RET_OK, ret);\n-      EXPECT_EQ(RMW_RET_ERROR, ret);\n+#include \"osrf_testing_tools_cpp/memory_tools/memory_tools.hpp\"\n+\n+#include \"rcutils/macros.h\"\n+#include \"rcutils/testing/fault_injection.h\"\n+",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "ca76c0e6701adfba7a2aa9b4185bf96ae36ded08",
    "RawMessage": "Updated QD (#53)",
    "Changes": "-The package `rosidl_typesupport_fastrtps_c` claims to be in the **Quality Level 3** category.\n+The package `rosidl_typesupport_fastrtps_c` claims to be in the **Quality Level 2** category.\n-`rosidl_typesupport_fastrtps_c` does not currently have performance tests.\n+The performance tests of `rosidl_typesupport_fastrtps_c` are located in the [test/benchmark directory](https://github.com/ros2/rosidl_typesupport_fastrtps/tree/master/rosidl_typesupport_fastrtps_c/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n-`rosidl_typesupport_fastrtps_c` has the following runtime ROS dependencies, which are at or above QL 3:\n-* `fastrtps_cmake_module`: [QUALITY DECLARATION](../fastrtps_cmake_module/QUALITY_DECLARATION.md)\n+`rosidl_typesupport_fastrtps_c` has the following runtime ROS dependencies, which are at or above QL 2:\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n-The package `rosidl_typesupport_fastrtps_cpp` claims to be in the **Quality Level 3** category.\n+The package `rosidl_typesupport_fastrtps_cpp` claims to be in the **Quality Level 2** category.\n-`rosidl_typesupport_fastrtps_cpp` does not currently have performance tests.\n+The performance tests of `rosidl_typesupport_fastrtps_cpp` are located in the [test/benchmark directory](https://github.com/ros2/rosidl_typesupport_fastrtps/tree/master/rosidl_typesupport_fastrtps_cpp/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b45b1f7f9c77a2c511a9ef59b9f87c2bcab4cefc",
    "RawMessage": "Support static discovery",
    "Changes": "+  std::string static_discovery_id;\n+  static_discovery_id += namespace_;\n+  static_discovery_id += name;\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n-    participant = dds_DomainParticipantFactory_create_participant(\n-      factory, domain_id, &participant_qos, nullptr, 0);\n+    dds_StringProperty props[] = {\n+      {const_cast<char *>(\"gurumdds.static_discovery.id\"),\n+        const_cast<void *>(static_cast<const void *>(static_discovery_id.c_str()))},\n+      {nullptr, nullptr},\n+    };\n+    participant = dds_DomainParticipantFactory_create_participant_w_props(\n+      factory, domain_id, &participant_qos, nullptr, 0, props);",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "1dcfe806874956158e1d93a77034c740e8790e19",
    "RawMessage": "Use Fast-DDS Waitsets instead of listeners (#619)",
    "Changes": "-  bool keyed,\n-  bool create_subscription_listener);\n+  bool keyed);\n-init_context_impl(rmw_context_t * context)\n+init_context_impl(\n+  rmw_context_t * context)\n-    [&](CustomParticipantInfo * participant_info) {\n+    [&](CustomParticipantInfo * participant_info)\n+    {\n-      false,  // our fastrtps typesupport doesn't support keyed topics\n+      false,       // our fastrtps typesupport doesn't support keyed topics\n-    [&](rmw_publisher_t * pub) {\n+    [&](rmw_publisher_t * pub)\n+    {\n-      false,  // our fastrtps typesupport doesn't support keyed topics\n-      true),\n-    [&](rmw_subscription_t * sub) {\n+      false),       // our fastrtps typesupport doesn't support keyed topics\n+    [&](rmw_subscription_t * sub)\n+    {\n-    [&](rmw_guard_condition_t * p) {\n+    [&](rmw_guard_condition_t * p)\n+    {\n-    [guard_condition = graph_guard_condition.get()]() {\n+    [guard_condition = graph_guard_condition.get()]()\n... [truncated] ...\n-  hasTriggered()\n-  {\n-    return hasTriggered_;\n-  }\n-\n-  bool\n-  getHasTriggered()\n-  {\n-    return hasTriggered_.exchange(false);\n-  }\n-\n-private:\n-  std::mutex internalMutex_;\n-  std::atomic_bool hasTriggered_;\n-  std::mutex * conditionMutex_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);\n-  std::condition_variable * conditionVariable_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);\n-};\n-\n-#endif  // TYPES__GUARD_CONDITION_HPP_\n-    listener);\n+    listener,\n+    eprosima::fastdds::dds::StatusMask::subscription_matched());\n-      listener);\n+      listener,\n+      eprosima::fastdds::dds::StatusMask::subscription_matched());",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rclpy",
    "SHA": "b3cd14d65d4aeb528b6bcd2db489c8000acfaf82",
    "RawMessage": "Break log function execution ASAP if configured severity is too high (#776)",
    "Changes": "+        # Gather context info and check filters only if the severity is appropriate.\n+        if not self.is_enabled_for(severity):\n+            return False\n+\n-        # Only check filters if the severity is appropriate.\n-        if not self.is_enabled_for(severity):\n-            return False\n-",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ed8deb81f8c33f351f8335dec3873707863824da",
    "RawMessage": "Fix struct array deserialization",
    "Changes": "-      for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n-        deserialize(\n-          reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n-            member->members_->data\n-          ),\n-          reinterpret_cast<uint8_t *>(\n-            member->get_function(output + member->offset_, j)\n-          )\n-        );\n-      }\n-    } else {\n-      void * tmp = output + member->offset_;\n-      for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n-        deserialize(\n-          reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n-            member->members_->data\n-          ),\n-          reinterpret_cast<uint8_t *>(\n-            member->get_function(&tmp, j)\n-          )\n-        );\n-      }\n+    }\n+    for (uint32_t j = 0; j < member->size_function(output + member->offset_); j++) {\n+      deserialize(\n+        reinterpret_cast<const rosidl_typesupport_introspection_c__MessageMembers *>(\n+          member->members_->data\n+        ),\n+        reinterpret_cast<uint8_t *>(\n+          member->get_function(output + member->offset_, j)\n+        )\n+      );",
    "BackportedTo": "galactic",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "e7bc3bc868e0bc09e6b4225cd1f121e978c26986",
    "RawMessage": "Wrap up unordered_map with shared_ptr",
    "Changes": "+#include <memory>\n-static const std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> mask_map = {\n-  {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n-  {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n-  {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n-  {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n-  {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n-  {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n-  {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n-};\n+static std::shared_ptr<std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>>>\n+g_mask_map_ptr {new std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> {\n+    {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n+    {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n+    {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n+    {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n+    {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n+    {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n+  }};\n-  return mask_map.at(event_t);\n+  auto mask_map_ptr{g_mask_map_ptr};\n+  if (mask_map_ptr == nullptr) {\n+    return 0;\n+  }\n+  return mask_map_ptr->at(event_t);\n-  return mask_map.count(event_t) > 0;\n+  auto mask_map_ptr{g_mask_map_ptr};\n+  if (mask_map_ptr == nullptr) {\n+    return false;\n+  }\n+  return mask_map_ptr->count(event_t) > 0;",
    "BackportedTo": "galactic",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "cdf7077c8db8c4b84b4e2b18c877a230f98d8485",
    "RawMessage": "Added rmw_event_type_is_supported (#250)",
    "Changes": "",
    "BackportedTo": "jazzy",
    "Label": "Documentation"
  },
  {
    "Repository": "rclpy",
    "SHA": "714f69ee64ee8ea5dbc5f3067211b7886a4e7226",
    "RawMessage": "reject cancel request if failed to transit to CANCEL_GOAL state. (#791)",
    "Changes": "+# Re-export exception defined in _rclpy C extension.\n+RCLError = _rclpy.RCLError\n+\n-                goal_handle._update_state(_rclpy.GoalEvent.CANCEL_GOAL)\n+                try:\n+                    # If the goal's just succeeded after user cancel callback\n+                    # that will generate an exception from invalid transition.\n+                    goal_handle._update_state(GoalEvent.CANCEL_GOAL)\n+                except RCLError as ex:\n+                    self._node.get_logger().debug(\n+                        'Failed to cancel goal in cancel callback: {0}'.format(ex))\n+                    # Remove from response since goal has been succeeded\n+                    cancel_response.goals_canceling.remove(goal_info)",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "829768d73028005a14d723484e56381bba70062a",
    "RawMessage": "Make sure to lock the mutex protecting client_endpoints_. (#492)",
    "Changes": "-    // Check if the guid is still in the map\n-    if (clients_endpoints_.find(guid) == clients_endpoints_.end()) {\n-      // Client is gone\n-      return client_present_t::GONE;\n+    {\n+      std::lock_guard<std::mutex> lock(mutex_);\n+      // Check if the guid is still in the map\n+      if (clients_endpoints_.find(guid) == clients_endpoints_.end()) {\n+        // Client is gone\n+        return client_present_t::GONE;\n+      }\n-  // Accesors\n-  clients_endpoints_map_t & clients_endpoints()\n+  void endpoint_erase_if_exists(const eprosima::fastrtps::rtps::GUID_t & endpointGuid)\n+  {\n+    std::lock_guard<std::mutex> lock(mutex_);\n+    auto endpoint = clients_endpoints_.find(endpointGuid);\n+    if (endpoint != clients_endpoints_.end()) {\n+      clients_endpoints_.erase(endpoint->second);\n+      clients_endpoints_.erase(endpointGuid);\n+    }\n+  }\n+\n+  void endpoint_add_reader_and_writer(\n+    const eprosima::fastrtps::rtps::GUID_t & readerGuid,\n+    const eprosima::fastrtps::rtps::GUID_t & writerGuid)\n-    return clients_endpoints_;\n+    clients_endpoints_.emplace(readerGuid, writerGuid);\n+    clients_endpoints_.emplace(writerGuid, readerGuid);\n-      auto endpoint = info_->pub_listener_->clients_endpoints().find(\n-        matchingInfo.remoteEndpointGuid);\n-      if (endpoint != info_->pub_listener_->clients_endpoints().end()) {\n-        info_->pub_listener_->clients_endpoints().erase(endpoint->second);\n-        info_->pub_listener_->clients_endpoints().erase(matchingInfo.remoteEndpointGuid);\n-      }\n+      info_->pub_listener_->endpoint_erase_if_exists(matchingInfo.remoteEndpointGuid);\n-        info_->pub_listener_->clients_endpoints().emplace(reader_guid, writer_guid);\n-        info_->pub_listener_->clients_endpoints().emplace(writer_guid, reader_guid);\n+        info_->pub_listener_->endpoint_add_reader_and_writer(reader_guid, writer_guid);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rviz",
    "SHA": "013ca3e5c591c06af82b951218c541399920a01e",
    "RawMessage": "Update displays_panel.cpp (#745)",
    "Changes": "+#include <QProgressDialog> // NOLINT: cpplint is unable to handle the include order here\n+  QProgressDialog progress_dlg(\"Duplicating displays...\", \"Cancel\", 0, displays_to_duplicate.size(),\n+    this);\n+  progress_dlg.setWindowModality(Qt::WindowModal);\n+  progress_dlg.show();\n+  // duplicate all selected displays\n+  int i = 0;\n+    progress_dlg.setValue(i + 1);\n+    i++;\n+    // push cancel to stop duplicate\n+    if (progress_dlg.wasCanceled()) {\n+      break;\n+    }",
    "BackportedTo": "galactic",
    "Label": "Documentation"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "b56cd5fe6f42946d69d2e75ec37bf06d9becbe3f",
    "RawMessage": "Fix incoherent dissociate_writer to dissociate_reader (#647) (#649)",
    "Changes": "-      static_cast<void>(common_context->graph_cache.dissociate_writer(\n+      static_cast<void>(common_context->graph_cache.dissociate_reader(\n-      static_cast<void>(common_context->graph_cache.dissociate_writer(\n+      static_cast<void>(common_context->graph_cache.dissociate_reader(\n-      static_cast<void>(common_context->graph_cache.dissociate_writer(\n+      static_cast<void>(common_context->graph_cache.dissociate_reader(",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "c9954fd6ca2010577a846d432d5b99f6ca3e09b5",
    "RawMessage": "Update changelogs",
    "Changes": "+Forthcoming\n+-----------\n+* Maintaining consistency of automatically putting time stamps in the service and action calls similiar to publishing in rostopics. (`#961 <https://github.com/ros2/ros2cli/issues/961>`_)\n+* ros2action: add SIGINT handler to manage cancel request. (`#956 <https://github.com/ros2/ros2cli/issues/956>`_)\n+* Contributors: Sukhvansh Jain, Tomoya Fujita\n+\n+Forthcoming\n+-----------\n+* Rename the test\\_{daemon,direct}.py tests. (`#959 <https://github.com/ros2/ros2cli/issues/959>`_)\n+* Contributors: Chris Lalancette\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n... [truncated] ...\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* Add ament_xmllint test by default to ament_python packages. (`#957 <https://github.com/ros2/ros2cli/issues/957>`_)\n+* Contributors: Chris Lalancette\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* Maintaining consistency of automatically putting time stamps in the service and action calls similiar to publishing in rostopics. (`#961 <https://github.com/ros2/ros2cli/issues/961>`_)\n+* Contributors: Sukhvansh Jain, Tomoya Fujita\n+\n+Forthcoming\n+-----------\n+* support multiple fields in ros2topic echo (`#964 <https://github.com/ros2/ros2cli/issues/964>`_)\n+* Contributors: SangtaekLee\n+",
    "BackportedTo": "iron",
    "Label": "Documentation"
  },
  {
    "Repository": "geometry2",
    "SHA": "1621942bc2ad1270ee0bfc1f6b7a44a5849a7b5e",
    "RawMessage": "Fix constantly increasing memory in std::list (#636)",
    "Changes": "+\n+  ament_add_gtest(test_storage test/test_storage.cpp)\n+  if(TARGET test_storage)\n+    target_link_libraries(test_storage tf2)\n+  endif()\n+  TF2_PUBLIC\n+  bool operator==(const TransformStorage & rhs) const\n+  {\n+    return (this->rotation_ == rhs.rotation_) &&\n+           (this->translation_ == rhs.translation_) &&\n+           (this->stamp_ == rhs.stamp_) &&\n+           (this->frame_id_ == rhs.frame_id_) &&\n+           (this->child_frame_id_ == rhs.child_frame_id_);\n+  }\n+\n+  TF2_PUBLIC\n+  bool operator!=(const TransformStorage & rhs) const\n+  {\n+    return !(*this == rhs);\n+  }\n+\n+#include <algorithm>\n-  storage_.insert(storage_it, new_data);\n+  // Insert elements only if not already present\n+  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n... [truncated] ...\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // TimePoint stamp_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.stamp_ = tf2::TimePoint(tf2::durationFromSec(1.0));\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.frame_id_ = 55;\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID child_frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+}",
    "BackportedTo": "humble",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "9abb3be6c9b482bb9945d9204a0427c7b3c0f450",
    "RawMessage": "Change docstring markdown code blocks to RST (#450)",
    "Changes": "-    e.g.:\n-    ```python3\n+\n+    For example:\n+\n+    .. code-block:: python\n+\n-                    Node(...),  // the param will be passed to this node\n+                    Node(...),  # the param will be passed to this node\n-            Node(...),  // here it won't be passed, as it's not in the same scope\n+            Node(...),  # here it won't be passed, as it's not in the same scope\n-    ```\n-    e.g.\n-    ```python3\n+    For example:\n+\n+    .. code-block:: python\n+\n-                    Node(...),  // the params will be passed to this node\n+                    Node(...),  # the params will be passed to this node\n-            Node(...),  // here it won't be passed, as it's not in the same scope\n+            Node(...),  # here it won't be passed, as it's not in the same scope\n-    ```\n-    ```xml\n-    <launch>\n... [truncated] ...\n+    For example:\n-    ```python3\n-    combined_ns = prefix_namespace('my_ns', 'original_ns')\n-    assert combined_ns == 'my_ns/original_ns'\n+    .. code-block:: python\n-    combined_ns = prefix_namespace('/my_ns', 'original_ns')\n-    assert combined_ns == '/my_ns/original_ns'\n+        combined_ns = prefix_namespace('my_ns', 'original_ns')\n+        assert combined_ns == 'my_ns/original_ns'\n-    combined_ns = prefix_namespace('my_ns', '/original_ns')\n-    assert combined_ns == '/original_ns'\n+        combined_ns = prefix_namespace('/my_ns', 'original_ns')\n+        assert combined_ns == '/my_ns/original_ns'\n-    combined_ns = prefix_namespace(None, 'original_ns')\n-    assert combined_ns == 'original_ns'\n+        combined_ns = prefix_namespace('my_ns', '/original_ns')\n+        assert combined_ns == '/original_ns'\n-    combined_ns = prefix_namespace('my_ns', None)\n-    assert combined_ns == 'my_ns'\n-    ```\n+        combined_ns = prefix_namespace(None, 'original_ns')\n+        assert combined_ns == 'original_ns'\n+\n+        combined_ns = prefix_namespace('my_ns', None)\n+        assert combined_ns == 'my_ns'",
    "BackportedTo": "humble",
    "Label": "Documentation"
  },
  {
    "Repository": "geometry2",
    "SHA": "1621942bc2ad1270ee0bfc1f6b7a44a5849a7b5e",
    "RawMessage": "Fix constantly increasing memory in std::list (#636)",
    "Changes": "+\n+  ament_add_gtest(test_storage test/test_storage.cpp)\n+  if(TARGET test_storage)\n+    target_link_libraries(test_storage tf2)\n+  endif()\n+  TF2_PUBLIC\n+  bool operator==(const TransformStorage & rhs) const\n+  {\n+    return (this->rotation_ == rhs.rotation_) &&\n+           (this->translation_ == rhs.translation_) &&\n+           (this->stamp_ == rhs.stamp_) &&\n+           (this->frame_id_ == rhs.frame_id_) &&\n+           (this->child_frame_id_ == rhs.child_frame_id_);\n+  }\n+\n+  TF2_PUBLIC\n+  bool operator!=(const TransformStorage & rhs) const\n+  {\n+    return !(*this == rhs);\n+  }\n+\n+#include <algorithm>\n-  storage_.insert(storage_it, new_data);\n+  // Insert elements only if not already present\n+  if (std::find(storage_.begin(), storage_.end(), new_data) == storage_.end()) {\n... [truncated] ...\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // TimePoint stamp_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.stamp_ = tf2::TimePoint(tf2::durationFromSec(1.0));\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.frame_id_ = 55;\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+  // CompactFrameID child_frame_id_;\n+  {\n+    tf2::TransformStorage transformStorage2 = createTransformStorage();\n+    ASSERT_TRUE(transformStorage1 == transformStorage2);\n+    transformStorage2.translation_.setValue(1.0, 0.0, 0.0);\n+    ASSERT_TRUE(transformStorage1 != transformStorage2);\n+  }\n+}",
    "BackportedTo": "iron",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "9318b19d1a401eb6ff21ac1d8a26696b412af2f4",
    "RawMessage": "Add tests for native entity getters (#439)",
    "Changes": "+\n+  find_package(ament_cmake_gtest REQUIRED)\n+  find_package(osrf_testing_tools_cpp REQUIRED)\n+  find_package(test_msgs REQUIRED)\n+\n+  ament_add_gtest(test_get_native_entities\n+    test/test_get_native_entities.cpp)\n+  ament_target_dependencies(test_get_native_entities\n+    osrf_testing_tools_cpp rcutils rmw test_msgs\n+  )\n+  target_link_libraries(test_get_native_entities rmw_fastrtps_cpp)\n+  <test_depend>ament_cmake_gtest</test_depend>\n+  <test_depend>osrf_testing_tools_cpp</test_depend>\n+  <test_depend>test_msgs</test_depend>\n+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n... [truncated] ...\n+}\n+\n+TEST_F(TestNativeEntities, get_client) {\n+  EXPECT_EQ(nullptr, rmw_fastrtps_dynamic_cpp::get_request_publisher(nullptr));\n+  EXPECT_EQ(nullptr, rmw_fastrtps_dynamic_cpp::get_response_subscriber(nullptr));\n+\n+  const rosidl_service_type_support_t * ts =\n+    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n+  constexpr char service_name[] = \"/test\";\n+  rmw_qos_profile_t qos_profile = rmw_qos_profile_default;\n+  rmw_client_t * client = rmw_create_client(node, ts, service_name, &qos_profile);\n+  ASSERT_NE(nullptr, client) << rmw_get_error_string().str;\n+\n+  const char * implementation_identifier = client->implementation_identifier;\n+  client->implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  EXPECT_EQ(nullptr, rmw_fastrtps_dynamic_cpp::get_request_publisher(client));\n+  EXPECT_EQ(nullptr, rmw_fastrtps_dynamic_cpp::get_response_subscriber(client));\n+  client->implementation_identifier = implementation_identifier;\n+\n+  EXPECT_NE(nullptr, rmw_fastrtps_dynamic_cpp::get_request_publisher(client));\n+  EXPECT_NE(nullptr, rmw_fastrtps_dynamic_cpp::get_response_subscriber(client));\n+\n+  rmw_ret_t ret = rmw_destroy_client(node, client);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+}",
    "BackportedTo": "foxy",
    "Label": "Test"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b9930c17d63328ed38554b0a19950adafde8e510",
    "RawMessage": "Fix rclcpp test(test_serialized_message) failure",
    "Changes": "+    serialized_message->buffer_capacity = size;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "launch_ros",
    "SHA": "edb63764c39993645fd6bc7e0fc31ed7316f0b45",
    "RawMessage": "Fix url in setup.py (#413)",
    "Changes": "-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch/tree/master/ros2launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',\n-    url='https://github.com/ros2/launch',\n-    download_url='https://github.com/ros2/launch/releases',\n+    url='https://github.com/ros2/launch_ros',\n+    download_url='https://github.com/ros2/launch_ros/releases',",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "realtime_support",
    "SHA": "c37c57949b3e4e08732801bf4fe550d7c20c6d80",
    "RawMessage": "Explicitly shutdown context before test exits (#129)",
    "Changes": "+find_package(rcpputils REQUIRED)\n+      rcpputils::rcpputils\n+  <test_depend>rcpputils</test_depend>\n+#include \"rcpputils/scope_exit.hpp\"\n+\n+  // Always shutdown the ROS context.\n+  auto always_shutdown = rcpputils::make_scope_exit(\n+    []() {rclcpp::shutdown();});",
    "BackportedTo": "jazzy",
    "Label": "Test"
  },
  {
    "Repository": "geometry2",
    "SHA": "894ab122f63123e40a0df8d643cbcde6835ccfde",
    "RawMessage": "tf2_kdl: add python_orocos_kdl_vendor dependency (#745)",
    "Changes": "-  find_package(tf2_msgs REQUIRED)\n+  <exec_depend>python_orocos_kdl_vendor</exec_depend>\n-  <test_depend>tf2_msgs</test_depend>",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "ddae02ffeff4f43c7b5f618aced78f7f1c3d9c1f",
    "RawMessage": "use rmw_event_type_is_supported (#1214)",
    "Changes": "-  if (std::string(rmw_get_implementation_identifier()).find(\"rmw_zenoh_cpp\") == 0) {\n+  if (!rmw_event_type_is_supported(RMW_EVENT_MESSAGE_LOST)) {",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "16e14d15e210672fbfe0beb1f57effbd8d1233b0",
    "RawMessage": "Add test creating two content filter topics with the same topic name (#230) (#233)",
    "Changes": "+\n+TEST_F(TestContentFilterSubscriptionUse, create_two_filters_with_same_topic_name_and_destroy) {\n+  if (sub->is_cft_enabled) {\n+    auto allocator = rcutils_get_default_allocator();\n+    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n+\n+    rmw_subscription_content_filter_options_t * content_filter_options =\n+      static_cast<rmw_subscription_content_filter_options_t *>(\n+      allocator.allocate(\n+        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      allocator.deallocate(content_filter_options, allocator.state);\n+    });\n+\n+    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters,\n+        &allocator,\n+        content_filter_options));\n+\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(content_filter_options, &allocator));\n+    });\n+\n+    options.content_filter_options = content_filter_options;\n+\n+    // Create another subscription with content filter in the same topic\n+    auto sub_2 = rmw_create_subscription(node, ts, topic_name, &qos_profile, &options);\n+    ASSERT_NE(nullptr, sub_2) << rmw_get_error_string().str;\n+\n+    rmw_ret_t ret = rmw_destroy_subscription(node, sub_2);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  }\n+}",
    "BackportedTo": "iron",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "696707552499e5ee64fcb7b9714158e794f74d67",
    "RawMessage": "Fix rcl package's logging API error specs and handling. (#746)",
    "Changes": "- * \\return `RCL_RET_ERR` if a general error occurs\n+ * \\return `RCL_RET_ERROR` if a general error occurs\n+ * \\return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or\n- * \\return `RCL_RET_ERR` if a general error occurs\n+ * \\return `RCL_RET_ERROR` if a general error occurs\n- * \\return `RCL_RET_ERR` if a general error occurs\n+ * \\return `RCL_RET_ERROR` if a general error occurs\n-  RCL_CHECK_ARGUMENT_FOR_NULL(allocator, RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_ALLOCATOR_WITH_MSG(allocator, \"invalid allocator\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_ARGUMENT_FOR_NULL(output_handler, RCL_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rcl",
    "SHA": "e1480ea1a9e39b335edb5e71357196c3929df435",
    "RawMessage": "Return OK when finalizing zero-initialized contexts (#842)",
    "Changes": "+ * A zero-initialized context that has not been initialized can be finalized.\n- * If context is zero-initialized, then `RCL_RET_INVALID_ARGUMENT` is returned.\n+ * If context is zero-initialized, then `RCL_RET_OK` is returned.\n-  RCL_CHECK_FOR_NULL_WITH_MSG(\n-    context->impl, \"context is zero-initialized\", return RCL_RET_INVALID_ARGUMENT);\n+  if (!context->impl) {\n+    // Context is zero-initialized\n+    return RCL_RET_OK;\n+  }\n+\n+  ret = rcl_context_fini(&context);\n+  EXPECT_EQ(RCL_RET_OK, ret);\n+",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rcl",
    "SHA": "6b354895959519832065dcc2bf196bae26a133fd",
    "RawMessage": "Fix rcl arguments' API memory leaks and bugs. (#778)",
    "Changes": "-  if (args_impl->num_remap_rules > 0) {\n-    args_impl->remap_rules = rcutils_reallocf(\n-      args_impl->remap_rules, sizeof(rcl_remap_t) * args_impl->num_remap_rules, &allocator);\n-    if (NULL == args_impl->remap_rules) {\n-      ret = RCL_RET_BAD_ALLOC;\n-      goto fail;\n-    }\n-  } else {\n+  if (0 == args_impl->num_remap_rules) {\n+  } else if (args_impl->num_remap_rules < argc) {\n+    rcl_remap_t * new_remap_rules = allocator.reallocate(\n+      args_impl->remap_rules,\n+      sizeof(rcl_remap_t) * args_impl->num_remap_rules,\n+      &allocator);\n+    if (NULL == new_remap_rules) {\n+      ret = RCL_RET_BAD_ALLOC;\n+      goto fail;\n+    }\n+    args_impl->remap_rules = new_remap_rules;\n-    args_impl->parameter_files = rcutils_reallocf(\n-      args_impl->parameter_files, sizeof(char *) * args_impl->num_param_files_args, &allocator);\n-    if (NULL == args_impl->parameter_files) {\n+    char ** new_parameter_files = allocator.reallocate(\n+      args_impl->parameter_files,\n+      sizeof(char *) * args_impl->num_param_files_args,\n... [truncated] ...\n-    }\n-    if (RCL_RET_OK != rcl_lexer_lookahead2_fini(&lex_lookahead)) {\n-      RCUTILS_LOG_ERROR_NAMED(ROS_PACKAGE_NAME, \"Failed to fini lookahead2 after error occurred\");\n+    rcl_ret_t fini_ret = rcl_lexer_lookahead2_fini(&lex_lookahead);\n+    if (RCL_RET_OK != ret) {\n+      if (RCL_RET_OK != fini_ret) {\n+        RCUTILS_LOG_ERROR_NAMED(\n+          ROS_PACKAGE_NAME, \"Failed to fini lookahead2 after error occurred\");\n+      }\n+    } else {\n+      if (RCL_RET_OK == fini_ret) {\n+        return RCL_RET_OK;\n+      }\n+      ret = fini_ret;\n-  } else {\n-    ret = rcl_lexer_lookahead2_fini(&lex_lookahead);\n+\n+  // cleanup output rule but keep first error return code\n+  if (RCL_RET_OK != rcl_remap_fini(output_rule)) {\n+    RCUTILS_LOG_ERROR_NAMED(\n+      ROS_PACKAGE_NAME, \"Failed to fini remap rule after error occurred\");\n+  }\n+\n+    allocator.deallocate(*param_file, allocator.state);\n+    *param_file = NULL;",
    "BackportedTo": "foxy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "ros2cli",
    "SHA": "2c9c1933af37ae8a502a1c3abf2acf4ea810dc9e",
    "RawMessage": "start the simulation from 1 second for the test. (#975)",
    "Changes": "+import time\n+    def wait_for_command_online(self):\n+        max_seconds_to_wait = 5\n+        end_time = time.time() + max_seconds_to_wait\n+        while self.publisher.get_subscription_count() < 1:\n+            time.sleep(0.1)\n+            assert time.time() <= end_time  # timeout waiting for command online\n+        assert self.publisher.get_subscription_count() >= 1\n+\n-        self.clock_sec = 0\n+\n+        # Start the timer from 1 second, so that 1st message fires event.\n+        self.clock_sec = 1\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()\n+                # Check if the command line is ready to receive /clock messages\n+                self.wait_for_command_online()",
    "BackportedTo": "humble",
    "Label": "Test"
  },
  {
    "Repository": "rcl",
    "SHA": "6d53d24a863c3e9e4a41e9fe5f550271210d9d9d",
    "RawMessage": "Fix up rmw_cyclonedds timestamp testing. (#1156)",
    "Changes": "-  if(rmw_implementation STREQUAL \"rmw_fastrtps_cpp\" OR\n-    rmw_implementation STREQUAL \"rmw_fastrtps_dynamic_cpp\" OR\n-    (rmw_implementation STREQUAL \"rmw_connextdds\" AND NOT WIN32))\n+  if(rmw_implementation STREQUAL \"rmw_connextdds\" AND WIN32)\n+    message(STATUS \"Disabling message timestamp test for ${rmw_implementation}\")\n+  else()\n-      PUBLIC \"RMW_TIMESTAMPS_SUPPORTED=1\" \"RMW_RECEIVED_TIMESTAMP_SUPPORTED=1\")\n+      PRIVATE \"RMW_TIMESTAMPS_SUPPORTED=1\")\n-      PUBLIC \"RMW_TIMESTAMPS_SUPPORTED=1\" \"RMW_RECEIVED_TIMESTAMP_SUPPORTED=1\")\n-  else()\n-    if(rmw_implementation STREQUAL \"rmw_cyclonedds_cpp\")\n-      message(STATUS \"Enabling only source timestamp test for ${rmw_implementation}\")\n-      target_compile_definitions(test_subscription${target_suffix}\n-        PUBLIC \"RMW_TIMESTAMPS_SUPPORTED=1\")\n-      target_compile_definitions(test_service${target_suffix}\n-        PUBLIC \"RMW_TIMESTAMPS_SUPPORTED=1\")\n-    else()\n-      message(STATUS \"Disabling message timestamp test for ${rmw_implementation}\")\n-    endif()\n+      PRIVATE \"RMW_TIMESTAMPS_SUPPORTED=1\")\n-#ifdef RMW_RECEIVED_TIMESTAMP_SUPPORTED\n-#else\n-    EXPECT_EQ(0u, header.received_timestamp);\n-#endif\n-#ifdef RMW_RECEIVED_TIMESTAMP_SUPPORTED\n-#else\n-  EXPECT_EQ(0u, header.received_timestamp);\n-#endif\n-  #ifdef RMW_RECEIVED_TIMESTAMP_SUPPORTED\n-  #else\n-    EXPECT_EQ(0u, message_info.received_timestamp);\n-  #endif",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix"
  },
  {
    "Repository": "rclpy",
    "SHA": "4f7c1afafc43114d19a2c133ce5fe1ee54be80f1",
    "RawMessage": "unregister_sigterm_signal_handler should be called. (#1170)",
    "Changes": "-    unregister_sigint_signal_handler();\n+    unregister_sigterm_signal_handler();",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "272b79f615322e5e848c68880c2031ec481d656e",
    "RawMessage": "Apply loop to take sequence",
    "Changes": "+  *taken = 0;\n+\n+  // Reset length of output sequences\n+  message_sequence->size = 0;\n+  message_info_sequence->size = 0;\n+\n-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      RMW_GURUMDDS_ID, \"No data on topic %s\", subscription->topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n... [truncated] ...\n-      message_info->received_timestamp = 0;\n-      message_info->publication_sequence_number = sequence_number;\n-      message_info->reception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n-      rmw_gid_t * sender_gid = &message_info->publisher_gid;\n-      sender_gid->implementation_identifier = RMW_GURUMDDS_ID;\n-      memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info->publication_handle, sender_gid->data);\n-      if (ret != dds_RETCODE_OK) {\n-        if (ret == dds_RETCODE_ERROR) {\n-          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+        dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n+          topic_reader, sample_info->publication_handle, sender_gid->data);\n+        if (ret != dds_RETCODE_OK) {\n+          if (ret == dds_RETCODE_ERROR) {\n+            RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+          }\n+          memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      }\n-      (*taken)++;\n+        (*taken)++;\n+      }\n+    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "e4856e4afeda704547bdb43edc29d008b07f15d9",
    "RawMessage": "Update the launch file to work with modern joy. (#52)",
    "Changes": "-================\n+=====================\n-The purpose of this package is to provide a generic facility for tele-operating Twist-based ROS2 robots with a standard joystick. \n+The purpose of this package is to provide a generic facility for tele-operating Twist-based ROS 2 robots with a standard joystick.\n-This node provides no rate limiting or autorepeat functionality. It is expected that you take advantage of the features built into [joy](https://index.ros.org/p/joy/github-ros-drivers-joystick_drivers/#foxy) for this.\n+This node provides no rate limiting or autorepeat functionality.\n+It is expected that you take advantage of the features built into [joy](https://index.ros.org/p/joy/github-ros-drivers-joystick_drivers) for this.\n-To configure the node to match your joystick a config file can be used. \n-There are several common ones provided in this package (atk3, ps3-holonomic, ps3, xbox, xd3), located here: https://github.com/ros2/teleop_twist_joy/tree/eloquent/config.\n+To configure the node to match your joystick a config file can be used.\n+There are several common ones provided in this package (atk3, ps3-holonomic, ps3, xbox, xd3), located here: https://github.com/ros2/teleop_twist_joy/tree/rolling/config.\n-- `joy_dev (string, default: 'dev/input/js0')`\n+- `joy_dev (string, default: '0')`\n-        launch.actions.DeclareLaunchArgument('joy_dev', default_value='/dev/input/js0'),\n+        launch.actions.DeclareLaunchArgument('joy_dev', default_value='0'),\n-                'dev': joy_dev,\n+                'device_id': joy_dev,",
    "BackportedTo": "iron",
    "Label": "Functional Improvement"
  },
  {
    "Repository": "rviz",
    "SHA": "a83d8195a16cdcdbd417938cb8d3a30b4c826b12",
    "RawMessage": "Handle missing effort limit in URDF (#1084)",
    "Changes": "+#include <rclcpp/logging.hpp>\n-      joints_[joint_name] = std::make_shared<JointInfo>(joint_name, joints_category_);\n-      joints_[joint_name]->setMaxEffort(limit->effort);\n+      if (limit) {\n+        joints_[joint_name] = std::make_shared<JointInfo>(joint_name, joints_category_);\n+        joints_[joint_name]->setMaxEffort(limit->effort);\n+      } else {\n+        RCLCPP_WARN(\n+          context_->getRosNodeAbstraction().lock()->get_raw_node()->get_logger(),\n+          \"Joint '%s' has no <limit> tag in URDF. Effort plugin needs to know the effort \"\n+          \"limit to determine the size of the corresponding visual marker. \"\n+          \"Effort display for this joint will be inhibited.\", joint_name.c_str());\n+      }",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "14af0e039c0d9c42b88eee1d2f2aec91eea68395",
    "RawMessage": "Remove the mirror-rolling-to-master workflow. (#164)",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master",
    "BackportedTo": "jazzy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "90eaee839be1fe08d1c81c2a2f226f462ab3cff6",
    "RawMessage": "Updated error returns on rmw_take (#241)",
    "Changes": "-  RET_NULL(taken);\n-  RET_NULL(ros_message);\n-  RET_NULL(subscription);\n-  RET_WRONG_IMPLID(subscription);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    ros_message, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_info, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RET_NULL(taken);\n-  RET_NULL(message_sequence);\n-  RET_NULL(message_info_sequence);\n-  RET_NULL(subscription);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_sequence, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_info_sequence, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+\n+  if (0u == count) {\n+    RMW_SET_ERROR_MSG(\"count cannot be 0\");\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+\n-    return RMW_RET_ERROR;\n+    return RMW_RET_INVALID_ARGUMENT;\n-    return RMW_RET_ERROR;\n+    return RMW_RET_INVALID_ARGUMENT;",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rviz",
    "SHA": "013ca3e5c591c06af82b951218c541399920a01e",
    "RawMessage": "Update displays_panel.cpp (#745)",
    "Changes": "+#include <QProgressDialog> // NOLINT: cpplint is unable to handle the include order here\n+  QProgressDialog progress_dlg(\"Duplicating displays...\", \"Cancel\", 0, displays_to_duplicate.size(),\n+    this);\n+  progress_dlg.setWindowModality(Qt::WindowModal);\n+  progress_dlg.show();\n+  // duplicate all selected displays\n+  int i = 0;\n+    progress_dlg.setValue(i + 1);\n+    i++;\n+    // push cancel to stop duplicate\n+    if (progress_dlg.wasCanceled()) {\n+      break;\n+    }",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "0d75ee1bd748605c4cce231cc28b5806b5ad5600",
    "RawMessage": "Updated error returns on rmw_take_serialized and with_message_info  (#435)",
    "Changes": "-  if (subscription->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"publisher handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription handle,\n+    subscription->implementation_identifier, identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    subscription, \"subscription pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    serialized_message, \"ros_message pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(taken, \"boolean flag for taken is null\", return RMW_RET_ERROR);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    serialized_message, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    subscription, \"subscription pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    serialized_message, \"ros_message pointer is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(taken, \"boolean flag for taken is null\", return RMW_RET_ERROR);\n-  RCUTILS_CHECK_FOR_NULL_WITH_MSG(\n-    message_info, \"message info pointer is null\", return RMW_RET_ERROR);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    subscription, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    serialized_message, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    taken, RMW_RET_INVALID_ARGUMENT);\n+\n+  RMW_CHECK_ARGUMENT_FOR_NULL(\n+    message_info, RMW_RET_INVALID_ARGUMENT);",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "launch_ros",
    "SHA": "2d125a5105bbfc1d34de17dd70c29905e3ce9732",
    "RawMessage": "`WaitForTopics`: get content of messages for each topic (#353)",
    "Changes": "+from collections import deque\n+            print(wait_for_topics.messages_received('topic_1')) # Should be [message_1, ...]\n-    def __init__(self, topic_tuples, timeout=5.0):\n+    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):\n+        self.messages_received_buffer_length = messages_received_buffer_length\n-        node_name = '_test_node_' +\\\n-            ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))\n-        self.__ros_node = _WaitForTopicsNode(name=node_name, node_context=self.__ros_context)\n+        node_name = '_test_node_' + ''.join(\n+            random.choices(string.ascii_uppercase + string.digits, k=10)\n+        )\n+        self.__ros_node = _WaitForTopicsNode(\n+            name=node_name,\n+            node_context=self.__ros_context,\n+            messages_received_buffer_length=self.messages_received_buffer_length,\n+        )\n+    def received_messages(self, topic_name):\n+        \"\"\"List of received messages of a specific topic.\"\"\"\n+        if topic_name not in self.__ros_node.received_messages_buffer:\n+            raise KeyError('No messages received for topic: ' + topic_name)\n+        return list(self.__ros_node.received_messages_buffer[topic_name])\n+\n-    def __init__(self, name='test_node', node_context=None):\n-        super().__init__(node_name=name, context=node_context)\n+    def __init__(\n... [truncated] ...\n+                        topic_name,\n+                        self.callback_template(topic_name),\n+                        10\n+                    )\n-            )\n-\n+            self.get_logger().debug('Message received for ' + topic_name)\n+            self.received_messages_buffer[topic_name].append(data)\n-                self.get_logger().debug('Message received for ' + topic_name)\n+import re\n+\n+\n+            message_pattern = re.compile(r'Hello World: \\d+')\n-            with WaitForTopics(topic_list, timeout=10.0) as wait_for_node_object_1:\n+            with WaitForTopics(\n+                topic_list, timeout=2.0, messages_received_buffer_length=10\n+            ) as wait_for_node_object_1:\n+                for topic_name, _ in topic_list:\n+                    assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                    message = wait_for_node_object_1.received_messages(topic_name).pop().data\n+                    assert message_pattern.match(message)\n+            for topic_name, _ in topic_list:\n+                assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                message = wait_for_node_object_2.received_messages(topic_name).pop().data\n+                assert message_pattern.match(message)",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement"
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ab0c67990ea04c68dd18329c0f754ad9e72abd34",
    "RawMessage": "Basic rpc",
    "Changes": "-    int64_t sequence_number = 0;\n+    int32_t sn_high = 0;\n+    uint32_t sn_low = 0;\n-      &sequence_number,\n+      &sn_high,\n+      &sn_low,\n-    request_header->request_id.sequence_number = sequence_number;\n+    request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-    int64_t sequence_number = 0;\n+    int32_t sn_high = 0;\n+    uint32_t sn_low = 0;\n-      &sequence_number,\n+      &sn_high,\n+      &sn_low,\n-      request_header->request_id.sequence_number = sequence_number;\n+      request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-      \"l(name=gurumdds__sequence_number_)\" <<\n-      \"L(name=gurumdds__client_guid_1_)\";\n+      \"L(name=gurumdds__client_guid_1_)\" <<\n+      \"l(name=gurumdds__sequence_number_)\";\n-    buffer << dummy;  // suquence_number\n+    buffer << dummy;  // sequence_number\n+    buffer << dummy;  // padding\n-  const int8_t * client_guid)\n+  const int8_t * client_guid,\n... [truncated] ...\n+  uint32_t * sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-  int64_t * sequence_number,\n+  int32_t * sn_high,\n+  uint32_t * sn_low,\n-    sequence_number,\n-    client_guid\n+    sn_high,\n+    sn_low,\n+    client_guid,\n+    false\n-  int64_t * sequence_number,\n+  int32_t * sn_high,\n+  uint32_t * sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,\n-      sequence_number,\n+      sn_high,\n+      sn_low,",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement"
  },
  {
    "SHA": "a855a7d29bbdd4fea1fffc135d4c6b2defa369bb",
    "RawMessage": "Increase coverage rclcpp_action to 95% (#1290)\n\n* Increase coverage rclcpp_action to 95%\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Rebase onto #1311\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* rcutils test depend\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Cleaning up\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+      \"rcutils\"\n+      mimick\n+      \"rcutils\"\n+      mimick\n+    )\n+  endif()\n+\n+  ament_add_gtest(test_server_goal_handle test/test_server_goal_handle.cpp)\n+  if(TARGET test_server_goal_handle)\n+    ament_target_dependencies(test_server_goal_handle\n+      \"rcutils\"\n+      \"test_msgs\"\n+    )\n+    target_link_libraries(test_server_goal_handle\n+      ${PROJECT_NAME}\n+      mimick",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "6e8aaa2ae64b898ebe989743cab4f93a53e6565b",
    "RawMessage": "Increase rclcpp_action test coverage (#1153)\n\nSigned-off-by: Michel Hidalgo <michel@ekumenlabs.com>\n",
    "Changes": "-      if (!shared_node) {\n-        return;\n-      }\n-      // API expects a shared pointer, give it one with a deleter that does nothing.\n-      std::shared_ptr<Client<ActionT>> fake_shared_ptr(ptr, [](Client<ActionT> *) {});\n+      if (shared_node) {\n+        // API expects a shared pointer, give it one with a deleter that does nothing.\n+        std::shared_ptr<Client<ActionT>> fake_shared_ptr(ptr, [](Client<ActionT> *) {});\n-      if (group_is_null) {\n-        // Was added to default group\n-        shared_node->remove_waitable(fake_shared_ptr, nullptr);\n-      } else {\n-        // Was added to a specfic group\n-        auto shared_group = weak_group.lock();\n-        if (shared_group) {\n-          shared_node->remove_waitable(fake_shared_ptr, shared_group);\n+        if (group_is_null) {\n+          // Was added to default group\n+          shared_node->remove_waitable(fake_shared_ptr, nullptr);\n+        } else {\n+          // Was added to a specific group\n+          auto shared_group = weak_group.lock();\n+          if (shared_group) {\n+            shared_node->remove_waitable(fake_shared_ptr, shared_group);\n+          }",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "018cfaa2197b94ed1517cc2860758e1b8db02bdb",
    "RawMessage": "Clear members for StaticExecutorEntitiesCollector to avoid shared_ptr dependency (#1303)\n\n* Clear members for StaticExecutorEntitiesCollector to avoid shared_ptr dependency\r\n\r\nSigned-off-by: Chen Lihui <Lihui.Chen@sony.com>\r\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\r\nCo-authored-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "-    rclcpp::memory_strategy::MemoryStrategy::SharedPtr & memory_strategy,\n+    rclcpp::memory_strategy::MemoryStrategy::SharedPtr memory_strategy,\n+\n+  /// Finalize StaticExecutorEntitiesCollector to clear resources\n+  RCLCPP_PUBLIC\n+  void\n+  fini();",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "31c202e325476f6e912d6d23c17d13393156dbf4",
    "RawMessage": "Increase test timeouts of slow running tests with rmw_connext_cpp (#1400)\n\n* Increase test timeouts of slow running tests with rmw_connext_cpp\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Fix other issues with connext\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-ament_add_gtest(test_add_callback_groups_to_executor rclcpp/test_add_callback_groups_to_executor.cpp)\n+ament_add_gtest(test_add_callback_groups_to_executor\n+  rclcpp/test_add_callback_groups_to_executor.cpp\n+  TIMEOUT 120)\n-  rclcpp/node_interfaces/test_node_graph.cpp)\n+  rclcpp/node_interfaces/test_node_graph.cpp\n+  TIMEOUT 120)\n-ament_add_gtest(test_publisher rclcpp/test_publisher.cpp)\n+ament_add_gtest(test_publisher rclcpp/test_publisher.cpp TIMEOUT 120)\n-ament_add_gtest(test_subscription rclcpp/test_subscription.cpp)\n+# Creating and destroying nodes is slow with Connext, so this needs larger timeout.\n+ament_add_gtest(test_subscription rclcpp/test_subscription.cpp TIMEOUT 120)\n-  APPEND_LIBRARY_DIRS \"${append_library_dirs}\")\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\" TIMEOUT 120)\n-)\n+  TIMEOUT 120)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "5851eebdda5cc2ed9186a034df0ef75ccfe032d3",
    "RawMessage": "Make sure to clean the external client/service handle. (#1296)\n\nSigned-off-by: Chen Lihui <Lihui.Chen@sony.com>\n",
    "Changes": "+    allocator_memory_strategy_.reset();",
    "isBackported": true,
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "c4c18d592ae2f3be9d79fddec0d69dc304b93679",
    "RawMessage": "Increase coverage of WaitSetTemplate (#1368)\n\n* Increase coverage of WaitSetTemplate\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+\n+/*\n+ * Testing adding each entity and waiting, and removing each entity and waiting\n+ */\n+TEST_F(TestWaitSet, add_remove_wait) {\n+  rclcpp::WaitSet wait_set;\n+  auto node = std::make_shared<rclcpp::Node>(\"add_remove_wait\");\n+\n+  auto guard_condition = std::make_shared<rclcpp::GuardCondition>();\n+  guard_condition->trigger();\n+\n+  // For coverage reasons, this subscription should have event handlers\n+  rclcpp::SubscriptionOptions subscription_options;\n+  subscription_options.event_callbacks.deadline_callback = [](auto) {};\n+  subscription_options.event_callbacks.liveliness_callback = [](auto) {};\n+  auto do_nothing = [](const std::shared_ptr<test_msgs::msg::BasicTypes>) {};\n+  auto sub =\n+    node->create_subscription<test_msgs::msg::BasicTypes>(\n+    \"~/test\", 1, do_nothing, subscription_options);\n+\n+  auto timer = node->create_wall_timer(std::chrono::milliseconds(1), []() {});\n+\n+  auto client = node->create_client<rcl_interfaces::srv::ListParameters>(\"~/test\");\n+\n+  auto srv_do_nothing = [](\n... [truncated] ...\n+  auto pub = node->create_publisher<test_msgs::msg::BasicTypes>(\n+    \"~/test\", 1, publisher_options);\n+  auto qos_event = pub->get_event_handlers()[0];\n+\n+  // Subscription mask is required here for coverage.\n+  wait_set.add_subscription(sub, {true, true, true});\n+  wait_set.add_guard_condition(guard_condition);\n+  wait_set.add_timer(timer);\n+  wait_set.add_client(client);\n+  wait_set.add_service(service);\n+  wait_set.add_waitable(qos_event, pub);\n+\n+  // At least timer or guard_condition should trigger\n+  EXPECT_EQ(rclcpp::WaitResultKind::Ready, wait_set.wait(std::chrono::seconds(1)).kind());\n+\n+  wait_set.remove_subscription(sub, {true, true, true});\n+  wait_set.remove_guard_condition(guard_condition);\n+  wait_set.remove_timer(timer);\n+  wait_set.remove_client(client);\n+  wait_set.remove_service(service);\n+  wait_set.remove_waitable(qos_event);\n+\n+  EXPECT_EQ(rclcpp::WaitResultKind::Empty, wait_set.wait(std::chrono::seconds(1)).kind());\n+}\n+",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "90ef1e1f9c1ddfdd48299b065a5ae48c1892a5ce",
    "RawMessage": "Increase coverage of guard_condition.cpp to 100% (#1369)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  target_link_libraries(test_guard_condition ${PROJECT_NAME})\n+  target_link_libraries(test_guard_condition ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "bf660c543d3ecb091cc69e13cdd755d1186aca55",
    "RawMessage": "Tests for LoanedMessage with mocked loaned message publisher (#1366)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-target_link_libraries(test_loaned_message ${PROJECT_NAME})\n+target_link_libraries(test_loaned_message ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "d9377dc740d4424d0740131e79cfdb2a31dcf87c",
    "RawMessage": "Add unit tests for qos and qos_event files (#1352)\n\n* Add unit tests for qos and qos_event files\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Fix windows CI\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+RCLCPP_PUBLIC",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "99d76be3a59aaa092921e12a3621cfda414edc72",
    "RawMessage": "Finish coverage of publisher API (#1365)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+TEST_F(TestPublisher, serialized_message_publish) {\n+  initialize();\n+  rclcpp::PublisherOptionsWithAllocator<std::allocator<void>> options;\n+  // This is the default, but it's also important for this test to succeed.\n+  options.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"topic\", 10, options);\n+\n+  rclcpp::SerializedMessage serialized_msg;\n+  EXPECT_NO_THROW(publisher->publish(serialized_msg));\n+\n+  EXPECT_NO_THROW(publisher->publish(serialized_msg.get_rcl_serialized_message()));\n+}\n+\n+\n+  void call_default_incompatible_qos_callback(rclcpp::QOSOfferedIncompatibleQoSInfo & event) const\n+  {\n+    this->default_incompatible_qos_callback(event);\n+  }\n+TEST_F(TestPublisher, default_incompatible_qos_callback) {\n+  initialize();\n+  using PublisherT = TestPublisherProtectedMethods<test_msgs::msg::Empty, std::allocator<void>>;\n+  auto publisher =\n+    node->create_publisher<test_msgs::msg::Empty, std::allocator<void>, PublisherT>(\"topic\", 10);\n+  rclcpp::QOSOfferedIncompatibleQoSInfo event;\n+  event.last_policy_kind = RMW_QOS_POLICY_INVALID;\n+  // This message just logs an error message\n+  EXPECT_NO_THROW(publisher->call_default_incompatible_qos_callback(event));\n+}\n+",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "a37df26a9fd33fc0ad57e02a75c0d6a0559f987d",
    "RawMessage": "Finish API coverage on executors. (#1364)\n\nIn particular, add API coverage for spin_node_until_future_complete,\r\nspin_until_future_complete, and spin_node_once.\r\n\r\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "+\n+// Check spin_node_until_future_complete with node base pointer\n+TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodeBasePtr) {\n+  using ExecutorType = TypeParam;\n+  ExecutorType executor;\n+\n+  std::promise<bool> promise;\n+  std::future<bool> future = promise.get_future();\n+  promise.set_value(true);\n+\n+  auto shared_future = future.share();\n+  auto ret = rclcpp::executors::spin_node_until_future_complete(\n+    executor, this->node->get_node_base_interface(), shared_future, 1s);\n+  EXPECT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);\n+}\n+\n+// Check spin_node_until_future_complete with node pointer\n+TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodePtr) {\n+  using ExecutorType = TypeParam;\n+  ExecutorType executor;\n+\n+  std::promise<bool> promise;\n+  std::future<bool> future = promise.get_future();\n+  promise.set_value(true);\n+\n... [truncated] ...\n+      node->get_node_base_interface(), shared_future, 1s);\n+    EXPECT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);\n+  }\n+\n+  rclcpp::shutdown();\n+}\n+\n+// Check spin_until_future_complete with node pointer (instantiates its own executor)\n+TEST(TestExecutors, testSpinUntilFutureCompleteNodePtr) {\n+  rclcpp::init(0, nullptr);\n+\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\");\n+\n+    std::promise<bool> promise;\n+    std::future<bool> future = promise.get_future();\n+    promise.set_value(true);\n+\n+    auto shared_future = future.share();\n+    auto ret = rclcpp::spin_until_future_complete(node, shared_future, 1s);\n+    EXPECT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);\n+  }\n+\n+  rclcpp::shutdown();\n+}",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "374deb9191502b1286948edf9b5a5e6da751c1f5",
    "RawMessage": "Only exchange intra_process waitable if nonnull (#1317)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-          inner_subscription->exchange_in_use_by_wait_set_state(local_waitable.get(), false);\n-            // This is the case when intra process is disabled for the subscription.\n+            // This is the case when intra process is enabled for the subscription.\n+            inner_subscription->exchange_in_use_by_wait_set_state(local_waitable.get(), false);",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "8581c24d89e53e316beac1e11419a644e0c643ec",
    "RawMessage": "Add test for ParameterService (#1355)\n\n* Add test for ParameterService\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_parameter_service rclcpp/test_parameter_service.cpp)\n+if(TARGET test_parameter_service)\n+  ament_target_dependencies(test_parameter_service\n+    \"rcl_interfaces\"\n+  )\n+  target_link_libraries(test_parameter_service ${PROJECT_NAME})\n+endif()",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "78a3354a06c6855a5535678b574bab5d0ea94c5f",
    "RawMessage": "Add time API coverage tests (#1347)\n\n* Change value used as max representation\r\n* Add coverage tests time\r\n* Add call to detach clock\r\n* Add tests time\r\n* Add duration construction tests\r\n* Add const qualifier to constants\r\n* Add check clock stays the same\r\n* Make operator RCLCPP_PUBLIC\r\n* Add tests exceptions duration\r\n* Fix division by 0 on windows\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "+RCLCPP_PUBLIC",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "611856225b38590f8bad47c2b46669cec9096668",
    "RawMessage": "Add timer coverage tests (#1363)\n\n* Add missing tests API\r\n* Reformat style error throw\r\n* Add internal errors tests\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "-  if (rcl_timer_cancel(timer_handle_.get()) != RCL_RET_OK) {\n-    throw std::runtime_error(std::string(\"Couldn't cancel timer: \") + rcl_get_error_string().str);\n+  rcl_ret_t ret = rcl_timer_cancel(timer_handle_.get());\n+  if (ret != RCL_RET_OK) {\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"Couldn't cancel timer\");\n-  if (rcl_timer_reset(timer_handle_.get()) != RCL_RET_OK) {\n-    throw std::runtime_error(std::string(\"Couldn't reset timer: \") + rcl_get_error_string().str);\n+  rcl_ret_t ret = rcl_timer_reset(timer_handle_.get());\n+  if (ret != RCL_RET_OK) {\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"Couldn't reset timer\");\n-  if (rcl_timer_is_ready(timer_handle_.get(), &ready) != RCL_RET_OK) {\n-    throw std::runtime_error(std::string(\"Failed to check timer: \") + rcl_get_error_string().str);\n+  rcl_ret_t ret = rcl_timer_is_ready(timer_handle_.get(), &ready);\n+  if (ret != RCL_RET_OK) {\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"Failed to check timer\");\n-  if (\n-    rcl_timer_get_time_until_next_call(\n-      timer_handle_.get(),\n-      &time_until_next_call) != RCL_RET_OK)\n-  {\n-    throw std::runtime_error(\n-            std::string(\n-              \"Timer could not get time until next call: \") + rcl_get_error_string().str);\n+  rcl_ret_t ret = rcl_timer_get_time_until_next_call(\n+    timer_handle_.get(), &time_until_next_call);\n+  if (ret != RCL_RET_OK) {\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"Timer could not get time until next call\");",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "47fdb6326a2300ef6aa12f628565d177cb26a9eb",
    "RawMessage": "Add in additional tests for parameter_client.cpp coverage.\n\nThis gets us to 96% line coverage.\n\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n\n",
    "Changes": "+#include <chrono>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n-#include <memory>\n+#include <vector>\n+\n+/*\n+  Coverage for async get_parameter_types\n+ */\n+TEST_F(TestParameterClient, async_parameter_get_parameter_types) {\n+  auto asynchronous_client = std::make_shared<rclcpp::AsyncParametersClient>(node);\n+  bool callback_called = false;\n+  auto callback = [&callback_called](std::shared_future<std::vector<rclcpp::ParameterType>> result)\n+    {\n+      // We expect the result to be empty since we tried to get a parameter that didn't exist.\n+      if (result.valid() && result.get().size() == 0) {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<std::string> names{\"foo\"};\n+  std::shared_future<std::vector<rclcpp::ParameterType>> future =\n+    asynchronous_client->get_parameter_types(names, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n... [truncated] ...\n+      if (result.valid() && result.get().names.size() == 0 && result.get().prefixes.size() == 0) {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<std::string> prefixes{\"foo\"};\n+  std::shared_future<rcl_interfaces::msg::ListParametersResult> future =\n+    asynchronous_client->list_parameters(prefixes, 0, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n+    node, future, std::chrono::milliseconds(100));\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  ASSERT_TRUE(callback_called);\n+}\n+\n+/*\n+  Coverage for sync get_parameter_types\n+ */\n+TEST_F(TestParameterClient, sync_parameter_get_parameter_types) {\n+  node->declare_parameter(\"foo\", 4);\n+  auto synchronous_client = std::make_shared<rclcpp::SyncParametersClient>(node);\n+  std::vector<std::string> names{\"foo\"};\n+  std::vector<rclcpp::ParameterType> parameter_types =\n+    synchronous_client->get_parameter_types(names);\n+  ASSERT_EQ(1u, parameter_types.size());\n+  ASSERT_EQ(rclcpp::ParameterType::PARAMETER_INTEGER, parameter_types[0]);\n+}",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "5acb77527808d7c30cf7054e6f68f428ed951e4c",
    "RawMessage": "Minor fixes to the parameter_service.cpp file.\n\nMake sure to #include what is used, and also fix a typo\nin a test.\n\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n\n",
    "Changes": "+#include <chrono>\n+#include <functional>\n+#include <future>\n+#include <iterator>\n+#include <stdexcept>",
    "isBackported": true,
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "049dc286c446d50ff241a446a3767a4f13c5a7f4",
    "RawMessage": "Improved test publisher - zero qos history depth value exception (#1360)\n\nSigned-off-by: ahcorde <ahcorde@gmail.com>\n",
    "Changes": "+  RCLCPP_EXPECT_THROW_EQ(\n+    node->create_publisher<test_msgs::msg::Empty>(\n+      \"topic\", rclcpp::QoS(0), options),\n+    std::invalid_argument(\n+      \"intraprocess communication is not allowed with a zero qos history depth value\"));",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "4a6e5e4d6b59c167bfe5b05333b9dd5f8292e64b",
    "RawMessage": "Covered resolve_use_intra_process (#1359)\n\n* Covered resolve_use_intra_process\r\n\r\nSigned-off-by: ahcorde <ahcorde@gmail.com>\r\n\r\n* used RCLCPP_EXPECT_THROW_EQ in test_subscription_throws_intraprocess\r\n\r\nSigned-off-by: ahcorde <ahcorde@gmail.com>\n",
    "Changes": "+#include <functional>\n+/*\n+   Testing subscription with invalid use_intra_process_comm\n+ */\n+TEST_P(TestSubscriptionInvalidIntraprocessQos, test_subscription_throws_intraprocess) {\n+  rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>> options;\n+  options.use_intra_process_comm = static_cast<rclcpp::IntraProcessSetting>(5);\n+\n+  initialize();\n+  rclcpp::QoS qos = GetParam().qos;\n+  auto callback = std::bind(\n+    &TestSubscriptionInvalidIntraprocessQos::OnMessage,\n+    this,\n+    std::placeholders::_1);\n+\n+  RCLCPP_EXPECT_THROW_EQ(\n+    {auto subscription = node->create_subscription<test_msgs::msg::Empty>(\n+        \"topic\",\n+        qos,\n+        callback,\n+        options);},\n+    std::runtime_error(\"Unrecognized IntraProcessSetting value\"));\n+}\n+",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "677af44910bc11bda193c8ce52023d5a8af270e2",
    "RawMessage": "Improved test_subscription_options (#1358)\n\n* Improved test_subscription_options\r\n\r\nSigned-off-by: ahcorde <ahcorde@gmail.com>\r\n\r\n* used RCLCPP_EXPECT_THROW_EQ in test_subcription_options\r\n\r\nSigned-off-by: ahcorde <ahcorde@gmail.com>\r\n\r\n* make linters happy\r\n\r\nSigned-off-by: ahcorde <ahcorde@gmail.com>\n",
    "Changes": "+\n+#include \"../utils/rclcpp_gtest_macros.hpp\"\n+\n+  subscription_options.topic_stats_options.state = rclcpp::TopicStatisticsState::Disable;\n+  EXPECT_FALSE(\n+    rclcpp::detail::resolve_enable_topic_statistics(\n+      subscription_options,\n+      *(node->get_node_base_interface())));\n+\n+  subscription_options.topic_stats_options.state = static_cast<rclcpp::TopicStatisticsState>(5);\n+  RCLCPP_EXPECT_THROW_EQ(\n+    rclcpp::detail::resolve_enable_topic_statistics(\n+      subscription_options,\n+      *(node->get_node_base_interface())),\n+    std::runtime_error(\"Unrecognized EnableTopicStatistics value\"));",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "bd214d3b6545deeb39293653c6ded9d00095c080",
    "RawMessage": "Add in more tests for init_options coverage. (#1353)\n\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "-    rclcpp::exceptions::throw_from_rcl_error(ret, \"failed to initialized rcl init options\");\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"failed to initialize rcl init options\");",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "e73b613a019e9ff763f68fa3b9bf2300789c1491",
    "RawMessage": "Test the remaining node public API (#1342)\n\n* Test the remaining node public API\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add comment\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  target_link_libraries(test_node ${PROJECT_NAME})\n+  target_link_libraries(test_node ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "43c07027bb653350a2111393ba9758c93120b0f9",
    "RawMessage": "Complete coverage of Parameter and ParameterValue API (#1344)\n\n* Complete coverage of Parameter and ParameterValue API\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Adding comments\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+  std::stringstream ss;\n+  ss << not_set_variant;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"\\\", \\\"type\\\": \\\"not set\\\", \\\"value\\\": \\\"not set\\\"}\", ss.str());\n+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(not_set_variant, not_set_variant);\n+  rclcpp::Parameter not_set_variant2;\n+  EXPECT_EQ(not_set_variant, not_set_variant2);\n+  rclcpp::Parameter bool_variant(\"bool_param\", true);\n+  EXPECT_NE(not_set_variant, bool_variant);\n+  std::stringstream ss;\n+  ss << bool_variant_true;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"bool_param\\\", \\\"type\\\": \\\"bool\\\", \\\"value\\\": \\\"true\\\"}\", ss.str());\n+\n+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(bool_variant_true, bool_variant_true);\n+  EXPECT_NE(bool_variant_false, bool_variant_true);\n+  EXPECT_EQ(bool_variant_true, from_msg_true);\n+  std::stringstream ss;\n+  ss << integer_variant;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"integer_param\\\", \\\"type\\\": \\\"integer\\\", \\\"value\\\": \\\"42\\\"}\", ss.str());\n+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(integer_variant, integer_variant);\n... [truncated] ...\n+  EXPECT_EQ(string_array_variant, string_array_variant);\n+  EXPECT_NE(string_array_variant, rclcpp::Parameter(\"string_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(string_array_variant, from_msg);\n+}\n+\n+TEST_F(TestParameter, parameter_vector_stringification) {\n+  const std::vector<rclcpp::Parameter> parameters = {\n+    rclcpp::Parameter(),\n+    rclcpp::Parameter(\"bool_param\", true),\n+    rclcpp::Parameter(\"integer_param\", 42),\n+    rclcpp::Parameter(\"double_param\", 3.14159),\n+    rclcpp::Parameter(\"string_param\", \"I'm a string\"),\n+  };\n+\n+  std::stringstream ss;\n+  ss << parameters;\n+  EXPECT_EQ(\n+    \"{\"\n+    \"\\\"\\\": {\\\"type\\\": \\\"not set\\\", \\\"value\\\": \\\"not set\\\"}, \"\n+    \"\\\"bool_param\\\": {\\\"type\\\": \\\"bool\\\", \\\"value\\\": \\\"true\\\"}, \"\n+    \"\\\"integer_param\\\": {\\\"type\\\": \\\"integer\\\", \\\"value\\\": \\\"42\\\"}, \"\n+    \"\\\"double_param\\\": {\\\"type\\\": \\\"double\\\", \\\"value\\\": \\\"3.141590\\\"}, \"\n+    \"\\\"string_param\\\": {\\\"type\\\": \\\"string\\\", \\\"value\\\": \\\"I'm a string\\\"}}\",\n+    ss.str());\n+}",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "0b54476ff7153adfba7c36f0474e06e1b5b0b680",
    "RawMessage": "Add in more tests for the utilities. (#1349)\n\n* Add in more tests for the utilities.\r\n\r\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "+#include <chrono>\n+#include <functional>",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "1b652841c6e142db6d0d6e488541ccbcb71fe624",
    "RawMessage": "Add in two more tests for expand_topic_or_service_name. (#1350)\n\nThis gets us to 100% line coverage.\r\n\r\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "+TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_name) {\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rclcpp\", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAME);\n+  RCLCPP_EXPECT_THROW_EQ(\n+    rclcpp::expand_topic_or_service_name(\"chatter\", \"node\", \"/ns\"),\n+    std::runtime_error(\"invalid rcl node name but valid rmw node name\"));\n+}\n+\n+TEST(TestExpandTopicOrServiceName, rcl_expand_topic_name_fail_invalid_node_namespace) {\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rclcpp\", rcl_expand_topic_name, RCL_RET_NODE_INVALID_NAMESPACE);\n+  RCLCPP_EXPECT_THROW_EQ(\n+    rclcpp::expand_topic_or_service_name(\"chatter\", \"node\", \"/ns\"),\n+    std::runtime_error(\"invalid rcl namespace but valid rmw namespace\"));\n+}\n+",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "a9add88c2a5e77c64db0011257e48c7fe684d974",
    "RawMessage": "Add tests for node_options API (#1343)\n\n* Add tests for node_options API\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Remove c-style casts\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  target_link_libraries(test_node_options ${PROJECT_NAME})\n+  target_link_libraries(test_node_options ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "554d933f518d06c839194d0ec21b40c436e123de",
    "RawMessage": "Add in more coverage for expand_topic_or_service_name. (#1346)\n\nThis gets this file up to 97% coverage.\r\n\r\nSigned-off-by: Chris Lalancette <clalancette@openrobotics.org>\n",
    "Changes": "-  target_link_libraries(test_expand_topic_or_service_name ${PROJECT_NAME})\n+  target_link_libraries(test_expand_topic_or_service_name ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "869f3ed873c0cdd0bd179ce7776676492a386e41",
    "RawMessage": "Add coverage tests graph_listener (#1330)\n\n* Add file to test graph_listener\r\n* Add tests start graph listener\r\n* Add tests errors run graph listener\r\n* Add tests add/remove node\r\n* Remove dynamic cast\r\n* Remove repeated line\r\n* Remove comment\r\n* Add reset to avoid warning\r\n* Add checks construction graph listener\r\n* Add tests shutdown\r\n* Change node_graph definition\r\n* Remove test failing MacOS\r\n* Remove test not working on Windows\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "+ament_add_gtest(test_graph_listener rclcpp/test_graph_listener.cpp)\n+if(TARGET test_graph_listener)\n+  target_link_libraries(test_graph_listener ${PROJECT_NAME} mimick)\n+endif()\n+",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "bb3debcfbaf159794298aa4096bcc04b81ef15ab",
    "RawMessage": "Add coverage for client API (#1329)\n\n* Add coverage for client API\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  )\n-  target_link_libraries(test_client ${PROJECT_NAME})\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_client ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "3b71ca627c945633c5a6d176e11e15197e51e8ed",
    "RawMessage": "Increase service coverage (#1332)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  target_link_libraries(test_service ${PROJECT_NAME})\n+  target_link_libraries(test_service ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "acf69710869f70ca8e7a510aa57498608da3d003",
    "RawMessage": "Increase coverage of publisher/subscription API (#1325)\n\n* Increase coverage of publisher/subscription API\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-    \"rmw\"\n-    \"rosidl_runtime_cpp\"\n-    \"rosidl_typesupport_cpp\"\n-    \"test_msgs\"\n-  )\n-  target_link_libraries(test_publisher ${PROJECT_NAME})\n+    \"rcl\"\n+    \"rmw\"\n+    \"rosidl_runtime_cpp\"\n+    \"rosidl_typesupport_cpp\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_publisher ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_subscription ${PROJECT_NAME})\n+  target_link_libraries(test_subscription ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "94c4d7fb0bd2453f77fe44b21151750540e52f6f",
    "RawMessage": "Add coverage for missing API (except executors) (#1326)\n\n* Add coverage for missing API (except executors\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Do not check state\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+\n+ament_add_gtest(\n+  test_allocator_common\n+  rclcpp/allocator/test_allocator_common.cpp)\n+if(TARGET test_allocator_common)\n+  target_link_libraries(test_allocator_common ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(\n+  test_allocator_deleter\n+  rclcpp/allocator/test_allocator_deleter.cpp)\n+if(TARGET test_allocator_deleter)\n+  target_link_libraries(test_allocator_deleter ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(\n+  test_exceptions\n+  rclcpp/exceptions/test_exceptions.cpp)\n+if(TARGET test_exceptions)\n+  target_link_libraries(test_exceptions ${PROJECT_NAME} mimick)\n+endif()\n+ament_add_gtest(\n+  test_future_return_code\n+  rclcpp/test_future_return_code.cpp)\n+if(TARGET test_future_return_code)\n+  target_link_libraries(test_future_return_code ${PROJECT_NAME})\n+endif()",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "974772e2abfdfdf7fa0ee92ed0a3577d11a0930b",
    "RawMessage": "Add coverage tests context functions (#1321)\n\n* Add basic tests context access\r\n* Add expected interrupt_guard get/release\r\n* Add mocking utilities to rclcpp\r\n* Add tests interrupt_guard_condition\r\n* Add tests ini/fini error context\r\n* Add destructor test error\r\n* Create context directly in block* Use scope exit to clean context\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "-  target_link_libraries(test_utilities ${PROJECT_NAME})\n+  target_link_libraries(test_utilities ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "3defa8fc9d7410bd833ecd95b305ac94bb9b627a",
    "RawMessage": "Increase coverage of node_interfaces, including with mocking rcl errors (#1322)\n\n* Increase coverage of node_interfaces, including with mocking rcl errors\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  target_link_libraries(test_node_interfaces__node_base ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_base ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_graph ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_graph ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_parameters ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_parameters ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_services ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_services ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_timers ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_timers ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_topics ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_topics ${PROJECT_NAME} mimick)\n-  target_link_libraries(test_node_interfaces__node_waitables ${PROJECT_NAME})\n+  target_link_libraries(test_node_interfaces__node_waitables ${PROJECT_NAME} mimick)",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "10fbde806257e1d2d31f2dbc909537beae3f0b24",
    "RawMessage": "Add coverage for wait_set_policies (#1316)\n\n* Add mocking utils for rclcpp\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add coverage for wait_set_policies\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Fix windows issues\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add test comment\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+  <test_depend>mimick_vendor</test_depend>",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "0e0a6a495c452bdf3526a0b7bf457e4186bb344d",
    "RawMessage": "Add tests type_support module (#1308)\n\n* Add tests getters msg type support\r\n* Add missing fini\r\n* Add tests type_support services\r\n* Reformat to re use test structure\r\n* Remove not needed headers\r\n* Improve teardown test cases\r\n* Add nullptr checks to type_support tests\r\n* Reformat type_support testing\r\n* Replace expect tests with asserts\r\n* \"Improve error msg for rcl_service_ini/fini fail\"\r\n* Improve test readability\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "+ament_add_gtest(test_type_support rclcpp/test_type_support.cpp)\n+if(TARGET test_type_support)\n+  ament_target_dependencies(test_type_support\n+    \"rmw\"\n+    \"rosidl_runtime_cpp\"\n+    \"rosidl_typesupport_cpp\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_type_support ${PROJECT_NAME})\n+endif()",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "180a596f7fe0e9f9fe10f1089839cb84efd36bc7",
    "RawMessage": "Replace std_msgs with test_msgs in executors test (#1310)\n\nWithout this change, I am unable to build locally.\r\nstd_msgs is not declared as a test dependency or find_package'd anywhere, so\r\nI'm not sure why CI ever passed the build phase.\r\n\r\nSigned-off-by: Jacob Perron <jacob@openrobotics.org>\n",
    "Changes": "-    \"rcl\")\n+    \"rcl\"\n+    \"test_msgs\")",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "d66cd96f254648de5fa68f6c28a34968563294fb",
    "RawMessage": "Adding tests basic getters (#1291)\n\n* Add tests serialize functions\r\n* Add test getter const get_service_handle\r\n* Add basic tests getters publisher\r\n* Add == operator tests\r\n* Improve check on QOS depth\r\n* Remove extra line, copy directly string\r\n* Expect specific error throws\r\n\r\nSigned-off-by: Jorge Perez <jjperez@ekumenlabs.com>\n",
    "Changes": "+    \"test_msgs\"",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "633e1157f8aeee9249afddcd0730c3f9bb894fce",
    "RawMessage": "Refactor Subscription Topic Statistics Tests (#1281)\n\n* Add check for the correct number of messages received\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Refactor duplicate code into functions\r\nAdd random jitter to generate non-zero standard deviation values\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Fix warning\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Fix conversion warnings\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Fix style issues\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\n",
    "Changes": "+#include <random>\n+constexpr const char kMessageAgeSourceLabel[]{\"message_age\"};\n+constexpr const char kMessagePeriodSourceLabel[]{\"message_period\"};\n+constexpr const uint64_t kNumExpectedMessages{8};\n+constexpr const uint64_t kNumExpectedMessageAgeMessages{kNumExpectedMessages / 2};\n+constexpr const uint64_t kNumExpectedMessagePeriodMessages{kNumExpectedMessages / 2};\n+/**\n+ * Wrapper class to test and expose parts of the SubscriptionTopicStatistics<T> class.\n+ * \\tparam CallbackMessageT\n+ */\n+    uniform_dist_ = std::uniform_int_distribution<uint32_t>{1000000, 100000000};\n+    std::random_device rd;\n+    std::mt19937 gen{rd()};\n+    uint32_t d = uniform_dist_(gen);\n-    // Subtract 1 sec from current time so the received message age is always > 0\n-    msg.header.stamp = this->now() - rclcpp::Duration{1, 0};\n+    // Subtract ~1 second (add some noise for a non-zero standard deviation)\n+    // so the received message age calculation is always > 0\n+    msg.header.stamp = this->now() - rclcpp::Duration{1, d};\n+  std::uniform_int_distribution<uint32_t> uniform_dist_;\n+/**\n+ * Check if a received statistics message is empty (no data was observed)\n+ * \\param message_to_check\n+ */\n+void check_if_statistics_message_is_empty(const MetricsMessage & message_to_check)\n... [truncated] ...\n-          EXPECT_LT(0, stats_point.data) << \"unexpected sample count\";\n-          break;\n-        case StatisticDataType::STATISTICS_DATA_TYPE_AVERAGE:\n-          EXPECT_LT(0, stats_point.data) << \"unexpected avg\";\n-          break;\n-        case StatisticDataType::STATISTICS_DATA_TYPE_MINIMUM:\n-          EXPECT_LT(0, stats_point.data) << \"unexpected min\";\n-          break;\n-        case StatisticDataType::STATISTICS_DATA_TYPE_MAXIMUM:\n-          EXPECT_LT(0, stats_point.data) << \"unexpected max\";\n-          break;\n-        case StatisticDataType::STATISTICS_DATA_TYPE_STDDEV:\n-          EXPECT_LE(0, stats_point.data) << \"unexpected stddev\";\n-          break;\n-        default:\n-          FAIL() << \"received unknown statistics type: \" << std::dec <<\n-            static_cast<unsigned int>(type);\n-      }\n-    }\n-  }\n-  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";\n-}\n+    check_if_statistic_message_is_populated(msg);\n+  }\n+}",
    "isBackported": true,
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "96cccf5fdef6401b14974595d3481f9cc2223d30",
    "RawMessage": "fix topic stats test, wait for more messages, only check the ones with samples (#1274)\n\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\n",
    "Changes": "-    2);\n+    4);\n-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());\n-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());\n+  bool any_samples = false;\n+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;\n+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";\n-    2);\n+    4);\n-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());\n-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());\n+  bool any_samples = false;\n+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;\n+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "a721d06ec50118c8823fa2ee6e08961003dc0041",
    "RawMessage": "Fixes for unit tests that fail under cyclonedds (#1270)\n\nAddresses #1268 and #1269\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n-    rclcpp::init(0, nullptr);\n-    node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    const auto test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+    std::stringstream test_name;\n+    test_name << test_info->test_case_name() << \"_\" << test_info->name();\n+    node = std::make_shared<rclcpp::Node>(\"node\", test_name.str());\n-    std::stringstream topic_name;\n-    const auto test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-    topic_name << \"topic_\" << test_info->test_case_name() << \"_\" << test_info->name();\n-\n-    publisher = node->create_publisher<std_msgs::msg::Empty>(topic_name.str(), rclcpp::QoS(10));\n+\n+    const std::string topic_name = std::string(\"topic_\") + test_name.str();\n+    publisher = node->create_publisher<std_msgs::msg::Empty>(topic_name, rclcpp::QoS(10));\n-      topic_name.str(), rclcpp::QoS(10), std::move(callback));\n... [truncated] ...\n-  // Shutdown needs to be called before join, so that executor.spin() returns.\n-  rclcpp::shutdown();\n-  spinner.join();\n+  // Cancel needs to be called before join, so that executor.spin() returns.\n+  executor.cancel();\n+  spinner.join();\n+  executor.remove_node(this->node, true);\n-  while (!timer_completed && (std::chrono::steady_clock::now() - start) < 1s) {\n+  while (!timer_completed && (std::chrono::steady_clock::now() - start) < 10s) {\n-  rclcpp::shutdown();\n-  spinner.join();\n+  executor.cancel();\n+  spinner.join();\n+  executor.remove_node(this->node, true);\n-\n+  executor.remove_node(this->node, true);\n+  executor.remove_node(this->node, true);\n+      executor.remove_node(this->node, true);\n+      executor.cancel();\n+  executor.cancel();\n+      executor.remove_node(this->node, true);\n-      executor.remove_node(this->node);\n+      executor.remove_node(this->node, true);\n-      executor.remove_node(this->node);\n+      executor.remove_node(this->node, true);",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "6a3a5ed841562b6e371f3cf8cc6d9201cf070c80",
    "RawMessage": "initialize_logging_ should be copied. (#1272)\n\nSigned-off-by: Tomoya.Fujita <Tomoya.Fujita@sony.com>\n",
    "Changes": "+  initialize_logging_ = other.initialize_logging_;\n+    this->initialize_logging_ = other.initialize_logging_;",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "3733a1051adea2d4a395d70c53eced7d337c5ca1",
    "RawMessage": "Ability to configure domain_id via InitOptions. (#1165)\n\nSigned-off-by: Tomoya.Fujita <Tomoya.Fujita@sony.com>\n",
    "Changes": "+#include <mutex>\n+  /// Retrieve default domain id and set.\n+  RCLCPP_PUBLIC\n+  void\n+  use_default_domain_id();\n+\n+  /// Set the domain id.\n+  RCLCPP_PUBLIC\n+  void\n+  set_domain_id(size_t domain_id);\n+\n+  /// Return domain id.\n+  RCLCPP_PUBLIC\n+  size_t\n+  get_domain_id() const;\n+\n+  void\n+  finalize_init_options_impl();\n+\n+  mutable std::mutex init_options_mutex_;",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "0e7fed993dcfa0eec28f094fb8518fc0877fb03d",
    "RawMessage": "Simplify and fix allocator memory strategy unit test for connext (#1252)\n\n* Fix allocator memory strategy for connext\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  : allocator_memory_strategy_(nullptr),\n-    num_ready_subscriptions_of_basic_node_(0),\n-    num_ready_services_of_basic_node_(0),\n-    num_ready_events_of_basic_node_(0),\n-    num_ready_clients_of_basic_node_(0),\n-    num_guard_conditions_of_basic_node_(0),\n-    num_ready_timers_of_basic_node_(0),\n-    num_waitables_of_basic_node_(0) {}\n+  : allocator_memory_strategy_(nullptr) {}\n-\n-    auto basic_node = std::make_shared<rclcpp::Node>(\"basic_node\", \"ns\");\n-    auto dummy_memory_strategy = std::make_shared<AllocatorMemoryStrategy<>>();\n-    WeakNodeList nodes;\n-    nodes.push_back(basic_node->get_node_base_interface());\n-    dummy_memory_strategy->collect_entities(nodes);\n-\n-    num_ready_subscriptions_of_basic_node_ =\n-      dummy_memory_strategy->number_of_ready_subscriptions();\n-    num_ready_services_of_basic_node_ = dummy_memory_strategy->number_of_ready_services();\n-    num_ready_events_of_basic_node_ = dummy_memory_strategy->number_of_ready_events();\n-    num_ready_clients_of_basic_node_ = dummy_memory_strategy->number_of_ready_clients();\n-    num_guard_conditions_of_basic_node_ = dummy_memory_strategy->number_of_guard_conditions();\n-    num_ready_timers_of_basic_node_ = dummy_memory_strategy->number_of_ready_timers();\n-    num_waitables_of_basic_node_ = dummy_memory_strategy->number_of_waitables();\n-  std::shared_ptr<rclcpp::Node> create_node_with_subscription(\n... [truncated] ...\n-  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  auto node = create_node_with_disabled_callback_groups(\"node\");\n+    auto callback_group =\n+      node->create_callback_group(\n+      rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n-      std::chrono::seconds(10), []() {});\n-\n-    allocator_memory_strategy()->collect_entities(nodes);\n-  }\n-  EXPECT_EQ(1u, number_of_ready_timers_in_addition_to_basic_node());\n+      std::chrono::seconds(10), []() {}, callback_group);\n+\n+    allocator_memory_strategy()->collect_entities(nodes);\n+  }\n+  EXPECT_EQ(1u, allocator_memory_strategy()->number_of_ready_timers());\n-  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  auto node = create_node_with_disabled_callback_groups(\"node\");\n+    auto callback_group =\n+      node->create_callback_group(\n+      rclcpp::CallbackGroupType::MutuallyExclusive);\n+    node->get_node_waitables_interface()->add_waitable(waitable, callback_group);\n-  EXPECT_EQ(1u, number_of_waitables_in_addition_to_basic_node());\n+  // Since all callback groups have been locked, except the one we added, this should only be 1\n+  EXPECT_EQ(1u, allocator_memory_strategy()->number_of_waitables());",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "7c84b724b4d5ba75e1b0348765fc371dc7ef7e37",
    "RawMessage": "Increase timeouts for connext for long tests (#1253)\n\n* Increase timeouts for connext for long tests\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Fix cmakelists\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-ament_add_gtest(test_allocator_memory_strategy rclcpp/strategies/test_allocator_memory_strategy.cpp)\n+# Increasing timeout because connext can take a long time to destroy nodes\n+# TODO(brawner) remove when destroying Node for Connext is resolved. See:\n+# https://github.com/ros2/rclcpp/issues/1250\n+ament_add_gtest(\n+  test_allocator_memory_strategy\n+  rclcpp/strategies/test_allocator_memory_strategy.cpp\n+  TIMEOUT 360)\n-ament_add_gtest(test_executors rclcpp/executors/test_executors.cpp\n-  APPEND_LIBRARY_DIRS \"${append_library_dirs}\")\n+# TODO(brawner) remove when destroying Node for Connext is resolved. See:\n+# https://github.com/ros2/rclcpp/issues/1250\n+ament_add_gtest(\n+  test_executors\n+  rclcpp/executors/test_executors.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\"\n+  TIMEOUT 180)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "d378cff7bf84ec408b13cc7733ef61316a2f0e77",
    "RawMessage": "Adjust test_static_executor_entities_collector for rmw_connext_cpp (#1251)\n\nIt turns out rmw_connext_cpp adds a default waitable that other rmw\r\nimplementations do not. Adjusting the unit test to take this into\r\naccount in a non-rmw specific manner.\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  const auto expected_number_of_entities = get_number_of_default_entities(node);\n+  auto expected_number_of_entities = get_number_of_default_entities(node);\n+\n+  // Adding a subscription with rmw_connext_cpp adds another waitable, so we need to get the\n+  // current number of waitables just before adding the new waitable.\n+  expected_number_of_entities->waitables = get_number_of_default_entities(node)->waitables;",
    "isBackported": true,
    "Label": "Bug Fix/Test",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "3b8c334d5dd5fddaf3fec03b34e6767a2fde3a78",
    "RawMessage": "fix failing test with Connext since it doesn't wait for discovery (#1246)\n\n* fix failing test with Connext since it doesn't wait for discovery\r\n\r\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\r\n\r\n* Check for added service in the node graph\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\nCo-authored-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+#include \"test_msgs/srv/empty.hpp\"\n+  auto callback = [](\n+    const test_msgs::srv::Empty::Request::SharedPtr,\n+    test_msgs::srv::Empty::Response::SharedPtr) {};\n+  auto service =\n+    node1->create_service<test_msgs::srv::Empty>(\"node1_service\", std::move(callback));\n+  // rcl_get_service_names_and_types_by_node() expects the node to exist, otherwise it fails\n-  auto service_names_and_types1 = node_graph->get_service_names_and_types_by_node(\"node1\", \"/ns\");\n-  auto service_names_and_types2 = node_graph->get_service_names_and_types_by_node(\"node2\", \"/ns\");\n-  EXPECT_EQ(service_names_and_types1.size(), service_names_and_types2.size());\n+\n+  // Check that node1_service exists for node1 but not node2. This shouldn't exercise graph\n+  // discovery as node_graph belongs to node1 anyway. This is just to test the API itself.\n+  auto services_of_node1 =\n+    node_graph->get_service_names_and_types_by_node(\"node1\", \"/ns\");\n+  auto services_of_node2 =\n+    node_graph->get_service_names_and_types_by_node(\"node2\", \"/ns\");\n+\n+  auto start = std::chrono::steady_clock::now();\n+  while (std::chrono::steady_clock::now() - start < std::chrono::seconds(1)) {\n+    services_of_node1 = node_graph->get_service_names_and_types_by_node(\"node1\", \"/ns\");\n+    services_of_node2 = node_graph->get_service_names_and_types_by_node(\"node2\", \"/ns\");\n+    if (services_of_node1.find(\"/ns/node1_service\") != services_of_node1.end()) {\n+      break;\n+    }\n+  }\n+\n+  EXPECT_TRUE(services_of_node1.find(\"/ns/node1_service\") != services_of_node1.end());\n+  EXPECT_FALSE(services_of_node2.find(\"/ns/node1_service\") != services_of_node2.end());",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "72fd2f57b21829df3d9245e824839517f99c14c7",
    "RawMessage": "fix node graph test with Connext and CycloneDDS returning actual data (#1245)\n\n* fix node graph test with Connext and CycloneDDS returning actual data\r\n\r\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\r\n\r\n* use ADD_FAILURE()\r\n\r\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\n",
    "Changes": "-  EXPECT_EQ(0u, actual_qos.get_rmw_qos_profile().depth);\n+  switch (actual_qos.get_rmw_qos_profile().history) {\n+    case RMW_QOS_POLICY_HISTORY_KEEP_LAST:\n+      EXPECT_EQ(1u, actual_qos.get_rmw_qos_profile().depth);\n+      break;\n+    case RMW_QOS_POLICY_HISTORY_UNKNOWN:\n+      EXPECT_EQ(0u, actual_qos.get_rmw_qos_profile().depth);\n+      break;\n+    default:\n+      ADD_FAILURE() << \"unexpected history\";\n+  }\n-  EXPECT_EQ(0u, const_actual_qos.get_rmw_qos_profile().depth);\n+  switch (const_actual_qos.get_rmw_qos_profile().history) {\n+    case RMW_QOS_POLICY_HISTORY_KEEP_LAST:\n+      EXPECT_EQ(1u, const_actual_qos.get_rmw_qos_profile().depth);\n+      break;\n+    case RMW_QOS_POLICY_HISTORY_UNKNOWN:\n+      EXPECT_EQ(0u, const_actual_qos.get_rmw_qos_profile().depth);\n+      break;\n+    default:\n+      ADD_FAILURE() << \"unexpected history\";\n+  }",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "a0376768f7d077d7543bb9a2cdd9d2a72b495538",
    "RawMessage": "Unittests for memory strategy files, except allocator_memory_strategy (#1189)\n\n* Unit tests for memory_strategy classes (part 1)\r\n\r\nAdds unit tests for:\r\n* strategies/message_pool_memory_strategy.hpp\r\n* memory_strategy.cpp\r\n* message_memory_strategy.cpp\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Update with new macros\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_message_pool_memory_strategy rclcpp/strategies/test_message_pool_memory_strategy.cpp)\n+if(TARGET test_message_pool_memory_strategy)\n+  ament_target_dependencies(test_message_pool_memory_strategy\n+    \"rcl\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_message_pool_memory_strategy ${PROJECT_NAME})\n+endif()\n+\n+ament_add_gtest(test_memory_strategy rclcpp/test_memory_strategy.cpp)\n+ament_target_dependencies(test_memory_strategy\n+  \"test_msgs\"\n+)\n+target_link_libraries(test_memory_strategy ${PROJECT_NAME})\n+\n+ament_add_gtest(test_message_memory_strategy rclcpp/test_message_memory_strategy.cpp)\n+ament_target_dependencies(test_message_memory_strategy\n+  \"test_msgs\"\n+)\n+target_link_libraries(test_message_memory_strategy ${PROJECT_NAME})",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "b0754dacc5a6a03d3d5b1c213e119d01b5967ae4",
    "RawMessage": "EXPECT_THROW_EQ and ASSERT_THROW_EQ macros for unittests (#1232)\n\n* EXPECT_THROW_EQ and ASSERT_THROW_EQ macros for unittests\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_rclcpp_gtest_macros utils/test_rclcpp_gtest_macros.cpp)\n+if(TARGET test_rclcpp_gtest_macros)\n+  target_link_libraries(test_rclcpp_gtest_macros ${PROJECT_NAME})\n+endif()\n+",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "f945d89aa8c2a2eefc3a121dfab2f74e4ca469b3",
    "RawMessage": "Add unit test for static_executor_entities_collector (#1221)\n\n* Add unit test for static_executor_entities_collector\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_static_executor_entities_collector rclcpp/executors/test_static_executor_entities_collector.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\")\n+if(TARGET test_static_executor_entities_collector)\n+  ament_target_dependencies(test_static_executor_entities_collector\n+    \"rcl\"\n+    \"test_msgs\")\n+  target_link_libraries(test_static_executor_entities_collector ${PROJECT_NAME})\n+endif()\n+",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "e3490a29cd076bff320f6b5f02b013eb93c8d29d",
    "RawMessage": "Unit tests for allocator_memory_strategy.cpp part 2 (#1198)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+  ::testing::AssertionResult TestGetNextEntity(\n+    std::shared_ptr<rclcpp::Node> node_with_entity1,\n+    std::shared_ptr<rclcpp::Node> node_with_entity2,\n+    std::function<rclcpp::AnyExecutable(WeakNodeList)> get_next_entity_func)\n+  {\n+    WeakNodeList nodes;\n+    auto basic_node = std::make_shared<rclcpp::Node>(\"basic_node\", \"ns\");\n+    nodes.push_back(node_with_entity1->get_node_base_interface());\n+    nodes.push_back(basic_node->get_node_base_interface());\n+    allocator_memory_strategy()->collect_entities(nodes);\n+\n+    rclcpp::AnyExecutable result = get_next_entity_func(nodes);\n+    if (result.node_base != node_with_entity1->get_node_base_interface()) {\n+      return ::testing::AssertionFailure() <<\n+             \"Failed to get expected entity with specified get_next_*() function\";\n+    }\n+\n+    WeakNodeList uncollected_nodes;\n+    auto basic_node2 = std::make_shared<rclcpp::Node>(\"basic_node2\", \"ns\");\n+    uncollected_nodes.push_back(node_with_entity2->get_node_base_interface());\n+    uncollected_nodes.push_back(basic_node2->get_node_base_interface());\n+\n+    rclcpp::AnyExecutable failed_result = get_next_entity_func(uncollected_nodes);\n+    if (nullptr != failed_result.node_base) {\n+      return ::testing::AssertionFailure() <<\n... [truncated] ...\n+  }\n+  EXPECT_EQ(1u, number_of_ready_timers_in_addition_to_basic_node());\n+\n+  rclcpp::AnyExecutable result;\n+  allocator_memory_strategy()->get_next_timer(result, nodes);\n+  EXPECT_EQ(nullptr, result.node_base);\n+}\n+\n+TEST_F(TestAllocatorMemoryStrategy, get_next_waitable_out_of_scope) {\n+  WeakNodeList nodes;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  nodes.push_back(node->get_node_base_interface());\n+\n+  // Force waitable to go out of scope and cleanup after collecting entities.\n+  {\n+    allocator_memory_strategy()->collect_entities(nodes);\n+    auto waitable = std::make_shared<TestWaitable>();\n+    allocator_memory_strategy()->add_waitable_handle(waitable);\n+  }\n+  EXPECT_EQ(1u, number_of_waitables_in_addition_to_basic_node());\n+\n+  rclcpp::AnyExecutable result;\n+  allocator_memory_strategy()->get_next_waitable(result, nodes);\n+  EXPECT_EQ(nullptr, result.node_base);\n+}",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "0986fbb0f7b0dd735dac02677be5c92a9180f8e5",
    "RawMessage": "Unit tests for allocator_memory_strategy.hpp (#1197)\n\n* Unit tests for allocator_memory_strategy.hpp\r\n\r\nPart 1 of 2 for this file, but part 2 of 3 for memory strategies\r\noverall\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Remove find_package\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Remove ref to osrf_testing_tools\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_allocator_memory_strategy rclcpp/strategies/test_allocator_memory_strategy.cpp)\n+if(TARGET test_allocator_memory_strategy)\n+  ament_target_dependencies(test_allocator_memory_strategy\n+    \"rcl\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_allocator_memory_strategy ${PROJECT_NAME})\n+endif()",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "860a9e0e4dc0a7f39ed6f4dc2547da1e7b82d27c",
    "RawMessage": "Unit tests for node interfaces (#1202)\n\n* Unit tests for node interfaces\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR Feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Adjusting comment\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_node_interfaces__node_base\n+  rclcpp/node_interfaces/test_node_base.cpp)\n+if(TARGET test_node_interfaces__node_base)\n+  target_link_libraries(test_node_interfaces__node_base ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_clock\n+  rclcpp/node_interfaces/test_node_clock.cpp)\n+if(TARGET test_node_interfaces__node_clock)\n+  target_link_libraries(test_node_interfaces__node_clock ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_graph\n+  rclcpp/node_interfaces/test_node_graph.cpp)\n+if(TARGET test_node_interfaces__node_graph)\n+  ament_target_dependencies(\n+    test_node_interfaces__node_graph\n+    \"test_msgs\")\n+  target_link_libraries(test_node_interfaces__node_graph ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_parameters\n+  rclcpp/node_interfaces/test_node_parameters.cpp)\n+if(TARGET test_node_interfaces__node_parameters)\n+  target_link_libraries(test_node_interfaces__node_parameters ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_services\n+  rclcpp/node_interfaces/test_node_services.cpp)\n+if(TARGET test_node_interfaces__node_services)\n+  target_link_libraries(test_node_interfaces__node_services ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_timers\n+  rclcpp/node_interfaces/test_node_timers.cpp)\n+if(TARGET test_node_interfaces__node_timers)\n+  target_link_libraries(test_node_interfaces__node_timers ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_topics\n+  rclcpp/node_interfaces/test_node_topics.cpp)\n+if(TARGET test_node_interfaces__node_topics)\n+  ament_target_dependencies(\n+    test_node_interfaces__node_topics\n+    \"test_msgs\")\n+  target_link_libraries(test_node_interfaces__node_topics ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_waitables\n+  rclcpp/node_interfaces/test_node_waitables.cpp)\n+if(TARGET test_node_interfaces__node_waitables)\n+  target_link_libraries(test_node_interfaces__node_waitables ${PROJECT_NAME})\n+endif()",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "c63060c42de403c02e41568d966c40ebc5346245",
    "RawMessage": "Unit tests for some header-only functions/classes (#1181)\n\n* Unit tests for header-only functions/classes\r\n\r\nAdds coverage for:\r\n  * any_service_callback.hpp\r\n  * any_subscription_callback.hpp\r\n  * create_subscription.hpp\r\n  * create_timer.hpp\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address PR feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+ament_add_gtest(test_any_service_callback rclcpp/test_any_service_callback.cpp)\n+if(TARGET test_any_service_callback)\n+  ament_target_dependencies(test_any_service_callback\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_any_service_callback ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_any_subscription_callback rclcpp/test_any_subscription_callback.cpp)\n+if(TARGET test_any_subscription_callback)\n+  ament_target_dependencies(test_any_subscription_callback\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_any_subscription_callback ${PROJECT_NAME})\n+endif()\n+endif()\n+ament_add_gtest(test_create_subscription rclcpp/test_create_subscription.cpp)\n+if(TARGET test_create_subscription)\n+  target_link_libraries(test_create_subscription ${PROJECT_NAME})\n+  ament_target_dependencies(test_create_subscription\n+    \"test_msgs\"\n+  )",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "a6741a4f8ed167adda6b27a359eec9291e8b3b8e",
    "RawMessage": "Add unit tests for logging functionality (#1184)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+#include <memory>\n+#include \"rclcpp/node.hpp\"\n+\n+TEST(TestLogger, get_node_logger) {\n+  rclcpp::init(0, nullptr);\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\");\n+  auto node_base = rclcpp::node_interfaces::get_node_base_interface(node);\n+  auto logger = rclcpp::get_node_logger(node_base->get_rcl_node_handle());\n+  EXPECT_STREQ(logger.get_name(), \"ns.my_node\");\n+\n+  logger = rclcpp::get_node_logger(nullptr);\n+  EXPECT_STREQ(logger.get_name(), \"rclcpp\");\n+  rclcpp::shutdown();\n+}",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "84ae5a18977757b92eacab600c43d86c15cf431e",
    "RawMessage": "Fix rclcpp::NodeOptions::operator= (#1211)\n\nSigned-off-by: Michel Hidalgo <michel@ekumenlabs.com>\n",
    "Changes": "+    this->node_options_.reset();",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "2ed85420d5f1a5ecaae027172f29186ae2e4d309",
    "RawMessage": "Check period duration in create_wall_timer (#1178)\n\n* Check period duration in create_wall_timer\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Adding comments\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "- * \\param period period to exectute callback\n+ * \\param period period to execute callback. This duration must be 0 <= period < nanoseconds::max()\n- * are null\n+ * are null, or period is negative or too large\n+  if (period < std::chrono::duration<DurationRepT, DurationT>::zero()) {\n+    throw std::invalid_argument{\"timer period cannot be negative\"};\n+  }\n+\n+  // Casting to a double representation might lose precision and allow the check below to succeed\n+  // but the actual cast to nanoseconds fail. Using 1 DurationT worth of nanoseconds less than max.\n+  constexpr auto maximum_safe_cast_ns =\n+    std::chrono::nanoseconds::max() - std::chrono::duration<DurationRepT, DurationT>(1);\n+\n+  // If period is greater than nanoseconds::max(), the duration_cast to nanoseconds will overflow\n+  // a signed integer, which is undefined behavior. Checking whether any std::chrono::duration is\n+  // greater than nanoseconds::max() is a difficult general problem. This is a more conservative\n+  // version of Howard Hinnant's (the <chrono> guy>) response here:\n+  // https://stackoverflow.com/a/44637334/2089061\n+  // However, this doesn't solve the issue for all possible duration types of period.\n+  // Follow-up issue: https://github.com/ros2/rclcpp/issues/1177\n+  constexpr auto ns_max_as_double =\n+    std::chrono::duration_cast<std::chrono::duration<double, std::chrono::nanoseconds::period>>(\n+    maximum_safe_cast_ns);\n+  if (period > ns_max_as_double) {\n+    throw std::invalid_argument{\n+            \"timer period must be less than std::chrono::nanoseconds::max()\"};\n+  }\n+\n+  const auto period_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(period);\n+  if (period_ns < std::chrono::nanoseconds::zero()) {\n+    throw std::runtime_error{\n+            \"Casting timer period to nanoseconds resulted in integer overflow.\"};\n+  }\n+\n-    std::chrono::duration_cast<std::chrono::nanoseconds>(period),\n-    std::move(callback),\n-    node_base->get_context());\n+    period_ns, std::move(callback), node_base->get_context());",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "8a62104ea7e9a58061468db89a4f05038e7118d1",
    "RawMessage": "Throw exception if rcl_timer_init fails (#1179)\n\n* Throw exception if rcl_timer_init fails\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add bad-argument tests for GenericTimer\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Add comments\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-    if (\n-      rcl_timer_init(\n-        timer_handle_.get(), clock_handle, rcl_context.get(), period.count(), nullptr,\n-        rcl_get_default_allocator()) != RCL_RET_OK)\n-    {\n-      RCUTILS_LOG_ERROR_NAMED(\n-        \"rclcpp\",\n-        \"Couldn't initialize rcl timer handle: %s\\n\", rcl_get_error_string().str);\n-      rcl_reset_error();\n+    rcl_ret_t ret = rcl_timer_init(\n+      timer_handle_.get(), clock_handle, rcl_context.get(), period.count(), nullptr,\n+      rcl_get_default_allocator());\n+    if (ret != RCL_RET_OK) {\n+      rclcpp::exceptions::throw_from_rcl_error(ret, \"Couldn't initialize rcl timer handle\");",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "c0b96616bb2f24d1c75dc26c4f2ff7927ebfb74c",
    "RawMessage": "Fix implementation of NodeOptions::use_global_arguments() (#1176)\n\n`this->node_options_` might still be `nullptr` for a default initialized NodeOptions instance.\r\n`use_global_arguments()` must return `this->use_global_arguments_`, in analogy to `NodeOptions::enable_rosout()`.\r\n\r\nSigned-off-by: Johannes Meyer <johannes@intermodalics.eu>\n",
    "Changes": "-  return this->node_options_->use_global_arguments;\n+  return this->use_global_arguments_;",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "c92f3b7ff9015ebb0341c07f5a9caeb802d10181",
    "RawMessage": "Fix conversion of negative durations to messages (#1188)\n\n* Fix conversion from negative Duration or Time to the respective message type and throw in Duration::to_rmw_time() if the duration is negative.\r\nrmw_time_t cannot represent negative durations.\r\n\r\nConstructors and assignment operators can be just defaulted.\r\n\r\nOther changes are mainly cosmetical, to make conversions between signed\r\nand unsigned types and between 32-bit and 64-bit types more explicit.\r\n\r\nSigned-off-by: Johannes Meyer <johannes@intermodalics.eu>\r\n\r\n* Add -Wconversion compiler option and fix implicit conversions that might alter the value\r\n\r\nSigned-off-by: Johannes Meyer <johannes@intermodalics.eu>\r\n\r\n* Fix usage of fixture class in some unit tests by using gtest macro TEST_F() instead of TEST().\r\n\r\nSigned-off-by: Johannes Meyer <johannes@intermodalics.eu>\r\n\r\n* Add compiler option -Wno-sign-conversion to fix build with Clang on macOS\r\n\r\nSigned-off-by: Johannes Meyer <johannes@intermodalics.eu>\n",
    "Changes": "-  add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)\n+  # About -Wno-sign-conversion: With Clang, -Wconversion implies -Wsign-conversion. There are a number of\n+  # implicit sign conversions in rclcpp and gtest.cc, see https://ci.ros2.org/job/ci_osx/9265/.\n+  # Hence disabling -Wsign-conversion for now until all those have eventually been fixed.\n+  # (from https://github.com/ros2/rclcpp/pull/1188#issuecomment-650229140)\n+  add_compile_options(-Wall -Wextra -Wconversion -Wno-sign-conversion -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "1be58c057dbe3cf1ea93aa5b6addf641e8fe087a",
    "RawMessage": "Call vector.erase with end iterator overload (#1314)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-    guard_conditions_.erase(std::remove_if(guard_conditions_.begin(), guard_conditions_.end(), p));\n-    timers_.erase(std::remove_if(timers_.begin(), timers_.end(), p));\n-    clients_.erase(std::remove_if(clients_.begin(), clients_.end(), p));\n-    services_.erase(std::remove_if(services_.begin(), services_.end(), p));\n-    waitables_.erase(std::remove_if(waitables_.begin(), waitables_.end(), p));\n+    guard_conditions_.erase(\n+      std::remove_if(guard_conditions_.begin(), guard_conditions_.end(), p),\n+      guard_conditions_.end());\n+    timers_.erase(std::remove_if(timers_.begin(), timers_.end(), p), timers_.end());\n+    clients_.erase(std::remove_if(clients_.begin(), clients_.end(), p), clients_.end());\n+    services_.erase(std::remove_if(services_.begin(), services_.end(), p), services_.end());\n+    waitables_.erase(std::remove_if(waitables_.begin(), waitables_.end(), p), waitables_.end());",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "d0d12f77d76c98d6c99a206e467e6c3df09132b1",
    "RawMessage": "Check waitable for nullptr during constructor (#1315)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-      rclcpp::Waitable & waitable = *waitable_entry.waitable.get();\n+      auto waitable_ptr_pair = get_raw_pointer_from_smart_pointer(waitable_entry.waitable);\n+      if (nullptr == waitable_ptr_pair.second) {\n+        if (HasStrongOwnership) {\n+          throw std::runtime_error(\"unexpected condition, fixed storage policy needs pruning\");\n+        }\n+        // Flag for pruning.\n+        needs_pruning_ = true;\n+        continue;\n+      }\n+\n+      rclcpp::Waitable & waitable = *waitable_ptr_pair.second;",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "3f0f2e28c3fb2a4abd4df3e1eec3b67495563861",
    "RawMessage": "Remove rmw-dependent unit-test checks (#1293)\n\n* Remove rmw-dependent unit-test checks\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* Address feedback\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\r\n\r\n* PR Fixup\r\n\r\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  EXPECT_EQ(names.size(), 1u);\n-  EXPECT_STREQ(names[0].c_str(), \"/testnode\");\n-\n-  // parameter_events, rosout, /testnode/transition_event\n+\n+  ASSERT_NE(names.end(), std::find(names.begin(), names.end(), std::string(\"/testnode\")));\n+\n+  // Other topics may exist for an rclcpp::Node, but just checking the lifecycle one exists\n-  EXPECT_EQ(topic_names_and_types.size(), 3u);\n+  ASSERT_NE(\n+    topic_names_and_types.end(),\n+    topic_names_and_types.find(std::string(\"/testnode/transition_event\")));\n-  EXPECT_EQ(service_names_and_types.size(), 11u);\n+  ASSERT_NE(\n+    service_names_and_types.end(),\n+    service_names_and_types.find(std::string(\"/testnode/change_state\")));\n+\n+  ASSERT_NE(\n+    service_names_and_types.end(),\n+    service_names_and_types.find(std::string(\"/testnode/get_available_states\")));\n+\n+  ASSERT_NE(\n+    service_names_and_types.end(),\n+    service_names_and_types.find(std::string(\"/testnode/get_available_transitions\")));\n+\n+  ASSERT_NE(\n+    service_names_and_types.end(),\n+    service_names_and_types.find(std::string(\"/testnode/get_state\")));\n+\n+  ASSERT_NE(\n+    service_names_and_types.end(),\n+    service_names_and_types.find(std::string(\"/testnode/get_transition_graph\")));",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "c23572fa14d881607639987500a860c251446605",
    "RawMessage": "Include original exception in ComponentManagerException (#1157)\n\n* Include original exception in ComponentManagerException\r\n\r\nSigned-off-by: Martijn Buijs <martijn.buijs@gmail.com>\r\n\r\n* Update rclcpp_components/src/component_manager.cpp\r\n\r\nCo-authored-by: tomoya <Tomoya.Fujita@sony.com>\r\nSigned-off-by: Martijn Buijs <martijn.buijs@gmail.com>\r\n\r\nCo-authored-by: tomoya <Tomoya.Fujita@sony.com>\n",
    "Changes": "+      } catch (const std::exception & ex) {\n+        // In the case that the component constructor throws an exception,\n+        // rethrow into the following catch block.\n+        throw ComponentManagerException(\n+                \"Component constructor threw an exception: \" + std::string(ex.what()));",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "a9d5a3feb9a04dcad6143beb32c8efff4e9cb376",
    "RawMessage": "Fix pub/sub count API tests. (#1203)\n\nSigned-off-by: Michel Hidalgo <michel@ekumenlabs.com>\n",
    "Changes": "-using test_msgs::msg::Empty;\n-\n-/**\n- * Parameterized test.\n- * The first param are the NodeOptions used to create the nodes.\n- * The second param are the expect intraprocess count results.\n- */\n-struct TestParameters\n-{\n-  rclcpp::NodeOptions node_options[2];\n-  uint64_t intraprocess_count_results[2];\n-  std::string description;\n-};\n-\n-std::ostream & operator<<(std::ostream & out, const TestParameters & params)\n-{\n-  out << params.description;\n-  return out;\n-}\n-\n-class TestPublisherSubscriptionCount : public ::testing::TestWithParam<TestParameters>\n+namespace\n+{\n+\n+\n... [truncated] ...\n-    {\n-      rclcpp::NodeOptions().use_intra_process_comms(true),\n-      rclcpp::NodeOptions().context(get_new_context()).use_intra_process_comms(true)\n-    },\n-    {1u, 1u},\n-    \"two_subscriptions_in_two_contexts_with_intraprocess_comm\"\n-  },\n-  /*\n-     Testing publisher subscription count api and internal process subscription count.\n-     Two contexts, both of them not using intra-process comm.\n-   */\n-  {\n-    {\n-      rclcpp::NodeOptions().use_intra_process_comms(false),\n-      rclcpp::NodeOptions().context(get_new_context()).use_intra_process_comms(false)\n-    },\n-    {0u, 0u},\n-    \"two_subscriptions_in_two_contexts_without_intraprocess_comm\"\n-  }\n-};\n-\n-INSTANTIATE_TEST_CASE_P(\n-  TestWithDifferentNodeOptions, TestPublisherSubscriptionCount,\n-  ::testing::ValuesIn(parameters),\n-  ::testing::PrintToStringParamName());",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "a667583821fb3b1c0830420ce3b0517df1e9f8c4",
    "RawMessage": "Reorganize test directory and split CMakeLists.txt (#1173)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-  find_package(ament_cmake_gtest REQUIRED)\n-  find_package(rmw_implementation_cmake REQUIRED)\n-  find_package(rosidl_default_generators REQUIRED)\n-\n-  find_package(test_msgs REQUIRED)\n-\n-  include(cmake/rclcpp_add_build_failure_test.cmake)\n-\n-  add_definitions(-DTEST_RESOURCES_DIRECTORY=\"${CMAKE_CURRENT_BINARY_DIR}/test/resources\")\n-\n-  rosidl_generate_interfaces(${PROJECT_NAME}_test_msgs\n-    test/msg/Header.msg\n-    test/msg/MessageWithHeader.msg\n-    DEPENDENCIES builtin_interfaces\n-    LIBRARY_NAME ${PROJECT_NAME}\n-    SKIP_INSTALL\n-  )\n-\n-  ament_add_gtest(test_client test/test_client.cpp)\n-  if(TARGET test_client)\n-    ament_target_dependencies(test_client\n-      \"rcl_interfaces\"\n-      \"rmw\"\n-      \"rosidl_runtime_cpp\"\n-      \"rosidl_typesupport_cpp\"\n... [truncated] ...\n-    ament_target_dependencies(test_subscription_topic_statistics\n-      \"builtin_interfaces\"\n-      \"libstatistics_collector\"\n-      \"rcl_interfaces\"\n-      \"rcutils\"\n-      \"rmw\"\n-      \"rosidl_runtime_cpp\"\n-      \"rosidl_typesupport_cpp\"\n-      \"statistics_msgs\"\n-      \"test_msgs\")\n-    rosidl_target_interfaces(test_subscription_topic_statistics ${PROJECT_NAME}_test_msgs \"rosidl_typesupport_cpp\")\n-    target_link_libraries(test_subscription_topic_statistics ${PROJECT_NAME})\n-  endif()\n-\n-  ament_add_gtest(test_subscription_options test/test_subscription_options.cpp)\n-  if(TARGET test_subscription_options)\n-    ament_target_dependencies(test_subscription_options \"rcl\")\n-    target_link_libraries(test_subscription_options ${PROJECT_NAME})\n-  endif()\n-\n-  # Install test resources\n-  install(\n-    DIRECTORY test/resources\n-    DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/test)\n+  add_subdirectory(test)",
    "isBackported": true,
    "Label": "Test",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "7e68d3549cb4162630446a1cadf62a4b2f64cc82",
    "RawMessage": "Warn about unused result of add_on_set_parameters_callback (#1238)\n\nIf the user doesn't retain a reference to the returned shared pointer there will be zero references and their callback will be unregistered.\r\n\r\nSigned-off-by: Jacob Perron <jacob@openrobotics.org>\n",
    "Changes": "+\n+#include \"rcutils/macros.h\"\n+  RCUTILS_WARN_UNUSED",
    "isBackported": true,
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "a640c3ea2ebd7f127607a7f0b71e9d3841f811ab",
    "RawMessage": "Add missing RCLCPP_PUBLIC to ~StaticExecutorEntitiesCollector (#1227)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+  RCLCPP_PUBLIC",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "549988277385fcfde410e419172a874cad2413c8",
    "RawMessage": "Remove recreation of entities_collector (#1217)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "-    entities_collector_ = std::make_shared<StaticExecutorEntitiesCollector>();",
    "isBackported": true,
    "Label": "Other",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "05e6b96847cbc4601194a117e00298dfb33563c6",
    "RawMessage": "link against thread library where necessary (#1210)\n\nSigned-off-by: Dirk Thomas <dirk-thomas@users.noreply.github.com>\n",
    "Changes": "+\n+find_package(Threads REQUIRED)\n+target_link_libraries(${PROJECT_NAME} ${CMAKE_THREAD_LIBS_INIT})",
    "isBackported": true,
    "Label": "Other",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "35c27e82501c49e7a6831bde65a7033852e64029",
    "RawMessage": "fix exception message on rcl_clock_init. (#1182)\n\nSigned-off-by: Tomoya.Fujita <Tomoya.Fujita@sony.com>\n",
    "Changes": "-      exceptions::throw_from_rcl_error(ret, \"could not get current time stamp\");\n+      exceptions::throw_from_rcl_error(ret, \"failed to initialize rcl clock\");",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Raw Message",
    "Agreed": "True"
  },
  {
    "SHA": "40f0040f0df9247ba597c756f1e1494f821b65e9",
    "RawMessage": "Add create_publisher include to create_subscription (#1180)\n\nSigned-off-by: Stephen Brawner <brawner@gmail.com>\n",
    "Changes": "+#include \"rclcpp/create_publisher.hpp\"",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Raw Message",
    "Agreed": "False"
  },
  {
    "SHA": "cc65905efa5e2b7f2ba3d3c5ce0a69a716b95630",
    "RawMessage": "Fix get_node_time_source_interface() docstring (#988)\n\nSigned-off-by: Jacob Perron <jacob@openrobotics.org>\n",
    "Changes": "-  /// Return the Node's internal NodeParametersInterface implementation.\n+  /// Return the Node's internal NodeTimeSourceInterface implementation.",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "cbde45481ef3368c04a5b7536b5f8a48871d2171",
    "RawMessage": "Fixed doxygen warnings (#1163)\n\nSigned-off-by: ahcorde <ahcorde@gmail.com>\n",
    "Changes": "-   * \\param pre_callback. Must be non-throwing\n-   * \\param post_callback. Must be non-throwing.\n-   * \\param threshold. Callbacks will be triggered if the time jump is greater\n+   * \\param pre_callback Must be non-throwing\n+   * \\param post_callback Must be non-throwing.\n+   * \\param threshold Callbacks will be triggered if the time jump is greater",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "SHA": "552c1a8deb21e9ddcbd547571df6a127ff435679",
    "RawMessage": "Check if context is valid when looping in spin_some (#1167)\n\nSigned-off-by: Ivan Santiago Paunovic <ivanpauno@ekumenlabs.com>\n",
    "Changes": "-  while (spinning.load() && max_duration_not_elapsed()) {\n+  while (rclcpp::ok(context_) && spinning.load() && max_duration_not_elapsed()) {",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "Fals"
  },
  {
    "SHA": "f703314f952733590a54c7402e42ad84c30e46dd",
    "RawMessage": "Fix spin_until_future_complete: check spinning value (#1023)\n\nSigned-off-by: Donghee Ye <donghee.ye@samsung.com>\n",
    "Changes": "+#include \"rclcpp/scope_exit.hpp\"\n-    while (rclcpp::ok(this->context_)) {\n+    if (spinning.exchange(true)) {\n+      throw std::runtime_error(\"spin_until_future_complete() called while already spinning\");\n+    }\n+    RCLCPP_SCOPE_EXIT(this->spinning.store(false); );\n+    while (rclcpp::ok(this->context_) && spinning.load()) {\n-      spin_once(timeout_left);\n+      spin_once_impl(timeout_left);\n+\n+  RCLCPP_PUBLIC\n+  void\n+  spin_once_impl(std::chrono::nanoseconds timeout);\n+",
    "isBackported": true,
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "SHA": "5cecbf99bbb0f1d558592761d9b41d3de39e169f",
    "RawMessage": "Add check for invalid topic statistics publish period (#1151)\n\n* Add check for invalid topic statistics publish period\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Update documentation\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Address review comments\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Address doc formatting comments\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\r\n\r\n* Update doc spacing\r\n\r\nSigned-off-by: Devin Bonnie <dbbonnie@amazon.com>\n",
    "Changes": "+#include <stdexcept>\n+ *\n+ * \\tparam MessageT\n+ * \\tparam CallbackT\n+ * \\tparam AllocatorT\n+ * \\tparam CallbackMessageT\n+ * \\tparam SubscriptionT\n+ * \\tparam MessageMemoryStrategyT\n+ * \\tparam NodeT\n+ * \\param node\n+ * \\param topic_name\n+ * \\param qos\n+ * \\param callback\n+ * \\param options\n+ * \\param msg_mem_strat\n+ * \\return the created subscription\n+ * \\throws std::invalid_argument if topic statistics is enabled and the publish period is\n+ * less than or equal to zero.\n+    if (options.topic_stats_options.publish_period <= std::chrono::milliseconds(0)) {\n+      throw std::invalid_argument(\n+              \"topic_stats_options.publish_period must be greater than 0, specified value of \" +\n+              std::to_string(options.topic_stats_options.publish_period.count()) +\n+              \" ms\");\n+    }\n+",
    "isBackported": true,
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "fix events-executor warm-up bug and add unit-tests (#2591)",
    "SHA": "f7056c0d86cd3b66c31ca02eb17d2dc6e789a3c4",
    "Changes": "-      entities_need_rebuild_ = false;\n+  // If this spin is not exhaustive (e.g. spin_some), we need to explicitly check\n+  // if entities need to be rebuilt here rather than letting the notify waitable event do it.\n+  // A non-exhaustive spin would not check for work a second time, thus delaying the execution\n+  // of some entities to the next invocation of spin.\n+  if (!exhaustive) {\n+    this->handle_updated_entities(false);\n+  }\n+\n+\n+  // Do not rebuild if we don't need to.\n+  // A rebuild event could be generated, but then\n+  // this function could end up being called from somewhere else\n+  // before that event gets processed, for example if\n+  // a node or callback group is manually added to the executor.\n+  const bool notify_waitable_triggered = entities_need_rebuild_.exchange(false);\n+  if (!notify_waitable_triggered && !this->collector_.has_pending()) {\n+    return;\n+  }\n+\n+ament_add_gtest(\n+  test_executors_warmup\n+  executors/test_executors_warmup.cpp\n+  executors/test_waitable.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\"\n... [truncated] ...\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  rclcpp::SubscriptionOptions sub_options;\n+  sub_options.callback_group = callback_group;\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback), sub_options);\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n+  // the new message, no risk of race conditions where spin_some gets called before the\n+  // message has been delivered.\n+  executor.spin_some();\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "revert call shutdown in LifecycleNode destructor (#2557)",
    "SHA": "f4923c6f43afaf983f95158584d37687f2679925",
    "Changes": "-  auto current_state = LifecycleNode::get_current_state().id();\n-  // shutdown if necessary to avoid leaving the device in any other primary state\n-  if (current_state < lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    if (node_base_->get_context()->is_valid()) {\n-      auto ret = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n-      auto finalized = LifecycleNode::shutdown(ret);\n-      if (finalized.id() != lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED ||\n-        ret != rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS)\n-      {\n-        RCLCPP_WARN(\n-          rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-          \"Shutdown error in destruction of LifecycleNode: final state(%s)\",\n-          finalized.label().c_str());\n-      }\n-    } else {\n-      // TODO(fujitatomoya): consider when context is gracefully shutdown before.\n-      RCLCPP_DEBUG(\n-        rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-        \"Context invalid error in destruction of LifecycleNode: Node still in transition state(%u)\",\n-        current_state);\n-    }\n-  } else if (current_state > lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    RCLCPP_WARN(\n-      rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-      \"Shutdown error in destruction of LifecycleNode: Node still in transition state(%u)\",\n... [truncated] ...\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-\n-  // PRIMARY_STATE_FINALIZED to shutdown via dtor\n-  shutdown_cb_called = false;\n-  {\n-    auto ret = reset_key;\n-    auto test_node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\"testnode\");\n-    test_node->register_on_shutdown(std::bind(on_shutdown_callback, std::placeholders::_1));\n-    auto configured = test_node->configure(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(configured.id(), State::PRIMARY_STATE_INACTIVE);\n-    ret = reset_key;\n-    auto activated = test_node->activate(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(activated.id(), State::PRIMARY_STATE_ACTIVE);\n-    ret = reset_key;\n-    auto finalized = test_node->shutdown(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(finalized.id(), State::PRIMARY_STATE_FINALIZED);\n-    EXPECT_TRUE(shutdown_cb_called);  // should be called already\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-}\n-",
    "BackportedTo": "humble",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "changelogs",
    "SHA": "76aae4f799fa11a3e942479877408080f10cabaf",
    "Changes": "+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+\n+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+\n+Forthcoming\n+-----------\n+\n+Forthcoming\n+-----------\n+* remove things that were deprecated during galactic (`#1913 <https://github.com/ros2/rclcpp/issues/1913>`_)\n+* Contributors: William Woodall\n+",
    "BackportedTo": "galactic",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Remake of \"fix: Fixed race condition in action server between is_ready and take\" (#2495)",
    "SHA": "dd81ef26a0c1def6e9c328b17f86f126cf40ccf3",
    "Changes": "+#include \"action_msgs/srv/cancel_goal.hpp\"\n+    Expired,\n-  execute_goal_request_received(const std::shared_ptr<void> & data);\n+  execute_goal_request_received(\n+    rcl_ret_t ret,\n+    rcl_action_goal_info_t goal_info,\n+    rmw_request_id_t request_header,\n+    std::shared_ptr<void> message);\n-  execute_cancel_request_received(const std::shared_ptr<void> & data);\n+  execute_cancel_request_received(\n+    rcl_ret_t ret,\n+    std::shared_ptr<action_msgs::srv::CancelGoal::Request> request,\n+    rmw_request_id_t request_header);\n-  execute_result_request_received(const std::shared_ptr<void> & data);\n+  execute_result_request_received(\n+    rcl_ret_t ret,\n+    std::shared_ptr<void> result_request,\n+    rmw_request_id_t request_header);\n-        const GoalUUID &, std::shared_ptr<const typename ActionT::Goal>)>;\n+        const GoalUUID &,\n+        std::shared_ptr<const typename ActionT::Goal>)>;\n-    GoalUUID uuid, std::shared_ptr<void> goal_request_message) override\n+    GoalUUID uuid,\n+    std::shared_ptr<void> goal_request_message) override\n+#include <variant>\n... [truncated] ...\n+ServerBase::execute_cancel_request_received(\n+  rcl_ret_t ret,\n+  std::shared_ptr<action_msgs::srv::CancelGoal::Request> request,\n+  rmw_request_id_t request_header)\n-  auto shared_ptr = std::static_pointer_cast\n-    <std::tuple<rcl_ret_t, std::shared_ptr<action_msgs::srv::CancelGoal::Request>,\n-      rmw_request_id_t>>(data);\n-  auto ret = std::get<0>(*shared_ptr);\n-  auto request = std::get<1>(*shared_ptr);\n-  auto request_header = std::get<2>(*shared_ptr);\n-  pimpl_->cancel_request_ready_ = false;\n-ServerBase::execute_result_request_received(const std::shared_ptr<void> & data)\n+ServerBase::execute_result_request_received(\n+  rcl_ret_t ret,\n+  std::shared_ptr<void> result_request,\n+  rmw_request_id_t request_header)\n-  auto shared_ptr = std::static_pointer_cast\n-    <std::tuple<rcl_ret_t, std::shared_ptr<void>, rmw_request_id_t>>(data);\n-  auto ret = std::get<0>(*shared_ptr);\n-  auto result_request = std::get<1>(*shared_ptr);\n-  auto request_header = std::get<2>(*shared_ptr);\n-  pimpl_->result_request_ready_ = false;\n+\n+  EXPECT_NO_THROW(action_server_->take_data());\n+",
    "BackportedTo": "iron",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "revert call shutdown in LifecycleNode destructor (#2557)",
    "SHA": "f4923c6f43afaf983f95158584d37687f2679925",
    "Changes": "-  auto current_state = LifecycleNode::get_current_state().id();\n-  // shutdown if necessary to avoid leaving the device in any other primary state\n-  if (current_state < lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    if (node_base_->get_context()->is_valid()) {\n-      auto ret = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n-      auto finalized = LifecycleNode::shutdown(ret);\n-      if (finalized.id() != lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED ||\n-        ret != rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS)\n-      {\n-        RCLCPP_WARN(\n-          rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-          \"Shutdown error in destruction of LifecycleNode: final state(%s)\",\n-          finalized.label().c_str());\n-      }\n-    } else {\n-      // TODO(fujitatomoya): consider when context is gracefully shutdown before.\n-      RCLCPP_DEBUG(\n-        rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-        \"Context invalid error in destruction of LifecycleNode: Node still in transition state(%u)\",\n-        current_state);\n-    }\n-  } else if (current_state > lifecycle_msgs::msg::State::PRIMARY_STATE_FINALIZED) {\n-    RCLCPP_WARN(\n-      rclcpp::get_logger(\"rclcpp_lifecycle\"),\n-      \"Shutdown error in destruction of LifecycleNode: Node still in transition state(%u)\",\n... [truncated] ...\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-\n-  // PRIMARY_STATE_FINALIZED to shutdown via dtor\n-  shutdown_cb_called = false;\n-  {\n-    auto ret = reset_key;\n-    auto test_node = std::make_shared<rclcpp_lifecycle::LifecycleNode>(\"testnode\");\n-    test_node->register_on_shutdown(std::bind(on_shutdown_callback, std::placeholders::_1));\n-    auto configured = test_node->configure(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(configured.id(), State::PRIMARY_STATE_INACTIVE);\n-    ret = reset_key;\n-    auto activated = test_node->activate(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(activated.id(), State::PRIMARY_STATE_ACTIVE);\n-    ret = reset_key;\n-    auto finalized = test_node->shutdown(ret);\n-    EXPECT_EQ(success, ret);\n-    EXPECT_EQ(finalized.id(), State::PRIMARY_STATE_FINALIZED);\n-    EXPECT_TRUE(shutdown_cb_called);  // should be called already\n-  }\n-  EXPECT_TRUE(shutdown_cb_called);\n-}\n-",
    "BackportedTo": "iron",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Fix data race in EventHandlerBase (#2349)",
    "SHA": "411dbe8212dd753ee60871f8605d0a8beaae5e37",
    "Changes": "+  ~EventHandler()\n+  {\n+    // Since the rmw event listener holds a reference to the\n+    // \"on ready\" callback, we need to clear it on destruction of this class.\n+    // This clearing is not needed for other rclcpp entities like pub/subs, since\n+    // they do own the underlying rmw entities, which are destroyed\n+    // on their rclcpp destructors, thus no risk of dangling pointers.\n+    clear_on_ready_callback();\n+  }\n+\n-  // Since the rmw event listener holds a reference to\n-  // this callback, we need to clear it on destruction of this class.\n-  // This clearing is not needed for other rclcpp entities like pub/subs, since\n-  // they do own the underlying rmw entities, which are destroyed\n-  // on their rclcpp destructors, thus no risk of dangling pointers.\n-  clear_on_ready_callback();\n-",
    "BackportedTo": "iron",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Added missing include (#207)",
    "SHA": "c0295f312a245b3e69a75f667ba7addeaa58cec0",
    "Changes": "+#include <cstdint>",
    "BackportedTo": "jazzy",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "Fals"
  },
  {
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#204)",
    "SHA": "d1abed6f53a443849cd45cd22c4255e630a8b5b9",
    "Changes": "-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @methylDragon @wjwwood",
    "BackportedTo": "jazzy",
    "Label": "Other",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "fix memory leak for remove_all(). (#201)",
    "SHA": "ac4ee13bd59f552a823d78590279ee49443c7c2b",
    "Changes": "+#include \"rcpputils/scope_exit.hpp\"\n+  if (dir == nullptr) {\n+    return false;\n+  }\n+  RCPPUTILS_SCOPE_EXIT(closedir(dir));\n-  closedir(dir);",
    "BackportedTo": "jazzy",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Added missing include (#207)",
    "SHA": "c0295f312a245b3e69a75f667ba7addeaa58cec0",
    "Changes": "+#include <cstdint>",
    "BackportedTo": "humble",
    "Label": "Other",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "fix memory leak for remove_all(). (#201)",
    "SHA": "ac4ee13bd59f552a823d78590279ee49443c7c2b",
    "Changes": "+#include \"rcpputils/scope_exit.hpp\"\n+  if (dir == nullptr) {\n+    return false;\n+  }\n+  RCPPUTILS_SCOPE_EXIT(closedir(dir));\n-  closedir(dir);",
    "BackportedTo": "humble",
    "Label": "Bug Fix",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Generate version header with ament_generate_version_header function (#190)",
    "SHA": "bc0e3cfb4168fbc286034f0ee8d27319ffd1e945",
    "Changes": "+ament_generate_version_header(${PROJECT_NAME})\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>",
    "BackportedTo": "humble",
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "Included tl_expected (#185)",
    "SHA": "2a5bfd57bc16f69016ee4df1f6a517cde53e7a13",
    "Changes": "+# TODO (ahcorde): Remove tl_expected when CXX 20 standard is available\n-  find_package(ament_lint_auto REQUIRED)\n+\n+  find_package(ament_cmake_copyright REQUIRED)\n+  find_package(ament_cmake_cppcheck REQUIRED)\n+  find_package(ament_cmake_cpplint REQUIRED)\n+  find_package(ament_cmake_flake8 REQUIRED)\n+  find_package(ament_cmake_lint_cmake REQUIRED)\n+  find_package(ament_cmake_pep257 REQUIRED)\n+  find_package(ament_cmake_uncrustify REQUIRED)\n+  find_package(ament_cmake_xmllint REQUIRED)\n+\n+  set(\n+    _linter_excludes\n+    include/rcpputils/tl_expected/expected.hpp\n+  )\n+\n+  ament_copyright(EXCLUDE ${_linter_excludes})\n+  ament_cppcheck(\n+    EXCLUDE ${_linter_excludes}\n+    LANGUAGE c++\n+  )\n+  ament_cpplint(EXCLUDE ${_linter_excludes})\n+  ament_flake8(EXCLUDE ${_linter_excludes})\n+  ament_lint_cmake()\n... [truncated] ...\n+template <class T, class E,\n+          detail::enable_if_t<(std::is_void<T>::value ||\n+                               std::is_move_constructible<T>::value) &&\n+                              detail::is_swappable<T>::value &&\n+                              std::is_move_constructible<E>::value &&\n+                              detail::is_swappable<E>::value> * = nullptr>\n+void swap(expected<T, E> &lhs,\n+          expected<T, E> &rhs) noexcept(noexcept(lhs.swap(rhs))) {\n+  lhs.swap(rhs);\n+}\n+} // namespace tl\n+\n+#endif\n-  <test_depend>ament_lint_common</test_depend>\n-  <test_depend>ament_lint_auto</test_depend>\n+  <test_depend>ament_cmake_gtest</test_depend>\n+  <test_depend>ament_cmake_copyright</test_depend>\n+  <test_depend>ament_cmake_cppcheck</test_depend>\n+  <test_depend>ament_cmake_cpplint</test_depend>\n+  <test_depend>ament_cmake_flake8</test_depend>\n+  <test_depend>ament_cmake_lint_cmake</test_depend>\n+  <test_depend>ament_cmake_pep257</test_depend>\n+  <test_depend>ament_cmake_uncrustify</test_depend>\n+  <test_depend>ament_cmake_xmllint</test_depend>\n+",
    "BackportedTo": "humble",
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "Add stream operator for paths to make it easier to log (#120)",
    "SHA": "38295cf188a692dabc9a22151146bc37e7e1123a",
    "Changes": "+/**\n+* \\brief Convert the path to a string for ostream usage, such as in logging or string formatting.\n+*\n+* \\param os The stream to send the path string to\n+* \\param p The path to stringify\n+* \\return The ostream, for chaining\n+*/\n+RCPPUTILS_PUBLIC std::ostream & operator<<(std::ostream & os, const path & p);\n+\n+std::ostream & operator<<(std::ostream & os, const path & p)\n+{\n+  os << p.string();\n+  return os;\n+}\n+\n+\n+TEST(TestFilesystemHelper, stream_operator)\n+{\n+  path p{\"foo\"};\n+  std::stringstream s;\n+  s << \"bar\" << p;\n+  ASSERT_EQ(s.str(), \"barfoo\");\n+}",
    "BackportedTo": "foxy",
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Removed Github Actions (#105)",
    "SHA": "3b412ca6f4501d8556d96a8bb5761b2f158b8b82",
    "Changes": "-# Run linters automatically on pull requests.\n-name: Lint rcpputils\n-on:\n-  pull_request:\n-\n-jobs:\n-  ament_copyright:\n-    name: ament_copyright\n-    runs-on: ubuntu-18.04\n-    steps:\n-    - uses: actions/checkout@v1\n-    - uses: ros-tooling/setup-ros@0.0.23\n-    - uses: ros-tooling/action-ros-lint@0.0.6\n-      with:\n-        linter: copyright\n-        package-name: rcpputils\n-\n-  ament_xmllint:\n-    name: ament_xmllint\n-    runs-on: ubuntu-18.04\n-    steps:\n-    - uses: actions/checkout@v1\n-    - uses: ros-tooling/setup-ros@0.0.23\n-    - uses: ros-tooling/action-ros-lint@0.0.6\n-      with:\n... [truncated] ...\n-  pull_request:\n-  push:\n-    branches:\n-      - master\n-  schedule:\n-    # Run every hour. This helps detect flakiness,\n-    # and broken external dependencies.\n-    - cron:  '0 * * * *'\n-\n-jobs:\n-  build_and_test:\n-    runs-on: ${{ matrix.os }}\n-    strategy:\n-      fail-fast: false\n-      matrix:\n-          os: [ubuntu-18.04]\n-    steps:\n-    - uses: ros-tooling/setup-ros@0.0.23\n-    - uses: ros-tooling/action-ros-ci@0.0.17\n-      with:\n-        package-name: rcpputils\n-    - uses: actions/upload-artifact@v1\n-      with:\n-        name: colcon-logs\n-        path: ros_ws/log",
    "BackportedTo": "foxy",
    "Label": "Other",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#130)",
    "SHA": "0fab5eba931821e3b24d81743d3998304db500cc",
    "Changes": "-`rcpputils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n+`rcpputils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n-`rcpputils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n+`rcpputils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n-`rcpputils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcpputils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n-A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n-`rcpputils` follows the recommendations for performance testing of C/C++ code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcpputils` follows the recommendations for performance testing of C/C++ code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n-`rcpputils` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n+`rcpputils` uses and passes all the standard linters and static analysis tools for a C++ package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).",
    "BackportedTo": "foxy",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Update changelogs",
    "SHA": "8bc15da490e591a883947e22b843c2acdecc4309",
    "Changes": "+Forthcoming\n+-----------\n+* Clear the rcutils error when throwing an exception. (`#206 <https://github.com/ros2/rcpputils/issues/206>`_)\n+* Remove CODEOWNERS and mirror-rolling-to-master workflow. (`#204 <https://github.com/ros2/rcpputils/issues/204>`_)\n+* Contributors: Chris Lalancette\n+",
    "BackportedTo": "iron",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Generate version header with ament_generate_version_header function (#190)",
    "SHA": "bc0e3cfb4168fbc286034f0ee8d27319ffd1e945",
    "Changes": "+ament_generate_version_header(${PROJECT_NAME})\n+  <buildtool_depend>ament_cmake_gen_version_h</buildtool_depend>",
    "BackportedTo": "iron",
    "Label": "Functional Improvement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "Update changelogs",
    "SHA": "8bc15da490e591a883947e22b843c2acdecc4309",
    "Changes": "+Forthcoming\n+-----------\n+* Clear the rcutils error when throwing an exception. (`#206 <https://github.com/ros2/rcpputils/issues/206>`_)\n+* Remove CODEOWNERS and mirror-rolling-to-master workflow. (`#204 <https://github.com/ros2/rcpputils/issues/204>`_)\n+* Contributors: Chris Lalancette\n+",
    "BackportedTo": "iron",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  },
  {
    "RawMessage": "Included tl_expected (#185)",
    "SHA": "2a5bfd57bc16f69016ee4df1f6a517cde53e7a13",
    "Changes": "+# TODO (ahcorde): Remove tl_expected when CXX 20 standard is available\n-  find_package(ament_lint_auto REQUIRED)\n+\n+  find_package(ament_cmake_copyright REQUIRED)\n+  find_package(ament_cmake_cppcheck REQUIRED)\n+  find_package(ament_cmake_cpplint REQUIRED)\n+  find_package(ament_cmake_flake8 REQUIRED)\n+  find_package(ament_cmake_lint_cmake REQUIRED)\n+  find_package(ament_cmake_pep257 REQUIRED)\n+  find_package(ament_cmake_uncrustify REQUIRED)\n+  find_package(ament_cmake_xmllint REQUIRED)\n+\n+  set(\n+    _linter_excludes\n+    include/rcpputils/tl_expected/expected.hpp\n+  )\n+\n+  ament_copyright(EXCLUDE ${_linter_excludes})\n+  ament_cppcheck(\n+    EXCLUDE ${_linter_excludes}\n+    LANGUAGE c++\n+  )\n+  ament_cpplint(EXCLUDE ${_linter_excludes})\n+  ament_flake8(EXCLUDE ${_linter_excludes})\n+  ament_lint_cmake()\n... [truncated] ...\n+template <class T, class E,\n+          detail::enable_if_t<(std::is_void<T>::value ||\n+                               std::is_move_constructible<T>::value) &&\n+                              detail::is_swappable<T>::value &&\n+                              std::is_move_constructible<E>::value &&\n+                              detail::is_swappable<E>::value> * = nullptr>\n+void swap(expected<T, E> &lhs,\n+          expected<T, E> &rhs) noexcept(noexcept(lhs.swap(rhs))) {\n+  lhs.swap(rhs);\n+}\n+} // namespace tl\n+\n+#endif\n-  <test_depend>ament_lint_common</test_depend>\n-  <test_depend>ament_lint_auto</test_depend>\n+  <test_depend>ament_cmake_gtest</test_depend>\n+  <test_depend>ament_cmake_copyright</test_depend>\n+  <test_depend>ament_cmake_cppcheck</test_depend>\n+  <test_depend>ament_cmake_cpplint</test_depend>\n+  <test_depend>ament_cmake_flake8</test_depend>\n+  <test_depend>ament_cmake_lint_cmake</test_depend>\n+  <test_depend>ament_cmake_pep257</test_depend>\n+  <test_depend>ament_cmake_uncrustify</test_depend>\n+  <test_depend>ament_cmake_xmllint</test_depend>\n+",
    "BackportedTo": "iron",
    "Label": "NonFunctional Enhancement",
    "What made you assign": "Code Changes",
    "Agreed": "False"
  },
  {
    "RawMessage": "Update changelogs",
    "SHA": "8bc15da490e591a883947e22b843c2acdecc4309",
    "Changes": "+Forthcoming\n+-----------\n+* Clear the rcutils error when throwing an exception. (`#206 <https://github.com/ros2/rcpputils/issues/206>`_)\n+* Remove CODEOWNERS and mirror-rolling-to-master workflow. (`#204 <https://github.com/ros2/rcpputils/issues/204>`_)\n+* Contributors: Chris Lalancette\n+",
    "BackportedTo": "iron",
    "Label": "Documentation",
    "What made you assign": "Code Changes",
    "Agreed": "True"
  }

]
