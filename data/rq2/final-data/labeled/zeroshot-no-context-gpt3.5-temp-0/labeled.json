[
  {
    "Repository": "ros2cli",
    "SHA": "cf020c0f0f90ded9aca6ebac806c78a387347a25",
    "RawMessage": "Update the ros2cli test fixture to C\u002B\u002B17. (#789)",
    "Changes": "diff --git ros2lifecycle_test_fixtures/CMakeLists.txt ros2lifecycle_test_fixtures/CMakeLists.txt\nindex 5ed4fd1..1c36878 100644\n--- ros2lifecycle_test_fixtures/CMakeLists.txt\n\u002B\u002B\u002B ros2lifecycle_test_fixtures/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(ros2lifecycle_test_fixtures)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n \n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "80efa3fa0861da45c1f81622763d06fc1f76f129",
    "RawMessage": "Wait for action server in rcl_action comm tests. (#919)",
    "Changes": "diff --git rcl_action/test/rcl_action/test_action_communication.cpp rcl_action/test/rcl_action/test_action_communication.cpp\nindex 7f59fc3..c13685e 100644\n--- rcl_action/test/rcl_action/test_action_communication.cpp\n\u002B\u002B\u002B rcl_action/test/rcl_action/test_action_communication.cpp\n@@ -13,6 \u002B13,9 @@\n // limitations under the License.\n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Cthread\u003E\n\u002B\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n \n #include \u0022rcl_action/action_client.h\u0022\n@@ -109,6 \u002B112,21 @@ protected:\n       \u0026context,\n       rcl_get_default_allocator());\n     ASSERT_EQ(ret, RCL_RET_OK) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B    // Make sure action client has discovered action server.\n\u002B    bool is_available = false;\n\u002B    for (int i = 0; i \u003C 10; \u002B\u002Bi) {\n\u002B      ret = rcl_action_server_is_available(\n\u002B        \u0026this-\u003Enode, \u0026this-\u003Eaction_client, \u0026is_available);\n\u002B      EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B      rcl_reset_error();\n\u002B      if (is_available) {\n\u002B        break;\n\u002B      }\n\u002B      using namespace std::literals::chrono_literals;\n\u002B      std::this_thread::sleep_for(100ms);\n\u002B    }\n\u002B    ASSERT_TRUE(is_available);\n   }\n \n   void TearDown() override\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcpputils",
    "SHA": "8a94c1c189561bfd8115e1cbdd2c94f5706ef323",
    "RawMessage": "Mirror rolling to master",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\nnew file mode 100644\nindex 0000000..2885eb4\n--- /dev/null\n\u002B\u002B\u002B .github/workflows/mirror-rolling-to-master.yaml\n@@ -0,0 \u002B1,13 @@\n\u002Bname: Mirror rolling to master\n\u002B\n\u002Bon:\n\u002B  push:\n\u002B    branches: [ rolling ]\n\u002B\n\u002Bjobs:\n\u002B  mirror-to-master:\n\u002B    runs-on: ubuntu-latest\n\u002B    steps:\n\u002B    - uses: zofrex/mirror-branch@v1\n\u002B      with:\n\u002B        target-branch: master\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "84552d4f15bc371c5e40ce98e876b33e84b528ae",
    "RawMessage": "Move and update documentation for ROS 2 (#600)",
    "Changes": "diff --git rviz/doc/add-button.png rviz2/doc/add-button.png\nsimilarity index 100%\nrename from rviz/doc/add-button.png\nrename to rviz2/doc/add-button.png\ndiff --git rviz/doc/add-display-dialog.png rviz2/doc/add-display-dialog.png\nsimilarity index 100%\nrename from rviz/doc/add-display-dialog.png\nrename to rviz2/doc/add-display-dialog.png\ndiff --git rviz/doc/conf.py rviz2/doc/conf.py\nsimilarity index 99%\nrename from rviz/doc/conf.py\nrename to rviz2/doc/conf.py\nindex 27569319..d398a90d 100644\n--- rviz/doc/conf.py\n\u002B\u002B\u002B rviz2/doc/conf.py\n@@ -121,7 \u002B121,7 @@ html_theme_options = {}\n # Add any paths that contain custom static files (such as style sheets) here,\n # relative to this directory. They are copied after the builtin static files,\n # so a file named \u0022default.css\u0022 will overwrite the builtin \u0022default.css\u0022.\n-html_static_path = [\u0027_static\u0027]\n\u002B#html_static_path = [\u0027_static\u0027]\n \n # If not \u0027\u0027, a \u0027Last updated on:\u0027 timestamp is inserted at every page bottom,\n # using the given strftime format.\ndiff --git rviz/doc/display-properties.png rviz2/doc/display-properties.png\nsimilarity index 100%\nrename from rviz/doc/display-properties.png\nrename to rviz2/doc/display-properties.png\ndiff --git rviz/doc/display-statuses.png rviz2/doc/display-statuses.png\nsimilarity index 100%\nrename from rviz/doc/display-statuses.png\nrename to rviz2/doc/display-statuses.png\ndiff --git rviz/doc/empty-rviz.png rviz2/doc/empty-rviz.png\nsimilarity index 100%\nrename from rviz/doc/empty-rviz.png\nrename to rviz2/doc/empty-rviz.png\ndiff --git rviz/doc/focal-point.png rviz2/doc/focal-point.png\nsimilarity index 100%\nrename from rviz/doc/focal-point.png\nrename to rviz2/doc/focal-point.png\ndiff --git rviz/doc/grouped-displays.png rviz2/doc/grouped-displays.png\nsimilarity index 100%\nrename from rviz/doc/grouped-displays.png\nrename to rviz2/doc/grouped-displays.png\ndiff --git rviz/doc/index.rst rviz2/doc/index.rst\nsimilarity index 53%\nrename from rviz/doc/index.rst\nrename to rviz2/doc/index.rst\nindex c86c0287..42a35e7d 100644\n--- rviz/doc/index.rst\n\u002B\u002B\u002B rviz2/doc/index.rst\n@@ -4,48 \u002B4,40 @@ RViz User\u0027s Guide\n Troubleshooting\n ---------------\n \n-If you\u0027re running into problems and have not seen the answer below, try the \u0060Troubleshooting Page \u003Chttp://ros.org/wiki/rviz/Troubleshooting\u003E\u0060_.\n\u002BIf you\u0027re running into problems and have not seen the answer below, please try searching \u0060Answers \u003Chttps://answers.ros.org\u003E\u0060_.\n \n-Build/Startup\n----------------\n-\n-First satisfy any system dependencies.::\n\u002BInstallation\n\u002B------------\n \n-  rosdep install rviz\n\u002BPlease see the installation instructions for ROS 2 (which includes RViz) in the \u0060ROS 2 documentation \u003Chttps://index.ros.org/doc/ros2/Installation/#installationguide\u003E\u0060_.\n \n-Now build the visualizer::\n-\n-  rosmake rviz\n\u002BStartup\n\u002B-------\n \n-Then start the visualizer::\n\u002BTo start the visualizer::\n \n-  rosrun rviz rviz\n\u002B  ros2 run rviz2 rviz2\n \n When rviz starts for the first time, you will see an empty view:\n \n .. image:: empty-rviz.png\n \n-The central area with the grid is the 3D view. On the left is the\n-Displays list, which will show any displays you have loaded. Right now\n-it just contains the global options and the time view, which I\u0027ll get\n-to later. On the right are some of the other panels, described below.\n\u002BThe central area with the grid is the 3D view.\n\u002BOn the left is the Displays list, which will show any displays you have loaded.\n\u002BRight now it just contains the global options and the time view, which will be explained later.\n\u002BOn the right are some of the other panels, described below.\n \n Displays\n --------\n \n-A display is something that draws something in the 3D world, and\n-likely has some options available in the displays list. An example is\n-a point cloud, the robot state, etc.\n-\n-For the current list of RViz display types, see \u0060RViz Display Types\n-\u003Chttp://ros.org/wiki/rviz/DisplayTypes\u003E\u0060_.\n\u002BA display is something that draws something in the 3D world, and likely has some options available in the displays list.\n\u002BAn example is a point cloud, the robot state, etc.\n \n \n Adding a new display\n ....................\n \n-To add a display, type \u0022control-N\u0022 (for \u0022new\u0022) or click the Add button\n-at the bottom:\n\u002BTo add a display, type \u0022control-N\u0022 (for \u0022new\u0022) or click the Add button at the bottom:\n \n .. image:: add-button.png\n \n@@ -53,11 \u002B45,9 @@ This will pop up the new display dialog:\n \n .. image:: add-display-dialog.png\n \n-The list at the top shows the available display types, grouped by the\n-plugin that provides them. The text box in the middle gives a\n-description of the selected display type. At the bottom you can give a\n-name to the new instance of the display, which defaults to the name of\n-the type name.\n\u002BThe list at the top shows the available display types, grouped by the plugin that provides them.\n\u002BThe text box in the middle gives a description of the selected display type.\n\u002BAt the bottom a name can be given to the new instance of the display, which defaults to the name of the type name.\n \n Display Properties\n ..................\n@@ -69,48 \u002B59,41 @@ Each display gets its own list of properties. For example:\n Display Status\n ..............\n \n-Each display gets its own status to help let you know if everything is\n-OK or not. The status can be one of 4: OK, Warning, Error and\n-Disabled. The status is indicated in the display\u0027s title by the text\n-color and icon, as well as in the Status category that you can see if\n\u002BEach display gets its own status to show if everything is OK or not.\n\u002BThe status will be one of the following: OK, Warning, Error or Disabled.\n\u002BThe status is indicated in the display\u0027s title by the text color and icon, as well as in the Status category that can be seen if\n the display is expanded:\n \n .. image:: display-statuses.png\n \n-The Status category also expands to show specific status\n-information. This information is different for different displays, and\n-the messages should be self explanitory.  The top-level status level\n-for the display is set based on the worst of the sub-statuses.\n\u002BThe Status category also expands to show specific status information.\n\u002BThis information is different for different displays, and the messages should be self explanatory.\n\u002BThe top-level status level for the display is set based on the worst of the sub-statuses.\n \n Organizing Displays\n ...................\n \n-You can move displays up or down in the list by dragging them with the\n-left mouse button.  You can select multiple displays and drag them\n-together.  You can also create a \u0022Group\u0022 display, which serves as a\n-container for other displays.  Displays in a group can be enabled and\n-disabled together with the group\u0027s checkbox.  In this example, the\n-\u0022Sensor data\u0022 group has been disabled and the \u0022Plans\u0022 group is\n-enabled:\n\u002BDisplays can be moved up or down in the list by dragging them with the left mouse button.\n\u002BMultiple displays can be selected and dragged together.\n\u002BA \u0022Group\u0022 display can also be created, which serves as a container for other displays.\n\u002BDisplays in a group can be enabled and disabled together with the group\u0027s checkbox.\n\u002BIn this example, the \u0022Sensor data\u0022 group has been disabled and the \u0022Plans\u0022 group is enabled:\n \n .. image:: grouped-displays.png\n \n Naming Displays\n ...............\n \n-In the above example, the \u0022Group\u0022 and \u0022Path\u0022 displays have been given\n-meaningful names.  You can do this either at creation time in the new\n-display dialog (described above) or any time later by selecting one\n-display and typing \u0022control-R\u0022 (for \u0022rename\u0022) or by clicking the\n-\u0022Rename\u0022 button.\n\u002BIn the above example, the \u0022Group\u0022 and \u0022Path\u0022 displays have been given meaningful names.\n\u002BThis can be done either at creation time in the new display dialog (described above) or any time later by selecting a\n\u002Bdisplay and typing \u0022control-R\u0022 (for \u0022rename\u0022) or by clicking the \u0022Rename\u0022 button.\n \n Configurations\n --------------\n \n-Different configurations of displays are often useful for different\n-uses of the visualizer. A configuration useful for a full PR2 is not\n-necessarily useful for a test cart, for example. To this end, the\n-visualizer lets you load and save different configurations.\n\u002BDifferent configurations of displays are often useful for different uses of the visualizer.\n\u002BA configuration useful for a full PR2 is not necessarily useful for a test cart, for example.\n\u002BTo this end, the visualizer can load and save different configurations.\n \n A configuration contains:\n \n@@ -119,22 \u002B102,17 @@ A configuration contains:\n  * View controller type and settings for the initial viewpoint, plus saved views\n  * Window layout and the list of panels\n \n-RViz treats configurations similarly to files in an editor.  When a\n-configuration file is opened, changes are made, and the \u0022save\u0022 menu\n-(or control-\u0022s\u0022) is triggered, the original config file is\n-overwritten.\n\u002BRViz treats configurations similarly to files in an editor.\n\u002BWhen a configuration file is opened, changes are made, and the \u0022save\u0022 menu\n\u002B(or control-\u0022s\u0022) is triggered, the original config file is overwritten.\n \n When no config file is specified, rviz loads the file\n \u0060\u0060~/.rviz/default.rviz\u0060\u0060, creating it if it does not exist.\n \n-When a config file other than the default is in use, RViz includes the\n-file name in the window title bar.  An asterisk (\u0022*\u0022) next to the file\n-name indicates changes have been made since the last time the\n\u002BWhen a config file other than the default is in use, RViz includes the file name in the window title bar.\n\u002BAn asterisk (\u0022*\u0022) next to the file name indicates changes have been made since the last time the\n configuration was loaded or saved.\n-\n-The config file format is YAML.  This has changed since the Fuerte\n-version of RViz, so config files saved with Fuerte RViz will not load\n-in Groovy RViz.\n\u002BThe config file format is YAML.\n \n Views Panel\n -----------\n@@ -147,31 \u002B125,32 @@ use, and optionally a list of saved views:\n Clicking on a saved view (\u0022Top view\u0022 and \u0022Side view\u0022 above) copies\n it to the \u0022Current View\u0022 entry and activates it.\n \n-The properties of the current view change as you move the viewpoint\n\u002BThe properties of the current view change as the viewpoint is moved\n with the mouse in the 3D display, but they can also be edited directly\n via the keyboard for precise control.\n \n There is a combobox control labelled \u0022Type\u0022 at the top of the Views\n-panel.  This lets you change the type of the current view controller.\n\u002Bpanel.\n\u002BThis can be used to change the type of the current view controller.\n \n-To the right of it is the \u0022Zero\u0022 button.  This resets the current view\n-controller to look at the point \u00220, 0, 0\u0022 from a short distance away.\n-This is useful to get back to a known location if the viewpoint gets\n-\u0022lost\u0022.  The keyboard shortcut for \u0022Zero\u0022 is \u0022z\u0022.\n\u002BTo the right of it is the \u0022Zero\u0022 button.\n\u002BThis resets the current view controller to look at the point \u00220, 0, 0\u0022 from a short distance away.\n\u002BThis is useful to get back to a known location if the viewpoint gets \u0022lost\u0022.\n\u002BThe keyboard shortcut for \u0022Zero\u0022 is \u0022z\u0022.\n \n Built-in view types\n ...................\n \n-\u0022Views\u0022 in RViz are view controllers.  They control both the viewpoint\n-and the camera projection.  There are 4 built-in types, but more can\n-be added via plugins.\n\u002B\u0022Views\u0022 in RViz are view controllers.\n\u002BThey control both the viewpoint and the camera projection.\n\u002BThere are 4 built-in types, but more can be added via plugins.\n \n Orbit (default)\n ,,,,,,,,,,,,,,,\n \n The orbital camera simply rotates around a focal point, while always\n-looking at that point. The focal point is visualized as a small disc\n-while you\u0027re moving the camera:\n\u002Blooking at that point.\n\u002BThe focal point is visualized as a small disc while you\u0027re moving the camera:\n \n .. image:: focal-point.png\n \n@@ -187,8 \u002B166,8 @@ XYOrbit\n ,,,,,,,\n \n The \u0022XYOrbit\u0022 view controller is similar to Orbit, but the focal point\n-is constrained to move only in the XY plane.  Also, the focal point is\n-kept lower in the window and is cyan colored.\n\u002Bis constrained to move only in the XY plane.\n\u002BAlso, the focal point is kept lower in the window and is cyan colored.\n \n Controls:\n \n@@ -226,8 \u002B205,8 @@ Coordinate Frames\n -----------------\n \n RViz uses the tf transform system for transforming data from the\n-coordinate frame it arrives in into a global reference frame. There\n-are two coordinate frames that are important to know about in the\n\u002Bcoordinate frame it arrives in into a global reference frame.\n\u002BThere are two coordinate frames that are important to know about in the\n visualizer. Here is a \u0060video that explains them both \u003Chttp://www.youtube.com/watch?v=rZ0xyzfG-tY\u003E\u0060_.\n \n .. Should really implement a youtube directive for embedding videos.\n@@ -235,36 \u002B214,32 @@ visualizer. Here is a \u0060video that explains them both \u003Chttp://www.youtube.com/wat\n The Fixed Frame\n ...............\n \n-The more-important of the two frames is the fixed frame. The fixed\n-frame is the reference frame used to denote the \u0022world\u0022 frame. This is\n-usually the \u0022map\u0022, or \u0022world\u0022, or something similar, but can also be,\n-for example, your odometry frame.\n\u002BThe more-important of the two frames is the fixed frame.\n\u002BThe fixed frame is the reference frame used to denote the \u0022world\u0022 frame.\n\u002BThis is usually the \u0022map\u0022, or \u0022world\u0022, or something similar, but can also be,\n\u002Bfor example, an odometry frame.\n \n If the fixed frame is erroneously set to, say, the base of the robot,\n then all the objects the robot has ever seen will appear in front of\n the robot, at the position relative to the robot at which they were\n-detected. For correct results, the fixed frame should not be moving\n-relative to the world.\n\u002Bdetected.\n\u002BFor correct results, the fixed frame should not be moving relative to the world.\n \n-If you change the fixed frame, all data currently being shown is\n-cleared rather than re-transformed.\n\u002BIf the fixed frame is changed, all data currently being shown is cleared rather than re-transformed.\n \n The Target Frame\n ................\n \n-Most view controllers provide a \u0022target frame\u0022 which provides a\n-reference frame for the camera view. For example, if your target frame\n-is the map, you\u0027ll see the robot driving around the map. If your\n-target frame is the base of the robot, the robot will stay in the same\n-place while everything else moves relative to it.  The built-in view\n-controllers use the target frame only for position, and ignore its\n-orientation, so when the robot rotates, you will see it spin, but when\n-in drives it will stay in the same place in the view.\n\u002BMost view controllers provide a \u0022target frame\u0022 which provides a reference frame for the camera view.\n\u002BFor example, if the target frame is the map, you\u0027ll see the robot driving around the map.\n\u002BIf the target frame is the base of the robot, the robot will stay in the same place while everything else moves relative to it.\n\u002BThe built-in view controllers use the target frame only for position, and ignore its orientation,\n\u002Bso when the robot rotates, you will see it spin, but when it drives it will stay in the same place in the view.\n \n Tools\n -----\n \n-The visualizer has a number of tools you can use on the toolbar:\n\u002BThe visualizer has a number of tools that can be used on the toolbar:\n \n Move Camera\n ...........\n@@ -278,44 \u002B253,40 @@ Interact\n \n  * Keyboard shortcut: i\n \n-The Interact tool allows the use of Interactive Marker displays.  When\n-the mouse is not over an interactive element, it behaves like the Move\n-Camera tool.\n\u002BThe Interact tool allows the use of Interactive Marker displays.\n\u002BWhen the mouse is not over an interactive element, it behaves like the Move Camera tool.\n \n Select\n ......\n \n  * Keyboard shortcut: s\n \n-The Select tool allows you to select items being displayed in the 3D\n-view. It supports single-point selection as well as click/drag box\n-selection.\n\u002BThe Select tool allows you to select items being displayed in the 3D view.\n\u002BIt supports single-point selection as well as click/drag box selection.\n \n .. image:: selection-box.png\n \n Once objects are selected, they are surrounded by cyan-colored\n bounding boxes, and information about the selected objects can be\n-viewed in the \u0022Selection\u0022 panel.  Here you can see the position of the\n-robot link \u0022head_tilt_link\u0022 has been expanded to show the XYZ\n-coordinates:\n\u002Bviewed in the \u0022Selection\u0022 panel.\n\u002BHere you can see the position of the robot link \u0022head_tilt_link\u0022 has been expanded to show the XYZ coordinates:\n \n .. image:: selection-properties.png\n \n-You can add to a selection with the Shift key, and remove from the\n-selection with the Ctrl key. If you want to move the camera around\n-while selecting without switching back to the Move Camera tool you can\n\u002BYou can add to a selection with the Shift key, and remove from the selection with the Ctrl key.\n\u002BIf you want to move the camera around while selecting without switching back to the Move Camera tool you can\n hold down the Alt key.\n \n The f key will focus the camera on the current selection.\n \n 2D Goal Pose\n-...........\n\u002B............\n \n  * Keyboard shortcut: g\n \n-This tool lets you set a goal sent on the \u0022/goal_pose\u0022 ROS\n-topic. Click on a location on the ground plane and drag to select the\n-orientation.  The output topic can be changed in the \u0022Tool Properties\u0022 panel.\n\u002BThis tool lets you set a goal sent on the \u0022/goal_pose\u0022 ROS topic.\n\u002BClick on a location on the ground plane and drag to select the orientation.\n\u002BThe output topic can be changed in the \u0022Tool Properties\u0022 panel.\n \n This tool works with the navigation stack.\n \n@@ -324,18 \u002B295,16 @@ This tool works with the navigation stack.\n \n  * Keyboard shortcut: p\n \n-This tool lets you set an initial pose to seed the localization system\n-(sent on the \u0022/initialpose\u0022 ROS topic). Click on a location on the\n-ground plane and drag to select the orientation.  The output topic can\n-be changed in the \u0022Tool Properties\u0022 panel.\n\u002BThis tool lets you set an initial pose to seed the localization system (sent on the \u0022/initialpose\u0022 ROS topic).\n\u002BClick on a location on the ground plane and drag to select the orientation.\n\u002BThe output topic can be changed in the \u0022Tool Properties\u0022 panel.\n \n This tool works with the navigation stack.\n \n Time\n ----\n \n-The Time panel is mostly useful when running in a simulator: it allows\n-you to see how much ROS Time time has passed, vs. how much \u0022Wall\n\u002BThe Time panel is mostly useful when running in a simulator: it allows you to see how much ROS Time time has passed, vs. how much \u0022Wall\n Clock\u0022 (aka real) time has passed.\n \n The time panel also lets you reset the visualizer\u0027s internal time\n@@ -345,7 \u002B314,8 @@ of tf\u0027s internal cache of data.\n .. image:: time-panel.png\n \n If you are not running in simulation, the time panel is mostly\n-useless. In most cases it can be closed and you will probably not even\n\u002Buseless.\n\u002BIn most cases it can be closed and you will probably not even\n notice (other than having a bit more screen real estate for the rest\n of rviz).\n \n@@ -353,8 \u002B323,8 @@ Plugins\n -------\n \n RViz is setup so that new displays, tools, view controllers, and\n-panels can be added through plugins.  Installed plugins are indexed\n-and made available within RViz automatically.\n\u002Bpanels can be added through plugins.\n\u002BInstalled plugins are indexed and made available within RViz automatically.\n \n For information on writing your own RViz plugin, see the plugin\n tutorials within \u0060the RViz tutorials  wiki page\ndiff --git rviz/doc/selection-box.png rviz2/doc/selection-box.png\nsimilarity index 100%\nrename from rviz/doc/selection-box.png\nrename to rviz2/doc/selection-box.png\ndiff --git rviz/doc/selection-properties.png rviz2/doc/selection-properties.png\nsimilarity index 100%\nrename from rviz/doc/selection-properties.png\nrename to rviz2/doc/selection-properties.png\ndiff --git rviz/doc/time-panel.png rviz2/doc/time-panel.png\nsimilarity index 100%\nrename from rviz/doc/time-panel.png\nrename to rviz2/doc/time-panel.png\ndiff --git rviz/doc/views-panel.png rviz2/doc/views-panel.png\nsimilarity index 100%\nrename from rviz/doc/views-panel.png\nrename to rviz2/doc/views-panel.png\ndiff --git rviz/doc/youtube.py rviz2/doc/youtube.py\nsimilarity index 100%\nrename from rviz/doc/youtube.py\nrename to rviz2/doc/youtube.py\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "8e757c2c39e382a0523e4ce230e5719ea450f483",
    "RawMessage": "Avoid redefinition of default color materials (#1281)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/material_manager.cpp rviz_rendering/src/rviz_rendering/material_manager.cpp\nindex 7983e962..4076b0f8 100644\n--- rviz_rendering/src/rviz_rendering/material_manager.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/material_manager.cpp\n@@ -42,6 \u002B42,9 @@ namespace rviz_rendering\n void MaterialManager::createColorMaterial(\n   const std::string \u0026 name, const Ogre::ColourValue \u0026 color, bool use_self_illumination)\n {\n\u002B  if (Ogre::MaterialManager::getSingleton().resourceExists(name, \u0022rviz_rendering\u0022)) {\n\u002B    return;\n\u002B  }\n   Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingleton().create(name, \u0022rviz_rendering\u0022);\n   mat-\u003EsetAmbient(color * 0.5f);\n   mat-\u003EsetDiffuse(color);\n",
    "BackportedTo": "jazzy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "e559b212bf2b0cc3b6b89407f52b9f43c8b36682",
    "RawMessage": "Add verbose option to echo that also prints the associated message info (#707)",
    "Changes": "diff --git ros2topic/ros2topic/verb/echo.py ros2topic/ros2topic/verb/echo.py\nindex bfae04a..0eb7c1c 100644\n--- ros2topic/ros2topic/verb/echo.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/echo.py\n@@ -36,6 \u002B36,8 @@ from rosidl_runtime_py import message_to_csv\n from rosidl_runtime_py import message_to_yaml\n from rosidl_runtime_py.utilities import get_message\n \n\u002Bimport yaml\n\u002B\n DEFAULT_TRUNCATE_LENGTH = 128\n MsgType = TypeVar(\u0027MsgType\u0027)\n default_profile_str = \u0027sensor_data\u0027\n@@ -85,8 \u002B87,14 @@ class EchoVerb(VerbExtension):\n                  \u0027Automatically match existing publishers )\u0027)\n         parser.add_argument(\n             \u0027--csv\u0027, action=\u0027store_true\u0027,\n-            help=\u0027Output all recursive fields separated by commas (e.g. for \u0027\n-                 \u0027plotting)\u0027)\n\u002B            help=(\n\u002B                \u0027Output all recursive fields separated by commas (e.g. for \u0027\n\u002B                \u0027plotting). \u0027\n\u002B                \u0027If --include-message-info is also passed, the following fields are prepended: \u0027\n\u002B                \u0027source_timestamp, received_timestamp, publication_sequence_number,\u0027\n\u002B                \u0027 reception_sequence_number.\u0027\n\u002B            )\n\u002B        )\n         parser.add_argument(\n             \u0027--field\u0027, type=str, default=None,\n             help=\u0027Echo a selected field of a message. \u0027\n@@ -122,6 \u002B130,9 @@ class EchoVerb(VerbExtension):\n                                                  \u0027as well as m (the message).\u0027)\n         parser.add_argument(\n             \u0027--once\u0027, action=\u0027store_true\u0027, help=\u0027Print the first message received and then exit.\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--include-message-info\u0027, \u0027-i\u0027, action=\u0027store_true\u0027,\n\u002B            help=\u0027Shows the associated message info.\u0027)\n \n     def choose_qos(self, node, args):\n \n@@ -189,11 \u002B200,7 @@ class EchoVerb(VerbExtension):\n                 \u0022WARNING: \u0027--lost-messages\u0027 is deprecated; lost messages are reported by default\u0022,\n                 file=sys.stderr)\n \n-        # Select print function\n-        self.print_func = _print_yaml\n         self.csv = args.csv\n-        if self.csv:\n-            self.print_func = _print_csv\n \n         # Validate field selection\n         self.field = args.field\n@@ -214,6 \u002B221,7 @@ class EchoVerb(VerbExtension):\n         self.future = None\n         if args.once:\n             self.future = Future()\n\u002B        self.include_message_info = args.include_message_info\n \n         with NodeStrategy(args) as node:\n \n@@ -247,7 \u002B255,7 @@ class EchoVerb(VerbExtension):\n         message_type: MsgType,\n         qos_profile: QoSProfile,\n         no_report_lost_messages: bool,\n-        raw: bool\n\u002B        raw: bool,\n     ) -\u003E Optional[str]:\n         \u0022\u0022\u0022Initialize a node with a single subscription and spin.\u0022\u0022\u0022\n         event_callbacks = None\n@@ -277,7 \u002B285,7 @@ class EchoVerb(VerbExtension):\n         else:\n             rclpy.spin(node)\n \n-    def _subscriber_callback(self, msg):\n\u002B    def _subscriber_callback(self, msg, info):\n         submsg = msg\n         if self.field is not None:\n             for field in self.field:\n@@ -293,11 \u002B301,33 @@ class EchoVerb(VerbExtension):\n         if self.future is not None:\n             self.future.set_result(True)\n \n\u002B        if not hasattr(submsg, \u0027__slots__\u0027):\n\u002B            # raw\n\u002B            if self.include_message_info:\n\u002B                print(\u0027---Got new message, message info:---\u0027)\n\u002B                print(info)\n\u002B                print(\u0027---Message data:---\u0027)\n\u002B            print(submsg, end=\u0027\\n---\\n\u0027)\n\u002B            return\n\u002B\n         if self.csv:\n-            self.print_func(submsg, self.truncate_length, self.no_arr, self.no_str)\n-        else:\n-            self.print_func(\n-                submsg, self.truncate_length, self.no_arr, self.no_str, self.flow_style)\n\u002B            to_print = message_to_csv(\n\u002B                submsg,\n\u002B                truncate_length=self.truncate_length,\n\u002B                no_arr=self.no_arr,\n\u002B                no_str=self.no_str)\n\u002B            if self.include_message_info:\n\u002B                to_print = f\u0027{\u0022,\u0022.join(str(x) for x in info.values())},{to_print}\u0027\n\u002B            print(to_print)\n\u002B            return\n\u002B        # yaml\n\u002B        if self.include_message_info:\n\u002B            print(yaml.dump(info), end=\u0027---\\n\u0027)\n\u002B        print(\n\u002B            message_to_yaml(\n\u002B                submsg, truncate_length=self.truncate_length,\n\u002B                no_arr=self.no_arr, no_str=self.no_str, flow_style=self.flow_style),\n\u002B            end=\u0027---\\n\u0027)\n \n \n def _expr_eval(expr):\n@@ -306,24 \u002B336,6 @@ def _expr_eval(expr):\n     return eval_fn\n \n \n-def _print_yaml(msg, truncate_length, noarr, nostr, flowstyle):\n-    if hasattr(msg, \u0027__slots__\u0027):\n-        print(\n-            message_to_yaml(\n-                msg, truncate_length=truncate_length,\n-                no_arr=noarr, no_str=nostr, flow_style=flowstyle),\n-            end=\u0027---\\n\u0027)\n-    else:\n-        print(msg, end=\u0027\\n---\\n\u0027)\n-\n-\n-def _print_csv(msg, truncate_length, noarr, nostr):\n-    if hasattr(msg, \u0027__slots__\u0027):\n-        print(message_to_csv(msg, truncate_length=truncate_length, no_arr=noarr, no_str=nostr))\n-    else:\n-        print(msg)\n-\n-\n def _message_lost_event_callback(message_lost_status):\n     print(\n         \u0027A message was lost!!!\\n\\ttotal count change:\u0027\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "ee221485aef4a1e6551ede22be2990019694260d",
    "RawMessage": "Add top-level try_shutdown method. (#1302)",
    "Changes": "diff --git rclpy/rclpy/__init__.py rclpy/rclpy/__init__.py\nindex d53d667..7ad9b86 100644\n--- rclpy/rclpy/__init__.py\n\u002B\u002B\u002B rclpy/rclpy/__init__.py\n@@ -56,7 \u002B56,7 @@ from rclpy.utilities import get_default_context\n from rclpy.utilities import get_rmw_implementation_identifier  # noqa: F401\n from rclpy.utilities import ok  # noqa: F401 forwarding to this module\n from rclpy.utilities import shutdown as _shutdown\n-from rclpy.utilities import try_shutdown  # noqa: F401\n\u002Bfrom rclpy.utilities import try_shutdown as _try_shutdown\n \n # Avoid loading extensions on module import\n if TYPE_CHECKING:\n@@ -100,7 \u002B100,7 @@ class InitContextManager:\n         exc_val: Optional[BaseException],\n         exc_tb: Optional[TracebackType],\n     ) -\u003E None:\n-        shutdown(context=self.context, uninstall_handlers=self.installed_signal_handlers)\n\u002B        try_shutdown(context=self.context, uninstall_handlers=self.installed_signal_handlers)\n \n \n def init(\n@@ -171,6 \u002B171,32 @@ def shutdown(\n         uninstall_signal_handlers()\n \n \n\u002Bdef try_shutdown(\n\u002B    *,\n\u002B    context: Optional[Context] = None,\n\u002B    uninstall_handlers: Optional[bool] = None\n\u002B) -\u003E None:\n\u002B    \u0022\u0022\u0022\n\u002B    Shutdown a previously initialized context if not already shutdown.\n\u002B\n\u002B    This will also shutdown the global executor.\n\u002B\n\u002B    :param context: The context to invalidate. If \u0060\u0060None\u0060\u0060, then the default context is used\n\u002B        (see :func:\u0060.get_default_context\u0060).\n\u002B    :param uninstall_handlers:\n\u002B        If \u0060None\u0060, signal handlers will be uninstalled when shutting down the default context.\n\u002B        If \u0060True\u0060, signal handlers will be uninstalled.\n\u002B        If \u0060False\u0060, signal handlers won\u0027t be uninstalled.\n\u002B    \u0022\u0022\u0022\n\u002B    _try_shutdown(context=context)\n\u002B    if (\n\u002B        uninstall_handlers or (\n\u002B            uninstall_handlers is None and (\n\u002B                context is None or context is get_default_context()))\n\u002B    ):\n\u002B        uninstall_signal_handlers()\n\u002B\n\u002B\n def create_node(\n     node_name: str,\n     *,\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "ee27b75395d85035311ea8191d17a9389c08639a",
    "RawMessage": "use one copy for continuous area instead of loop copy (#312)",
    "Changes": "diff --git src/array_list.c src/array_list.c\nindex bea877a..c498c3c 100644\n--- src/array_list.c\n\u002B\u002B\u002B src/array_list.c\n@@ -168,10 \u002B168,11 @@ rcutils_array_list_remove(rcutils_array_list_t * array_list, size_t index)\n   ARRAY_LIST_VALIDATE_INDEX_IN_BOUNDS(array_list, index);\n \n   // Shift all the data in the list to replace the missing data\n-  for (size_t i = index; i \u003C (array_list-\u003Eimpl-\u003Esize - 1); \u002B\u002Bi) {\n-    uint8_t * dst_ptr = rcutils_array_list_get_pointer_for_index(array_list, i);\n-    uint8_t * src_ptr = rcutils_array_list_get_pointer_for_index(array_list, i \u002B 1);\n-    memcpy(dst_ptr, src_ptr, array_list-\u003Eimpl-\u003Edata_size);\n\u002B  size_t copy_count = array_list-\u003Eimpl-\u003Esize - (index \u002B 1);\n\u002B  if (copy_count \u003E 0) {\n\u002B    uint8_t * dst_ptr = rcutils_array_list_get_pointer_for_index(array_list, index);\n\u002B    uint8_t * src_ptr = rcutils_array_list_get_pointer_for_index(array_list, index \u002B 1);\n\u002B    memcpy(dst_ptr, src_ptr, array_list-\u003Eimpl-\u003Edata_size * copy_count);\n   }\n \n   array_list-\u003Eimpl-\u003Esize--;\ndiff --git test/test_array_list.cpp test/test_array_list.cpp\nindex 46d4179..122b010 100644\n--- test/test_array_list.cpp\n\u002B\u002B\u002B test/test_array_list.cpp\n@@ -374,6 \u002B374,39 @@ TEST_F(ArrayListPreInitTest, remove_preserves_data_around_it) {\n   ret = rcutils_array_list_get(\u0026list, 2, \u0026ret_data);\n   EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n   EXPECT_EQ((uint32_t)6, ret_data) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_remove(\u0026list, 2);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_get_size(\u0026list, \u0026size);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ(size, (size_t)2);\n\u002B\n\u002B  ret = rcutils_array_list_get(\u0026list, 0, \u0026ret_data);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ((uint32_t)0, ret_data) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_get(\u0026list, 1, \u0026ret_data);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ((uint32_t)2, ret_data) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_remove(\u0026list, 0);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_get_size(\u0026list, \u0026size);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ(size, (size_t)1);\n\u002B\n\u002B  ret = rcutils_array_list_get(\u0026list, 0, \u0026ret_data);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ((uint32_t)2, ret_data) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_remove(\u0026list, 0);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rcutils_array_list_get_size(\u0026list, \u0026size);\n\u002B  EXPECT_EQ(RCUTILS_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  EXPECT_EQ(size, (size_t)0);\n }\n \n TEST_F(ArrayListPreInitTest, init_list_twice_fails) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "88ddc22c1220cf321a75587b055a4373dd2b1e52",
    "RawMessage": "Use the macros from Cyclone DDS to work with sample payload when using SHM (#300)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 5a883ac..0aa6b68 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1611,7 \u002B1611,7 @@ static rmw_ret_t publish_loaned_int(\n   // if the publisher allow loaning\n   if (cdds_publisher-\u003Eis_loaning_available) {\n     auto d = std::make_unique\u003Cserdata_rmw\u003E(cdds_publisher-\u003Esertype, ddsi_serdata_kind::SDK_DATA);\n-    d-\u003Eiox_chunk = SHIFT_BACK_ICEORYX_HEADER(ros_message);\n\u002B    d-\u003Eiox_chunk = SHIFT_BACK_TO_ICEORYX_HEADER(ros_message);\n     if (dds_writecdr(cdds_publisher-\u003Eenth, d.release()) \u003E= 0) {\n       return RMW_RET_OK;\n     } else {\n@@ -2304,7 \u002B2304,7 @@ static rmw_ret_t borrow_loaned_message_int(\n     dds_data_allocator_init(cdds_publisher-\u003Eenth, \u0026cdds_publisher-\u003Edata_allocator);\n     // allocate memory for message \u002B header\n     auto sample_size = rmw_cyclonedds_cpp::get_message_size(type_support);\n-    auto chunk_size = GET_ICEORYX_CHUNK_SIZE(sample_size);\n\u002B    auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(sample_size);\n     auto chunk_ptr = dds_data_allocator_alloc(\n       \u0026cdds_publisher-\u003Edata_allocator, chunk_size);\n     RMW_CHECK_FOR_NULL_WITH_MSG(\n@@ -2371,7 \u002B2371,7 @@ static rmw_ret_t return_loaned_message_from_publisher_int(\n     // free the message memory\n     dds_data_allocator_free(\n       \u0026cdds_publisher-\u003Edata_allocator,\n-      SHIFT_BACK_ICEORYX_HEADER(loaned_message));\n\u002B      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n     // fini data collector\n     dds_data_allocator_fini(\u0026cdds_publisher-\u003Edata_allocator);\n     return RMW_RET_OK;\n@@ -3165,7 \u002B3165,7 @@ static rmw_ret_t return_loaned_message_from_subscription_int(\n   if (cdds_subscription-\u003Eis_loaning_available) {\n     dds_data_allocator_t data_allocator;\n     dds_data_allocator_init(cdds_subscription-\u003Eenth, \u0026data_allocator);\n-    dds_data_allocator_free(\u0026data_allocator, SHIFT_BACK_ICEORYX_HEADER(loaned_message));\n\u002B    dds_data_allocator_free(\u0026data_allocator, SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n     dds_data_allocator_fini(\u0026data_allocator);\n   } else {\n     RMW_SET_ERROR_MSG(\u0022returning loan for a non fixed type is not allowed\u0022);\ndiff --git rmw_cyclonedds_cpp/src/serdata.hpp rmw_cyclonedds_cpp/src/serdata.hpp\nindex fe48e7f..f07b3f0 100644\n--- rmw_cyclonedds_cpp/src/serdata.hpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdata.hpp\n@@ -21,7 \u002B21,9 @@\n #include \u0022bytewise.hpp\u0022\n #include \u0022dds/dds.h\u0022\n #include \u0022dds/ddsi/ddsi_serdata.h\u0022\n\u002B#ifdef DDS_HAS_SHM\n #include \u0022dds/ddsi/q_xmsg.h\u0022\n\u002B#endif  // DDS_HAS_SHM\n \n #if !DDS_HAS_DDSI_SERTYPE\n #define ddsi_sertype ddsi_sertopic\n@@ -30,17 \u002B32,6 @@\n #define sertype_rmw_ops sertopic_rmw_ops\n #endif\n \n-#ifdef DDS_HAS_SHM\n-#define GET_ICEORYX_CHUNK_SIZE(sample_size) \\\n-  (uint32_t) (sizeof(iceoryx_header_t) \u002B 8 - (sizeof(iceoryx_header_t) % 8) \u002B (sample_size))\n-#define SHIFT_PAST_ICEORYX_HEADER(chunk) \\\n-  (static_cast\u003Cvoid *\u003E((reinterpret_cast\u003Cchar *\u003E(chunk)) \u002B \\\n-  sizeof(iceoryx_header_t) \u002B 8 - (sizeof(iceoryx_header_t) % 8)))\n-#define SHIFT_BACK_ICEORYX_HEADER(chunk) \\\n-  (static_cast\u003Cvoid *\u003E((reinterpret_cast\u003Cchar *\u003E(chunk)) - \\\n-  sizeof(iceoryx_header_t) - 8 \u002B (sizeof(iceoryx_header_t) % 8)))\n-#endif  // DDS_HAS_SHM\n-\n namespace rmw_cyclonedds_cpp\n {\n class BaseCDRWriter;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "703992c68986bf66490ae3274a62bfcd38e55e08",
    "RawMessage": "Introduce RMW_DURATION_INFINITE constant and API return value promise (#301)",
    "Changes": "diff --git rmw/CMakeLists.txt rmw/CMakeLists.txt\nindex 93b959e..f3b2fb3 100644\n--- rmw/CMakeLists.txt\n\u002B\u002B\u002B rmw/CMakeLists.txt\n@@ -36,6 \u002B36,7 @@ set(rmw_sources\n   \u0022src/sanity_checks.c\u0022\n   \u0022src/security_options.c\u0022\n   \u0022src/subscription_options.c\u0022\n\u002B  \u0022src/time.c\u0022\n   \u0022src/topic_endpoint_info_array.c\u0022\n   \u0022src/topic_endpoint_info.c\u0022\n   \u0022src/types.c\u0022\ndiff --git rmw/include/rmw/get_topic_endpoint_info.h rmw/include/rmw/get_topic_endpoint_info.h\nindex b9f6ae6..bde2ffa 100644\n--- rmw/include/rmw/get_topic_endpoint_info.h\n\u002B\u002B\u002B rmw/include/rmw/get_topic_endpoint_info.h\n@@ -72,6 \u002B72,8 @@ extern \u0022C\u0022\n  *   left unchanged on failure.\n  *   If populated, it is up to the caller to finalize this array later on,\n  *   using rmw_topic_endpoint_info_array_fini().\n\u002B *   QoS Profiles in the info array will use RMW_DURATION_INFINITE for infinite durations,\n\u002B *   avoiding exposing any implementation-specific values.\n  * \\return \u0060RMW_RET_OK\u0060 if the query was successful, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060node\u0060 is NULL, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060allocator\u0060 is not valid,\n@@ -142,6 \u002B144,8 @@ rmw_get_publishers_info_by_topic(\n  *   left unchanged on failure.\n  *   If populated, it is up to the caller to finalize this array later on,\n  *   using rmw_topic_endpoint_info_array_fini().\n\u002B *   QoS Profiles in the info array will use RMW_DURATION_INFINITE for infinite durations,\n\u002B *   avoiding exposing any implementation-specific values.\n  * \\return \u0060RMW_RET_OK\u0060 if the query was successful, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060node\u0060 is NULL, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060allocator\u0060 is not valid,\ndiff --git rmw/include/rmw/time.h rmw/include/rmw/time.h\nnew file mode 100644\nindex 0000000..1405333\n--- /dev/null\n\u002B\u002B\u002B rmw/include/rmw/time.h\n@@ -0,0 \u002B1,92 @@\n\u002B// Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RMW__TIME_H_\n\u002B#define RMW__TIME_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif  // __cplusplus\n\u002B\n\u002B#include \u003Cstdint.h\u003E\n\u002B\n\u002B#include \u0022rcutils/time.h\u0022\n\u002B\n\u002B#include \u0022rmw/macros.h\u0022\n\u002B#include \u0022rmw/visibility_control.h\u0022\n\u002B\n\u002B/// A struct representing a duration or relative time in RMW - does not encode an origin.\n\u002Btypedef struct RMW_PUBLIC_TYPE rmw_time_t\n\u002B{\n\u002B  /// Seconds component\n\u002B  uint64_t sec;\n\u002B\n\u002B  /// Nanoseconds component\n\u002B  uint64_t nsec;\n\u002B} rmw_time_t;\n\u002B\n\u002Btypedef rcutils_time_point_value_t rmw_time_point_value_t;\n\u002Btypedef rcutils_duration_value_t rmw_duration_t;\n\u002B\n\u002B/// Constant representing an infinite duration. Use rmw_time_equal for comparisons.\n\u002B/**\n\u002B  * Different RMW implementations have different representations for infinite durations.\n\u002B  * This value is reported for QoS policy durations that are left unspecified.\n\u002B  * Do not directly compare \u0060sec == sec \u0026\u0026 nsec == nsec\u0060, because we don\u0027t want to be sensitive\n\u002B  * to non-normalized values (nsec \u003E 1 second) - use rmw_time_equal instead.\n\u002B  * This value is INT64_MAX nanoseconds = 0x7FFF FFFF FFFF FFFF = d 9 223 372 036 854 775 807\n\u002B  *\n\u002B  * Note: these constants cannot be \u0060static const rmw_time_t\u0060 because in C that can\u0027t be used\n\u002B  * as a compile-time initializer\n\u002B  */\n\u002B#define RMW_DURATION_INFINITE {9223372036LL, 854775807LL}\n\u002B#define RMW_DURATION_UNSPECIFIED {0LL, 0LL}\n\u002B\n\u002B/// Check whether two rmw_time_t represent the same time.\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Bbool\n\u002Brmw_time_equal(const rmw_time_t left, const rmw_time_t right);\n\u002B\n\u002B/// Return the total nanosecond representation of a time.\n\u002B/**\n\u002B  * \\return INT64_MAX if input is too large to store in 64 bits\n\u002B  */\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_duration_t\n\u002Brmw_time_total_nsec(const rmw_time_t time);\n\u002B\n\u002B/// Construct rmw_time_t from a total nanoseconds representation.\n\u002B/**\n\u002B  * rmw_time_t only specifies relative time, so the origin is not relevant for this calculation.\n\u002B  * \\return RMW_DURATION_INFINITE if input is negative, which is not representable in rmw_time_t\n\u002B  */\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_time_t\n\u002Brmw_time_from_nsec(const rmw_duration_t nanoseconds);\n\u002B\n\u002B/// Ensure that an rmw_time_t does not have nanoseconds \u003E 1 second.\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_time_t\n\u002Brmw_time_normalize(const rmw_time_t time);\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif  // __cplusplus\n\u002B\n\u002B#endif  // RMW__TIME_H_\ndiff --git rmw/include/rmw/types.h rmw/include/rmw/types.h\nindex fa14c66..478b23a 100644\n--- rmw/include/rmw/types.h\n\u002B\u002B\u002B rmw/include/rmw/types.h\n@@ -33,6 \u002B33,7 @@ extern \u0022C\u0022\n #include \u0022rmw/ret_types.h\u0022\n #include \u0022rmw/security_options.h\u0022\n #include \u0022rmw/serialized_message.h\u0022\n\u002B#include \u0022rmw/time.h\u0022\n #include \u0022rmw/visibility_control.h\u0022\n \n // 24 bytes is the most memory needed to represent the GID by any current\n@@ -318,18 \u002B319,6 @@ typedef struct RMW_PUBLIC_TYPE rmw_request_id_t\n   int64_t sequence_number;\n } rmw_request_id_t;\n \n-/// Struct representing a time point for rmw\n-typedef struct RMW_PUBLIC_TYPE rmw_time_t\n-{\n-  /// Seconds since the epoch\n-  uint64_t sec;\n-\n-  /// Nanoseconds component of this time point\n-  uint64_t nsec;\n-} rmw_time_t;\n-\n-typedef rcutils_time_point_value_t rmw_time_point_value_t;\n-\n /// Meta-data for a service-related take.\n typedef struct RMW_PUBLIC_TYPE rmw_service_info_t\n {\n@@ -424,14 \u002B413,14 @@ enum RMW_PUBLIC_TYPE rmw_qos_liveliness_policy_t\n   RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4\n };\n \n-/// QoS Deadline default, 0s indicates deadline policies are not tracked or enforced\n-#define RMW_QOS_DEADLINE_DEFAULT {0, 0}\n\u002B/// QoS Deadline default.\n\u002B#define RMW_QOS_DEADLINE_DEFAULT RMW_DURATION_UNSPECIFIED\n \n-/// QoS Lifespan default, 0s indicate lifespan policies are not tracked or enforced\n-#define RMW_QOS_LIFESPAN_DEFAULT {0, 0}\n\u002B/// QoS Lifespan default.\n\u002B#define RMW_QOS_LIFESPAN_DEFAULT RMW_DURATION_UNSPECIFIED\n \n-/// QoS Liveliness lease duration default, 0s indicate lease durations are not tracked or enforced\n-#define RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT {0, 0}\n\u002B/// QoS Liveliness lease duration default.\n\u002B#define RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT RMW_DURATION_UNSPECIFIED\n \n /// ROS MiddleWare quality of service profile.\n typedef struct RMW_PUBLIC_TYPE rmw_qos_profile_t\n@@ -444,12 \u002B433,27 @@ typedef struct RMW_PUBLIC_TYPE rmw_qos_profile_t\n   /// Durability QoS policy setting\n   enum rmw_qos_durability_policy_t durability;\n   /// The period at which messages are expected to be sent/received\n\u002B  /**\n\u002B    * RMW_DURATION_UNSPEFICIED will use the RMW implementation\u0027s default value,\n\u002B    *   which may or may not be infinite.\n\u002B    * RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation.\n\u002B    */\n   struct rmw_time_t deadline;\n   /// The age at which messages are considered expired and no longer valid\n\u002B  /**\n\u002B    * RMW_DURATION_UNSPEFICIED will use the RMW implementation\u0027s default value,\n\u002B    *   which may or may not be infinite.\n\u002B    * RMW_DURATION_INFINITE explicitly states that messages do not expire.\n\u002B    */\n   struct rmw_time_t lifespan;\n   /// Liveliness QoS policy setting\n   enum rmw_qos_liveliness_policy_t liveliness;\n   /// The time within which the RMW node or publisher must show that it is alive\n\u002B  /**\n\u002B    * RMW_DURATION_UNSPEFICIED will use the RMW implementation\u0027s default value,\n\u002B    *   which may or may not be infinite.\n\u002B    * RMW_DURATION_INFINITE explicitly states that liveliness is not enforced.\n\u002B    */\n   struct rmw_time_t liveliness_lease_duration;\n \n   /// If true, any ROS specific namespacing conventions will be circumvented.\ndiff --git rmw/src/time.c rmw/src/time.c\nnew file mode 100644\nindex 0000000..e6b103e\n--- /dev/null\n\u002B\u002B\u002B rmw/src/time.c\n@@ -0,0 \u002B1,68 @@\n\u002B// Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022rmw/time.h\u0022\n\u002B\n\u002B#include \u0022rcutils/time.h\u0022\n\u002B\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Bbool\n\u002Brmw_time_equal(const rmw_time_t left, const rmw_time_t right)\n\u002B{\n\u002B  return rmw_time_total_nsec(left) == rmw_time_total_nsec(right);\n\u002B}\n\u002B\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_duration_t\n\u002Brmw_time_total_nsec(const rmw_time_t time)\n\u002B{\n\u002B  static const uint64_t max_sec = INT64_MAX / RCUTILS_S_TO_NS(1);\n\u002B  if (time.sec \u003E max_sec) {\n\u002B    // Seconds not representable in nanoseconds\n\u002B    return INT64_MAX;\n\u002B  }\n\u002B\n\u002B  const int64_t sec_as_nsec = RCUTILS_S_TO_NS(time.sec);\n\u002B  if (time.nsec \u003E (uint64_t)(INT64_MAX - sec_as_nsec)) {\n\u002B    // overflow\n\u002B    return INT64_MAX;\n\u002B  }\n\u002B  return sec_as_nsec \u002B time.nsec;\n\u002B}\n\u002B\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_time_t\n\u002Brmw_time_from_nsec(const rmw_duration_t nanoseconds)\n\u002B{\n\u002B  if (nanoseconds \u003C 0) {\n\u002B    return (rmw_time_t)RMW_DURATION_INFINITE;\n\u002B  }\n\u002B\n\u002B  // Avoid typing the 1 billion constant\n\u002B  rmw_time_t time;\n\u002B  time.sec = RCUTILS_NS_TO_S(nanoseconds);\n\u002B  time.nsec = nanoseconds % RCUTILS_S_TO_NS(1);\n\u002B  return time;\n\u002B}\n\u002B\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_time_t\n\u002Brmw_time_normalize(const rmw_time_t time)\n\u002B{\n\u002B  return rmw_time_from_nsec(rmw_time_total_nsec(time));\n\u002B}\ndiff --git rmw/test/CMakeLists.txt rmw/test/CMakeLists.txt\nindex cea827e..2f13aed 100644\n--- rmw/test/CMakeLists.txt\n\u002B\u002B\u002B rmw/test/CMakeLists.txt\n@@ -121,6 \u002B121,15 @@ if(TARGET test_subscription_options)\n   target_link_libraries(test_subscription_options ${PROJECT_NAME})\n endif()\n \n\u002Bament_add_gmock(test_time\n\u002B  test_time.cpp\n\u002B  # Append the directory of librmw so it is found at test time.\n\u002B  APPEND_LIBRARY_DIRS \u0022$\u003CTARGET_FILE_DIR:${PROJECT_NAME}\u003E\u0022\n\u002B)\n\u002Bif(TARGET test_time)\n\u002B  target_link_libraries(test_time ${PROJECT_NAME})\n\u002Bendif()\n\u002B\n ament_add_gmock(test_types\n   test_types.cpp\n   # Append the directory of librmw so it is found at test time.\ndiff --git rmw/test/test_time.cpp rmw/test/test_time.cpp\nnew file mode 100644\nindex 0000000..f69691e\n--- /dev/null\n\u002B\u002B\u002B rmw/test/test_time.cpp\n@@ -0,0 \u002B1,120 @@\n\u002B// Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022gmock/gmock.h\u0022\n\u002B#include \u0022rmw/time.h\u0022\n\u002B\n\u002BTEST(test_time, time_equal) {\n\u002B  {\n\u002B    rmw_time_t a{100, 100};\n\u002B    rmw_time_t b{100, 100};\n\u002B    ASSERT_TRUE(rmw_time_equal(a, b));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t a{0, 0};\n\u002B    rmw_time_t b{0, 0};\n\u002B    ASSERT_TRUE(rmw_time_equal(a, b));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t a{0, 100};\n\u002B    rmw_time_t b{100, 0};\n\u002B    ASSERT_FALSE(rmw_time_equal(a, b));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t a{0, 1000000000};\n\u002B    rmw_time_t b{1, 0};\n\u002B    ASSERT_TRUE(rmw_time_equal(a, b));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t a{2, 100};\n\u002B    rmw_time_t b{1, 1000000100};\n\u002B    ASSERT_TRUE(rmw_time_equal(a, b));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t a{1, 100};\n\u002B    rmw_time_t b{1, 101};\n\u002B    ASSERT_FALSE(rmw_time_equal(a, b));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST(test_time, time_total_nsec) {\n\u002B  static const rmw_duration_t MAXTIME = INT64_MAX;\n\u002B  {\n\u002B    rmw_time_t time{1, 1};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), 1000000001);\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t time{0, 0};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), 0);\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t time{0, 123456789};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), 123456789);\n\u002B  }\n\u002B  {\n\u002B    // Should not overflow\n\u002B    rmw_time_t time{0, MAXTIME};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), MAXTIME);\n\u002B  }\n\u002B  {\n\u002B    // Will overflow, expect clamp\n\u002B    rmw_time_t time{1, MAXTIME};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), MAXTIME);\n\u002B  }\n\u002B  {\n\u002B    // Overflow on seconds alone, not at the type limit\n\u002B    rmw_time_t time{1ll \u003C\u003C 35, 0};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), MAXTIME);\n\u002B  }\n\u002B  {\n\u002B    // Very big overflow with arbitrary values\n\u002B    rmw_time_t time{MAXTIME - 20, 12};\n\u002B    EXPECT_EQ(rmw_time_total_nsec(time), MAXTIME);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST(test_time, time_from_nsec) {\n\u002B  {\n\u002B    rmw_time_t zero = rmw_time_from_nsec(0);\n\u002B    EXPECT_TRUE(rmw_time_equal({0, 0}, zero));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t less_than_sec = rmw_time_from_nsec(100000);\n\u002B    EXPECT_TRUE(rmw_time_equal({0, 100000}, less_than_sec));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t time = rmw_time_from_nsec(INT64_MAX);\n\u002B    EXPECT_TRUE(rmw_time_equal(time, RMW_DURATION_INFINITE));\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t negative = rmw_time_from_nsec(-1);\n\u002B    EXPECT_TRUE(rmw_time_equal(negative, RMW_DURATION_INFINITE));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST(test_time, time_normalize) {\n\u002B  {\n\u002B    rmw_time_t bad{0, 1234567890};\n\u002B    rmw_time_t good{1, 234567890};\n\u002B    rmw_time_t normalized = rmw_time_normalize(bad);\n\u002B    EXPECT_EQ(good.sec, normalized.sec);\n\u002B    EXPECT_EQ(good.nsec, normalized.nsec);\n\u002B  }\n\u002B  {\n\u002B    rmw_time_t good{10, 10};\n\u002B    rmw_time_t normalized = rmw_time_normalize(good);\n\u002B    EXPECT_EQ(good.sec, normalized.sec);\n\u002B    EXPECT_EQ(good.nsec, normalized.nsec);\n\u002B  }\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_dds",
    "SHA": "ec8143d44004909acd5e646d0884d9e221dca1b8",
    "RawMessage": "remove .github/ISSUE_TEMPLATE.md (old version of templates) (#63)",
    "Changes": "diff --git .github/ISSUE_TEMPLATE.md .github/ISSUE_TEMPLATE.md\ndeleted file mode 100644\nindex f705392..0000000\n--- .github/ISSUE_TEMPLATE.md\n\u002B\u002B\u002B /dev/null\n@@ -1,45 \u002B0,0 @@\n-\u003C!--\n-For general questions, please ask on ROS answers: https://answers.ros.org, make sure to include at least the \u0060ros2\u0060 tag and the rosdistro version you are running, e.g. \u0060ardent\u0060.\n-For general design discussions, please post on discourse: https://discourse.ros.org/c/ng-ros\n-Not sure if this is the right repository? Open an issue on https://github.com/ros2/ros2/issues\n-For Bug report or feature requests, please fill out the relevant category below\n---\u003E\n-\n-## Bug report\n-\n-**Required Info:**\n-\n-- Operating System:\n-  - \u003C!-- OS and version (e.g. Windows 10, Ubuntu 16.04...) --\u003E\n-- Installation type:\n-  - \u003C!-- binaries or from source  --\u003E\n-- Version or commit hash:\n-  - \u003C!-- Output of git rev-parse HEAD, release version, or repos file  --\u003E\n-- DDS implementation:\n-  - \u003C!-- rmw_implementation used (e.g. Fast-RTPS, RTI Connext, etc --\u003E\n-- Client library (if applicable):\n-  - \u003C!-- e.g. rclcpp, rclpy, or N/A --\u003E\n-\n-#### Steps to reproduce issue\n-\u003C!-- Detailed instructions on how to reliably reproduce this issue http://sscce.org/\n-\u0060\u0060\u0060 code that can be copy-pasted is preferred \u0060\u0060\u0060 --\u003E\n-\u0060\u0060\u0060\n-\n-\u0060\u0060\u0060\n-\n-#### Expected behavior\n-\n-#### Actual behavior\n-\n-#### Additional information\n-\n-\u003C!-- If you are reporting a bug delete everything below\n-     If you are requesting a feature deleted everything above this line --\u003E\n-----\n-## Feature request\n-\n-#### Feature description\n-\u003C!-- Description in a few sentences what the feature consists of and what problem it will solve --\u003E\n-\n-#### Implementation considerations\n-\u003C!-- Relevant information on how the feature could be implemented and pros and cons of the different solutions --\u003E\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "b12c55d0b5e7d0cf1c51f41288e87b9dc1156539",
    "RawMessage": "Fix up some overwritten errors. (#246)",
    "Changes": "diff --git test_rmw_implementation/test/test_publisher_allocator.cpp test_rmw_implementation/test/test_publisher_allocator.cpp\nindex 00359e7..4e817e4 100644\n--- test_rmw_implementation/test/test_publisher_allocator.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_publisher_allocator.cpp\n@@ -11,17 \u002B11,21 @@\n // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n // See the License for the specific language governing permissions and\n // limitations under the License.\n\u002B\n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/rmw.h\u0022\n \n TEST(TestPublisherAllocator, init_fini_publisher_allocation)\n {\n-  if (rmw_init_publisher_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n-    // Add tests here when the implementation it\u0027s supported\n\u002B  rmw_ret_t ret = rmw_init_publisher_allocation(nullptr, nullptr, nullptr);\n\u002B  rmw_reset_error();\n\u002B  if (ret == RMW_RET_UNSUPPORTED) {\n     GTEST_SKIP();\n-  } else {\n-    rmw_ret_t ret = rmw_fini_publisher_allocation(nullptr);\n-    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n   }\n\u002B\n\u002B  ASSERT_NE(ret, RMW_RET_UNSUPPORTED);\n\u002B\n\u002B  // TODO(anyone): Add tests here when the API has been implemented\n }\ndiff --git test_rmw_implementation/test/test_qos_profile_check_compatible.cpp test_rmw_implementation/test/test_qos_profile_check_compatible.cpp\nindex 9d4b128..e6462e8 100644\n--- test_rmw_implementation/test/test_qos_profile_check_compatible.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_qos_profile_check_compatible.cpp\n@@ -14,6 \u002B14,7 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/qos_profiles.h\u0022\n \n TEST(TestQoSProfilesAreCompatible, compatible) {\n@@ -43,6 \u002B44,7 @@ TEST(TestQoSProfilesAreCompatible, invalid_input) {\n     rmw_ret_t ret = rmw_qos_profile_check_compatible(\n       rmw_qos_profile_sensor_data, rmw_qos_profile_sensor_data, nullptr, nullptr, 0u);\n     EXPECT_EQ(ret, RMW_RET_INVALID_ARGUMENT);\n\u002B    rmw_reset_error();\n   }\n   // Error on null reason and non-zero size\n   {\n@@ -50,5 \u002B52,6 @@ TEST(TestQoSProfilesAreCompatible, invalid_input) {\n     rmw_ret_t ret = rmw_qos_profile_check_compatible(\n       rmw_qos_profile_sensor_data, rmw_qos_profile_sensor_data, \u0026compatible, nullptr, 1u);\n     EXPECT_EQ(ret, RMW_RET_INVALID_ARGUMENT);\n\u002B    rmw_reset_error();\n   }\n }\ndiff --git test_rmw_implementation/test/test_serialize_deserialize.cpp test_rmw_implementation/test/test_serialize_deserialize.cpp\nindex e40e15a..7426e8c 100644\n--- test_rmw_implementation/test/test_serialize_deserialize.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_serialize_deserialize.cpp\n@@ -246,8 \u002B246,13 @@ TEST(TestSerializeDeserialize, clean_round_trip_for_cpp_bounded_message) {\n \n TEST(TestSerializeDeserialize, rmw_get_serialized_message_size)\n {\n-  if (rmw_get_serialized_message_size(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n-    // TODO(anyone): Add tests here when the implementation it\u0027s supported\n\u002B  rmw_ret_t ret = rmw_get_serialized_message_size(nullptr, nullptr, nullptr);\n\u002B  rmw_reset_error();\n\u002B  if (ret == RMW_RET_UNSUPPORTED) {\n     GTEST_SKIP();\n   }\n\u002B\n\u002B  ASSERT_NE(ret, RMW_RET_UNSUPPORTED);\n\u002B\n\u002B  // TODO(anyone): Add tests here when the API has been implemented\n }\ndiff --git test_rmw_implementation/test/test_subscription_allocator.cpp test_rmw_implementation/test/test_subscription_allocator.cpp\nindex 2e3f59d..3b8e99e 100644\n--- test_rmw_implementation/test/test_subscription_allocator.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_subscription_allocator.cpp\n@@ -11,17 \u002B11,21 @@\n // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n // See the License for the specific language governing permissions and\n // limitations under the License.\n\u002B\n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/rmw.h\u0022\n \n TEST(TestSubscriptionAllocator, init_fini_subscription_allocation)\n {\n-  if (rmw_init_subscription_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n-    // Add tests here when the implementation it\u0027s supported\n\u002B  rmw_ret_t ret = rmw_init_subscription_allocation(nullptr, nullptr, nullptr);\n\u002B  rmw_reset_error();\n\u002B  if (ret == RMW_RET_UNSUPPORTED) {\n     GTEST_SKIP();\n-  } else {\n-    rmw_ret_t ret = rmw_fini_subscription_allocation(nullptr);\n-    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n   }\n\u002B\n\u002B  ASSERT_NE(ret, RMW_RET_UNSUPPORTED);\n\u002B\n\u002B  // TODO(anyone): Add tests here when the API has been implemented\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "e6c063a6de5b97b6d98c9f919871f976d5063c11",
    "RawMessage": "Depend on rosidl_core_generators for packages required by actions (#144)",
    "Changes": "diff --git action_msgs/CMakeLists.txt action_msgs/CMakeLists.txt\nindex 003082c..b8799f4 100644\n--- action_msgs/CMakeLists.txt\n\u002B\u002B\u002B action_msgs/CMakeLists.txt\n@@ -12,7 \u002B12,9 @@ endif()\n \n find_package(ament_cmake REQUIRED)\n find_package(builtin_interfaces REQUIRED)\n-find_package(rosidl_default_generators REQUIRED)\n\u002B# Depend on \u0022core\u0022 generators instead of \u0022default\u0022 generators\n\u002B# because ROS actions depend on this package\n\u002Bfind_package(rosidl_core_generators REQUIRED)\n find_package(unique_identifier_msgs REQUIRED)\n \n set(msg_files\n@@ -36,6 \u002B38,6 @@ if(BUILD_TESTING)\n   ament_lint_auto_find_test_dependencies()\n endif()\n \n-ament_export_dependencies(rosidl_default_runtime)\n\u002Bament_export_dependencies(rosidl_core_runtime)\n \n ament_package()\ndiff --git action_msgs/QUALITY_DECLARATION.md action_msgs/QUALITY_DECLARATION.md\nindex f905b76..69f1835 100644\n--- action_msgs/QUALITY_DECLARATION.md\n\u002B\u002B\u002B action_msgs/QUALITY_DECLARATION.md\n@@ -90,7 \u002B90,7 @@ The nightly test can be found at [here](http://build.ros2.org/view/Rpr/job/Rpr__\n \n \u0060action_msgs\u0060 has the following runtime ROS dependencies, which are at **Quality Level 1**:\n * \u0060builtin_interfaces\u0060: [QUALITY DECLARATION](../builtin_interfaces/QUALITY_DECLARATION.md)\n-* \u0060rosidl_default_runtime\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_core_runtime\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_core/tree/master/rosidl_core_runtime/QUALITY_DECLARATION.md)\n * \u0060unique_identifier_msgs\u0060: [QUALITY DECLARATION](https://github.com/ros2/unique_identifier_msgs/tree/master/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\ndiff --git action_msgs/package.xml action_msgs/package.xml\nindex 284e4df..58a9839 100644\n--- action_msgs/package.xml\n\u002B\u002B\u002B action_msgs/package.xml\n@@ -14,12 \u002B14,12 @@\n   \u003Cauthor email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n-  \u003Cbuildtool_depend\u003Erosidl_default_generators\u003C/buildtool_depend\u003E\n\u002B  \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n   \u003Cdepend\u003Eunique_identifier_msgs\u003C/depend\u003E\n \n-  \u003Cexec_depend\u003Erosidl_default_runtime\u003C/exec_depend\u003E\n\u002B  \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\n \n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\ndiff --git builtin_interfaces/CMakeLists.txt builtin_interfaces/CMakeLists.txt\nindex 23741d5..2e35a84 100644\n--- builtin_interfaces/CMakeLists.txt\n\u002B\u002B\u002B builtin_interfaces/CMakeLists.txt\n@@ -11,7 \u002B11,9 @@ if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n endif()\n \n find_package(ament_cmake REQUIRED)\n-find_package(rosidl_default_generators REQUIRED)\n\u002B# Depend on \u0022core\u0022 generators instead of \u0022default\u0022 generators\n\u002B# because ROS actions depend on this package\n\u002Bfind_package(rosidl_core_generators REQUIRED)\n \n rosidl_generate_interfaces(${PROJECT_NAME}\n   \u0022msg/Duration.msg\u0022\n@@ -19,6 \u002B21,6 @@ rosidl_generate_interfaces(${PROJECT_NAME}\n   ADD_LINTER_TESTS\n )\n \n-ament_export_dependencies(rosidl_default_runtime)\n\u002Bament_export_dependencies(rosidl_core_runtime)\n \n ament_package()\ndiff --git builtin_interfaces/QUALITY_DECLARATION.md builtin_interfaces/QUALITY_DECLARATION.md\nindex 46d8636..48ffe3c 100644\n--- builtin_interfaces/QUALITY_DECLARATION.md\n\u002B\u002B\u002B builtin_interfaces/QUALITY_DECLARATION.md\n@@ -89,7 \u002B89,7 @@ The nightly test can be found at [here](http://build.ros2.org/view/Rpr/job/Rpr__\n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n \u0060builtin_interfaces\u0060 has the following ROS dependencies, which are at **Quality Level 1**:\n-* \u0060rosidl_default_runtime\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_core_runtime\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_core/tree/master/rosidl_core_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git builtin_interfaces/package.xml builtin_interfaces/package.xml\nindex 5c691f6..d16bd6e 100644\n--- builtin_interfaces/package.xml\n\u002B\u002B\u002B builtin_interfaces/package.xml\n@@ -14,9 \u002B14,9 @@\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n-  \u003Cbuildtool_depend\u003Erosidl_default_generators\u003C/buildtool_depend\u003E\n\u002B  \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n-  \u003Cexec_depend\u003Erosidl_default_runtime\u003C/exec_depend\u003E\n\u002B  \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\n \n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n \ndiff --git test_msgs/package.xml test_msgs/package.xml\nindex 7cb4483..098a7df 100644\n--- test_msgs/package.xml\n\u002B\u002B\u002B test_msgs/package.xml\n@@ -19,7 \u002B19,6 @@\n   \u003Cbuild_depend\u003Ebuiltin_interfaces\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Etest_interface_files\u003C/build_depend\u003E\n \n-  \u003Cdepend\u003Eaction_msgs\u003C/depend\u003E\n   \u003Cexec_depend\u003Ebuiltin_interfaces\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Erosidl_default_runtime\u003C/exec_depend\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "5a298f908eb8e39b33309d7fad8697353f1fb5da",
    "RawMessage": "clear relative callback of Buffer if MessageFilter is destroyed (#490)",
    "Changes": "diff --git tf2_ros/include/tf2_ros/async_buffer_interface.h tf2_ros/include/tf2_ros/async_buffer_interface.h\nindex bc6e9164..88950f05 100644\n--- tf2_ros/include/tf2_ros/async_buffer_interface.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/async_buffer_interface.h\n@@ -33,8 \u002B33,10 @@\n #include \u003Cfunctional\u003E\n #include \u003Cfuture\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n \n #include \u0022tf2_ros/visibility_control.h\u0022\n\u002B#include \u0022tf2/buffer_core.h\u0022\n #include \u0022tf2/time.h\u0022\n #include \u0022tf2/transform_datatypes.h\u0022\n \n@@ -43,7 \u002B45,39 @@\n namespace tf2_ros\n {\n \n-using TransformStampedFuture = std::shared_future\u003Cgeometry_msgs::msg::TransformStamped\u003E;\n\u002Bclass TransformStampedFuture : public std::shared_future\u003Cgeometry_msgs::msg::TransformStamped\u003E\n\u002B{\n\u002B  using BaseType = std::shared_future\u003Cgeometry_msgs::msg::TransformStamped\u003E;\n\u002B\n\u002Bpublic:\n\u002B  /// Constructor\n\u002B  explicit TransformStampedFuture(BaseType \u0026\u0026 future) noexcept\n\u002B  : BaseType(std::move(future)) {}\n\u002B\n\u002B  /// Copy constructor\n\u002B  TransformStampedFuture(const TransformStampedFuture \u0026 ts_future) noexcept\n\u002B  : BaseType(ts_future),\n\u002B    handle_(ts_future.handle_) {}\n\u002B\n\u002B  /// Move constructor\n\u002B  TransformStampedFuture(TransformStampedFuture \u0026\u0026 ts_future) noexcept\n\u002B  : BaseType(std::move(ts_future)),\n\u002B    handle_(std::move(ts_future.handle_)) {}\n\u002B\n\u002B  void setHandle(const tf2::TransformableRequestHandle handle)\n\u002B  {\n\u002B    handle_ = handle;\n\u002B  }\n\u002B\n\u002B  tf2::TransformableRequestHandle getHandle() const\n\u002B  {\n\u002B    return handle_;\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  tf2::TransformableRequestHandle handle_ {};\n\u002B};\n\u002B\n using TransformReadyCallback = std::function\u003Cvoid (const TransformStampedFuture \u0026)\u003E;\n \n /**\n@@ -75,6 \u002B109,13 @@ public:\n     const tf2::TimePoint \u0026 time,\n     const tf2::Duration \u0026 timeout,\n     TransformReadyCallback callback) = 0;\n\u002B\n\u002B  /**\n\u002B   * \\brief Cancel the future to make sure the callback of requested transform is clean.\n\u002B   * \\param ts_future The future to the requested transform.\n\u002B   */\n\u002B  virtual void\n\u002B  cancel(const TransformStampedFuture \u0026 ts_future) = 0;\n };  // class AsyncBufferInterface\n \n }  // namespace tf2_ros\ndiff --git tf2_ros/include/tf2_ros/buffer.h tf2_ros/include/tf2_ros/buffer.h\nindex f1086c06..66975086 100644\n--- tf2_ros/include/tf2_ros/buffer.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/buffer.h\n@@ -252,6 \u002B252,14 @@ public:\n       callback);\n   }\n \n\u002B  /**\n\u002B   * \\brief Cancel the future to make sure the callback of requested transform is clean.\n\u002B   * \\param ts_future The future to the requested transform.\n\u002B   */\n\u002B  TF2_ROS_PUBLIC\n\u002B  void\n\u002B  cancel(const TransformStampedFuture \u0026 ts_future) override;\n\u002B\n   TF2_ROS_PUBLIC\n   inline void\n   setCreateTimerInterface(CreateTimerInterface::SharedPtr create_timer_interface)\ndiff --git tf2_ros/include/tf2_ros/buffer_interface.h tf2_ros/include/tf2_ros/buffer_interface.h\nindex 381fa585..4f5e4c31 100644\n--- tf2_ros/include/tf2_ros/buffer_interface.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/buffer_interface.h\n@@ -49,8 \u002B49,6 @@\n \n namespace tf2_ros\n {\n-using TransformStampedFuture = std::shared_future\u003Cgeometry_msgs::msg::TransformStamped\u003E;\n-using TransformReadyCallback = std::function\u003Cvoid (const TransformStampedFuture \u0026)\u003E;\n \n inline builtin_interfaces::msg::Time toMsg(const tf2::TimePoint \u0026 t)\n {\ndiff --git tf2_ros/include/tf2_ros/message_filter.h tf2_ros/include/tf2_ros/message_filter.h\nindex 9267b1f1..f20eb38d 100644\n--- tf2_ros/include/tf2_ros/message_filter.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/message_filter.h\n@@ -43,6 \u002B43,8 @@\n #include \u003Cstring\u003E\n #include \u003Ctuple\u003E\n #include \u003Ctype_traits\u003E\n\u002B#include \u003Cunordered_map\u003E\n\u002B#include \u003Cutility\u003E\n #include \u003Cvector\u003E\n \n #include \u0022message_filters/connection.h\u0022\n@@ -335,6 \u002B337,14 @@ public:\n    */\n   void clear()\n   {\n\u002B    {\n\u002B      std::unique_lock\u003Cstd::mutex\u003E lock(ts_futures_mutex_);\n\u002B      for (auto \u0026 kv : ts_futures_) {\n\u002B        buffer_.cancel(kv.second);\n\u002B      }\n\u002B      ts_futures_.clear();\n\u002B    }\n\u002B\n     std::unique_lock\u003Cstd::mutex\u003E unique_lock(messages_mutex_);\n \n     TF2_ROS_MESSAGEFILTER_DEBUG(\u0022%s\u0022, \u0022Cleared\u0022);\n@@ -423,12 \u002B433,19 @@ public:\n       const auto \u0026 handle = std::get\u003C0\u003E(param);\n       const auto \u0026 stamp = std::get\u003C1\u003E(param);\n       const auto \u0026 target_frame = std::get\u003C2\u003E(param);\n-      buffer_.waitForTransform(\n\u002B      tf2_ros::TransformStampedFuture future = buffer_.waitForTransform(\n         target_frame,\n         frame_id,\n         stamp,\n         buffer_timeout_,\n         std::bind(\u0026MessageFilter::transformReadyCallback, this, std::placeholders::_1, handle));\n\u002B\n\u002B      // If handle of future is 0 or 0xffffffffffffffffULL, waitForTransform have already called\n\u002B      // the callback.\n\u002B      if (0 != future.getHandle() || 0xffffffffffffffffULL != future.getHandle()) {\n\u002B        std::unique_lock\u003Cstd::mutex\u003E lock(ts_futures_mutex_);\n\u002B        ts_futures_.insert({handle, std::move(future)});\n\u002B      }\n     }\n   }\n \n@@ -485,6 \u002B502,14 @@ private:\n     MEvent saved_event;\n     bool event_found = false;\n \n\u002B    {\n\u002B      std::unique_lock\u003Cstd::mutex\u003E lock(ts_futures_mutex_);\n\u002B      auto iter = ts_futures_.find(handle);\n\u002B      if (iter != ts_futures_.end()) {\n\u002B        ts_futures_.erase(iter);\n\u002B      }\n\u002B    }\n\u002B\n     {\n       // We will be accessing and mutating messages now, require unique lock\n       std::unique_lock\u003Cstd::mutex\u003E lock(messages_mutex_);\n@@ -748,6 \u002B773,13 @@ private:\n \n   // Timeout duration when calling the buffer method \u0027waitForTransform\u0027\n   tf2::Duration buffer_timeout_;\n\u002B\n\u002B  ///\u003C The mutex used for locking TransformStampedFuture map operations\n\u002B  std::mutex ts_futures_mutex_;\n\u002B\n\u002B  ///\u003C Store the TransformStampedFuture returned by \u0027waitForTransform\u0027,\n\u002B  // to clear the callback in the Buffer if MessageFiltered object is destroyed.\n\u002B  std::unordered_map\u003Cuint64_t, tf2_ros::TransformStampedFuture\u003E ts_futures_;\n };\n }  // namespace tf2_ros\n \ndiff --git tf2_ros/src/buffer.cpp tf2_ros/src/buffer.cpp\nindex 434ccd80..3e83f50e 100644\n--- tf2_ros/src/buffer.cpp\n\u002B\u002B\u002B tf2_ros/src/buffer.cpp\n@@ -240,6 \u002B240,7 @@ Buffer::waitForTransform(\n     };\n \n   auto handle = addTransformableRequest(cb, target_frame, source_frame, time);\n\u002B  future.setHandle(handle);\n   if (0 == handle) {\n     // Immediately transformable\n     geometry_msgs::msg::TransformStamped msg_stamped = lookupTransform(\n@@ -266,6 \u002B267,18 @@ Buffer::waitForTransform(\n   return future;\n }\n \n\u002Bvoid\n\u002BBuffer::cancel(const TransformStampedFuture \u0026 ts_future)\n\u002B{\n\u002B  cancelTransformableRequest(ts_future.getHandle());\n\u002B\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(timer_to_request_map_mutex_);\n\u002B  auto iter = timer_to_request_map_.find(ts_future.getHandle());\n\u002B  if (iter != timer_to_request_map_.end()) {\n\u002B    timer_to_request_map_.erase(iter);\n\u002B  }\n\u002B}\n\u002B\n void\n Buffer::timerCallback(\n   const TimerHandle \u0026 timer_handle,\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2f0e1ef39da47d6bf37b99acd76fd660565f6304",
    "RawMessage": "Add tracepoint for publish/subscribe serialized message (#485)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 5dd8bb5..7f47a2d 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1989,9 \u002B1989,13 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n     serialized_message, \u0022serialized message handle is null\u0022,\n     return RMW_RET_INVALID_ARGUMENT);\n   auto pub = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n\u002B  const dds_time_t tstamp = dds_time();\n\u002B  TRACETOOLS_TRACEPOINT(rmw_publish, (const void *)publisher, serialized_message, tstamp);\n \n   struct ddsi_serdata * d = serdata_rmw_from_serialized_message(\n     pub-\u003Esertype, serialized_message-\u003Ebuffer, serialized_message-\u003Ebuffer_length);\n\u002B  d-\u003Etimestamp.v = tstamp;\n\u002B  d-\u003Estatusinfo = 0;\n \n #ifdef DDS_HAS_SHM\n   // publishing a serialized message when SHM is available\n@@ -2005,7 \u002B2009,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n   }\n #endif\n \n-  const bool ok = (dds_writecdr(pub-\u003Eenth, d) \u003E= 0);\n\u002B  const bool ok = (dds_forwardcdr(pub-\u003Eenth, d) \u003E= 0);\n   return ok ? RMW_RET_OK : RMW_RET_ERROR;\n }\n \n@@ -3458,6 \u002B3462,12 @@ static rmw_ret_t rmw_take_ser_int(\n           serialized_message-\u003Ebuffer_length = size;\n           ddsi_serdata_unref(d);\n           *taken = true;\n\u002B          TRACETOOLS_TRACEPOINT(\n\u002B            rmw_take,\n\u002B            static_cast\u003Cconst void *\u003E(subscription),\n\u002B            static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B            (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B            *taken);\n           return RMW_RET_OK;\n         } else if (iox_header-\u003Eshm_data_state == IOX_CHUNK_CONTAINS_RAW_DATA) {\n           if (rmw_serialize(d-\u003Eiox_chunk, \u0026sub-\u003Etype_supports, serialized_message) != RMW_RET_OK) {\n@@ -3468,6 \u002B3478,12 @@ static rmw_ret_t rmw_take_ser_int(\n           }\n           ddsi_serdata_unref(d);\n           *taken = true;\n\u002B          TRACETOOLS_TRACEPOINT(\n\u002B            rmw_take,\n\u002B            static_cast\u003Cconst void *\u003E(subscription),\n\u002B            static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B            (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B            *taken);\n           return RMW_RET_OK;\n         } else {\n           RMW_SET_ERROR_MSG(\u0022The recieved sample over SHM is not initialized\u0022);\n@@ -3489,12 \u002B3505,24 @@ static rmw_ret_t rmw_take_ser_int(\n         serialized_message-\u003Ebuffer_length = size;\n         ddsi_serdata_unref(d);\n         *taken = true;\n\u002B        TRACETOOLS_TRACEPOINT(\n\u002B          rmw_take,\n\u002B          static_cast\u003Cconst void *\u003E(subscription),\n\u002B          static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B          (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B          *taken);\n         return RMW_RET_OK;\n       }\n     }\n     ddsi_serdata_unref(d);\n   }\n   *taken = false;\n\u002B  TRACETOOLS_TRACEPOINT(\n\u002B    rmw_take,\n\u002B    static_cast\u003Cconst void *\u003E(subscription),\n\u002B    static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B    0LL,\n\u002B    *taken);\n   return RMW_RET_OK;\n }\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "403f305b15b734508859aae3c8dc15f6aeed242c",
    "RawMessage": "Fix a typo in a comment. (#2283)",
    "Changes": "diff --git rclcpp_action/include/rclcpp_action/server_goal_handle.hpp rclcpp_action/include/rclcpp_action/server_goal_handle.hpp\nindex b77eaf27..7d178191 100644\n--- rclcpp_action/include/rclcpp_action/server_goal_handle.hpp\n\u002B\u002B\u002B rclcpp_action/include/rclcpp_action/server_goal_handle.hpp\n@@ -128,7 \u002B128,7 @@ class Server;\n  * accepted.\n  * A \u0060Server\u0060 will create an instance and give it to the user in their \u0060handle_accepted\u0060 callback.\n  *\n- * Internally, this class is responsible for coverting between the C\u002B\u002B action type and generic\n\u002B * Internally, this class is responsible for converting between the C\u002B\u002B action type and generic\n  * types for \u0060rclcpp_action::ServerGoalHandleBase\u0060.\n  */\n template\u003Ctypename ActionT\u003E\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "7e9ff5f4c774e6c0b28268f2d2b1b03fc52383a2",
    "RawMessage": "accept custom allocator for LoanedMessage. (#2672)",
    "Changes": "diff --git rclcpp/include/rclcpp/loaned_message.hpp rclcpp/include/rclcpp/loaned_message.hpp\nindex 3fd86f07..34a1633e 100644\n--- rclcpp/include/rclcpp/loaned_message.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/loaned_message.hpp\n@@ -31,10 \u002B31,10 @@ namespace rclcpp\n template\u003Ctypename MessageT, typename AllocatorT = std::allocator\u003Cvoid\u003E\u003E\n class LoanedMessage\n {\n\u002Bpublic:\n   using MessageAllocatorTraits = rclcpp::allocator::AllocRebind\u003CMessageT, AllocatorT\u003E;\n   using MessageAllocator = typename MessageAllocatorTraits::allocator_type;\n \n-public:\n   /// Constructor of the LoanedMessage class.\n   /**\n    * The constructor of this class allocates memory for a given message type\n@@ -57,7 \u002B57,7 @@ public:\n    */\n   LoanedMessage(\n     const rclcpp::PublisherBase \u0026 pub,\n-    std::allocator\u003CMessageT\u003E allocator)\n\u002B    MessageAllocator allocator)\n   : pub_(pub),\n     message_(nullptr),\n     message_allocator_(std::move(allocator))\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "6da83635828fa5b41fe328acc53107e06ca57303",
    "RawMessage": "subscriber_statistics_collectors_ should be protected by mutex. (#2592)",
    "Changes": "diff --git rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\nindex 781e2c86..7a6db135 100644\n--- rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\n@@ -172,12 \u002B172,11 @@ private:\n   {\n     auto received_message_age = std::make_unique\u003CReceivedMessageAge\u003E();\n     received_message_age-\u003EStart();\n-    subscriber_statistics_collectors_.emplace_back(std::move(received_message_age));\n-\n     auto received_message_period = std::make_unique\u003CReceivedMessagePeriod\u003E();\n     received_message_period-\u003EStart();\n     {\n       std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B      subscriber_statistics_collectors_.emplace_back(std::move(received_message_age));\n       subscriber_statistics_collectors_.emplace_back(std::move(received_message_period));\n     }\n \ndiff --git rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\nindex 91662722..a6fbbcbc 100644\n--- rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n@@ -343,7 \u002B343,6 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n   uint64_t message_age_count{0};\n   uint64_t message_period_count{0};\n \n-  std::set\u003Cstd::string\u003E received_metrics;\n   for (const auto \u0026 msg : received_messages) {\n     if (msg.metrics_source == kMessageAgeSourceLabel) {\n       message_age_count\u002B\u002B;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "ae6f0652ae5d4aba89fb2cfe83d8105bde89d6d3",
    "RawMessage": "Account for alignment on \u0060is_plain\u0060 calculations (#108)",
    "Changes": "diff --git rosidl_typesupport_fastrtps_c/resource/msg__type_support_c.cpp.em rosidl_typesupport_fastrtps_c/resource/msg__type_support_c.cpp.em\nindex 8a67a28..4b1c8f7 100644\n--- rosidl_typesupport_fastrtps_c/resource/msg__type_support_c.cpp.em\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/resource/msg__type_support_c.cpp.em\n@@ -530,13 \u002B530,21 @@ size_t max_serialized_size_@(\u0027__\u0027.join([package_name] \u002B list(interface_path.pare\n \n   const size_t padding = 4;\n   const size_t wchar_size = 4;\n\u002B  size_t last_member_size = 0;\n\u002B  (void)last_member_size;\n   (void)padding;\n   (void)wchar_size;\n \n   full_bounded = true;\n   is_plain = true;\n \n\u002B@{\n\u002Blast_member_name_ = None\n\u002B}@\n @[for member in message.structure.members]@\n\u002B@{\n\u002Blast_member_name_ = member.name\n\u002B}@\n   // member: @(member.name)\n   {\n @[  if isinstance(member.type, AbstractNestedType)]@\n@@ -581,27 \u002B589,36 @@ if isinstance(type_, AbstractNestedType):\n     }\n @[  elif isinstance(type_, BasicType)]@\n @[    if type_.typename in (\u0027boolean\u0027, \u0027octet\u0027, \u0027char\u0027, \u0027uint8\u0027, \u0027int8\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint8_t);\n     current_alignment \u002B= array_size * sizeof(uint8_t);\n @[    elif type_.typename in (\u0027wchar\u0027, \u0027int16\u0027, \u0027uint16\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint16_t);\n     current_alignment \u002B= array_size * sizeof(uint16_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint16_t));\n @[    elif type_.typename in (\u0027int32\u0027, \u0027uint32\u0027, \u0027float\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint32_t);\n     current_alignment \u002B= array_size * sizeof(uint32_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint32_t));\n @[    elif type_.typename in (\u0027int64\u0027, \u0027uint64\u0027, \u0027double\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint64_t);\n     current_alignment \u002B= array_size * sizeof(uint64_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint64_t));\n @[    elif type_.typename == \u0027long double\u0027]@\n\u002B    last_member_size = array_size * sizeof(long double);\n     current_alignment \u002B= array_size * sizeof(long double) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(long double));\n @[    end if]@\n @[  else]\n\u002B    last_member_size = 0;\n     for (size_t index = 0; index \u003C array_size; \u002B\u002Bindex) {\n       bool inner_full_bounded;\n       bool inner_is_plain;\n-      current_alignment \u002B=\n\u002B      size_t inner_size;\n\u002B      inner_size =\n         max_serialized_size_@(\u0027__\u0027.join(type_.namespaced_name()))(\n         inner_full_bounded, inner_is_plain, current_alignment);\n\u002B      last_member_size \u002B= inner_size;\n\u002B      current_alignment \u002B= inner_size;\n       full_bounded \u0026= inner_full_bounded;\n       is_plain \u0026= inner_is_plain;\n     }\n@@ -609,7 \u002B626,22 @@ if isinstance(type_, AbstractNestedType):\n   }\n @[end for]@\n \n-  return current_alignment - initial_alignment;\n\u002B  size_t ret_val = current_alignment - initial_alignment;\n\u002B@[if last_member_name_ is not None]@\n\u002B  if (is_plain) {\n\u002B    // All members are plain, and type is not empty.\n\u002B    // We still need to check that the in-memory alignment\n\u002B    // is the same as the CDR mandated alignment.\n\u002B    using DataType = @(\u0027__\u0027.join([package_name] \u002B list(interface_path.parents[0].parts) \u002B [message.structure.namespaced_type.name]));\n\u002B    is_plain =\n\u002B      (\n\u002B      offsetof(DataType, @(last_member_name_)) \u002B\n\u002B      last_member_size\n\u002B      ) == ret_val;\n\u002B  }\n\u002B\n\u002B@[end if]@\n\u002B  return ret_val;\n }\n \n static size_t _@(message.structure.namespaced_type.name)__max_serialized_size(char \u0026 bounds_info)\ndiff --git rosidl_typesupport_fastrtps_cpp/resource/msg__type_support.cpp.em rosidl_typesupport_fastrtps_cpp/resource/msg__type_support.cpp.em\nindex a02d04f..c4623c5 100644\n--- rosidl_typesupport_fastrtps_cpp/resource/msg__type_support.cpp.em\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/resource/msg__type_support.cpp.em\n@@ -376,13 \u002B376,21 @@ max_serialized_size_@(message.structure.namespaced_type.name)(\n \n   const size_t padding = 4;\n   const size_t wchar_size = 4;\n\u002B  size_t last_member_size = 0;\n\u002B  (void)last_member_size;\n   (void)padding;\n   (void)wchar_size;\n \n   full_bounded = true;\n   is_plain = true;\n \n\u002B@{\n\u002Blast_member_name_ = None\n\u002B}@\n @[for member in message.structure.members]@\n\u002B@{\n\u002Blast_member_name_ = member.name\n\u002B}@\n \n   // Member: @(member.name)\n   {\n@@ -428,27 \u002B436,35 @@ if isinstance(type_, AbstractNestedType):\n     }\n @[  elif isinstance(type_, BasicType)]@\n @[    if type_.typename in (\u0027boolean\u0027, \u0027octet\u0027, \u0027char\u0027, \u0027uint8\u0027, \u0027int8\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint8_t);\n     current_alignment \u002B= array_size * sizeof(uint8_t);\n @[    elif type_.typename in (\u0027wchar\u0027, \u0027int16\u0027, \u0027uint16\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint16_t);\n     current_alignment \u002B= array_size * sizeof(uint16_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint16_t));\n @[    elif type_.typename in (\u0027int32\u0027, \u0027uint32\u0027, \u0027float\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint32_t);\n     current_alignment \u002B= array_size * sizeof(uint32_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint32_t));\n @[    elif type_.typename in (\u0027int64\u0027, \u0027uint64\u0027, \u0027double\u0027)]@\n\u002B    last_member_size = array_size * sizeof(uint64_t);\n     current_alignment \u002B= array_size * sizeof(uint64_t) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(uint64_t));\n @[    elif type_.typename == \u0027long double\u0027]@\n\u002B    last_member_size = array_size * sizeof(long double);\n     current_alignment \u002B= array_size * sizeof(long double) \u002B\n       eprosima::fastcdr::Cdr::alignment(current_alignment, sizeof(long double));\n @[    end if]@\n @[  else]\n\u002B    last_member_size = 0;\n     for (size_t index = 0; index \u003C array_size; \u002B\u002Bindex) {\n       bool inner_full_bounded;\n       bool inner_is_plain;\n-      current_alignment \u002B=\n\u002B      size_t inner_size =\n         @(\u0027::\u0027.join(type_.namespaces))::typesupport_fastrtps_cpp::max_serialized_size_@(type_.name)(\n         inner_full_bounded, inner_is_plain, current_alignment);\n\u002B      last_member_size \u002B= inner_size;\n\u002B      current_alignment \u002B= inner_size;\n       full_bounded \u0026= inner_full_bounded;\n       is_plain \u0026= inner_is_plain;\n     }\n@@ -456,7 \u002B472,22 @@ if isinstance(type_, AbstractNestedType):\n   }\n @[end for]@\n \n-  return current_alignment - initial_alignment;\n\u002B  size_t ret_val = current_alignment - initial_alignment;\n\u002B@[if last_member_name_ is not None]@\n\u002B  if (is_plain) {\n\u002B    // All members are plain, and type is not empty.\n\u002B    // We still need to check that the in-memory alignment\n\u002B    // is the same as the CDR mandated alignment.\n\u002B    using DataType = @(\u0027::\u0027.join([package_name] \u002B list(interface_path.parents[0].parts) \u002B [message.structure.namespaced_type.name]));\n\u002B    is_plain =\n\u002B      (\n\u002B      offsetof(DataType, @(last_member_name_)) \u002B\n\u002B      last_member_size\n\u002B      ) == ret_val;\n\u002B  }\n\u002B\n\u002B@[end if]@\n\u002B  return ret_val;\n }\n \n static bool _@(message.structure.namespaced_type.name)__cdr_serialize(\n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "6cd7a3747220aabd40c2aa47e3993e126483511a",
    "RawMessage": "Drop deprecated get_container_components_info() API. (#647)",
    "Changes": "diff --git ros2component/ros2component/api/__init__.py ros2component/ros2component/api/__init__.py\nindex 01adcfc..171caec 100644\n--- ros2component/ros2component/api/__init__.py\n\u002B\u002B\u002B ros2component/ros2component/api/__init__.py\n@@ -68,34 \u002B68,6 @@ def get_registered_component_types():\n ComponentInfo = namedtuple(\u0027Component\u0027, (\u0027uid\u0027, \u0027name\u0027))\n \n \n-def get_container_components_info(*, node, remote_container_node_name):\n-    \u0022\u0022\u0022\n-    Get information about the components in a container.\n-\n-    .. deprecated:: Galactic\n-\n-       Use :func:\u0060get_components_in_container()\u0060 instead.\n-\n-    :param node: an \u0060rclpy.Node\u0060 instance.\n-    :param remote_container_node_name: of the container node to inspect.\n-    :return: a list of \u0060ComponentInfo\u0060 instances, with the unique id and name of\n-    each component in the container.\n-    :throws: RuntimeError if an error occurs.\n-    \u0022\u0022\u0022\n-    import warnings\n-    warnings.warn(\n-        \u0027get_container_components_info() is deprecated. \u0027\n-        \u0027Use get_components_in_container() instead.\u0027\n-    )\n-\n-    ok, outcome = get_components_in_container(\n-        node=node, remote_container_node_name=remote_container_node_name\n-    )\n-    if not ok:\n-        raise RuntimeError(f\u0027{outcome} for {remote_container_node_name}\u0027)\n-    return outcome\n-\n-\n def get_components_in_container(*, node, remote_container_node_name):\n     \u0022\u0022\u0022\n     Get information about the components in a container.\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "2d0c9e2e94080c4a207057cd4f1b5804766a1633",
    "RawMessage": "Cleanup time_unix.c (#389)",
    "Changes": "diff --git src/time_unix.c src/time_unix.c\nindex 10aa372..c33f898 100644\n--- src/time_unix.c\n\u002B\u002B\u002B src/time_unix.c\n@@ -16,11 \u002B16,6 @@\n # error time_unix.c is not intended to be used with win32 based systems\n #endif  // defined(_WIN32)\n \n-#ifdef __cplusplus\n-extern \u0022C\u0022\n-{\n-#endif\n-\n #include \u0022rcutils/time.h\u0022\n \n #if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n@@ -40,36 \u002B35,38 @@ extern \u0022C\u0022\n #include \u003Ctime.h\u003E\n #endif  //  defined(__ZEPHYR__)\n \n\u002B#include \u003Cerrno.h\u003E\n #include \u003Cunistd.h\u003E\n-#include \u0022./common.h\u0022\n\u002B\n #include \u0022rcutils/allocator.h\u0022\n #include \u0022rcutils/error_handling.h\u0022\n \n #if !defined(__MACH__) \u0026\u0026 !defined(__APPLE__)   // Assume clock_get_time is available on OS X.\n-// This id an appropriate check for clock_gettime() according to:\n\u002B// This is an appropriate check for clock_gettime() according to:\n //   http://man7.org/linux/man-pages/man2/clock_gettime.2.html\n # if !defined(_POSIX_TIMERS) || !_POSIX_TIMERS\n #  error no monotonic clock function available\n # endif  // !defined(_POSIX_TIMERS) || !_POSIX_TIMERS\n #endif  // !defined(__MACH__) \u0026\u0026 !defined(__APPLE__)\n \n-#define __WOULD_BE_NEGATIVE(seconds, subseconds) (seconds \u003C 0 || (subseconds \u003C 0 \u0026\u0026 seconds == 0))\n\u002Bstatic inline bool would_be_negative(const struct timespec * const now)\n\u002B{\n\u002B  return now-\u003Etv_sec \u003C 0 || (now-\u003Etv_nsec \u003C 0 \u0026\u0026 now-\u003Etv_sec == 0);\n\u002B}\n \n rcutils_ret_t\n rcutils_system_time_now(rcutils_time_point_value_t * now)\n {\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(now, RCUTILS_RET_INVALID_ARGUMENT);\n   struct timespec timespec_now;\n-#if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  // On macOS, use clock_gettime(CLOCK_REALTIME), which matches\n-  // the clang implementation\n\u002B  // Using clock_gettime(CLOCK_REALTIME) matches what both Linux and macOS use.\n\u002B  // For macOS, see the clang implementation at\n   // (https://github.com/llvm/llvm-project/blob/baebe12ad0d6f514cd33e418d6504075d3e79c0a/libcxx/src/chrono.cpp)\n-  clock_gettime(CLOCK_REALTIME, \u0026timespec_now);\n-#else  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  // Otherwise use clock_gettime.\n-  clock_gettime(CLOCK_REALTIME, \u0026timespec_now);\n-#endif  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  if (__WOULD_BE_NEGATIVE(timespec_now.tv_sec, timespec_now.tv_nsec)) {\n\u002B  if (clock_gettime(CLOCK_REALTIME, \u0026timespec_now) \u003C 0) {\n\u002B    RCUTILS_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022Failed to get system time: %d\u0022, errno);\n\u002B    return RCUTILS_RET_ERROR;\n\u002B  }\n\u002B  if (would_be_negative(\u0026timespec_now)) {\n     RCUTILS_SET_ERROR_MSG(\u0022unexpected negative time\u0022);\n     return RCUTILS_RET_ERROR;\n   }\n@@ -81,25 \u002B78,23 @@ rcutils_ret_t\n rcutils_steady_time_now(rcutils_time_point_value_t * now)\n {\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(now, RCUTILS_RET_INVALID_ARGUMENT);\n-  // If clock_gettime is available or on OS X, use a timespec.\n   struct timespec timespec_now;\n\u002B  clockid_t monotonic_clock = CLOCK_MONOTONIC;\n\u002B\n #if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  // On macOS, use clock_gettime(CLOCK_MONOTONIC_RAW), which matches\n-  // the clang implementation\n\u002B  // On macOS, use CLOCK_MONOTONIC_RAW, which matches the clang implementation\n   // (https://github.com/llvm/llvm-project/blob/baebe12ad0d6f514cd33e418d6504075d3e79c0a/libcxx/src/chrono.cpp)\n-  clock_gettime(CLOCK_MONOTONIC_RAW, \u0026timespec_now);\n-#else  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  // Otherwise use clock_gettime.\n-  clock_gettime(CLOCK_MONOTONIC, \u0026timespec_now);\n\u002B  monotonic_clock = CLOCK_MONOTONIC_RAW;\n #endif  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n-  if (__WOULD_BE_NEGATIVE(timespec_now.tv_sec, timespec_now.tv_nsec)) {\n\u002B\n\u002B  if (clock_gettime(monotonic_clock, \u0026timespec_now) \u003C 0) {\n\u002B    RCUTILS_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022Failed to get steady time: %d\u0022, errno);\n\u002B    return RCUTILS_RET_ERROR;\n\u002B  }\n\u002B  if (would_be_negative(\u0026timespec_now)) {\n     RCUTILS_SET_ERROR_MSG(\u0022unexpected negative time\u0022);\n     return RCUTILS_RET_ERROR;\n   }\n   *now = RCUTILS_S_TO_NS((int64_t)timespec_now.tv_sec) \u002B timespec_now.tv_nsec;\n   return RCUTILS_RET_OK;\n }\n-\n-#ifdef __cplusplus\n-}\n-#endif\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "297df3d56d2e639a5862fa0b1399cf963e354920",
    "RawMessage": "Additional checks for loan API",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 485eee5..3ec24ed 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -2588,6 \u002B2588,10 @@ static rmw_ret_t borrow_loaned_message_int(\n     publisher-\u003Eimplementation_identifier,\n     eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(ros_message, RMW_RET_INVALID_ARGUMENT);\n\u002B  if (*ros_message) {\n\u002B    return RMW_RET_INVALID_ARGUMENT;\n\u002B  }\n   auto cdds_publisher = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n   if (!cdds_publisher) {\n     RMW_SET_ERROR_MSG(\u0022publisher data is null\u0022);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "623c3eb8747f4aa55985f0d2d29694c33a81767d",
    "RawMessage": "Add locking to protect the TimeSource::NodeState::node_base_ (#2320)",
    "Changes": "diff --git rclcpp/src/rclcpp/time_source.cpp rclcpp/src/rclcpp/time_source.cpp\nindex a0e1d008..465ceaf5 100644\n--- rclcpp/src/rclcpp/time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time_source.cpp\n@@ -236,6 \u002B236,7 @@ public:\n     rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_interface,\n     rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_interface)\n   {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(node_base_lock_);\n     node_base_ = node_base_interface;\n     node_topics_ = node_topics_interface;\n     node_graph_ = node_graph_interface;\n@@ -280,17 \u002B281,14 @@ public:\n     parameter_subscription_ = rclcpp::AsyncParametersClient::on_parameter_event(\n       node_topics_,\n       [this](std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event) {\n-        if (node_base_ != nullptr) {\n-          this-\u003Eon_parameter_event(event);\n-        }\n-        // Do nothing if node_base_ is nullptr because it means the TimeSource is now\n-        // without an attached node\n\u002B        this-\u003Eon_parameter_event(event);\n       });\n   }\n \n   // Detach the attached node\n   void detachNode()\n   {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(node_base_lock_);\n     // destroy_clock_sub() *must* be first here, to ensure that the executor\n     // can\u0027t possibly call any of the callbacks as we are cleaning up.\n     destroy_clock_sub();\n@@ -327,6 \u002B325,7 @@ private:\n   std::thread clock_executor_thread_;\n \n   // Preserve the node reference\n\u002B  std::mutex node_base_lock_;\n   rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_{nullptr};\n   rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_{nullptr};\n   rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_{nullptr};\n@@ -464,6 \u002B463,14 @@ private:\n   // Callback for parameter updates\n   void on_parameter_event(std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event)\n   {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(node_base_lock_);\n\u002B\n\u002B    if (node_base_ == nullptr) {\n\u002B      // Do nothing if node_base_ is nullptr because it means the TimeSource is now\n\u002B      // without an attached node\n\u002B      return;\n\u002B    }\n\u002B\n     // Filter out events on \u0027use_sim_time\u0027 parameter instances in other nodes.\n     if (event-\u003Enode != node_base_-\u003Eget_fully_qualified_name()) {\n       return;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "a5236920be273cdf91d8104485a3657b7b08ac55",
    "RawMessage": "fix typo (#890)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex f007653..48e654d 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -437,7 \u002B437,7 @@ class Node:\n \n             if len(parameter_tuple) == 1:\n                 warnings.warn(\n-                    f\u0022when declaring parmater named \u0027{name}\u0027, \u0022\n\u002B                    f\u0022when declaring parameter named \u0027{name}\u0027, \u0022\n                     \u0027declaring a parameter only providing its name is deprecated. \u0027\n                     \u0027You have to either:\\n\u0027\n                     \u0027\\t- Pass a name and a default value different to \u0022PARAMETER NOT SET\u0022\u0027\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "3db0cfa7e8a648277986035b8b40050372aa2def",
    "RawMessage": "Add bad_alloc return to topic_endpoint_info functions (#269)",
    "Changes": "diff --git rmw/include/rmw/topic_endpoint_info.h rmw/include/rmw/topic_endpoint_info.h\nindex 968cd5f..1e4ac69 100644\n--- rmw/include/rmw/topic_endpoint_info.h\n\u002B\u002B\u002B rmw/include/rmw/topic_endpoint_info.h\n@@ -82,6 \u002B82,7 @@ rmw_topic_endpoint_info_fini(\n  * \\param[in] allocator the allocator that will be used to allocate memory\n  * \\returns \u0060RMW_RET_OK\u0060 on successfully setting the topic_type, or\n  * \\returns \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any parameters are NULL, or\n\u002B * \\returns \u0060RMW_RET_BAD_ALLOC\u0060 if allocation for string duplication fails, or\n  * \\returns \u0060RMW_RET_ERROR\u0060 when an unspecified error occurs.\n  */\n RMW_PUBLIC\n@@ -104,6 \u002B105,7 @@ rmw_topic_endpoint_info_set_topic_type(\n  * \\param[in] allocator the allocator that will be used to allocate memory\n  * \\returns \u0060RMW_RET_OK\u0060 on successfully setting the node_name, or\n  * \\returns \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any parameters are NULL, or\n\u002B * \\returns \u0060RMW_RET_BAD_ALLOC\u0060 if allocation for string duplication fails, or\n  * \\returns \u0060RMW_RET_ERROR\u0060 when an unspecified error occurs.\n  */\n RMW_PUBLIC\n@@ -126,6 \u002B128,7 @@ rmw_topic_endpoint_info_set_node_name(\n  * \\param[in] allocator the allocator that will be used to allocate memory\n  * \\returns \u0060RMW_RET_OK\u0060 on successfully setting the node_namespace, or\n  * \\returns \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any parameters are NULL, or\n\u002B * \\returns \u0060RMW_RET_BAD_ALLOC\u0060 if allocation for string duplication fails, or\n  * \\returns \u0060RMW_RET_ERROR\u0060 when an unspecified error occurs.\n  */\n RMW_PUBLIC\n@@ -148,6 \u002B151,7 @@ rmw_topic_endpoint_info_set_node_namespace(\n  * \\returns \u0060RMW_RET_OK\u0060 on successfully setting the gid, or\n  * \\returns \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any parameters are NULL, or\n  * \\returns \u0060RMW_RET_INVALID_ARGUMENT\u0060 size is greater than RMW_GID_STORAGE_SIZE, or\n\u002B * \\returns \u0060RMW_RET_BAD_ALLOC\u0060 if allocation for string duplication fails, or\n  * \\returns \u0060RMW_RET_ERROR\u0060 when an unspecified error occurs.\n  */\n RMW_PUBLIC\ndiff --git rmw/src/topic_endpoint_info.c rmw/src/topic_endpoint_info.c\nindex 4cc9118..ee8cc4c 100644\n--- rmw/src/topic_endpoint_info.c\n\u002B\u002B\u002B rmw/src/topic_endpoint_info.c\n@@ -121,6 \u002B121,9 @@ _rmw_topic_endpoint_info_copy_str(\n   }\n \n   *topic_endpoint_info_str = rcutils_strdup(str, *allocator);\n\u002B  if (NULL == *topic_endpoint_info_str) {\n\u002B    return RMW_RET_BAD_ALLOC;\n\u002B  }\n \n   return RMW_RET_OK;\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "642b1a34b1a50bfa8afa76817ec3fe0e2f9cf210",
    "RawMessage": "Set ContentsMargins for RenderPanel to 0 to avoid borders in fullscreen mode. Fixes #1024 (#1228)",
    "Changes": "diff --git rviz_common/src/rviz_common/render_panel.cpp rviz_common/src/rviz_common/render_panel.cpp\nindex 9f0d9d02..f8ca4fd6 100644\n--- rviz_common/src/rviz_common/render_panel.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/render_panel.cpp\n@@ -77,6 \u002B77,7 @@ RenderPanel::RenderPanel(QWidget * parent)\n   setFocus(Qt::OtherFocusReason);\n   render_window_container_widget_ = QWidget::createWindowContainer(render_window_, this);\n   layout_ = new QGridLayout(this);\n\u002B  layout_-\u003EsetContentsMargins(0, 0, 0, 0);\n   layout_-\u003EaddWidget(render_window_container_widget_);\n   this-\u003EsetLayout(layout_);\n   render_window_-\u003EsetOnRenderWindowMouseEventsCallback(\n",
    "BackportedTo": "jazzy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "9b8edabb95cc2ecafe29f2c4eb458d9c19d47a11",
    "RawMessage": "Minor fixes to rcl clock implementation. (#688)",
    "Changes": "diff --git rcl/src/rcl/time.c rcl/src/rcl/time.c\nindex 3b91743..21ed848 100644\n--- rcl/src/rcl/time.c\n\u002B\u002B\u002B rcl/src/rcl/time.c\n@@ -171,11 \u002B171,8 @@ rcl_ros_clock_fini(\n     return RCL_RET_ERROR;\n   }\n   rcl_clock_generic_fini(clock);\n-  if (!clock-\u003Edata) {\n-    RCL_SET_ERROR_MSG(\u0022clock data invalid\u0022);\n-    return RCL_RET_ERROR;\n-  }\n-  clock-\u003Eallocator.deallocate((rcl_ros_clock_storage_t *)clock-\u003Edata, clock-\u003Eallocator.state);\n\u002B  clock-\u003Eallocator.deallocate(clock-\u003Edata, clock-\u003Eallocator.state);\n\u002B  clock-\u003Edata = NULL;\n   return RCL_RET_OK;\n }\n \n@@ -293,10 \u002B290,8 @@ rcl_enable_ros_time_override(rcl_clock_t * clock)\n     return RCL_RET_ERROR;\n   }\n   rcl_ros_clock_storage_t * storage = (rcl_ros_clock_storage_t *)clock-\u003Edata;\n-  if (!storage) {\n-    RCL_SET_ERROR_MSG(\u0022Clock storage is not initialized, cannot enable override.\u0022);\n-    return RCL_RET_ERROR;\n-  }\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    storage, \u0022Clock storage is not initialized, cannot enable override.\u0022, return RCL_RET_ERROR);\n   if (!storage-\u003Eactive) {\n     rcl_time_jump_t time_jump;\n     time_jump.delta.nanoseconds = 0;\n@@ -316,12 \u002B311,9 @@ rcl_disable_ros_time_override(rcl_clock_t * clock)\n     RCL_SET_ERROR_MSG(\u0022Clock is not of type RCL_ROS_TIME, cannot disable override.\u0022);\n     return RCL_RET_ERROR;\n   }\n-  rcl_ros_clock_storage_t * storage = \\\n-    (rcl_ros_clock_storage_t *)clock-\u003Edata;\n-  if (!storage) {\n-    RCL_SET_ERROR_MSG(\u0022Clock storage is not initialized, cannot disable override.\u0022);\n-    return RCL_RET_ERROR;\n-  }\n\u002B  rcl_ros_clock_storage_t * storage = (rcl_ros_clock_storage_t *)clock-\u003Edata;\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    storage, \u0022Clock storage is not initialized, cannot enable override.\u0022, return RCL_RET_ERROR);\n   if (storage-\u003Eactive) {\n     rcl_time_jump_t time_jump;\n     time_jump.delta.nanoseconds = 0;\n@@ -344,12 \u002B336,9 @@ rcl_is_enabled_ros_time_override(\n     RCL_SET_ERROR_MSG(\u0022Clock is not of type RCL_ROS_TIME, cannot query override state.\u0022);\n     return RCL_RET_ERROR;\n   }\n-  rcl_ros_clock_storage_t * storage = \\\n-    (rcl_ros_clock_storage_t *)clock-\u003Edata;\n-  if (!storage) {\n-    RCL_SET_ERROR_MSG(\u0022Clock storage is not initialized, cannot query override state.\u0022);\n-    return RCL_RET_ERROR;\n-  }\n\u002B  rcl_ros_clock_storage_t * storage = (rcl_ros_clock_storage_t *)clock-\u003Edata;\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    storage, \u0022Clock storage is not initialized, cannot enable override.\u0022, return RCL_RET_ERROR);\n   *is_enabled = storage-\u003Eactive;\n   return RCL_RET_OK;\n }\n@@ -364,8 \u002B353,10 @@ rcl_set_ros_time_override(\n     RCL_SET_ERROR_MSG(\u0022Clock is not of type RCL_ROS_TIME, cannot set time override.\u0022);\n     return RCL_RET_ERROR;\n   }\n-  rcl_time_jump_t time_jump;\n   rcl_ros_clock_storage_t * storage = (rcl_ros_clock_storage_t *)clock-\u003Edata;\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    storage, \u0022Clock storage is not initialized, cannot enable override.\u0022, return RCL_RET_ERROR);\n\u002B  rcl_time_jump_t time_jump;\n   if (storage-\u003Eactive) {\n     time_jump.clock_change = RCL_ROS_TIME_NO_CHANGE;\n     rcl_time_point_value_t current_time;\n@@ -453,12 \u002B444,12 @@ rcl_clock_remove_jump_callback(\n   }\n \n   // Shrink size of the callback array\n-  if (clock-\u003Enum_jump_callbacks == 1) {\n\u002B  if (--(clock-\u003Enum_jump_callbacks) == 0) {\n     clock-\u003Eallocator.deallocate(clock-\u003Ejump_callbacks, clock-\u003Eallocator.state);\n     clock-\u003Ejump_callbacks = NULL;\n   } else {\n     rcl_jump_callback_info_t * callbacks = clock-\u003Eallocator.reallocate(\n-      clock-\u003Ejump_callbacks, sizeof(rcl_jump_callback_info_t) * (clock-\u003Enum_jump_callbacks - 1),\n\u002B      clock-\u003Ejump_callbacks, sizeof(rcl_jump_callback_info_t) * clock-\u003Enum_jump_callbacks,\n       clock-\u003Eallocator.state);\n     if (NULL == callbacks) {\n       RCL_SET_ERROR_MSG(\u0022Failed to shrink jump callbacks\u0022);\n@@ -466,6 \u002B457,5 @@ rcl_clock_remove_jump_callback(\n     }\n     clock-\u003Ejump_callbacks = callbacks;\n   }\n-  --(clock-\u003Enum_jump_callbacks);\n   return RCL_RET_OK;\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "5c4f809f2adcca61ffff46923ffcc809526b568b",
    "RawMessage": "Use a different mechanism to avoid timers being scheduled multiple times by the MultiThreadedExecutor (#1692)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex 95dc5311..c1cb8bf3 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -41,7 \u002B41,6 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/clock.cpp\n   src/rclcpp/context.cpp\n   src/rclcpp/contexts/default_context.cpp\n-  src/rclcpp/detail/mutex_two_priorities.cpp\n   src/rclcpp/detail/resolve_parameter_overrides.cpp\n   src/rclcpp/detail/rmw_implementation_specific_payload.cpp\n   src/rclcpp/detail/rmw_implementation_specific_publisher_payload.cpp\ndiff --git rclcpp/include/rclcpp/detail/mutex_two_priorities.hpp rclcpp/include/rclcpp/detail/mutex_two_priorities.hpp\ndeleted file mode 100644\nindex 98118b61..00000000\n--- rclcpp/include/rclcpp/detail/mutex_two_priorities.hpp\n\u002B\u002B\u002B /dev/null\n@@ -1,76 \u002B0,0 @@\n-// Copyright 2021 Open Source Robotics Foundation, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#ifndef RCLCPP__DETAIL__MUTEX_TWO_PRIORITIES_HPP_\n-#define RCLCPP__DETAIL__MUTEX_TWO_PRIORITIES_HPP_\n-\n-#include \u003Ccondition_variable\u003E\n-#include \u003Cmutex\u003E\n-\n-namespace rclcpp\n-{\n-namespace detail\n-{\n-/// \\internal A mutex that has two locking mechanism, one with higher priority than the other.\n-/**\n- * After the current mutex owner release the lock, a thread that used the high\n- * priority mechanism will have priority over threads that used the low priority mechanism.\n- */\n-class MutexTwoPriorities\n-{\n-public:\n-  class HighPriorityLockable\n-  {\n-public:\n-    explicit HighPriorityLockable(MutexTwoPriorities \u0026 parent);\n-\n-    void lock();\n-\n-    void unlock();\n-\n-private:\n-    MutexTwoPriorities \u0026 parent_;\n-  };\n-\n-  class LowPriorityLockable\n-  {\n-public:\n-    explicit LowPriorityLockable(MutexTwoPriorities \u0026 parent);\n-\n-    void lock();\n-\n-    void unlock();\n-\n-private:\n-    MutexTwoPriorities \u0026 parent_;\n-  };\n-\n-  HighPriorityLockable\n-  get_high_priority_lockable();\n-\n-  LowPriorityLockable\n-  get_low_priority_lockable();\n-\n-private:\n-  std::condition_variable hp_cv_;\n-  std::condition_variable lp_cv_;\n-  std::mutex cv_mutex_;\n-  size_t hp_waiting_count_{0u};\n-  bool data_taken_{false};\n-};\n-\n-}  // namespace detail\n-}  // namespace rclcpp\n-\n-#endif  // RCLCPP__DETAIL__MUTEX_TWO_PRIORITIES_HPP_\ndiff --git rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp\nindex 28504620..a1befba3 100644\n--- rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp\n@@ -22,7 \u002B22,6 @@\n #include \u003Cthread\u003E\n #include \u003Cunordered_map\u003E\n \n-#include \u0022rclcpp/detail/mutex_two_priorities.hpp\u0022\n #include \u0022rclcpp/executor.hpp\u0022\n #include \u0022rclcpp/macros.hpp\u0022\n #include \u0022rclcpp/memory_strategies.hpp\u0022\n@@ -82,12 \u002B81,10 @@ protected:\n private:\n   RCLCPP_DISABLE_COPY(MultiThreadedExecutor)\n \n-  detail::MutexTwoPriorities wait_mutex_;\n\u002B  std::mutex wait_mutex_;\n   size_t number_of_threads_;\n   bool yield_before_execute_;\n   std::chrono::nanoseconds next_exec_timeout_;\n-\n-  std::set\u003CTimerBase::SharedPtr\u003E scheduled_timers_;\n };\n \n }  // namespace executors\ndiff --git rclcpp/include/rclcpp/strategies/allocator_memory_strategy.hpp rclcpp/include/rclcpp/strategies/allocator_memory_strategy.hpp\nindex 76790b12..43ef7168 100644\n--- rclcpp/include/rclcpp/strategies/allocator_memory_strategy.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/strategies/allocator_memory_strategy.hpp\n@@ -388,6 \u002B388,11 @@ public:\n           \u002B\u002Bit;\n           continue;\n         }\n\u002B        if (!timer-\u003Ecall()) {\n\u002B          // timer was cancelled, skip it.\n\u002B          \u002B\u002Bit;\n\u002B          continue;\n\u002B        }\n         // Otherwise it is safe to set and return the any_exec\n         any_exec.timer = timer;\n         any_exec.callback_group = group;\n@@ -395,7 \u002B400,7 @@ public:\n         timer_handles_.erase(it);\n         return;\n       }\n-      // Else, the service is no longer valid, remove it and continue\n\u002B      // Else, the timer is no longer valid, remove it and continue\n       it = timer_handles_.erase(it);\n     }\n   }\ndiff --git rclcpp/include/rclcpp/timer.hpp rclcpp/include/rclcpp/timer.hpp\nindex cc8e5c6c..52df423d 100644\n--- rclcpp/include/rclcpp/timer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/timer.hpp\n@@ -91,6 \u002B91,17 @@ public:\n   void\n   reset();\n \n\u002B  /// Indicate that we\u0027re about to execute the callback.\n\u002B  /**\n\u002B   * The multithreaded executor takes advantage of this to avoid scheduling\n\u002B   * the callback multiple times.\n\u002B   *\n\u002B   * \\return \u0060true\u0060 if the callback should be executed, \u0060false\u0060 if the timer was canceled.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  virtual bool\n\u002B  call() = 0;\n\u002B\n   /// Call the callback function when the timer signal is emitted.\n   RCLCPP_PUBLIC\n   virtual void\n@@ -192,19 \u002B203,28 @@ public:\n   }\n \n   /**\n-   * \\sa rclcpp::TimerBase::execute_callback\n-   * \\throws std::runtime_error if it failed to notify timer that callback occurred\n\u002B   * \\sa rclcpp::TimerBase::call\n\u002B   * \\throws std::runtime_error if it failed to notify timer that callback will occurr\n    */\n-  void\n-  execute_callback() override\n\u002B  bool\n\u002B  call() override\n   {\n     rcl_ret_t ret = rcl_timer_call(timer_handle_.get());\n     if (ret == RCL_RET_TIMER_CANCELED) {\n-      return;\n\u002B      return false;\n     }\n     if (ret != RCL_RET_OK) {\n       throw std::runtime_error(\u0022Failed to notify timer that callback occurred\u0022);\n     }\n\u002B    return true;\n\u002B  }\n\u002B\n\u002B  /**\n\u002B   * \\sa rclcpp::TimerBase::execute_callback\n\u002B   */\n\u002B  void\n\u002B  execute_callback() override\n\u002B  {\n     TRACEPOINT(callback_start, static_cast\u003Cconst void *\u003E(\u0026callback_), false);\n     execute_callback_delegate\u003C\u003E();\n     TRACEPOINT(callback_end, static_cast\u003Cconst void *\u003E(\u0026callback_));\ndiff --git rclcpp/src/rclcpp/detail/mutex_two_priorities.cpp rclcpp/src/rclcpp/detail/mutex_two_priorities.cpp\ndeleted file mode 100644\nindex 8deb864f..00000000\n--- rclcpp/src/rclcpp/detail/mutex_two_priorities.cpp\n\u002B\u002B\u002B /dev/null\n@@ -1,104 \u002B0,0 @@\n-// Copyright 2021 Open Source Robotics Foundation, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#include \u0022rclcpp/detail/mutex_two_priorities.hpp\u0022\n-\n-#include \u003Cmutex\u003E\n-\n-namespace rclcpp\n-{\n-namespace detail\n-{\n-\n-using LowPriorityLockable = MutexTwoPriorities::LowPriorityLockable;\n-using HighPriorityLockable = MutexTwoPriorities::HighPriorityLockable;\n-\n-HighPriorityLockable::HighPriorityLockable(MutexTwoPriorities \u0026 parent)\n-: parent_(parent)\n-{}\n-\n-void\n-HighPriorityLockable::lock()\n-{\n-  std::unique_lock\u003Cstd::mutex\u003E guard{parent_.cv_mutex_};\n-  if (parent_.data_taken_) {\n-    \u002B\u002Bparent_.hp_waiting_count_;\n-    while (parent_.data_taken_) {\n-      parent_.hp_cv_.wait(guard);\n-    }\n-    --parent_.hp_waiting_count_;\n-  }\n-  parent_.data_taken_ = true;\n-}\n-\n-void\n-HighPriorityLockable::unlock()\n-{\n-  bool notify_lp{false};\n-  {\n-    std::lock_guard\u003Cstd::mutex\u003E guard{parent_.cv_mutex_};\n-    parent_.data_taken_ = false;\n-    notify_lp = 0u == parent_.hp_waiting_count_;\n-  }\n-  if (notify_lp) {\n-    parent_.lp_cv_.notify_one();\n-  } else {\n-    parent_.hp_cv_.notify_one();\n-  }\n-}\n-\n-LowPriorityLockable::LowPriorityLockable(MutexTwoPriorities \u0026 parent)\n-: parent_(parent)\n-{}\n-\n-void\n-LowPriorityLockable::lock()\n-{\n-  std::unique_lock\u003Cstd::mutex\u003E guard{parent_.cv_mutex_};\n-  while (parent_.data_taken_ || parent_.hp_waiting_count_) {\n-    parent_.lp_cv_.wait(guard);\n-  }\n-  parent_.data_taken_ = true;\n-}\n-\n-void\n-LowPriorityLockable::unlock()\n-{\n-  bool notify_lp{false};\n-  {\n-    std::lock_guard\u003Cstd::mutex\u003E guard{parent_.cv_mutex_};\n-    parent_.data_taken_ = false;\n-    notify_lp = 0u == parent_.hp_waiting_count_;\n-  }\n-  if (notify_lp) {\n-    parent_.lp_cv_.notify_one();\n-  } else {\n-    parent_.hp_cv_.notify_one();\n-  }\n-}\n-\n-HighPriorityLockable\n-MutexTwoPriorities::get_high_priority_lockable()\n-{\n-  return HighPriorityLockable{*this};\n-}\n-\n-LowPriorityLockable\n-MutexTwoPriorities::get_low_priority_lockable()\n-{\n-  return LowPriorityLockable{*this};\n-}\n-\n-}  // namespace detail\n-}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\nindex a9b01b0c..73a65516 100644\n--- rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n@@ -22,7 \u002B22,6 @@\n #include \u0022rclcpp/utilities.hpp\u0022\n #include \u0022rclcpp/scope_exit.hpp\u0022\n \n-using rclcpp::detail::MutexTwoPriorities;\n using rclcpp::executors::MultiThreadedExecutor;\n \n MultiThreadedExecutor::MultiThreadedExecutor(\n@@ -52,8 \u002B51,7 @@ MultiThreadedExecutor::spin()\n   std::vector\u003Cstd::thread\u003E threads;\n   size_t thread_id = 0;\n   {\n-    auto low_priority_wait_mutex = wait_mutex_.get_low_priority_lockable();\n-    std::lock_guard\u003CMutexTwoPriorities::LowPriorityLockable\u003E wait_lock(low_priority_wait_mutex);\n\u002B    std::lock_guard wait_lock{wait_mutex_};\n     for (; thread_id \u003C number_of_threads_ - 1; \u002B\u002Bthread_id) {\n       auto func = std::bind(\u0026MultiThreadedExecutor::run, this, thread_id);\n       threads.emplace_back(func);\n@@ -78,26 \u002B76,13 @@ MultiThreadedExecutor::run(size_t)\n   while (rclcpp::ok(this-\u003Econtext_) \u0026\u0026 spinning.load()) {\n     rclcpp::AnyExecutable any_exec;\n     {\n-      auto low_priority_wait_mutex = wait_mutex_.get_low_priority_lockable();\n-      std::lock_guard\u003CMutexTwoPriorities::LowPriorityLockable\u003E wait_lock(low_priority_wait_mutex);\n\u002B      std::lock_guard wait_lock{wait_mutex_};\n       if (!rclcpp::ok(this-\u003Econtext_) || !spinning.load()) {\n         return;\n       }\n       if (!get_next_executable(any_exec, next_exec_timeout_)) {\n         continue;\n       }\n-      if (any_exec.timer) {\n-        // Guard against multiple threads getting the same timer.\n-        if (scheduled_timers_.count(any_exec.timer) != 0) {\n-          // Make sure that any_exec\u0027s callback group is reset before\n-          // the lock is released.\n-          if (any_exec.callback_group) {\n-            any_exec.callback_group-\u003Ecan_be_taken_from().store(true);\n-          }\n-          continue;\n-        }\n-        scheduled_timers_.insert(any_exec.timer);\n-      }\n     }\n     if (yield_before_execute_) {\n       std::this_thread::yield();\n@@ -105,14 \u002B90,6 @@ MultiThreadedExecutor::run(size_t)\n \n     execute_any_executable(any_exec);\n \n-    if (any_exec.timer) {\n-      auto high_priority_wait_mutex = wait_mutex_.get_high_priority_lockable();\n-      std::lock_guard\u003CMutexTwoPriorities::HighPriorityLockable\u003E wait_lock(high_priority_wait_mutex);\n-      auto it = scheduled_timers_.find(any_exec.timer);\n-      if (it != scheduled_timers_.end()) {\n-        scheduled_timers_.erase(it);\n-      }\n-    }\n     // Clear the callback_group to prevent the AnyExecutable destructor from\n     // resetting the callback group \u0060can_be_taken_from\u0060\n     any_exec.callback_group.reset();\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp\nindex e206e75b..d368e0e8 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp\n@@ -32,6 \u002B32,7 @@ public:\n   : TimerBase(node-\u003Eget_clock(), std::chrono::nanoseconds(1),\n       node-\u003Eget_node_base_interface()-\u003Eget_context()) {}\n \n\u002B  bool call() override {return true;}\n   void execute_callback() override {}\n   bool is_steady() override {return false;}\n };\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "efc8b4d271999f4ea394a36283faef60e9db85d7",
    "RawMessage": "add test to parameter_dict_from_yaml for nonexistent file",
    "Changes": "diff --git rclpy/test/test_parameter.py rclpy/test/test_parameter.py\nindex 187ef9f..acf6b9b 100644\n--- rclpy/test/test_parameter.py\n\u002B\u002B\u002B rclpy/test/test_parameter.py\n@@ -227,10 \u002B227,13 @@ class TestParameter(unittest.TestCase):\n \n         with NamedTemporaryFile(mode=\u0027w\u0027) as f:\n             f.write(yaml_string)\n-            f.seek(0)\n\u002B            f.flush()\n             parameter_dict = parameter_dict_from_yaml_file(f.name)\n\u002B            print(parameter_dict)\n         assert parameter_dict == expected\n \n\u002B        self.assertRaises(FileNotFoundError, parameter_dict_from_yaml_file, \u0027unknown_file\u0027)\n\u002B\n \n if __name__ == \u0027__main__\u0027:\n     unittest.main()\ndiff --git rclpy/test/test_parameter_client.py rclpy/test/test_parameter_client.py\nindex 56ae923..cbd62df 100644\n--- rclpy/test/test_parameter_client.py\n\u002B\u002B\u002B rclpy/test/test_parameter_client.py\n@@ -85,6 \u002B85,7 @@ class TestParameterClient(unittest.TestCase):\n         self.executor.spin_until_future_complete(future)\n         results = future.result()\n         assert results is not None\n\u002B        assert len(results.descriptors) == 1\n         assert results.descriptors[0].type == 7\n         assert results.descriptors[0].name == \u0027int_arr_param\u0027\n \n@@ -93,6 \u002B94,7 @@ class TestParameterClient(unittest.TestCase):\n         self.executor.spin_until_future_complete(future)\n         results = future.result()\n         assert results is not None\n\u002B        assert len(results.types) == 1\n         assert results.types[0] == ParameterType.PARAMETER_INTEGER_ARRAY\n \n     def test_set_parameters_atomically(self):\n@@ -114,6 \u002B116,7 @@ class TestParameterClient(unittest.TestCase):\n         self.executor.spin_until_future_complete(future)\n         result = future.result()\n         assert result is not None\n\u002B        assert len(result.results) == 1\n         assert not result.results[0].successful\n         assert result.results[0].reason == \u0027Static parameter cannot be undeclared\u0027\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "aba3e4650329294b0c514fdd3273b1f8eff7caa9",
    "RawMessage": "Fix up the style in tf2_eigen. (#378)",
    "Changes": "diff --git tf2_eigen/CMakeLists.txt tf2_eigen/CMakeLists.txt\nindex f29a3870..2bd4852e 100644\n--- tf2_eigen/CMakeLists.txt\n\u002B\u002B\u002B tf2_eigen/CMakeLists.txt\n@@ -21,7 \u002B21,18 @@ install(DIRECTORY include/${PROJECT_NAME}/\n         DESTINATION include/${PROJECT_NAME})\n \n if(BUILD_TESTING)\n\u002B  find_package(ament_cmake_cppcheck REQUIRED)\n\u002B  find_package(ament_cmake_cpplint REQUIRED)\n\u002B  find_package(ament_cmake_lint_cmake REQUIRED)\n\u002B  find_package(ament_cmake_uncrustify REQUIRED)\n\u002B\n\u002B  ament_cppcheck(LANGUAGE \u0022c\u002B\u002B\u0022)\n\u002B  ament_cpplint()\n\u002B  ament_lint_cmake()\n\u002B  ament_uncrustify(LANGUAGE \u0022c\u002B\u002B\u0022)\n\u002B\n   find_package(ament_cmake_gtest REQUIRED)\n\u002B\n   ament_add_gtest(tf2_eigen-test test/tf2_eigen-test.cpp)\n   if(TARGET tf2_eigen-test)\n     target_include_directories(tf2_eigen-test PUBLIC\ndiff --git tf2_eigen/include/tf2_eigen/tf2_eigen.h tf2_eigen/include/tf2_eigen/tf2_eigen.h\nindex fe25dbfa..691e09db 100644\n--- tf2_eigen/include/tf2_eigen/tf2_eigen.h\n\u002B\u002B\u002B tf2_eigen/include/tf2_eigen/tf2_eigen.h\n@@ -26,8 \u002B26,8 @@\n \n /** \\author Koji Terada */\n \n-#ifndef TF2_EIGEN_H\n-#define TF2_EIGEN_H\n\u002B#ifndef TF2_EIGEN__TF2_EIGEN_H_\n\u002B#define TF2_EIGEN__TF2_EIGEN_H_\n \n #include \u003Ctf2/convert.h\u003E\n #include \u003Ctf2_ros/buffer_interface.h\u003E\n@@ -48,10 \u002B48,12 @@ namespace tf2\n  * \\param t The transform to convert, as a geometry_msgs Transform message.\n  * \\return The transform message converted to an Eigen Isometry3d transform.\n  */\n- inline\n- Eigen::Isometry3d transformToEigen(const geometry_msgs::msg::Transform\u0026 t) {\n-   return Eigen::Isometry3d(Eigen::Translation3d(t.translation.x, t.translation.y, t.translation.z)\n-\t\t\t * Eigen::Quaterniond(t.rotation.w, t.rotation.x, t.rotation.y, t.rotation.z));\n\u002Binline\n\u002BEigen::Isometry3d transformToEigen(const geometry_msgs::msg::Transform \u0026 t)\n\u002B{\n\u002B  return Eigen::Isometry3d(\n\u002B    Eigen::Translation3d(t.translation.x, t.translation.y, t.translation.z) *\n\u002B    Eigen::Quaterniond(t.rotation.w, t.rotation.x, t.rotation.y, t.rotation.z));\n }\n \n /** \\brief Convert a timestamped transform to the equivalent Eigen data type.\n@@ -59,7 \u002B61,8 @@ namespace tf2\n  * \\return The transform message converted to an Eigen Isometry3d transform.\n  */\n inline\n-Eigen::Isometry3d transformToEigen(const geometry_msgs::msg::TransformStamped\u0026 t) {\n\u002BEigen::Isometry3d transformToEigen(const geometry_msgs::msg::TransformStamped \u0026 t)\n\u002B{\n   return transformToEigen(t.transform);\n }\n \n@@ -68,7 \u002B71,7 @@ Eigen::Isometry3d transformToEigen(const geometry_msgs::msg::TransformStamped\u0026 t\n  * \\return The transform converted to a TransformStamped message.\n  */\n inline\n-geometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Affine3d\u0026 T)\n\u002Bgeometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Affine3d \u0026 T)\n {\n   geometry_msgs::msg::TransformStamped t;\n   t.transform.translation.x = T.translation().x();\n@@ -89,7 \u002B92,7 @@ geometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Affine3d\u0026 T)\n  * \\return The transform converted to a TransformStamped message.\n  */\n inline\n-geometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Isometry3d\u0026 T)\n\u002Bgeometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Isometry3d \u0026 T)\n {\n   geometry_msgs::msg::TransformStamped t;\n   t.transform.translation.x = T.translation().x();\n@@ -114,9 \u002B117,12 @@ geometry_msgs::msg::TransformStamped eigenToTransform(const Eigen::Isometry3d\u0026 T\n  * \\param t_out The transformed vector, as a Eigen Vector3d data type.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const Eigen::Vector3d\u0026 t_in, Eigen::Vector3d\u0026 t_out, const geometry_msgs::msg::TransformStamped\u0026 transform)\n\u002Bvoid doTransform(\n\u002B  const Eigen::Vector3d \u0026 t_in,\n\u002B  Eigen::Vector3d \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n {\n   t_out = Eigen::Vector3d(transformToEigen(transform) * t_in);\n }\n@@ -127,7 \u002B133,7 @@ void doTransform(const Eigen::Vector3d\u0026 t_in, Eigen::Vector3d\u0026 t_out, const geom\n  * \\return The vector converted to a Point message.\n  */\n inline\n-geometry_msgs::msg::Point toMsg(const Eigen::Vector3d\u0026 in)\n\u002Bgeometry_msgs::msg::Point toMsg(const Eigen::Vector3d \u0026 in)\n {\n   geometry_msgs::msg::Point msg;\n   msg.x = in.x();\n@@ -142,7 \u002B148,7 @@ geometry_msgs::msg::Point toMsg(const Eigen::Vector3d\u0026 in)\n  * \\param out The point converted to a Eigen Vector3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Point\u0026 msg, Eigen::Vector3d\u0026 out)\n\u002Bvoid fromMsg(const geometry_msgs::msg::Point \u0026 msg, Eigen::Vector3d \u0026 out)\n {\n   out.x() = msg.x;\n   out.y() = msg.y;\n@@ -155,7 \u002B161,7 @@ void fromMsg(const geometry_msgs::msg::Point\u0026 msg, Eigen::Vector3d\u0026 out)\n  * \\return The vector converted to a Vector3 message.\n  */\n inline\n-geometry_msgs::msg::Vector3\u0026 toMsg(const Eigen::Vector3d\u0026 in, geometry_msgs::msg::Vector3\u0026 out)\n\u002Bgeometry_msgs::msg::Vector3 \u0026 toMsg(const Eigen::Vector3d \u0026 in, geometry_msgs::msg::Vector3 \u0026 out)\n {\n   out.x = in.x();\n   out.y = in.y();\n@@ -169,7 \u002B175,7 @@ geometry_msgs::msg::Vector3\u0026 toMsg(const Eigen::Vector3d\u0026 in, geometry_msgs::msg\n  * \\param out The vector converted to a Eigen Vector3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Vector3\u0026 msg, Eigen::Vector3d\u0026 out)\n\u002Bvoid fromMsg(const geometry_msgs::msg::Vector3 \u0026 msg, Eigen::Vector3d \u0026 out)\n {\n   out.x() = msg.x;\n   out.y() = msg.y;\n@@ -182,14 \u002B188,17 @@ void fromMsg(const geometry_msgs::msg::Vector3\u0026 msg, Eigen::Vector3d\u0026 out)\n  * \\param t_out The transformed vector, as a timestamped Eigen Vector3d data type.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 t_in,\n-\t\t tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 t_out,\n-\t\t const geometry_msgs::msg::TransformStamped\u0026 transform) {\n-  t_out = tf2::Stamped\u003CEigen::Vector3d\u003E(transformToEigen(transform) * t_in,\n-                                        tf2_ros::fromMsg(transform.header.stamp),\n-\t\t\t\t\ttransform.header.frame_id);\n\u002Bvoid doTransform(\n\u002B  const tf2::Stamped\u003CEigen::Vector3d\u003E \u0026 t_in,\n\u002B  tf2::Stamped\u003CEigen::Vector3d\u003E \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n\u002B  t_out = tf2::Stamped\u003CEigen::Vector3d\u003E(\n\u002B    transformToEigen(transform) * t_in,\n\u002B    tf2_ros::fromMsg(transform.header.stamp),\n\u002B    transform.header.frame_id);\n }\n \n /** \\brief Convert a stamped Eigen Vector3d type to a PointStamped message.\n@@ -198,12 \u002B207,12 @@ void doTransform(const tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 t_in,\n  * \\return The vector converted to a PointStamped message.\n  */\n inline\n-geometry_msgs::msg::PointStamped toMsg(const tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 in)\n\u002Bgeometry_msgs::msg::PointStamped toMsg(const tf2::Stamped\u003CEigen::Vector3d\u003E \u0026 in)\n {\n   geometry_msgs::msg::PointStamped msg;\n   msg.header.stamp = tf2_ros::toMsg(in.stamp_);\n   msg.header.frame_id = in.frame_id_;\n-  msg.point = toMsg(static_cast\u003Cconst Eigen::Vector3d\u0026\u003E(in));\n\u002B  msg.point = toMsg(static_cast\u003Cconst Eigen::Vector3d \u0026\u003E(in));\n   return msg;\n }\n \n@@ -213,10 \u002B222,11 @@ geometry_msgs::msg::PointStamped toMsg(const tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 in)\n  * \\param out The point converted to a timestamped Eigen Vector3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::PointStamped\u0026 msg, tf2::Stamped\u003CEigen::Vector3d\u003E\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::PointStamped \u0026 msg, tf2::Stamped\u003CEigen::Vector3d\u003E \u0026 out)\n\u002B{\n   out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);\n   out.frame_id_ = msg.header.frame_id;\n-  fromMsg(msg.point, static_cast\u003CEigen::Vector3d\u0026\u003E(out));\n\u002B  fromMsg(msg.point, static_cast\u003CEigen::Vector3d \u0026\u003E(out));\n }\n \n /** \\brief Apply a geometry_msgs Transform to an Eigen Affine3d transform.\n@@ -228,19 \u002B238,23 @@ void fromMsg(const geometry_msgs::msg::PointStamped\u0026 msg, tf2::Stamped\u003CEigen::Ve\n  * \\param t_out The transformed frame, as a Eigen Affine3d transform.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const Eigen::Affine3d\u0026 t_in,\n-                 Eigen::Affine3d\u0026 t_out,\n-                 const geometry_msgs::msg::TransformStamped\u0026 transform) {\n\u002Bvoid doTransform(\n\u002B  const Eigen::Affine3d \u0026 t_in,\n\u002B  Eigen::Affine3d \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n   t_out = Eigen::Affine3d(transformToEigen(transform) * t_in);\n }\n \n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const Eigen::Isometry3d\u0026 t_in,\n-                 Eigen::Isometry3d\u0026 t_out,\n-                 const geometry_msgs::msg::TransformStamped\u0026 transform) {\n\u002Bvoid doTransform(\n\u002B  const Eigen::Isometry3d \u0026 t_in,\n\u002B  Eigen::Isometry3d \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n   t_out = Eigen::Isometry3d(transformToEigen(transform) * t_in);\n }\n \n@@ -250,13 \u002B264,14 @@ void doTransform(const Eigen::Isometry3d\u0026 t_in,\n  * \\return The quaternion converted to a Quaterion message.\n  */\n inline\n-geometry_msgs::msg::Quaternion toMsg(const Eigen::Quaterniond\u0026 in) {\n- geometry_msgs::msg::Quaternion msg;\n- msg.w = in.w();\n- msg.x = in.x();\n- msg.y = in.y();\n- msg.z = in.z();\n- return msg;\n\u002Bgeometry_msgs::msg::Quaternion toMsg(const Eigen::Quaterniond \u0026 in)\n\u002B{\n\u002B  geometry_msgs::msg::Quaternion msg;\n\u002B  msg.w = in.w();\n\u002B  msg.x = in.x();\n\u002B  msg.y = in.y();\n\u002B  msg.z = in.z();\n\u002B  return msg;\n }\n \n /** \\brief Convert a Quaternion message type to a Eigen-specific Quaterniond type.\n@@ -265,7 \u002B280,8 @@ geometry_msgs::msg::Quaternion toMsg(const Eigen::Quaterniond\u0026 in) {\n  * \\param out The quaternion converted to a Eigen Quaterniond.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Quaternion\u0026 msg, Eigen::Quaterniond\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Quaternion \u0026 msg, Eigen::Quaterniond \u0026 out)\n\u002B{\n   out = Eigen::Quaterniond(msg.w, msg.x, msg.y, msg.z);\n }\n \n@@ -280,9 \u002B296,11 @@ void fromMsg(const geometry_msgs::msg::Quaternion\u0026 msg, Eigen::Quaterniond\u0026 out)\n  */\n template\u003C\u003E\n inline\n-void doTransform(const Eigen::Quaterniond\u0026 t_in,\n-                 Eigen::Quaterniond\u0026 t_out,\n-                 const geometry_msgs::msg::TransformStamped\u0026 transform) {\n\u002Bvoid doTransform(\n\u002B  const Eigen::Quaterniond \u0026 t_in,\n\u002B  Eigen::Quaterniond \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n   Eigen::Quaterniond t;\n   fromMsg(transform.transform.rotation, t);\n   t_out = t * t_in;\n@@ -294,11 \u002B312,12 @@ void doTransform(const Eigen::Quaterniond\u0026 t_in,\n  * \\return The quaternion converted to a QuaternionStamped message.\n  */\n inline\n-geometry_msgs::msg::QuaternionStamped toMsg(const Stamped\u003CEigen::Quaterniond\u003E\u0026 in) {\n\u002Bgeometry_msgs::msg::QuaternionStamped toMsg(const Stamped\u003CEigen::Quaterniond\u003E \u0026 in)\n\u002B{\n   geometry_msgs::msg::QuaternionStamped msg;\n   msg.header.stamp = tf2_ros::toMsg(in.stamp_);\n   msg.header.frame_id = in.frame_id_;\n-  msg.quaternion = toMsg(static_cast\u003Cconst Eigen::Quaterniond\u0026\u003E(in));\n\u002B  msg.quaternion = toMsg(static_cast\u003Cconst Eigen::Quaterniond \u0026\u003E(in));\n   return msg;\n }\n \n@@ -308,10 \u002B327,11 @@ geometry_msgs::msg::QuaternionStamped toMsg(const Stamped\u003CEigen::Quaterniond\u003E\u0026 i\n  * \\param out The quaternion converted to a timestamped Eigen Quaterniond.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::QuaternionStamped\u0026 msg, Stamped\u003CEigen::Quaterniond\u003E\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::QuaternionStamped \u0026 msg, Stamped\u003CEigen::Quaterniond\u003E \u0026 out)\n\u002B{\n   out.frame_id_ = msg.header.frame_id;\n   out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);\n-  fromMsg(msg.quaternion, static_cast\u003CEigen::Quaterniond\u0026\u003E(out));\n\u002B  fromMsg(msg.quaternion, static_cast\u003CEigen::Quaterniond \u0026\u003E(out));\n }\n \n /** \\brief Apply a geometry_msgs TransformStamped to an Eigen-specific Quaterniond type.\n@@ -320,14 \u002B340,18 @@ void fromMsg(const geometry_msgs::msg::QuaternionStamped\u0026 msg, Stamped\u003CEigen::Qu\n  * \\param t_out The transformed vector, as a timestamped Eigen Quaterniond data type.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const tf2::Stamped\u003CEigen::Quaterniond\u003E\u0026 t_in,\n-     tf2::Stamped\u003CEigen::Quaterniond\u003E\u0026 t_out,\n-     const geometry_msgs::msg::TransformStamped\u0026 transform) {\n\u002Bvoid doTransform(\n\u002B  const tf2::Stamped\u003CEigen::Quaterniond\u003E \u0026 t_in,\n\u002B  tf2::Stamped\u003CEigen::Quaterniond\u003E \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n   t_out.frame_id_ = transform.header.frame_id;\n   t_out.stamp_ = tf2_ros::fromMsg(transform.header.stamp);\n-  doTransform(static_cast\u003Cconst Eigen::Quaterniond\u0026\u003E(t_in), static_cast\u003CEigen::Quaterniond\u0026\u003E(t_out), transform);\n\u002B  doTransform(\n\u002B    static_cast\u003Cconst Eigen::Quaterniond \u0026\u003E(t_in),\n\u002B    static_cast\u003CEigen::Quaterniond \u0026\u003E(t_out), transform);\n }\n \n /** \\brief Convert a Eigen Affine3d transform type to a Pose message.\n@@ -336,7 \u002B360,8 @@ void doTransform(const tf2::Stamped\u003CEigen::Quaterniond\u003E\u0026 t_in,\n  * \\return The Eigen transform converted to a Pose message.\n  */\n inline\n-geometry_msgs::msg::Pose toMsg(const Eigen::Affine3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Pose toMsg(const Eigen::Affine3d \u0026 in)\n\u002B{\n   geometry_msgs::msg::Pose msg;\n   msg.position.x = in.translation().x();\n   msg.position.y = in.translation().y();\n@@ -355,7 \u002B380,8 @@ geometry_msgs::msg::Pose toMsg(const Eigen::Affine3d\u0026 in) {\n  * \\return The Eigen transform converted to a Pose message.\n  */\n inline\n-geometry_msgs::msg::Pose toMsg(const Eigen::Isometry3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Pose toMsg(const Eigen::Isometry3d \u0026 in)\n\u002B{\n   geometry_msgs::msg::Pose msg;\n   msg.position.x = in.translation().x();\n   msg.position.y = in.translation().y();\n@@ -376,11 \u002B402,12 @@ geometry_msgs::msg::Pose toMsg(const Eigen::Isometry3d\u0026 in) {\n  * \\return The Eigen::Vector3d converted to a geometry_msgs::msg::Vector3 message.\n  */\n inline\n-geometry_msgs::msg::Vector3 toMsg2(const Eigen::Vector3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Vector3 toMsg2(const Eigen::Vector3d \u0026 in)\n\u002B{\n   geometry_msgs::msg::Vector3 msg;\n-  msg.x = in(0);\n-  msg.y = in(1);\n-  msg.z = in(2);\n\u002B  msg.x = in (0);\n\u002B  msg.y = in (1);\n\u002B  msg.z = in (2);\n   return msg;\n }\n \n@@ -390,13 \u002B417,15 @@ geometry_msgs::msg::Vector3 toMsg2(const Eigen::Vector3d\u0026 in) {\n  * \\param out The pose converted to a Eigen Affine3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Affine3d\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Pose \u0026 msg, Eigen::Affine3d \u0026 out)\n\u002B{\n   out = Eigen::Affine3d(\n-      Eigen::Translation3d(msg.position.x, msg.position.y, msg.position.z) *\n-      Eigen::Quaterniond(msg.orientation.w,\n-                         msg.orientation.x,\n-                         msg.orientation.y,\n-                         msg.orientation.z));\n\u002B    Eigen::Translation3d(msg.position.x, msg.position.y, msg.position.z) *\n\u002B    Eigen::Quaterniond(\n\u002B      msg.orientation.w,\n\u002B      msg.orientation.x,\n\u002B      msg.orientation.y,\n\u002B      msg.orientation.z));\n }\n \n /** \\brief Convert a Pose message transform type to a Eigen Isometry3d.\n@@ -405,13 \u002B434,15 @@ void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Affine3d\u0026 out) {\n  * \\param out The pose converted to a Eigen Isometry3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Isometry3d\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Pose \u0026 msg, Eigen::Isometry3d \u0026 out)\n\u002B{\n   out = Eigen::Isometry3d(\n-      Eigen::Translation3d(msg.position.x, msg.position.y, msg.position.z) *\n-      Eigen::Quaterniond(msg.orientation.w,\n-                         msg.orientation.x,\n-                         msg.orientation.y,\n-                         msg.orientation.z));\n\u002B    Eigen::Translation3d(msg.position.x, msg.position.y, msg.position.z) *\n\u002B    Eigen::Quaterniond(\n\u002B      msg.orientation.w,\n\u002B      msg.orientation.x,\n\u002B      msg.orientation.y,\n\u002B      msg.orientation.z));\n }\n \n /** \\brief Convert a Eigen 6x1 Matrix type to a Twist message.\n@@ -420,7 \u002B451,8 @@ void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Isometry3d\u0026 out) {\n  * \\return The Eigen Matrix converted to a Twist message.\n  */\n inline\n-geometry_msgs::msg::Twist toMsg(const Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 in) {\n\u002Bgeometry_msgs::msg::Twist toMsg(const Eigen::Matrix\u003Cdouble, 6, 1\u003E \u0026 in)\n\u002B{\n   geometry_msgs::msg::Twist msg;\n   msg.linear.x = in[0];\n   msg.linear.y = in[1];\n@@ -437,7 \u002B469,8 @@ geometry_msgs::msg::Twist toMsg(const Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 in) {\n  * \\param out The twist converted to a Eigen 6x1 Matrix.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::Twist \u0026msg, Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Twist \u0026 msg, Eigen::Matrix\u003Cdouble, 6, 1\u003E \u0026 out)\n\u002B{\n   out[0] = msg.linear.x;\n   out[1] = msg.linear.y;\n   out[2] = msg.linear.z;\n@@ -455,12 \u002B488,16 @@ void fromMsg(const geometry_msgs::msg::Twist \u0026msg, Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 ou\n  * \\param t_out The transformed frame, as a timestamped Eigen Affine3d transform.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const tf2::Stamped\u003CEigen::Affine3d\u003E\u0026 t_in,\n-\t\t tf2::Stamped\u003CEigen::Affine3d\u003E\u0026 t_out,\n-\t\t const geometry_msgs::msg::TransformStamped\u0026 transform) {\n-  t_out = tf2::Stamped\u003CEigen::Affine3d\u003E(transformToEigen(transform) * t_in, tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);\n\u002Bvoid doTransform(\n\u002B  const tf2::Stamped\u003CEigen::Affine3d\u003E \u0026 t_in,\n\u002B  tf2::Stamped\u003CEigen::Affine3d\u003E \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n\u002B  t_out = tf2::Stamped\u003CEigen::Affine3d\u003E(\n\u002B    transformToEigen(transform) * t_in, tf2_ros::fromMsg(\n\u002B      transform.header.stamp), transform.header.frame_id);\n }\n \n /** \\brief Apply a geometry_msgs TransformStamped to an Eigen Isometry transform.\n@@ -472,12 \u002B509,16 @@ void doTransform(const tf2::Stamped\u003CEigen::Affine3d\u003E\u0026 t_in,\n  * \\param t_out The transformed frame, as a timestamped Eigen Isometry transform.\n  * \\param transform The timestamped transform to apply, as a TransformStamped message.\n  */\n-template \u003C\u003E\n\u002Btemplate\u003C\u003E\n inline\n-void doTransform(const tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 t_in,\n-\t\t tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 t_out,\n-\t\t const geometry_msgs::msg::TransformStamped\u0026 transform) {\n-  t_out = tf2::Stamped\u003CEigen::Isometry3d\u003E(transformToEigen(transform) * t_in, tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);\n\u002Bvoid doTransform(\n\u002B  const tf2::Stamped\u003CEigen::Isometry3d\u003E \u0026 t_in,\n\u002B  tf2::Stamped\u003CEigen::Isometry3d\u003E \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n\u002B  t_out = tf2::Stamped\u003CEigen::Isometry3d\u003E(\n\u002B    transformToEigen(transform) * t_in, tf2_ros::fromMsg(\n\u002B      transform.header.stamp), transform.header.frame_id);\n }\n \n /** \\brief Convert a stamped Eigen Affine3d transform type to a Pose message.\n@@ -486,22 \u002B527,22 @@ void doTransform(const tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 t_in,\n  * \\return The Eigen transform converted to a PoseStamped message.\n  */\n inline\n-geometry_msgs::msg::PoseStamped toMsg(const tf2::Stamped\u003CEigen::Affine3d\u003E\u0026 in)\n\u002Bgeometry_msgs::msg::PoseStamped toMsg(const tf2::Stamped\u003CEigen::Affine3d\u003E \u0026 in)\n {\n   geometry_msgs::msg::PoseStamped msg;\n   msg.header.stamp = tf2_ros::toMsg(in.stamp_);\n   msg.header.frame_id = in.frame_id_;\n-  msg.pose = toMsg(static_cast\u003Cconst Eigen::Affine3d\u0026\u003E(in));\n\u002B  msg.pose = toMsg(static_cast\u003Cconst Eigen::Affine3d \u0026\u003E(in));\n   return msg;\n }\n \n inline\n-geometry_msgs::msg::PoseStamped toMsg(const tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 in)\n\u002Bgeometry_msgs::msg::PoseStamped toMsg(const tf2::Stamped\u003CEigen::Isometry3d\u003E \u0026 in)\n {\n   geometry_msgs::msg::PoseStamped msg;\n   msg.header.stamp = tf2_ros::toMsg(in.stamp_);\n   msg.header.frame_id = in.frame_id_;\n-  msg.pose = toMsg(static_cast\u003Cconst Eigen::Isometry3d\u0026\u003E(in));\n\u002B  msg.pose = toMsg(static_cast\u003Cconst Eigen::Isometry3d \u0026\u003E(in));\n   return msg;\n }\n \n@@ -511,25 \u002B552,26 @@ geometry_msgs::msg::PoseStamped toMsg(const tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 in)\n  * \\param out The pose converted to a timestamped Eigen Affine3d.\n  */\n inline\n-void fromMsg(const geometry_msgs::msg::PoseStamped\u0026 msg, tf2::Stamped\u003CEigen::Affine3d\u003E\u0026 out)\n\u002Bvoid fromMsg(const geometry_msgs::msg::PoseStamped \u0026 msg, tf2::Stamped\u003CEigen::Affine3d\u003E \u0026 out)\n {\n   out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);\n   out.frame_id_ = msg.header.frame_id;\n-  fromMsg(msg.pose, static_cast\u003CEigen::Affine3d\u0026\u003E(out));\n\u002B  fromMsg(msg.pose, static_cast\u003CEigen::Affine3d \u0026\u003E(out));\n }\n \n inline\n-void fromMsg(const geometry_msgs::msg::PoseStamped\u0026 msg, tf2::Stamped\u003CEigen::Isometry3d\u003E\u0026 out)\n\u002Bvoid fromMsg(const geometry_msgs::msg::PoseStamped \u0026 msg, tf2::Stamped\u003CEigen::Isometry3d\u003E \u0026 out)\n {\n   out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);\n   out.frame_id_ = msg.header.frame_id;\n-  fromMsg(msg.pose, static_cast\u003CEigen::Isometry3d\u0026\u003E(out));\n\u002B  fromMsg(msg.pose, static_cast\u003CEigen::Isometry3d \u0026\u003E(out));\n }\n \n-} // namespace\n\u002B}  // namespace tf2\n \n \n-namespace Eigen {\n\u002Bnamespace Eigen\n\u002B{\n // This is needed to make the usage of the following conversion functions usable in tf2::convert().\n // According to clangs error note \u0027fromMsg\u0027/\u0027toMsg\u0027 should be declared prior to the call site or\n // in an associated namespace of one of its arguments. The stamped versions of this conversion\n@@ -539,50 \u002B581,59 @@ namespace Eigen {\n // tf2::convert().\n \n inline\n-geometry_msgs::msg::Pose toMsg(const Eigen::Affine3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Pose toMsg(const Eigen::Affine3d \u0026 in)\n\u002B{\n   return tf2::toMsg(in);\n }\n \n inline\n-geometry_msgs::msg::Pose toMsg(const Eigen::Isometry3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Pose toMsg(const Eigen::Isometry3d \u0026 in)\n\u002B{\n   return tf2::toMsg(in);\n }\n \n inline\n-void fromMsg(const geometry_msgs::msg::Point\u0026 msg, Eigen::Vector3d\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Point \u0026 msg, Eigen::Vector3d \u0026 out)\n\u002B{\n   tf2::fromMsg(msg, out);\n }\n \n inline\n-geometry_msgs::msg::Point toMsg(const Eigen::Vector3d\u0026 in) {\n\u002Bgeometry_msgs::msg::Point toMsg(const Eigen::Vector3d \u0026 in)\n\u002B{\n   return tf2::toMsg(in);\n }\n \n inline\n-void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Affine3d\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Pose \u0026 msg, Eigen::Affine3d \u0026 out)\n\u002B{\n   tf2::fromMsg(msg, out);\n }\n \n inline\n-void fromMsg(const geometry_msgs::msg::Pose\u0026 msg, Eigen::Isometry3d\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Pose \u0026 msg, Eigen::Isometry3d \u0026 out)\n\u002B{\n   tf2::fromMsg(msg, out);\n }\n \n inline\n-geometry_msgs::msg::Quaternion toMsg(const Eigen::Quaterniond\u0026 in) {\n\u002Bgeometry_msgs::msg::Quaternion toMsg(const Eigen::Quaterniond \u0026 in)\n\u002B{\n   return tf2::toMsg(in);\n }\n \n inline\n-geometry_msgs::msg::Twist toMsg(const Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 in) {\n\u002Bgeometry_msgs::msg::Twist toMsg(const Eigen::Matrix\u003Cdouble, 6, 1\u003E \u0026 in)\n\u002B{\n   return tf2::toMsg(in);\n }\n \n inline\n-void fromMsg(const geometry_msgs::msg::Twist \u0026msg, Eigen::Matrix\u003Cdouble,6,1\u003E\u0026 out) {\n\u002Bvoid fromMsg(const geometry_msgs::msg::Twist \u0026 msg, Eigen::Matrix\u003Cdouble, 6, 1\u003E \u0026 out)\n\u002B{\n   tf2::fromMsg(msg, out);\n }\n \n-} // namespace\n\u002B}  // namespace Eigen\n \n-#endif // TF2_EIGEN_H\n\u002B#endif  // TF2_EIGEN__TF2_EIGEN_H_\ndiff --git tf2_eigen/package.xml tf2_eigen/package.xml\nindex c69058a5..c20183a8 100644\n--- tf2_eigen/package.xml\n\u002B\u002B\u002B tf2_eigen/package.xml\n@@ -21,6 \u002B21,8 @@\n   \u003Cdepend\u003Etf2_ros\u003C/depend\u003E\n \n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n \n   \u003Cbuild_export_depend\u003Eeigen\u003C/build_export_depend\u003E\n \ndiff --git tf2_eigen/test/tf2_eigen-test.cpp tf2_eigen/test/tf2_eigen-test.cpp\nindex 45d077c7..f03c2544 100644\n--- tf2_eigen/test/tf2_eigen-test.cpp\n\u002B\u002B\u002B tf2_eigen/test/tf2_eigen-test.cpp\n@@ -34,23 \u002B34,21 @@\n #endif\n #endif\n \n-#include \u003Cmath.h\u003E\n-\n-\n #include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Crclcpp/clock.hpp\u003E\n #include \u003Ctf2/convert.h\u003E\n #include \u003Ctf2_eigen/tf2_eigen.h\u003E\n #include \u003Ctf2_ros/buffer.h\u003E\n #include \u003Ctf2_ros/transform_listener.h\u003E\n \n-\n\u002B#include \u003Ccmath\u003E\n #include \u003Cmemory\u003E\n-#include \u003Crclcpp/clock.hpp\u003E\n \n // TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented\n // TEST(TfEigen, ConvertVector3dStamped)\n // {\n-//   const tf2::Stamped\u003CEigen::Vector3d\u003E v(Eigen::Vector3d(1,2,3), tf2::TimePoint(std::chrono::seconds(5)), \u0022test\u0022);\n\u002B//   const tf2::Stamped\u003CEigen::Vector3d\u003E v(Eigen::Vector3d(1,2,3),\n\u002B//     tf2::TimePoint(std::chrono::seconds(5)), \u0022test\u0022);\n \n //   tf2::Stamped\u003CEigen::Vector3d\u003E v1;\n //   geometry_msgs::msg::PointStamped p1;\n@@ -74,8 \u002B72,10 @@\n \n // TEST(TfEigen, ConvertAffine3dStamped)\n // {\n-//   const Eigen::Affine3d v_nonstamped(Eigen::Translation3d(1,2,3) * Eigen::AngleAxis\u003Cdouble\u003E(1, Eigen::Vector3d::UnitX()));\n-//   const tf2::Stamped\u003CEigen::Affine3d\u003E v(v_nonstamped, tf2::TimePoint(std::chrono::seconds(42)), \u0022test_frame\u0022);\n\u002B//   const Eigen::Affine3d v_nonstamped(\n\u002B//     Eigen::Translation3d(1,2,3) * Eigen::AngleAxis\u003Cdouble\u003E(1, Eigen::Vector3d::UnitX()));\n\u002B//   const tf2::Stamped\u003CEigen::Affine3d\u003E v(\n\u002B//     v_nonstamped, tf2::TimePoint(std::chrono::seconds(42)), \u0022test_frame\u0022);\n \n //   tf2::Stamped\u003CEigen::Affine3d\u003E v1;\n //   geometry_msgs::msg::PoseStamped p1;\n@@ -90,7 \u002B90,8 @@\n \n // TEST(TfEigen, ConvertAffine3d)\n // {\n-//   const Eigen::Affine3d v(Eigen::Translation3d(1,2,3) * Eigen::AngleAxis\u003Cdouble\u003E(1, Eigen::Vector3d::UnitX()));\n\u002B//   const Eigen::Affine3d v(\n\u002B//     Eigen::Translation3d(1,2,3) * Eigen::AngleAxis\u003Cdouble\u003E(1, Eigen::Vector3d::UnitX()));\n \n //   Eigen::Affine3d v1;\n //   geometry_msgs::msg::Pose p1;\n@@ -105,14 \u002B106,16 @@ TEST(TfEigen, ConvertTransform)\n {\n   Eigen::Matrix4d tm;\n \n-  double alpha = M_PI/4.0;\n-  double theta = M_PI/6.0;\n-  double gamma = M_PI/12.0;\n\u002B  double alpha = M_PI / 4.0;\n\u002B  double theta = M_PI / 6.0;\n\u002B  double gamma = M_PI / 12.0;\n \n-  tm \u003C\u003C cos(theta)*cos(gamma),-cos(theta)*sin(gamma),sin(theta), 1, //\n-  cos(alpha)*sin(gamma)\u002Bsin(alpha)*sin(theta)*cos(gamma),cos(alpha)*cos(gamma)-sin(alpha)*sin(theta)*sin(gamma),-sin(alpha)*cos(theta), 2, //\n-  sin(alpha)*sin(gamma)-cos(alpha)*sin(theta)*cos(gamma),cos(alpha)*sin(theta)*sin(gamma)\u002Bsin(alpha)*cos(gamma),cos(alpha)*cos(theta), 3, //\n-  0, 0, 0, 1;\n\u002B  tm \u003C\u003C cos(theta) * cos(gamma), -cos(theta) * sin(gamma), sin(theta), 1,\n\u002B    cos(alpha) * sin(gamma) \u002B sin(alpha) * sin(theta) * cos(gamma),\n\u002B    cos(alpha) * cos(gamma) - sin(alpha) * sin(theta) * sin(gamma), -sin(alpha) * cos(theta), 2,\n\u002B    sin(alpha) * sin(gamma) - cos(alpha) * sin(theta) * cos(gamma),\n\u002B    cos(alpha) * sin(theta) * sin(gamma) \u002B sin(alpha) * cos(gamma), cos(alpha) * cos(theta), 3,\n\u002B    0, 0, 0, 1;\n \n   Eigen::Affine3d T(tm);\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "9abac34e6375c3dae0fd2bc9901dbc6a269b7d45",
    "RawMessage": "Updated performance QD section (#153)",
    "Changes": "diff --git rmw_implementation/QUALITY_DECLARATION.md rmw_implementation/QUALITY_DECLARATION.md\nindex c5e6150..9e98576 100644\n--- rmw_implementation/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_implementation/QUALITY_DECLARATION.md\n@@ -118,7 \u002B118,7 @@ A description of how coverage statistics are summarized from this page, can be f\n \n ### Performance [4.iv]\n \n-\u0060rmw_implementation\u0060 does not currently have performance tests.\n\u002BThe performance tests of \u0060rmw_implementation\u0060 are located in the [test/benchmark directory](https://github.com/ros2/rmw_implementation/tree/master/rmw_implementation/test/benchmark). The most recent test results can be found [here](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/).\n \n ### Linters and Static Analysis [4.v]\n \n@@ -195,7 \u002B195,7 @@ The chart below compares the requirements in the REP-2004 with the current state\n |4.ii| Public API tests | None |\n |4.iii.a| Using coverage | \u0393\u00A3\u00F4 |\n |4.iii.a| Coverage policy | \u0393\u00A3\u00F4 |\n-|4.iv.a| Performance tests (if applicable) | x |\n\u002B|4.iv.a| Performance tests (if applicable) | \u0393\u00A3\u00F4 |\n |4.iv.b| Performance tests policy| None |\n |4.v.a| Code style enforcement (linters)| \u0393\u00A3\u00F4 |\n |4.v.b| Use of static analysis tools | None |\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_logging",
    "SHA": "72f3e6a13c964c70c0d9e1c370273f929f74d7fc",
    "RawMessage": "Fix include order for cpplint (#84)",
    "Changes": "diff --git rcl_logging_interface/test/test_get_logging_directory.cpp rcl_logging_interface/test/test_get_logging_directory.cpp\nindex ea58092..971b020 100644\n--- rcl_logging_interface/test/test_get_logging_directory.cpp\n\u002B\u002B\u002B rcl_logging_interface/test/test_get_logging_directory.cpp\n@@ -12,16 \u002B12,17 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcpputils/env.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-\n #include \u003Ciostream\u003E\n #include \u003Cstring\u003E\n \n #include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcpputils/env.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B\n #include \u0022rcl_logging_interface/rcl_logging_interface.h\u0022\n \n // This is a helper class that resets an environment\ndiff --git rcl_logging_spdlog/src/rcl_logging_spdlog.cpp rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\nindex 5eccab3..2295b5f 100644\n--- rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\n\u002B\u002B\u002B rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\n@@ -12,13 \u002B12,6 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/logging.h\u003E\n-#include \u003Crcutils/process.h\u003E\n-#include \u003Crcutils/snprintf.h\u003E\n-#include \u003Crcutils/time.h\u003E\n-\n #include \u003Ccerrno\u003E\n #include \u003Ccinttypes\u003E\n #include \u003Cmemory\u003E\n@@ -26,6 \u002B19,13 @@\n #include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/logging.h\u0022\n\u002B#include \u0022rcutils/process.h\u0022\n\u002B#include \u0022rcutils/snprintf.h\u0022\n\u002B#include \u0022rcutils/time.h\u0022\n\u002B\n #include \u0022spdlog/spdlog.h\u0022\n #include \u0022spdlog/sinks/basic_file_sink.h\u0022\n \ndiff --git rcl_logging_spdlog/test/fixtures.hpp rcl_logging_spdlog/test/fixtures.hpp\nindex ecdc627..85697f9 100644\n--- rcl_logging_spdlog/test/fixtures.hpp\n\u002B\u002B\u002B rcl_logging_spdlog/test/fixtures.hpp\n@@ -15,13 \u002B15,6 @@\n #ifndef FIXTURES_HPP_\n #define FIXTURES_HPP_\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-#include \u003Crcutils/process.h\u003E\n-#include \u003Crcutils/types/string_array.h\u003E\n-\n #include \u003Climits.h\u003E\n #ifdef _WIN32\n # include \u003Cwindows.h\u003E  // MAX_PATH\n@@ -30,6 \u002B23,13 @@\n \n #include \u0022gtest/gtest.h\u0022\n \n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B#include \u0022rcutils/process.h\u0022\n\u002B#include \u0022rcutils/types/string_array.h\u0022\n\u002B\n #ifdef _WIN32\n #define popen _popen\n #define pclose _pclose\ndiff --git rcl_logging_spdlog/test/test_logging_interface.cpp rcl_logging_spdlog/test/test_logging_interface.cpp\nindex 8f97458..17be297 100644\n--- rcl_logging_spdlog/test/test_logging_interface.cpp\n\u002B\u002B\u002B rcl_logging_spdlog/test/test_logging_interface.cpp\n@@ -12,20 \u002B12,21 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcpputils/env.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-#include \u003Crcutils/logging.h\u003E\n-#include \u003Crcutils/testing/fault_injection.h\u003E\n-\n #include \u003Climits.h\u003E\n #include \u003Cfstream\u003E\n #include \u003Cstring\u003E\n \n-#include \u0022fixtures.hpp\u0022\n #include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcpputils/env.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B#include \u0022rcutils/logging.h\u0022\n\u002B#include \u0022rcutils/testing/fault_injection.h\u0022\n\u002B\n\u002B#include \u0022fixtures.hpp\u0022\n #include \u0022rcl_logging_interface/rcl_logging_interface.h\u0022\n \n const int logger_levels[] =\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "44419a00b0800861982a4e465756f74659b7e5f0",
    "RawMessage": "Add tests for RMW QoS to DDS attribute conversion. (#449)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/test/CMakeLists.txt rmw_fastrtps_shared_cpp/test/CMakeLists.txt\nindex 3db9b12..12054b5 100644\n--- rmw_fastrtps_shared_cpp/test/CMakeLists.txt\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/test/CMakeLists.txt\n@@ -7,6 \u002B7,11 @@ if(TARGET test_dds_attributes_to_rmw_qos)\n     target_link_libraries(test_dds_attributes_to_rmw_qos ${PROJECT_NAME})\n endif()\n \n\u002Bament_add_gtest(test_rmw_qos_to_dds_attributes test_rmw_qos_to_dds_attributes.cpp)\n\u002Bif(TARGET test_rmw_qos_to_dds_attributes)\n\u002B  target_link_libraries(test_rmw_qos_to_dds_attributes ${PROJECT_NAME})\n\u002Bendif()\n\u002B\n ament_add_gmock(test_security_logging test_security_logging.cpp)\n if(TARGET test_security_logging)\n     ament_target_dependencies(test_security_logging)\ndiff --git rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp\nnew file mode 100644\nindex 0000000..c0428a8\n--- /dev/null\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp\n@@ -0,0 \u002B1,171 @@\n\u002B// Copyright 2017 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Ctuple\u003E\n\u002B\n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022fastrtps/attributes/PublisherAttributes.h\u0022\n\u002B#include \u0022fastrtps/attributes/SubscriberAttributes.h\u0022\n\u002B\n\u002B#include \u0022rmw_fastrtps_shared_cpp/qos.hpp\u0022\n\u002B\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B\n\u002B\n\u002Busing eprosima::fastrtps::SubscriberAttributes;\n\u002B\n\u002Bclass GetDataReaderQoSTest : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n\u002B  SubscriberAttributes subscriber_attributes_{};\n\u002B};\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, test_unknown_history_policy_conversion_fails) {\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_reliability_policy_conversion_fails) {\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_durability_policy_conversion_fails) {\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_liveliness_policy_conversion_fails) {\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, nominal_conversion) {\n\u002B  qos_profile_.depth = 10u;\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n\u002B  qos_profile_.lifespan.sec = 0u;\n\u002B  qos_profile_.lifespan.nsec = 500000000u;\n\u002B  qos_profile_.deadline.sec = 0u;\n\u002B  qos_profile_.deadline.nsec = 100000000u;\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  qos_profile_.liveliness_lease_duration.sec = 10u;\n\u002B  qos_profile_.liveliness_lease_duration.nsec = 0u;\n\u002B\n\u002B  EXPECT_TRUE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n\u002B    subscriber_attributes_.qos.m_reliability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n\u002B    subscriber_attributes_.qos.m_durability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n\u002B    subscriber_attributes_.qos.m_liveliness.kind);\n\u002B  EXPECT_EQ(0, subscriber_attributes_.qos.m_lifespan.duration.seconds);\n\u002B  EXPECT_EQ(500000000u, subscriber_attributes_.qos.m_lifespan.duration.nanosec);\n\u002B  EXPECT_EQ(0, subscriber_attributes_.qos.m_deadline.period.seconds);\n\u002B  EXPECT_EQ(100000000u, subscriber_attributes_.qos.m_deadline.period.nanosec);\n\u002B  EXPECT_EQ(10, subscriber_attributes_.qos.m_liveliness.lease_duration.seconds);\n\u002B  EXPECT_EQ(0u, subscriber_attributes_.qos.m_liveliness.lease_duration.nanosec);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n\u002B    subscriber_attributes_.topic.historyQos.kind);\n\u002B  EXPECT_EQ(10, subscriber_attributes_.topic.historyQos.depth);\n\u002B}\n\u002B\n\u002Busing eprosima::fastrtps::PublisherAttributes;\n\u002B\n\u002Bclass GetDataWriterQoSTest : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n\u002B  PublisherAttributes publisher_attributes_{};\n\u002B};\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, test_unknown_history_policy_conversion_fails) {\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_reliability_policy_conversion_fails) {\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_durability_policy_conversion_fails) {\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_liveliness_policy_conversion_fails) {\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, nominal_conversion) {\n\u002B  qos_profile_.depth = 10u;\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n\u002B  qos_profile_.lifespan.sec = 0u;\n\u002B  qos_profile_.lifespan.nsec = 500000000u;\n\u002B  qos_profile_.deadline.sec = 0u;\n\u002B  qos_profile_.deadline.nsec = 100000000u;\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  qos_profile_.liveliness_lease_duration.sec = 10u;\n\u002B  qos_profile_.liveliness_lease_duration.nsec = 0u;\n\u002B\n\u002B  EXPECT_TRUE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n\u002B    publisher_attributes_.qos.m_reliability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n\u002B    publisher_attributes_.qos.m_durability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n\u002B    publisher_attributes_.qos.m_liveliness.kind);\n\u002B  EXPECT_EQ(0, publisher_attributes_.qos.m_lifespan.duration.seconds);\n\u002B  EXPECT_EQ(500000000u, publisher_attributes_.qos.m_lifespan.duration.nanosec);\n\u002B  EXPECT_EQ(0, publisher_attributes_.qos.m_deadline.period.seconds);\n\u002B  EXPECT_EQ(100000000u, publisher_attributes_.qos.m_deadline.period.nanosec);\n\u002B  EXPECT_EQ(10, publisher_attributes_.qos.m_liveliness.lease_duration.seconds);\n\u002B  EXPECT_EQ(0u, publisher_attributes_.qos.m_liveliness.lease_duration.nanosec);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n\u002B    publisher_attributes_.topic.historyQos.kind);\n\u002B  EXPECT_EQ(10, publisher_attributes_.topic.historyQos.depth);\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "b9cfc243bf018091b5c5bcb5585d19591daf4ae6",
    "RawMessage": "Remove unused internal prototypes (#699)",
    "Changes": "diff --git rcl/src/rcl/remap_impl.h rcl/src/rcl/remap_impl.h\nindex de8e835..2729b61 100644\n--- rcl/src/rcl/remap_impl.h\n\u002B\u002B\u002B rcl/src/rcl/remap_impl.h\n@@ -51,10 \u002B51,6 @@ typedef struct rcl_remap_impl_t\n   rcl_allocator_t allocator;\n } rcl_remap_impl_t;\n \n-/// Get an rcl_remap_t structure initialized with NULL.\n-rcl_remap_t\n-rcl_remap_get_zero_initialized();\n-\n /// Copy one remap structure into another.\n /**\n  * \u003Chr\u003E\n@@ -73,35 \u002B69,13 @@ rcl_remap_get_zero_initialized();\n  * \\return \u0060RCL_RET_BAD_ALLOC\u0060 if allocating memory failed, or\n  * \\return \u0060RCL_RET_ERROR\u0060 if an unspecified error occurs.\n  */\n-RCL_PUBLIC\n\u002BRCL_LOCAL\n RCL_WARN_UNUSED\n rcl_ret_t\n rcl_remap_copy(\n   const rcl_remap_t * rule,\n   rcl_remap_t * rule_out);\n \n-/// Reclaim resources used in an rcl_remap_t structure.\n-/**\n- * \u003Chr\u003E\n- * Attribute          | Adherence\n- * ------------------ | -------------\n- * Allocates Memory   | No\n- * Thread-Safe        | Yes\n- * Uses Atomics       | No\n- * Lock-Free          | Yes\n- *\n- * \\param[in] rule A rule to deallocate back to a zero initialized state.\n- * \\return \u0060RCL_RET_OK\u0060 if the structure was free\u0027d, or\n- * \\return \u0060RCL_RET_INVALID_ARGUMENT\u0060 if any arguments are invalid, or\n- * \\return \u0060RCL_RET_BAD_ALLOC\u0060 if allocating memory failed, or\n- * \\return \u0060RCL_RET_NODE_INVALID_NAME\u0060 if the name is invalid, or\n- * \\return \u0060RCL_RET_ERROR\u0060 if an unspecified error occurs.\n- */\n-RCL_WARN_UNUSED\n-rcl_ret_t\n-rcl_remap_fini(\n-  rcl_remap_t * rule);\n-\n #ifdef __cplusplus\n }\n #endif\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "9b9505af2bede4d10a5de27d56ee1b07776c9a96",
    "RawMessage": "Add quality declaration for rmw_cyclonedds_cpp (#335)",
    "Changes": "diff --git README.md README.md\nindex 1aa034b..ce3f8cc 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -69,3 \u002B69,7 @@ If building ROS 2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/ma\n     rosdep install --from src -i\n     colcon build\n     export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n\u002B\n\u002B## Quality Declaration\n\u002B\n\u002BThis package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./rmw_cyclonedds_cpp/QUALITY_DECLARATION.md) for more details.\ndiff --git rmw_cyclonedds_cpp/QUALITY_DECLARATION.md rmw_cyclonedds_cpp/QUALITY_DECLARATION.md\nnew file mode 100644\nindex 0000000..6f57c27\n--- /dev/null\n\u002B\u002B\u002B rmw_cyclonedds_cpp/QUALITY_DECLARATION.md\n@@ -0,0 \u002B1,210 @@\n\u002BThis document is a declaration of software quality for the \u0060rmw_cyclonedds_cpp\u0060 package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B# \u0060rmw_cyclonedds_cpp\u0060 Quality Declaration\n\u002B\n\u002BThe package \u0060rmw_cyclonedds_cpp\u0060 claims to be in the **Quality Level 4** category.\n\u002B\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B## Version Policy [1]\n\u002B\n\u002B### Version Scheme [1.i]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n\u002B\n\u002B### Version Stability [1.ii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 is not yet at a stable version, i.e. \u0060\u003C 1.0.0\u0060.\n\u002BThe current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n\u002B\n\u002B### Public API Declaration [1.iii]\n\u002B\n\u002BPublic API for \u0060rmw_cyclonedds_cpp\u0060 is declared through \u0060rmw\u0060.\n\u002B\n\u002B### API Stability Within a Released ROS Distribution [1.iv]/[1.vi]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n\u002B\n\u002B### ABI Stability Within a Released ROS Distribution [1.v]/[1.vi]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 contains C and C\u002B\u002B code and therefore must be concerned with ABI stability, and will maintain ABI stability within a ROS distribution.\n\u002B\n\u002B## Change Control Process [2]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n\u002B\n\u002B### Change Requests [2.i]\n\u002B\n\u002BThis package requires that all changes occur through a pull request.\n\u002B\n\u002B### Contributor Origin [2.ii]\n\u002B\n\u002BThis package uses DCO as its confirmation of contributor origin policy.\n\u002BMore information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002B### Peer Review Policy [2.iii]\n\u002B\n\u002BFollowing the recommended guidelines for ROS Core packages, all pull requests must have at least 1 peer review.\n\u002B\n\u002B### Continuous Integration [2.iv]\n\u002B\n\u002BAll pull request must pass CI on all [tier 1 platforms](https://www.ros.org/reps/rep-2000.html#support-tiers).\n\u002B\n\u002B### Documentation Policy [2.v]\n\u002B\n\u002BAll pull requests must resolve related documentation changes before merging.\n\u002B\n\u002B## Documentation [3]\n\u002B\n\u002B### Feature Documentation [3.i]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060\u0027s features are documented through \u0060rmw\u0060.\n\u002BIt has a [feature list](https://docs.ros2.org/latest/api/rmw/) and each item in the list links to the corresponding feature documentation.\n\u002BThere is documentation for all of the features, and new features require documentation before being added.\n\u002B\n\u002B### Public API Documentation [3.ii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060\u0027s API is declared and documented by \u0060rmw\u0060.\n\u002BIt has embedded API documentation and it is generated using doxygen and is hosted [alongside the feature documentation](https://docs.ros2.org/latest/api/rmw/).\n\u002BThere is documentation for all of the public API, and new additions to the public API require documentation before being added.\n\u002B\n\u002B### License [3.iii]\n\u002B\n\u002BThe license for \u0060rmw_cyclonedds_cpp\u0060 is Apache 2.0, and a summary is in each source file, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the [LICENSE](../LICENSE) file.\n\u002B\n\u002BThere is an automated test which runs a linter that ensures each file has a license statement.\n\u002B\n\u002BMost recent test results can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_cyclonedds_cpp/copyright/)\n\u002B\n\u002B### Copyright Statements [3.iv]\n\u002B\n\u002BThe copyright holders each provide a statement of copyright in each source code file in \u0060rmw_cyclonedds_cpp\u0060.\n\u002B\n\u002BThere is an automated test which runs a linter that ensures each file has at least one copyright statement.\n\u002B\n\u002BThe results of the test can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_cyclonedds_cpp/copyright/).\n\u002B\n\u002B## Testing [4]\n\u002B\n\u002B### Feature Testing [4.i]\n\u002B\n\u002BAll of \u0060rmw_cyclonedds_cpp\u0060\u0027s public features are ROS middleware features.\n\u002B\n\u002BUnit, integration, and system tests higher up in the stack, such as those found in [\u0060test_rmw_implementation\u0060](https://github.com/ros2/rmw_implementation/tree/master/test_rmw_implementation), [\u0060test_rclcpp\u0060](https://github.com/ros2/system_tests/tree/master/test_rclcpp), and [\u0060test_communication\u0060](https://github.com/ros2/system_tests/tree/master/test_communication) packages, provide feature coverage.\n\u002BNightly CI jobs in [\u0060ci.ros2.org\u0060](https://ci.ros2.org/) and [\u0060build.ros2.org\u0060](https://build.ros2.org/), where \u0060rmw_cyclonedds_cpp\u0060 is the default \u0060rmw\u0060 implementation, thoroughly exercise this middleware.\n\u002B\n\u002B### Public API Testing [4.ii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 implements the ROS middleware public API.\n\u002BUnit, integration, and system tests higher up in the stack, such as those found in [\u0060test_rmw_implementation\u0060](https://github.com/ros2/rmw_implementation/tree/master/test_rmw_implementation), [\u0060test_rclcpp\u0060](https://github.com/ros2/system_tests/tree/master/test_rclcpp), and [\u0060test_communication\u0060](https://github.com/ros2/system_tests/tree/master/test_communication) packages, ensure compliance with the ROS middleware API specification (see [\u0060rmw\u0060](https://github.com/ros2/rmw) package) and further extend coverage.\n\u002BNew additions or changes to this API require tests before being added.\n\u002B\n\u002B### Coverage [4.iii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use branch coverage instead of line coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- achieving and maintaining a reasonable branch line coverage (90-100%)\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_cyclonedds_rmw_cyclonedds_cpp_src/).\n\u002BA summary of how these statistics are calculated can be found in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n\u002B\n\u002BThis package claims to meet the coverage requirements for the current quality level, even though it doesn\u0027t have 95% line coverage.\n\u002B\n\u002B### Performance [4.iv]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 does not currently have performance tests.\n\u002B\n\u002B### Linters and Static Analysis [4.v]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 uses and passes all the standard linters and static analysis tools for a C\u002B\u002B package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n\u002B\n\u002BResults of the nightly linter tests can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_cyclonedds_cpp).\n\u002B\n\u002B## Dependencies [5]\n\u002B\n\u002B### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 has the following runtime ROS dependencies:\n\u002B* \u0060rcpputils\u0060: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n\u002B* \u0060rcutils\u0060: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n\u002B* \u0060rmw\u0060: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n\u002B* \u0060rmw_dds_common\u0060: [QUALITY DECLARATION](https://github.com/ros2/rmw_dds_common/blob/master/rmw_dds_common/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_runtime_c\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_runtime_c/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_runtime_cpp\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_runtime_cpp/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_typesupport_introspection_c\u0060: no quality declaration\n\u002B* \u0060rosidl_typesupport_introspection_cpp\u0060: no quality declaration\n\u002B* \u0060tracetools\u0060: [QUALITY DECLARATION](https://gitlab.com/ros-tracing/ros2_tracing/-/blob/master/tracetools/QUALITY_DECLARATION.md)\n\u002B\n\u002BIt has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n\u002BIt also has several test dependencies, which do not affect the resulting quality of the package, because they are only used to build and run the test code.\n\u002B\n\u002B### Direct Runtime Non-ROS Dependencies [5.iii]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 has the following runtime non-ROS dependencies:\n\u002B* \u0060cyclonedds\u0060: Eclipse Cyclone DDS claims to be Quality Level 3. For more information, please refer to its [quality declaration document](../CYCLONEDDS_QUALITY_DECLARATION.md).\n\u002B\n\u002B## Platform Support [6]\n\u002B\n\u002B\u0060rmw_cyclonedds_cpp\u0060 supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers), and tests each change against all of them.\n\u002B\n\u002BCurrently nightly results can be seen here:\n\u002B* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rmw_cyclonedds_cpp/)\n\u002B* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_cyclonedds_cpp/)\n\u002B* [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rmw_cyclonedds_cpp/)\n\u002B* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rmw_cyclonedds_cpp/)\n\u002B\n\u002B## Security [7]\n\u002B\n\u002B### Vulnerability Disclosure Policy [7.i]\n\u002B\n\u002BThis package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n\u002B\n\u002B# Current status Summary\n\u002B\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the \u0060rmw_cyclonedds_cpp\u0060 package.\n\u002B\n\u002B|Number| Requirement| Current state |\n\u002B|--|--|--|\n\u002B|1| **Version policy** |---|\n\u002B|1.i|Version Policy available | \u0393\u00A3\u00F4 |\n\u002B|1.ii|Stable version | x |\n\u002B|1.iii|Declared public API| \u0393\u00A3\u00F4 |\n\u002B|1.iv|API stability policy| \u0393\u00A3\u00F4 |\n\u002B|1.v|ABI stability policy| \u0393\u00A3\u00F4 |\n\u002B|1.vi_|API/ABI stable within ros distribution| \u0393\u00A3\u00F4 |\n\u002B|2| **Change control process** |---|\n\u002B|2.i| All changes occur on change request | \u0393\u00A3\u00F4 |\n\u002B|2.ii| Contributor origin (DCO, CLA, etc) | \u0393\u00A3\u00F4 |\n\u002B|2.iii| Peer review policy | \u0393\u00A3\u00F4 |\n\u002B|2.iv| CI policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|2.v| Documentation policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|3| **Documentation** | --- |\n\u002B|3.i| Per feature documentation | \u0393\u00A3\u00F4 |\n\u002B|3.ii| Per public API item documentation | \u0393\u00A3\u00F4 |\n\u002B|3.iii| Declared License(s) | \u0393\u00A3\u00F4 |\n\u002B|3.iv| Copyright in source files| \u0393\u00A3\u00F4 |\n\u002B|3.v.a| Quality declaration linked to README | \u0393\u00A3\u00F4 |\n\u002B|3.v.b| Centralized declaration available for peer review | \u0393\u00A3\u00F4 |\n\u002B|4| **Testing** | --- |\n\u002B|4.i| Feature items tests | \u0393\u00A3\u00F4 |\n\u002B|4.ii| Public API tests | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Using coverage | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Coverage policy | \u0393\u00A3\u00F4 |\n\u002B|4.iv.a| Performance tests (if applicable) | \u0393\u00FF\u00F4 |\n\u002B|4.iv.b| Performance tests policy| \u0393\u00A3\u00F4 |\n\u002B|4.v.a| Code style enforcement (linters)| \u0393\u00A3\u00F4 |\n\u002B|4.v.b| Use of static analysis tools | \u0393\u00A3\u00F4 |\n\u002B|5| **Dependencies** | --- |\n\u002B|5.i| Must not have ROS lower level dependencies | x |\n\u002B|5.ii| Optional ROS lower level dependencies| \u0393\u00A3\u00F4 |\n\u002B|5.iii| Justifies quality use of non-ROS dependencies | \u0393\u00A3\u00F4 |\n\u002B|6| **Platform support** | --- |\n\u002B|6.i| Support targets Tier1 ROS platforms| \u0393\u00A3\u00F4 |\n\u002B|7| **Security** | --- |\n\u002B|7.i| Vulnerability Disclosure Policy | \u0393\u00A3\u00F4 |\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "5af95c7095fa87466ef0a2e3000bec8956374dab",
    "RawMessage": "Ensure compliant matched pub/sub count API. (#424)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/rmw_publisher.cpp rmw_fastrtps_cpp/src/rmw_publisher.cpp\nindex 2c3b606..4f5fc61 100644\n--- rmw_fastrtps_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_publisher.cpp\n@@ -123,6 \u002B123,14 @@ rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_count_matched_subscriptions(\n     publisher, subscription_count);\n }\ndiff --git rmw_fastrtps_cpp/src/rmw_subscription.cpp rmw_fastrtps_cpp/src/rmw_subscription.cpp\nindex 712f6f9..a27f326 100644\n--- rmw_fastrtps_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_subscription.cpp\n@@ -119,6 \u002B119,14 @@ rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_count_matched_publishers(\n     subscription, publisher_count);\n }\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\nindex 52ce147..baaedcb 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n@@ -127,6 \u002B127,14 @@ rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_count_matched_subscriptions(\n     publisher, subscription_count);\n }\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\nindex fad3f4b..00873ce 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n@@ -122,6 \u002B122,14 @@ rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_count_matched_publishers(\n     subscription, publisher_count);\n }\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\nindex afa4b2e..fb8cd2a 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n@@ -87,13 \u002B87,9 @@ __rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n-\n   auto info = static_cast\u003CCustomPublisherInfo *\u003E(publisher-\u003Edata);\n-  if (info != nullptr) {\n-    *subscription_count = info-\u003Elistener_-\u003EsubscriptionCount();\n-  }\n\u002B\n\u002B  *subscription_count = info-\u003Elistener_-\u003EsubscriptionCount();\n \n   return RMW_RET_OK;\n }\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\nindex 95c4252..4ce18ac 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n@@ -85,13 \u002B85,10 @@ __rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n-\n   auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n-  if (info != nullptr) {\n-    *publisher_count = info-\u003Elistener_-\u003EpublisherCount();\n-  }\n\u002B\n\u002B  *publisher_count = info-\u003Elistener_-\u003EpublisherCount();\n\u002B\n   return RMW_RET_OK;\n }\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "a59841594a1f90a646cbf93c6dc43530cf6c7b97",
    "RawMessage": "Filter topics in drop down menu (#591)",
    "Changes": "diff --git README.md README.md\nindex 253dc7e9..c88b6ab8 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -50,7 \u002B50,6 @@ These features have not been ported to \u0060ros2/rviz\u0060 yet.\n | Effort        |\n \n Other features:\n-- Filtering of Topic lists by topic type\n - Image transport features\n - Stereo\n \ndiff --git rviz_common/include/rviz_common/message_filter_display.hpp rviz_common/include/rviz_common/message_filter_display.hpp\nindex bbb79efa..d2da7a6c 100644\n--- rviz_common/include/rviz_common/message_filter_display.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/message_filter_display.hpp\n@@ -59,11 \u002B59,7 @@ public:\n   : tf_filter_(nullptr),\n     messages_received_(0)\n   {\n-    // TODO(Martin-Idel-SI): We need a way to extract the MessageType from the template to set a\n-    // correct string. Previously was:\n-    // QString message_type =\n-    //   QString::fromStdString(message_filters::message_traits::datatype\u003CMessageType\u003E());\n-    QString message_type = QString::fromStdString(\u0022\u0022);\n\u002B    QString message_type = rosidl_generator_traits::name\u003CMessageType\u003E();\n     topic_property_-\u003EsetMessageType(message_type);\n     topic_property_-\u003EsetDescription(message_type \u002B \u0022 topic to subscribe to.\u0022);\n   }\ndiff --git rviz_common/src/rviz_common/properties/ros_topic_property.cpp rviz_common/src/rviz_common/properties/ros_topic_property.cpp\nindex 2699f618..ce5deefc 100644\n--- rviz_common/src/rviz_common/properties/ros_topic_property.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/properties/ros_topic_property.cpp\n@@ -80,10 \u002B80,7 @@ void RosTopicProperty::fillTopicList()\n   for (const auto \u0026 topic : published_topics) {\n     // Only add topics whose type matches.\n     for (const auto \u0026 type : topic.second) {\n-      // TODO(Martin-Idel-SI): revisit after message_traits become available.\n-      // We only want to show the types of the topic we subscribe to, however, currently we can\u0027t\n-      // get the type, so std_message_type will always be empty --\u003E show all topics instead\n-      if (std_message_type.empty() || type == std_message_type) {\n\u002B      if (type == std_message_type) {\n         addOptionStd(topic.first);\n       }\n     }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "3270aad95eda0bc5ac7a3a79d4b1e07273154340",
    "RawMessage": "add operator!= for duration (#1236)",
    "Changes": "diff --git rclcpp/include/rclcpp/duration.hpp rclcpp/include/rclcpp/duration.hpp\nindex d5f8401c..49125ec7 100644\n--- rclcpp/include/rclcpp/duration.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/duration.hpp\n@@ -77,6 \u002B77,9 @@ public:\n   bool\n   operator==(const rclcpp::Duration \u0026 rhs) const;\n \n\u002B  bool\n\u002B  operator!=(const rclcpp::Duration \u0026 rhs) const;\n\u002B\n   bool\n   operator\u003C(const rclcpp::Duration \u0026 rhs) const;\n \ndiff --git rclcpp/src/rclcpp/duration.cpp rclcpp/src/rclcpp/duration.cpp\nindex cd335e68..47faa0d6 100644\n--- rclcpp/src/rclcpp/duration.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/duration.cpp\n@@ -94,6 \u002B94,12 @@ Duration::operator==(const rclcpp::Duration \u0026 rhs) const\n   return rcl_duration_.nanoseconds == rhs.rcl_duration_.nanoseconds;\n }\n \n\u002Bbool\n\u002BDuration::operator!=(const rclcpp::Duration \u0026 rhs) const\n\u002B{\n\u002B  return rcl_duration_.nanoseconds != rhs.rcl_duration_.nanoseconds;\n\u002B}\n\u002B\n bool\n Duration::operator\u003C(const rclcpp::Duration \u0026 rhs) const\n {\ndiff --git rclcpp/test/rclcpp/test_duration.cpp rclcpp/test/rclcpp/test_duration.cpp\nindex 4217005b..e09295a5 100644\n--- rclcpp/test/rclcpp/test_duration.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_duration.cpp\n@@ -41,6 \u002B41,7 @@ TEST_F(TestDuration, operators) {\n   EXPECT_TRUE(old \u003C= young);\n   EXPECT_TRUE(young \u003E= old);\n   EXPECT_FALSE(young == old);\n\u002B  EXPECT_TRUE(young != old);\n \n   rclcpp::Duration add = old \u002B young;\n   EXPECT_EQ(add.nanoseconds(), old.nanoseconds() \u002B young.nanoseconds());\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "438822fe13b8d13033fc6d9acf30894ea365bd75",
    "RawMessage": "Revert \u0022Add get_logging_directory method to rclcpp::Logger (#1509)\u0022 (#1511)",
    "Changes": "diff --git rclcpp/include/rclcpp/logger.hpp rclcpp/include/rclcpp/logger.hpp\nindex ed022c47..bca473c4 100644\n--- rclcpp/include/rclcpp/logger.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/logger.hpp\n@@ -22,12 \u002B22,6 @@\n \n #include \u0022rcl/node.h\u0022\n #include \u0022rcutils/logging.h\u0022\n-#ifdef _WIN32\n-# ifndef NOMINMAX\n-#   define NOMINMAX\n-# endif\n-#endif\n-#include \u0022rcpputils/filesystem_helper.hpp\u0022\n \n /**\n  * \\def RCLCPP_LOGGING_ENABLED\n@@ -81,18 \u002B75,6 @@ RCLCPP_PUBLIC\n Logger\n get_node_logger(const rcl_node_t * node);\n \n-/// Get the current logging directory.\n-/**\n- * For more details of how the logging directory is determined,\n- * see \\ref rcl_logging_get_logging_directory.\n- *\n- * \\returns the logging directory being used.\n- * \\throws rclcpp::exceptions::RCLError if an unexpected error occurs.\n- */\n-RCLCPP_PUBLIC\n-rcpputils::fs::path\n-get_logging_directory();\n-\n class Logger\n {\n public:\ndiff --git rclcpp/src/rclcpp/logger.cpp rclcpp/src/rclcpp/logger.cpp\nindex b58edd4c..af65b846 100644\n--- rclcpp/src/rclcpp/logger.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/logger.cpp\n@@ -14,8 \u002B14,6 @@\n \n #include \u003Cstring\u003E\n \n-#include \u0022rcl_logging_interface/rcl_logging_interface.h\u0022\n-\n #include \u0022rclcpp/exceptions.hpp\u0022\n #include \u0022rclcpp/logger.hpp\u0022\n #include \u0022rclcpp/logging.hpp\u0022\n@@ -48,20 \u002B46,6 @@ get_node_logger(const rcl_node_t * node)\n   return rclcpp::get_logger(logger_name);\n }\n \n-rcpputils::fs::path\n-get_logging_directory()\n-{\n-  char * log_dir = NULL;\n-  auto allocator = rcutils_get_default_allocator();\n-  rcl_logging_ret_t ret = rcl_logging_get_logging_directory(allocator, \u0026log_dir);\n-  if (RCL_LOGGING_RET_OK != ret) {\n-    rclcpp::exceptions::throw_from_rcl_error(ret);\n-  }\n-  std::string path{log_dir};\n-  allocator.deallocate(log_dir, allocator.state);\n-  return path;\n-}\n-\n void\n Logger::set_level(Level level)\n {\ndiff --git rclcpp/test/rclcpp/test_logger.cpp rclcpp/test/rclcpp/test_logger.cpp\nindex 1869b8f4..b83a2d40 100644\n--- rclcpp/test/rclcpp/test_logger.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_logger.cpp\n@@ -17,8 \u002B17,6 @@\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n \n-#include \u0022rcutils/env.h\u0022\n-\n #include \u0022rclcpp/logger.hpp\u0022\n #include \u0022rclcpp/logging.hpp\u0022\n #include \u0022rclcpp/node.hpp\u0022\n@@ -159,22 \u002B157,3 @@ TEST(TestLogger, set_level) {\n   rcutils_logging_set_output_handler(previous_output_handler);\n   EXPECT_EQ(RCUTILS_RET_OK, rcutils_logging_shutdown());\n }\n-\n-TEST(TestLogger, get_logging_directory) {\n-  ASSERT_EQ(true, rcutils_set_env(\u0022HOME\u0022, \u0022/fake_home_dir\u0022));\n-  ASSERT_EQ(true, rcutils_set_env(\u0022USERPROFILE\u0022, nullptr));\n-  ASSERT_EQ(true, rcutils_set_env(\u0022ROS_LOG_DIR\u0022, nullptr));\n-  ASSERT_EQ(true, rcutils_set_env(\u0022ROS_HOME\u0022, nullptr));\n-\n-  auto path = rclcpp::get_logging_directory();\n-  auto expected_path = rcpputils::fs::path{\u0022/fake_home_dir\u0022} / \u0022.ros\u0022 / \u0022log\u0022;\n-\n-  // TODO(ivanpauno): Add operator== to rcpputils::fs::path\n-  auto it = path.cbegin();\n-  auto eit = expected_path.cbegin();\n-  for (; it != path.cend() \u0026\u0026 eit != expected_path.cend(); \u002B\u002Bit, \u002B\u002Beit) {\n-    EXPECT_EQ(*eit, *it);\n-  }\n-  EXPECT_EQ(it, path.cend());\n-  EXPECT_EQ(eit, expected_path.cend());\n-}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclc",
    "SHA": "8e8a2d9b6b56e232f8b2cf524d11d804ae3a8b7c",
    "RawMessage": "updated table of bloom releases (removed dashing, inserted galactic) (#147)",
    "Changes": "diff --git README.md README.md\nindex ae8f134..a2b3130 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -54,19 \u002B54,25 @@ Please notice the following issues/limitations:\n \n Bloom release status of all packages in repository [github.com/ros2/rclc/](https://github.com/ros2/rclc) for different architectures and releases.\n \n-|Package | Release | amd64 | arm64 | armhf |\n-|:--     |  :--    |  :--  |  :--  | :--   |\n-| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Dashing | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dpr__rclc__ubuntu_bionic_amd64)](https://build.ros2.org/job/Dpr__rclc__ubuntu_bionic_amd64/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc__ubuntu_bionic_arm64__binary)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc__ubuntu_bionic_arm64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc__ubuntu_bionic_armhf__binary/)|\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | |\n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | |\n-|     |     |   |   |    |\n-| [rclc_examples](https://github.com/ros2/rclc/tree/master/rclc_examples) |  Dashing | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_uB64__rclc_examples__ubuntu_bionic_amd64__binary)](https://build.ros2.org/job/Dbin_uB64__rclc_examples__ubuntu_bionic_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc_examples__ubuntu_bionic_arm64__binary\u0026build=8)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc_examples__ubuntu_bionic_arm64__binary/8/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc_examples__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc_examples__ubuntu_bionic_armhf__binary/) |\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | |\n-| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | |\n-|     |     |   |   |    |\n-| [rclc_lifecycle](https://github.com/ros2/rclc/tree/master/rclc_lifecycle) | Dashing |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary)](https://build.ros2.org/job/Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary/) |\n-| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n-| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n\u002B|Package | Release | amd64 | arm64 | \n\u002B|:--     |  :--    |  :--  |  :--  | \n\u002B| [rclc](https://github.com/ros2/rclc/tree/master/rclc) | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Fpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n\u002B| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Gpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) | \n\u002B| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rpr__rclc__ubuntu_focal_amd64)](https://build.ros2.org/job/Rpr__rclc__ubuntu_focal_amd64/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc__ubuntu_focal_arm64__binary/) |\n\u002B|     |     |   |   |    \n\u002B| [rclc_examples](https://github.com/ros2/rclc/tree/master/rclc_examples)  \n\u002B| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n\u002B| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n\u002B| | Rolling| [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_examples__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_examples__ubuntu_focal_arm64__binary/) | \n\u002B|     |     |   |   |    \n\u002B| [rclc_lifecycle](https://github.com/ros2/rclc/tree/master/rclc_lifecycle) \n\u002B| | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | \n\u002B| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) |\n\u002B| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | \n\u002B|     |     |   |   |    \n\u002B| [rclc_parameter](https://github.com/ros2/rclc/tree/master/rclc_parameter) \n\u002B| | Galactic | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Gbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary/) |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Gbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary/) |\n\u002B| | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_parameter__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_parameter__ubuntu_focal_arm64__binary/)\n \n ## Code coverage\n The code coverage is tested with every commit, pull request. Results are available at [codecov](https://app.codecov.io/gh/ros2/rclc/branch/master/).\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "d7b4688743a99063e444f216f30c462fb03369b3",
    "RawMessage": "Fix Enum not being comparable with ints in get_parameter_types service",
    "Changes": "diff --git rclpy/rclpy/parameter_service.py rclpy/rclpy/parameter_service.py\nindex 936779c..cc18581 100644\n--- rclpy/rclpy/parameter_service.py\n\u002B\u002B\u002B rclpy/rclpy/parameter_service.py\n@@ -85,7 \u002B85,7 @@ class ParameterService:\n     def _get_parameter_types_callback(self, request, response):\n         node = self._get_node()\n         for name in request.names:\n-            response.types.append(node.get_parameter_or(name).type_)\n\u002B            response.types.append(node.get_parameter_or(name).type_.value)\n         return response\n \n     def _list_parameters_callback(self, request, response):\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "9696867179460b68ee90292f4ad89207280a4798",
    "RawMessage": "Revert \u0022Support loading meshes other than .mesh and .stl with package URIs (#610)\u0022 (#638)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/mesh_loader.cpp rviz_rendering/src/rviz_rendering/mesh_loader.cpp\nindex f98b4943..55ebddc2 100644\n--- rviz_rendering/src/rviz_rendering/mesh_loader.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/mesh_loader.cpp\n@@ -94,14 \u002B94,13 @@ Ogre::MeshPtr loadMeshFromResource(const std::string \u0026 resource_path)\n   } else {\n     QFileInfo model_path(QString::fromStdString(resource_path));\n     std::string ext = model_path.completeSuffix().toStdString();\n\u002B    if (ext == \u0022mesh\u0022 || ext == \u0022MESH\u0022) {\n\u002B      auto res = getResource(resource_path);\n \n-    auto res = getResource(resource_path);\n-\n-    if (res.size == 0) {\n-      return Ogre::MeshPtr();\n-    }\n\u002B      if (res.size == 0) {\n\u002B        return Ogre::MeshPtr();\n\u002B      }\n \n-    if (ext == \u0022mesh\u0022 || ext == \u0022MESH\u0022) {\n       Ogre::MeshSerializer ser;\n       Ogre::DataStreamPtr stream(new Ogre::MemoryDataStream(res.data.get(), res.size));\n       Ogre::MeshPtr mesh = Ogre::MeshManager::getSingleton().createManual(\n@@ -110,6 \u002B109,12 @@ Ogre::MeshPtr loadMeshFromResource(const std::string \u0026 resource_path)\n \n       return mesh;\n     } else if (ext == \u0022stl\u0022 || ext == \u0022STL\u0022 || ext == \u0022stlb\u0022 || ext == \u0022STLB\u0022) {\n\u002B      auto res = getResource(resource_path);\n\u002B\n\u002B      if (res.size == 0) {\n\u002B        return Ogre::MeshPtr();\n\u002B      }\n\u002B\n       STLLoader stl_loader;\n       if (!stl_loader.load(res.data.get(), res.size, resource_path)) {\n         RVIZ_RENDERING_LOG_ERROR_STREAM(\u0022Failed to load file [\u0022 \u003C\u003C resource_path.c_str() \u003C\u003C \u0022]\u0022);\n@@ -120,7 \u002B125,7 @@ Ogre::MeshPtr loadMeshFromResource(const std::string \u0026 resource_path)\n     } else {\n       AssimpLoader assimp_loader;\n \n-      const aiScene * scene = assimp_loader.getScene(static_cast\u003Cvoid *\u003E(res.data.get()), res.size);\n\u002B      const aiScene * scene = assimp_loader.getScene(resource_path);\n       if (!scene) {\n         RVIZ_RENDERING_LOG_ERROR_STREAM(\n           \u0022Could not load resource [\u0022 \u003C\u003C resource_path.c_str() \u003C\u003C \u0022]: \u0022 \u003C\u003C\ndiff --git rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\nindex b8e6bcc8..63518c44 100644\n--- rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\n@@ -228,10 \u002B228,10 @@ Ogre::MeshPtr AssimpLoader::meshFromAssimpScene(const std::string \u0026 name, const\n   return mesh;\n }\n \n-const aiScene * AssimpLoader::getScene(void * buffer, size_t size)\n\u002Bconst aiScene * AssimpLoader::getScene(const std::string \u0026 resource_path)\n {\n-  return importer_-\u003EReadFileFromMemory(\n-    buffer, size,\n\u002B  return importer_-\u003EReadFile(\n\u002B    resource_path,\n     aiProcess_SortByPType | aiProcess_GenNormals | aiProcess_Triangulate |\n     aiProcess_GenUVCoords | aiProcess_FlipUVs);\n }\ndiff --git rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.hpp rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.hpp\nindex c3e85283..34adb38b 100644\n--- rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.hpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.hpp\n@@ -62,7 \u002B62,7 @@ class AssimpLoader\n public:\n   AssimpLoader();\n   Ogre::MeshPtr meshFromAssimpScene(const std::string \u0026 name, const aiScene * scene);\n-  const aiScene * getScene(void * buffer, size_t size);\n\u002B  const aiScene * getScene(const std::string \u0026 resource_path);\n   std::string getErrorMessage();\n \n private:\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "b812790ee301d9aa536c79b9636736471701d1c3",
    "RawMessage": "Fix a format-security warning when building with clang (#2171)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_rosout_subscription.cpp rclcpp/test/rclcpp/test_rosout_subscription.cpp\nindex ea761fdc..c5f00bb2 100644\n--- rclcpp/test/rclcpp/test_rosout_subscription.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_rosout_subscription.cpp\n@@ -70,7 \u002B70,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_getchild) {\n     // before calling get_child of Logger\n     {\n       RCLCPP_INFO(\n-        rclcpp::get_logger(logger_name), this-\u003Erosout_msg_data.c_str());\n\u002B        rclcpp::get_logger(logger_name), \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n       auto future = received_msg_promise.get_future();\n       auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n       ASSERT_EQ(rclcpp::FutureReturnCode::TIMEOUT, return_code);\n@@ -83,7 \u002B83,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_getchild) {\n     // after calling get_child of Logger\n     // 1. use child_logger directly\n     {\n-      RCLCPP_INFO(child_logger, this-\u003Erosout_msg_data.c_str());\n\u002B      RCLCPP_INFO(child_logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n       auto future = received_msg_promise.get_future();\n       auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n       ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n@@ -93,7 \u002B93,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_getchild) {\n \n     // 2. use rclcpp::get_logger\n     {\n-      RCLCPP_INFO(rclcpp::get_logger(logger_name), this-\u003Erosout_msg_data.c_str());\n\u002B      RCLCPP_INFO(rclcpp::get_logger(logger_name), \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n       auto future = received_msg_promise.get_future();\n       auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n       ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n@@ -104,7 \u002B104,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_getchild) {\n \n   // \u0060child_logger\u0060 is end of life, there is no sublogger\n   {\n-    RCLCPP_INFO(rclcpp::get_logger(logger_name), this-\u003Erosout_msg_data.c_str());\n\u002B    RCLCPP_INFO(rclcpp::get_logger(logger_name), \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n     auto future = received_msg_promise.get_future();\n     auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n     ASSERT_EQ(rclcpp::FutureReturnCode::TIMEOUT, return_code);\n@@ -119,7 \u002B119,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_parent_log) {\n \n   rclcpp::Logger logger = this-\u003Enode-\u003Eget_logger();\n   ASSERT_EQ(logger.get_name(), logger_name);\n-  RCLCPP_INFO(logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   auto future = received_msg_promise.get_future();\n   auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n@@ -133,14 \u002B133,14 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_child_log) {\n   this-\u003Erosout_msg_name = logger_name;\n \n   rclcpp::Logger logger = this-\u003Enode-\u003Eget_logger();\n-  RCLCPP_INFO(logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   auto future = received_msg_promise.get_future();\n   auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::TIMEOUT, return_code);\n   received_msg_promise = {};\n \n   logger = this-\u003Enode-\u003Eget_logger().get_child(\u0022child1\u0022);\n-  RCLCPP_INFO(logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   future = received_msg_promise.get_future();\n   return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n@@ -148,14 \u002B148,14 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_child_log) {\n   received_msg_promise = {};\n \n   logger = this-\u003Enode-\u003Eget_logger().get_child(\u0022child2\u0022);\n-  RCLCPP_INFO(logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   future = received_msg_promise.get_future();\n   return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::TIMEOUT, return_code);\n   received_msg_promise = {};\n \n   this-\u003Erosout_msg_name = \u0022ns.test_rosout_subscription.child2\u0022;\n-  RCLCPP_INFO(logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   future = received_msg_promise.get_future();\n   return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n@@ -171,7 \u002B171,7 @@ TEST_F(TestRosoutSubscription, test_rosoutsubscription_getchild_hierarchy) {\n   rclcpp::Logger grandchild_logger =\n     this-\u003Enode-\u003Eget_logger().get_child(\u0022child\u0022).get_child(\u0022grandchild\u0022);\n   ASSERT_EQ(grandchild_logger.get_name(), logger_name);\n-  RCLCPP_INFO(grandchild_logger, this-\u003Erosout_msg_data.c_str());\n\u002B  RCLCPP_INFO(grandchild_logger, \u0022%s\u0022, this-\u003Erosout_msg_data.c_str());\n   auto future = received_msg_promise.get_future();\n   auto return_code = rclcpp::spin_until_future_complete(this-\u003Enode, future, 3s);\n   ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "8e508d01789803334dfcd59ba277cb49c0ea4219",
    "RawMessage": "Adding date-time to frames filename (#454)",
    "Changes": "diff --git tf2_tools/tf2_tools/view_frames.py tf2_tools/tf2_tools/view_frames.py\nindex b7f7e23b..c478cd60 100755\n--- tf2_tools/tf2_tools/view_frames.py\n\u002B\u002B\u002B tf2_tools/tf2_tools/view_frames.py\n@@ -49,6 \u002B49,7 @@ def main():\n     parser.add_argument(\n         \u0027--wait-time\u0027, \u0027-t\u0027, type=float, default=5.0,\n         help=\u0027Listen to the /tf topic for this many seconds before rendering the frame tree\u0027)\n\u002B    parser.add_argument(\u0027-o\u0027,\u0027--output\u0027, help=\u0027Output filename\u0027)\n     parsed_args = parser.parse_args(args=args_without_ros[1:])\n \n     node = rclpy.create_node(\u0027view_frames\u0027)\n@@ -85,9 \u002B86,20 @@ def main():\n         node.get_logger().info(\n             \u0027Result:\u0027\u002B str(result) )\n         data = yaml.safe_load(result.frame_yaml)\n-        with open(\u0027frames.gv\u0027, \u0027w\u0027) as f:\n-           f.write(generate_dot(data, node.get_clock().now().seconds_nanoseconds()))\n-        subprocess.Popen(\u0027dot -Tpdf frames.gv -o frames.pdf\u0027.split(\u0027 \u0027)).communicate()\n\u002B        \n\u002B        if parsed_args.output is not None:\n\u002B            frames_gv = \u0027{:s}.gv\u0027.format(parsed_args.output)\n\u002B            frames_pdf = \u0027{:s}.pdf\u0027.format(parsed_args.output)\n\u002B        else:\n\u002B            datetime = time.strftime(\u0027%Y-%m-%d_%H.%M.%S\u0027)\n\u002B            frames_gv = \u0027frames_{:s}.gv\u0027.format(datetime)\n\u002B            frames_pdf = \u0027frames_{:s}.pdf\u0027.format(datetime)\n\u002B        \n\u002B        with open(frames_gv, \u0027w\u0027) as f:\n\u002B            f.write(generate_dot(data, node.get_clock().now().seconds_nanoseconds()))\n\u002B        \n\u002B        cmd = [\u0027dot\u0027, \u0027-Tpdf\u0027, frames_gv, \u0027-o\u0027, frames_pdf]\n\u002B        subprocess.Popen(cmd).communicate()\n     finally:\n         cli.destroy()\n         node.destroy_node()\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclc",
    "SHA": "b4e3b9c4f6456b4cdf957296a1ad27c842bf91da",
    "RawMessage": "updated ros-tooling versions (#407)",
    "Changes": "diff --git .github/workflows/ci.yml .github/workflows/ci.yml\nindex 2adff39..b01cdcf 100644\n--- .github/workflows/ci.yml\n\u002B\u002B\u002B .github/workflows/ci.yml\n@@ -24,7 \u002B24,7 @@ jobs:\n       image: ${{ matrix.docker_image }}\n     steps:\n     - uses: actions/checkout@v3\n-    - uses: ros-tooling/setup-ros@0.6.3\n\u002B    - uses: ros-tooling/setup-ros@0.7.9\n       with:\n         use-ros2-testing: true\n         required-ros-distributions: ${{ matrix.ros_distribution }}\n@@ -35,7 \u002B35,7 @@ jobs:\n         apt-get install ros-${{ matrix.ros_distribution }}-rclcpp-action\n         apt-get install ros-${{ matrix.ros_distribution }}-mimick-vendor\n         apt-get -y install ros-${{ matrix.ros_distribution }}-performance-test-fixture\n-    - uses : ros-tooling/action-ros-ci@0.3.5\n\u002B    - uses : ros-tooling/action-ros-ci@0.3.13\n       with:\n         package-name: \u0022rclc rclc_examples rclc_lifecycle rclc_parameter\u0022\n         target-ros2-distro: ${{ matrix.ros_distribution }}\ndiff --git rclc/test/rclc/test_action_client.cpp rclc/test/rclc/test_action_client.cpp\nindex a28926c..e8272f4 100644\n--- rclc/test/rclc/test_action_client.cpp\n\u002B\u002B\u002B rclc/test/rclc/test_action_client.cpp\n@@ -195,7 \u002B195,7 @@ public:\n \n     handle_feedback =\n       [\u0026](rclc_action_goal_handle_t * /* goal_handle */, void * /* ros_feedback */,\n-        void * /* context */) {};\n\u002B      void * /* context */) {};\n \n     // Init RCLCPP\n     using namespace std::placeholders;\n@@ -352,7 \u002B352,7 @@ TEST_F(ActionClientTest, goal_accept) {\n \n   // Prepare RCLCPP\n   server_handle_goal = [ = ](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n     };\n@@ -381,7 \u002B381,7 @@ TEST_F(ActionClientTest, goal_reject) {\n \n   // Prepare RCLCPP\n   server_handle_goal = [ = ](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::REJECT;\n     };\n@@ -414,7 \u002B414,7 @@ TEST_F(ActionClientTest, goal_accept_feedback_and_result) {\n   // Prepare RCLCPP\n \n   server_handle_goal = [\u0026](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n     };\n@@ -467,7 \u002B467,7 @@ TEST_F(ActionClientTest, goal_accept_feedback_and_result) {\n   bool goal_result_received = false;\n   handle_result =\n     [\u0026](rclc_action_goal_handle_t * /* goal_handle */, void * ros_result_response,\n-      void * /* context */) {\n\u002B    void * /* context */) {\n       goal_result_received = true;\n \n       example_interfaces__action__Fibonacci_GetResult_Response * result =\n@@ -499,7 \u002B499,7 @@ TEST_F(ActionClientTest, goal_accept_feedback_and_abort) {\n   // Prepare RCLCPP\n \n   server_handle_goal = [\u0026](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n     };\n@@ -552,7 \u002B552,7 @@ TEST_F(ActionClientTest, goal_accept_feedback_and_abort) {\n   bool goal_result_received = false;\n   handle_result =\n     [\u0026](rclc_action_goal_handle_t * /* goal_handle */, void * ros_result_response,\n-      void * /* context */) {\n\u002B    void * /* context */) {\n       goal_result_received = true;\n \n       example_interfaces__action__Fibonacci_GetResult_Response * result =\n@@ -584,7 \u002B584,7 @@ TEST_F(ActionClientTest, goal_accept_cancel_success) {\n   // Prepare RCLCPP\n \n   server_handle_goal = [\u0026](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n     };\n@@ -627,7 \u002B627,7 @@ TEST_F(ActionClientTest, goal_accept_cancel_success) {\n   bool goal_result_received = false;\n   handle_result =\n     [\u0026](rclc_action_goal_handle_t * /* goal_handle */, void * /* ros_result_response */,\n-      void * /* context */) {\n\u002B    void * /* context */) {\n       goal_result_received = true;\n     };\n \n@@ -668,7 \u002B668,7 @@ TEST_F(ActionClientTest, goal_accept_cancel_reject) {\n   // Prepare RCLCPP\n \n   server_handle_goal = [\u0026](const rclcpp_action::GoalUUID \u0026 /* uuid */,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request.goal.order, goal-\u003Eorder);\n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n     };\n@@ -727,7 \u002B727,7 @@ TEST_F(ActionClientTest, goal_accept_cancel_reject) {\n   bool goal_result_received = false;\n   handle_result =\n     [\u0026](rclc_action_goal_handle_t * /* goal_handle */, void * ros_result_response,\n-      void * /* context */) {\n\u002B    void * /* context */) {\n       goal_result_received = true;\n \n       example_interfaces__action__Fibonacci_GetResult_Response * result =\n@@ -787,7 \u002B787,7 @@ TEST_F(ActionClientTest, multi_goal_accept_feedback_and_result) {\n \n   // Prepare RCLCPP\n   server_handle_goal = [\u0026](const rclcpp_action::GoalUUID \u0026 uuid,\n-      std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n\u002B    std::shared_ptr\u003Cconst Fibonacci::Goal\u003E goal) -\u003E rclcpp_action::GoalResponse {\n       EXPECT_EQ(ros_goal_request[get_raw_uuid(uuid)].goal.order, goal-\u003Eorder);\n \n       return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\ndiff --git rclc/test/rclc/test_action_server.cpp rclc/test/rclc/test_action_server.cpp\nindex 5004c73..2f6ac0a 100644\n--- rclc/test/rclc/test_action_server.cpp\n\u002B\u002B\u002B rclc/test/rclc/test_action_server.cpp\n@@ -373,7 \u002B373,7 @@ TEST_F(ActionServerTest, goal_accept_feedback_and_result) {\n   size_t feedback_received = 0;\n   send_goal_options.feedback_callback =\n     [\u0026](GoalHandleFibonacci::SharedPtr,\n-      const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n\u002B    const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n       feedback_received\u002B\u002B;\n       ASSERT_EQ(feedback-\u003Esequence.size(), 3U);\n     };\n@@ -444,7 \u002B444,7 @@ TEST_F(ActionServerTest, goal_accept_feedback_and_abort) {\n   size_t feedback_received = 0;\n   send_goal_options.feedback_callback =\n     [\u0026](GoalHandleFibonacci::SharedPtr,\n-      const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n\u002B    const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n       feedback_received\u002B\u002B;\n       ASSERT_EQ(feedback-\u003Esequence.size(), 3U);\n     };\n@@ -648,7 \u002B648,7 @@ TEST_F(ActionServerTest, multi_goal_accept_feedback_and_result) {\n   size_t feedback_received = 0;\n   send_goal_options.feedback_callback =\n     [\u0026](GoalHandleFibonacci::SharedPtr goal_handle,\n-      const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n\u002B    const std::shared_ptr\u003Cconst Fibonacci::Feedback\u003E feedback) -\u003E void {\n       feedback_received\u002B\u002B;\n       size_t feedback_size = goals[goal_handle-\u003Eget_goal_id()];\n       ASSERT_EQ(feedback-\u003Esequence.size(), feedback_size);\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "2d1b770e858fdb20e9c25913341fb388100dd19e",
    "RawMessage": "fix: make the loop condition align with the description (#2726)",
    "Changes": "diff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 901806f3..011e776a 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -749,8 \u002B749,7 @@ TYPED_TEST(TestExecutors, notifyTwiceWhileSpinning)\n   this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n   start = std::chrono::steady_clock::now();\n   while (\n-    sub1_msg_count == 1 \u0026\u0026\n-    sub2_msg_count == 0 \u0026\u0026\n\u002B    (sub1_msg_count == 1 || sub2_msg_count == 0) \u0026\u0026\n     (std::chrono::steady_clock::now() - start) \u003C 10s)\n   {\n     std::this_thread::sleep_for(1ms);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "0890417ccb430a0dbdbd4c6f8b483ffee3aa6784",
    "RawMessage": "Implement test for subscription loaned messages (#186)",
    "Changes": "diff --git test_rmw_implementation/test/test_subscription.cpp test_rmw_implementation/test/test_subscription.cpp\nindex 1710b95..57c70f7 100644\n--- test_rmw_implementation/test/test_subscription.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_subscription.cpp\n@@ -808,23 \u002B808,112 @@ protected:\n };\n \n TEST_F(CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION), rmw_take_loaned_message) {\n-  // TODO(lobotuerk): add tests for rmw_take_loaned_message() when we have an implementation.\n-  FAIL() \u003C\u003C \u0022Not implemented\u0022;\n\u002B  bool taken = false;\n\u002B  void * loaned_message = nullptr;\n\u002B  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n\u002B  rmw_ret_t ret = rmw_take_loaned_message(nullptr, \u0026loaned_message, \u0026taken, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message(sub, nullptr, \u0026taken, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message(sub, \u0026loaned_message, nullptr, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message(sub, \u0026loaned_message, \u0026taken, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  const char * implementation_identifier = sub-\u003Eimplementation_identifier;\n\u002B  sub-\u003Eimplementation_identifier = \u0022not-an-rmw-implementation-identifier\u0022;\n\u002B  ret = rmw_take_loaned_message(sub, \u0026loaned_message, \u0026taken, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  sub-\u003Eimplementation_identifier = implementation_identifier;\n }\n \n TEST_F(\n   CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION), rmw_take_loaned_message_with_info) {\n-  // TODO(lobotuerk): add tests for rmw_take_loaned_message_with_info()\n-  // when we have an implementation.\n-  FAIL() \u003C\u003C \u0022Not implemented\u0022;\n\u002B  bool taken = false;\n\u002B  void * loaned_message = nullptr;\n\u002B  rmw_message_info_t message_info = rmw_get_zero_initialized_message_info();\n\u002B  rmw_subscription_allocation_t * null_allocation{nullptr};  // still valid allocation\n\u002B  rmw_ret_t ret = rmw_take_loaned_message_with_info(\n\u002B    nullptr, \u0026loaned_message, \u0026taken, \u0026message_info, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message_with_info(\n\u002B    sub, nullptr, \u0026taken, \u0026message_info, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message_with_info(\n\u002B    sub, \u0026loaned_message, nullptr, \u0026message_info, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message_with_info(\n\u002B    sub, \u0026loaned_message, \u0026taken, nullptr, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  ret = rmw_take_loaned_message_with_info(\n\u002B    sub, \u0026loaned_message, \u0026taken, \u0026message_info, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(nullptr, loaned_message);\n\u002B  EXPECT_FALSE(taken);\n\u002B\n\u002B  const char * implementation_identifier = sub-\u003Eimplementation_identifier;\n\u002B  sub-\u003Eimplementation_identifier = \u0022not-an-rmw-implementation-identifier\u0022;\n\u002B  ret = rmw_take_loaned_message_with_info(\n\u002B    sub, \u0026loaned_message, \u0026taken, \u0026message_info, null_allocation);\n\u002B  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  sub-\u003Eimplementation_identifier = implementation_identifier;\n }\n \n TEST_F(\n   CLASSNAME(TestSubscriptionUseLoan, RMW_IMPLEMENTATION),\n   rmw_return_loaned_message_from_subscription) {\n-  // TODO(lobotuerk): add tests for rmw_return_loaned_message_from_subscription()\n-  // when we have an implementation.\n-  FAIL() \u003C\u003C \u0022Not implemented\u0022;\n\u002B  test_msgs__msg__BasicTypes msg{};\n\u002B  rmw_ret_t ret = rmw_return_loaned_message_from_subscription(nullptr, \u0026msg);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B\n\u002B  ret = rmw_return_loaned_message_from_subscription(sub, nullptr);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B\n\u002B  // Returning a sample that was not loaned\n\u002B  ret = rmw_return_loaned_message_from_subscription(sub, \u0026msg);\n\u002B  EXPECT_EQ(RMW_RET_ERROR, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B\n\u002B  const char * implementation_identifier = sub-\u003Eimplementation_identifier;\n\u002B  sub-\u003Eimplementation_identifier = \u0022not-an-rmw-implementation-identifier\u0022;\n\u002B  ret = rmw_return_loaned_message_from_subscription(sub, \u0026msg);\n\u002B  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  rmw_reset_error();\n\u002B  sub-\u003Eimplementation_identifier = implementation_identifier;\n }\n \n bool operator==(const test_msgs__msg__BasicTypes \u0026 m1, const test_msgs__msg__BasicTypes \u0026 m2)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "4de9cafdc0213c6c8141cab2cb2169899a7fdd26",
    "RawMessage": "Switch to target_link_libraries. (#361)",
    "Changes": "diff --git rmw/CMakeLists.txt rmw/CMakeLists.txt\nindex edf7c3a..872bcdd 100644\n--- rmw/CMakeLists.txt\n\u002B\u002B\u002B rmw/CMakeLists.txt\n@@ -55,18 \u002B55,16 @@ add_library(${PROJECT_NAME} ${rmw_sources})\n target_include_directories(${PROJECT_NAME} PUBLIC\n   \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n   \u0022$\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\u0022)\n-target_link_libraries(${PROJECT_NAME}\n\u002Btarget_link_libraries(${PROJECT_NAME} PUBLIC\n\u002B  rcutils::rcutils\n   rosidl_dynamic_typesupport::rosidl_dynamic_typesupport\n\u002B  rosidl_runtime_c::rosidl_runtime_c\n )\n \n if(BUILD_TESTING AND NOT RCUTILS_DISABLE_FAULT_INJECTION)\n   target_compile_definitions(${PROJECT_NAME} PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n endif()\n \n-ament_target_dependencies(${PROJECT_NAME}\n-  \u0022rcutils\u0022\n-  \u0022rosidl_runtime_c\u0022\n-)\n configure_rmw_library(${PROJECT_NAME} LANGUAGE \u0022C\u0022)\n \n ament_export_dependencies(\ndiff --git rmw/include/rmw/types.h rmw/include/rmw/types.h\nindex 9079895..6a59ae8 100644\n--- rmw/include/rmw/types.h\n\u002B\u002B\u002B rmw/include/rmw/types.h\n@@ -578,7 \u002B578,7 @@ typedef struct RMW_PUBLIC_TYPE rmw_qos_profile_s\n   enum rmw_qos_durability_policy_e durability;\n   /// The period at which messages are expected to be sent/received\n   /**\n-    * RMW_DURATION_UNSPEFICIED will use the RMW implementation\u0027s default value,\n\u002B    * RMW_DURATION_UNSPECIFIED will use the RMW implementation\u0027s default value,\n     *   which may or may not be infinite.\n     * RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation.\n     */\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_python",
    "SHA": "122b738f3b490280c217440e0bc2f5904f10fe3b",
    "RawMessage": "Service introspection (#178)",
    "Changes": "diff --git rosidl_generator_py/resource/_idl_support.c.em rosidl_generator_py/resource/_idl_support.c.em\nindex abb7536..d46c022 100644\n--- rosidl_generator_py/resource/_idl_support.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_idl_support.c.em\n@@ -50,6 \u002B50,13 @@ TEMPLATE(\n     package_name=package_name, interface_path=interface_path,\n     message=service.response_message, include_directives=include_directives)\n }@\n\u002B\n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=service.event_message, include_directives=include_directives)\n\u002B}@\n @[end for]@\n @\n @#######################################################################\n@@ -97,6 \u002B104,14 @@ TEMPLATE(\n     include_directives=include_directives)\n }@\n \n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=action.send_goal_service.event_message,\n\u002B    include_directives=include_directives)\n\u002B}@\n\u002B\n @{\n TEMPLATE(\n     \u0027_msg_support.c.em\u0027,\n@@ -113,6 \u002B128,14 @@ TEMPLATE(\n     include_directives=include_directives)\n }@\n \n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=action.get_result_service.event_message,\n\u002B    include_directives=include_directives)\n\u002B}@\n\u002B\n @{\n TEMPLATE(\n     \u0027_msg_support.c.em\u0027,\ndiff --git rosidl_generator_py/resource/_msg.py.em rosidl_generator_py/resource/_msg.py.em\nindex b2cc43d..a5b9cab 100644\n--- rosidl_generator_py/resource/_msg.py.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_msg.py.em\n@@ -13,6 \u002B13,9 @@ from rosidl_parser.definition import AbstractWString\n from rosidl_parser.definition import ACTION_FEEDBACK_SUFFIX\n from rosidl_parser.definition import ACTION_GOAL_SUFFIX\n from rosidl_parser.definition import ACTION_RESULT_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_EVENT_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX\n from rosidl_parser.definition import Array\n from rosidl_parser.definition import BasicType\n from rosidl_parser.definition import BOOLEAN_TYPE\n@@ -129,6 \u002B132,11 @@ for member in message.structure.members:\n     if isinstance(type_, AbstractNestedType):\n         type_ = type_.value_type\n     if isinstance(type_, NamespacedType):\n\u002B        if (\n\u002B            type_.name.endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX) or\n\u002B            type_.name.endswith(SERVICE_REQUEST_MESSAGE_SUFFIX)\n\u002B        ):\n\u002B            continue\n         if (\n             type_.name.endswith(ACTION_GOAL_SUFFIX) or\n             type_.name.endswith(ACTION_RESULT_SUFFIX) or\ndiff --git rosidl_generator_py/resource/_msg_support.c.em rosidl_generator_py/resource/_msg_support.c.em\nindex efa53a1..1afdafb 100644\n--- rosidl_generator_py/resource/_msg_support.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_msg_support.c.em\n@@ -11,6 \u002B11,8 @@ from rosidl_parser.definition import Array\n from rosidl_parser.definition import BasicType\n from rosidl_parser.definition import EMPTY_STRUCTURE_REQUIRED_MEMBER_NAME\n from rosidl_parser.definition import NamespacedType\n\u002Bfrom rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX\n \n \n def primitive_msg_type_to_c(type_):\n@@ -119,7 \u002B121,10 @@ if isinstance(member.type, AbstractNestedType) and isinstance(member.type.value_\n nested_header = \u0027/\u0027.join(type_[:-1] \u002B (\u0027detail\u0027, convert_camel_case_to_lower_case_underscore(type_[-1]),))\n nested_header \u002B= \u0027__functions.h\u0027\n }@\n-@[    if nested_header in include_directives]@\n\u002B@[    if type_[-1].endswith(SERVICE_REQUEST_MESSAGE_SUFFIX) or type_[-1].endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX)]\n\u002B@# Service request/response messages are included in the srv__struct\n\u002B@[continue]\n\u002B@[    elif nested_header in include_directives]@\n // already included above\n // @\n @[    else]@\ndiff --git rosidl_generator_py/resource/_srv.py.em rosidl_generator_py/resource/_srv.py.em\nindex ccd6d90..24d4548 100644\n--- rosidl_generator_py/resource/_srv.py.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_srv.py.em\n@@ -13,6 \u002B13,10 @@ TEMPLATE(\n     \u0027_msg.py.em\u0027,\n     package_name=package_name, interface_path=interface_path,\n     message=service.response_message, import_statements=import_statements)\n\u002BTEMPLATE(\n\u002B    \u0027_msg.py.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=service.event_message, import_statements=import_statements)\n }@\n \n \n@@ -42,11 \u002B46,14 @@ class Metaclass_@(service.namespaced_type.name)(type):\n                 @(module_name).Metaclass_@(service.request_message.structure.namespaced_type.name).__import_type_support__()\n             if @(module_name).Metaclass_@(service.response_message.structure.namespaced_type.name)._TYPE_SUPPORT is None:\n                 @(module_name).Metaclass_@(service.response_message.structure.namespaced_type.name).__import_type_support__()\n\u002B            if @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name)._TYPE_SUPPORT is None:\n\u002B                @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name).__import_type_support__()\n \n \n class @(service.namespaced_type.name)(metaclass=Metaclass_@(service.namespaced_type.name)):\n     from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.request_message.structure.namespaced_type.name) as Request\n     from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.response_message.structure.namespaced_type.name) as Response\n\u002B    from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.event_message.structure.namespaced_type.name) as Event\n \n     def __init__(self):\n         raise NotImplementedError(\u0027Service classes can not be instantiated\u0027)\ndiff --git rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\nindex e5ab4f1..353b01f 100644\n--- rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\n@@ -16,6 \u002B16,15 @@ TEMPLATE(\n     include_directives=include_directives,\n     register_functions=register_functions)\n }@\n\u002B\n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_pkg_typesupport_entry_point.c.em\u0027,\n\u002B    package_name=package_name, idl_type=idl_type,\n\u002B    message=service.event_message, typesupport_impl=typesupport_impl,\n\u002B    include_directives=include_directives,\n\u002B    register_functions=register_functions)\n\u002B}@\n @\n @{\n from rosidl_pycommon import convert_camel_case_to_lower_case_underscore\ndiff --git rosidl_generator_py/rosidl_generator_py/generate_py_impl.py rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\nindex 87a9f27..0cbaaa1 100644\n--- rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n\u002B\u002B\u002B rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n@@ -131,6 \u002B131,35 @@ def generate_py(generator_arguments_file, typesupport_impls):\n                 f.write(\n                     f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n                     f\u0027{idl_stem}  # noqa: F401\\n\u0027)\n\u002B                if subfolder == \u0027srv\u0027:\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Response  # noqa: F401\\n\u0027)\n\u002B                elif subfolder == \u0027action\u0027:\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Response  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Response  # noqa: F401\\n\u0027)\n \n     # expand templates per available typesupport implementation\n     template_dir = args[\u0027template_dir\u0027]\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "28742f605e119a19006cbf2e402475f2a3e59ded",
    "RawMessage": "wrap lines to shorten line length (#586)",
    "Changes": "diff --git rclpy/rclpy/impl/__init__.py rclpy/rclpy/impl/__init__.py\nindex 6972c2c..8da25ca 100644\n--- rclpy/rclpy/impl/__init__.py\n\u002B\u002B\u002B rclpy/rclpy/impl/__init__.py\n@@ -21,8 \u002B21,8 @@ from rpyutils import add_dll_directories_from_env\n \n def _import(name):\n     try:\n-        # Since Python 3.8, on Windows we should ensure DLL directories are explicitly added\n-        # to the search path.\n\u002B        # Since Python 3.8, on Windows we should ensure DLL directories are\n\u002B        # explicitly added to the search path.\n         # See https://docs.python.org/3/whatsnew/3.8.html#bpo-36085-whatsnew\n         with add_dll_directories_from_env(\u0027PATH\u0027):\n             return importlib.import_module(name, package=\u0027rclpy\u0027)\n@@ -40,8 \u002B40,9 @@ def _import(name):\n                 \u0027possible solutions\u0027\n         if e.path is not None and os.path.isfile(e.path):\n             e.msg \u002B= \\\n-                \u0022\\nThe C extension \u0027%s\u0027 failed to be imported while being present on the system.\u0022 \\\n-                \u0022 Please refer to \u0027%s\u0027 for possible solutions\u0022 % \\\n-                (e.path, \u0027https://index.ros.org/doc/ros2/Troubleshooting/Installation-Troubleshooting/\u0027\n-                         \u0027#import-failing-even-with-library-present-on-the-system\u0027)\n\u002B                f\u0022\\nThe C extension \u0027{e.path}\u0027 failed to be imported while \u0022 \\\n\u002B                \u0022being present on the system. Please refer to \u0027https://\u0022 \\\n\u002B                \u0027index.ros.org/doc/ros2/Troubleshooting/Installation-\u0027 \\\n\u002B                \u0027Troubleshooting/#import-failing-even-with-library-present-\u0027 \\\n\u002B                \u0022on-the-system\u0027 for possible solutions\u0022\n         raise\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "972167c5741b4412f80263a6ca5932b06037f7a1",
    "RawMessage": "Call callbacks only if unread count \u003E 0 (#634)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/custom_publisher_info.cpp rmw_fastrtps_shared_cpp/src/custom_publisher_info.cpp\nindex 2cc7845..85f6b6c 100644\n--- rmw_fastrtps_shared_cpp/src/custom_publisher_info.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/custom_publisher_info.cpp\n@@ -114,24 \u002B114,29 @@ void PubListener::set_on_new_event_callback(\n     switch (event_type) {\n       case RMW_EVENT_LIVELINESS_LOST:\n         publisher_info_-\u003Edata_writer_-\u003Eget_liveliness_lost_status(liveliness_lost_status_);\n-        callback(user_data, liveliness_lost_status_.total_count_change);\n-        liveliness_lost_status_.total_count_change = 0;\n\u002B\n\u002B        if (liveliness_lost_status_.total_count_change \u003E 0) {\n\u002B          callback(user_data, liveliness_lost_status_.total_count_change);\n\u002B          liveliness_lost_status_.total_count_change = 0;\n\u002B        }\n         break;\n       case RMW_EVENT_OFFERED_DEADLINE_MISSED:\n         publisher_info_-\u003Edata_writer_-\u003Eget_offered_deadline_missed_status(\n           offered_deadline_missed_status_);\n-        callback(\n-          user_data,\n-          offered_deadline_missed_status_.total_count_change);\n-        offered_deadline_missed_status_.total_count_change = 0;\n\u002B\n\u002B        if (offered_deadline_missed_status_.total_count_change \u003E 0) {\n\u002B          callback(user_data, offered_deadline_missed_status_.total_count_change);\n\u002B          offered_deadline_missed_status_.total_count_change = 0;\n\u002B        }\n         break;\n       case RMW_EVENT_OFFERED_QOS_INCOMPATIBLE:\n         publisher_info_-\u003Edata_writer_-\u003Eget_offered_incompatible_qos_status(\n           incompatible_qos_status_);\n-        callback(\n-          user_data,\n-          incompatible_qos_status_.total_count_change);\n-        incompatible_qos_status_.total_count_change = 0;\n\u002B\n\u002B        if (incompatible_qos_status_.total_count_change \u003E 0) {\n\u002B          callback(user_data, incompatible_qos_status_.total_count_change);\n\u002B          incompatible_qos_status_.total_count_change = 0;\n\u002B        }\n         break;\n       default:\n         break;\ndiff --git rmw_fastrtps_shared_cpp/src/custom_subscriber_info.cpp rmw_fastrtps_shared_cpp/src/custom_subscriber_info.cpp\nindex fe8a8e8..3454cad 100644\n--- rmw_fastrtps_shared_cpp/src/custom_subscriber_info.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/custom_subscriber_info.cpp\n@@ -138,40 \u002B138,49 @@ void SubListener::set_on_new_event_callback(\n       case RMW_EVENT_LIVELINESS_CHANGED:\n         {\n           subscriber_info_-\u003Edata_reader_-\u003Eget_liveliness_changed_status(liveliness_changed_status_);\n-          callback(\n-            user_data, liveliness_changed_status_.alive_count_change \u002B\n-            liveliness_changed_status_.not_alive_count_change);\n-          liveliness_changed_status_.alive_count_change = 0;\n-          liveliness_changed_status_.not_alive_count_change = 0;\n\u002B\n\u002B          if ((liveliness_changed_status_.alive_count_change \u003E 0) ||\n\u002B            (liveliness_changed_status_.not_alive_count_change \u003E 0))\n\u002B          {\n\u002B            callback(\n\u002B              user_data, liveliness_changed_status_.alive_count_change \u002B\n\u002B              liveliness_changed_status_.not_alive_count_change);\n\u002B\n\u002B            liveliness_changed_status_.alive_count_change = 0;\n\u002B            liveliness_changed_status_.not_alive_count_change = 0;\n\u002B          }\n         }\n         break;\n       case RMW_EVENT_REQUESTED_DEADLINE_MISSED:\n         {\n           subscriber_info_-\u003Edata_reader_-\u003Eget_requested_deadline_missed_status(\n             requested_deadline_missed_status_);\n-          callback(\n-            user_data,\n-            requested_deadline_missed_status_.total_count_change);\n-          requested_deadline_missed_status_.total_count_change = 0;\n\u002B\n\u002B          if (requested_deadline_missed_status_.total_count_change \u003E 0) {\n\u002B            callback(user_data, requested_deadline_missed_status_.total_count_change);\n\u002B            requested_deadline_missed_status_.total_count_change = 0;\n\u002B          }\n         }\n         break;\n       case RMW_EVENT_MESSAGE_LOST:\n         {\n           subscriber_info_-\u003Edata_reader_-\u003Eget_sample_lost_status(sample_lost_status_);\n-          callback(\n-            user_data,\n-            sample_lost_status_.total_count_change);\n-          sample_lost_status_.total_count_change = 0;\n\u002B\n\u002B          if (sample_lost_status_.total_count_change \u003E 0) {\n\u002B            callback(user_data, sample_lost_status_.total_count_change);\n\u002B            sample_lost_status_.total_count_change = 0;\n\u002B          }\n         }\n         break;\n       case RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE:\n         {\n           subscriber_info_-\u003Edata_reader_-\u003Eget_requested_incompatible_qos_status(\n             incompatible_qos_status_);\n-          callback(\n-            user_data,\n-            incompatible_qos_status_.total_count_change);\n-          incompatible_qos_status_.total_count_change = 0;\n\u002B\n\u002B          if (incompatible_qos_status_.total_count_change \u003E 0) {\n\u002B            callback(user_data, incompatible_qos_status_.total_count_change);\n\u002B            incompatible_qos_status_.total_count_change = 0;\n\u002B          }\n         }\n         break;\n       default:\n",
    "BackportedTo": "humble",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "abf3b96f1198cb40efbd264992f6529245cece59",
    "RawMessage": "Add sequence numbers to message info structure",
    "Changes": "diff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\nindex 63183e1..df280fe 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n@@ -25,6 \u002B25,7 @@ typedef struct _GurumddsPublisherInfo : GurumddsEventInfo\n   dds_DataWriter * topic_writer;\n   const rosidl_message_type_support_t * rosidl_message_typesupport;\n   const char * implementation_identifier;\n\u002B  int64_t sequence_number;\n \n   rmw_ret_t get_status(dds_StatusMask mask, void * event) override;\n   dds_StatusCondition * get_statuscondition() override;\ndiff --git rmw_gurumdds_cpp/src/rmw_features.cpp rmw_gurumdds_cpp/src/rmw_features.cpp\nnew file mode 100644\nindex 0000000..2b335e0\n--- /dev/null\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_features.cpp\n@@ -0,0 \u002B1,21 @@\n\u002B// Copyright 2022 GurumNetworks, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022rmw/features.h\u0022\n\u002B\n\u002Bbool\n\u002Brmw_feature_supported(rmw_feature_t feature)\n\u002B{\n\u002B  return feature == RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER ? true : false;\n\u002B}\ndiff --git rmw_gurumdds_cpp/src/rmw_publisher.cpp rmw_gurumdds_cpp/src/rmw_publisher.cpp\nindex 5490aa6..83b70e8 100644\n--- rmw_gurumdds_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_publisher.cpp\n@@ -35,6 \u002B35,7 @@\n #include \u0022rcutils/error_handling.h\u0022\n \n #include \u0022type_support_common.hpp\u0022\n\u002B#include \u0022type_support_service.hpp\u0022\n \n extern \u0022C\u0022\n {\n@@ -256,6 \u002B257,7 @@ rmw_create_publisher(\n   publisher_info-\u003Etopic_writer = topic_writer;\n   publisher_info-\u003Erosidl_message_typesupport = type_support;\n   publisher_info-\u003Epublisher_gid.implementation_identifier = gurum_gurumdds_identifier;\n\u002B  publisher_info-\u003Esequence_number = 0;\n \n   static_assert(\n     sizeof(GurumddsPublisherGID) \u003C= RMW_GID_STORAGE_SIZE,\n@@ -629,7 \u002B631,18 @@ rmw_publish(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_ReturnCode_t ret = dds_DataWriter_raw_write(topic_writer, dds_message, size);\n\u002B  dds_SampleInfoEx sampleinfo_ex;\n\u002B  memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B  ros_sn_to_dds_sn(\u002B\u002Binfo-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n\u002B  auto publisher_gid =\n\u002B    reinterpret_cast\u003CGurumddsPublisherGID *\u003E(info-\u003Epublisher_gid.data);\n\u002B  ros_guid_to_dds_guid(\n\u002B    reinterpret_cast\u003Cint8_t *\u003E(publisher_gid-\u003Epublication_handle),\n\u002B    reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n\u002B\n\u002B  dds_ReturnCode_t ret = dds_DataWriter_raw_write_w_sampleinfoex(\n\u002B    topic_writer, dds_message, size,\n\u002B    \u0026sampleinfo_ex);\n   const char * errstr;\n   if (ret == dds_RETCODE_OK) {\n     errstr = \u0022dds_RETCODE_OK\u0022;\n@@ -681,10 \u002B694,20 @@ rmw_publish_serialized_message(\n   dds_DataWriter * topic_writer = info-\u003Etopic_writer;\n   RCUTILS_CHECK_FOR_NULL_WITH_MSG(info, \u0022topic writer is null\u0022, return RMW_RET_ERROR);\n \n-  dds_ReturnCode_t ret = dds_DataWriter_raw_write(\n\u002B  dds_SampleInfoEx sampleinfo_ex;\n\u002B  memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B  ros_sn_to_dds_sn(\u002B\u002Binfo-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n\u002B  auto publisher_gid =\n\u002B    reinterpret_cast\u003CGurumddsPublisherGID *\u003E(info-\u003Epublisher_gid.data);\n\u002B  ros_guid_to_dds_guid(\n\u002B    reinterpret_cast\u003Cint8_t *\u003E(publisher_gid-\u003Epublication_handle),\n\u002B    reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n\u002B\n\u002B  dds_ReturnCode_t ret = dds_DataWriter_raw_write_w_sampleinfoex(\n     topic_writer,\n     serialized_message-\u003Ebuffer,\n-    static_cast\u003Cuint32_t\u003E(serialized_message-\u003Ebuffer_length)\n\u002B    static_cast\u003Cuint32_t\u003E(serialized_message-\u003Ebuffer_length),\n\u002B    \u0026sampleinfo_ex\n   );\n   const char * errstr;\n   if (ret == dds_RETCODE_OK) {\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex bd2af19..851b3f6 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -36,6 \u002B36,7 @@\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n \n #include \u0022type_support_common.hpp\u0022\n\u002B#include \u0022type_support_service.hpp\u0022\n \n extern \u0022C\u0022\n {\n@@ -561,7 \u002B562,7 @@ _take(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n     topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n     dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n@@ -622,11 \u002B623,16 @@ _take(\n     *taken = true;\n \n     if (message_info != nullptr) {\n\u002B      int64_t sequence_number = 0;\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n\u002B      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n\u002B      message_info-\u003Epublication_sequence_number = sequence_number;\n\u002B      message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n       sender_gid-\u003Eimplementation_identifier = identifier;\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n@@ -758,7 \u002B764,7 @@ rmw_take_sequence(\n \n   *taken = 0;\n \n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n     topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n     dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n@@ -817,6 \u002B823,10 @@ rmw_take_sequence(\n         return RMW_RET_ERROR;\n       }\n \n\u002B      int64_t sequence_number = 0;\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n\u002B      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B\n       auto message_info = \u0026(message_info_sequence-\u003Edata[*taken]);\n \n       message_info-\u003Esource_timestamp =\n@@ -824,6 \u002B834,8 @@ rmw_take_sequence(\n         sample_info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n\u002B      message_info-\u003Epublication_sequence_number = sequence_number;\n\u002B      message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n       sender_gid-\u003Eimplementation_identifier = gurum_gurumdds_identifier;\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n@@ -897,7 \u002B909,7 @@ _take_serialized(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n     topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n     dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n@@ -958,11 \u002B970,16 @@ _take_serialized(\n     *taken = true;\n \n     if (message_info != nullptr) {\n\u002B      int64_t sequence_number = 0;\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n\u002B      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n\u002B      message_info-\u003Epublication_sequence_number = sequence_number;\n\u002B      message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n       sender_gid-\u003Eimplementation_identifier = identifier;\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "72558c95808e569ada26848395edb011c87bc976",
    "RawMessage": "Change TF2Error names to be a bit more descriptive. (#349)",
    "Changes": "diff --git tf2/include/tf2/buffer_core.h tf2/include/tf2/buffer_core.h\nindex 3ff0a7de..73364f87 100644\n--- tf2/include/tf2/buffer_core.h\n\u002B\u002B\u002B tf2/include/tf2/buffer_core.h\n@@ -222,7 \u002B222,7 @@ public:\n   void cancelTransformableRequest(TransformableRequestHandle handle);\n \n \n-  // Tell the buffer that there are multiple threads serviciing it.\n\u002B  // Tell the buffer that there are multiple threads servicing it.\n   // This is useful for derived classes to know if they can block or not.\n   TF2_PUBLIC\n   void setUsingDedicatedThread(bool value) {using_dedicated_thread_ = value;}\ndiff --git tf2/include/tf2/exceptions.h tf2/include/tf2/exceptions.h\nindex c516da85..c187b5e7 100644\n--- tf2/include/tf2/exceptions.h\n\u002B\u002B\u002B tf2/include/tf2/exceptions.h\n@@ -40,17 \u002B40,51 @@\n namespace tf2\n {\n \n\u002B// TODO(clalancette): We can remove these workarounds when we remove the\n\u002B// deprecated TF2Error enums.\n\u002B#if defined(_WIN32)\n\u002B#pragma push_macro(\u0022NO_ERROR\u0022)\n\u002B#undef NO_ERROR\n\u002B#endif\n\u002B#if defined(__APPLE__)\n\u002B// The clang compiler on Apple claims that [[deprecated]] on an enumerator value\n\u002B// is a C\u002B\u002B17 feature, when it was really introduced in C\u002B\u002B14.  Ignore that\n\u002B// warning when defining the structure; this whole thing will go away when we\n\u002B// remove the deprecated values.\n\u002B#pragma clang diagnostic push\n\u002B#pragma clang diagnostic ignored \u0022-Wc\u002B\u002B17-extensions\u0022\n\u002B#endif\n\u002B\n enum class TF2Error : std::uint8_t\n {\n-  NO_ERROR = 0,\n-  LOOKUP_ERROR = 1,\n-  CONNECTIVITY_ERROR = 2,\n-  EXTRAPOLATION_ERROR = 3,\n-  INVALID_ARGUMENT_ERROR = 4,\n-  TIMEOUT_ERROR = 5,\n-  TRANSFORM_ERROR = 6\n\u002B  // While the TF2_ prefix here is a bit redundant, it also prevents us from\n\u002B  // colliding with Windows defines (specifically, NO_ERROR).\n\u002B  TF2_NO_ERROR = 0,\n\u002B  TF2_LOOKUP_ERROR = 1,\n\u002B  TF2_CONNECTIVITY_ERROR = 2,\n\u002B  TF2_EXTRAPOLATION_ERROR = 3,\n\u002B  TF2_INVALID_ARGUMENT_ERROR = 4,\n\u002B  TF2_TIMEOUT_ERROR = 5,\n\u002B  TF2_TRANSFORM_ERROR = 6,\n\u002B\n\u002B  NO_ERROR [[deprecated(\u0022Use TF2_NO_ERROR instead\u0022)]] = 0,\n\u002B  LOOKUP_ERROR [[deprecated(\u0022Use TF2_LOOKUP_ERROR instead\u0022)]] = 1,\n\u002B  CONNECTIVITY_ERROR [[deprecated(\u0022Use TF2_CONNECTIVITY_ERROR instead\u0022)]] = 2,\n\u002B  EXTRAPOLATION_ERROR [[deprecated(\u0022Use TF2_EXTRAPOLATION_ERROR instead\u0022)]] = 3,\n\u002B  INVALID_ARGUMENT_ERROR [[deprecated(\u0022Use TF2_INVALID_ARGUMENT_ERROR instead\u0022)]] = 4,\n\u002B  TIMEOUT_ERROR [[deprecated(\u0022Use TF2_TIMEOUT_ERROR instead\u0022)]] = 5,\n\u002B  TRANSFORM_ERROR [[deprecated(\u0022Use TF2_TRANSFORM_ERROR instead\u0022)]] = 6\n };\n \n\u002B// TODO(clalancette): We can remove these workarounds when we remove the\n\u002B// deprecated TF2Error enums.\n\u002B#if defined(__APPLE__)\n\u002B#pragma clang diagnostic pop\n\u002B#endif\n\u002B#if defined(_WIN32)\n\u002B#pragma pop_macro(\u0022NO_ERROR\u0022)\n\u002B#endif\n\u002B\n /** \\brief A base class for all tf2 exceptions\n  * This inherits from ros::exception\n  * which inherits from std::runtime_exception\ndiff --git tf2/src/buffer_core.cpp tf2/src/buffer_core.cpp\nindex 0ecc350b..9e54acfa 100644\n--- tf2/src/buffer_core.cpp\n\u002B\u002B\u002B tf2/src/buffer_core.cpp\n@@ -408,13 \u002B408,13 @@ tf2::TF2Error BufferCore::walkToTopParent(\n   // Short circuit if zero length transform to allow lookups on non existant links\n   if (source_id == target_id) {\n     f.finalize(Identity, time);\n-    return tf2::TF2Error::NO_ERROR;\n\u002B    return tf2::TF2Error::TF2_NO_ERROR;\n   }\n \n   // If getting the latest get the latest common time\n   if (time == TimePointZero) {\n     tf2::TF2Error retval = getLatestCommonTime(target_id, source_id, time, error_string);\n-    if (retval != tf2::TF2Error::NO_ERROR) {\n\u002B    if (retval != tf2::TF2Error::TF2_NO_ERROR) {\n       return retval;\n     }\n   }\n@@ -450,7 \u002B450,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n     // Early out... target frame is a direct parent of the source frame\n     if (frame == target_id) {\n       f.finalize(TargetParentOfSource, time);\n-      return tf2::TF2Error::NO_ERROR;\n\u002B      return tf2::TF2Error::TF2_NO_ERROR;\n     }\n \n     f.accum(true);\n@@ -466,7 \u002B466,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n           allFramesAsStringNoLock() \u003C\u003C std::endl;\n         *error_string = ss.str();\n       }\n-      return tf2::TF2Error::LOOKUP_ERROR;\n\u002B      return tf2::TF2Error::TF2_LOOKUP_ERROR;\n     }\n   }\n \n@@ -494,7 \u002B494,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n         *error_string = ss.str();\n       }\n \n-      return tf2::TF2Error::EXTRAPOLATION_ERROR;\n\u002B      return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;\n     }\n \n     // Early out... source frame is a direct parent of the target frame\n@@ -503,7 \u002B503,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n       if (frame_chain) {\n         frame_chain-\u003Eswap(reverse_frame_chain);\n       }\n-      return tf2::TF2Error::NO_ERROR;\n\u002B      return tf2::TF2Error::TF2_NO_ERROR;\n     }\n \n     f.accum(false);\n@@ -518,7 \u002B518,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n           allFramesAsStringNoLock() \u003C\u003C std::endl;\n         *error_string = ss.str();\n       }\n-      return tf2::TF2Error::LOOKUP_ERROR;\n\u002B      return tf2::TF2Error::TF2_LOOKUP_ERROR;\n     }\n   }\n \n@@ -530,10 \u002B530,10 @@ tf2::TF2Error BufferCore::walkToTopParent(\n           lookupFrameString(source_id) \u003C\u003C \u0022] to frame [\u0022 \u003C\u003C lookupFrameString(target_id) \u003C\u003C \u0022]\u0022;\n         *error_string = ss.str();\n       }\n-      return tf2::TF2Error::EXTRAPOLATION_ERROR;\n\u002B      return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;\n     }\n     createConnectivityErrorString(source_id, target_id, error_string);\n-    return tf2::TF2Error::CONNECTIVITY_ERROR;\n\u002B    return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;\n   }\n \n   f.finalize(FullPath, time);\n@@ -562,7 \u002B562,7 @@ tf2::TF2Error BufferCore::walkToTopParent(\n     }\n   }\n \n-  return tf2::TF2Error::NO_ERROR;\n\u002B  return tf2::TF2Error::TF2_NO_ERROR;\n }\n \n struct TransformAccum\n@@ -730,13 \u002B730,13 @@ void BufferCore::lookupTransformImpl(\n   std::string error_string;\n   TransformAccum accum;\n   tf2::TF2Error retval = walkToTopParent(accum, time, target_id, source_id, \u0026error_string);\n-  if (retval != tf2::TF2Error::NO_ERROR) {\n\u002B  if (retval != tf2::TF2Error::TF2_NO_ERROR) {\n     switch (retval) {\n-      case tf2::TF2Error::CONNECTIVITY_ERROR:\n\u002B      case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:\n         throw ConnectivityException(error_string);\n-      case tf2::TF2Error::EXTRAPOLATION_ERROR:\n\u002B      case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:\n         throw ExtrapolationException(error_string);\n-      case tf2::TF2Error::LOOKUP_ERROR:\n\u002B      case tf2::TF2Error::TF2_LOOKUP_ERROR:\n         throw LookupException(error_string);\n       default:\n         CONSOLE_BRIDGE_logError(\u0022Unknown error code: %d\u0022, retval);\n@@ -806,7 \u002B806,7 @@ bool BufferCore::canTransformNoLock(\n   }\n \n   CanTransformAccum accum;\n-  if (walkToTopParent(accum, time, target_id, source_id, error_msg) == tf2::TF2Error::NO_ERROR) {\n\u002B  if (walkToTopParent(accum, time, target_id, source_id, error_msg) == tf2::TF2Error::TF2_NO_ERROR) {\n     return true;\n   }\n \n@@ -988,7 \u002B988,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n   TimePoint \u0026 time, std::string * error_string) const\n {\n   // Error if one of the frames don\u0027t exist.\n-  if (source_id == 0 || target_id == 0) {return tf2::TF2Error::LOOKUP_ERROR;}\n\u002B  if (source_id == 0 || target_id == 0) {return tf2::TF2Error::TF2_LOOKUP_ERROR;}\n \n   if (source_id == target_id) {\n     TimeCacheInterfacePtr cache = getFrame(source_id);\n@@ -998,7 \u002B998,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n     } else {\n       time = TimePointZero;\n     }\n-    return tf2::TF2Error::NO_ERROR;\n\u002B    return tf2::TF2Error::TF2_NO_ERROR;\n   }\n \n   std::vector\u003CP_TimeAndFrameID\u003E lct_cache;\n@@ -1037,7 \u002B1037,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n       if (time == TimePoint::max()) {\n         time = TimePointZero;\n       }\n-      return tf2::TF2Error::NO_ERROR;\n\u002B      return tf2::TF2Error::TF2_NO_ERROR;\n     }\n \n     \u002B\u002Bdepth;\n@@ -1048,7 \u002B1048,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n           allFramesAsStringNoLock() \u003C\u003C std::endl;\n         *error_string = ss.str();\n       }\n-      return tf2::TF2Error::LOOKUP_ERROR;\n\u002B      return tf2::TF2Error::TF2_LOOKUP_ERROR;\n     }\n   }\n \n@@ -1091,7 \u002B1091,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n       if (time == TimePoint::max()) {\n         time = TimePointZero;\n       }\n-      return tf2::TF2Error::NO_ERROR;\n\u002B      return tf2::TF2Error::TF2_NO_ERROR;\n     }\n \n     \u002B\u002Bdepth;\n@@ -1102,13 \u002B1102,13 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n           allFramesAsStringNoLock() \u003C\u003C std::endl;\n         *error_string = ss.str();\n       }\n-      return tf2::TF2Error::LOOKUP_ERROR;\n\u002B      return tf2::TF2Error::TF2_LOOKUP_ERROR;\n     }\n   }\n \n   if (common_parent == 0) {\n     createConnectivityErrorString(source_id, target_id, error_string);\n-    return tf2::TF2Error::CONNECTIVITY_ERROR;\n\u002B    return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;\n   }\n \n   // Loop through the source -\u003E root list until we hit the common parent\n@@ -1131,7 \u002B1131,7 @@ tf2::TF2Error BufferCore::getLatestCommonTime(\n   }\n \n   time = common_time;\n-  return tf2::TF2Error::NO_ERROR;\n\u002B  return tf2::TF2Error::TF2_NO_ERROR;\n }\n \n std::string BufferCore::allFramesAsYAML(TimePoint current_time) const\n@@ -1525,13 \u002B1525,13 @@ void BufferCore::_chainAsVector(\n   tf2::TF2Error retval = walkToTopParent(\n     accum, source_time, fixed_id, source_id, \u0026error_string,\n     \u0026source_frame_chain);\n-  if (retval != tf2::TF2Error::NO_ERROR) {\n\u002B  if (retval != tf2::TF2Error::TF2_NO_ERROR) {\n     switch (retval) {\n-      case tf2::TF2Error::CONNECTIVITY_ERROR:\n\u002B      case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:\n         throw ConnectivityException(error_string);\n-      case tf2::TF2Error::EXTRAPOLATION_ERROR:\n\u002B      case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:\n         throw ExtrapolationException(error_string);\n-      case tf2::TF2Error::LOOKUP_ERROR:\n\u002B      case tf2::TF2Error::TF2_LOOKUP_ERROR:\n         throw LookupException(error_string);\n       default:\n         CONSOLE_BRIDGE_logError(\u0022Unknown error code: %d\u0022, retval);\n@@ -1545,13 \u002B1545,13 @@ void BufferCore::_chainAsVector(\n       accum, target_time, target_id, fixed_id, \u0026error_string,\n       \u0026target_frame_chain);\n \n-    if (retval != tf2::TF2Error::NO_ERROR) {\n\u002B    if (retval != tf2::TF2Error::TF2_NO_ERROR) {\n       switch (retval) {\n-        case tf2::TF2Error::CONNECTIVITY_ERROR:\n\u002B        case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:\n           throw ConnectivityException(error_string);\n-        case tf2::TF2Error::EXTRAPOLATION_ERROR:\n\u002B        case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:\n           throw ExtrapolationException(error_string);\n-        case tf2::TF2Error::LOOKUP_ERROR:\n\u002B        case tf2::TF2Error::TF2_LOOKUP_ERROR:\n           throw LookupException(error_string);\n         default:\n           CONSOLE_BRIDGE_logError(\u0022Unknown error code: %d\u0022, retval);\ndiff --git tf2_py/src/tf2_py.cpp tf2_py/src/tf2_py.cpp\nindex ccd89d42..dadde92c 100644\n--- tf2_py/src/tf2_py.cpp\n\u002B\u002B\u002B tf2_py/src/tf2_py.cpp\n@@ -505,7 \u002B505,7 @@ static PyObject * getLatestCommonTime(PyObject * self, PyObject * args)\n   WRAP(source_id = bc-\u003E_validateFrameId(\u0022get_latest_common_time\u0022, source_frame));\n   const tf2::TF2Error r = bc-\u003E_getLatestCommonTime(target_id, source_id, tf2_time, \u0026error_string);\n \n-  if (r != tf2::TF2Error::NO_ERROR) {\n\u002B  if (r != tf2::TF2Error::TF2_NO_ERROR) {\n     PyErr_SetString(tf2_exception, error_string.c_str());\n     return nullptr;\n   }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "8c0161a07f1a44db023650d10f1b2e581c64e1f1",
    "RawMessage": "fix TestTimeSource.ROS_time_valid_attach_detach. (#2700)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_time_source.cpp rclcpp/test/rclcpp/test_time_source.cpp\nindex 1437e471..cb799cba 100644\n--- rclcpp/test/rclcpp/test_time_source.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_time_source.cpp\n@@ -212,6 \u002B212,9 @@ TEST_F(TestTimeSource, ROS_time_valid_attach_detach) {\n   ts.attachNode(node);\n   EXPECT_FALSE(ros_clock-\u003Eros_time_is_active());\n \n\u002B  ts.attachClock(ros_clock);\n\u002B  EXPECT_FALSE(ros_clock-\u003Eros_time_is_active());\n\u002B\n   ts.detachClock(ros_clock);\n   EXPECT_FALSE(ros_clock-\u003Eros_time_is_active());\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "6c10f941d3f5c7585ef0af60ad30a301d8d65f16",
    "RawMessage": "use maybe_unused attribute for the portability. (#2758)",
    "Changes": "diff --git rclcpp/include/rclcpp/allocator/allocator_deleter.hpp rclcpp/include/rclcpp/allocator/allocator_deleter.hpp\nindex 73fbc7b9..28aeb47d 100644\n--- rclcpp/include/rclcpp/allocator/allocator_deleter.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/allocator/allocator_deleter.hpp\n@@ -69,18 \u002B69,17 @@ private:\n };\n \n template\u003Ctypename Alloc, typename T, typename D\u003E\n-void set_allocator_for_deleter(D * deleter, Alloc * alloc)\n\u002Bvoid set_allocator_for_deleter([[maybe_unused]] D * deleter, [[maybe_unused]] Alloc * alloc)\n {\n-  (void) alloc;\n-  (void) deleter;\n   throw std::runtime_error(\u0022Reached unexpected template specialization\u0022);\n }\n \n template\u003Ctypename T, typename U\u003E\n-void set_allocator_for_deleter(std::default_delete\u003CT\u003E * deleter, std::allocator\u003CU\u003E * alloc)\n\u002Bvoid set_allocator_for_deleter(\n\u002B  [[maybe_unused]] std::default_delete\u003CT\u003E * deleter,\n\u002B  [[maybe_unused]] std::allocator\u003CU\u003E * alloc)\n {\n-  (void) deleter;\n-  (void) alloc;\n\u002B  // This function is intentionally left empty.\n }\n \n template\u003Ctypename Alloc, typename T\u003E\ndiff --git rclcpp/include/rclcpp/event_handler.hpp rclcpp/include/rclcpp/event_handler.hpp\nindex 8d8bb27e..5c91dc30 100644\n--- rclcpp/include/rclcpp/event_handler.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/event_handler.hpp\n@@ -293,9 \u002B293,8 @@ public:\n   }\n \n   std::shared_ptr\u003Cvoid\u003E\n-  take_data_by_entity_id(size_t id) override\n\u002B  take_data_by_entity_id([[maybe_unused]] size_t id) override\n   {\n-    (void)id;\n     return take_data();\n   }\n \ndiff --git rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\nindex 5f619baf..cc9326ae 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\n@@ -79,9 \u002B79,8 @@ public:\n   take_data() override = 0;\n \n   std::shared_ptr\u003Cvoid\u003E\n-  take_data_by_entity_id(size_t id) override\n\u002B  take_data_by_entity_id([[maybe_unused]] size_t id) override\n   {\n-    (void)id;\n     return take_data();\n   }\n \ndiff --git rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\nindex 2f384f35..329c38d9 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\n@@ -110,9 \u002B110,8 @@ public:\n   }\n \n   bool\n-  is_ready(const rcl_wait_set_t \u0026 wait_set) override\n\u002B  is_ready([[maybe_unused]] const rcl_wait_set_t \u0026 wait_set) override\n   {\n-    (void) wait_set;\n     return buffer_-\u003Ehas_data();\n   }\n \ndiff --git rclcpp/include/rclcpp/publisher.hpp rclcpp/include/rclcpp/publisher.hpp\nindex fc167d9c..92dbaddc 100644\n--- rclcpp/include/rclcpp/publisher.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/publisher.hpp\n@@ -143,12 \u002B143,9 @@ public:\n   post_init_setup(\n     rclcpp::node_interfaces::NodeBaseInterface * node_base,\n     const std::string \u0026 topic,\n-    const rclcpp::QoS \u0026 qos,\n-    const rclcpp::PublisherOptionsWithAllocator\u003CAllocatorT\u003E \u0026 options)\n\u002B    [[maybe_unused]] const rclcpp::QoS \u0026 qos,\n\u002B    [[maybe_unused]] const rclcpp::PublisherOptionsWithAllocator\u003CAllocatorT\u003E \u0026 options)\n   {\n-    (void)qos;\n-    (void)options;\n-\n     // If needed, setup intra process communication.\n     if (rclcpp::detail::resolve_use_intra_process(options_, *node_base)) {\n       auto context = node_base-\u003Eget_context();\ndiff --git rclcpp/include/rclcpp/strategies/message_pool_memory_strategy.hpp rclcpp/include/rclcpp/strategies/message_pool_memory_strategy.hpp\nindex 703066fa..970acdb3 100644\n--- rclcpp/include/rclcpp/strategies/message_pool_memory_strategy.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/strategies/message_pool_memory_strategy.hpp\n@@ -114,9 \u002B114,9 @@ public:\n    * all references.\n    * \\param[in] msg Shared pointer to the message to return.\n    */\n-  void return_message(std::shared_ptr\u003CMessageT\u003E \u0026 msg)\n\u002B  void return_message([[maybe_unused]] std::shared_ptr\u003CMessageT\u003E \u0026 msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n \n protected:\ndiff --git rclcpp/include/rclcpp/subscription.hpp rclcpp/include/rclcpp/subscription.hpp\nindex 4366cae2..20f2b575 100644\n--- rclcpp/include/rclcpp/subscription.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription.hpp\n@@ -209,13 \u002B209,11 @@ public:\n   /// Called after construction to continue setup that requires shared_from_this().\n   void\n   post_init_setup(\n-    rclcpp::node_interfaces::NodeBaseInterface * node_base,\n-    const rclcpp::QoS \u0026 qos,\n-    const rclcpp::SubscriptionOptionsWithAllocator\u003CAllocatorT\u003E \u0026 options)\n\u002B    [[maybe_unused]] rclcpp::node_interfaces::NodeBaseInterface * node_base,\n\u002B    [[maybe_unused]] const rclcpp::QoS \u0026 qos,\n\u002B    [[maybe_unused]] const rclcpp::SubscriptionOptionsWithAllocator\u003CAllocatorT\u003E \u0026 options)\n   {\n-    (void)node_base;\n-    (void)qos;\n-    (void)options;\n\u002B    // This function is intentionally left empty.\n   }\n \n   /// Take the next message from the inter-process subscription.\n@@ -422,20 \u002B420,17 @@ public:\n \n   void\n   return_dynamic_message(\n-    rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message) override\n\u002B    [[maybe_unused]] rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message) override\n   {\n-    (void) message;\n     throw rclcpp::exceptions::UnimplementedError(\n             \u0022return_dynamic_message is not implemented for Subscription\u0022);\n   }\n \n   void\n   handle_dynamic_message(\n-    const rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message,\n-    const rclcpp::MessageInfo \u0026 message_info) override\n\u002B    [[maybe_unused]] const rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message,\n\u002B    [[maybe_unused]] const rclcpp::MessageInfo \u0026 message_info) override\n   {\n-    (void) message;\n-    (void) message_info;\n     throw rclcpp::exceptions::UnimplementedError(\n             \u0022handle_dynamic_message is not implemented for Subscription\u0022);\n   }\ndiff --git rclcpp/src/rclcpp/detail/rmw_implementation_specific_publisher_payload.cpp rclcpp/src/rclcpp/detail/rmw_implementation_specific_publisher_payload.cpp\nindex cd7580d4..0d1811f3 100644\n--- rclcpp/src/rclcpp/detail/rmw_implementation_specific_publisher_payload.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/detail/rmw_implementation_specific_publisher_payload.cpp\n@@ -23,10 \u002B23,9 @@ namespace detail\n \n void\n RMWImplementationSpecificPublisherPayload::modify_rmw_publisher_options(\n-  rmw_publisher_options_t \u0026 rmw_publisher_options) const\n\u002B  [[maybe_unused]] rmw_publisher_options_t \u0026 rmw_publisher_options) const\n {\n   // By default, do not mutate the rmw publisher options.\n-  (void)rmw_publisher_options;\n }\n \n }  // namespace detail\ndiff --git rclcpp/src/rclcpp/detail/rmw_implementation_specific_subscription_payload.cpp rclcpp/src/rclcpp/detail/rmw_implementation_specific_subscription_payload.cpp\nindex c84c3d4b..435dff23 100644\n--- rclcpp/src/rclcpp/detail/rmw_implementation_specific_subscription_payload.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/detail/rmw_implementation_specific_subscription_payload.cpp\n@@ -23,10 \u002B23,9 @@ namespace detail\n \n void\n RMWImplementationSpecificSubscriptionPayload::modify_rmw_subscription_options(\n-  rmw_subscription_options_t \u0026 rmw_subscription_options) const\n\u002B  [[maybe_unused]] rmw_subscription_options_t \u0026 rmw_subscription_options) const\n {\n   // By default, do not mutate the rmw subscription options.\n-  (void)rmw_subscription_options;\n }\n \n }  // namespace detail\ndiff --git rclcpp/src/rclcpp/detail/utilities.cpp rclcpp/src/rclcpp/detail/utilities.cpp\nindex 0166f2dc..58930f32 100644\n--- rclcpp/src/rclcpp/detail/utilities.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/detail/utilities.cpp\n@@ -31,11 \u002B31,10 @@ namespace detail\n \n std::vector\u003Cstd::string\u003E\n get_unparsed_ros_arguments(\n-  int argc, char const * const * argv,\n\u002B  [[maybe_unused]] int argc, char const * const * argv,\n   rcl_arguments_t * arguments,\n   rcl_allocator_t allocator)\n {\n-  (void)argc;\n   std::vector\u003Cstd::string\u003E unparsed_ros_arguments;\n   int unparsed_ros_args_count = rcl_arguments_get_count_unparsed_ros(arguments);\n   if (unparsed_ros_args_count \u003E 0) {\ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex e7b79959..70e2f699 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -169,10 \u002B169,9 @@ Executor::get_automatically_added_callback_groups_from_nodes()\n void\n Executor::add_callback_group(\n   rclcpp::CallbackGroup::SharedPtr group_ptr,\n-  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr,\n\u002B  [[maybe_unused]] rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr,\n   bool notify)\n {\n-  (void) node_ptr;\n   this-\u003Ecollector_.add_callback_group(group_ptr);\n \n   try {\ndiff --git rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\nindex 43850179..b5d88e16 100644\n--- rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\n@@ -138,9 \u002B138,8 @@ ExecutorNotifyWaitable::take_data()\n }\n \n std::shared_ptr\u003Cvoid\u003E\n-ExecutorNotifyWaitable::take_data_by_entity_id(size_t id)\n\u002BExecutorNotifyWaitable::take_data_by_entity_id([[maybe_unused]] size_t id)\n {\n-  (void) id;\n   return nullptr;\n }\n \ndiff --git rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\nindex 130b4d95..378fdfb8 100644\n--- rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n@@ -79,9 \u002B79,8 @@ MultiThreadedExecutor::get_number_of_threads()\n }\n \n void\n-MultiThreadedExecutor::run(size_t this_thread_number)\n\u002BMultiThreadedExecutor::run([[maybe_unused]] size_t this_thread_number)\n {\n-  (void)this_thread_number;\n   while (rclcpp::ok(this-\u003Econtext_) \u0026\u0026 spinning.load()) {\n     rclcpp::AnyExecutable any_exec;\n     {\ndiff --git rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\nindex 322102cb..8f39c0fb 100644\n--- rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n@@ -318,10 \u002B318,8 @@ EventsExecutor::execute_event(const ExecutorEvent \u0026 event)\n }\n \n void\n-EventsExecutor::handle_updated_entities(bool notify)\n\u002BEventsExecutor::handle_updated_entities([[maybe_unused]] bool notify)\n {\n-  (void)notify;\n-\n   // Do not rebuild if we don\u0027t need to.\n   // A rebuild event could be generated, but then\n   // this function could end up being called from somewhere else\ndiff --git rclcpp/src/rclcpp/generic_subscription.cpp rclcpp/src/rclcpp/generic_subscription.cpp\nindex ae28354b..63e52d3f 100644\n--- rclcpp/src/rclcpp/generic_subscription.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/generic_subscription.cpp\n@@ -56,10 \u002B56,9 @@ GenericSubscription::handle_serialized_message(\n \n void\n GenericSubscription::handle_loaned_message(\n-  void * message, const rclcpp::MessageInfo \u0026 message_info)\n\u002B  [[maybe_unused]] void * message,\n\u002B  [[maybe_unused]] const rclcpp::MessageInfo \u0026 message_info)\n {\n-  (void) message;\n-  (void) message_info;\n   throw rclcpp::exceptions::UnimplementedError(\n           \u0022handle_loaned_message is not implemented for GenericSubscription\u0022);\n }\n@@ -111,20 \u002B110,17 @@ GenericSubscription::create_dynamic_message()\n \n void\n GenericSubscription::return_dynamic_message(\n-  rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message)\n\u002B  [[maybe_unused]] rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message)\n {\n-  (void) message;\n   throw rclcpp::exceptions::UnimplementedError(\n           \u0022return_dynamic_message is not implemented for GenericSubscription\u0022);\n }\n \n void\n GenericSubscription::handle_dynamic_message(\n-  const rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message,\n-  const rclcpp::MessageInfo \u0026 message_info)\n\u002B  [[maybe_unused]] const rclcpp::dynamic_typesupport::DynamicMessage::SharedPtr \u0026 message,\n\u002B  [[maybe_unused]] const rclcpp::MessageInfo \u0026 message_info)\n {\n-  (void) message;\n-  (void) message_info;\n   throw rclcpp::exceptions::UnimplementedError(\n           \u0022handle_dynamic_message is not implemented for GenericSubscription\u0022);\n }\ndiff --git rclcpp/src/rclcpp/publisher_base.cpp rclcpp/src/rclcpp/publisher_base.cpp\nindex 0dc9b01a..bcade9b1 100644\n--- rclcpp/src/rclcpp/publisher_base.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/publisher_base.cpp\n@@ -367,10 \u002B367,8 @@ PublisherBase::default_incompatible_qos_callback(\n \n void\n PublisherBase::default_incompatible_type_callback(\n-  rclcpp::IncompatibleTypeInfo \u0026 event) const\n\u002B  [[maybe_unused]] rclcpp::IncompatibleTypeInfo \u0026 event) const\n {\n-  (void)event;\n-\n   RCLCPP_WARN(\n     rclcpp::get_logger(rcl_node_get_logger_name(rcl_node_handle_.get())),\n     \u0022Incompatible type on topic \u0027%s\u0027, no messages will be sent to it.\u0022, get_topic_name());\ndiff --git rclcpp/src/rclcpp/subscription_base.cpp rclcpp/src/rclcpp/subscription_base.cpp\nindex 7dca16a1..6e9ca700 100644\n--- rclcpp/src/rclcpp/subscription_base.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/subscription_base.cpp\n@@ -381,10 \u002B381,8 @@ SubscriptionBase::default_incompatible_qos_callback(\n \n void\n SubscriptionBase::default_incompatible_type_callback(\n-  rclcpp::IncompatibleTypeInfo \u0026 event) const\n\u002B  [[maybe_unused]] rclcpp::IncompatibleTypeInfo \u0026 event) const\n {\n-  (void)event;\n-\n   RCLCPP_WARN(\n     rclcpp::get_logger(rcl_node_get_logger_name(node_handle_.get())),\n     \u0022Incompatible type on topic \u0027%s\u0027, no messages will be sent to it.\u0022, get_topic_name());\ndiff --git rclcpp/test/rclcpp/executors/executor_types.hpp rclcpp/test/rclcpp/executors/executor_types.hpp\nindex baa13be9..0478eb0e 100644\n--- rclcpp/test/rclcpp/executors/executor_types.hpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/executor_types.hpp\n@@ -61,9 \u002B61,8 @@ class ExecutorTypeNames\n {\n public:\n   template\u003Ctypename T\u003E\n-  static std::string GetName(int idx)\n\u002B  static std::string GetName([[maybe_unused]] int idx)\n   {\n-    (void)idx;\n     if (std::is_same\u003CT, rclcpp::executors::SingleThreadedExecutor\u003E()) {\n       return \u0022SingleThreadedExecutor\u0022;\n     }\ndiff --git rclcpp/test/rclcpp/executors/test_events_executor.cpp rclcpp/test/rclcpp/executors/test_events_executor.cpp\nindex fa9c5177..44756704 100644\n--- rclcpp/test/rclcpp/executors/test_events_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_events_executor.cpp\n@@ -48,9 \u002B48,8 @@ TEST_F(TestEventsExecutor, run_pub_sub)\n   bool msg_received = false;\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n     \u0022topic\u0022, rclcpp::SensorDataQoS(),\n-    [\u0026msg_received](test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B    [\u0026msg_received]([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n     {\n-      (void)msg;\n       msg_received = true;\n     });\n \n@@ -115,8 \u002B114,8 @@ TEST_F(TestEventsExecutor, run_clients_servers)\n   auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n   client-\u003Easync_send_request(\n     request,\n-    [\u0026response_received](rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture result_future) {\n-      (void)result_future;\n\u002B    [\u0026response_received]([[maybe_unused]] rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture\n\u002B    result_future){\n       response_received = true;\n     });\n \ndiff --git rclcpp/test/rclcpp/executors/test_waitable.cpp rclcpp/test/rclcpp/executors/test_waitable.cpp\nindex dfae485f..da563c53 100644\n--- rclcpp/test/rclcpp/executors/test_waitable.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_waitable.cpp\n@@ -64,9 \u002B64,8 @@ TestWaitable::take_data()\n }\n \n std::shared_ptr\u003Cvoid\u003E\n-TestWaitable::take_data_by_entity_id(size_t id)\n\u002BTestWaitable::take_data_by_entity_id([[maybe_unused]] size_t id)\n {\n-  (void) id;\n   return nullptr;\n }\n \ndiff --git rclcpp/test/rclcpp/test_client_common.cpp rclcpp/test/rclcpp/test_client_common.cpp\nindex 62aa2c05..83b0232e 100644\n--- rclcpp/test/rclcpp/test_client_common.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_client_common.cpp\n@@ -184,9 \u002B184,8 @@ class ClientTypeNames\n {\n public:\n   template\u003Ctypename T\u003E\n-  static std::string GetName(int idx)\n\u002B  static std::string GetName([[maybe_unused]] int idx)\n   {\n-    (void)idx;\n     if (std::is_same_v\u003CT, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n       return \u0022Client\u0022;\n     }\ndiff --git rclcpp/test/rclcpp/test_function_traits.cpp rclcpp/test/rclcpp/test_function_traits.cpp\nindex 20c9521c..fc617c6c 100644\n--- rclcpp/test/rclcpp/test_function_traits.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_function_traits.cpp\n@@ -74,29 \u002B74,23 @@ struct FunctionObjectOneIntOneChar\n \n struct ObjectMember\n {\n-  int callback_one_bool(bool a)\n\u002B  int callback_one_bool([[maybe_unused]] bool a)\n   {\n-    (void)a;\n     return 7;\n   }\n \n-  int callback_one_bool_const(bool a) const\n\u002B  int callback_one_bool_const([[maybe_unused]] bool a) const\n   {\n-    (void)a;\n     return 7;\n   }\n \n-  int callback_two_bools(bool a, bool b)\n\u002B  int callback_two_bools([[maybe_unused]] bool a, [[maybe_unused]] bool b)\n   {\n-    (void)a;\n-    (void)b;\n     return 8;\n   }\n \n-  int callback_one_bool_one_float(bool a, float b)\n\u002B  int callback_one_bool_one_float([[maybe_unused]] bool a, [[maybe_unused]] float b)\n   {\n-    (void)a;\n-    (void)b;\n     return 9;\n   }\n };\n@@ -212,20 \u002B206,15 @@ TEST(TestFunctionTraits, arity) {\n       return 0;\n     };\n \n-  auto lambda_one_int = [](int one) {\n-      (void)one;\n\u002B  auto lambda_one_int = []([[maybe_unused]] int one) {\n       return 1;\n     };\n \n-  auto lambda_two_ints = [](int one, int two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_two_ints = []([[maybe_unused]] int one, [[maybe_unused]] int two) {\n       return 2;\n     };\n \n-  auto lambda_one_int_one_char = [](int one, char two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_one_int_one_char = []([[maybe_unused]] int one, [[maybe_unused]] char two) {\n       return 3;\n     };\n \n@@ -303,20 \u002B292,15 @@ TEST(TestFunctionTraits, argument_types) {\n     \u003E::value, \u0022Functor accepts a char as second argument\u0022);\n \n   // Test lambdas\n-  auto lambda_one_int = [](int one) {\n-      (void)one;\n\u002B  auto lambda_one_int = []([[maybe_unused]] int one) {\n       return 1;\n     };\n \n-  auto lambda_two_ints = [](int one, int two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_two_ints = []([[maybe_unused]] int one, [[maybe_unused]] int two) {\n       return 2;\n     };\n \n-  auto lambda_one_int_one_char = [](int one, char two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_one_int_one_char = []([[maybe_unused]] int one, [[maybe_unused]]  char two) {\n       return 3;\n     };\n \n@@ -533,22 \u002B517,17 @@ TEST(TestFunctionTraits, check_arguments) {\n     \u0022Functor accepts an int and a char as arguments\u0022);\n \n   // Test lambdas\n-  auto lambda_one_int = [](int one) {\n-      (void)one;\n\u002B  auto lambda_one_int = []([[maybe_unused]] int one) {\n       return 1;\n     };\n   (void)lambda_one_int;  // to quiet clang\n \n-  auto lambda_two_ints = [](int one, int two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_two_ints = []([[maybe_unused]] int one, [[maybe_unused]] int two) {\n       return 2;\n     };\n   (void)lambda_two_ints;  // to quiet clang\n \n-  auto lambda_one_int_one_char = [](int one, char two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_one_int_one_char = []([[maybe_unused]] int one, [[maybe_unused]]  char two) {\n       return 3;\n     };\n   (void)lambda_one_int_one_char;  // to quiet clang\n@@ -603,14 \u002B582,11 @@ TEST(TestFunctionTraits, check_arguments) {\n    Tests that same_arguments work.\n */\n TEST(TestFunctionTraits, same_arguments) {\n-  auto lambda_one_int = [](int one) {\n-      (void)one;\n\u002B  auto lambda_one_int = []([[maybe_unused]] int one) {\n       return 1;\n     };\n \n-  auto lambda_two_ints = [](int one, int two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_two_ints = []([[maybe_unused]] int one, [[maybe_unused]]  int two) {\n       return 1;\n     };\n \n@@ -658,8 \u002B634,7 @@ TEST(TestFunctionTraits, return_type) {\n     \u0022Functor return ints\u0022);\n \n   // Test lambda\n-  auto lambda_one_int_return_double = [](int one) -\u003E double {\n-      (void)one;\n\u002B  auto lambda_one_int_return_double = []([[maybe_unused]] int one) -\u003E double {\n       return 1.0;\n     };\n \n@@ -697,20 \u002B672,15 @@ TEST(TestFunctionTraits, sfinae_match) {\n       return 0;\n     };\n \n-  auto lambda_one_int = [](int one) {\n-      (void)one;\n\u002B  auto lambda_one_int = []([[maybe_unused]] int one) {\n       return 1;\n     };\n \n-  auto lambda_two_ints = [](int one, int two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_two_ints = []([[maybe_unused]] int one, [[maybe_unused]]  int two) {\n       return 2;\n     };\n \n-  auto lambda_one_int_one_char = [](int one, char two) {\n-      (void)one;\n-      (void)two;\n\u002B  auto lambda_one_int_one_char = []([[maybe_unused]] int one, [[maybe_unused]]  char two) {\n       return 3;\n     };\n \ndiff --git rclcpp/test/rclcpp/test_intra_process_manager.cpp rclcpp/test/rclcpp/test_intra_process_manager.cpp\nindex 6a4bfe56..6a253a42 100644\n--- rclcpp/test/rclcpp/test_intra_process_manager.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_intra_process_manager.cpp\n@@ -193,16 \u002B193,14 @@ public:\n   }\n \n   bool\n-  operator==(const rmw_gid_t \u0026 gid) const\n\u002B  operator==([[maybe_unused]] const rmw_gid_t \u0026 gid) const\n   {\n-    (void)gid;\n     return false;\n   }\n \n   bool\n-  operator==(const rmw_gid_t * gid) const\n\u002B  operator==([[maybe_unused]] const rmw_gid_t * gid) const\n   {\n-    (void)gid;\n     return false;\n   }\n \n@@ -260,12 \u002B258,12 @@ public:\n   RCLCPP_SMART_PTR_ALIASES_ONLY(SubscriptionIntraProcessBase)\n \n   explicit SubscriptionIntraProcessBase(\n-    rclcpp::Context::SharedPtr context,\n\u002B    [[maybe_unused]] rclcpp::Context::SharedPtr context,\n     const std::string \u0026 topic,\n     const rclcpp::QoS \u0026 qos)\n   : topic_name(topic), qos_profile(qos)\n   {\n-    (void)context;\n\u002B    // This function is intentionally left empty.\n   }\n \n   virtual ~SubscriptionIntraProcessBase() {}\ndiff --git rclcpp/test/rclcpp/test_intra_process_manager_with_allocators.cpp rclcpp/test/rclcpp/test_intra_process_manager_with_allocators.cpp\nindex 6d192ca8..823b00f3 100644\n--- rclcpp/test/rclcpp/test_intra_process_manager_with_allocators.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_intra_process_manager_with_allocators.cpp\n@@ -61,9 \u002B61,8 @@ public:\n     return static_cast\u003CT *\u003E(std::malloc(size * sizeof(T)));\n   }\n \n-  void deallocate(T * ptr, size_t size)\n\u002B  void deallocate(T * ptr, [[maybe_unused]] size_t size)\n   {\n-    (void)size;\n     if (!ptr) {\n       return;\n     }\ndiff --git rclcpp/test/rclcpp/test_parameter_client.cpp rclcpp/test/rclcpp/test_parameter_client.cpp\nindex a709d8cc..d0fa5b20 100644\n--- rclcpp/test/rclcpp/test_parameter_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_client.cpp\n@@ -34,9 \u002B34,9 @@ using namespace std::chrono_literals;\n class TestParameterClient : public ::testing::Test\n {\n public:\n-  void OnMessage(rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)\n\u002B  void OnMessage([[maybe_unused]] rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)\n   {\n-    (void)event;\n\u002B    // This function is intentionally left empty.\n   }\n \n protected:\ndiff --git rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\nindex eac46c1d..d2a01a8f 100644\n--- rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\n@@ -122,9 \u002B122,9 @@ public:\n   }\n \n protected:\n-  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B  static void OnMessage([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n \n   std::chrono::milliseconds offset{2000};\ndiff --git rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\nindex d70b0e38..0522c35e 100644\n--- rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\n@@ -88,21 \u002B88,18 @@ struct TypeAdapter\u003Cint, rclcpp::msg::String\u003E\n \n   static void\n   convert_to_ros_message(\n-    const custom_type \u0026 source,\n-    ros_message_type \u0026 destination)\n\u002B    [[maybe_unused]] const custom_type \u0026 source,\n\u002B    [[maybe_unused]] ros_message_type \u0026 destination)\n   {\n-    (void) source;\n-    (void) destination;\n     throw std::runtime_error(\u0022This should not happen\u0022);\n   }\n \n   static void\n   convert_to_custom(\n-    const ros_message_type \u0026 source,\n-    custom_type \u0026 destination)\n\u002B    [[maybe_unused]] const ros_message_type \u0026 source,\n\u002B    [[maybe_unused]] custom_type \u0026 destination)\n   {\n-    (void) source;\n-    (void) destination;\n\u002B    // This function is intentionally left empty.\n   }\n };\n \n@@ -165,9 \u002B162,9 @@ TEST_F(TestPublisher, conversion_exception_is_passed_up) {\n     options.use_intra_process_comms(is_intra_process);\n \n     auto callback =\n-      [](const rclcpp::msg::String::ConstSharedPtr msg) -\u003E void\n\u002B      []([[maybe_unused]] const rclcpp::msg::String::ConstSharedPtr msg) -\u003E void\n       {\n-        (void)msg;\n\u002B        // This function is intentionally left empty.\n       };\n \n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, options);\ndiff --git rclcpp/test/rclcpp/test_service_introspection.cpp rclcpp/test/rclcpp/test_service_introspection.cpp\nindex d037be3d..fddcafd5 100644\n--- rclcpp/test/rclcpp/test_service_introspection.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_service_introspection.cpp\n@@ -63,7 \u002B63,6 @@ protected:\n \n     auto callback = [this](const std::shared_ptr\u003Cconst BasicTypes::Event\u003E \u0026 msg) {\n         events.push_back(msg);\n-        (void)msg;\n       };\n \n     client = node-\u003Ecreate_client\u003CBasicTypes\u003E(\u0022service\u0022);\ndiff --git rclcpp/test/rclcpp/test_subscription.cpp rclcpp/test/rclcpp/test_subscription.cpp\nindex 06f6f978..7a5e30ca 100644\n--- rclcpp/test/rclcpp/test_subscription.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription.cpp\n@@ -36,9 \u002B36,9 @@ using namespace std::chrono_literals;\n class TestSubscription : public ::testing::Test\n {\n public:\n-  void on_message(test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B  void on_message([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n \n protected:\n@@ -66,8 \u002B66,8 @@ protected:\n TEST_F(TestSubscription, construction_and_destruction) {\n   initialize();\n   using test_msgs::msg::Empty;\n-  auto callback = [](Empty::ConstSharedPtr msg) {\n-      (void)msg;\n\u002B  auto callback = []([[maybe_unused]] Empty::ConstSharedPtr msg) {\n\u002B    // This function is intentionally left empty.\n     };\n   {\n     constexpr size_t depth = 10u;\n@@ -156,9 \u002B156,9 @@ public:\n   }\n \n private:\n-  void on_message(test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B  void on_message([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n };\n \n@@ -178,9 \u002B178,9 @@ public:\n   }\n \n private:\n-  void on_message(test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B  void on_message([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n };\n \n@@ -502,8 \u002B502,8 @@ TEST_F(TestSubscription, on_new_intra_process_message_callback) {\n TEST_F(TestSubscription, get_network_flow_endpoints_errors) {\n   initialize();\n   const rclcpp::QoS subscription_qos(1);\n-  auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr msg) {\n-      (void)msg;\n\u002B  auto subscription_callback = []([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg) {\n\u002B      // This function is intentionally left empty.\n     };\n   auto subscription = node_-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n     \u0022topic\u0022, subscription_qos, subscription_callback);\n@@ -560,8 \u002B560,8 @@ protected:\n    Testing subscription construction and destruction for subnodes.\n  */\n TEST_F(TestSubscriptionSub, construction_and_destruction) {\n-  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr msg) {\n-      (void)msg;\n\u002B  auto callback = []([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg) {\n\u002B    // This function is intentionally left empty.\n     };\n   {\n     auto sub = subnode_-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, 1, callback);\ndiff --git rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\nindex 92297e0e..131bc98b 100644\n--- rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\n@@ -108,9 \u002B108,9 @@ public:\n   }\n \n protected:\n-  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n\u002B  static void OnMessage([[maybe_unused]] test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n-    (void)msg;\n\u002B    // This function is intentionally left empty.\n   }\n \n   std::chrono::milliseconds offset{2000};\ndiff --git rclcpp/test/rclcpp/test_subscription_publisher_with_same_type_adapter.cpp rclcpp/test/rclcpp/test_subscription_publisher_with_same_type_adapter.cpp\nindex 5cee82c3..ffb47e94 100644\n--- rclcpp/test/rclcpp/test_subscription_publisher_with_same_type_adapter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_publisher_with_same_type_adapter.cpp\n@@ -57,21 \u002B57,17 @@ struct TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E\n \n   static void\n   convert_to_ros_message(\n-    const custom_type \u0026 source,\n-    ros_message_type \u0026 destination)\n\u002B    [[maybe_unused]] const custom_type \u0026 source,\n\u002B    [[maybe_unused]] ros_message_type \u0026 destination)\n   {\n-    (void) source;\n-    (void) destination;\n     throw std::runtime_error(\u0022This should not happen\u0022);\n   }\n \n   static void\n   convert_to_custom(\n-    const ros_message_type \u0026 source,\n-    custom_type \u0026 destination)\n\u002B    [[maybe_unused]] const ros_message_type \u0026 source,\n\u002B    [[maybe_unused]] custom_type \u0026 destination)\n   {\n-    (void) source;\n-    (void) destination;\n     throw std::runtime_error(\u0022This should not happen\u0022);\n   }\n };\ndiff --git rclcpp/test/rclcpp/test_subscription_traits.cpp rclcpp/test/rclcpp/test_subscription_traits.cpp\nindex c7b062ae..2b8a7115 100644\n--- rclcpp/test/rclcpp/test_subscription_traits.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_traits.cpp\n@@ -26,41 \u002B26,44 @@\n \n #include \u0022test_msgs/msg/empty.hpp\u0022\n \n-void serialized_callback_copy(rcl_serialized_message_t unused)\n\u002Bvoid serialized_callback_copy([[maybe_unused]] rcl_serialized_message_t unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n-void serialized_callback_shared_ptr(std::shared_ptr\u003Crcl_serialized_message_t\u003E unused)\n\u002Bvoid serialized_callback_shared_ptr(\n\u002B  [[maybe_unused]] std::shared_ptr\u003Crcl_serialized_message_t\u003E unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n-void not_serialized_callback(char * unused)\n\u002Bvoid not_serialized_callback([[maybe_unused]] char * unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n-void not_serialized_shared_ptr_callback(std::shared_ptr\u003Cchar\u003E unused)\n\u002Bvoid not_serialized_shared_ptr_callback([[maybe_unused]] std::shared_ptr\u003Cchar\u003E unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n void not_serialized_unique_ptr_callback(\n\u002B  [[maybe_unused]]\n   test_msgs::msg::Empty::UniquePtrWithDeleter\u003Crclcpp::allocator::Deleter\u003Cstd::allocator\u003Cvoid\u003E,\n   test_msgs::msg::Empty\u003E\u003E unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n-void rclcpp_serialized_callback_copy(rclcpp::SerializedMessage unused)\n\u002Bvoid rclcpp_serialized_callback_copy([[maybe_unused]] rclcpp::SerializedMessage unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n-void rclcpp_serialized_callback_shared_ptr(std::shared_ptr\u003Crclcpp::SerializedMessage\u003E unused)\n\u002Bvoid rclcpp_serialized_callback_shared_ptr(\n\u002B  [[maybe_unused]] std::shared_ptr\u003Crclcpp::SerializedMessage\u003E unused)\n {\n-  (void) unused;\n\u002B  // This function is intentionally left empty.\n }\n \n TEST(TestSubscriptionTraits, is_serialized_callback) {\n@@ -85,9 \u002B88,9 @@ TEST(TestSubscriptionTraits, is_serialized_callback) {\n     rclcpp::subscription_traits::is_serialized_callback\u003Cdecltype(cb4)\u003E::value == false,\n     \u0022passing a std::shared_tr\u003Cchar\u003E is not a serialized callback\u0022);\n \n-  auto cb5 = [](rcl_serialized_message_t unused) -\u003E void\n\u002B  auto cb5 = []([[maybe_unused]] rcl_serialized_message_t unused) -\u003E void\n     {\n-      (void) unused;\n\u002B      // This function is intentionally left empty.\n     };\n   static_assert(\n     rclcpp::subscription_traits::is_serialized_callback\u003Cdecltype(cb5)\u003E::value == false,\n@@ -96,9 \u002B99,10 @@ TEST(TestSubscriptionTraits, is_serialized_callback) {\n   using MessageT = test_msgs::msg::Empty;\n   using MessageTAllocator = std::allocator\u003Cvoid\u003E;\n   using MessageTDeallocator = rclcpp::allocator::Deleter\u003CMessageTAllocator, MessageT\u003E;\n-  auto cb6 = [](MessageT::UniquePtrWithDeleter\u003CMessageTDeallocator\u003E unique_msg_ptr) -\u003E void\n\u002B  auto cb6 = [](\n\u002B    [[maybe_unused]] MessageT::UniquePtrWithDeleter\u003CMessageTDeallocator\u003E unique_msg_ptr) -\u003E void\n     {\n-      (void) unique_msg_ptr;\n\u002B      // This function is intentionally left empty.\n     };\n   static_assert(\n     rclcpp::subscription_traits::is_serialized_callback\u003Cdecltype(cb6)\u003E::value == false,\n@@ -167,9 \u002B171,9 @@ TEST(TestSubscriptionTraits, callback_messages) {\n       rclcpp::subscription_traits::has_message_type\u003Cdecltype(cb4)\u003E::type\u003E::value,\n     \u0022not serialized shared_ptr callback message type is std::shared_ptr\u003Cchar\u003E\u0022);\n \n-  auto cb5 = [](rcl_serialized_message_t unused) -\u003E void\n\u002B  auto cb5 = []([[maybe_unused]] rcl_serialized_message_t unused) -\u003E void\n     {\n-      (void) unused;\n\u002B      // This function is intentionally left empty.\n     };\n   static_assert(\n     std::is_same\u003C\n@@ -180,9 \u002B184,10 @@ TEST(TestSubscriptionTraits, callback_messages) {\n   using MessageT = test_msgs::msg::Empty;\n   using MessageTAllocator = std::allocator\u003CMessageT\u003E;\n   using MessageTDeallocator = rclcpp::allocator::Deleter\u003CMessageTAllocator, MessageT\u003E;\n-  auto cb6 = [](std::unique_ptr\u003CMessageT, MessageTDeallocator\u003E unique_msg_ptr) -\u003E void\n\u002B  auto cb6 = [](\n\u002B    [[maybe_unused]] std::unique_ptr\u003CMessageT, MessageTDeallocator\u003E unique_msg_ptr) -\u003E void\n     {\n-      (void) unique_msg_ptr;\n\u002B      // This function is intentionally left empty.\n     };\n   static_assert(\n     std::is_same\u003C\ndiff --git rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\nindex a6fbbcbc..0137caf0 100644\n--- rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n@@ -189,8 \u002B189,8 @@ public:\n     options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n     options.topic_stats_options.publish_period = publish_period;\n \n-    auto callback = [](typename MessageT::UniquePtr msg) {\n-        (void) msg;\n\u002B    auto callback = []([[maybe_unused]] typename MessageT::UniquePtr msg) {\n\u002B        // This function is intentionally left empty.\n       };\n     subscription_ = create_subscription\u003CMessageT,\n         std::function\u003Cvoid(typename MessageT::UniquePtr)\u003E\u003E(\ndiff --git rclcpp_action/include/rclcpp_action/server.hpp rclcpp_action/include/rclcpp_action/server.hpp\nindex 0fe3be46..00490fa1 100644\n--- rclcpp_action/include/rclcpp_action/server.hpp\n\u002B\u002B\u002B rclcpp_action/include/rclcpp_action/server.hpp\n@@ -501,13 \u002B501,12 @@ protected:\n       };\n \n     std::function\u003Cvoid(const GoalUUID \u0026)\u003E on_executing =\n-      [weak_this](const GoalUUID \u0026 goal_uuid)\n\u002B      [weak_this]([[maybe_unused]] const GoalUUID \u0026 goal_uuid)\n       {\n         std::shared_ptr\u003CServer\u003CActionT\u003E\u003E shared_this = weak_this.lock();\n         if (!shared_this) {\n           return;\n         }\n-        (void)goal_uuid;\n         // Publish a status message any time a goal handle changes state\n         shared_this-\u003Epublish_status();\n       };\ndiff --git rclcpp_action/test/test_client.cpp rclcpp_action/test/test_client.cpp\nindex 08093cb8..743c10f7 100644\n--- rclcpp_action/test/test_client.cpp\n\u002B\u002B\u002B rclcpp_action/test/test_client.cpp\n@@ -545,11 \u002B545,9 @@ TEST_F(TestClientAgainstServer, async_send_goal_with_feedback_callback_wait_for_\n   int feedback_count = 0;\n   auto send_goal_ops = rclcpp_action::Client\u003CActionType\u003E::SendGoalOptions();\n   send_goal_ops.feedback_callback = [\u0026feedback_count](\n-    typename ActionGoalHandle::SharedPtr goal_handle,\n-    const std::shared_ptr\u003Cconst ActionFeedback\u003E feedback)\n\u002B    [[maybe_unused]] typename ActionGoalHandle::SharedPtr goal_handle,\n\u002B    [[maybe_unused]] const std::shared_ptr\u003Cconst ActionFeedback\u003E feedback)\n     {\n-      (void)goal_handle;\n-      (void)feedback;\n       feedback_count\u002B\u002B;\n     };\n   auto future_goal_handle = action_client-\u003Easync_send_goal(goal, send_goal_ops);\ndiff --git rclcpp_components/src/component_manager.cpp rclcpp_components/src/component_manager.cpp\nindex ee901c2f..636c6e08 100644\n--- rclcpp_components/src/component_manager.cpp\n\u002B\u002B\u002B rclcpp_components/src/component_manager.cpp\n@@ -253,12 \u002B253,10 @@ ComponentManager::remove_node_from_executor(uint64_t node_id)\n \n void\n ComponentManager::on_load_node(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n   const std::shared_ptr\u003CLoadNode::Request\u003E request,\n   std::shared_ptr\u003CLoadNode::Response\u003E response)\n {\n-  (void) request_header;\n-\n   try {\n     auto resources = get_component_resources(request-\u003Epackage_name);\n \n@@ -322,12 \u002B320,10 @@ ComponentManager::on_load_node(\n \n void\n ComponentManager::on_unload_node(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n   const std::shared_ptr\u003CUnloadNode::Request\u003E request,\n   std::shared_ptr\u003CUnloadNode::Response\u003E response)\n {\n-  (void) request_header;\n-\n   auto wrapper = node_wrappers_.find(request-\u003Eunique_id);\n \n   if (wrapper == node_wrappers_.end()) {\n@@ -345,13 \u002B341,10 @@ ComponentManager::on_unload_node(\n \n void\n ComponentManager::on_list_nodes(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n-  const std::shared_ptr\u003CListNodes::Request\u003E request,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003CListNodes::Request\u003E request,\n   std::shared_ptr\u003CListNodes::Response\u003E response)\n {\n-  (void) request_header;\n-  (void) request;\n-\n   for (auto \u0026 wrapper : node_wrappers_) {\n     response-\u003Eunique_ids.push_back(wrapper.first);\n     response-\u003Efull_node_names.push_back(\ndiff --git rclcpp_lifecycle/src/lifecycle_node_interface_impl.cpp rclcpp_lifecycle/src/lifecycle_node_interface_impl.cpp\nindex cb6eaf1d..1a955547 100644\n--- rclcpp_lifecycle/src/lifecycle_node_interface_impl.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node_interface_impl.cpp\n@@ -208,11 \u002B208,10 @@ LifecycleNode::LifecycleNodeInterfaceImpl::register_callback(\n \n void\n LifecycleNode::LifecycleNodeInterfaceImpl::on_change_state(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n   const std::shared_ptr\u003CChangeStateSrv::Request\u003E req,\n   std::shared_ptr\u003CChangeStateSrv::Response\u003E resp)\n {\n-  (void)header;\n   std::uint8_t transition_id;\n   {\n     std::lock_guard\u003Cstd::recursive_mutex\u003E lock(state_machine_mutex_);\n@@ -252,12 \u002B251,10 @@ LifecycleNode::LifecycleNodeInterfaceImpl::on_change_state(\n \n void\n LifecycleNode::LifecycleNodeInterfaceImpl::on_get_state(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n-  const std::shared_ptr\u003CGetStateSrv::Request\u003E req,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003CGetStateSrv::Request\u003E req,\n   std::shared_ptr\u003CGetStateSrv::Response\u003E resp) const\n {\n-  (void)header;\n-  (void)req;\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(state_machine_mutex_);\n   if (rcl_lifecycle_state_machine_is_initialized(\u0026state_machine_) != RCL_RET_OK) {\n     throw std::runtime_error(\n@@ -269,12 \u002B266,10 @@ LifecycleNode::LifecycleNodeInterfaceImpl::on_get_state(\n \n void\n LifecycleNode::LifecycleNodeInterfaceImpl::on_get_available_states(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n-  const std::shared_ptr\u003CGetAvailableStatesSrv::Request\u003E req,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003CGetAvailableStatesSrv::Request\u003E req,\n   std::shared_ptr\u003CGetAvailableStatesSrv::Response\u003E resp) const\n {\n-  (void)header;\n-  (void)req;\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(state_machine_mutex_);\n   if (rcl_lifecycle_state_machine_is_initialized(\u0026state_machine_) != RCL_RET_OK) {\n     throw std::runtime_error(\n@@ -292,12 \u002B287,10 @@ LifecycleNode::LifecycleNodeInterfaceImpl::on_get_available_states(\n \n void\n LifecycleNode::LifecycleNodeInterfaceImpl::on_get_available_transitions(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n-  const std::shared_ptr\u003CGetAvailableTransitionsSrv::Request\u003E req,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003CGetAvailableTransitionsSrv::Request\u003E req,\n   std::shared_ptr\u003CGetAvailableTransitionsSrv::Response\u003E resp) const\n {\n-  (void)header;\n-  (void)req;\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(state_machine_mutex_);\n   if (rcl_lifecycle_state_machine_is_initialized(\u0026state_machine_) != RCL_RET_OK) {\n     throw std::runtime_error(\n@@ -320,12 \u002B313,10 @@ LifecycleNode::LifecycleNodeInterfaceImpl::on_get_available_transitions(\n \n void\n LifecycleNode::LifecycleNodeInterfaceImpl::on_get_transition_graph(\n-  const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n-  const std::shared_ptr\u003CGetAvailableTransitionsSrv::Request\u003E req,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003Crmw_request_id_t\u003E header,\n\u002B  [[maybe_unused]] const std::shared_ptr\u003CGetAvailableTransitionsSrv::Request\u003E req,\n   std::shared_ptr\u003CGetAvailableTransitionsSrv::Response\u003E resp) const\n {\n-  (void)header;\n-  (void)req;\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(state_machine_mutex_);\n   if (rcl_lifecycle_state_machine_is_initialized(\u0026state_machine_) != RCL_RET_OK) {\n     throw std::runtime_error(\ndiff --git rclcpp_lifecycle/test/test_lifecycle_node.cpp rclcpp_lifecycle/test/test_lifecycle_node.cpp\nindex 70993af6..d22f981a 100644\n--- rclcpp_lifecycle/test/test_lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_node.cpp\n@@ -822,9 \u002B822,8 @@ TEST_F(TestDefaultStateMachine, test_callback_groups) {\n   auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n   size_t num_groups = 0;\n   test_node-\u003Efor_each_callback_group(\n-    [\u0026num_groups](rclcpp::CallbackGroup::SharedPtr group_ptr)\n\u002B    [\u0026num_groups]([[maybe_unused]] rclcpp::CallbackGroup::SharedPtr group_ptr)\n     {\n-      (void)group_ptr;\n       num_groups\u002B\u002B;\n     });\n   EXPECT_EQ(num_groups, 1u);\n@@ -835,9 \u002B834,8 @@ TEST_F(TestDefaultStateMachine, test_callback_groups) {\n \n   num_groups = 0;\n   test_node-\u003Efor_each_callback_group(\n-    [\u0026num_groups](rclcpp::CallbackGroup::SharedPtr group_ptr)\n\u002B    [\u0026num_groups]([[maybe_unused]] rclcpp::CallbackGroup::SharedPtr group_ptr)\n     {\n-      (void)group_ptr;\n       num_groups\u002B\u002B;\n     });\n   EXPECT_EQ(num_groups, 2u);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_logging",
    "SHA": "c8d466d9a0aacdb4974515fc249dc5a2327dcf6b",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master. (#127)",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\ndeleted file mode 100644\nindex 2885eb4..0000000\n--- .github/workflows/mirror-rolling-to-master.yaml\n\u002B\u002B\u002B /dev/null\n@@ -1,13 \u002B0,0 @@\n-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\ndiff --git CODEOWNERS CODEOWNERS\ndeleted file mode 100644\nindex cb949d5..0000000\n--- CODEOWNERS\n\u002B\u002B\u002B /dev/null\n@@ -1,2 \u002B0,0 @@\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @clalancette @wjwwood\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "5f9695afb02f178ec739fa1591bb018a9f9b2be0",
    "RawMessage": "Trigger the intraprocess guard condition with data (#2164)",
    "Changes": "diff --git rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\nindex 91ea91a7..ec89ebc5 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\n@@ -118,6 \u002B118,13 @@ public:\n         return nullptr;\n       }\n     }\n\u002B\n\u002B    if (this-\u003Ebuffer_-\u003Ehas_data()) {\n\u002B      // If there is data still to be processed, indicate to the\n\u002B      // executor or waitset by triggering the guard condition.\n\u002B      this-\u003Etrigger_guard_condition();\n\u002B    }\n\u002B\n     return std::static_pointer_cast\u003Cvoid\u003E(\n       std::make_shared\u003Cstd::pair\u003CConstMessageSharedPtr, MessageUniquePtr\u003E\u003E(\n         std::pair\u003CConstMessageSharedPtr, MessageUniquePtr\u003E(\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 1fa2cbb4..eb6652f1 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -593,3 \u002B593,106 @@ TEST(TestExecutors, testSpinUntilFutureCompleteNodePtr) {\n \n   rclcpp::shutdown();\n }\n\u002B\n\u002Btemplate\u003Ctypename T\u003E\n\u002Bclass TestIntraprocessExecutors : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void SetUp()\n\u002B  {\n\u002B    const auto test_info = ::testing::UnitTest::GetInstance()-\u003Ecurrent_test_info();\n\u002B    std::stringstream test_name;\n\u002B    test_name \u003C\u003C test_info-\u003Etest_case_name() \u003C\u003C \u0022_\u0022 \u003C\u003C test_info-\u003Ename();\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, test_name.str());\n\u002B\n\u002B    callback_count = 0;\n\u002B\n\u002B    const std::string topic_name = std::string(\u0022topic_\u0022) \u002B test_name.str();\n\u002B\n\u002B    rclcpp::PublisherOptions po;\n\u002B    po.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n\u002B    publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(topic_name, rclcpp::QoS(1), po);\n\u002B\n\u002B    auto callback = [this](test_msgs::msg::Empty::ConstSharedPtr) {\n\u002B        this-\u003Ecallback_count.fetch_add(1);\n\u002B      };\n\u002B\n\u002B    rclcpp::SubscriptionOptions so;\n\u002B    so.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n\u002B    subscription =\n\u002B      node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, rclcpp::QoS(kNumMessages), std::move(callback), so);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    publisher.reset();\n\u002B    subscription.reset();\n\u002B    node.reset();\n\u002B  }\n\u002B\n\u002B  const size_t kNumMessages = 100;\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B  rclcpp::Publisher\u003Ctest_msgs::msg::Empty\u003E::SharedPtr publisher;\n\u002B  rclcpp::Subscription\u003Ctest_msgs::msg::Empty\u003E::SharedPtr subscription;\n\u002B  std::atomic_int callback_count;\n\u002B};\n\u002B\n\u002BTYPED_TEST_SUITE(TestIntraprocessExecutors, ExecutorTypes, ExecutorTypeNames);\n\u002B\n\u002BTYPED_TEST(TestIntraprocessExecutors, testIntraprocessRetrigger) {\n\u002B  // This tests that executors will continue to service intraprocess subscriptions in the case\n\u002B  // that publishers aren\u0027t continuing to publish.\n\u002B  // This was previously broken in that intraprocess guard conditions were only triggered on\n\u002B  // publish and the test was added to prevent future regressions.\n\u002B  const size_t kNumMessages = 100;\n\u002B\n\u002B  using ExecutorType = TypeParam;\n\u002B  ExecutorType executor;\n\u002B  executor.add_node(this-\u003Enode);\n\u002B\n\u002B  EXPECT_EQ(0, this-\u003Ecallback_count.load());\n\u002B  this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B\n\u002B  // Wait for up to 5 seconds for the first message to come available.\n\u002B  const std::chrono::milliseconds sleep_per_loop(10);\n\u002B  int loops = 0;\n\u002B  while (1u != this-\u003Ecallback_count.load() \u0026\u0026 loops \u003C 500) {\n\u002B    rclcpp::sleep_for(sleep_per_loop);\n\u002B    executor.spin_some();\n\u002B    loops\u002B\u002B;\n\u002B  }\n\u002B  EXPECT_EQ(1u, this-\u003Ecallback_count.load());\n\u002B\n\u002B  // reset counter\n\u002B  this-\u003Ecallback_count.store(0);\n\u002B\n\u002B  for (size_t ii = 0; ii \u003C kNumMessages; \u002B\u002Bii) {\n\u002B    this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B  }\n\u002B\n\u002B  // Fire a timer every 10ms up to 5 seconds waiting for subscriptions to be read.\n\u002B  loops = 0;\n\u002B  auto timer = this-\u003Enode-\u003Ecreate_wall_timer(\n\u002B    std::chrono::milliseconds(10), [this, \u0026executor, \u0026loops, \u0026kNumMessages]() {\n\u002B      loops\u002B\u002B;\n\u002B      if (kNumMessages == this-\u003Ecallback_count.load() ||\n\u002B      loops == 500)\n\u002B      {\n\u002B        executor.cancel();\n\u002B      }\n\u002B    });\n\u002B  executor.spin();\n\u002B  EXPECT_EQ(kNumMessages, this-\u003Ecallback_count.load());\n\u002B}\n",
    "BackportedTo": "humble",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "74c54c50f60cf1da607067091d2b97ec44ac6c4d",
    "RawMessage": "Fix a memory leak when using the ResourceIOSystem. (#641)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\nindex 63518c44..8433af9f 100644\n--- rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/mesh_loader_helpers/assimp_loader.cpp\n@@ -136,19 \u002B136,9 @@ private:\n   uint8_t * pos_;\n };\n \n-class ResourceIOSystem : public Assimp::IOSystem\n\u002Bclass ResourceIOSystem final : public Assimp::IOSystem\n {\n public:\n-  struct RetrieverResult\n-  {\n-    RetrieverResult(bool resource_exists, Assimp::IOStream * resource_io_stream)\n-    : resource_exists_(resource_exists),\n-      resource_io_stream_(resource_io_stream) {}\n-\n-    bool resource_exists_;\n-    Assimp::IOStream * resource_io_stream_;\n-  };\n-\n   ResourceIOSystem() = default;\n \n   ~ResourceIOSystem() override = default;\n@@ -162,16 \u002B152,18 @@ public:\n   // Check whether a specific file exists\n   bool Exists(const char * file) const override\n   {\n-    return checkExistsAndOpen(file).resource_exists_;\n\u002B    try {\n\u002B      resource_retriever::MemoryResource res = retriever_.get(file);\n\u002B    } catch (const resource_retriever::Exception \u0026 e) {\n\u002B      (void) e;  // do nothing on exception\n\u002B      return false;\n\u002B    }\n\u002B\n\u002B    return true;\n   }\n \n   // ... and finally a method to open a custom stream\n   Assimp::IOStream * Open(const char * file, const char * mode = \u0022rb\u0022) override\n-  {\n-    return checkExistsAndOpen(file, mode).resource_io_stream_;\n-  }\n-\n-  RetrieverResult checkExistsAndOpen(const char * file, const char * mode = \u0022rb\u0022) const\n   {\n     (void) mode;\n     assert(mode == std::string(\u0022r\u0022) || mode == std::string(\u0022rb\u0022));\n@@ -179,12 \u002B171,13 @@ public:\n     resource_retriever::MemoryResource res;\n     try {\n       res = retriever_.get(file);\n-    } catch (resource_retriever::Exception \u0026 e) {\n\u002B    } catch (const resource_retriever::Exception \u0026 e) {\n       (void) e;  // do nothing on exception\n-      return RetrieverResult(false, nullptr);\n\u002B      return nullptr;\n     }\n \n-    return RetrieverResult(true, new ResourceIOStream(res));\n\u002B    // This will get freed when \u0027Close\u0027 is called\n\u002B    return new ResourceIOStream(res);\n   }\n \n   void Close(Assimp::IOStream * stream) override\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "3299fca6e4dcd54ace6176eeceec3828411ceec4",
    "RawMessage": "Add sequence numbers to message info structure (#318)",
    "Changes": "diff --git rmw/include/rmw/features.h rmw/include/rmw/features.h\nnew file mode 100644\nindex 0000000..367b586\n--- /dev/null\n\u002B\u002B\u002B rmw/include/rmw/features.h\n@@ -0,0 \u002B1,63 @@\n\u002B// Copyright 2022 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B\n\u002B#ifndef RMW__FEATURES_H_\n\u002B#define RMW__FEATURES_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B#include \u003Cstdint.h\u003E\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B\n\u002B#include \u0022rmw/macros.h\u0022\n\u002B#include \u0022rmw/types.h\u0022\n\u002B#include \u0022rmw/ret_types.h\u0022\n\u002B#include \u0022rmw/visibility_control.h\u0022\n\u002B\n\u002B/// List of optional rmw features.\n\u002B/**\n\u002B * Some of the features listed here might become mandatory in the feature, in which case all rmw\n\u002B * implementations should return \u0060true\u0060.\n\u002B *\n\u002B * There might be some optional features that are not listed here, but the goal is to have all of\n\u002B * them added.\n\u002B */\n\u002Btypedef enum RMW_PUBLIC_TYPE rmw_feature_e\n\u002B{\n\u002B  /// \u0060rmw_message_info_t.publication_sequence_number\u0060 is filled correctly\n\u002B  /// by the rmw implementation.\n\u002B  RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER = 0,\n\u002B  /// \u0060rmw_message_info_t.reception_sequence_number\u0060 is filled correctly\n\u002B  /// by the rmw implementation.\n\u002B  RMW_FEATURE_MESSAGE_INFO_RECEPTION_SEQUENCE_NUMBER = 1,\n\u002B} rmw_feature_t;\n\u002B\n\u002B/// Query if a feature is supported by the rmw implementation.\n\u002B/**\n\u002B * \\return \u0060true\u0060 if the rmw implementation supports the feature, \u0060false\u0060 if not.\n\u002B */\n\u002BRMW_PUBLIC\n\u002Bbool\n\u002Brmw_feature_supported(rmw_feature_t feature);\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // RMW__FEATURES_H_\ndiff --git rmw/include/rmw/types.h rmw/include/rmw/types.h\nindex 0ba286f..4f08ea5 100644\n--- rmw/include/rmw/types.h\n\u002B\u002B\u002B rmw/include/rmw/types.h\n@@ -515,11 \u002B515,89 @@ typedef struct RMW_PUBLIC_TYPE rmw_gid_s\n   uint8_t data[RMW_GID_STORAGE_SIZE];\n } rmw_gid_t;\n \n\u002B#define RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED UINT64_MAX\n\u002B\n /// Information describing an rmw message\n typedef struct RMW_PUBLIC_TYPE rmw_message_info_s\n {\n\u002B  /// Time when the message was published by the publisher.\n\u002B  /**\n\u002B   * The exact point at which the timestamp is taken is not specified, but\n\u002B   * it should be taken consistently at the same point in the\n\u002B   * publishing process each time.\n\u002B   */\n   rmw_time_point_value_t source_timestamp;\n\u002B  /// Time when the message was received by the subscription.\n\u002B  /**\n\u002B   * The exact point at which the timestamp is taken is not specified, but\n\u002B   * it should be taken consistently at the same point in the\n\u002B   * process of receiving a message each time.\n\u002B   */\n   rmw_time_point_value_t received_timestamp;\n\u002B  /// Sequence number of the received message set by the publisher.\n\u002B  /**\n\u002B   * This sequence number is set by the publisher and therefore uniquely identifies\n\u002B   * a message when combined with the publisher GID.\n\u002B   * For long running applications, the sequence number might wrap around at some point.\n\u002B   *\n\u002B   * If the rmw implementation doesn\u0027t support sequence numbers, its value will be\n\u002B   * RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n\u002B   *\n\u002B   * Requirements:\n\u002B   *\n\u002B   * If \u0060psn1\u0060 and \u0060psn2\u0060 are the publication sequence numbers obtained by\n\u002B   * calls to \u0060rmw_take*()\u0060, where \u0060psn1\u0060 was obtained in a call that happened before \u0060psn2\u0060 and both\n\u002B   * sequence numbers are from the same publisher (i.e. also same publisher gid), then:\n\u002B   *\n\u002B   * - psn2 \u003E psn1 (except in the case of a wrap around)\n\u002B   * - \u0060psn2 - psn1 - 1\u0060 is the number of messages the publisher sent in the middle of both\n\u002B   *   received messages.\n\u002B   *   Those might have already been taken by other \u0060rmw_take*()\u0060 calls that happened in between or lost.\n\u002B   *   \u0060psn2 - psn1 - 1 = 0\u0060 if and only if the messages were sent by the publisher consecutively.\n\u002B   */\n\u002B  uint64_t publication_sequence_number;\n\u002B  /// Sequence number of the received message set by the subscription.\n\u002B  /**\n\u002B   * This sequence number is set by the subscription regardless of which\n\u002B   * publisher sent the message.\n\u002B   * For long running applications, the sequence number might wrap around at some point.\n\u002B   *\n\u002B   * If the rmw implementation doesn\u0027t support sequence numbers, its value will be\n\u002B   * RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.\n\u002B   *\n\u002B   * Requirements:\n\u002B   *\n\u002B   * If \u0060rsn1\u0060 and \u0060rsn2\u0060 are the reception sequence numbers obtained by\n\u002B   * calls to \u0060rmw_take*()\u0060, where \u0060rsn1\u0060 was obtained in a call that happened before \u0060rsn2\u0060, then:\n\u002B   *\n\u002B   * - rsn2 \u003E rsn1 (except in the case of a wrap around)\n\u002B   * - \u0060rsn2 = rsn1 \u002B 1\u0060 if and only if both \u0060rmw_take*()\u0060 calls happened consecutively.\n\u002B   */\n\u002B  uint64_t reception_sequence_number;\n\u002B  /// Global unique identifier of the publisher that sent the message.\n\u002B  /**\n\u002B   * The identifier uniquely identifies the publisher for the local context, but\n\u002B   * it will not necessarily be the same identifier given in other contexts or processes\n\u002B   * for the same publisher.\n\u002B   * Therefore the identifier will uniquely identify the publisher within your application\n\u002B   * but may disagree about the identifier for that publisher when compared to another\n\u002B   * application.\n\u002B   * Even with this limitation, when combined with the publisher sequence number it can\n\u002B   * uniquely identify a message within your local context.\n\u002B   * Publisher GIDs generated by the rmw implementation could collide at some point, in which\n\u002B   * case it is not possible to distinguish which publisher sent the message.\n\u002B   * The details of how GIDs are generated are rmw implementation dependent.\n\u002B   *\n\u002B   * It is possible the the rmw implementation needs to reuse a publisher GID,\n\u002B   * due to running out of unique identifiers or some other constraint, in which case\n\u002B   * the rmw implementation may document what happens in that case, but that\n\u002B   * behavior is not defined here.\n\u002B   * However, this should be avoided, if at all possible, by the rmw implementation,\n\u002B   * and should be unlikely to happen in practice.\n\u002B   *\n\u002B   * \\todo In the future we want this to uniquely identify the publisher globally across\n\u002B   *   contexts, processes, and machines.\n\u002B   */\n   rmw_gid_t publisher_gid;\n \n   /// Whether this message is from intra_process communication or not\ndiff --git rmw/src/types.c rmw/src/types.c\nindex 422ba07..dfb79dc 100644\n--- rmw/src/types.c\n\u002B\u002B\u002B rmw/src/types.c\n@@ -19,6 \u002B19,6 @@ RMW_WARN_UNUSED\n rmw_message_info_t\n rmw_get_zero_initialized_message_info(void)\n {\n-  rmw_message_info_t zero_initialized_message_info = {0, 0, {NULL, {0}}, false};\n\u002B  rmw_message_info_t zero_initialized_message_info = {0};\n   return zero_initialized_message_info;\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "b03ad4d9af032d834206e9fe344c8c5f535d3da3",
    "RawMessage": "Added rmw_publisher_allocation and rmw_subscription_allocation related tests (#137)",
    "Changes": "diff --git test_rmw_implementation/CMakeLists.txt test_rmw_implementation/CMakeLists.txt\nindex 5b84983..48b1f0a 100644\n--- test_rmw_implementation/CMakeLists.txt\n\u002B\u002B\u002B test_rmw_implementation/CMakeLists.txt\n@@ -90,6 \u002B90,25 @@ if(BUILD_TESTING)\n       rcutils rmw rmw_implementation test_msgs\n     )\n \n\u002B    ament_add_gtest(test_publisher_allocator${target_suffix}\n\u002B      test/test_publisher_allocator.cpp\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n\u002B    target_compile_definitions(test_publisher_allocator${target_suffix}\n\u002B      PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n\u002B    ament_target_dependencies(test_publisher_allocator${target_suffix}\n\u002B      rmw rmw_implementation\n\u002B    )\n\u002B    ament_add_gtest(test_subscription_allocator${target_suffix}\n\u002B      test/test_subscription_allocator.cpp\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n\u002B    target_compile_definitions(test_subscription_allocator${target_suffix}\n\u002B      PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n\u002B    ament_target_dependencies(test_subscription_allocator${target_suffix}\n\u002B      rmw rmw_implementation\n\u002B    )\n\u002B\n     ament_add_gtest(test_graph_api${target_suffix}\n       test/test_graph_api.cpp\n       ENV ${rmw_implementation_env_var}\ndiff --git test_rmw_implementation/test/test_publisher_allocator.cpp test_rmw_implementation/test/test_publisher_allocator.cpp\nnew file mode 100644\nindex 0000000..51b6b18\n--- /dev/null\n\u002B\u002B\u002B test_rmw_implementation/test/test_publisher_allocator.cpp\n@@ -0,0 \u002B1,36 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B\n\u002B#ifdef RMW_IMPLEMENTATION\n\u002B# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n\u002B# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n\u002B#else\n\u002B# define CLASSNAME(NAME, SUFFIX) NAME\n\u002B#endif\n\u002B\n\u002Bclass CLASSNAME (TestPublisherAllocator, RMW_IMPLEMENTATION) : public ::testing::Test {};\n\u002B\n\u002BTEST_F(CLASSNAME(TestPublisherAllocator, RMW_IMPLEMENTATION), init_fini_publisher_allocation)\n\u002B{\n\u002B  if (rmw_init_publisher_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n\u002B    // Add tests here when the implementation it\u0027s supported\n\u002B    GTEST_SKIP();\n\u002B  } else {\n\u002B    rmw_ret_t ret = rmw_fini_publisher_allocation(nullptr);\n\u002B    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n\u002B  }\n\u002B}\ndiff --git test_rmw_implementation/test/test_subscription_allocator.cpp test_rmw_implementation/test/test_subscription_allocator.cpp\nnew file mode 100644\nindex 0000000..9ee0b34\n--- /dev/null\n\u002B\u002B\u002B test_rmw_implementation/test/test_subscription_allocator.cpp\n@@ -0,0 \u002B1,36 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B\n\u002B#ifdef RMW_IMPLEMENTATION\n\u002B# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n\u002B# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n\u002B#else\n\u002B# define CLASSNAME(NAME, SUFFIX) NAME\n\u002B#endif\n\u002B\n\u002Bclass CLASSNAME (TestSubscriptionAllocator, RMW_IMPLEMENTATION) : public ::testing::Test {};\n\u002B\n\u002BTEST_F(CLASSNAME(TestSubscriptionAllocator, RMW_IMPLEMENTATION), init_fini_subscription_allocation)\n\u002B{\n\u002B  if (rmw_init_subscription_allocation(nullptr, nullptr, nullptr) != RMW_RET_UNSUPPORTED) {\n\u002B    // Add tests here when the implementation it\u0027s supported\n\u002B    GTEST_SKIP();\n\u002B  } else {\n\u002B    rmw_ret_t ret = rmw_fini_subscription_allocation(nullptr);\n\u002B    EXPECT_EQ(ret, RMW_RET_UNSUPPORTED);\n\u002B  }\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "8948499b4898b8ed13c21b77532c17761310e523",
    "RawMessage": "Add method in Node to resolve a topic or service name (#636)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex b574015..2c28053 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -1091,6 \u002B1091,32 @@ class Node:\n         self.__waitables.remove(waitable)\n         self._wake_executor()\n \n\u002B    def resolve_topic_name(self, topic: str, *, only_expand: bool = False) -\u003E str:\n\u002B        \u0022\u0022\u0022\n\u002B        Return a topic name expanded and remapped.\n\u002B\n\u002B        :param topic: topic name to be expanded and remapped.\n\u002B        :param only_expand: if \u0060True\u0060, remapping rules won\u0027t be applied.\n\u002B        :return: a fully qualified topic name,\n\u002B            result of applying expansion and remapping to the given \u0060topic\u0060.\n\u002B        \u0022\u0022\u0022\n\u002B        with self.handle as capsule:\n\u002B            return _rclpy.rclpy_resolve_name(capsule, topic, only_expand, False)\n\u002B\n\u002B    def resolve_service_name(\n\u002B        self, service: str, *, only_expand: bool = False\n\u002B    ) -\u003E str:\n\u002B        \u0022\u0022\u0022\n\u002B        Return a service name expanded and remapped.\n\u002B\n\u002B        :param service: service name to be expanded and remapped.\n\u002B        :param only_expand: if \u0060True\u0060, remapping rules won\u0027t be applied.\n\u002B        :return: a fully qualified service name,\n\u002B            result of applying expansion and remapping to the given \u0060service\u0060.\n\u002B        \u0022\u0022\u0022\n\u002B        with self.handle as capsule:\n\u002B            return _rclpy.rclpy_resolve_name(capsule, service, only_expand, True)\n\u002B\n     def create_publisher(\n         self,\n         msg_type,\ndiff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 6102ec5..08b4fb4 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -1693,6 \u002B1693,61 @@ rclpy_remap_topic_name(PyObject * Py_UNUSED(self), PyObject * args)\n   return result;\n }\n \n\u002B\n\u002B/// Expand and remap a topic name\n\u002B/**\n\u002B * Raises ValueError if the capsule is not the correct type\n\u002B *\n\u002B * \\param[in] pynode Capsule pointing to the node\n\u002B * \\param[in] topic_name topic string to be remapped\n\u002B * \\param[in] only_expand when \u0060false\u0060, remapping rules are ignored\n\u002B * \\param[in] is_service \u0060true\u0060 for service names, \u0060false\u0060 for topic names\n\u002B * \\return expanded and remapped topic name\n\u002B */\n\u002Bstatic PyObject *\n\u002Brclpy_resolve_name(PyObject * Py_UNUSED(self), PyObject * args)\n\u002B{\n\u002B  PyObject * pynode = NULL;\n\u002B  const char * name = NULL;\n\u002B  int only_expand = false;\n\u002B  int is_service = false;\n\u002B\n\u002B\n\u002B  if (!PyArg_ParseTuple(args, \u0022Ospp\u0022, \u0026pynode, \u0026name, \u0026only_expand, \u0026is_service)) {\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  const rcl_node_t * node = rclpy_handle_get_pointer_from_capsule(pynode, \u0022rcl_node_t\u0022);\n\u002B  if (node == NULL) {\n\u002B    return NULL;\n\u002B  }\n\u002B  const rcl_node_options_t * node_options = rcl_node_get_options(node);\n\u002B  if (node_options == NULL) {\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  char * output_cstr = NULL;\n\u002B  rcl_ret_t ret = rcl_node_resolve_name(\n\u002B    node,\n\u002B    name,\n\u002B    node_options-\u003Eallocator,\n\u002B    is_service,\n\u002B    only_expand,\n\u002B    \u0026output_cstr);\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    PyErr_Format(\n\u002B      PyExc_RuntimeError, \u0022Failed to resolve name %s: %s\u0022, name, rcl_get_error_string().str);\n\u002B    rcl_reset_error();\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  PyObject * result = PyUnicode_FromString(output_cstr);\n\u002B  node_options-\u003Eallocator.deallocate(output_cstr, node_options-\u003Eallocator.state);\n\u002B\n\u002B  return result;\n\u002B}\n\u002B\n\u002B\n /// Handle destructor for publisher\n static void\n _rclpy_destroy_publisher(void * p)\n@@ -5697,6 \u002B5752,10 @@ static PyMethodDef rclpy_methods[] = {\n     rclpy_get_validation_error_for_node_name, METH_VARARGS,\n     \u0022Get the error message and invalid index of a node name or None if valid.\u0022\n   },\n\u002B  {\n\u002B    \u0022rclpy_resolve_name\u0022, rclpy_resolve_name, METH_VARARGS,\n\u002B    \u0022Expand and remap a topic or service name.\u0022\n\u002B  },\n   {\n     \u0022rclpy_create_publisher\u0022, rclpy_create_publisher, METH_VARARGS,\n     \u0022Create a Publisher.\u0022\ndiff --git rclpy/test/test_node.py rclpy/test/test_node.py\nindex 3a766c0..601750e 100644\n--- rclpy/test/test_node.py\n\u002B\u002B\u002B rclpy/test/test_node.py\n@@ -1920,5 \u002B1920,21 @@ class TestCreateNode(unittest.TestCase):\n         rclpy.shutdown(context=g_context)\n \n \n\u002Bdef test_node_resolve_name():\n\u002B    context = rclpy.Context()\n\u002B    rclpy.init(\n\u002B        args=[\u0027--ros-args\u0027, \u0027-r\u0027, \u0027foo:=bar\u0027],\n\u002B        context=context,\n\u002B    )\n\u002B    node = rclpy.create_node(\u0027test_rclpy_node_resolve_name\u0027, namespace=\u0027/my_ns\u0027, context=context)\n\u002B    assert node.resolve_topic_name(\u0027foo\u0027) == \u0027/my_ns/bar\u0027\n\u002B    assert node.resolve_topic_name(\u0027/abs\u0027) == \u0027/abs\u0027\n\u002B    assert node.resolve_topic_name(\u0027foo\u0027, only_expand=True) == \u0027/my_ns/foo\u0027\n\u002B    assert node.resolve_service_name(\u0027foo\u0027) == \u0027/my_ns/bar\u0027\n\u002B    assert node.resolve_service_name(\u0027/abs\u0027) == \u0027/abs\u0027\n\u002B    assert node.resolve_service_name(\u0027foo\u0027, only_expand=True) == \u0027/my_ns/foo\u0027\n\u002B    rclpy.shutdown(context=context)\n\u002B\n\u002B\n if __name__ == \u0027__main__\u0027:\n     unittest.main()\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "1ee274d74b156390260910b042242a5c11a34c00",
    "RawMessage": "Mirror rolling to ros2",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-ros2.yaml .github/workflows/mirror-rolling-to-ros2.yaml\nnew file mode 100644\nindex 00000000..fa4e69bf\n--- /dev/null\n\u002B\u002B\u002B .github/workflows/mirror-rolling-to-ros2.yaml\n@@ -0,0 \u002B1,13 @@\n\u002Bname: Mirror rolling to ros2\n\u002B\n\u002Bon:\n\u002B  push:\n\u002B    branches: [ rolling ]\n\u002B\n\u002Bjobs:\n\u002B  mirror-to-ros2:\n\u002B    runs-on: ubuntu-latest\n\u002B    steps:\n\u002B    - uses: zofrex/mirror-branch@v1\n\u002B      with:\n\u002B        target-branch: ros2\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "b05b7e0af0c909a96febb8f8fec7ab34f751fade",
    "RawMessage": "build shared lib only if BUILD_SHARED_LIBS is set (#62)",
    "Changes": "diff --git rmw_dds_common/CMakeLists.txt rmw_dds_common/CMakeLists.txt\nindex 2d8dfa0..423195f 100644\n--- rmw_dds_common/CMakeLists.txt\n\u002B\u002B\u002B rmw_dds_common/CMakeLists.txt\n@@ -17,6 \u002B17,7 @@ find_package(rcutils REQUIRED)\n find_package(rmw REQUIRED)\n find_package(rosidl_default_generators REQUIRED)\n \n\u002Bament_add_default_options()\n ament_export_dependencies(ament_cmake_core)\n ament_export_dependencies(rcpputils)\n ament_export_dependencies(rcutils)\n@@ -29,7 \u002B30,7 @@ rosidl_generate_interfaces(\n   \u0022msg/ParticipantEntitiesInfo.msg\u0022\n )\n \n-add_library(${PROJECT_NAME}_library SHARED\n\u002Badd_library(${PROJECT_NAME}_library\n   src/gid_utils.cpp\n   src/graph_cache.cpp\n   src/qos.cpp\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "common_interfaces",
    "SHA": "65e9cc4e10a106a8bf99c4bea5a523baeba7e4c0",
    "RawMessage": "Retain width and height after resize for master (#193)",
    "Changes": "diff --git sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.hpp sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.hpp\nindex d766d0d..1005a84 100644\n--- sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.hpp\n\u002B\u002B\u002B sensor_msgs/include/sensor_msgs/impl/point_cloud2_iterator.hpp\n@@ -121,23 \u002B121,38 @@ inline void PointCloud2Modifier::reserve(size_t size)\n \n inline void PointCloud2Modifier::resize(size_t size)\n {\n-  cloud_msg_.data.resize(size * cloud_msg_.point_step);\n\u002B  size_t total_size = size * cloud_msg_.point_step;\n\u002B  cloud_msg_.data.resize(total_size);\n\u002B\n\u002B  size_t original_size = cloud_msg_.height * cloud_msg_.width;\n\u002B  if (original_size == size) {\n\u002B    return;\n\u002B  }\n \n   // Update height/width\n   if (cloud_msg_.height == 1) {\n     cloud_msg_.width = static_cast\u003Cuint32_t\u003E(size);\n-    cloud_msg_.row_step = static_cast\u003Cuint32_t\u003E(size * cloud_msg_.point_step);\n\u002B    cloud_msg_.row_step = static_cast\u003Cuint32_t\u003E(total_size);\n   } else {\n     if (cloud_msg_.width == 1) {\n       cloud_msg_.height = static_cast\u003Cuint32_t\u003E(size);\n     } else {\n       cloud_msg_.height = 1;\n       cloud_msg_.width = static_cast\u003Cuint32_t\u003E(size);\n-      cloud_msg_.row_step = static_cast\u003Cuint32_t\u003E(size * cloud_msg_.point_step);\n\u002B      cloud_msg_.row_step = static_cast\u003Cuint32_t\u003E(total_size);\n     }\n   }\n }\n \n\u002Binline void PointCloud2Modifier::resize(size_t width, size_t height)\n\u002B{\n\u002B  size_t size = width * height;\n\u002B  resize(size);\n\u002B\n\u002B  cloud_msg_.width = width;\n\u002B  cloud_msg_.height = height;\n\u002B}\n\u002B\n inline void PointCloud2Modifier::clear()\n {\n   cloud_msg_.data.clear();\ndiff --git sensor_msgs/include/sensor_msgs/point_cloud2_iterator.hpp sensor_msgs/include/sensor_msgs/point_cloud2_iterator.hpp\nindex c691dfe..bafcdec 100644\n--- sensor_msgs/include/sensor_msgs/point_cloud2_iterator.hpp\n\u002B\u002B\u002B sensor_msgs/include/sensor_msgs/point_cloud2_iterator.hpp\n@@ -125,6 \u002B125,12 @@ public:\n    */\n   void resize(size_t size);\n \n\u002B  /**\n\u002B   * @param width The new width of the point cloud.\n\u002B   * @param height The new height of the point cloud.\n\u002B   */\n\u002B  void resize(size_t width, size_t height);\n\u002B\n   /**\n    * @brief remove all T\u0027s from the original sensor_msgs::msg::PointCloud2\n    */\ndiff --git sensor_msgs/test/test_pointcloud_iterator.cpp sensor_msgs/test/test_pointcloud_iterator.cpp\nindex 67ea498..9451e7f 100644\n--- sensor_msgs/test/test_pointcloud_iterator.cpp\n\u002B\u002B\u002B sensor_msgs/test/test_pointcloud_iterator.cpp\n@@ -124,3 \u002B124,51 @@ TEST(sensor_msgs, PointCloud2Iterator)\n   }\n   EXPECT_EQ(i, n_points);\n }\n\u002B\n\u002BTEST(sensor_msgs, PointCloud2Resize)\n\u002B{\n\u002B  // Check if size will retain when width and height given explicitly (width == 1)\n\u002B  size_t n_points = 4;\n\u002B  sensor_msgs::msg::PointCloud2 cloud_msg_1;\n\u002B  cloud_msg_1.height = static_cast\u003Cuint32_t\u003E(n_points);\n\u002B  cloud_msg_1.width = 1;\n\u002B  sensor_msgs::PointCloud2Modifier modifier(cloud_msg_1);\n\u002B  modifier.setPointCloud2FieldsByString(2, \u0022xyz\u0022, \u0022rgb\u0022);\n\u002B  modifier.resize(1 * n_points);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(1), cloud_msg_1.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(4), cloud_msg_1.height);\n\u002B  modifier.resize(1, n_points);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(1), cloud_msg_1.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(4), cloud_msg_1.height);\n\u002B\n\u002B  // Check if size will retain when width and height given explicitly (height == 1)\n\u002B  size_t n_points2 = 5;\n\u002B  sensor_msgs::msg::PointCloud2 cloud_msg_2;\n\u002B  cloud_msg_2.height = 1;\n\u002B  cloud_msg_2.width = static_cast\u003Cuint32_t\u003E(n_points2);\n\u002B  sensor_msgs::PointCloud2Modifier modifier2(cloud_msg_2);\n\u002B  modifier2.setPointCloud2FieldsByString(2, \u0022xyz\u0022, \u0022rgb\u0022);\n\u002B  modifier2.resize(1 * n_points2);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(5), cloud_msg_2.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(1), cloud_msg_2.height);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(160), cloud_msg_2.row_step);\n\u002B  modifier2.resize(n_points2, 1);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(5), cloud_msg_2.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(1), cloud_msg_2.height);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(160), cloud_msg_2.row_step);\n\u002B\n\u002B  // Check if resize works when width and height are changed\n\u002B  sensor_msgs::msg::PointCloud2 cloud_msg_3;\n\u002B  cloud_msg_3.height = 3;\n\u002B  cloud_msg_3.width = 3;\n\u002B  sensor_msgs::PointCloud2Modifier modifier3(cloud_msg_3);\n\u002B  modifier3.setPointCloud2FieldsByString(2, \u0022xyz\u0022, \u0022rgb\u0022);\n\u002B  modifier3.resize(10);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(10), cloud_msg_3.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(1), cloud_msg_3.height);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(320), cloud_msg_3.row_step);\n\u002B  modifier3.resize(11, 11);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(11), cloud_msg_3.width);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(11), cloud_msg_3.height);\n\u002B  EXPECT_EQ(static_cast\u003Cuint32_t\u003E(3872), cloud_msg_3.row_step);\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "5e14a283b67940526a20c365b827d8090a552bad",
    "RawMessage": "Modify rclcpp_action::GoalUUID hashing algorithm (#2441)",
    "Changes": "diff --git rclcpp_action/include/rclcpp_action/types.hpp rclcpp_action/include/rclcpp_action/types.hpp\nindex 829b6cd2..cf359dfa 100644\n--- rclcpp_action/include/rclcpp_action/types.hpp\n\u002B\u002B\u002B rclcpp_action/include/rclcpp_action/types.hpp\n@@ -69,14 \u002B69,13 @@ struct hash\u003Crclcpp_action::GoalUUID\u003E\n {\n   size_t operator()(const rclcpp_action::GoalUUID \u0026 uuid) const noexcept\n   {\n-    // TODO(sloretz) Use someone else\u0027s hash function and cite it\n-    size_t result = 0;\n-    for (size_t i = 0; i \u003C uuid.size(); \u002B\u002Bi) {\n-      for (size_t b = 0; b \u003C sizeof(size_t); \u002B\u002Bb) {\n-        size_t part = uuid[i];\n-        part \u003C\u003C= CHAR_BIT * b;\n-        result ^= part;\n-      }\n\u002B    // Using the FNV-1a hash algorithm\n\u002B    constexpr size_t FNV_prime = 1099511628211u;\n\u002B    size_t result = 14695981039346656037u;\n\u002B\n\u002B    for (const auto \u0026 byte : uuid) {\n\u002B      result ^= byte;\n\u002B      result *= FNV_prime;\n     }\n     return result;\n   }\ndiff --git rclcpp_action/test/test_types.cpp rclcpp_action/test/test_types.cpp\nindex 4922c529..619a4f78 100644\n--- rclcpp_action/test/test_types.cpp\n\u002B\u002B\u002B rclcpp_action/test/test_types.cpp\n@@ -15,6 \u002B15,7 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Climits\u003E\n\u002B#include \u003Crandom\u003E\n #include \u0022rclcpp_action/types.hpp\u0022\n \n TEST(TestActionTypes, goal_uuid_to_string) {\n@@ -59,3 \u002B60,35 @@ TEST(TestActionTypes, rcl_action_goal_info_to_goal_uuid) {\n     EXPECT_EQ(goal_info.goal_id.uuid[i], goal_id[i]);\n   }\n }\n\u002B\n\u002BTEST(TestActionTypes, goal_uuid_to_hashed_uuid_random) {\n\u002B  // Use std::random_device to seed the generator of goal IDs.\n\u002B  std::random_device rd;\n\u002B  std::independent_bits_engine\u003C\n\u002B    std::default_random_engine, 8, decltype(rd())\u003E random_bytes_generator(rd());\n\u002B\n\u002B  std::vector\u003Csize_t\u003E hashed_guuids;\n\u002B  constexpr size_t iterations = 1000;\n\u002B\n\u002B  for (size_t i = 0; i \u003C iterations; i\u002B\u002B) {\n\u002B    rclcpp_action::GoalUUID goal_id;\n\u002B\n\u002B    // Generate random bytes for each element of the array\n\u002B    for (auto \u0026 element : goal_id) {\n\u002B      element = static_cast\u003Cuint8_t\u003E(random_bytes_generator());\n\u002B    }\n\u002B\n\u002B    size_t new_hashed_guuid = std::hash\u003Crclcpp_action::GoalUUID\u003E()(goal_id);\n\u002B\n\u002B    // Search for any prevoius hashed goal_id with the same value\n\u002B    for (auto prev_hashed_guuid : hashed_guuids) {\n\u002B      EXPECT_NE(prev_hashed_guuid, new_hashed_guuid);\n\u002B      if (prev_hashed_guuid == new_hashed_guuid) {\n\u002B        // Fail before the first occurrence of a collision\n\u002B        GTEST_FAIL();\n\u002B      }\n\u002B    }\n\u002B\n\u002B    hashed_guuids.push_back(new_hashed_guuid);\n\u002B  }\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "urdf",
    "SHA": "4f38dd9c86fea25d0e74953d5c19b8253fe05969",
    "RawMessage": "[urdf] package.xml: add missing exec_depend to urdf_parser_plugin (#34)",
    "Changes": "diff --git urdf/package.xml urdf/package.xml\nindex 460fef8..9c039b6 100644\n--- urdf/package.xml\n\u002B\u002B\u002B urdf/package.xml\n@@ -30,6 \u002B30,8 @@\n   \u003Cexec_depend\u003Epluginlib\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Etinyxml2_vendor\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Eurdfdom\u003C/exec_depend\u003E\n\u002B  \u003C!-- while \u0060urdf_parser_plugin\u0060 is a header only lib, \u0060pluginlib\u0060 requires the package to exist during runtime. --\u003E\n\u002B  \u003Cexec_depend\u003Eurdf_parser_plugin\u003C/exec_depend\u003E\n   \u003C!-- use ROS 2 package urdfdom_headers until upstream provides 1.0.0.--\u003E\n   \u003Cexec_depend\u003Eurdfdom_headers\u003C/exec_depend\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "4f20a8b416f248b66bfaca44aa7d3e527ef83a13",
    "RawMessage": "\u2261\u0192\u00E6\u2310\u0393\u00C7\u00EC\u2261\u0192\u00EE\u255B Check that header is not none before accessing it in test (#818)",
    "Changes": "diff --git rclpy/test/test_client.py rclpy/test/test_client.py\nindex 7659d6a..6846a0e 100644\n--- rclpy/test/test_client.py\n\u002B\u002B\u002B rclpy/test/test_client.py\n@@ -108,6 \u002B108,7 @@ class TestClient(unittest.TestCase):\n                     result = srv.handle.service_take_request(srv.srv_type.Request)\n                 if result is not None:\n                     request, header = result\n\u002B                    self.assertTrue(header is not None)\n                     self.assertNotEqual(0, header.source_timestamp)\n                     return\n                 else:\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "5007fb592e3b205858b042d0fd63a7ed858fad45",
    "RawMessage": "Duplicated code RobotJoint (#702)",
    "Changes": "diff --git rviz_default_plugins/include/rviz_default_plugins/robot/robot_joint.hpp rviz_default_plugins/include/rviz_default_plugins/robot/robot_joint.hpp\nindex d4a98dc3..50239cb5 100644\n--- rviz_default_plugins/include/rviz_default_plugins/robot/robot_joint.hpp\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/robot/robot_joint.hpp\n@@ -53,6 \u002B53,7 @@\n #include \u0022rviz_common/interaction/forwards.hpp\u0022\n \n #include \u0022rviz_default_plugins/robot/robot_element_base_class.hpp\u0022\n\u002B#include \u0022rviz_default_plugins/robot/robot_link.hpp\u0022\n #include \u0022rviz_default_plugins/visibility_control.hpp\u0022\n \n namespace Ogre\n@@ -141,7 \u002B142,7 @@ private:\n     int \u0026 links_with_geom,              // returns # of children with geometry\n     int \u0026 links_with_geom_checked,      // returns # of enabled children with geometry\n     int \u0026 links_with_geom_unchecked,    // returns # of disabled children with geometry\n-    bool recursive) const;              // True: all descendant links.\n\u002B    bool recursive);              // True: all descendant links.\n   // False: just single child link.\n \n   // set the value of the enable checkbox without touching child joints/links\n@@ -163,6 \u002B164,13 @@ protected:\n   rviz_common::properties::FloatProperty * upper_limit_property_;\n \n private:\n\u002B  RobotLink * links_checked_and_unchecked(\n\u002B    int \u0026 links_with_geom_checked,\n\u002B    int \u0026 links_with_geom_unchecked);\n\u002B  int links_with_geom(\n\u002B    RobotLink * link, int \u0026 links_with_geom_checked,\n\u002B    int \u0026 links_with_geom_unchecked, int n_args, ...);\n\u002B\n   Ogre::Vector3 joint_origin_pos_;\n   Ogre::Quaternion joint_origin_rot_;\n   bool has_decendent_links_with_geometry_;\ndiff --git rviz_default_plugins/src/rviz_default_plugins/robot/robot_joint.cpp rviz_default_plugins/src/rviz_default_plugins/robot/robot_joint.cpp\nindex 71323535..2f9d3b13 100644\n--- rviz_default_plugins/src/rviz_default_plugins/robot/robot_joint.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/robot/robot_joint.cpp\n@@ -34,7 \u002B34,6 @@\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n-#include \u0022rviz_default_plugins/robot/robot_link.hpp\u0022\n #include \u0022rviz_default_plugins/robot/robot.hpp\u0022\n \n #include \u0022rviz_common/load_resource.hpp\u0022\n@@ -212,6 \u002B211,37 @@ void RobotJoint::setJointCheckbox(QVariant val)\n   doing_set_checkbox_ = false;\n }\n \n\u002Bint RobotJoint::links_with_geom(\n\u002B  RobotLink * link, int \u0026 links_with_geom_checked,\n\u002B  int \u0026 links_with_geom_unchecked, int n_args, ...)\n\u002B{\n\u002B  va_list arg_ptr;\n\u002B  va_start(arg_ptr, n_args);\n\u002B\n\u002B  for (auto \u0026 child_joint_name : link-\u003EgetChildJointNames()) {\n\u002B    RobotJoint * child_joint = robot_-\u003EgetJoint(child_joint_name);\n\u002B    if (child_joint) {\n\u002B      int child_links_with_geom;\n\u002B      int child_links_with_geom_checked;\n\u002B      int child_links_with_geom_unchecked;\n\u002B      if (n_args == 1) {\n\u002B        child_joint-\u003EgetChildLinkState(\n\u002B          child_links_with_geom, child_links_with_geom_checked,\n\u002B          child_links_with_geom_unchecked, va_arg(arg_ptr, int));\n\u002B      } else {\n\u002B        child_joint-\u003EcalculateJointCheckboxesRecursive(\n\u002B          child_links_with_geom,\n\u002B          child_links_with_geom_checked,\n\u002B          child_links_with_geom_unchecked);\n\u002B      }\n\u002B      links_with_geom_checked \u002B= child_links_with_geom_checked;\n\u002B      links_with_geom_unchecked \u002B= child_links_with_geom_unchecked;\n\u002B    }\n\u002B  }\n\u002B  va_end(arg_ptr);\n\u002B  return links_with_geom_checked \u002B links_with_geom_unchecked;\n\u002B}\n\u002B\n void RobotJoint::calculateJointCheckboxesRecursive(\n   int \u0026 links_with_geom,\n   int \u0026 links_with_geom_checked,\n@@ -221,15 \u002B251,12 @@ void RobotJoint::calculateJointCheckboxesRecursive(\n   links_with_geom_checked = 0;\n   links_with_geom_unchecked = 0;\n \n-  RobotLink * link = robot_-\u003EgetLink(child_link_name_);\n-  if (link == nullptr) {\n\u002B  RobotLink * link =\n\u002B    links_checked_and_unchecked(links_with_geom_checked, links_with_geom_unchecked);\n\u002B  if (!link) {\n     return;\n   }\n-  if (link-\u003EhasGeometry()) {\n-    bool checked = link-\u003EgetLinkProperty()-\u003EgetValue().toBool();\n-    links_with_geom_checked \u002B= checked ? 1 : 0;\n-    links_with_geom_unchecked \u002B= checked ? 0 : 1;\n-  }\n\u002B\n   links_with_geom = links_with_geom_checked \u002B links_with_geom_unchecked;\n \n   if (!styleIsTree()) {\n@@ -240,21 \u002B267,8 @@ void RobotJoint::calculateJointCheckboxesRecursive(\n     }\n   }\n \n-  for (auto \u0026 child_joint_name : link-\u003EgetChildJointNames()) {\n-    RobotJoint * child_joint = robot_-\u003EgetJoint(child_joint_name);\n-    if (child_joint) {\n-      int child_links_with_geom;\n-      int child_links_with_geom_checked;\n-      int child_links_with_geom_unchecked;\n-      child_joint-\u003EcalculateJointCheckboxesRecursive(\n-        child_links_with_geom,\n-        child_links_with_geom_checked,\n-        child_links_with_geom_unchecked);\n-      links_with_geom_checked \u002B= child_links_with_geom_checked;\n-      links_with_geom_unchecked \u002B= child_links_with_geom_unchecked;\n-    }\n-  }\n-  links_with_geom = links_with_geom_checked \u002B links_with_geom_unchecked;\n\u002B  links_with_geom = this-\u003Elinks_with_geom(\n\u002B    link, links_with_geom_checked, links_with_geom_unchecked, 0);\n \n   if (styleIsTree()) {\n     if (!links_with_geom) {\n@@ -265,40 \u002B279,39 @@ void RobotJoint::calculateJointCheckboxesRecursive(\n   }\n }\n \n-void RobotJoint::getChildLinkState(\n-  int \u0026 links_with_geom,\n-  int \u0026 links_with_geom_checked,\n-  int \u0026 links_with_geom_unchecked,\n-  bool recursive) const\n\u002BRobotLink * RobotJoint::links_checked_and_unchecked(\n\u002B  int \u0026 links_with_geom_checked, int \u0026 links_with_geom_unchecked)\n {\n-  links_with_geom = 0;\n   links_with_geom_checked = 0;\n   links_with_geom_unchecked = 0;\n \n   RobotLink * link = robot_-\u003EgetLink(child_link_name_);\n-  if (link == nullptr) {\n-    return;\n\u002B  if (!link) {\n\u002B    return nullptr;\n   }\n   if (link-\u003EhasGeometry()) {\n     bool checked = link-\u003EgetLinkProperty()-\u003EgetValue().toBool();\n     links_with_geom_checked \u002B= checked ? 1 : 0;\n     links_with_geom_unchecked \u002B= checked ? 0 : 1;\n   }\n\u002B  return link;\n\u002B}\n\u002B\n\u002Bvoid RobotJoint::getChildLinkState(\n\u002B  int \u0026 links_with_geom,\n\u002B  int \u0026 links_with_geom_checked,\n\u002B  int \u0026 links_with_geom_unchecked,\n\u002B  bool recursive)\n\u002B{\n\u002B  links_with_geom = 0;\n\u002B  RobotLink * link = this-\u003Elinks_checked_and_unchecked(\n\u002B    links_with_geom_checked, links_with_geom_unchecked);\n\u002B  if (!link) {\n\u002B    return;\n\u002B  }\n \n   if (recursive) {\n-    for (auto \u0026 child_joint_name : link-\u003EgetChildJointNames()) {\n-      RobotJoint * child_joint = robot_-\u003EgetJoint(child_joint_name);\n-      if (child_joint) {\n-        int child_links_with_geom;\n-        int child_links_with_geom_checked;\n-        int child_links_with_geom_unchecked;\n-        child_joint-\u003EgetChildLinkState(\n-          child_links_with_geom, child_links_with_geom_checked,\n-          child_links_with_geom_unchecked, recursive);\n-        links_with_geom_checked \u002B= child_links_with_geom_checked;\n-        links_with_geom_unchecked \u002B= child_links_with_geom_unchecked;\n-      }\n-    }\n\u002B    this-\u003Elinks_with_geom(link, links_with_geom_checked, links_with_geom_unchecked, 1, recursive);\n   }\n \n   links_with_geom = links_with_geom_checked \u002B links_with_geom_unchecked;\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "d716ad105259d89018fad301800a2caf06adb3b2",
    "RawMessage": "Don\u0027t overwrite string_array pointer on reallocation failure (#775)",
    "Changes": "diff --git rcl_yaml_param_parser/src/parser.c rcl_yaml_param_parser/src/parser.c\nindex 9ac0f24..814da9d 100644\n--- rcl_yaml_param_parser/src/parser.c\n\u002B\u002B\u002B rcl_yaml_param_parser/src/parser.c\n@@ -1006,13 \u002B1006,14 @@ static rcutils_ret_t add_val_to_string_arr(\n     val_array-\u003Edata[0U] = value;\n   } else {\n     /// Increase the array size by one and add the new value\n-    val_array-\u003Edata = allocator.reallocate(\n\u002B    char ** new_string_arr_ptr = allocator.reallocate(\n       val_array-\u003Edata,\n       ((val_array-\u003Esize \u002B 1U) * sizeof(char *)), allocator.state);\n-    if (NULL == val_array-\u003Edata) {\n\u002B    if (NULL == new_string_arr_ptr) {\n       RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022Error allocating mem\\n\u0022);\n       return RCUTILS_RET_BAD_ALLOC;\n     }\n\u002B    val_array-\u003Edata = new_string_arr_ptr;\n     val_array-\u003Edata[val_array-\u003Esize] = value;\n     val_array-\u003Esize\u002B\u002B;\n   }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "31c6fd094c8bd01d0a231856df1bd9a476bea26a",
    "RawMessage": "[rolling] Update maintainers - 2022-11-07 (#337)",
    "Changes": "diff --git CODEOWNERS CODEOWNERS\nnew file mode 100644\nindex 0000000..bcaefff\n--- /dev/null\n\u002B\u002B\u002B CODEOWNERS\n@@ -0,0 \u002B1,2 @@\n\u002B# This file was generated by https://github.com/audrow/update-ros2-repos\n\u002B* @methylDragon @ivanpauno @wjwwood\ndiff --git rmw/package.xml rmw/package.xml\nindex b9a9d59..3cee5ab 100644\n--- rmw/package.xml\n\u002B\u002B\u002B rmw/package.xml\n@@ -4,9 \u002B4,13 @@\n   \u003Cname\u003Ermw\u003C/name\u003E\n   \u003Cversion\u003E6.4.0\u003C/version\u003E\n   \u003Cdescription\u003EContains the ROS middleware API.\u003C/description\u003E\n\u002B\n\u002B  \u003Cmaintainer email=\u0022brandon@openrobotics.org\u0022\u003EBrandon Ong\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022ivanpauno@ekumenlabs.com\u0022\u003EIvan Paunovic\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B\n   \u003Cauthor email=\u0022dthomas@openrobotics.org\u0022\u003EDirk Thomas\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\ndiff --git rmw_implementation_cmake/package.xml rmw_implementation_cmake/package.xml\nindex e8fcfde..5fd2ccf 100644\n--- rmw_implementation_cmake/package.xml\n\u002B\u002B\u002B rmw_implementation_cmake/package.xml\n@@ -6,9 \u002B6,13 @@\n   \u003Cdescription\u003E\n     CMake functions which can discover and enumerate available implementations.\n   \u003C/description\u003E\n\u002B\n\u002B  \u003Cmaintainer email=\u0022brandon@openrobotics.org\u0022\u003EBrandon Ong\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022ivanpauno@ekumenlabs.com\u0022\u003EIvan Paunovic\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B\n   \u003Cauthor email=\u0022dthomas@openrobotics.org\u0022\u003EDirk Thomas\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "417c54ed5dfcde82d27d3a2c90eca9041047d4f3",
    "RawMessage": "Drop support for float128. (#788)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\nindex 62f8cc2..7a57bef 100644\n--- rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n@@ -419,11 \u002B419,6 @@ MemberIdentifierName GetTypeIdentifier(const MembersType * members, uint32_t ind\n         type_name = \u0022double\u0022;\n         break;\n       }\n-    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_LONG_DOUBLE:\n-      {\n-        type_name = \u0022longdouble\u0022;\n-        break;\n-      }\n     case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n       {\n         type_name = \u0022char\u0022;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "e7f06398dbcc5ef59362f416535f9e7acb0899ff",
    "RawMessage": "add logger level service to lifecycle node. (#2277)",
    "Changes": "diff --git rclcpp_lifecycle/src/lifecycle_node.cpp rclcpp_lifecycle/src/lifecycle_node.cpp\nindex 9e58c4fa..a85d661e 100644\n--- rclcpp_lifecycle/src/lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node.cpp\n@@ -144,6 \u002B144,10 @@ LifecycleNode::LifecycleNode(\n       \u0026LifecycleNodeInterface::on_deactivate, this,\n       std::placeholders::_1));\n   register_on_error(std::bind(\u0026LifecycleNodeInterface::on_error, this, std::placeholders::_1));\n\u002B\n\u002B  if (options.enable_logger_service()) {\n\u002B    node_logging_-\u003Ecreate_logger_services(node_services_);\n\u002B  }\n }\n \n LifecycleNode::~LifecycleNode()\ndiff --git rclcpp_lifecycle/test/test_lifecycle_node.cpp rclcpp_lifecycle/test/test_lifecycle_node.cpp\nindex 8a09884e..ddcc9265 100644\n--- rclcpp_lifecycle/test/test_lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_node.cpp\n@@ -25,6 \u002B25,8 @@\n #include \u0022lifecycle_msgs/msg/transition.hpp\u0022\n \n #include \u0022rcl_lifecycle/rcl_lifecycle.h\u0022\n\u002B#include \u0022rcl_interfaces/srv/get_logger_levels.hpp\u0022\n\u002B#include \u0022rcl_interfaces/srv/set_logger_levels.hpp\u0022\n \n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp_lifecycle/lifecycle_node.hpp\u0022\n@@ -34,6 \u002B36,8 @@\n using lifecycle_msgs::msg::State;\n using lifecycle_msgs::msg::Transition;\n \n\u002Busing namespace std::chrono_literals;\n\u002B\n static const std::chrono::nanoseconds DEFAULT_EVENT_TIMEOUT = std::chrono::seconds(3);\n static const std::chrono::nanoseconds DEFAULT_EVENT_SLEEP_PERIOD = std::chrono::milliseconds(100);\n \n@@ -249,6 \u002B253,35 @@ TEST_F(TestDefaultStateMachine, empty_initializer_rcl_errors) {\n   }\n }\n \n\u002BTEST_F(TestDefaultStateMachine, check_logger_services_exist) {\n\u002B  // Logger level services are disabled\n\u002B  {\n\u002B    rclcpp::NodeOptions options = rclcpp::NodeOptions();\n\u002B    options.enable_logger_service(false);\n\u002B    auto node = std::make_shared\u003Crclcpp_lifecycle::LifecycleNode\u003E(\n\u002B      \u0022test_logger_service\u0022, \u0022/test\u0022, options);\n\u002B    auto get_client = node-\u003Ecreate_client\u003Crcl_interfaces::srv::GetLoggerLevels\u003E(\n\u002B      \u0022/test/test_logger_service/get_logger_levels\u0022);\n\u002B    ASSERT_FALSE(get_client-\u003Ewait_for_service(2s));\n\u002B    auto set_client = node-\u003Ecreate_client\u003Crcl_interfaces::srv::SetLoggerLevels\u003E(\n\u002B      \u0022/test/test_logger_service/set_logger_levels\u0022);\n\u002B    ASSERT_FALSE(set_client-\u003Ewait_for_service(2s));\n\u002B  }\n\u002B  // Logger level services are enabled\n\u002B  {\n\u002B    rclcpp::NodeOptions options = rclcpp::NodeOptions();\n\u002B    options.enable_logger_service(true);\n\u002B    auto node = std::make_shared\u003Crclcpp_lifecycle::LifecycleNode\u003E(\n\u002B      \u0022test_logger_service\u0022, \u0022/test\u0022, options);\n\u002B    auto get_client = node-\u003Ecreate_client\u003Crcl_interfaces::srv::GetLoggerLevels\u003E(\n\u002B      \u0022/test/test_logger_service/get_logger_levels\u0022);\n\u002B    ASSERT_TRUE(get_client-\u003Ewait_for_service(2s));\n\u002B    auto set_client = node-\u003Ecreate_client\u003Crcl_interfaces::srv::SetLoggerLevels\u003E(\n\u002B      \u0022/test/test_logger_service/set_logger_levels\u0022);\n\u002B    ASSERT_TRUE(set_client-\u003Ewait_for_service(2s));\n\u002B  }\n\u002B}\n\u002B\n TEST_F(TestDefaultStateMachine, trigger_transition) {\n   auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n \n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "8a2e2d3de5a96eaa50b9c9336d97396f8489bda4",
    "RawMessage": "Add types to Node.py (#1346)",
    "Changes": "diff --git rclpy/rclpy/callback_groups.py rclpy/rclpy/callback_groups.py\nindex de5ef04..bee08d6 100644\n--- rclpy/rclpy/callback_groups.py\n\u002B\u002B\u002B rclpy/rclpy/callback_groups.py\n@@ -23,7 \u002B23,8 @@ if TYPE_CHECKING:\n     from rclpy.client import Client\n     from rclpy.service import Service\n     from rclpy.waitable import Waitable\n-    Entity = Union[Subscription, Timer, Client, Service, Waitable[Any]]\n\u002B    from rclpy.guard_condition import GuardCondition\n\u002B    Entity = Union[Subscription, Timer, Client, Service, Waitable[Any], GuardCondition]\n \n \n class CallbackGroup:\ndiff --git rclpy/rclpy/exceptions.py rclpy/rclpy/exceptions.py\nindex ee22e8b..dbe63e0 100644\n--- rclpy/rclpy/exceptions.py\n\u002B\u002B\u002B rclpy/rclpy/exceptions.py\n@@ -109,7 \u002B109,7 @@ class InvalidParameterTypeException(ParameterException):\n \n     from rclpy.parameter import Parameter\n \n-    def __init__(self, desired_parameter: Parameter, expected_type: Parameter.Type) -\u003E None:\n\u002B    def __init__(self, desired_parameter: Parameter, expected_type: str) -\u003E None:\n         from rclpy.parameter import Parameter\n         ParameterException.__init__(\n             self,\ndiff --git rclpy/rclpy/impl/_rclpy_pybind11.pyi rclpy/rclpy/impl/_rclpy_pybind11.pyi\nindex 0570c43..679f6fa 100644\n--- rclpy/rclpy/impl/_rclpy_pybind11.pyi\n\u002B\u002B\u002B rclpy/rclpy/impl/_rclpy_pybind11.pyi\n@@ -20,8 \u002B20,8 @@ from typing import Any, Generic, Literal, overload, Sequence, TypedDict\n \n from rclpy.clock import JumpHandle\n from rclpy.clock_type import ClockType\n-from rclpy.qos import (QoSDurabilityPolicy, QoSHistoryPolicy, QoSLivelinessPolicy,\n-                       QoSReliabilityPolicy)\n\u002Bfrom rclpy.duration import Duration\n\u002Bfrom rclpy.parameter import Parameter\n from rclpy.subscription import MessageInfo\n from rclpy.type_support import MsgT\n \n@@ -173,10 \u002B173,118 @@ class Subscription(Destroyable, Generic[MsgT]):\n         \u0022\u0022\u0022Count the publishers from a subscription.\u0022\u0022\u0022\n \n \n-class Node:\n\u002Bclass Node(Destroyable):\n\u002B\n\u002B    def __init__(self, node_name: str, namespace_: str, context: Context,\n\u002B                 pycli_args: list[str] | None, use_global_arguments: bool,\n\u002B                 enable_rosout: bool) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def get_fully_qualified_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the fully qualified name of the node.\u0022\u0022\u0022\n\u002B\n\u002B    def logger_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the name of the logger associated with a node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_node_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the name of a node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_namespace(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the namespace of a node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_count_publishers(self, topic_name: str) -\u003E int:\n\u002B        \u0022\u0022\u0022Return the count of all the publishers known for that topic in the entire ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B    def get_count_subscribers(self, topic_name: str) -\u003E int:\n\u002B        \u0022\u0022\u0022Return the count of all the subscribers known for that topic in the entire ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B    def get_count_clients(self, service_name: str) -\u003E int:\n\u002B        \u0022\u0022\u0022Return the count of all the clients known for that service in the entire ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B    def get_count_services(self, service_name: str) -\u003E int:\n\u002B        \u0022\u0022\u0022Return the count of all the servers known for that service in the entire ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B    def get_node_names_and_namespaces(self) -\u003E list[tuple[str, str, str] | tuple[str, str]]:\n\u002B        \u0022\u0022\u0022Get the list of nodes discovered by the provided node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_node_names_and_namespaces_with_enclaves(self) -\u003E list[tuple[str, str, str] |\n\u002B                                                                  tuple[str, str]]:\n\u002B        \u0022\u0022\u0022Get the list of nodes discovered by the provided node, with their enclaves.\u0022\u0022\u0022\n\u002B\n\u002B    def get_action_client_names_and_types_by_node(self, remote_node_name: str,\n\u002B                                                  remote_node_namespace: str) -\u003E list[tuple[str,\n\u002B                                                                                      list[str]]]:\n\u002B        \u0022\u0022\u0022Get action client names and types by node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_action_server_names_and_types_by_node(self, remote_node_name: str,\n\u002B                                                  remote_node_namespace: str) -\u003E list[tuple[str,\n\u002B                                                                                      list[str]]]:\n\u002B        \u0022\u0022\u0022Get action server names and types by node.\u0022\u0022\u0022\n\u002B\n\u002B    def get_action_names_and_types(self) -\u003E list[tuple[str, list[str]]]:\n\u002B        \u0022\u0022\u0022Get action names and types.\u0022\u0022\u0022\n\u002B\n\u002B    def get_parameters(self, pyparamter_cls: type[Parameter]) -\u003E dict[str, Parameter]:\n\u002B        \u0022\u0022\u0022Get a list of parameters for the current node.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_resolve_name(node: Node, topic_name: str, only_expand: bool, is_service: bool) -\u003E str:\n\u002B    \u0022\u0022\u0022Expand and remap a topic or service name.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_publisher_names_and_types_by_node(node: Node, no_demangle: bool, node_name: str,\n\u002B                                                node_namespace: str\n\u002B                                                ) -\u003E list[tuple[str, list[str]]]:\n\u002B    \u0022\u0022\u0022Get topic names and types for which a remote node has publishers.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_subscriber_names_and_types_by_node(node: Node, no_demangle: bool, node_name: str,\n\u002B                                                 node_namespace: str\n\u002B                                                 ) -\u003E list[tuple[str, list[str]]]:\n\u002B    \u0022\u0022\u0022Get topic names and types for which a remote node has subscribers.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_service_names_and_types_by_node(node: Node, node_name: str, node_namespace: str\n\u002B                                              ) -\u003E list[tuple[str, list[str]]]:\n\u002B    \u0022\u0022\u0022Get all service names and types in the ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_client_names_and_types_by_node(node: Node, node_name: str, node_namespace: str\n\u002B                                             ) -\u003E list[tuple[str, list[str]]]:\n\u002B    \u0022\u0022\u0022Get service names and types for which a remote node has servers.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_service_names_and_types(node: Node) -\u003E list[tuple[str, list[str]]]:\n\u002B    \u0022\u0022\u0022Get all service names and types in the ROS graph.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass TypeHashDict(TypedDict):\n\u002B    version: int\n\u002B    value: bytes\n\u002B\n\u002B\n\u002Bclass QoSDict(TypedDict):\n     pass\n \n \n\u002Bclass TopicEndpointInfoDict(TypedDict):\n\u002B    node_name: str\n\u002B    node_namespace: str\n\u002B    topic_type: str\n\u002B    topic_type_hash: TypeHashDict\n\u002B    endpoint_type: int\n\u002B    endpoint_gid: list[int]\n\u002B    qos_profile: rmw_qos_profile_dict\n\u002B\n\u002B\n\u002Bdef rclpy_get_publishers_info_by_topic(node: Node, topic_name: str, no_mangle: bool\n\u002B                                       ) -\u003E list[TopicEndpointInfoDict]:\n\u002B    \u0022\u0022\u0022Get publishers info for a topic.\u0022\u0022\u0022\n\u002B\n\u002B\n class Publisher(Destroyable, Generic[MsgT]):\n \n     def __init__(self, arg0: Node, arg1: type[MsgT], arg2: str, arg3: rmw_qos_profile_t) -\u003E None:\n@@ -257,14 \u002B365,14 @@ PredefinedQosProfileTNames = Literal[\u0027qos_profile_sensor_data\u0027, \u0027qos_profile_def\n \n \n class rmw_qos_profile_dict(TypedDict):\n-    qos_history: QoSHistoryPolicy | int\n-    qos_depth: int\n-    qos_reliability: QoSReliabilityPolicy | int\n-    qos_durability: QoSDurabilityPolicy | int\n-    pyqos_lifespan: rcl_duration_t\n-    pyqos_deadline: rcl_duration_t\n-    qos_liveliness: QoSLivelinessPolicy | int\n-    pyqos_liveliness_lease_duration: rcl_duration_t\n\u002B    depth: int\n\u002B    history: int\n\u002B    reliability: int\n\u002B    durability: int\n\u002B    lifespan: Duration\n\u002B    deadline: Duration\n\u002B    liveliness: int\n\u002B    liveliness_lease_duration: Duration\n     avoid_ros_namespace_conventions: bool\n \n \n@@ -335,6 \u002B443,18 @@ class WaitSet(Destroyable):\n         \u0022\u0022\u0022Wait until timeout is reached or event happened.\u0022\u0022\u0022\n \n \n\u002Bclass RCLError(RuntimeError):\n\u002B    pass\n\u002B\n\u002B\n\u002Bclass NodeNameNonExistentError(RCLError):\n\u002B    pass\n\u002B\n\u002B\n\u002Bclass InvalidHandle(RuntimeError):\n\u002B    pass\n\u002B\n\u002B  \n class SignalHandlerOptions(Enum):\n     _value_: int\n     NO = ...\ndiff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex cba822b..8da2faa 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -65,6 \u002B65,7 @@ from rclpy.executors import Executor\n from rclpy.expand_topic_name import expand_topic_name\n from rclpy.guard_condition import GuardCondition\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n\u002Bfrom rclpy.impl.rcutils_logger import RcutilsLogger\n from rclpy.logging import get_logger\n from rclpy.logging_service import LoggingService\n from rclpy.parameter import (AllowableParameterValue, AllowableParameterValueT, Parameter,\n@@ -137,7 \u002B138,7 @@ class Node:\n         use_global_arguments: bool = True,\n         enable_rosout: bool = True,\n         start_parameter_services: bool = True,\n-        parameter_overrides: Optional[List[Parameter]] = None,\n\u002B        parameter_overrides: Optional[List[Parameter[Any]]] = None,\n         allow_undeclared_parameters: bool = False,\n         automatically_declare_parameters_from_overrides: bool = False,\n         enable_logger_service: bool = False\n@@ -168,29 \u002B169,31 @@ class Node:\n             to get and set logger levels of this node. Otherwise, logger levels are only managed\n             locally. That is, logger levels cannot be changed remotely.\n         \u0022\u0022\u0022\n-        self.__handle = None\n         self._context = get_default_context() if context is None else context\n-        self._parameters: Dict[str, Parameter] = {}\n-        self._publishers: List[Publisher] = []\n-        self._subscriptions: List[Subscription] = []\n-        self._clients: List[Client] = []\n-        self._services: List[Service] = []\n\u002B        self._parameters: Dict[str, Parameter[Any]] = {}\n\u002B        self._publishers: List[Publisher[Any]] = []\n\u002B        self._subscriptions: List[Subscription[Any]] = []\n\u002B        self._clients: List[Client[Any, Any, Any]] = []\n\u002B        self._services: List[Service[Any, Any, Any]] = []\n         self._timers: List[Timer] = []\n         self._guards: List[GuardCondition] = []\n         self.__waitables: List[Waitable[Any]] = []\n         self._default_callback_group = MutuallyExclusiveCallbackGroup()\n-        self._pre_set_parameters_callbacks: List[Callable[[List[Parameter]], List[Parameter]]] = []\n\u002B        self._pre_set_parameters_callbacks: List[Callable[[List[Parameter[Any]]],\n\u002B                                                          List[Parameter[Any]]]] = []\n         self._on_set_parameters_callbacks: \\\n-            List[Callable[[List[Parameter]], SetParametersResult]] = []\n-        self._post_set_parameters_callbacks: List[Callable[[List[Parameter]], None]] = []\n\u002B            List[Callable[[List[Parameter[Any]]], SetParametersResult]] = []\n\u002B        self._post_set_parameters_callbacks: List[Callable[[List[Parameter[Any]]], None]] = []\n         self._rate_group = ReentrantCallbackGroup()\n         self._allow_undeclared_parameters = allow_undeclared_parameters\n-        self._parameter_overrides: Dict[str, Parameter] = {}\n\u002B        self._parameter_overrides: Dict[str, Parameter[Any]] = {}\n         self._descriptors: Dict[str, ParameterDescriptor] = {}\n \n         namespace = namespace or \u0027\u0027\n-        if not self._context.ok():\n\u002B\n\u002B        if self._context.handle is None or not self._context.ok():\n             raise NotInitializedException(\u0027cannot create node\u0027)\n\u002B\n         with self._context.handle:\n             try:\n                 self.__node = _rclpy.Node(\n@@ -215,10 \u002B218,11 @@ class Node:\n         with self.handle:\n             self._logger = get_logger(self.__node.logger_name())\n \n-        self.__executor_weakref = None\n\u002B        self.__executor_weakref: Optional[weakref.ReferenceType[Executor]] = None\n \n-        self._parameter_event_publisher = self.create_publisher(\n-            ParameterEvent, \u0027/parameter_events\u0027, qos_profile_parameter_events)\n\u002B        self._parameter_event_publisher: Optional[Publisher[ParameterEvent]] = \\\n\u002B            self.create_publisher(ParameterEvent, \u0027/parameter_events\u0027,\n\u002B                                  qos_profile_parameter_events)\n \n         with self.handle:\n             self._parameter_overrides = self.__node.get_parameters(Parameter)\n@@ -256,22 \u002B260,22 @@ class Node:\n         self._context.track_node(self)\n \n     @property\n-    def publishers(self) -\u003E Iterator[Publisher]:\n\u002B    def publishers(self) -\u003E Iterator[Publisher[Any]]:\n         \u0022\u0022\u0022Get publishers that have been created on this node.\u0022\u0022\u0022\n         yield from self._publishers\n \n     @property\n-    def subscriptions(self) -\u003E Iterator[Subscription]:\n\u002B    def subscriptions(self) -\u003E Iterator[Subscription[Any]]:\n         \u0022\u0022\u0022Get subscriptions that have been created on this node.\u0022\u0022\u0022\n         yield from self._subscriptions\n \n     @property\n-    def clients(self) -\u003E Iterator[Client]:\n\u002B    def clients(self) -\u003E Iterator[Client[Any, Any, Any]]:\n         \u0022\u0022\u0022Get clients that have been created on this node.\u0022\u0022\u0022\n         yield from self._clients\n \n     @property\n-    def services(self) -\u003E Iterator[Service]:\n\u002B    def services(self) -\u003E Iterator[Service[Any, Any, Any]]:\n         \u0022\u0022\u0022Get services that have been created on this node.\u0022\u0022\u0022\n         yield from self._services\n \n@@ -311,7 \u002B315,7 @@ class Node:\n             new_executor.add_node(self)\n             self.__executor_weakref = weakref.ref(new_executor)\n \n-    def _wake_executor(self):\n\u002B    def _wake_executor(self) -\u003E None:\n         executor = self.executor\n         if executor:\n             executor.wake()\n@@ -332,7 \u002B336,7 @@ class Node:\n         return self._default_callback_group\n \n     @property\n-    def handle(self):\n\u002B    def handle(self) -\u003E _rclpy.Node:\n         \u0022\u0022\u0022\n         Get the handle to the underlying \u0060rcl_node_t\u0060.\n \n@@ -343,7 \u002B347,7 @@ class Node:\n         return self.__node\n \n     @handle.setter\n-    def handle(self, value):\n\u002B    def handle(self, value: None) -\u003E None:\n         raise AttributeError(\u0027handle cannot be modified after node creation\u0027)\n \n     def get_name(self) -\u003E str:\n@@ -360,7 \u002B364,7 @@ class Node:\n         \u0022\u0022\u0022Get the clock used by the node.\u0022\u0022\u0022\n         return self._clock\n \n-    def get_logger(self):\n\u002B    def get_logger(self) -\u003E RcutilsLogger:\n         \u0022\u0022\u0022Get the nodes logger.\u0022\u0022\u0022\n         return self._logger\n \n@@ -383,7 \u002B387,7 @@ class Node:\n         value: Union[AllowableParameterValue, Parameter.Type, ParameterValue] = None,\n         descriptor: Optional[ParameterDescriptor] = None,\n         ignore_override: bool = False\n-    ) -\u003E Parameter:\n\u002B    ) -\u003E Parameter[Any]:\n         \u0022\u0022\u0022\n         Declare and initialize a parameter.\n \n@@ -423,7 \u002B427,7 @@ class Node:\n                   ParameterDescriptor],\n         ]],\n         ignore_override: bool = False\n-    ) -\u003E List[Parameter]:\n\u002B    ) -\u003E List[Parameter[Any]]:\n         \u0022\u0022\u0022\n         Declare a list of parameters.\n \n@@ -470,7 \u002B474,7 @@ class Node:\n         :raises: InvalidParameterValueException if the registered callback rejects any parameter.\n         :raises: TypeError if any tuple in **parameters** does not match the annotated type.\n         \u0022\u0022\u0022\n-        parameter_list: List[Parameter] = []\n\u002B        parameter_list: List[Parameter[Any]] = []\n         descriptors: Dict[str, ParameterDescriptor] = {}\n         for index, parameter_tuple in enumerate(parameters):\n             if len(parameter_tuple) \u003C 1 or len(parameter_tuple) \u003E 3:\n@@ -545,6 \u002B549,8 @@ class Node:\n                                  \u0027being included in self._parameter_overrides, and \u0027,\n                                  \u0027ignore_override=False\u0027)\n \n\u002B            from typing import cast\n\u002B            value = cast(AllowableParameterValue, value)\n             parameter_list.append(Parameter(name, value=value))\n             descriptors.update({name: descriptor})\n \n@@ -565,7 \u002B571,7 @@ class Node:\n \n     def _declare_parameter_common(\n         self,\n-        parameter_list: List[Parameter],\n\u002B        parameter_list: List[Parameter[Any]],\n         descriptors: Optional[Dict[str, ParameterDescriptor]] = None\n     ) -\u003E List[SetParametersResult]:\n         \u0022\u0022\u0022\n@@ -612,13 \u002B618,14 @@ class Node:\n             )\n             if not result.successful:\n                 if result.reason.startswith(\u0027Wrong parameter type\u0027):\n-                    raise InvalidParameterTypeException(\n-                        param, Parameter.Type(descriptors[param._name].type).name)\n\u002B                    if descriptors:\n\u002B                        raise InvalidParameterTypeException(\n\u002B                            param, Parameter.Type(descriptors[param._name].type).name)\n                 raise InvalidParameterValueException(param.name, param.value, result.reason)\n             results.append(result)\n         return results\n \n-    def undeclare_parameter(self, name: str):\n\u002B    def undeclare_parameter(self, name: str) -\u003E None:\n         \u0022\u0022\u0022\n         Undeclare a previously declared parameter.\n \n@@ -676,7 \u002B683,7 @@ class Node:\n         else:\n             raise ParameterNotDeclaredException(name)\n \n-    def get_parameters(self, names: List[str]) -\u003E List[Parameter]:\n\u002B    def get_parameters(self, names: List[str]) -\u003E List[Parameter[Any]]:\n         \u0022\u0022\u0022\n         Get a list of parameters.\n \n@@ -693,7 \u002B700,7 @@ class Node:\n             raise TypeError(\u0027All names must be instances of type str\u0027)\n         return [self.get_parameter(name) for name in names]\n \n-    def get_parameter(self, name: str) -\u003E Parameter:\n\u002B    def get_parameter(self, name: str) -\u003E Parameter[Any]:\n         \u0022\u0022\u0022\n         Get a parameter by name.\n \n@@ -721,7 \u002B728,7 @@ class Node:\n             raise ParameterNotDeclaredException(name)\n \n     def get_parameter_or(\n-            self, name: str, alternative_value: Optional[Parameter] = None) -\u003E Parameter:\n\u002B            self, name: str, alternative_value: Optional[Parameter[Any]] = None) -\u003E Parameter[Any]:\n         \u0022\u0022\u0022\n         Get a parameter or the alternative value.\n \n@@ -745,7 \u002B752,7 @@ class Node:\n \n         return self._parameters[name]\n \n-    def get_parameters_by_prefix(self, prefix: str) -\u003E Dict[str, Parameter]:\n\u002B    def get_parameters_by_prefix(self, prefix: str) -\u003E Dict[str, Parameter[Any]]:\n         \u0022\u0022\u0022\n         Get parameters that have a given prefix in their names as a dictionary.\n \n@@ -771,7 \u002B778,7 @@ class Node:\n             if param_name.startswith(prefix)\n         }\n \n-    def set_parameters(self, parameter_list: List[Parameter]) -\u003E List[SetParametersResult]:\n\u002B    def set_parameters(self, parameter_list: List[Parameter[Any]]) -\u003E List[SetParametersResult]:\n         \u0022\u0022\u0022\n         Set parameters for the node, and return the result for the set action.\n \n@@ -823,7 \u002B830,8 @@ class Node:\n \n         return results\n \n-    def set_parameters_atomically(self, parameter_list: List[Parameter]) -\u003E SetParametersResult:\n\u002B    def set_parameters_atomically(self, parameter_list: List[Parameter[Any]]\n\u002B                                  ) -\u003E SetParametersResult:\n         \u0022\u0022\u0022\n         Set the given parameters, all at one time, and then aggregate result.\n \n@@ -868,7 \u002B876,7 @@ class Node:\n \n     def _set_parameters_atomically(\n         self,\n-        parameter_list: List[Parameter],\n\u002B        parameter_list: List[Parameter[Any]],\n     ) -\u003E SetParametersResult:\n \n         modified_parameter_list = self._call_pre_set_parameters_callback(parameter_list)\n@@ -888,7 \u002B896,7 @@ class Node:\n \n     def _set_parameters_atomically_common(\n         self,\n-        parameter_list: List[Parameter],\n\u002B        parameter_list: List[Parameter[Any]],\n         descriptors: Optional[Dict[str, ParameterDescriptor]] = None,\n         allow_not_set_type: bool = False\n     ) -\u003E SetParametersResult:\n@@ -979,7 \u002B987,8 @@ class Node:\n                     self._parameters[param.name] = param\n \n             parameter_event.stamp = self._clock.now().to_msg()\n-            self._parameter_event_publisher.publish(parameter_event)\n\u002B            if self._parameter_event_publisher:\n\u002B                self._parameter_event_publisher.publish(parameter_event)\n \n             # call post set parameter registered callbacks\n             self._call_post_set_parameters_callback(parameter_list)\n@@ -1046,7 \u002B1055,7 @@ class Node:\n \n         return result\n \n-    def _check_undeclared_parameters(self, parameter_list: List[Parameter]):\n\u002B    def _check_undeclared_parameters(self, parameter_list: List[Parameter[Any]]) -\u003E None:\n         \u0022\u0022\u0022\n         Check if parameter list has correct types and was declared beforehand.\n \n@@ -1062,9 \u002B1071,10 @@ class Node:\n         if not self._allow_undeclared_parameters and any(undeclared_parameters):\n             raise ParameterNotDeclaredException(list(undeclared_parameters))\n \n-    def _call_pre_set_parameters_callback(self, parameter_list: List[Parameter]):\n\u002B    def _call_pre_set_parameters_callback(self, parameter_list: List[Parameter[Any]]\n\u002B                                          ) -\u003E Optional[List[Parameter[Any]]]:\n         if self._pre_set_parameters_callbacks:\n-            modified_parameter_list = []\n\u002B            modified_parameter_list: List[Parameter[Any]] = []\n             for callback in self._pre_set_parameters_callbacks:\n                 modified_parameter_list.extend(callback(parameter_list))\n \n@@ -1072,14 \u002B1082,14 @@ class Node:\n         else:\n             return None\n \n-    def _call_post_set_parameters_callback(self, parameter_list: List[Parameter]):\n\u002B    def _call_post_set_parameters_callback(self, parameter_list: List[Parameter[Any]]) -\u003E None:\n         if self._post_set_parameters_callbacks:\n             for callback in self._post_set_parameters_callbacks:\n                 callback(parameter_list)\n \n     def add_pre_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], List[Parameter]]\n\u002B            callback: Callable[[List[Parameter[Any]]], List[Parameter[Any]]]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Add a callback gets triggered before parameters are validated.\n@@ -1115,7 \u002B1125,7 @@ class Node:\n \n     def add_on_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], SetParametersResult]\n\u002B            callback: Callable[[List[Parameter[Any]]], SetParametersResult]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Add a callback in front to the list of callbacks.\n@@ -1132,7 \u002B1142,7 @@ class Node:\n \n     def add_post_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], None]\n\u002B            callback: Callable[[List[Parameter[Any]]], None]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Add a callback gets triggered after parameters are set successfully.\n@@ -1153,7 \u002B1163,7 @@ class Node:\n \n     def remove_pre_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], List[Parameter]]\n\u002B            callback: Callable[[List[Parameter[Any]]], List[Parameter[Any]]]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Remove a callback from list of callbacks.\n@@ -1167,7 \u002B1177,7 @@ class Node:\n \n     def remove_on_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], SetParametersResult]\n\u002B            callback: Callable[[List[Parameter[Any]]], SetParametersResult]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Remove a callback from list of callbacks.\n@@ -1181,7 \u002B1191,7 @@ class Node:\n \n     def remove_post_set_parameters_callback(\n             self,\n-            callback: Callable[[List[Parameter]], None]\n\u002B            callback: Callable[[List[Parameter[Any]]], None]\n     ) -\u003E None:\n         \u0022\u0022\u0022\n         Remove a callback from list of callbacks.\n@@ -1195,7 \u002B1205,7 @@ class Node:\n \n     def _apply_descriptors(\n         self,\n-        parameter_list: List[Parameter],\n\u002B        parameter_list: List[Parameter[Any]],\n         descriptors: Dict[str, ParameterDescriptor],\n         check_read_only: bool = True\n     ) -\u003E SetParametersResult:\n@@ -1221,7 \u002B1231,7 @@ class Node:\n \n     def _apply_descriptor(\n         self,\n-        parameter: Parameter,\n\u002B        parameter: Parameter[Any],\n         descriptor: Optional[ParameterDescriptor] = None,\n         check_read_only: bool = True\n     ) -\u003E SetParametersResult:\n@@ -1279,7 \u002B1289,7 @@ class Node:\n \n     def _apply_integer_range(\n         self,\n-        parameter: Parameter,\n\u002B        parameter: Parameter[Any],\n         integer_range: IntegerRange\n     ) -\u003E SetParametersResult:\n         min_value = min(integer_range.from_value, integer_range.to_value)\n@@ -1315,7 \u002B1325,7 @@ class Node:\n \n     def _apply_floating_point_range(\n         self,\n-        parameter: Parameter,\n\u002B        parameter: Parameter[Any],\n         floating_point_range: FloatingPointRange\n     ) -\u003E SetParametersResult:\n         min_value = min(floating_point_range.from_value, floating_point_range.to_value)\n@@ -1360,7 \u002B1370,7 @@ class Node:\n \n     def _apply_descriptor_and_set(\n         self,\n-        parameter: Parameter,\n\u002B        parameter: Parameter[Any],\n         descriptor: Optional[ParameterDescriptor] = None,\n         check_read_only: bool = True\n     ) -\u003E SetParametersResult:\n@@ -1461,7 \u002B1471,8 @@ class Node:\n         self._descriptors[name] = descriptor\n         return self.get_parameter(name).get_parameter_value()\n \n-    def _validate_topic_or_service_name(self, topic_or_service_name, *, is_service=False):\n\u002B    def _validate_topic_or_service_name(self, topic_or_service_name: str, *,\n\u002B                                        is_service: bool = False) -\u003E None:\n         name = self.get_name()\n         namespace = self.get_namespace()\n         validate_node_name(name)\n@@ -1470,7 \u002B1481,7 @@ class Node:\n         expanded_topic_or_service_name = expand_topic_name(topic_or_service_name, name, namespace)\n         validate_full_topic_name(expanded_topic_or_service_name, is_service=is_service)\n \n-    def _validate_qos_or_depth_parameter(self, qos_or_depth) -\u003E QoSProfile:\n\u002B    def _validate_qos_or_depth_parameter(self, qos_or_depth: Union[QoSProfile, int]) -\u003E QoSProfile:\n         if isinstance(qos_or_depth, QoSProfile):\n             return qos_or_depth\n         elif isinstance(qos_or_depth, int):\n@@ -1534,7 \u002B1545,7 @@ class Node:\n         callback_group: Optional[CallbackGroup] = None,\n         event_callbacks: Optional[PublisherEventCallbacks] = None,\n         qos_overriding_options: Optional[QoSOverridingOptions] = None,\n-        publisher_class: Type[Publisher[MsgT]] = Publisher[MsgT],\n\u002B        publisher_class: Type[Publisher[MsgT]] = Publisher,\n     ) -\u003E Publisher[MsgT]:\n         \u0022\u0022\u0022\n         Create a new publisher.\n@@ -1803,7 \u002B1814,7 @@ class Node:\n \n     def create_guard_condition(\n         self,\n-        callback: Callable,\n\u002B        callback: Callable[[], None],\n         callback_group: Optional[CallbackGroup] = None\n     ) -\u003E GuardCondition:\n         \u0022\u0022\u0022\n@@ -1845,7 \u002B1856,7 @@ class Node:\n         timer = self.create_timer(period, callback, group, clock)\n         return Rate(timer, context=self.context)\n \n-    def destroy_publisher(self, publisher: Publisher) -\u003E bool:\n\u002B    def destroy_publisher(self, publisher: Publisher[Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a publisher created by the node.\n \n@@ -1863,7 \u002B1874,7 @@ class Node:\n             return True\n         return False\n \n-    def destroy_subscription(self, subscription: Subscription) -\u003E bool:\n\u002B    def destroy_subscription(self, subscription: Subscription[Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a subscription created by the node.\n \n@@ -1881,7 \u002B1892,7 @@ class Node:\n             return True\n         return False\n \n-    def destroy_client(self, client: Client) -\u003E bool:\n\u002B    def destroy_client(self, client: Client[Any, Any, Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a service client created by the node.\n \n@@ -1897,7 \u002B1908,7 @@ class Node:\n             return True\n         return False\n \n-    def destroy_service(self, service: Service) -\u003E bool:\n\u002B    def destroy_service(self, service: Service[Any, Any, Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a service server created by the node.\n \n@@ -1955,7 \u002B1966,7 @@ class Node:\n         rate.destroy()\n         return success\n \n-    def destroy_node(self):\n\u002B    def destroy_node(self) -\u003E None:\n         \u0022\u0022\u0022\n         Destroy the node.\n \n@@ -2152,7 \u002B2163,7 @@ class Node:\n         with self.handle:\n             return self.handle.get_fully_qualified_name()\n \n-    def _count_publishers_or_subscribers(self, topic_name, func):\n\u002B    def _count_publishers_or_subscribers(self, topic_name: str, func: Callable[[str], int]) -\u003E int:\n         fq_topic_name = expand_topic_name(topic_name, self.get_name(), self.get_namespace())\n         validate_full_topic_name(fq_topic_name)\n         with self.handle:\n@@ -2188,7 \u002B2199,7 @@ class Node:\n             return self._count_publishers_or_subscribers(\n                 topic_name, self.handle.get_count_subscribers)\n \n-    def _count_clients_or_servers(self, service_name, func):\n\u002B    def _count_clients_or_servers(self, service_name: str, func: Callable[[str], int]) -\u003E int:\n         fq_service_name = expand_topic_name(service_name, self.get_name(), self.get_namespace())\n         validate_full_topic_name(fq_service_name, is_service=True)\n         with self.handle:\n@@ -2228,7 \u002B2239,7 @@ class Node:\n         self,\n         topic_name: str,\n         no_mangle: bool,\n-        func: Callable[[object, str, bool], List[Dict]]\n\u002B        func: Callable[[_rclpy.Node, str, bool], List[\u0027_rclpy.TopicEndpointInfoDict\u0027]]\n     ) -\u003E List[TopicEndpointInfo]:\n         with self.handle:\n             if no_mangle:\ndiff --git rclpy/rclpy/parameter.py rclpy/rclpy/parameter.py\nindex 464ee70..e1945ea 100644\n--- rclpy/rclpy/parameter.py\n\u002B\u002B\u002B rclpy/rclpy/parameter.py\n@@ -23,6 \u002B23,7 @@ from typing import Optional\n from typing import overload\n from typing import Tuple\n from typing import TYPE_CHECKING\n\u002Bfrom typing import TypeVar\n from typing import Union\n \n from rcl_interfaces.msg import Parameter as ParameterMsg\n@@ -33,7 \u002B34,6 @@ import yaml\n PARAMETER_SEPARATOR_STRING = \u0027.\u0027\n \n if TYPE_CHECKING:\n-    from typing_extensions import TypeVar\n     # Mypy does not handle string literals of array.array[int/str/float] very well\n     # So if user has newer version of python can use proper array types.\n     if sys.version_info \u003E (3, 9):\n@@ -51,15 \u002B51,13 @@ if TYPE_CHECKING:\n                                         List[float], Tuple[float, ...], \u0027array.array[float]\u0027,\n                                         List[str], Tuple[str, ...], \u0027array.array[str]\u0027]\n \n-    AllowableParameterValueT = TypeVar(\u0027AllowableParameterValueT\u0027,\n-                                       bound=AllowableParameterValue,\n-                                       default=AllowableParameterValue)\n else:\n-    from typing import TypeVar\n     # Done to prevent runtime errors of undefined values.\n     # after python3.13 is minimum support this could be removed.\n     AllowableParameterValue = Any\n-    AllowableParameterValueT = TypeVar(\u0027AllowableParameterValueT\u0027)\n\u002B\n\u002BAllowableParameterValueT = TypeVar(\u0027AllowableParameterValueT\u0027,\n\u002B                                   bound=AllowableParameterValue)\n \n \n class Parameter(Generic[AllowableParameterValueT]):\n@@ -171,9 \u002B169,12 @@ class Parameter(Generic[AllowableParameterValueT]):\n     def __init__(self, name: str, type_: Optional[\u0027Parameter.Type\u0027] = None) -\u003E None: ...\n \n     @overload\n-    def __init__(self, name: str, type_: Optional[\u0027Parameter.Type\u0027],\n\u002B    def __init__(self, name: str, type_: \u0027Parameter.Type\u0027,\n                  value: AllowableParameterValueT) -\u003E None: ...\n \n\u002B    @overload\n\u002B    def __init__(self, name: str, *, value: AllowableParameterValueT) -\u003E None: ...\n\u002B\n     def __init__(self, name: str, type_: Optional[\u0027Parameter.Type\u0027] = None, value=None) -\u003E None:\n         if type_ is None:\n             # This will raise a TypeError if it is not possible to get a type from the value.\ndiff --git rclpy/rclpy/qos.py rclpy/rclpy/qos.py\nindex 6c8b18f..ceb6d23 100644\n--- rclpy/rclpy/qos.py\n\u002B\u002B\u002B rclpy/rclpy/qos.py\n@@ -14,7 \u002B14,7 @@\n \n from enum import Enum, IntEnum\n from typing import (Callable, Iterable, List, Optional, Tuple, Type, TYPE_CHECKING,\n-                    TypedDict, TypeVar, Union)\n\u002B                    TypeVar, Union)\n import warnings\n \n from rclpy.duration import Duration\n@@ -56,18 \u002B56,6 @@ class InvalidQoSProfileException(Exception):\n         Exception(self, f\u0027Invalid QoSProfile: {message}\u0027)\n \n \n-class QoSProfileDictionary(TypedDict):\n-    history: \u0027QoSHistoryPolicy\u0027\n-    depth: int\n-    reliability: \u0027QoSReliabilityPolicy\u0027\n-    durability: \u0027QoSDurabilityPolicy\u0027\n-    lifespan: Duration\n-    deadline: Duration\n-    liveliness: \u0027QoSLivelinessPolicy\u0027\n-    liveliness_lease_duration: Duration\n-    avoid_ros_namespace_conventions: bool\n-\n-\n class QoSProfile:\n     \u0022\u0022\u0022Define Quality of Service policies.\u0022\u0022\u0022\n \ndiff --git rclpy/rclpy/topic_endpoint_info.py rclpy/rclpy/topic_endpoint_info.py\nindex 40301ef..ef5c74c 100644\n--- rclpy/rclpy/topic_endpoint_info.py\n\u002B\u002B\u002B rclpy/rclpy/topic_endpoint_info.py\n@@ -15,7 \u002B15,8 @@\n from enum import IntEnum\n from typing import List, Union\n \n-from rclpy.qos import QoSHistoryPolicy, QoSPresetProfiles, QoSProfile, QoSProfileDictionary\n\u002Bfrom rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n\u002Bfrom rclpy.qos import QoSHistoryPolicy, QoSPresetProfiles, QoSProfile\n from rclpy.type_hash import TypeHash, TypeHashDictionary\n \n \n@@ -159,7 \u002B160,7 @@ class TopicEndpointInfo:\n         return self._qos_profile\n \n     @qos_profile.setter\n-    def qos_profile(self, value: Union[QoSProfile, QoSProfileDictionary]) -\u003E None:\n\u002B    def qos_profile(self, value: Union[QoSProfile, \u0027_rclpy.rmw_qos_profile_dict\u0027]) -\u003E None:\n         if isinstance(value, QoSProfile):\n             self._qos_profile = value\n         elif isinstance(value, dict):\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "9f4acba185a5cd586276ad9bb8432f7fa8b9c626",
    "RawMessage": "Add doTransform function for twists or wrenches (#406)",
    "Changes": "diff --git tf2_eigen/include/tf2_eigen/tf2_eigen.hpp tf2_eigen/include/tf2_eigen/tf2_eigen.hpp\nindex 12866c04..aaf85fc8 100644\n--- tf2_eigen/include/tf2_eigen/tf2_eigen.hpp\n\u002B\u002B\u002B tf2_eigen/include/tf2_eigen/tf2_eigen.hpp\n@@ -127,6 \u002B127,51 @@ void doTransform(\n   t_out = Eigen::Vector3d(transformToEigen(transform) * t_in);\n }\n \n\u002B/** \\brief Apply a geometry_msgs TransformStamped to a 6-long Eigen vector.\n\u002B * Useful for transforming wrenches or twists.\n\u002B * Wrench: (force-x, force-y, force-z, torque-x, torque-y, torque-z)\n\u002B * Twist: (trans. vel. x, trans. vel. y, trans. vel. z, ang. vel. x, ang. vel. y, ang. vel. z)\n\u002B * This function is a specialization of the doTransform template defined in tf2/convert.h,\n\u002B * although it can not be used in tf2_ros::BufferInterface::transform because this\n\u002B * functions rely on the existence of a time stamp and a frame id in the type which should\n\u002B * get transformed.\n\u002B * \\param t_in The vector to transform. Must be 6-long.\n\u002B * \\param t_out The transformed vector. Will be 6-long.\n\u002B * \\param transform The timestamped transform to apply, as a TransformStamped message.\n\u002B */\n\u002Btemplate\u003C\u003E\n\u002Binline\n\u002Bvoid doTransform(\n\u002B  const Eigen::VectorXd \u0026 t_in,\n\u002B  Eigen::VectorXd \u0026 t_out,\n\u002B  const geometry_msgs::msg::TransformStamped \u0026 transform)\n\u002B{\n\u002B  // References:\n\u002B  // https://core.ac.uk/download/pdf/154240607.pdf, https://www.seas.upenn.edu/~meam520/notes02/Forces8.pdf\n\u002B\n\u002B  Eigen::Isometry3d affine_transform = tf2::transformToEigen(transform);\n\u002B\n\u002B  // Build the 6x6 transformation matrix\n\u002B  Eigen::MatrixXd twist_transform(6, 6);\n\u002B  // upper left 3x3 block is the rotation part\n\u002B  twist_transform.block(0, 0, 3, 3) = affine_transform.rotation();\n\u002B  // upper right 3x3 block is all zeros\n\u002B  twist_transform.block(0, 3, 3, 3) = Eigen::MatrixXd::Zero(3, 3);\n\u002B  // lower left 3x3 block is tricky. See https://core.ac.uk/download/pdf/154240607.pdf\n\u002B  Eigen::MatrixXd pos_vector_3x3(3, 3);\n\u002B  // Disable formatting checks so the matrix remains human-readable\n\u002B  /* *INDENT-OFF* */\n\u002B  pos_vector_3x3 \u003C\u003C 0, -affine_transform.translation().z(), affine_transform.translation().y(),\n\u002B                    affine_transform.translation().z(), 0, -affine_transform.translation().x(),\n\u002B                    -affine_transform.translation().y(), affine_transform.translation().x(), 0;\n\u002B  /* *INDENT-ON* */\n\u002B  twist_transform.block(3, 0, 3, 3) = pos_vector_3x3 * affine_transform.rotation();\n\u002B  // lower right 3x3 block is the rotation part\n\u002B  twist_transform.block(3, 3, 3, 3) = affine_transform.rotation();\n\u002B\n\u002B  t_out = twist_transform * t_in;\n\u002B}\n\u002B\n /** \\brief Convert a Eigen Vector3d type to a Point message.\n  * This function is a specialization of the toMsg template defined in tf2/convert.h.\n  * \\param in The timestamped Eigen Vector3d to convert.\ndiff --git tf2_eigen/test/tf2_eigen-test.cpp tf2_eigen/test/tf2_eigen-test.cpp\nindex 8a8a1112..aa9de709 100644\n--- tf2_eigen/test/tf2_eigen-test.cpp\n\u002B\u002B\u002B tf2_eigen/test/tf2_eigen-test.cpp\n@@ -239,6 \u002B239,34 @@ TEST_F(EigenBufferTransform, Vector)\n   EXPECT_NEAR(v_advanced.z(), 27, EPS);\n }\n \n\u002B// Test transformation of a 6-long wrench or twist\n\u002BTEST_F(EigenBufferTransform, WrenchTransform)\n\u002B{\n\u002B  // Transform the wrench (due to gravity) of a point mass to a different frame\n\u002B\n\u002B  double mass = 1.0;\n\u002B  double gravity = -9.81;\n\u002B  // Negative y force, no moment\n\u002B  Eigen::VectorXd wrench_in(6);\n\u002B  wrench_in \u003C\u003C 0., mass * gravity, 0., 0., 0., 0.;\n\u002B\n\u002B  // The new frame is not rotated at all but it is offset along x-axis\n\u002B  double x_offset = -0.1;\n\u002B  geometry_msgs::msg::TransformStamped tf_to_new_frame;\n\u002B  tf_to_new_frame.transform.translation.x = x_offset;\n\u002B  tf_to_new_frame.transform.rotation.w = 1.0;\n\u002B\n\u002B  Eigen::VectorXd wrench_out(6);\n\u002B  tf2::doTransform(wrench_in, wrench_out, tf_to_new_frame);\n\u002B\n\u002B  EXPECT_NEAR(wrench_out(0), 0., EPS);\n\u002B  EXPECT_NEAR(wrench_out(1), mass * gravity, EPS);\n\u002B  EXPECT_NEAR(wrench_out(2), 0., EPS);\n\u002B  EXPECT_NEAR(wrench_out(3), 0., EPS);\n\u002B  EXPECT_NEAR(wrench_out(4), 0., EPS);\n\u002B  EXPECT_NEAR(wrench_out(5), mass * gravity * x_offset, EPS);\n\u002B}\n\u002B\n // helper method for Quaternion tests\n ::testing::AssertionResult EigenBufferTransform::doTestEigenQuaternion(\n   const Eigen::Quaterniond \u0026 parameter, const Eigen::Quaterniond \u0026 expected)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "51dfdc3708f37b880d82550b056d985fb8a4e446",
    "RawMessage": "Skip some tests in test_qos_event and run others with event types supported by rmw_zenoh (#2626)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_qos_event.cpp rclcpp/test/rclcpp/test_qos_event.cpp\nindex 8b7d8f97..634d4837 100644\n--- rclcpp/test/rclcpp/test_qos_event.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_qos_event.cpp\n@@ -33,13 \u002B33,14 @@ using namespace std::chrono_literals;\n class TestQosEvent : public ::testing::Test\n {\n protected:\n-  static void SetUpTestCase()\n\u002B  void SetUp()\n   {\n\u002B    // We initialize and shutdown the context (and hence also the rmw_context),\n\u002B    // for each test case to reset the ROS graph for each test case.\n     rclcpp::init(0, nullptr);\n-  }\n \n-  void SetUp()\n-  {\n\u002B    rmw_implementation_str = std::string(rmw_get_implementation_identifier());\n\u002B\n     node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_qos_event\u0022, \u0022/ns\u0022);\n \n     message_callback = [node = node.get()](test_msgs::msg::Empty::ConstSharedPtr /*msg*/) {\n@@ -50,13 \u002B51,10 @@ protected:\n   void TearDown()\n   {\n     node.reset();\n-  }\n-\n-  static void TearDownTestCase()\n-  {\n     rclcpp::shutdown();\n   }\n \n\u002B  std::string rmw_implementation_str;\n   static constexpr char topic_name[] = \u0022test_topic\u0022;\n   rclcpp::Node::SharedPtr node;\n   std::function\u003Cvoid(test_msgs::msg::Empty::ConstSharedPtr)\u003E message_callback;\n@@ -75,28 \u002B73,29 @@ TEST_F(TestQosEvent, test_publisher_constructor)\n   auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n     topic_name, 10, options);\n \n-  // options arg with one of the callbacks\n-  options.event_callbacks.deadline_callback =\n-    [node = node.get()](rclcpp::QOSDeadlineOfferedInfo \u0026 event) {\n-      RCLCPP_INFO(\n-        node-\u003Eget_logger(),\n-        \u0022Offered deadline missed - total %d (delta %d)\u0022,\n-        event.total_count, event.total_count_change);\n-    };\n-  publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n-    topic_name, 10, options);\n-\n-  // options arg with two of the callbacks\n-  options.event_callbacks.liveliness_callback =\n-    [node = node.get()](rclcpp::QOSLivelinessLostInfo \u0026 event) {\n-      RCLCPP_INFO(\n-        node-\u003Eget_logger(),\n-        \u0022Liveliness lost - total %d (delta %d)\u0022,\n-        event.total_count, event.total_count_change);\n-    };\n-  publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n-    topic_name, 10, options);\n-\n\u002B  if (rmw_implementation_str != \u0022rmw_zenoh_cpp\u0022) {\n\u002B    // options arg with one of the callbacks\n\u002B    options.event_callbacks.deadline_callback =\n\u002B      [node = node.get()](rclcpp::QOSDeadlineOfferedInfo \u0026 event) {\n\u002B        RCLCPP_INFO(\n\u002B          node-\u003Eget_logger(),\n\u002B          \u0022Offered deadline missed - total %d (delta %d)\u0022,\n\u002B          event.total_count, event.total_count_change);\n\u002B      };\n\u002B    publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, 10, options);\n\u002B\n\u002B    // options arg with two of the callbacks\n\u002B    options.event_callbacks.liveliness_callback =\n\u002B      [node = node.get()](rclcpp::QOSLivelinessLostInfo \u0026 event) {\n\u002B        RCLCPP_INFO(\n\u002B          node-\u003Eget_logger(),\n\u002B          \u0022Liveliness lost - total %d (delta %d)\u0022,\n\u002B          event.total_count, event.total_count_change);\n\u002B      };\n\u002B    publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, 10, options);\n\u002B  }\n   // options arg with three of the callbacks\n   options.event_callbacks.incompatible_qos_callback =\n     [node = node.get()](rclcpp::QOSOfferedIncompatibleQoSInfo \u0026 event) {\n@@ -114,35 \u002B113,38 @@ TEST_F(TestQosEvent, test_publisher_constructor)\n  */\n TEST_F(TestQosEvent, test_subscription_constructor)\n {\n\u002B  // While rmw_zenoh does not support Deadline/LivelinessChanged events,\n\u002B  // it does support IncompatibleQoS\n   rclcpp::SubscriptionOptions options;\n \n   // options arg with no callbacks\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n     topic_name, 10, message_callback, options);\n \n-  // options arg with one of the callbacks\n-  options.event_callbacks.deadline_callback =\n-    [node = node.get()](rclcpp::QOSDeadlineRequestedInfo \u0026 event) {\n-      RCLCPP_INFO(\n-        node-\u003Eget_logger(),\n-        \u0022Requested deadline missed - total %d (delta %d)\u0022,\n-        event.total_count, event.total_count_change);\n-    };\n-  subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    topic_name, 10, message_callback, options);\n-\n-  // options arg with two of the callbacks\n-  options.event_callbacks.liveliness_callback =\n-    [node = node.get()](rclcpp::QOSLivelinessChangedInfo \u0026 event) {\n-      RCLCPP_INFO(\n-        node-\u003Eget_logger(),\n-        \u0022Liveliness changed - alive %d (delta %d), not alive %d (delta %d)\u0022,\n-        event.alive_count, event.alive_count_change,\n-        event.not_alive_count, event.not_alive_count_change);\n-    };\n-  subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    topic_name, 10, message_callback, options);\n-\n\u002B  if (rmw_implementation_str != \u0022rmw_zenoh_cpp\u0022) {\n\u002B    // options arg with one of the callbacks\n\u002B    options.event_callbacks.deadline_callback =\n\u002B      [node = node.get()](rclcpp::QOSDeadlineRequestedInfo \u0026 event) {\n\u002B        RCLCPP_INFO(\n\u002B          node-\u003Eget_logger(),\n\u002B          \u0022Requested deadline missed - total %d (delta %d)\u0022,\n\u002B          event.total_count, event.total_count_change);\n\u002B      };\n\u002B    subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, 10, message_callback, options);\n\u002B\n\u002B    // options arg with two of the callbacks\n\u002B    options.event_callbacks.liveliness_callback =\n\u002B      [node = node.get()](rclcpp::QOSLivelinessChangedInfo \u0026 event) {\n\u002B        RCLCPP_INFO(\n\u002B          node-\u003Eget_logger(),\n\u002B          \u0022Liveliness changed - alive %d (delta %d), not alive %d (delta %d)\u0022,\n\u002B          event.alive_count, event.alive_count_change,\n\u002B          event.not_alive_count, event.not_alive_count_change);\n\u002B      };\n\u002B    subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, 10, message_callback, options);\n\u002B  }\n   // options arg with three of the callbacks\n   options.event_callbacks.incompatible_qos_callback =\n     [node = node.get()](rclcpp::QOSRequestedIncompatibleQoSInfo \u0026 event) {\n@@ -209,14 \u002B211,19 @@ TEST_F(TestQosEvent, test_default_incompatible_qos_callbacks)\n   const auto timeout = std::chrono::seconds(10);\n   ex.spin_until_future_complete(log_msgs_future, timeout);\n \n-  EXPECT_EQ(\n-    \u0022New subscription discovered on topic \u0027/ns/test_topic\u0027, requesting incompatible QoS. \u0022\n-    \u0022No messages will be sent to it. Last incompatible policy: DURABILITY_QOS_POLICY\u0022,\n-    pub_log_msg);\n-  EXPECT_EQ(\n-    \u0022New publisher discovered on topic \u0027/ns/test_topic\u0027, offering incompatible QoS. \u0022\n-    \u0022No messages will be sent to it. Last incompatible policy: DURABILITY_QOS_POLICY\u0022,\n-    sub_log_msg);\n\u002B  if (rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022) {\n\u002B    EXPECT_EQ(rclcpp::QoSCompatibility::Ok,\n\u002B      qos_check_compatible(qos_profile_publisher, qos_profile_subscription).compatibility);\n\u002B  } else {\n\u002B    EXPECT_EQ(\n\u002B      \u0022New subscription discovered on topic \u0027/ns/test_topic\u0027, requesting incompatible QoS. \u0022\n\u002B      \u0022No messages will be sent to it. Last incompatible policy: DURABILITY_QOS_POLICY\u0022,\n\u002B      pub_log_msg);\n\u002B    EXPECT_EQ(\n\u002B      \u0022New publisher discovered on topic \u0027/ns/test_topic\u0027, offering incompatible QoS. \u0022\n\u002B      \u0022No messages will be sent to it. Last incompatible policy: DURABILITY_QOS_POLICY\u0022,\n\u002B      sub_log_msg);\n\u002B  }\n \n   rcutils_logging_set_output_handler(original_output_handler);\n }\n@@ -228,7 \u002B235,8 @@ TEST_F(TestQosEvent, construct_destruct_rcl_error) {\n \n   // This callback requires some type of parameter, but it could be anything\n   auto callback = [](int) {};\n-  const rcl_publisher_event_type_t event_type = RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n\u002B  const rcl_publisher_event_type_t event_type = rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022 ?\n\u002B    RCL_PUBLISHER_MATCHED : RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n \n   {\n     // Logs error and returns\n@@ -265,13 \u002B273,16 @@ TEST_F(TestQosEvent, construct_destruct_rcl_error) {\n }\n \n TEST_F(TestQosEvent, execute) {\n\u002B  if (rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022) {\n\u002B    GTEST_SKIP();\n\u002B  }\n   auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(topic_name, 10);\n   auto rcl_handle = publisher-\u003Eget_publisher_handle();\n \n   bool handler_callback_executed = false;\n   // This callback requires some type of parameter, but it could be anything\n   auto callback = [\u0026handler_callback_executed](int) {handler_callback_executed = true;};\n-  rcl_publisher_event_type_t event_type = RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n\u002B  const rcl_publisher_event_type_t event_type = RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n \n   rclcpp::EventHandler\u003Cdecltype(callback), decltype(rcl_handle)\u003E handler(\n     callback, rcl_publisher_event_init, rcl_handle, event_type);\n@@ -297,8 \u002B308,9 @@ TEST_F(TestQosEvent, add_to_wait_set) {\n   // This callback requires some type of parameter, but it could be anything\n   auto callback = [](int) {};\n \n-  rcl_publisher_event_type_t event_type = RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n-  rclcpp::EventHandler\u003Cdecltype(callback), decltype(rcl_handle)\u003E handler(\n\u002B  const rcl_publisher_event_type_t event_type = rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022 ?\n\u002B    RCL_PUBLISHER_MATCHED : RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;\n\u002B   rclcpp::EventHandler\u003Cdecltype(callback), decltype(rcl_handle)\u003E handler(\n     callback, rcl_publisher_event_init, rcl_handle, event_type);\n \n   EXPECT_EQ(1u, handler.get_number_of_ready_events());\n@@ -319,6 \u002B331,10 @@ TEST_F(TestQosEvent, add_to_wait_set) {\n \n TEST_F(TestQosEvent, test_on_new_event_callback)\n {\n\u002B  if (rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022) {\n\u002B    GTEST_SKIP();\n\u002B  }\n\u002B\n   auto offered_deadline = rclcpp::Duration(std::chrono::milliseconds(1));\n   auto requested_deadline = rclcpp::Duration(std::chrono::milliseconds(2));\n \n@@ -364,18 \u002B380,19 @@ TEST_F(TestQosEvent, test_invalid_on_new_event_callback)\n   auto sub = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(topic_name, 10, message_callback);\n   auto dummy_cb = [](size_t count_events) {(void)count_events;};\n \n-  EXPECT_NO_THROW(\n-    pub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_PUBLISHER_OFFERED_DEADLINE_MISSED));\n\u002B  if (rmw_implementation_str != \u0022rmw_zenoh_cpp\u0022) {\n\u002B    EXPECT_NO_THROW(\n\u002B      pub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_PUBLISHER_OFFERED_DEADLINE_MISSED));\n \n-  EXPECT_NO_THROW(\n-    pub-\u003Eclear_on_new_qos_event_callback(RCL_PUBLISHER_OFFERED_DEADLINE_MISSED));\n\u002B    EXPECT_NO_THROW(\n\u002B      pub-\u003Eclear_on_new_qos_event_callback(RCL_PUBLISHER_OFFERED_DEADLINE_MISSED));\n \n-  EXPECT_NO_THROW(\n-    pub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_PUBLISHER_LIVELINESS_LOST));\n\u002B    EXPECT_NO_THROW(\n\u002B      pub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_PUBLISHER_LIVELINESS_LOST));\n \n-  EXPECT_NO_THROW(\n\u002B    EXPECT_NO_THROW(\n     pub-\u003Eclear_on_new_qos_event_callback(RCL_PUBLISHER_LIVELINESS_LOST));\n-\n\u002B  }\n   EXPECT_NO_THROW(\n     pub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS));\n \n@@ -388,18 \u002B405,19 @@ TEST_F(TestQosEvent, test_invalid_on_new_event_callback)\n   EXPECT_NO_THROW(\n     pub-\u003Eclear_on_new_qos_event_callback(RCL_PUBLISHER_MATCHED));\n \n-  EXPECT_NO_THROW(\n-    sub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED));\n\u002B  if (rmw_implementation_str == \u0022rmw_zenoh_cpp\u0022) {\n\u002B    EXPECT_NO_THROW(\n\u002B      sub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED));\n \n-  EXPECT_NO_THROW(\n-    sub-\u003Eclear_on_new_qos_event_callback(RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED));\n\u002B    EXPECT_NO_THROW(\n\u002B      sub-\u003Eclear_on_new_qos_event_callback(RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED));\n \n-  EXPECT_NO_THROW(\n-    sub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_SUBSCRIPTION_LIVELINESS_CHANGED));\n-\n-  EXPECT_NO_THROW(\n-    sub-\u003Eclear_on_new_qos_event_callback(RCL_SUBSCRIPTION_LIVELINESS_CHANGED));\n\u002B    EXPECT_NO_THROW(\n\u002B      sub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_SUBSCRIPTION_LIVELINESS_CHANGED));\n \n\u002B    EXPECT_NO_THROW(\n\u002B      sub-\u003Eclear_on_new_qos_event_callback(RCL_SUBSCRIPTION_LIVELINESS_CHANGED));\n\u002B  }\n   EXPECT_NO_THROW(\n     sub-\u003Eset_on_new_qos_event_callback(dummy_cb, RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS));\n \n@@ -412,24 \u002B430,26 @@ TEST_F(TestQosEvent, test_invalid_on_new_event_callback)\n   EXPECT_NO_THROW(\n     sub-\u003Eclear_on_new_qos_event_callback(RCL_SUBSCRIPTION_MATCHED));\n \n-  std::function\u003Cvoid(size_t)\u003E invalid_cb;\n\u002B  if (rmw_implementation_str != \u0022rmw_zenoh_cpp\u0022) {\n\u002B    std::function\u003Cvoid(size_t)\u003E invalid_cb;\n \n-  rclcpp::SubscriptionOptions sub_options;\n-  sub_options.event_callbacks.deadline_callback = [](auto) {};\n-  sub = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    topic_name, 10, message_callback, sub_options);\n\u002B    rclcpp::SubscriptionOptions sub_options;\n\u002B    sub_options.event_callbacks.deadline_callback = [](auto) {};\n\u002B    sub = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B      topic_name, 10, message_callback, sub_options);\n \n-  EXPECT_THROW(\n-    sub-\u003Eset_on_new_qos_event_callback(invalid_cb, RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED),\n-    std::invalid_argument);\n\u002B    EXPECT_THROW(\n\u002B      sub-\u003Eset_on_new_qos_event_callback(invalid_cb, RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED),\n\u002B      std::invalid_argument);\n \n-  rclcpp::PublisherOptions pub_options;\n-  pub_options.event_callbacks.deadline_callback = [](auto) {};\n-  pub = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(topic_name, 10, pub_options);\n\u002B    rclcpp::PublisherOptions pub_options;\n\u002B    pub_options.event_callbacks.deadline_callback = [](auto) {};\n\u002B    pub = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(topic_name, 10, pub_options);\n \n-  EXPECT_THROW(\n-    pub-\u003Eset_on_new_qos_event_callback(invalid_cb, RCL_PUBLISHER_OFFERED_DEADLINE_MISSED),\n-    std::invalid_argument);\n\u002B    EXPECT_THROW(\n\u002B      pub-\u003Eset_on_new_qos_event_callback(invalid_cb, RCL_PUBLISHER_OFFERED_DEADLINE_MISSED),\n\u002B      std::invalid_argument);\n\u002B  }\n }\n \n TEST_F(TestQosEvent, test_pub_matched_event_by_set_event_callback)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "1f5a713d9bb262ffd04e83fd4c59860037701e85",
    "RawMessage": "[rcl_yaml_param_parser] Add warnings (#831)",
    "Changes": "diff --git rcl_yaml_param_parser/CMakeLists.txt rcl_yaml_param_parser/CMakeLists.txt\nindex 218801b..397f662 100644\n--- rcl_yaml_param_parser/CMakeLists.txt\n\u002B\u002B\u002B rcl_yaml_param_parser/CMakeLists.txt\n@@ -13,7 \u002B13,10 @@ if(NOT CMAKE_CXX_STANDARD)\n endif()\n \n if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \u0022Clang\u0022)\n-  add_compile_options(-Wall -Wextra -Wpedantic)\n\u002B  add_compile_options(\n\u002B    -Wall -Wextra -Wpedantic\n\u002B    -Wformat=2 -Wconversion -Wsign-conversion\n\u002B  )\n endif()\n \n set(rcl_yaml_parser_sources\ndiff --git rcl_yaml_param_parser/src/parse.c rcl_yaml_param_parser/src/parse.c\nindex c7cd69c..acce68a 100644\n--- rcl_yaml_param_parser/src/parse.c\n\u002B\u002B\u002B rcl_yaml_param_parser/src/parse.c\n@@ -501,7 \u002B501,7 @@ _validate_name(const char * name, rcutils_allocator_t allocator)\n     }\n   } else {\n     // substring namespace including the last \u0027/\u0027\n-    char * namespace_ = rcutils_strndup(name, separator_pos - name \u002B 1, allocator);\n\u002B    char * namespace_ = rcutils_strndup(name, ((size_t) (separator_pos - name)) \u002B 1, allocator);\n     if (NULL == namespace_) {\n       ret = RCUTILS_RET_BAD_ALLOC;\n       goto clean;\n@@ -534,7 \u002B534,7 @@ _validate_name(const char * name, rcutils_allocator_t allocator)\n       }\n     } else {\n       do {\n-        size_t len = separator_pos - absolute_namespace - i;\n\u002B        size_t len = ((size_t) (separator_pos - absolute_namespace)) - i;\n         char * namespace_ = rcutils_strndup(absolute_namespace \u002B i, len, allocator);\n         if (NULL == namespace_) {\n           ret = RCUTILS_RET_BAD_ALLOC;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "4f07ae1675ccbcf445d757d5d14450be03924a8c",
    "RawMessage": "Update quality declaration and coverage (#674)",
    "Changes": "diff --git rcl/QUALITY_DECLARATION.md rcl/QUALITY_DECLARATION.md\nindex 2c9a0de..021503a 100644\n--- rcl/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rcl/QUALITY_DECLARATION.md\n@@ -2,7 \u002B2,7 @@ This document is a declaration of software quality for the \u0060rcl\u0060 package, based\n \n # \u0060rcl\u0060 Quality Declaration\n \n-The package \u0060rcl\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rcl\u0060 claims to be in the **Quality Level 3** category.\n \n Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n \n@@ -101,7 \u002B101,9 @@ Currently nightly test results can be seen here:\n \n ### Public API Testing [4.ii]\n \n-Most of the functionality of the declared API in this package is covered in its unit tests. Currently it has a line coverage of [77%](https://ci.ros2.org/job/ci_linux_coverage/85/cobertura/src_ros2_rcl_rcl_src_rcl/).\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n\u002B\n\u002BThe following functions are partially supported: \u0060rcl_take_loaned_message\u0060, \u0060rcl_return_loaned_message_from_subscription\u0060, \u0060rcl_borrow_loaned_message\u0060, \u0060rcl_return_loaned_message_from_publisher\u0060 and \u0060rcl_publish_loaned_message\u0060 because they are not currently supported on Tier 1 RMW providers.\n \n ### Coverage [4.iii]\n \n@@ -114,7 \u002B116,7 @@ This includes:\n \n Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n \n-Current coverage statistics can be viewed (77%) [here](https://ci.ros2.org/job/ci_linux_coverage/85/cobertura/src_ros2_rcl_rcl_src_rcl/). Current coverage statistics need to be improved to reach a higher quality level.\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_src_rcl/). A description of how coverage statistics are calculated is summarized in this page [\u0022ROS 2 Onboarding Guide\u0022](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n@@ -167,7 \u002B169,7 @@ It is **Quality Level 4**, see its [Quality Declaration document](https://github\n \n The \u0060rcutils\u0060 package provides an API which contains common utilities and data structures needed when programming in C.\n \n-It is **Quality Level 4**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n\u002BIt is **Quality Level 2**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n \n #### \u0060rmw_implementation\u0060\n \ndiff --git rcl/README.md rcl/README.md\nindex c7f7783..c602d80 100644\n--- rcl/README.md\n\u002B\u002B\u002B rcl/README.md\n@@ -4,4 \u002B4,4 @@ Library to support implementation of language specific ROS Client Libraries.\n \n Features are described in detail at [http://docs.ros2.org](http://docs.ros2.org/latest/api/rcl/index.html)\n \n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\ndiff --git rcl_action/QUALITY_DECLARATION.md rcl_action/QUALITY_DECLARATION.md\nindex 7dec8d8..9966b2a 100644\n--- rcl_action/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rcl_action/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rcl_action\u0060 package,\n \n # \u0060rcl_action\u0060 Quality Declaration\n \n-The package \u0060rcl_action\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rcl_action\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n \n ## Version Policy [1]\n \n@@ -88,15 \u002B88,29 @@ The results of the test can be found [here](https://ci.ros2.org/view/nightly/job\n \n \u0060rcl_action\u0060 has feature tests, which test for proper node state transitions.\n The tests are located in the [test](test) subdirectory.\n\u002BNew features are required to have tests before being added.\n\u002BCurrently nightly test results can be seen here:\n\u002B* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rcl_action/)\n\u002B* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rcl_action/)\n\u002B* [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rcl_action/)\n\u002B* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rcl_action/)\n \n ### Public API Testing [4.ii]\n \n-Much of the API in \u0060rcl_action\u0060 is tested.\n-The tests are located in the [test](test) subdirectory.\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n \n ### Coverage [4.iii]\n \n-\u0060rcl_action\u0060 does not currently track test coverage.\n\u002B\u0060rcl_action\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_action_src_rcl_action/). A description of how coverage statistics are calculated is summarized in this page [\u0022ROS 2 Onboarding Guide\u0022](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n@@ -129,13 \u002B143,13 @@ It is **Quality Level 4**, see its [Quality Declaration document](https://github\n \n \u0060rcl\u0060 is the ROS 2 client library in C.\n \n-It is **Quality Level 4**, see its [Quality Declaration document](../rcl/QUALITY_DECLARATION).\n\u002BIt is **Quality Level 3**, see its [Quality Declaration document](../rcl/QUALITY_DECLARATION).\n \n #### \u0060rcutils\u0060\n \n \u0060rcutils\u0060 provides commonly used functionality in C.\n \n-It is **Quality Level 4**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n\u002BIt is **Quality Level 2**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n \n #### \u0060rmw\u0060\n \ndiff --git rcl_action/README.md rcl_action/README.md\nindex bd9e267..2f74f5b 100644\n--- rcl_action/README.md\n\u002B\u002B\u002B rcl_action/README.md\n@@ -9,4 \u002B9,4 @@ http://design.ros2.org/articles/actions.html\n \n ## Quality Declaration\n \n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\ndiff --git rcl_lifecycle/QUALITY_DECLARATION.md rcl_lifecycle/QUALITY_DECLARATION.md\nindex 933d0be..837996f 100644\n--- rcl_lifecycle/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rcl_lifecycle/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rcl_lifecycle\u0060 packa\n \n # \u0060rcl_lifecycle\u0060 Quality Declaration\n \n-The package \u0060rcl_lifecycle\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rcl_lifecycle\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n \n ## Version Policy [1]\n \n@@ -88,14 \u002B88,30 @@ The results of the test can be found [here](https://ci.ros2.org/view/nightly/job\n \n \u0060rcl_lifecycle\u0060 has feature tests, which test for proper node state transitions.\n The tests are located in the [test](test) subdirectory.\n\u002BNew features are required to have tests before being added.\n\u002BCurrently nightly test results can be seen here:\n\u002B* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rcl_lifecycle/)\n\u002B* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rcl_lifecycle/)\n\u002B* [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rcl_lifecycle/)\n\u002B* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rcl_lifecycle/)\n\u002B\n \n ### Public API Testing [4.ii]\n \n-Much of the API in \u0060rcl_lifecycle\u0060 is tested in the aforementioned feature tests, but it is not tested explicitly.\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n \n ### Coverage [4.iii]\n \n-\u0060rcl_lifecycle\u0060 does not currently track test coverage.\n\u002B\u0060rcl_lifecycle\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_lifecycle_src/). A description of how coverage statistics are calculated is summarized in this page [\u0022ROS 2 Onboarding Guide\u0022](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n@@ -128,7 \u002B144,7 @@ It is **Quality Level 4**, see its [Quality Declaration document](https://github\n \n \u0060rcl\u0060 is the ROS 2 client library in C.\n \n-It is **Quality Level 4**, see its [Quality Declaration document](../rcl/QUALITY_DECLARATION).\n\u002BIt is **Quality Level 3**, see its [Quality Declaration document](../rcl/QUALITY_DECLARATION).\n \n #### \u0060rcutils\u0060\n \ndiff --git rcl_lifecycle/README.md rcl_lifecycle/README.md\nindex e6fabf0..a161d08 100644\n--- rcl_lifecycle/README.md\n\u002B\u002B\u002B rcl_lifecycle/README.md\n@@ -9,4 \u002B9,4 @@ https://design.ros2.org/articles/node_lifecycle.html\n \n ## Quality Declaration\n \n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\ndiff --git rcl_yaml_param_parser/QUALITY_DECLARATION.md rcl_yaml_param_parser/QUALITY_DECLARATION.md\nindex aa3f4bb..f429290 100644\n--- rcl_yaml_param_parser/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rcl_yaml_param_parser/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rcl_yaml_param_parse\n \n # \u0060rcl_yaml_param_parser\u0060 Quality Declaration\n \n-The package \u0060rcl_yaml_param_parser\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rcl_yaml_param_parser\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories).\n \n ## Version Policy [1]\n \n@@ -59,10 \u002B59,12 @@ All pull requests must resolve related documentation changes before merging.\n \n ### Feature Documentation [3.i]\n \n-\u0060rcl_yaml_param_parser\u0060 does not have feature documentation.\n\u002B\u0060rcl_yaml_param_parser\u0060 provides the main elements of its API listed using doxygen and is hosted [here](http://docs.ros2.org/latest/api/rcl_yaml_param_parser/index.html).\n \n ### Public API Documentation [3.ii]\n \n\u002B\u0060rcl_yaml_param_parser\u0060 has embedded API documentation and it is generated using doxygen. Currently, its latest version is hosted [here](http://docs.ros2.org/latest/api/rcl_yaml_param_parser/index.html). Latest version has to be generated before considering this item fully resolved.\n\u002B\n All of \u0060rcl_yaml_param_parser\u0060 has embedded API documentation. It is not yet hosted publicly.\n \n ### License [3.iii]\n@@ -85,15 \u002B87,30 @@ The results of the test can be found [here](https://ci.ros2.org/view/nightly/job\n \n ### Feature Testing [4.i]\n \n-\u0060rcl_yaml_param_parser\u0060 has feature tests, which ensure that a wide variety of yaml files are checked for parsing.\n\u002BMost features in \u0060rcl_yaml_param_parser\u0060 have corresponding tests which simulate typical usage, and they are located in the [\u0060test\u0060](./test) directory.\n\u002BNew features are required to have tests before being added.\n\u002BCurrently nightly test results can be seen here:\n\u002B* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rcl_yaml_param_parser/)\n\u002B* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rcl_yaml_param_parser/)\n\u002B* [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rcl_yaml_param_parser/)\n\u002B* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rcl_yaml_param_parser/)\n \n ### Public API Testing [4.ii]\n \n-Much of the API in \u0060rcl_yaml_param_parser\u0060 is tested in the aforementioned feature tests, but it is not tested explicitly.\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n \n ### Coverage [4.iii]\n \n-\u0060rcl_yaml_param_parser\u0060 does not currently track test coverage.\n\u002B\u0060rcl_yaml_param_parser\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/nightly_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcl_rcl_yaml_param_parser_src/). A description of how coverage statistics are calculated is summarized in this page [\u0022ROS 2 Onboarding Guide\u0022](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n@@ -118,7 \u002B135,7 @@ It also has several test dependencies, which do not affect the resulting quality\n \n \u0060rcutils\u0060 provides commonly used functionality in C.\n \n-It is **Quality Level 4**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n\u002BIt is **Quality Level 3**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n \n #### \u0060libyaml_vendor\u0060\n \ndiff --git rcl_yaml_param_parser/README.md rcl_yaml_param_parser/README.md\nindex 7e57104..e402a1e 100644\n--- rcl_yaml_param_parser/README.md\n\u002B\u002B\u002B rcl_yaml_param_parser/README.md\n@@ -30,4 \u002B30,4 @@ This package depends on C libyaml.\n \n ## Quality Declaration\n \n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "8de4b90512469d74802871e6c88db2e3135720e7",
    "RawMessage": "avoid adding notify waitable twice to events-executor collection (#2564)",
    "Changes": "diff --git rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\nindex ce6a103a..c7d6be7e 100644\n--- rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n@@ -415,14 \u002B415,11 @@ EventsExecutor::refresh_current_collection_from_callback_groups()\n   // We could explicitly check for the notify waitable ID when we receive a waitable event\n   // but I think that it\u0027s better if the waitable was in the collection and it could be\n   // retrieved in the \u0022standard\u0022 way.\n-  // To do it, we need to add the notify waitable as an entry in both the new and\n-  // current collections such that it\u0027s neither added or removed.\n\u002B  // To do it, we need to add the notify waitable as an entry in the new collection\n\u002B  // such that it\u0027s neither added or removed (it should have already been added\n\u002B  // to the current collection in the constructor)\n   this-\u003Eadd_notify_waitable_to_collection(new_collection.waitables);\n \n-  // Acquire lock before modifying the current collection\n-  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(collection_mutex_);\n-  this-\u003Eadd_notify_waitable_to_collection(current_entities_collection_-\u003Ewaitables);\n-\n   this-\u003Erefresh_current_collection(new_collection);\n }\n \ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex a82b702d..dfbdbb8f 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -807,6 \u002B807,67 @@ TYPED_TEST(TestExecutors, testRaceConditionAddNode)\n   }\n }\n \n\u002B// Check that executors are correctly notified while they are spinning\n\u002B// we notify twice to ensure that the notify waitable is still working\n\u002B// after the first notification\n\u002BTYPED_TEST(TestExecutors, notifyTwiceWhileSpinning)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B\n\u002B  // Create executor, add the node and start spinning\n\u002B  ExecutorType executor;\n\u002B  executor.add_node(this-\u003Enode);\n\u002B  std::thread spinner([\u0026]() {executor.spin();});\n\u002B\n\u002B  // Wait for executor to be spinning\n\u002B  while (!executor.is_spinning()) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B\n\u002B  // Create the first subscription while the executor is already spinning\n\u002B  std::atomic\u003Csize_t\u003E sub1_msg_count {0};\n\u002B  auto sub1 = this-\u003Enode-\u003Etemplate create_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    this-\u003Epublisher-\u003Eget_topic_name(),\n\u002B    rclcpp::QoS(10),\n\u002B    [\u0026sub1_msg_count](test_msgs::msg::Empty::ConstSharedPtr) {\n\u002B      sub1_msg_count\u002B\u002B;\n\u002B    });\n\u002B\n\u002B  // Publish a message and verify it\u0027s received\n\u002B  this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  while (sub1_msg_count == 0 \u0026\u0026 (std::chrono::steady_clock::now() - start) \u003C 10s) {\n\u002B    std::this_thread::sleep_for(1ms);\n\u002B  }\n\u002B  EXPECT_EQ(sub1_msg_count, 1u);\n\u002B\n\u002B  // Create a second subscription while the executor is already spinning\n\u002B  std::atomic\u003Csize_t\u003E sub2_msg_count {0};\n\u002B  auto sub2 = this-\u003Enode-\u003Etemplate create_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    this-\u003Epublisher-\u003Eget_topic_name(),\n\u002B    rclcpp::QoS(10),\n\u002B    [\u0026sub2_msg_count](test_msgs::msg::Empty::ConstSharedPtr) {\n\u002B      sub2_msg_count\u002B\u002B;\n\u002B    });\n\u002B\n\u002B  // Publish a message and verify it\u0027s received by both subscriptions\n\u002B  this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  while (\n\u002B    sub1_msg_count == 1 \u0026\u0026\n\u002B    sub2_msg_count == 0 \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C 10s)\n\u002B  {\n\u002B    std::this_thread::sleep_for(1ms);\n\u002B  }\n\u002B  EXPECT_EQ(sub1_msg_count, 2u);\n\u002B  EXPECT_EQ(sub2_msg_count, 1u);\n\u002B\n\u002B  // Cancel needs to be called before join, so that executor.spin() returns.\n\u002B  executor.cancel();\n\u002B  spinner.join();\n\u002B}\n\u002B\n // Check spin_until_future_complete with node base pointer (instantiates its own executor)\n TEST(TestExecutors, testSpinUntilFutureCompleteNodeBasePtr)\n {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "92d4f3e347c8d12f25ee23b2dba5ae9179c14853",
    "RawMessage": "support regex match for parameter client (#1992)",
    "Changes": "diff --git rclcpp/include/rclcpp/parameter_client.hpp rclcpp/include/rclcpp/parameter_client.hpp\nindex 5e509bbf..1bbe4c2e 100644\n--- rclcpp/include/rclcpp/parameter_client.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_client.hpp\n@@ -185,6 \u002B185,9 @@ public:\n   /**\n    * This function filters the parameters to be set based on the node name.\n    *\n\u002B   * If two duplicate keys exist in node names belongs to one FQN, there is no guarantee\n\u002B   * which one could be set.\n\u002B   *\n    * \\param parameter_map named parameters to be loaded\n    * \\return the future of the set_parameter service used to load the parameters\n    * \\throw InvalidParametersException if there is no parameter to set\ndiff --git rclcpp/include/rclcpp/parameter_map.hpp rclcpp/include/rclcpp/parameter_map.hpp\nindex 303eac4a..17e2128a 100644\n--- rclcpp/include/rclcpp/parameter_map.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_map.hpp\n@@ -53,11 \u002B53,20 @@ parameter_value_from(const rcl_variant_t * const c_value);\n \n /// Get the ParameterMap from a yaml file.\n /// \\param[in] yaml_filename full name of the yaml file.\n\u002B/// \\param[in] node_fqn a Fully Qualified Name of node, default value is nullptr.\n /// \\returns an instance of a parameter map\n /// \\throws from rcl error of rcl_parse_yaml_file()\n RCLCPP_PUBLIC\n ParameterMap\n-parameter_map_from_yaml_file(const std::string \u0026 yaml_filename);\n\u002Bparameter_map_from_yaml_file(const std::string \u0026 yaml_filename, const char * node_fqn = nullptr);\n\u002B\n\u002B/// Get the Parameters from ParameterMap.\n\u002B/// \\param[in] parameter_map a parameter map.\n\u002B/// \\param[in] node_fqn a Fully Qualified Name of node, default value is nullptr.\n\u002B/// \\returns a list of a parameter\n\u002BRCLCPP_PUBLIC\n\u002Bstd::vector\u003CParameter\u003E\n\u002Bparameters_from_map(const ParameterMap \u0026 parameter_map, const char * node_fqn = nullptr);\n \n }  // namespace rclcpp\n \ndiff --git rclcpp/src/rclcpp/parameter_client.cpp rclcpp/src/rclcpp/parameter_client.cpp\nindex 38ced0e1..64e415e8 100644\n--- rclcpp/src/rclcpp/parameter_client.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_client.cpp\n@@ -290,28 \u002B290,24 @@ std::shared_future\u003Cstd::vector\u003Crcl_interfaces::msg::SetParametersResult\u003E\u003E\n AsyncParametersClient::load_parameters(\n   const std::string \u0026 yaml_filename)\n {\n-  rclcpp::ParameterMap parameter_map = rclcpp::parameter_map_from_yaml_file(yaml_filename);\n-  return this-\u003Eload_parameters(parameter_map);\n\u002B  rclcpp::ParameterMap parameter_map =\n\u002B    rclcpp::parameter_map_from_yaml_file(yaml_filename, remote_node_name_.c_str());\n\u002B\n\u002B  auto iter = parameter_map.find(remote_node_name_);\n\u002B  if (iter == parameter_map.end() || iter-\u003Esecond.size() == 0) {\n\u002B    throw rclcpp::exceptions::InvalidParametersException(\u0022No valid parameter\u0022);\n\u002B  }\n\u002B  auto future_result = set_parameters(iter-\u003Esecond);\n\u002B\n\u002B  return future_result;\n }\n \n std::shared_future\u003Cstd::vector\u003Crcl_interfaces::msg::SetParametersResult\u003E\u003E\n AsyncParametersClient::load_parameters(\n   const rclcpp::ParameterMap \u0026 parameter_map)\n {\n-  std::vector\u003Crclcpp::Parameter\u003E parameters;\n-  std::string remote_name = remote_node_name_.substr(remote_node_name_.substr(1).find(\u0022/\u0022) \u002B 2);\n-  for (const auto \u0026 params : parameter_map) {\n-    std::string node_full_name = params.first;\n-    std::string node_name = node_full_name.substr(node_full_name.find(\u0022/*/\u0022) \u002B 3);\n-    if (node_full_name == remote_node_name_ ||\n-      node_full_name == \u0022/**\u0022 ||\n-      (node_name == remote_name))\n-    {\n-      for (const auto \u0026 param : params.second) {\n-        parameters.push_back(param);\n-      }\n-    }\n-  }\n\u002B  std::vector\u003Crclcpp::Parameter\u003E parameters =\n\u002B    rclcpp::parameters_from_map(parameter_map, remote_node_name_.c_str());\n \n   if (parameters.size() == 0) {\n     throw rclcpp::exceptions::InvalidParametersException(\u0022No valid parameter\u0022);\ndiff --git rclcpp/src/rclcpp/parameter_map.cpp rclcpp/src/rclcpp/parameter_map.cpp\nindex cb458e7d..5ed67daa 100644\n--- rclcpp/src/rclcpp/parameter_map.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_map.cpp\n@@ -25,6 \u002B25,13 @@ using rclcpp::exceptions::InvalidParameterValueException;\n using rclcpp::ParameterMap;\n using rclcpp::ParameterValue;\n \n\u002Bstatic bool is_node_name_matched(const std::string \u0026 node_name, const char * node_fqn)\n\u002B{\n\u002B  // Update the regular expression [\u0022/*\u0022 -\u003E \u0022(/\\\\w\u002B)\u0022 and \u0022/**\u0022 -\u003E \u0022(/\\\\w\u002B)*\u0022]\n\u002B  std::string regex = rcpputils::find_and_replace(node_name, \u0022/*\u0022, \u0022(/\\\\w\u002B)\u0022);\n\u002B  return std::regex_match(node_fqn, std::regex(regex));\n\u002B}\n\u002B\n ParameterMap\n rclcpp::parameter_map_from(const rcl_params_t * const c_params, const char * node_fqn)\n {\n@@ -53,9 \u002B60,7 @@ rclcpp::parameter_map_from(const rcl_params_t * const c_params, const char * nod\n     }\n \n     if (node_fqn) {\n-      // Update the regular expression [\u0022/*\u0022 -\u003E \u0022(/\\\\w\u002B)\u0022 and \u0022/**\u0022 -\u003E \u0022(/\\\\w\u002B)*\u0022]\n-      std::string regex = rcpputils::find_and_replace(node_name, \u0022/*\u0022, \u0022(/\\\\w\u002B)\u0022);\n-      if (!std::regex_match(node_fqn, std::regex(regex))) {\n\u002B      if (!is_node_name_matched(node_name, node_fqn)) {\n         // No need to parse the items because the user just care about node_fqn\n         continue;\n       }\n@@ -143,7 \u002B148,7 @@ rclcpp::parameter_value_from(const rcl_variant_t * const c_param_value)\n }\n \n ParameterMap\n-rclcpp::parameter_map_from_yaml_file(const std::string \u0026 yaml_filename)\n\u002Brclcpp::parameter_map_from_yaml_file(const std::string \u0026 yaml_filename, const char * node_fqn)\n {\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n   rcl_params_t * rcl_parameters = rcl_yaml_node_struct_init(allocator);\n@@ -153,5 \u002B158,21 @@ rclcpp::parameter_map_from_yaml_file(const std::string \u0026 yaml_filename)\n     rclcpp::exceptions::throw_from_rcl_error(RCL_RET_ERROR);\n   }\n \n-  return rclcpp::parameter_map_from(rcl_parameters);\n\u002B  return rclcpp::parameter_map_from(rcl_parameters, node_fqn);\n\u002B}\n\u002B\n\u002Bstd::vector\u003Crclcpp::Parameter\u003E\n\u002Brclcpp::parameters_from_map(const ParameterMap \u0026 parameter_map, const char * node_fqn)\n\u002B{\n\u002B  std::vector\u003Crclcpp::Parameter\u003E parameters;\n\u002B  std::string node_name_old;\n\u002B  for (auto \u0026 [node_name, node_parameters] : parameter_map) {\n\u002B    if (node_fqn \u0026\u0026 !is_node_name_matched(node_name, node_fqn)) {\n\u002B      // No need to parse the items because the user just care about node_fqn\n\u002B      continue;\n\u002B    }\n\u002B    parameters.insert(parameters.end(), node_parameters.begin(), node_parameters.end());\n\u002B  }\n\u002B\n\u002B  return parameters;\n }\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex 6f915fee..d4e497f4 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -299,7 \u002B299,7 @@ if(TARGET test_init_options)\n   ament_target_dependencies(test_init_options \u0022rcl\u0022)\n   target_link_libraries(test_init_options ${PROJECT_NAME} mimick)\n endif()\n-ament_add_gtest(test_parameter_client test_parameter_client.cpp)\n\u002Bament_add_gmock(test_parameter_client test_parameter_client.cpp)\n if(TARGET test_parameter_client)\n   ament_target_dependencies(test_parameter_client\n     \u0022rcl_interfaces\u0022\ndiff --git rclcpp/test/rclcpp/test_parameter_client.cpp rclcpp/test/rclcpp/test_parameter_client.cpp\nindex 4cd9e671..64ef2d90 100644\n--- rclcpp/test/rclcpp/test_parameter_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_client.cpp\n@@ -12,7 \u002B12,7 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Cgmock/gmock.h\u003E\n \n #include \u003Cchrono\u003E\n #include \u003Cfunctional\u003E\n@@ -948,3 \u002B948,138 @@ TEST_F(TestParameterClient, sync_parameter_load_parameters) {\n   auto list_parameters = synchronous_client-\u003Elist_parameters({}, 3);\n   ASSERT_EQ(list_parameters.names.size(), static_cast\u003Cuint64_t\u003E(5));\n }\n\u002B\n\u002B/*\n\u002B  Coverage for async load_parameters with complicated regex expression\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_load_parameters_complicated_regex) {\n\u002B  auto load_node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022load_node\u0022,\n\u002B    \u0022namespace\u0022,\n\u002B    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n\u002B  auto asynchronous_client =\n\u002B    std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(load_node, \u0022/namespace/load_node\u0022);\n\u002B  // load parameters\n\u002B  rcpputils::fs::path test_resources_path{TEST_RESOURCES_DIRECTORY};\n\u002B  const std::string parameters_filepath = (\n\u002B    test_resources_path / \u0022test_node\u0022 / \u0022load_complicated_parameters.yaml\u0022).string();\n\u002B  auto load_future = asynchronous_client-\u003Eload_parameters(parameters_filepath);\n\u002B  auto result_code = rclcpp::spin_until_future_complete(\n\u002B    load_node, load_future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(result_code, rclcpp::FutureReturnCode::SUCCESS);\n\u002B  ASSERT_EQ(load_future.get()[0].successful, true);\n\u002B  // list parameters\n\u002B  auto list_parameters = asynchronous_client-\u003Elist_parameters({}, 3);\n\u002B  rclcpp::spin_until_future_complete(\n\u002B    load_node, list_parameters, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(list_parameters.get().names.size(), static_cast\u003Cuint64_t\u003E(6));\n\u002B  // to check the parameter \u0022a_value\u0022\n\u002B  std::string param_name = \u0022a_value\u0022;\n\u002B  auto param = load_node-\u003Eget_parameter(param_name);\n\u002B  ASSERT_EQ(param.get_value\u003Cstd::string\u003E(), \u0022last_one_win\u0022);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async load_parameters to load file without valid parameters\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_load_no_valid_parameter) {\n\u002B  auto load_node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022load_node\u0022,\n\u002B    \u0022namespace\u0022,\n\u002B    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n\u002B  auto asynchronous_client =\n\u002B    std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(load_node, \u0022/namespace/load_node\u0022);\n\u002B  // load parameters\n\u002B  rcpputils::fs::path test_resources_path{TEST_RESOURCES_DIRECTORY};\n\u002B  const std::string parameters_filepath = (\n\u002B    test_resources_path / \u0022test_node\u0022 / \u0022no_valid_parameters.yaml\u0022).string();\n\u002B  EXPECT_THROW(\n\u002B    asynchronous_client-\u003Eload_parameters(parameters_filepath),\n\u002B    rclcpp::exceptions::InvalidParametersException);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async load_parameters from maps with complicated regex expression\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_load_parameters_from_map) {\n\u002B  auto load_node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022load_node\u0022,\n\u002B    \u0022namespace\u0022,\n\u002B    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n\u002B  auto asynchronous_client =\n\u002B    std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(load_node, \u0022/namespace/load_node\u0022);\n\u002B  // load parameters\n\u002B  rclcpp::ParameterMap parameter_map = {\n\u002B    {\u0022/**\u0022,\n\u002B      {\n\u002B        {\u0022bar\u0022, 5},\n\u002B        {\u0022foo\u0022, 3.5},\n\u002B        {\u0022a_value\u0022, \u0022first\u0022}\n\u002B      }\n\u002B    },\n\u002B    {\u0022/*/load_node\u0022,\n\u002B      {\n\u002B        {\u0022bar_foo\u0022, \u0022ok\u0022},\n\u002B        {\u0022a_value\u0022, \u0022second\u0022}\n\u002B      }\n\u002B    },\n\u002B    {\u0022/namespace/load_node\u0022,\n\u002B      {\n\u002B        {\u0022foo_bar\u0022, true},\n\u002B        {\u0022a_value\u0022, \u0022third\u0022}\n\u002B      }\n\u002B    },\n\u002B    {\u0022/bar\u0022,\n\u002B      {\n\u002B        {\u0022fatal\u0022, 10}\n\u002B      }\n\u002B    },\n\u002B    {\u0022/**/namespace/*\u0022,\n\u002B      {\n\u002B        {\u0022a_value\u0022, \u0022not_win\u0022}\n\u002B      }\n\u002B    }\n\u002B  };\n\u002B\n\u002B  auto load_future = asynchronous_client-\u003Eload_parameters(parameter_map);\n\u002B  auto result_code = rclcpp::spin_until_future_complete(\n\u002B    load_node, load_future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(result_code, rclcpp::FutureReturnCode::SUCCESS);\n\u002B  ASSERT_EQ(load_future.get()[0].successful, true);\n\u002B  // list parameters\n\u002B  auto list_parameters = asynchronous_client-\u003Elist_parameters({}, 3);\n\u002B  rclcpp::spin_until_future_complete(\n\u002B    load_node, list_parameters, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(list_parameters.get().names.size(), static_cast\u003Cuint64_t\u003E(6));\n\u002B  // to check the parameter \u0022a_value\u0022\n\u002B  std::string param_name = \u0022a_value\u0022;\n\u002B  auto param = load_node-\u003Eget_parameter(param_name);\n\u002B  // rclcpp::ParameterMap is an unordered map, no guarantee which value will be set for \u0060a_value\u0060.\n\u002B  EXPECT_THAT(\n\u002B    (std::array{\u0022first\u0022, \u0022second\u0022, \u0022third\u0022, \u0022not_win\u0022}),\n\u002B    testing::Contains(param.get_value\u003Cstd::string\u003E()));\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async load_parameters from maps without valid parameters\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_load_from_map_no_valid_parameter) {\n\u002B  auto load_node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022load_node\u0022,\n\u002B    \u0022namespace\u0022,\n\u002B    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n\u002B  auto asynchronous_client =\n\u002B    std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(load_node, \u0022/namespace/load_node\u0022);\n\u002B  // load parameters\n\u002B  rclcpp::ParameterMap parameter_map = {\n\u002B    {\u0022/no/valid/parameters/node\u0022,\n\u002B      {\n\u002B        {\u0022bar\u0022, 5},\n\u002B        {\u0022bar\u0022, 3.5}\n\u002B      }\n\u002B    }\n\u002B  };\n\u002B  EXPECT_THROW(\n\u002B    asynchronous_client-\u003Eload_parameters(parameter_map),\n\u002B    rclcpp::exceptions::InvalidParametersException);\n\u002B}\ndiff --git rclcpp/test/resources/test_node/load_complicated_parameters.yaml rclcpp/test/resources/test_node/load_complicated_parameters.yaml\nnew file mode 100644\nindex 00000000..7722f636\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/resources/test_node/load_complicated_parameters.yaml\n@@ -0,0 \u002B1,25 @@\n\u002B/**:\n\u002B  ros__parameters:\n\u002B    bar: 5\n\u002B    foo: 3.5\n\u002B    a_value: \u0022first\u0022\n\u002B\n\u002B/*:\n\u002B  load_node:\n\u002B    ros__parameters:\n\u002B      bar_foo: \u0022ok\u0022\n\u002B      a_value: \u0022second\u0022\n\u002B\n\u002Bnamespace:\n\u002B  load_node:\n\u002B    ros__parameters:\n\u002B      foo_bar: true\n\u002B      a_value: \u0022third\u0022\n\u002B\n\u002Bbar:\n\u002B  ros__parameters:\n\u002B    fatal: 10\n\u002B\n\u002B/**/namespace/*:\n\u002B  ros__parameters:\n\u002B    a_value: \u0022last_one_win\u0022\ndiff --git rclcpp/test/resources/test_node/no_valid_parameters.yaml rclcpp/test/resources/test_node/no_valid_parameters.yaml\nnew file mode 100644\nindex 00000000..a75356cd\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/resources/test_node/no_valid_parameters.yaml\n@@ -0,0 \u002B1,4 @@\n\u002B/no/valid/parameters/node:\n\u002B  ros__parameters:\n\u002B    bar: 5\n\u002B    foo: 3.5\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "6100096293e995fab6fcb9eece043db4cd901299",
    "RawMessage": "Use rmw_security_common (#167)",
    "Changes": "diff --git rmw_connextdds_common/CMakeLists.txt rmw_connextdds_common/CMakeLists.txt\nindex 80062a9..3ff1e7f 100644\n--- rmw_connextdds_common/CMakeLists.txt\n\u002B\u002B\u002B rmw_connextdds_common/CMakeLists.txt\n@@ -122,6 \u002B122,7 @@ set(RMW_CONNEXT_DEPS\n     rcpputils\n     rmw\n     rmw_dds_common\n\u002B    rmw_security_common\n     tracetools\n     fastcdr\n     rosidl_runtime_c\ndiff --git rmw_connextdds_common/package.xml rmw_connextdds_common/package.xml\nindex e072c62..fc2891b 100644\n--- rmw_connextdds_common/package.xml\n\u002B\u002B\u002B rmw_connextdds_common/package.xml\n@@ -16,6 \u002B16,7 @@\n   \u003Cdepend\u003Ercpputils\u003C/depend\u003E\n   \u003Cdepend\u003Ermw\u003C/depend\u003E\n   \u003Cdepend\u003Ermw_dds_common\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Ermw_security_common\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_runtime_c\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_runtime_cpp\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_typesupport_fastrtps_c\u003C/depend\u003E\ndiff --git rmw_connextdds_common/src/common/rmw_context.cpp rmw_connextdds_common/src/common/rmw_context.cpp\nindex 81a5835..ea3bfc7 100644\n--- rmw_connextdds_common/src/common/rmw_context.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_context.cpp\n@@ -27,7 \u002B27,7 @@\n #include \u0022rmw_connextdds/discovery.hpp\u0022\n #include \u0022rmw_connextdds/graph_cache.hpp\u0022\n \n-#include \u0022rmw_dds_common/security.hpp\u0022\n\u002B#include \u0022rmw_security_common/security.hpp\u0022\n \n #include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/filesystem.h\u0022\n@@ -405,9 \u002B405,27 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n   static const char * const uri_prefix = \u0022\u0022;\n #endif /* !RMW_CONNEXT_DDS_API_PRO_LEGACY */\n \n-  std::unordered_map\u003Cstd::string, std::string\u003E security_files;\n-  if (!rmw_dds_common::get_security_files(\n-      uri_prefix, this-\u003Ebase-\u003Eoptions.security_options.security_root_path, security_files))\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B\n\u002B  if (ret != RMW_RET_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Failed to initialize string map for security\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  auto scope_exit_ws = rcpputils::make_scope_exit(\n\u002B    [\u0026security_files]()\n\u002B    {\n\u002B      rcutils_ret_t ret = rcutils_string_map_fini(\u0026security_files);\n\u002B      if (ret != RMW_RET_OK) {\n\u002B        RMW_SET_ERROR_MSG(\u0022Failed to fini string map for security\u0022);\n\u002B      }\n\u002B    });\n\u002B\n\u002B  if (get_security_files(\n\u002B      uri_prefix, this-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n\u002B    \u0026security_files) != RMW_RET_OK)\n   {\n     RMW_CONNEXT_LOG_ERROR(\u0022couldn\u0027t find all security files\u0022);\n     return RMW_RET_ERROR;\n@@ -418,12 \u002B436,13 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_IDENTITY_CA_PROPERTY,\n-      security_files[\u0022IDENTITY_CA\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_IDENTITY_CA_PROPERTY, security_files[\u0022IDENTITY_CA\u0022].c_str())\n\u002B      DDS_SECURITY_IDENTITY_CA_PROPERTY,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n \n@@ -432,12 \u002B451,13 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PERMISSIONS_CA_PROPERTY,\n-      security_files[\u0022PERMISSIONS_CA\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PERMISSIONS_CA_PROPERTY, security_files[\u0022PERMISSIONS_CA\u0022].c_str())\n\u002B      DDS_SECURITY_PERMISSIONS_CA_PROPERTY,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n \n@@ -446,12 \u002B466,12 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PRIVATE_KEY_PROPERTY,\n-      security_files[\u0022PRIVATE_KEY\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PRIVATE_KEY_PROPERTY, security_files[\u0022PRIVATE_KEY\u0022].c_str())\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n \n@@ -461,12 \u002B481,13 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY,\n-      security_files[\u0022CERTIFICATE\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY, security_files[\u0022CERTIFICATE\u0022].c_str())\n\u002B      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n   /* XML file containing domain governance configuration, signed by\n@@ -475,12 \u002B496,13 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_GOVERNANCE_PROPERTY,\n-      security_files[\u0022GOVERNANCE\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_GOVERNANCE_PROPERTY, security_files[\u0022GOVERNANCE\u0022].c_str())\n\u002B      DDS_SECURITY_GOVERNANCE_PROPERTY,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n \n@@ -490,12 \u002B512,13 @@ rmw_context_impl_s::configure_security(DDS_DomainParticipantQos * const qos)\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PERMISSIONS_PROPERTY,\n-      security_files[\u0022PERMISSIONS\u0022].c_str(),\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)).c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PERMISSIONS_PROPERTY, security_files[\u0022PERMISSIONS\u0022].c_str())\n\u002B      DDS_SECURITY_PERMISSIONS_PROPERTY,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)).c_str())\n     return RMW_RET_ERROR;\n   }\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "ef0fcda0a98ce64ddd07ca9403c65b56b9b4f074",
    "RawMessage": "Make sure to initialize the rmw_message_sequence after init. (#175)",
    "Changes": "diff --git test_rmw_implementation/test/test_subscription.cpp test_rmw_implementation/test/test_subscription.cpp\nindex 528a6d8..1710b95 100644\n--- test_rmw_implementation/test/test_subscription.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_subscription.cpp\n@@ -24,6 \u002B24,7 @@\n #include \u0022rmw/error_handling.h\u0022\n \n #include \u0022test_msgs/msg/basic_types.h\u0022\n\u002B#include \u0022test_msgs/msg/strings.h\u0022\n #include \u0022./config.hpp\u0022\n #include \u0022./testing_macros.hpp\u0022\n \n@@ -530,6 \u002B531,12 @@ TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_sequence) {\n   rmw_message_sequence_t sequence = rmw_get_zero_initialized_message_sequence();\n   rmw_ret_t ret = rmw_message_sequence_init(\u0026sequence, count, \u0026allocator);\n   EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  auto seq = test_msgs__msg__Strings__Sequence__create(count);\n\u002B  for (size_t ii = 0; ii \u003C count; \u002B\u002Bii) {\n\u002B    sequence.data[ii] = \u0026seq-\u003Edata[ii];\n\u002B  }\n\u002B\n   rmw_message_info_sequence_t info_sequence = rmw_get_zero_initialized_message_info_sequence();\n   ret = rmw_message_info_sequence_init(\u0026info_sequence, count, \u0026allocator);\n   EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n@@ -539,11 \u002B546,13 @@ TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_sequence) {\n   EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n   EXPECT_EQ(taken, 0u);\n \n-  ret = rmw_message_sequence_fini(\u0026sequence);\n\u002B  ret = rmw_message_info_sequence_fini(\u0026info_sequence);\n   EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n \n-  ret = rmw_message_info_sequence_fini(\u0026info_sequence);\n\u002B  ret = rmw_message_sequence_fini(\u0026sequence);\n   EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  test_msgs__msg__Strings__Sequence__destroy(seq);\n }\n \n TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), take_sequence_with_bad_args) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "c0cc63870a763340952471c848eb85827f97879b",
    "RawMessage": "Cleanup errors after error paths in rcl_yaml_param_parser tests. (#1203)",
    "Changes": "diff --git rcl_yaml_param_parser/test/test_parse.cpp rcl_yaml_param_parser/test/test_parse.cpp\nindex 0fd78b1..f7e004f 100644\n--- rcl_yaml_param_parser/test/test_parse.cpp\n\u002B\u002B\u002B rcl_yaml_param_parser/test/test_parse.cpp\n@@ -155,6 \u002B155,7 @@ TEST(TestParse, parse_value_sequence) {\n   EXPECT_EQ(\n     nullptr,\n     params_st-\u003Eparams[node_idx].parameter_values[parameter_idx].integer_array_value);\n\u002B  rcutils_reset_error();\n \n   // Check proper sequence type\n   seq_data_type = DATA_TYPE_UNKNOWN;\n@@ -187,6 \u002B188,7 @@ TEST(TestParse, parse_value_sequence) {\n     rcutils_get_error_string().str;\n   EXPECT_EQ(\n     nullptr, params_st-\u003Eparams[node_idx].parameter_values[parameter_idx].integer_array_value);\n\u002B  rcutils_reset_error();\n \n   // Check proper sequence type\n   seq_data_type = DATA_TYPE_UNKNOWN;\n@@ -222,6 \u002B224,7 @@ TEST(TestParse, parse_value_sequence) {\n     rcutils_get_error_string().str;\n   EXPECT_EQ(\n     nullptr, params_st-\u003Eparams[node_idx].parameter_values[parameter_idx].integer_array_value);\n\u002B  rcutils_reset_error();\n \n   // Check proper sequence type\n   seq_data_type = DATA_TYPE_UNKNOWN;\n@@ -256,6 \u002B259,7 @@ TEST(TestParse, parse_value_sequence) {\n     rcutils_get_error_string().str;\n   EXPECT_EQ(\n     nullptr, params_st-\u003Eparams[node_idx].parameter_values[parameter_idx].integer_array_value);\n\u002B  rcutils_reset_error();\n \n   // Check proper sequence type\n   seq_data_type = DATA_TYPE_UNKNOWN;\ndiff --git rcl_yaml_param_parser/test/test_parser.cpp rcl_yaml_param_parser/test/test_parser.cpp\nindex 609dccf..1dec47d 100644\n--- rcl_yaml_param_parser/test/test_parser.cpp\n\u002B\u002B\u002B rcl_yaml_param_parser/test/test_parser.cpp\n@@ -45,17 \u002B45,21 @@ TEST(RclYamlParamParser, node_init_fini) {\n   set_time_bomb_allocator_calloc_count(allocator, 0);\n   // This cleans up after itself if it fails so no need to call fini()\n   EXPECT_EQ(rcl_yaml_node_struct_init(allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Bad alloc of params_st-\u003Enode_names\n   set_time_bomb_allocator_calloc_count(allocator, 1);\n   EXPECT_EQ(rcl_yaml_node_struct_init(allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Bad alloc of params_st-\u003Eparams\n   set_time_bomb_allocator_calloc_count(allocator, 2);\n   EXPECT_EQ(rcl_yaml_node_struct_init(allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Check this doesn\u0027t die.\n   rcl_yaml_node_struct_fini(nullptr);\n\u002B  rcutils_reset_error();\n }\n \n TEST(RclYamlParamParser, node_init_with_capacity_fini) {\n@@ -72,17 \u002B76,21 @@ TEST(RclYamlParamParser, node_init_with_capacity_fini) {\n   set_time_bomb_allocator_calloc_count(allocator, 0);\n   // This cleans up after itself if it fails so no need to call fini()\n   EXPECT_EQ(rcl_yaml_node_struct_init_with_capacity(1024, allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Bad alloc of params_st-\u003Enode_names\n   set_time_bomb_allocator_calloc_count(allocator, 1);\n   EXPECT_EQ(rcl_yaml_node_struct_init_with_capacity(1024, allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Bad alloc of params_st-\u003Eparams\n   set_time_bomb_allocator_calloc_count(allocator, 2);\n   EXPECT_EQ(rcl_yaml_node_struct_init_with_capacity(1024, allocator), nullptr);\n\u002B  rcutils_reset_error();\n \n   // Check this doesn\u0027t die.\n   rcl_yaml_node_struct_fini(nullptr);\n\u002B  rcutils_reset_error();\n }\n \n TEST(RclYamlParamParser, reallocate_node_init_with_capacity_fini) {\n@@ -104,6 \u002B112,7 @@ TEST(RclYamlParamParser, node_copy) {\n   EXPECT_NE(params_st, nullptr);\n \n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(nullptr));\n\u002B  rcutils_reset_error();\n \n   const char node_name[] = \u0022node name\u0022;\n   const char param_name[] = \u0022param name\u0022;\n@@ -119,15 \u002B128,18 @@ TEST(RclYamlParamParser, node_copy) {\n   // init of out_params_st fails\n   set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, 0);\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, 1);\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   constexpr int expected_num_calloc_calls = 5;\n   for (int i = 0; i \u003C expected_num_calloc_calls; \u002B\u002Bi) {\n     // Check various locations for allocation failures\n     set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, i);\n     EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B    rcutils_reset_error();\n   }\n   // Check that the expected number of calloc calls occur\n   set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, expected_num_calloc_calls);\n@@ -142,6 \u002B154,7 @@ TEST(RclYamlParamParser, node_copy) {\n   for (int i = 0; i \u003C expected_num_malloc_calls; \u002B\u002Bi) {\n     set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, i);\n     EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B    rcutils_reset_error();\n   }\n \n   // Check that the expected number of malloc calls occur\n@@ -163,6 \u002B176,7 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].integer_value = \u0026temp_int;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n   params_st-\u003Eparams-\u003Eparameter_values[0].integer_value = nullptr;\n \n   // Check double value\n@@ -170,6 \u002B184,7 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].double_value = \u0026temp_double;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n   params_st-\u003Eparams-\u003Eparameter_values[0].double_value = nullptr;\n \n   // Check string value\n@@ -177,6 \u002B192,7 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].string_value = temp_string;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n   params_st-\u003Eparams-\u003Eparameter_values[0].string_value = nullptr;\n \n   // Check bool_array_value array pointer is allocated\n@@ -185,11 \u002B201,13 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].bool_array_value = \u0026temp_bool_array;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   // Check bool_array_value-\u003Evalues is allocated\n   set_time_bomb_allocator_malloc_count(\n     params_st-\u003Eallocator, num_malloc_calls_until_copy_param \u002B 1);\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   // Check bool_array_value-\u003Evalues is set to null if size is 0\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, -1);\n@@ -206,11 \u002B224,13 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].integer_array_value = \u0026temp_integer_array;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   // Check integer_array-\u003Evalues is allocated\n   set_time_bomb_allocator_malloc_count(\n     params_st-\u003Eallocator, num_malloc_calls_until_copy_param \u002B 1);\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   // Check integer_array-\u003Evalues is set to null if size is 0\n   params_st-\u003Eparams-\u003Eparameter_values[0].integer_array_value-\u003Esize = 0u;\n@@ -220,16 \u002B240,17 @@ TEST(RclYamlParamParser, node_copy) {\n   rcl_yaml_node_struct_fini(copy);\n   params_st-\u003Eparams-\u003Eparameter_values[0].integer_array_value = nullptr;\n \n-\n   double double_array[] = {42.0};\n   rcl_double_array_s temp_double_array = {double_array, 1};\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].double_array_value = \u0026temp_double_array;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   set_time_bomb_allocator_malloc_count(\n     params_st-\u003Eallocator, num_malloc_calls_until_copy_param \u002B 1);\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n \n   params_st-\u003Eparams-\u003Eparameter_values[0].double_array_value-\u003Esize = 0u;\n   copy = rcl_yaml_node_struct_copy(params_st);\n@@ -244,11 \u002B265,13 @@ TEST(RclYamlParamParser, node_copy) {\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, num_malloc_calls_until_copy_param);\n   params_st-\u003Eparams-\u003Eparameter_values[0].string_array_value = \u0026temp_string_array;\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B  rcutils_reset_error();\n   params_st-\u003Eparams-\u003Eparameter_values[0].string_array_value = nullptr;\n \n   for (int i = 0; i \u003C 5; \u002B\u002Bi) {\n     set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, i);\n     EXPECT_EQ(nullptr, rcl_yaml_node_struct_copy(params_st));\n\u002B    rcutils_reset_error();\n   }\n \n   rcl_yaml_node_struct_fini(params_st);\n@@ -258,14 \u002B281,17 @@ TEST(RclYamlParamParser, node_copy) {\n TEST(RclYamlParamParser, test_file) {\n   // file path is null\n   EXPECT_FALSE(rcl_parse_yaml_file(nullptr, nullptr));\n\u002B  rcutils_reset_error();\n   const char bad_file_path[] = \u0022not_a_file.yaml\u0022;\n \n   // params_st is null\n   EXPECT_FALSE(rcl_parse_yaml_file(bad_file_path, nullptr));\n\u002B  rcutils_reset_error();\n \n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n   rcl_params_t * params_st = rcl_yaml_node_struct_init(allocator);\n   EXPECT_FALSE(rcl_parse_yaml_file(bad_file_path, params_st));\n\u002B  rcutils_reset_error();\n \n   rcl_yaml_node_struct_fini(params_st);\n }\n@@ -282,29 \u002B308,44 @@ TEST(RclYamlParamParser, test_parse_yaml_value) {\n \n   // Check null arguments\n   EXPECT_FALSE(rcl_parse_yaml_value(nullptr, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, nullptr, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, nullptr, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, nullptr));\n\u002B  rcutils_reset_error();\n \n   // Check strings are empty\n   EXPECT_FALSE(rcl_parse_yaml_value(empty_string, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, empty_string, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, empty_string, params_st));\n\u002B  rcutils_reset_error();\n \n   // Check allocating params_st-\u003Enode_names[*node_idx] fails\n   params_st-\u003Eallocator = get_time_bomb_allocator();\n   set_time_bomb_allocator_malloc_count(params_st-\u003Eallocator, 0);\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n \n   // Check allocating node_params-\u003Eparameter_names fails\n   allocator = get_time_bomb_allocator();\n   set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, 0);\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n \n   // Check allocating node_params-\u003Eparameter_values fails\n   allocator = get_time_bomb_allocator();\n   set_time_bomb_allocator_calloc_count(params_st-\u003Eallocator, 1);\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n \n   allocator = rcutils_get_default_allocator();\n   EXPECT_TRUE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n@@ -324,8 \u002B365,13 @@ TEST(RclYamlParamParser, test_yaml_node_struct_get) {\n \n   // Check null arguments\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_get(nullptr, param_name, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_get(node_name, nullptr, params_st));\n\u002B  rcutils_reset_error();\n\u002B\n   EXPECT_EQ(nullptr, rcl_yaml_node_struct_get(node_name, param_name, nullptr));\n\u002B  rcutils_reset_error();\n \n   rcl_variant_t * result = rcl_yaml_node_struct_get(node_name, param_name, params_st);\n   ASSERT_NE(nullptr, result-\u003Ebool_value);\n@@ -393,6 \u002B439,7 @@ TEST(RclYamlParamParser, test_parse_file_with_bad_allocator) {\n       rcutils_allocator_t allocator = rcutils_get_default_allocator();\n       rcl_params_t * params_hdl = rcl_yaml_node_struct_init(allocator);\n       if (NULL == params_hdl) {\n\u002B        rcutils_reset_error();\n         continue;\n       }\n \n@@ -404,6 \u002B451,9 @@ TEST(RclYamlParamParser, test_parse_file_with_bad_allocator) {\n       // If \u0060rcutils_string_array_fini\u0060 fails, there will be a small memory leak here.\n       // However, it\u0027s necessary for coverage\n       rcl_yaml_node_struct_fini(params_hdl);\n\u002B\n\u002B      rcutils_reset_error();\n\u002B\n       params_hdl = NULL;\n     });\n   }\n@@ -435,6 \u002B485,7 @@ TEST(RclYamlParamParser, test_parse_yaml_initialize_mock) {\n     \u0022lib:rcl_yaml_param_parser\u0022, yaml_parser_initialize, false);\n \n   EXPECT_FALSE(rcl_parse_yaml_file(path, params_hdl));\n\u002B  rcutils_reset_error();\n \n   constexpr char node_name[] = \u0022node name\u0022;\n   constexpr char param_name[] = \u0022param name\u0022;\n@@ -447,6 \u002B498,7 @@ TEST(RclYamlParamParser, test_parse_yaml_initialize_mock) {\n     rcl_yaml_node_struct_fini(params_st);\n   });\n   EXPECT_FALSE(rcl_parse_yaml_value(node_name, param_name, yaml_value, params_st));\n\u002B  rcutils_reset_error();\n }\n \n \ndiff --git rcl_yaml_param_parser/test/test_parser_multiple_nodes.cpp rcl_yaml_param_parser/test/test_parser_multiple_nodes.cpp\nindex d163f6b..5458bfa 100644\n--- rcl_yaml_param_parser/test/test_parser_multiple_nodes.cpp\n\u002B\u002B\u002B rcl_yaml_param_parser/test/test_parser_multiple_nodes.cpp\n@@ -93,6 \u002B93,7 @@ TEST(RclYamlParamParserMultipleNodes, test_multiple_nodes_with_bad_allocator) {\n     rcutils_allocator_t allocator = rcutils_get_default_allocator();\n     rcl_params_t * params_hdl = rcl_yaml_node_struct_init(allocator);\n     if (NULL == params_hdl) {\n\u002B      rcutils_reset_error();\n       continue;\n     }\n \n@@ -104,6 \u002B105,9 @@ TEST(RclYamlParamParserMultipleNodes, test_multiple_nodes_with_bad_allocator) {\n     // If \u0060rcutils_string_array_fini\u0060 fails, there will be a small memory leak here.\n     // However, it\u0027s necessary for coverage\n     rcl_yaml_node_struct_fini(params_hdl);\n\u002B\n\u002B    rcutils_reset_error();\n\u002B\n     params_hdl = NULL;\n   });\n }\ndiff --git rcl_yaml_param_parser/test/test_parser_multiple_params.cpp rcl_yaml_param_parser/test/test_parser_multiple_params.cpp\nindex 26706da..244a2cc 100644\n--- rcl_yaml_param_parser/test/test_parser_multiple_params.cpp\n\u002B\u002B\u002B rcl_yaml_param_parser/test/test_parser_multiple_params.cpp\n@@ -91,6 \u002B91,7 @@ TEST(RclYamlParamParserMultipleParams, test_multiple_params_with_bad_allocator)\n     rcutils_allocator_t allocator = rcutils_get_default_allocator();\n     rcl_params_t * params_hdl = rcl_yaml_node_struct_init(allocator);\n     if (NULL == params_hdl) {\n\u002B      rcutils_reset_error();\n       continue;\n     }\n \n@@ -102,6 \u002B103,9 @@ TEST(RclYamlParamParserMultipleParams, test_multiple_params_with_bad_allocator)\n     // If \u0060rcutils_string_array_fini\u0060 fails, there will be a small memory leak here.\n     // However, it\u0027s necessary for coverage\n     rcl_yaml_node_struct_fini(params_hdl);\n\u002B\n\u002B    rcutils_reset_error();\n\u002B\n     params_hdl = NULL;\n   });\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "7ffe94865f38c67812799bf5751a8f0f3f918c25",
    "RawMessage": "check if the context is already shutdown. (#939)",
    "Changes": "diff --git rclpy/src/rclpy/context.cpp rclpy/src/rclpy/context.cpp\nindex 07cfcc5..5d4993f 100644\n--- rclpy/src/rclpy/context.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/context.cpp\n@@ -34,6 \u002B34,7 @@\n \n namespace\n {\n\u002B// g_contexts is a collection of valid contexts\n std::vector\u003Crcl_context_t *\u003E g_contexts;\n std::mutex g_contexts_mutex;\n }\n@@ -42,11 \u002B43,13 @@ namespace rclpy\n {\n void shutdown_contexts()\n {\n\u002B  // graceful shutdown all contexts\n   std::lock_guard guard{g_contexts_mutex};\n   for (auto * c : g_contexts) {\n     rcl_ret_t ret = rcl_shutdown(c);\n     (void)ret;\n   }\n\u002B  g_contexts.clear();\n }\n \n Context::Context(py::list pyargs, size_t domain_id)\n@@ -149,10 \u002B152,12 @@ Context::shutdown()\n {\n   {\n     std::lock_guard guard{g_contexts_mutex};\n-    g_contexts.erase(\n-      std::remove(g_contexts.begin(), g_contexts.end(), rcl_context_.get()),\n-      g_contexts.end());\n\u002B    auto iter = std::find(g_contexts.begin(), g_contexts.end(), rcl_context_.get());\n\u002B    if (iter != g_contexts.end()) {\n\u002B      g_contexts.erase(iter);\n\u002B    }\n   }\n\u002B\n   rcl_ret_t ret = rcl_shutdown(rcl_context_.get());\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to shutdown\u0022);\n",
    "BackportedTo": "humble",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "bb15182fe107efdc54ccbfe49d31812543aa92dc",
    "RawMessage": "Fix memory leak that type support not deleted. (#225)",
    "Changes": "diff --git rmw_cyclonedds_cpp/include/rmw_cyclonedds_cpp/TypeSupport.hpp rmw_cyclonedds_cpp/include/rmw_cyclonedds_cpp/TypeSupport.hpp\nindex 303ef3c..91a2184 100644\n--- rmw_cyclonedds_cpp/include/rmw_cyclonedds_cpp/TypeSupport.hpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/include/rmw_cyclonedds_cpp/TypeSupport.hpp\n@@ -119,6 \u002B119,7 @@ public:\n     cycprint \u0026 deser,\n     std::function\u003Cvoid(cycprint \u0026)\u003E prefix = nullptr);\n   std::string getName();\n\u002B  virtual ~TypeSupport() = default;\n \n protected:\n   TypeSupport();\ndiff --git rmw_cyclonedds_cpp/src/serdata.cpp rmw_cyclonedds_cpp/src/serdata.cpp\nindex 6dd8542..79fc758 100644\n--- rmw_cyclonedds_cpp/src/serdata.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdata.cpp\n@@ -43,6 \u002B43,10 @@\n #define ddsi_keyhash nn_keyhash\n #endif\n \n\u002Busing TypeSupport_c =\n\u002B  rmw_cyclonedds_cpp::TypeSupport\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E;\n\u002Busing TypeSupport_cpp =\n\u002B  rmw_cyclonedds_cpp::TypeSupport\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E;\n using MessageTypeSupport_c =\n   rmw_cyclonedds_cpp::MessageTypeSupport\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E;\n using MessageTypeSupport_cpp =\n@@ -432,6 \u002B436,15 @@ static void sertopic_rmw_free(struct ddsi_sertopic * tpcmn)\n #if DDSI_SERTOPIC_HAS_TOPICKIND_NO_KEY\n   ddsi_sertopic_fini(tpcmn);\n #endif\n\u002B  if (tp-\u003Etype_support.type_support_) {\n\u002B    if (using_introspection_c_typesupport(tp-\u003Etype_support.typesupport_identifier_)) {\n\u002B      delete static_cast\u003CTypeSupport_c *\u003E(tp-\u003Etype_support.type_support_);\n\u002B    } else if (using_introspection_cpp_typesupport(tp-\u003Etype_support.typesupport_identifier_)) {\n\u002B      delete static_cast\u003CTypeSupport_cpp *\u003E(tp-\u003Etype_support.type_support_);\n\u002B    }\n\u002B    tp-\u003Etype_support.type_support_ = NULL;\n\u002B  }\n\u002B\n   delete tp;\n }\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "900be20a5a75e4cff05b6e5fba5bd682b5cfb181",
    "RawMessage": "Update for checking correct variable (#1534)",
    "Changes": "diff --git rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\nindex 786422d0..31b755b4 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\n@@ -125,7 \u002B125,7 @@ TEST_F(TestNodeParameters, parameter_overrides)\n   auto * node_parameters_interface =\n     dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n     node2-\u003Eget_node_parameters_interface().get());\n-  ASSERT_NE(nullptr, node_parameters);\n\u002B  ASSERT_NE(nullptr, node_parameters_interface);\n \n   const auto \u0026 parameter_overrides = node_parameters_interface-\u003Eget_parameter_overrides();\n   EXPECT_EQ(2u, parameter_overrides.size());\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_python",
    "SHA": "20bcc4ca118145a8a2914fa20aaef20a8e3ce72d",
    "RawMessage": "Remove stray numpy import (#185)",
    "Changes": "diff --git rosidl_generator_py/resource/_msg.py.em rosidl_generator_py/resource/_msg.py.em\nindex f32126f..b2cc43d 100644\n--- rosidl_generator_py/resource/_msg.py.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_msg.py.em\n@@ -30,7 \u002B30,6 @@ from rosidl_parser.definition import UNSIGNED_INTEGER_TYPES\n @# Collect necessary import statements for all members\n @{\n from collections import OrderedDict\n-import numpy\n imports = OrderedDict()\n if message.structure.members:\n     imports.setdefault(\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "82eb85013efb0aa36c067aa0fbdd226a5474305c",
    "RawMessage": "Switch to using a context manager for the python examples. (#700)",
    "Changes": "diff --git examples_tf2_py/examples_tf2_py/async_waits_for_transform.py examples_tf2_py/examples_tf2_py/async_waits_for_transform.py\nindex 0f3f2ae0..08434af4 100644\n--- examples_tf2_py/examples_tf2_py/async_waits_for_transform.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/async_waits_for_transform.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n import rclpy.time\n from tf2_ros import LookupException\n@@ -62,10 \u002B63,9 @@ class AsyncWaitsForTransform(Node):\n \n \n def main():\n-    rclpy.init()\n-    node = AsyncWaitsForTransform()\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init():\n\u002B            node = AsyncWaitsForTransform()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    rclpy.shutdown()\ndiff --git examples_tf2_py/examples_tf2_py/blocking_waits_for_transform.py examples_tf2_py/examples_tf2_py/blocking_waits_for_transform.py\nindex 92a684b5..bbdfd496 100644\n--- examples_tf2_py/examples_tf2_py/blocking_waits_for_transform.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/blocking_waits_for_transform.py\n@@ -14,6 \u002B14,7 @@\n \n import rclpy\n from rclpy.duration import Duration\n\u002Bfrom rclpy.executors import ExternalShutdownException, MultiThreadedExecutor\n from rclpy.node import Node\n import rclpy.time\n from tf2_ros import LookupException\n@@ -55,16 \u002B56,12 @@ class BlockingWaitsForTransform(Node):\n \n \n def main():\n-    from rclpy.executors import MultiThreadedExecutor\n-\n-    rclpy.init()\n-    node = BlockingWaitsForTransform()\n-    # this node blocks in a callback, so a MultiThreadedExecutor is required\n-    executor = MultiThreadedExecutor()\n-    executor.add_node(node)\n     try:\n-        executor.spin()\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init():\n\u002B            node = BlockingWaitsForTransform()\n\u002B            # this node blocks in a callback, so a MultiThreadedExecutor is required\n\u002B            executor = MultiThreadedExecutor()\n\u002B            executor.add_node(node)\n\u002B            executor.spin()\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    executor.shutdown()\n-    rclpy.shutdown()\ndiff --git examples_tf2_py/examples_tf2_py/dynamic_broadcaster.py examples_tf2_py/examples_tf2_py/dynamic_broadcaster.py\nindex 4779448e..8ef040b9 100644\n--- examples_tf2_py/examples_tf2_py/dynamic_broadcaster.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/dynamic_broadcaster.py\n@@ -16,6 \u002B16,7 @@ import math\n \n from geometry_msgs.msg import TransformStamped\n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException, SingleThreadedExecutor\n from rclpy.node import Node\n from rclpy.qos import QoSProfile\n from sensor_msgs.msg import JointState\n@@ -87,20 \u002B88,16 @@ class FakeJointStatePublisher(Node):\n \n \n def main():\n-    rclpy.init()\n-    nodes = []\n-    nodes.append(DynamicFramePublisher())\n-    nodes.append(FakeJointStatePublisher())\n\u002B    try:\n\u002B        with rclpy.init():\n\u002B            nodes = []\n\u002B            nodes.append(DynamicFramePublisher())\n\u002B            nodes.append(FakeJointStatePublisher())\n \n-    from rclpy.executors import SingleThreadedExecutor\n-    executor = SingleThreadedExecutor()\n-    for node in nodes:\n-        executor.add_node(node)\n\u002B            executor = SingleThreadedExecutor()\n\u002B            for node in nodes:\n\u002B                executor.add_node(node)\n \n-    try:\n-        executor.spin()\n-    except KeyboardInterrupt:\n\u002B            executor.spin()\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-\n-    executor.shutdown()\n-    rclpy.shutdown()\ndiff --git examples_tf2_py/examples_tf2_py/frame_dumper.py examples_tf2_py/examples_tf2_py/frame_dumper.py\nindex 4b76663e..2e61ac20 100644\n--- examples_tf2_py/examples_tf2_py/frame_dumper.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/frame_dumper.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n from tf2_ros.buffer import Buffer\n from tf2_ros.transform_listener import TransformListener\n@@ -34,11 \u002B35,9 @@ class FrameDumper(Node):\n \n \n def main():\n-    rclpy.init()\n-    node = FrameDumper()\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init():\n\u002B            node = FrameDumper()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-\n-    rclpy.shutdown()\ndiff --git examples_tf2_py/examples_tf2_py/static_broadcaster.py examples_tf2_py/examples_tf2_py/static_broadcaster.py\nindex c921a552..7c2d550f 100644\n--- examples_tf2_py/examples_tf2_py/static_broadcaster.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/static_broadcaster.py\n@@ -16,6 \u002B16,7 @@ import math\n \n from geometry_msgs.msg import TransformStamped\n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n from tf2_ros.static_transform_broadcaster import StaticTransformBroadcaster\n \n@@ -109,11 \u002B110,9 @@ class StaticFramePublisher(Node):\n \n \n def main():\n-    rclpy.init()\n-    node = StaticFramePublisher()\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init():\n\u002B            node = StaticFramePublisher()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-\n-    rclpy.shutdown()\ndiff --git examples_tf2_py/examples_tf2_py/waits_for_transform.py examples_tf2_py/examples_tf2_py/waits_for_transform.py\nindex b7606a12..25d144f0 100644\n--- examples_tf2_py/examples_tf2_py/waits_for_transform.py\n\u002B\u002B\u002B examples_tf2_py/examples_tf2_py/waits_for_transform.py\n@@ -15,6 \u002B15,7 @@\n import threading\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n import rclpy.time\n from tf2_ros import LookupException\n@@ -73,10 \u002B74,9 @@ class WaitsForTransform(Node):\n \n \n def main():\n-    rclpy.init()\n-    node = WaitsForTransform()\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init():\n\u002B            node = WaitsForTransform()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    rclpy.shutdown()\ndiff --git test_tf2/test/test_buffer_client.py test_tf2/test/test_buffer_client.py\nindex 97570c01..50fe895b 100755\n--- test_tf2/test/test_buffer_client.py\n\u002B\u002B\u002B test_tf2/test/test_buffer_client.py\n@@ -59,6 \u002B59,9 @@ class TestBufferClient(unittest.TestCase):\n \n     @classmethod\n     def tearDownClass(cls):\n\u002B        cls.executor.remove_node(cls.node)\n\u002B        cls.node.destroy_node()\n\u002B        cls.executor.shutdown()\n         rclpy.shutdown(context=cls.context)\n \n     def setUp(self):\ndiff --git tf2_ros_py/test/test_buffer_client.py tf2_ros_py/test/test_buffer_client.py\nindex dff0f147..7e167452 100644\n--- tf2_ros_py/test/test_buffer_client.py\n\u002B\u002B\u002B tf2_ros_py/test/test_buffer_client.py\n@@ -112,6 \u002B112,8 @@ class TestBufferClient:\n \n     @classmethod\n     def teardown_class(cls):\n\u002B        cls.executor.remove_node(cls.node)\n\u002B        cls.executor.shutdown()\n         cls.mock_action_server.destroy()\n         cls.node.destroy_node()\n         rclpy.shutdown(context=cls.context)\ndiff --git tf2_ros_py/test/test_listener_and_broadcaster.py tf2_ros_py/test/test_listener_and_broadcaster.py\nindex 0d41c1f6..fa0b6c0f 100644\n--- tf2_ros_py/test/test_listener_and_broadcaster.py\n\u002B\u002B\u002B tf2_ros_py/test/test_listener_and_broadcaster.py\n@@ -73,6 \u002B73,7 @@ class TestBroadcasterAndListener:\n \n     @classmethod\n     def teardown_class(cls):\n\u002B        cls.executor.remove_node(cls.node)\n         cls.node.destroy_node()\n         rclpy.shutdown()\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "common_interfaces",
    "SHA": "8c9a144399fed2a35a409098e7b009c2e6b86446",
    "RawMessage": "Change index.ros.org -\u003E docs.ros.org. (#149)",
    "Changes": "diff --git diagnostic_msgs/README.md diagnostic_msgs/README.md\nindex 31c54a5..8383c5c 100644\n--- diagnostic_msgs/README.md\n\u002B\u002B\u002B diagnostic_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides several messages and services for ROS node diagnostics.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [DiagnosticArray](msg/DiagnosticArray.msg): Used to send diagnostic information about the state of the robot.\ndiff --git geometry_msgs/README.md geometry_msgs/README.md\nindex 4a2b171..34a9513 100644\n--- geometry_msgs/README.md\n\u002B\u002B\u002B geometry_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides messages for common geometric primitives such as points, vectors, and poses. These primitives are designed to provide a common data type and facilitate interoperability throughout the system.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [Accel](msg/Accel.msg): Expresses acceleration in free space broken into its linear and angular parts.\ndiff --git nav_msgs/README.md nav_msgs/README.md\nindex 1168b35..d30926b 100644\n--- nav_msgs/README.md\n\u002B\u002B\u002B nav_msgs/README.md\n@@ -4,7 \u002B4,7 @@ This package provides several messages and services for robotic navigation.\n \n For more information about the navigation2 stack in ROS 2, see https://ros-planning.github.io/navigation2/.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [GridCells](msg/GridCells.msg): An array of cells in a 2D grid.\ndiff --git sensor_msgs/README.md sensor_msgs/README.md\nindex 7d332ba..ff9fbf0 100644\n--- sensor_msgs/README.md\n\u002B\u002B\u002B sensor_msgs/README.md\n@@ -4,7 \u002B4,7 @@ This package provides many messages and services relating to sensor devices.\n \n Many of these messages were ported from ROS 1 and a lot of still-relevant documentation can be found through the [ROS 1 sensor_msgs wiki](http://wiki.ros.org/sensor_msgs?distro=noetic).\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## sensor_msgs c\u002B\u002B API\n This package provides some common C\u002B\u002B functionality relating to manipulating a couple of particular sensor_msgs messages.\ndiff --git shape_msgs/README.md shape_msgs/README.md\nindex f1c7b23..96225e9 100644\n--- shape_msgs/README.md\n\u002B\u002B\u002B shape_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides several messages and services for describing 3-dimensional shapes.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [Mesh](msg/Mesh.msg): Holds information describing a mesh for visualization and collision detections.\ndiff --git std_msgs/README.md std_msgs/README.md\nindex 74df61c..4845511 100644\n--- std_msgs/README.md\n\u002B\u002B\u002B std_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n \u0060std_msgs\u0060 provides many basic message types. Only a few messages are intended for incorporation into higher-level messages. The primitive and primitive array types should generally not be relied upon for long-term use.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [ColorRGBA](msg/ColorRGBA.msg): A single RGBA value for representing colors.\ndiff --git std_srvs/README.md std_srvs/README.md\nindex e83568c..a89fb84 100644\n--- std_srvs/README.md\n\u002B\u002B\u002B std_srvs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides several service definitions for standard but simple ROS services.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Services (.srv)\n * [Empty.srv](srv/Empty.srv): A service containing an empty request and response.\ndiff --git stereo_msgs/README.md stereo_msgs/README.md\nindex d9b5a1f..59d6da8 100644\n--- stereo_msgs/README.md\n\u002B\u002B\u002B stereo_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides a message for describing a disparity image.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [DisparityImage](msg/DisparityImage.msg): A floating point disparity image with metadata.\ndiff --git trajectory_msgs/README.md trajectory_msgs/README.md\nindex 15cc213..71bf260 100644\n--- trajectory_msgs/README.md\n\u002B\u002B\u002B trajectory_msgs/README.md\n@@ -2,7 \u002B2,7 @@\n \n This package provides several messages for defining robotic joint trajectories.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [JointTrajectory](msg/JointTrajectory.msg): A coordinated sequence of joint configurations to be reached at prescribed time points.\ndiff --git visualization_msgs/README.md visualization_msgs/README.md\nindex 5bfc5a5..ae093e0 100644\n--- visualization_msgs/README.md\n\u002B\u002B\u002B visualization_msgs/README.md\n@@ -4,7 \u002B4,7 @@ This package provides messages for visualizing 3D information in ROS GUI program\n \n These messages were ported from ROS 1 and for now the [visualization_msgs wiki](http://wiki.ros.org/visualization_msgs) is still a good place for information about these messages and how they are used.\n \n-For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)\n\u002BFor more information about ROS 2 interfaces, see [docs.ros.org](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html).\n \n ## Messages (.msg)\n * [ImageMarker](msg/ImageMarker.msg): A marker to overlay on displayed images.\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "302c704d43c299a70a072e33abd6e72a543ad59e",
    "RawMessage": "added \u0022Tier 1\u0022 (#238)",
    "Changes": "diff --git README.md README.md\nindex 90fab96..cba839e 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -1,6 \u002B1,6 @@\n # ROS 2 RMW for Eclipse Cyclone DDS\n \n-**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS 2. Make your **\u2261\u0192\u00C9\u00F3 run like a \u2261\u0192\u00DC\u00C7** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n\u002B**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) Tier 1 ROS middleware** for ROS 2. Make your **\u2261\u0192\u00C9\u00F3 run like a \u2261\u0192\u00DC\u00C7** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n \n This package lets [*ROS 2*](https://docs.ros.org/en/rolling/) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS 2 experience. Let the Cyclone blow you away!\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "a001486377e0883b9c1c10081ed708e62b9472b1",
    "RawMessage": "Add some additional checking that cleanup happens. (#168)",
    "Changes": "diff --git test_rmw_implementation/test/test_service.cpp test_rmw_implementation/test/test_service.cpp\nindex 5d90939..cb5a3c4 100644\n--- test_rmw_implementation/test/test_service.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_service.cpp\n@@ -486,6 \u002B486,7 @@ TEST_F(CLASSNAME(TestService, RMW_IMPLEMENTATION), send_reponse_with_client_gone\n \n   // Remove client\n   ret = rmw_destroy_client(node, client);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret);\n   destroy_client = false;\n \n   // RMW_RET_OK is returned even if the client is gone\ndiff --git test_rmw_implementation/test/test_wait_set.cpp test_rmw_implementation/test/test_wait_set.cpp\nindex 721240b..5e9b01e 100644\n--- test_rmw_implementation/test/test_wait_set.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_wait_set.cpp\n@@ -144,6 \u002B144,7 @@ protected:\n     ret = rmw_destroy_guard_condition(gc);\n     EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n     ret = rmw_destroy_node(node);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n     Base::TearDown();\n   }\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "e97deeccf801aa783126df6eba9c9405c46d19c2",
    "RawMessage": "Make static_transform_broadcaster consistent with its command line description (#294)",
    "Changes": "diff --git tf2_ros/src/static_transform_broadcaster_program.cpp tf2_ros/src/static_transform_broadcaster_program.cpp\nindex 34a9f4b9..d363abbb 100644\n--- tf2_ros/src/static_transform_broadcaster_program.cpp\n\u002B\u002B\u002B tf2_ros/src/static_transform_broadcaster_program.cpp\n@@ -89,9 \u002B89,9 @@ int main(int argc, char ** argv)\n   std::string frame_id, child_id;\n \n   if (args.size() == 9) {\n-    // grab parameters from roll, pitch, yaw\n\u002B    // grab parameters from yaw, pitch, roll\n     tf2::Quaternion quat;\n-    quat.setRPY(std::stod(args[4]), std::stod(args[5]), std::stod(args[6]));\n\u002B    quat.setRPY(std::stod(args[6]), std::stod(args[5]), std::stod(args[4]));\n     rx = quat.x();\n     ry = quat.y();\n     rz = quat.z();\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "7f4d0d6b0509452b0d76af6122cdf5251919ecc9",
    "RawMessage": "Fix for invalid conversion from const char8_t* to char for C\u002B\u002B20 (#160)",
    "Changes": "diff --git test_msgs/include/test_msgs/message_fixtures.hpp test_msgs/include/test_msgs/message_fixtures.hpp\nindex 4292d43..45a5e1d 100644\n--- test_msgs/include/test_msgs/message_fixtures.hpp\n\u002B\u002B\u002B test_msgs/include/test_msgs/message_fixtures.hpp\n@@ -21,6 \u002B21,8 @@\n #include \u003Climits\u003E\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n\u002B#include \u003Cutility\u003E\n\u002B#include \u003Cstring\u003E\n \n #include \u0022test_msgs/msg/arrays.hpp\u0022\n #include \u0022test_msgs/msg/basic_types.hpp\u0022\n@@ -36,6 \u002B38,26 @@\n #include \u0022test_msgs/msg/unbounded_sequences.hpp\u0022\n #include \u0022test_msgs/msg/w_strings.hpp\u0022\n \n\u002Bstatic inline std::string\n\u002Bfrom_u8string(const std::string \u0026 s)\n\u002B{\n\u002B  return s;\n\u002B}\n\u002B\n\u002Bstatic inline std::string\n\u002Bfrom_u8string(std::string \u0026\u0026 s)\n\u002B{\n\u002B  return std::move(s);\n\u002B}\n\u002B\n\u002B#if defined(__cpp_lib_char8_t)\n\u002Bstatic inline std::string\n\u002Bfrom_u8string(const std::u8string \u0026 s)\n\u002B{\n\u002B  return std::string(s.begin(), s.end());\n\u002B}\n\u002B#endif\n\u002B\n static inline std::vector\u003Ctest_msgs::msg::Empty::SharedPtr\u003E\n get_messages_empty()\n {\n@@ -160,8 \u002B182,8 @@ get_messages_strings()\n   }\n   {\n     auto msg = std::make_shared\u003Ctest_msgs::msg::Strings\u003E();\n-    msg-\u003Estring_value = u8\u0022Hell\\u00F6 W\\u00F6rld!\u0022;  // using umlaut\n-    msg-\u003Ebounded_string_value = u8\u0022Hell\\u00F6 W\\u00F6rld!\u0022;  // using umlaut\n\u002B    msg-\u003Estring_value = from_u8string(u8\u0022Hell\\u00F6 W\\u00F6rld!\u0022);  // using umlaut\n\u002B    msg-\u003Ebounded_string_value = from_u8string(u8\u0022Hell\\u00F6 W\\u00F6rld!\u0022);  // using umlaut\n     messages.push_back(msg);\n   }\n   {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "b1f31e0eaaf7dcd59505ada2ca6e8646da347f95",
    "RawMessage": "min_forward \u0026 min_backward thresholds must not be disabled (#1815)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_time_source.cpp rclcpp/test/rclcpp/test_time_source.cpp\nindex 4a572c7a..c355ea62 100644\n--- rclcpp/test/rclcpp/test_time_source.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_time_source.cpp\n@@ -304,8 \u002B304,8 @@ public:\n TEST_F(TestTimeSource, callbacks) {\n   CallbackObject cbo;\n   rcl_jump_threshold_t jump_threshold;\n-  jump_threshold.min_forward.nanoseconds = 0;\n-  jump_threshold.min_backward.nanoseconds = 0;\n\u002B  jump_threshold.min_forward.nanoseconds = 1;\n\u002B  jump_threshold.min_backward.nanoseconds = -1;\n   jump_threshold.on_clock_change = true;\n \n   rclcpp::TimeSource ts(node);\n@@ -396,8 \u002B396,8 @@ TEST_F(TestTimeSource, callbacks) {\n TEST_F(TestTimeSource, callback_handler_erasure) {\n   CallbackObject cbo;\n   rcl_jump_threshold_t jump_threshold;\n-  jump_threshold.min_forward.nanoseconds = 0;\n-  jump_threshold.min_backward.nanoseconds = 0;\n\u002B  jump_threshold.min_forward.nanoseconds = 1;\n\u002B  jump_threshold.min_backward.nanoseconds = -1;\n   jump_threshold.on_clock_change = true;\n \n   rclcpp::TimeSource ts(node);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "7a7f23e0d7e51dd244001ef606b97f1153e5a97e",
    "RawMessage": "Add types to context.py (#1240)",
    "Changes": "diff --git rclpy/rclpy/context.py rclpy/rclpy/context.py\nindex 429a442..c3a2795 100644\n--- rclpy/rclpy/context.py\n\u002B\u002B\u002B rclpy/rclpy/context.py\n@@ -15,17 \u002B15,33 @@\n from inspect import ismethod\n import sys\n import threading\n-from types import TracebackType\n\u002Bfrom types import MethodType, TracebackType\n from typing import Callable\n from typing import ContextManager\n from typing import List\n from typing import Optional\n\u002Bfrom typing import Protocol\n from typing import Type\n-import weakref\n\u002Bfrom typing import Union\n\u002Bfrom weakref import WeakMethod\n\u002B\n\u002Bfrom rclpy.destroyable import DestroyableType\n\u002B\n\u002B\n\u002Bclass ContextHandle(DestroyableType, Protocol):\n\u002B\n\u002B    def ok(self) -\u003E bool:\n\u002B        ...\n\u002B\n\u002B    def get_domain_id(self) -\u003E int:\n\u002B        ...\n\u002B\n\u002B    def shutdown(self) -\u003E None:\n\u002B        ...\n \n \n g_logging_configure_lock = threading.Lock()\n-g_logging_ref_count = 0\n\u002Bg_logging_ref_count: int = 0\n \n \n class Context(ContextManager[\u0027Context\u0027]):\n@@ -43,24 \u002B59,25 @@ class Context(ContextManager[\u0027Context\u0027]):\n \n     \u0022\u0022\u0022\n \n-    def __init__(self):\n\u002B    def __init__(self) -\u003E None:\n         self._lock = threading.Lock()\n-        self._callbacks = []\n\u002B        self._callbacks: List[Union[\u0027WeakMethod[MethodType]\u0027, Callable[[], None]]] = []\n         self._logging_initialized = False\n-        self.__context = None\n\u002B        self.__context: Optional[ContextHandle] = None\n \n     @property\n-    def handle(self):\n\u002B    def handle(self) -\u003E Optional[ContextHandle]:\n         return self.__context\n \n-    def destroy(self):\n-        self.__context.destroy_when_not_in_use()\n\u002B    def destroy(self) -\u003E None:\n\u002B        if self.__context:\n\u002B            self.__context.destroy_when_not_in_use()\n \n     def init(self,\n              args: Optional[List[str]] = None,\n              *,\n              initialize_logging: bool = True,\n-             domain_id: Optional[int] = None):\n\u002B             domain_id: Optional[int] = None) -\u003E None:\n         \u0022\u0022\u0022\n         Initialize ROS communications for a given context.\n \n@@ -89,7 \u002B106,7 @@ class Context(ContextManager[\u0027Context\u0027]):\n                         _rclpy.rclpy_logging_configure(self.__context)\n                 self._logging_initialized = True\n \n-    def ok(self):\n\u002B    def ok(self) -\u003E bool:\n         \u0022\u0022\u0022Check if context hasn\u0027t been shut down.\u0022\u0022\u0022\n         with self._lock:\n             if self.__context is None:\n@@ -97,14 \u002B114,14 @@ class Context(ContextManager[\u0027Context\u0027]):\n             with self.__context:\n                 return self.__context.ok()\n \n-    def _call_on_shutdown_callbacks(self):\n\u002B    def _call_on_shutdown_callbacks(self) -\u003E None:\n         for weak_method in self._callbacks:\n             callback = weak_method()\n             if callback is not None:\n                 callback()\n         self._callbacks = []\n \n-    def shutdown(self):\n\u002B    def shutdown(self) -\u003E None:\n         \u0022\u0022\u0022Shutdown this context.\u0022\u0022\u0022\n         if self.__context is None:\n             raise RuntimeError(\u0027Context must be initialized before it can be shutdown\u0027)\n@@ -113,7 \u002B130,7 @@ class Context(ContextManager[\u0027Context\u0027]):\n             self._call_on_shutdown_callbacks()\n             self._logging_fini()\n \n-    def try_shutdown(self):\n\u002B    def try_shutdown(self) -\u003E None:\n         \u0022\u0022\u0022Shutdown this context, if not already shutdown.\u0022\u0022\u0022\n         if self.__context is None:\n             return\n@@ -123,23 \u002B140,32 @@ class Context(ContextManager[\u0027Context\u0027]):\n                 self._call_on_shutdown_callbacks()\n                 self._logging_fini()\n \n-    def _remove_callback(self, weak_method):\n\u002B    def _remove_callback(self, weak_method: \u0027WeakMethod[MethodType]\u0027) -\u003E None:\n         self._callbacks.remove(weak_method)\n \n-    def on_shutdown(self, callback: Callable[[], None]):\n\u002B    def on_shutdown(self, callback: Callable[[], None]) -\u003E None:\n         \u0022\u0022\u0022Add a callback to be called on shutdown.\u0022\u0022\u0022\n         if not callable(callback):\n             raise TypeError(\u0027callback should be a callable, got {}\u0027, type(callback))\n\u002B\n\u002B        if self.__context is None:\n\u002B            with self._lock:\n\u002B                if ismethod(callback):\n\u002B                    self._callbacks.append(WeakMethod(callback, self._remove_callback))\n\u002B                else:\n\u002B                    self._callbacks.append(callback)\n\u002B            return\n\u002B\n         with self.__context, self._lock:\n             if not self.__context.ok():\n                 callback()\n             else:\n                 if ismethod(callback):\n-                    self._callbacks.append(weakref.WeakMethod(callback, self._remove_callback))\n\u002B                    self._callbacks.append(WeakMethod(callback, self._remove_callback))\n                 else:\n                     self._callbacks.append(callback)\n \n-    def _logging_fini(self):\n\u002B    def _logging_fini(self) -\u003E None:\n         # This function must be called with self._lock held.\n         from rclpy.impl.implementation_singleton import rclpy_implementation\n         global g_logging_ref_count\n@@ -153,7 \u002B179,7 @@ class Context(ContextManager[\u0027Context\u0027]):\n                         \u0027Unexpected error: logger ref count should never be lower that zero\u0027)\n             self._logging_initialized = False\n \n-    def get_domain_id(self):\n\u002B    def get_domain_id(self) -\u003E int:\n         \u0022\u0022\u0022Get domain id of context.\u0022\u0022\u0022\n         if self.__context is None:\n             raise RuntimeError(\u0027Context must be initialized before it can have a domain id\u0027)\n@@ -162,7 \u002B188,7 @@ class Context(ContextManager[\u0027Context\u0027]):\n \n     def __enter__(self) -\u003E \u0027Context\u0027:\n         # We do not accept parameters here. If one wants to customize the init() call,\n-        # they would have to call it manaully and not use the ContextManager convenience\n\u002B        # they would have to call it manually and not use the ContextManager convenience\n         self.init()\n         return self\n \ndiff --git rclpy/rclpy/destroyable.py rclpy/rclpy/destroyable.py\nnew file mode 100644\nindex 0000000..8c05792\n--- /dev/null\n\u002B\u002B\u002B rclpy/rclpy/destroyable.py\n@@ -0,0 \u002B1,29 @@\n\u002B# Copyright 2024 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bfrom types import TracebackType\n\u002Bfrom typing import Optional, Protocol, Type\n\u002B\n\u002B\n\u002Bclass DestroyableType(Protocol):\n\u002B\n\u002B    def __enter__(self) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def __exit__(self, exc_type: Optional[Type[BaseException]],\n\u002B                 exc_val: Optional[BaseException], exctb: Optional[TracebackType]) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def destroy_when_not_in_use(self) -\u003E None:\n\u002B        ...\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclc",
    "SHA": "cc6879fbfd9e3c0591c5ee094b0ebaaac7a4eb82",
    "RawMessage": "Do not return error when rcl_send_response timeout. (#408)",
    "Changes": "diff --git rclc/src/rclc/executor.c rclc/src/rclc/executor.c\nindex 79ddcd3..e9adebf 100644\n--- rclc/src/rclc/executor.c\n\u002B\u002B\u002B rclc/src/rclc/executor.c\n@@ -1473,6 \u002B1473,12 @@ _rclc_execute(rclc_executor_handle_t * handle)\n         }\n         // handle rcl-side services\n         rc = rcl_send_response(handle-\u003Eservice, \u0026handle-\u003Ereq_id, handle-\u003Edata_response_msg);\n\u002B        if (rc == RCL_RET_TIMEOUT) {\n\u002B          // because of racy condition between service client and server endpoint creation,\n\u002B          // server cannot find the concerned client just yet.\n\u002B          PRINT_RCLC_WARN(rclc_execute, rcl_send_response);\n\u002B          rc = RCL_RET_OK;\n\u002B        }\n         if (rc != RCL_RET_OK) {\n           PRINT_RCLC_ERROR(rclc_execute, rcl_send_response);\n           return rc;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "238dded50093578aa017efe9c78883c3e0aa3d52",
    "RawMessage": "Update geometry2 to C\u002B\u002B17 (#584)",
    "Changes": "diff --git tf2/CMakeLists.txt tf2/CMakeLists.txt\nindex 6e8d654e..20366888 100644\n--- tf2/CMakeLists.txt\n\u002B\u002B\u002B tf2/CMakeLists.txt\n@@ -1,9 \u002B1,10 @@\n cmake_minimum_required(VERSION 3.5)\n project(tf2)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n \n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\ndiff --git tf2_eigen_kdl/CMakeLists.txt tf2_eigen_kdl/CMakeLists.txt\nindex 9bdfa1d1..c52a0591 100644\n--- tf2_eigen_kdl/CMakeLists.txt\n\u002B\u002B\u002B tf2_eigen_kdl/CMakeLists.txt\n@@ -1,9 \u002B1,10 @@\n cmake_minimum_required(VERSION 3.5)\n project(tf2_eigen_kdl)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git tf2_msgs/CMakeLists.txt tf2_msgs/CMakeLists.txt\nindex f8f424c0..2661fc85 100644\n--- tf2_msgs/CMakeLists.txt\n\u002B\u002B\u002B tf2_msgs/CMakeLists.txt\n@@ -1,9 \u002B1,10 @@\n cmake_minimum_required(VERSION 3.5)\n project(tf2_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)\ndiff --git tf2_py/CMakeLists.txt tf2_py/CMakeLists.txt\nindex c0e7b9a8..a8e4e9ba 100644\n--- tf2_py/CMakeLists.txt\n\u002B\u002B\u002B tf2_py/CMakeLists.txt\n@@ -1,9 \u002B1,10 @@\n cmake_minimum_required(VERSION 3.5)\n project(tf2_py)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n \n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "ef5d8116a4899b069b0cb444b1fdf8e3b1b7b6d4",
    "RawMessage": "Update ros2 param dump dosctring. (#837)",
    "Changes": "diff --git ros2param/ros2param/verb/dump.py ros2param/ros2param/verb/dump.py\nindex e9577fd..be9cd71 100644\n--- ros2param/ros2param/verb/dump.py\n\u002B\u002B\u002B ros2param/ros2param/verb/dump.py\n@@ -29,7 \u002B29,7 @@ import yaml\n \n \n class DumpVerb(VerbExtension):\n-    \u0022\u0022\u0022Dump the parameters of a node to a yaml file.\u0022\u0022\u0022\n\u002B    \u0022\u0022\u0022Show all of the parameters of a node in a YAML file format.\u0022\u0022\u0022\n \n     def add_arguments(self, parser, cli_name):  # noqa: D102\n         add_arguments(parser)\n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "79829674ed8ce1bc6263ffdc94c823915d52e0e5",
    "RawMessage": "address linter waning for windows. (#592)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\nindex 87eb46d..bad85cb 100644\n--- rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n@@ -443,7 \u002B443,8 @@ MemberIdentifierName GetTypeIdentifier(const MembersType * members, uint32_t ind\n     case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n     case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n       {\n-        uint32_t bound = member-\u003Estring_upper_bound_ ? member-\u003Estring_upper_bound_ : 255;\n\u002B        uint32_t bound = member-\u003Estring_upper_bound_ ?\n\u002B          static_cast\u003Cuint32_t\u003E(member-\u003Estring_upper_bound_) : 255;\n         bool wide =\n           (member-\u003Etype_id_ == ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING) ?\n           false : true;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "a4daa7672f287997d1345a44ebb9e0c3d0c490b6",
    "RawMessage": "Continue to next iteration after exceptions in generate_reports (#623)",
    "Changes": "diff --git ros2doctor/ros2doctor/api/__init__.py ros2doctor/ros2doctor/api/__init__.py\nindex 244711e..88cd71a 100644\n--- ros2doctor/ros2doctor/api/__init__.py\n\u002B\u002B\u002B ros2doctor/ros2doctor/api/__init__.py\n@@ -95,10 \u002B95,12 @@ def run_checks(*, include_warnings=False) -\u003E Tuple[Set[str], int, int]:\n             check_class = check_entry_pt.load()\n         except ImportError:\n             doctor_warn(f\u0027Check entry point {check_entry_pt.name} fails to load.\u0027)\n\u002B            continue\n         try:\n             check_instance = check_class()\n         except Exception:\n             doctor_warn(f\u0027Unable to instantiate check object from {check_entry_pt.name}.\u0027)\n\u002B            continue\n         try:\n             check_category = check_instance.category()\n             result = check_instance.check()\n@@ -123,10 \u002B125,12 @@ def generate_reports(*, categories=None) -\u003E List[Report]:\n             report_class = report_entry_pt.load()\n         except ImportError:\n             doctor_warn(f\u0027Report entry point {report_entry_pt.name} fails to load.\u0027)\n\u002B            continue\n         try:\n             report_instance = report_class()\n         except Exception:\n             doctor_warn(f\u0027Unable to instantiate report object from {report_entry_pt.name}.\u0027)\n\u002B            continue\n         try:\n             report_category = report_instance.category()\n             report = report_instance.report()\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "8edb67482dbd96dbdb2919858bdd0dcce4d22bfb",
    "RawMessage": "add test to ensure binary STL files from SOLIDWORKS get imported without a warning (#917)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/mesh_loader_helpers/stl_loader.cpp rviz_rendering/src/rviz_rendering/mesh_loader_helpers/stl_loader.cpp\nindex b5a269e2..773e8c50 100644\n--- rviz_rendering/src/rviz_rendering/mesh_loader_helpers/stl_loader.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/mesh_loader_helpers/stl_loader.cpp\n@@ -52,29 \u002B52,17 @@ bool STLLoader::load(uint8_t * buffer, const size_t num_bytes, const std::string\n   // check for ascii since we can only load binary types with this class\n   std::string buffer_str = std::string(reinterpret_cast\u003Cchar *\u003E(buffer), num_bytes);\n \n-  if (buffer_str.substr(0, 5) == std::string(\u0022solid\u0022)) {\n-    // file says that it is ascii, but why should we trust it?\n-\n-    // check for \u0022endsolid\u0022 as well\n-    if (buffer_str.find(\u0022endsolid\u0022, 5) != std::string::npos) {\n-      RVIZ_RENDERING_LOG_ERROR_STREAM(\n-        \u0022The STL file \u0027\u0022 \u003C\u003C origin \u003C\u003C \u0022\u0027 is malformed. It \u0022\n-          \u0022starts with the word \u0027solid\u0027 and also contains the \u0022\n-          \u0022word \u0027endsolid\u0027, indicating that it\u0027s an ASCII STL \u0022\n-          \u0022file, but rviz can only load binary STL files so it \u0022\n-          \u0022will not be loaded. Please convert it to a \u0022\n-          \u0022binary STL file.\u0022);\n-      return false;\n-    }\n-\n-    // chastise the user for malformed files\n-    RVIZ_RENDERING_LOG_WARNING_STREAM(\n-      \u0022The STL file \u0027\u0022 \u003C\u003C origin \u003C\u003C \u0022\u0027 is malformed. It starts \u0022\n-        \u0022with the word \u0027solid\u0027, indicating that it\u0027s an ASCII \u0022\n-        \u0022STL file, but it does not contain the word \u0027endsolid\u0027 so \u0022\n-        \u0022it is either a malformed ASCII STL file or it is actually \u0022\n-        \u0022a binary STL file. Trying to interpret it as a binary \u0022\n-        \u0022STL file instead.\u0022);\n\u002B  if (buffer_str.substr(0, 5) == std::string(\u0022solid\u0022) \u0026\u0026\n\u002B    buffer_str.find(\u0022endsolid\u0022, 5) != std::string::npos)\n\u002B  {\n\u002B    RVIZ_RENDERING_LOG_ERROR_STREAM(\n\u002B      \u0022The STL file \u0027\u0022 \u003C\u003C origin \u003C\u003C \u0022\u0027 is malformed. It \u0022\n\u002B        \u0022starts with the word \u0027solid\u0027 and also contains the \u0022\n\u002B        \u0022word \u0027endsolid\u0027, indicating that it\u0027s an ASCII STL \u0022\n\u002B        \u0022file, but rviz can only load binary STL files so it \u0022\n\u002B        \u0022will not be loaded. Please convert it to a \u0022\n\u002B        \u0022binary STL file.\u0022);\n\u002B    return false;\n   }\n \n   // make sure there\u0027s enough data for a binary STL header and triangle count\ndiff --git rviz_rendering_tests/ogre_media_resources/test_meshes/solidworks.stl rviz_rendering_tests/ogre_media_resources/test_meshes/solidworks.stl\nnew file mode 100644\nindex 00000000..510903e4\nBinary files /dev/null and rviz_rendering_tests/ogre_media_resources/test_meshes/solidworks.stl differ\ndiff --git rviz_rendering_tests/test/mesh_loader_test.cpp rviz_rendering_tests/test/mesh_loader_test.cpp\nindex badd0d26..a924d793 100644\n--- rviz_rendering_tests/test/mesh_loader_test.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/mesh_loader_test.cpp\n@@ -184,3 \u002B184,16 @@ TEST_F(MeshLoaderTestFixture, assimp_loader_reads_size_correctly) {\n   ASSERT_FLOAT_EQ(expected_bounding_radius, mesh-\u003EgetBoundingSphereRadius());\n   assertBoundingBoxEquality(expected_bounding_box, mesh-\u003EgetBounds());\n }\n\u002B\n\u002BTEST_F(MeshLoaderTestFixture, loading_solidworks_binary_stl) {\n\u002B  // In general, binary STL files should not start with \u0022solid\u0022 as this hints ASCII STL files.\n\u002B  // Annoyingly, STL files exported from Solidworks don\u0027t follow this guideline and contain\n\u002B  // \u0022solid\u0022 at the start of binary STL files.\n\u002B  // However, they don\u0027t finish with \u0022endsolid\u0022 like ASCII STL files, so we can still detect\n\u002B  // them as binary STL files.\n\u002B  // This test checks that SOLIDWORKS binary STL files get loaded correctly and don\u0027t get treated\n\u002B  // as ASCII STL files.\n\u002B  std::string mesh_path = \u0022package://rviz_rendering_tests/test_meshes/solidworks.stl\u0022;\n\u002B\n\u002B  ASSERT_TRUE(rviz_rendering::loadMeshFromResource(mesh_path));\n\u002B}\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "0096a96f19920e193dc3736c1aee0f4a56d8f478",
    "RawMessage": "Use Py_XDECREF for pynode_names_and_namespaces (#673)",
    "Changes": "diff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 0671d24..f1fc9a8 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -3825,7 \u002B3825,7 @@ cleanup:\n     PyErr_Format(\n       RCLError,\n       \u0022Failed to destroy node_names: %s\u0022, rcl_get_error_string().str);\n-    Py_DECREF(pynode_names_and_namespaces);\n\u002B    Py_XDECREF(pynode_names_and_namespaces);\n     rcl_reset_error();\n     return NULL;\n   }\n@@ -3833,7 \u002B3833,7 @@ cleanup:\n     PyErr_Format(\n       RCLError,\n       \u0022Failed to destroy node_namespaces: %s\u0022, rcl_get_error_string().str);\n-    Py_DECREF(pynode_names_and_namespaces);\n\u002B    Py_XDECREF(pynode_names_and_namespaces);\n     rcl_reset_error();\n     return NULL;\n   }\n@@ -3841,7 \u002B3841,7 @@ cleanup:\n     PyErr_Format(\n       RCLError,\n       \u0022Failed to destroy enclaves string array: %s\u0022, rcl_get_error_string().str);\n-    Py_DECREF(pynode_names_and_namespaces);\n\u002B    Py_XDECREF(pynode_names_and_namespaces);\n     rcl_reset_error();\n     return NULL;\n   }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "0fd866d201fd63e21a84e4c78857217fd884eecc",
    "RawMessage": "Fix unused QoS profile for clock subscription and make ClockQoS the default (#1801)",
    "Changes": "diff --git rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\nindex 1c9afebe..1594d5f8 100644\n--- rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\n@@ -48,7 \u002B48,7 @@ public:\n     rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging,\n     rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock,\n     rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters,\n-    const rclcpp::QoS \u0026 qos = rclcpp::RosoutQoS(),\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ClockQoS(),\n     bool use_clock_thread = true\n   );\n \ndiff --git rclcpp/src/rclcpp/time_source.cpp rclcpp/src/rclcpp/time_source.cpp\nindex 61c5fdd7..7e1226e1 100644\n--- rclcpp/src/rclcpp/time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time_source.cpp\n@@ -420,7 \u002B420,7 @@ private:\n       node_parameters_,\n       node_topics_,\n       \u0022/clock\u0022,\n-      rclcpp::QoS(KeepLast(1)).best_effort(),\n\u002B      qos_,\n       [state = std::weak_ptr\u003CNodeState\u003E(this-\u003Eshared_from_this())](\n         std::shared_ptr\u003Cconst rosgraph_msgs::msg::Clock\u003E msg) {\n         if (auto state_ptr = state.lock()) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "c46896731c3a02b39140bea9d31ae36c99846344",
    "RawMessage": "Make more of the Waitable API abstract (#2593)",
    "Changes": "diff --git rclcpp/include/rclcpp/waitable.hpp rclcpp/include/rclcpp/waitable.hpp\nindex 280d79c3..c803629d 100644\n--- rclcpp/include/rclcpp/waitable.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/waitable.hpp\n@@ -109,7 \u002B109,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   void\n-  add_to_wait_set(rcl_wait_set_t \u0026 wait_set);\n\u002B  add_to_wait_set(rcl_wait_set_t \u0026 wait_set) = 0;\n \n   /// Check if the Waitable is ready.\n   /**\n@@ -124,7 \u002B124,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   bool\n-  is_ready(const rcl_wait_set_t \u0026 wait_set);\n\u002B  is_ready(const rcl_wait_set_t \u0026 wait_set) = 0;\n \n   /// Take the data so that it can be consumed with \u0060execute\u0060.\n   /**\n@@ -176,7 \u002B176,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   std::shared_ptr\u003Cvoid\u003E\n-  take_data_by_entity_id(size_t id);\n\u002B  take_data_by_entity_id(size_t id) = 0;\n \n   /// Execute data that is passed in.\n   /**\n@@ -203,7 \u002B203,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   void\n-  execute(const std::shared_ptr\u003Cvoid\u003E \u0026 data);\n\u002B  execute(const std::shared_ptr\u003Cvoid\u003E \u0026 data) = 0;\n \n   /// Exchange the \u0022in use by wait set\u0022 state for this timer.\n   /**\n@@ -246,7 \u002B246,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   void\n-  set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E callback);\n\u002B  set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E callback) = 0;\n \n   /// Unset any callback registered via set_on_ready_callback.\n   /**\n@@ -256,7 \u002B256,7 @@ public:\n   RCLCPP_PUBLIC\n   virtual\n   void\n-  clear_on_ready_callback();\n\u002B  clear_on_ready_callback() = 0;\n \n private:\n   std::atomic\u003Cbool\u003E in_use_by_wait_set_{false};\ndiff --git rclcpp/src/rclcpp/waitable.cpp rclcpp/src/rclcpp/waitable.cpp\nindex 1ee4f907..ef3a50a8 100644\n--- rclcpp/src/rclcpp/waitable.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/waitable.cpp\n@@ -54,54 \u002B54,8 @@ Waitable::get_number_of_ready_guard_conditions()\n   return 0u;\n }\n \n-std::shared_ptr\u003Cvoid\u003E\n-Waitable::take_data_by_entity_id(size_t id)\n-{\n-  (void)id;\n-  throw std::runtime_error(\n-          \u0022Custom waitables should override take_data_by_entity_id \u0022\n-          \u0022if they want to use it.\u0022);\n-}\n-\n bool\n Waitable::exchange_in_use_by_wait_set_state(bool in_use_state)\n {\n   return in_use_by_wait_set_.exchange(in_use_state);\n }\n-\n-void\n-Waitable::set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E callback)\n-{\n-  (void)callback;\n-\n-  throw std::runtime_error(\n-          \u0022Custom waitables should override set_on_ready_callback \u0022\n-          \u0022if they want to use it.\u0022);\n-}\n-\n-void\n-Waitable::clear_on_ready_callback()\n-{\n-  throw std::runtime_error(\n-          \u0022Custom waitables should override clear_on_ready_callback if they \u0022\n-          \u0022want to use it and make sure to call it on the waitable destructor.\u0022);\n-}\n-\n-bool\n-Waitable::is_ready(const rcl_wait_set_t \u0026 wait_set)\n-{\n-  return this-\u003Eis_ready(wait_set);\n-}\n-\n-void\n-Waitable::add_to_wait_set(rcl_wait_set_t \u0026 wait_set)\n-{\n-  this-\u003Eadd_to_wait_set(wait_set);\n-}\n-\n-void\n-Waitable::execute(const std::shared_ptr\u003Cvoid\u003E \u0026 data)\n-{\n-  // note this const cast is only required to support a deprecated function\n-  this-\u003Eexecute(const_cast\u003Cstd::shared_ptr\u003Cvoid\u003E \u0026\u003E(data));\n-}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp\nindex aa34a71a..2b6b1092 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp\n@@ -31,13 \u002B31,13 @@ public:\n   void add_to_wait_set(rcl_wait_set_t \u0026) override {}\n   bool is_ready(const rcl_wait_set_t \u0026) override {return false;}\n \n-  std::shared_ptr\u003Cvoid\u003E\n-  take_data() override\n-  {\n-    return nullptr;\n-  }\n-\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n   void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B\n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n };\n \n class TestNodeWaitables : public ::testing::Test\ndiff --git rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\nindex 45222864..27c27119 100644\n--- rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\n@@ -51,13 \u002B51,13 @@ public:\n     return test_waitable_result;\n   }\n \n-  std::shared_ptr\u003Cvoid\u003E\n-  take_data() override\n-  {\n-    return nullptr;\n-  }\n-\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n   void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B\n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n };\n \n struct RclWaitSetSizes\ndiff --git rclcpp/test/rclcpp/test_memory_strategy.cpp rclcpp/test/rclcpp/test_memory_strategy.cpp\nindex 4c166ebb..7ceb4e7b 100644\n--- rclcpp/test/rclcpp/test_memory_strategy.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_memory_strategy.cpp\n@@ -40,6 \u002B40,11 @@ public:\n \n   std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n   void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B\n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n };\n \n class TestMemoryStrategy : public ::testing::Test\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\nindex 12bd2f88..e69d3480 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\n@@ -52,16 \u002B52,18 @@ public:\n   : is_ready_(false) {}\n \n   void add_to_wait_set(rcl_wait_set_t \u0026) override {}\n-\n   bool is_ready(const rcl_wait_set_t \u0026) override {return is_ready_;}\n \n   std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n-\n-  void\n-  execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B  void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n \n   void set_is_ready(bool value) {is_ready_ = value;}\n \n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n\u002B\n private:\n   bool is_ready_;\n };\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\nindex f3e94b6a..ed3336e1 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\n@@ -52,16 \u002B52,18 @@ public:\n   : is_ready_(false) {}\n \n   void add_to_wait_set(rcl_wait_set_t \u0026) override {}\n-\n   bool is_ready(const rcl_wait_set_t \u0026) override {return is_ready_;}\n \n   std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n-\n-  void\n-  execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B  void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n \n   void set_is_ready(bool value) {is_ready_ = value;}\n \n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n\u002B\n private:\n   bool is_ready_;\n };\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\nindex eaf3a866..f7ae12c2 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\n@@ -61,14 \u002B61,17 @@ public:\n   bool is_ready(const rcl_wait_set_t \u0026) override {return is_ready_;}\n \n   std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n-\n-  void\n-  execute(const std::shared_ptr\u003Cvoid\u003E \u0026 data) override {(void)data;}\n\u002B  void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n \n   void set_is_ready(bool value) {is_ready_ = value;}\n \n   void set_add_to_wait_set(bool value) {add_to_wait_set_ = value;}\n \n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n\u002B\n private:\n   bool is_ready_;\n   bool add_to_wait_set_;\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\nindex e6a03483..12c88381 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\n@@ -52,16 \u002B52,18 @@ public:\n   : is_ready_(false) {}\n \n   void add_to_wait_set(rcl_wait_set_t \u0026) override {}\n-\n   bool is_ready(const rcl_wait_set_t \u0026) override {return is_ready_;}\n \n   std::shared_ptr\u003Cvoid\u003E take_data() override {return nullptr;}\n-\n-  void\n-  execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B  void execute(const std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n \n   void set_is_ready(bool value) {is_ready_ = value;}\n \n\u002B  void set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E) override {}\n\u002B  void clear_on_ready_callback() override {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E take_data_by_entity_id(size_t) override {return nullptr;}\n\u002B\n private:\n   bool is_ready_;\n };\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_logging",
    "SHA": "0724aeb90f5d4efd23a75b1a97a4429ec6911a60",
    "RawMessage": "rcl_logging_interface is only valid path with build environment. (#122)",
    "Changes": "diff --git rcl_logging_noop/CMakeLists.txt rcl_logging_noop/CMakeLists.txt\nindex ba48cf4..c67891f 100644\n--- rcl_logging_noop/CMakeLists.txt\n\u002B\u002B\u002B rcl_logging_noop/CMakeLists.txt\n@@ -39,7 \u002B39,7 @@ install(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}\n   LIBRARY DESTINATION lib\n   RUNTIME DESTINATION bin)\n \n-\n\u002Bament_export_dependencies(rcl_logging_interface)\n ament_export_libraries(${PROJECT_NAME})\n ament_export_targets(${PROJECT_NAME})\n ament_package()\ndiff --git rcl_logging_spdlog/CMakeLists.txt rcl_logging_spdlog/CMakeLists.txt\nindex 9c58fa2..82d4d27 100644\n--- rcl_logging_spdlog/CMakeLists.txt\n\u002B\u002B\u002B rcl_logging_spdlog/CMakeLists.txt\n@@ -68,6 \u002B68,7 @@ if(BUILD_TESTING)\n   endif()\n endif()\n \n\u002Bament_export_dependencies(rcl_logging_interface)\n ament_export_libraries(${PROJECT_NAME})\n ament_export_targets(${PROJECT_NAME})\n ament_package()\n",
    "BackportedTo": "jazzy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "210791c2a57a5c7c87e348e684c9cdc28469cb70",
    "RawMessage": "More info in tf2_echo output (#468)",
    "Changes": "diff --git tf2_ros/src/tf2_echo.cpp tf2_ros/src/tf2_echo.cpp\nindex 39a5582d..44bd777d 100644\n--- tf2_ros/src/tf2_echo.cpp\n\u002B\u002B\u002B tf2_ros/src/tf2_echo.cpp\n@@ -28,8 \u002B28,16 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#ifdef _MSC_VER\n\u002B#ifndef _USE_MATH_DEFINES\n\u002B#define _USE_MATH_DEFINES\n\u002B#endif\n\u002B#endif\n\u002B\n\u002B#include \u003Ccmath\u003E\n #include \u003Ccstdio\u003E\n #include \u003Ccstring\u003E\n\u002B#include \u003Ciomanip\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n@@ -40,8 \u002B48,6 @@\n \n #include \u0022rclcpp/rclcpp.hpp\u0022\n \n-#define _USE_MATH_DEFINES\n-\n class echoListener\n {\n public:\n@@ -125,6 \u002B131,7 @@ int main(int argc, char ** argv)\n       source_frameid.c_str(), target_frameid.c_str(), warning_msg.c_str());\n     rate.sleep();\n   }\n\u002B  constexpr double rad_to_deg = 180.0 / M_PI;\n \n   // Nothing needs to be done except wait for a quit\n   // The callbacks within the listener class will take care of everything\n@@ -138,21 \u002B145,38 @@ int main(int argc, char ** argv)\n       std::cout.setf(std::ios::fixed, std::ios::floatfield);\n       std::cout \u003C\u003C \u0022At time \u0022 \u003C\u003C echo_transform.header.stamp.sec \u003C\u003C \u0022.\u0022 \u003C\u003C\n         echo_transform.header.stamp.nanosec \u003C\u003C std::endl;\n-      // double yaw, pitch, roll;\n-      // echo_transform.getBasis().getRPY(roll, pitch, yaw);\n-      // tf::Quaternion q = echo_transform.getRotation();\n-      // tf::Vector3 v = echo_transform.getOrigin();\n       auto translation = echo_transform.transform.translation;\n\u002B      double translation_xyz[] = {translation.x, translation.y, translation.z};\n       auto rotation = echo_transform.transform.rotation;\n       std::cout \u003C\u003C \u0022- Translation: [\u0022 \u003C\u003C translation.x \u003C\u003C \u0022, \u0022 \u003C\u003C translation.y \u003C\u003C \u0022, \u0022 \u003C\u003C\n         translation.z \u003C\u003C \u0022]\u0022 \u003C\u003C std::endl;\n       std::cout \u003C\u003C \u0022- Rotation: in Quaternion [\u0022 \u003C\u003C rotation.x \u003C\u003C \u0022, \u0022 \u003C\u003C rotation.y \u003C\u003C \u0022, \u0022 \u003C\u003C\n         rotation.z \u003C\u003C \u0022, \u0022 \u003C\u003C rotation.w \u003C\u003C \u0022]\u0022 \u003C\u003C std::endl;\n-      // TODO(tfoote): restory rpy\n-      // \u003C\u003C \u0022            in RPY (radian) [\u0022 \u003C\u003C  roll \u003C\u003C \u0022, \u0022 \u003C\u003C pitch \u003C\u003C \u0022, \u0022 \u003C\u003C yaw \u003C\u003C \u0022]\u0022 \u003C\u003C\n-      // std::endl\n-      // \u003C\u003C \u0022            in RPY (degree) [\u0022 \u003C\u003C  roll*180.0/M_PI \u003C\u003C \u0022, \u0022 \u003C\u003C pitch*180.0/M_PI \u003C\u003C\n-      // \u0022, \u0022 \u003C\u003C yaw*180.0/M_PI \u003C\u003C \u0022]\u0022 \u003C\u003C std::endl;\n\u002B\n\u002B      tf2::Matrix3x3 mat(tf2::Quaternion{rotation.x, rotation.y, rotation.z, rotation.w});\n\u002B\n\u002B      tf2Scalar yaw, pitch, roll;\n\u002B      mat.getEulerYPR(yaw, pitch, roll);\n\u002B\n\u002B      std::cout \u003C\u003C \u0022- Rotation: in RPY (radian) [\u0022 \u003C\u003C roll \u003C\u003C \u0022, \u0022 \u003C\u003C pitch \u003C\u003C \u0022, \u0022 \u003C\u003C yaw \u003C\u003C \u0022]\u0022 \u003C\u003C\n\u002B        std::endl;\n\u002B      std::cout \u003C\u003C \u0022- Rotation: in RPY (degree) [\u0022 \u003C\u003C\n\u002B        roll * rad_to_deg \u003C\u003C \u0022, \u0022 \u003C\u003C\n\u002B        pitch * rad_to_deg \u003C\u003C \u0022, \u0022 \u003C\u003C\n\u002B        yaw * rad_to_deg \u003C\u003C \u0022]\u0022 \u003C\u003C std::endl;\n\u002B\n\u002B      std::cout \u003C\u003C \u0022- Matrix:\u0022 \u003C\u003C std::endl;\n\u002B      for (int i = 0; i \u003C 3; i\u002B\u002B) {\n\u002B        for (int j = 0; j \u003C 3; j\u002B\u002B) {\n\u002B          std::cout \u003C\u003C \u0022 \u0022 \u003C\u003C std::setw(6) \u003C\u003C std::setprecision(3) \u003C\u003C mat[i][j];\n\u002B        }\n\u002B        std::cout \u003C\u003C \u0022 \u0022 \u003C\u003C std::setw(6) \u003C\u003C std::setprecision(3) \u003C\u003C translation_xyz[i];\n\u002B        std::cout \u003C\u003C std::endl;\n\u002B      }\n\u002B      for (int j = 0; j \u003C 3; j\u002B\u002B) {\n\u002B        std::cout \u003C\u003C \u0022 \u0022 \u003C\u003C std::setw(6) \u003C\u003C std::setprecision(3) \u003C\u003C 0.0;\n\u002B      }\n\u002B      std::cout \u003C\u003C \u0022 \u0022 \u003C\u003C std::setw(6) \u003C\u003C std::setprecision(3) \u003C\u003C 1.0 \u003C\u003C std::endl;\n     } catch (const tf2::TransformException \u0026 ex) {\n       std::cout \u003C\u003C \u0022Failure at \u0022 \u003C\u003C clock-\u003Enow().seconds() \u003C\u003C std::endl;\n       std::cout \u003C\u003C \u0022Exception thrown:\u0022 \u003C\u003C ex.what() \u003C\u003C std::endl;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "06a4ee01d41e6870000ce2011acd157d3e85c5ce",
    "RawMessage": "Add spin_some support to the StaticSingleThreadedExecutor (#1338)",
    "Changes": "diff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex 946aa188..9321f679 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -544,7 \u002B544,7 @@ protected:\n   RCLCPP_DISABLE_COPY(Executor)\n \n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   spin_once_impl(std::chrono::nanoseconds timeout);\n \n   typedef std::map\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\ndiff --git rclcpp/include/rclcpp/executors/static_executor_entities_collector.hpp rclcpp/include/rclcpp/executors/static_executor_entities_collector.hpp\nindex 51f80b32..695b35a2 100644\n--- rclcpp/include/rclcpp/executors/static_executor_entities_collector.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/static_executor_entities_collector.hpp\n@@ -68,6 \u002B68,10 @@ public:\n     rcl_guard_condition_t * executor_guard_condition);\n \n   /// Finalize StaticExecutorEntitiesCollector to clear resources\n\u002B  RCLCPP_PUBLIC\n\u002B  bool\n\u002B  is_init() {return initialized_;}\n\u002B\n   RCLCPP_PUBLIC\n   void\n   fini();\n@@ -339,6 \u002B343,9 @@ private:\n \n   /// Executable list: timers, subscribers, clients, services and waitables\n   rclcpp::experimental::ExecutableList exec_list_;\n\u002B\n\u002B  /// Bool to check if the entities collector has been initialized\n\u002B  bool initialized_ = false;\n };\n \n }  // namespace executors\ndiff --git rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\nindex cbfcd00a..61da15e1 100644\n--- rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\n@@ -15,6 \u002B15,7 @@\n #ifndef RCLCPP__EXECUTORS__STATIC_SINGLE_THREADED_EXECUTOR_HPP_\n #define RCLCPP__EXECUTORS__STATIC_SINGLE_THREADED_EXECUTOR_HPP_\n \n\u002B#include \u003Cchrono\u003E\n #include \u003Ccassert\u003E\n #include \u003Ccstdlib\u003E\n #include \u003Cmemory\u003E\n@@ -78,6 \u002B79,42 @@ public:\n   void\n   spin() override;\n \n\u002B  /// Static executor implementation of spin some\n\u002B  /**\n\u002B   * This non-blocking function will execute entities that\n\u002B   * were ready when this API was called, until timeout or no\n\u002B   * more work available. Entities that got ready while\n\u002B   * executing work, won\u0027t be taken into account here.\n\u002B   *\n\u002B   * Example:\n\u002B   *   while(condition) {\n\u002B   *     spin_some();\n\u002B   *     sleep(); // User should have some sync work or\n\u002B   *              // sleep to avoid a 100% CPU usage\n\u002B   *   }\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  spin_some(std::chrono::nanoseconds max_duration = std::chrono::nanoseconds(0)) override;\n\u002B\n\u002B  /// Static executor implementation of spin all\n\u002B  /**\n\u002B   * This non-blocking function will execute entities until\n\u002B   * timeout or no more work available. If new entities get ready\n\u002B   * while executing work available, they will be executed\n\u002B   * as long as the timeout hasn\u0027t expired.\n\u002B   *\n\u002B   * Example:\n\u002B   *   while(condition) {\n\u002B   *     spin_all();\n\u002B   *     sleep(); // User should have some sync work or\n\u002B   *              // sleep to avoid a 100% CPU usage\n\u002B   *   }\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  spin_all(std::chrono::nanoseconds max_duration) override;\n\u002B\n   /// Add a callback group to an executor.\n   /**\n    * \\sa rclcpp::Executor::add_callback_group\n@@ -155,113 \u002B192,23 @@ public:\n   std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n   get_automatically_added_callback_groups_from_nodes() override;\n \n-  /// Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.\n\u002Bprotected:\n   /**\n-   * \\param[in] future The future to wait on. If this function returns SUCCESS, the future can be\n-   *   accessed without blocking (though it may still throw an exception).\n-   * \\param[in] timeout Optional timeout parameter, which gets passed to\n-   *    Executor::execute_ready_executables.\n-   *   \u0060-1\u0060 is block forever, \u00600\u0060 is non-blocking.\n-   *   If the time spent inside the blocking loop exceeds this timeout, return a TIMEOUT return\n-   *   code.\n-   * \\return The return code, one of \u0060SUCCESS\u0060, \u0060INTERRUPTED\u0060, or \u0060TIMEOUT\u0060.\n-   *\n-   *  Example usage:\n-   *  rclcpp::executors::StaticSingleThreadedExecutor exec;\n-   *  // ... other part of code like creating node\n-   *  // define future\n-   *  exec.add_node(node);\n-   *  exec.spin_until_future_complete(future);\n\u002B   * @brief Executes ready executables from wait set.\n\u002B   * @param spin_once if true executes only the first ready executable.\n\u002B   * @return true if any executable was ready.\n    */\n-  template\u003Ctypename FutureT, typename TimeRepT = int64_t, typename TimeT = std::milli\u003E\n-  rclcpp::FutureReturnCode\n-  spin_until_future_complete(\n-    FutureT \u0026 future,\n-    std::chrono::duration\u003CTimeRepT, TimeT\u003E timeout = std::chrono::duration\u003CTimeRepT, TimeT\u003E(-1))\n-  {\n-    std::future_status status = future.wait_for(std::chrono::seconds(0));\n-    if (status == std::future_status::ready) {\n-      return rclcpp::FutureReturnCode::SUCCESS;\n-    }\n-\n-    auto end_time = std::chrono::steady_clock::now();\n-    std::chrono::nanoseconds timeout_ns = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(\n-      timeout);\n-    if (timeout_ns \u003E std::chrono::nanoseconds::zero()) {\n-      end_time \u002B= timeout_ns;\n-    }\n-    std::chrono::nanoseconds timeout_left = timeout_ns;\n-\n-    entities_collector_-\u003Einit(\u0026wait_set_, memory_strategy_, \u0026interrupt_guard_condition_);\n-    RCLCPP_SCOPE_EXIT(entities_collector_-\u003Efini());\n-\n-    while (rclcpp::ok(this-\u003Econtext_)) {\n-      // Do one set of work.\n-      entities_collector_-\u003Erefresh_wait_set(timeout_left);\n-      execute_ready_executables();\n-      // Check if the future is set, return SUCCESS if it is.\n-      status = future.wait_for(std::chrono::seconds(0));\n-      if (status == std::future_status::ready) {\n-        return rclcpp::FutureReturnCode::SUCCESS;\n-      }\n-      // If the original timeout is \u003C 0, then this is blocking, never TIMEOUT.\n-      if (timeout_ns \u003C std::chrono::nanoseconds::zero()) {\n-        continue;\n-      }\n-      // Otherwise check if we still have time to wait, return TIMEOUT if not.\n-      auto now = std::chrono::steady_clock::now();\n-      if (now \u003E= end_time) {\n-        return rclcpp::FutureReturnCode::TIMEOUT;\n-      }\n-      // Subtract the elapsed time from the original timeout.\n-      timeout_left = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(end_time - now);\n-    }\n-\n-    // The future did not complete before ok() returned false, return INTERRUPTED.\n-    return rclcpp::FutureReturnCode::INTERRUPTED;\n-  }\n-\n-  /// Not yet implemented, see https://github.com/ros2/rclcpp/issues/1219 for tracking\n   RCLCPP_PUBLIC\n-  void\n-  spin_some(std::chrono::nanoseconds max_duration = std::chrono::nanoseconds(0)) override\n-  {\n-    (void)max_duration;\n-    throw rclcpp::exceptions::UnimplementedError(\n-            \u0022spin_some is not implemented for StaticSingleThreadedExecutor, use spin or \u0022\n-            \u0022spin_until_future_complete\u0022);\n-  }\n\u002B  bool\n\u002B  execute_ready_executables(bool spin_once = false);\n \n-  /// Not yet implemented, see https://github.com/ros2/rclcpp/issues/1219 for tracking\n   RCLCPP_PUBLIC\n   void\n-  spin_all(std::chrono::nanoseconds) override\n-  {\n-    throw rclcpp::exceptions::UnimplementedError(\n-            \u0022spin_all is not implemented for StaticSingleThreadedExecutor, use spin or \u0022\n-            \u0022spin_until_future_complete\u0022);\n-  }\n\u002B  spin_some_impl(std::chrono::nanoseconds max_duration, bool exhaustive);\n \n-  /// Not yet implemented, see https://github.com/ros2/rclcpp/issues/1219 for tracking\n-  RCLCPP_PUBLIC\n-  void\n-  spin_once(std::chrono::nanoseconds timeout = std::chrono::nanoseconds(-1)) override\n-  {\n-    (void)timeout;\n-    throw rclcpp::exceptions::UnimplementedError(\n-            \u0022spin_once is not implemented for StaticSingleThreadedExecutor, use spin or \u0022\n-            \u0022spin_until_future_complete\u0022);\n-  }\n-\n-protected:\n-  /// Check which executables in ExecutableList struct are ready from wait_set and execute them.\n-  /**\n-   * \\param[in] exec_list Structure that can hold subscriptionbases, timerbases, etc\n-   * \\param[in] timeout Optional timeout parameter.\n-   */\n   RCLCPP_PUBLIC\n   void\n-  execute_ready_executables();\n\u002B  spin_once_impl(std::chrono::nanoseconds timeout) override;\n \n private:\n   RCLCPP_DISABLE_COPY(StaticSingleThreadedExecutor)\ndiff --git rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\nindex a0f55d3d..fada15e5 100644\n--- rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\n@@ -76,9 \u002B76,13 @@ StaticExecutorEntitiesCollector::init(\n \n   // Add executor\u0027s guard condition\n   memory_strategy_-\u003Eadd_guard_condition(executor_guard_condition);\n\u002B\n   // Get memory strategy and executable list. Prepare wait_set_\n   std::shared_ptr\u003Cvoid\u003E shared_ptr;\n   execute(shared_ptr);\n\u002B\n\u002B  // The entities collector is now initialized\n\u002B  initialized_ = true;\n }\n \n void\ndiff --git rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\nindex 4b5afc30..5402d324 100644\n--- rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n@@ -14,6 \u002B14,7 @@\n \n #include \u0022rclcpp/executors/static_single_threaded_executor.hpp\u0022\n \n\u002B#include \u003Cchrono\u003E\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n \n@@ -29,7 \u002B30,12 @@ StaticSingleThreadedExecutor::StaticSingleThreadedExecutor(\n   entities_collector_ = std::make_shared\u003CStaticExecutorEntitiesCollector\u003E();\n }\n \n-StaticSingleThreadedExecutor::~StaticSingleThreadedExecutor() {}\n\u002BStaticSingleThreadedExecutor::~StaticSingleThreadedExecutor()\n\u002B{\n\u002B  if (entities_collector_-\u003Eis_init()) {\n\u002B    entities_collector_-\u003Efini();\n\u002B  }\n\u002B}\n \n void\n StaticSingleThreadedExecutor::spin()\n@@ -42,7 \u002B48,6 @@ StaticSingleThreadedExecutor::spin()\n   // Set memory_strategy_ and exec_list_ based on weak_nodes_\n   // Prepare wait_set_ based on memory_strategy_\n   entities_collector_-\u003Einit(\u0026wait_set_, memory_strategy_, \u0026interrupt_guard_condition_);\n-  RCLCPP_SCOPE_EXIT(entities_collector_-\u003Efini());\n \n   while (rclcpp::ok(this-\u003Econtext_) \u0026\u0026 spinning.load()) {\n     // Refresh wait set and wait for work\n@@ -51,6 \u002B56,79 @@ StaticSingleThreadedExecutor::spin()\n   }\n }\n \n\u002Bvoid\n\u002BStaticSingleThreadedExecutor::spin_some(std::chrono::nanoseconds max_duration)\n\u002B{\n\u002B  // In this context a 0 input max_duration means no duration limit\n\u002B  if (std::chrono::nanoseconds(0) == max_duration) {\n\u002B    max_duration = std::chrono::nanoseconds::max();\n\u002B  }\n\u002B\n\u002B  return this-\u003Espin_some_impl(max_duration, false);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BStaticSingleThreadedExecutor::spin_all(std::chrono::nanoseconds max_duration)\n\u002B{\n\u002B  if (max_duration \u003C= std::chrono::nanoseconds(0)) {\n\u002B    throw std::invalid_argument(\u0022max_duration must be positive\u0022);\n\u002B  }\n\u002B  return this-\u003Espin_some_impl(max_duration, true);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BStaticSingleThreadedExecutor::spin_some_impl(std::chrono::nanoseconds max_duration, bool exhaustive)\n\u002B{\n\u002B  // Make sure the entities collector has been initialized\n\u002B  if (!entities_collector_-\u003Eis_init()) {\n\u002B    entities_collector_-\u003Einit(\u0026wait_set_, memory_strategy_, \u0026interrupt_guard_condition_);\n\u002B  }\n\u002B\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  auto max_duration_not_elapsed = [max_duration, start]() {\n\u002B      if (std::chrono::nanoseconds(0) == max_duration) {\n\u002B        // told to spin forever if need be\n\u002B        return true;\n\u002B      } else if (std::chrono::steady_clock::now() - start \u003C max_duration) {\n\u002B        // told to spin only for some maximum amount of time\n\u002B        return true;\n\u002B      }\n\u002B      // spun too long\n\u002B      return false;\n\u002B    };\n\u002B\n\u002B  if (spinning.exchange(true)) {\n\u002B    throw std::runtime_error(\u0022spin_some() called while already spinning\u0022);\n\u002B  }\n\u002B  RCLCPP_SCOPE_EXIT(this-\u003Espinning.store(false); );\n\u002B\n\u002B  while (rclcpp::ok(context_) \u0026\u0026 spinning.load() \u0026\u0026 max_duration_not_elapsed()) {\n\u002B    // Get executables that are ready now\n\u002B    entities_collector_-\u003Erefresh_wait_set(std::chrono::milliseconds::zero());\n\u002B    // Execute ready executables\n\u002B    bool work_available = execute_ready_executables();\n\u002B    if (!work_available || !exhaustive) {\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002BStaticSingleThreadedExecutor::spin_once_impl(std::chrono::nanoseconds timeout)\n\u002B{\n\u002B  // Make sure the entities collector has been initialized\n\u002B  if (!entities_collector_-\u003Eis_init()) {\n\u002B    entities_collector_-\u003Einit(\u0026wait_set_, memory_strategy_, \u0026interrupt_guard_condition_);\n\u002B  }\n\u002B\n\u002B  if (rclcpp::ok(context_) \u0026\u0026 spinning.load()) {\n\u002B    // Wait until we have a ready entity or timeout expired\n\u002B    entities_collector_-\u003Erefresh_wait_set(timeout);\n\u002B    // Execute ready executables\n\u002B    execute_ready_executables(true);\n\u002B  }\n\u002B}\n\u002B\n void\n StaticSingleThreadedExecutor::add_callback_group(\n   rclcpp::CallbackGroup::SharedPtr group_ptr,\n@@ -138,14 \u002B216,20 @@ StaticSingleThreadedExecutor::remove_node(std::shared_ptr\u003Crclcpp::Node\u003E node_ptr\n   this-\u003Eremove_node(node_ptr-\u003Eget_node_base_interface(), notify);\n }\n \n-void\n-StaticSingleThreadedExecutor::execute_ready_executables()\n\u002Bbool\n\u002BStaticSingleThreadedExecutor::execute_ready_executables(bool spin_once)\n {\n\u002B  bool any_ready_executable = false;\n\u002B\n   // Execute all the ready subscriptions\n   for (size_t i = 0; i \u003C wait_set_.size_of_subscriptions; \u002B\u002Bi) {\n     if (i \u003C entities_collector_-\u003Eget_number_of_subscriptions()) {\n       if (wait_set_.subscriptions[i]) {\n         execute_subscription(entities_collector_-\u003Eget_subscription(i));\n\u002B        if (spin_once) {\n\u002B          return true;\n\u002B        }\n\u002B        any_ready_executable = true;\n       }\n     }\n   }\n@@ -154,6 \u002B238,10 @@ StaticSingleThreadedExecutor::execute_ready_executables()\n     if (i \u003C entities_collector_-\u003Eget_number_of_timers()) {\n       if (wait_set_.timers[i] \u0026\u0026 entities_collector_-\u003Eget_timer(i)-\u003Eis_ready()) {\n         execute_timer(entities_collector_-\u003Eget_timer(i));\n\u002B        if (spin_once) {\n\u002B          return true;\n\u002B        }\n\u002B        any_ready_executable = true;\n       }\n     }\n   }\n@@ -162,6 \u002B250,10 @@ StaticSingleThreadedExecutor::execute_ready_executables()\n     if (i \u003C entities_collector_-\u003Eget_number_of_services()) {\n       if (wait_set_.services[i]) {\n         execute_service(entities_collector_-\u003Eget_service(i));\n\u002B        if (spin_once) {\n\u002B          return true;\n\u002B        }\n\u002B        any_ready_executable = true;\n       }\n     }\n   }\n@@ -170,6 \u002B262,10 @@ StaticSingleThreadedExecutor::execute_ready_executables()\n     if (i \u003C entities_collector_-\u003Eget_number_of_clients()) {\n       if (wait_set_.clients[i]) {\n         execute_client(entities_collector_-\u003Eget_client(i));\n\u002B        if (spin_once) {\n\u002B          return true;\n\u002B        }\n\u002B        any_ready_executable = true;\n       }\n     }\n   }\n@@ -179,6 \u002B275,11 @@ StaticSingleThreadedExecutor::execute_ready_executables()\n     if (waitable-\u003Eis_ready(\u0026wait_set_)) {\n       auto data = waitable-\u003Etake_data();\n       waitable-\u003Eexecute(data);\n\u002B      if (spin_once) {\n\u002B        return true;\n\u002B      }\n\u002B      any_ready_executable = true;\n     }\n   }\n\u002B  return any_ready_executable;\n }\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 970cd3bd..1cf90d99 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -349,49 \u002B349,6 @@ TYPED_TEST(TestExecutors, testSpinUntilFutureCompleteWithTimeout) {\n   spinner.join();\n }\n \n-// Check spin_until_future_complete can be properly interrupted.\n-TYPED_TEST(TestExecutors, testSpinUntilFutureCompleteInterrupted) {\n-  using ExecutorType = TypeParam;\n-  ExecutorType executor;\n-  executor.add_node(this-\u003Enode);\n-\n-  bool spin_exited = false;\n-\n-  // This needs to block longer than it takes to get to the shutdown call below and for\n-  // spin_until_future_complete to return\n-  std::future\u003Cvoid\u003E future = std::async(\n-    std::launch::async,\n-    [\u0026spin_exited]() {\n-      auto start = std::chrono::steady_clock::now();\n-      while (!spin_exited \u0026\u0026 (std::chrono::steady_clock::now() - start) \u003C 1s) {\n-        std::this_thread::sleep_for(1ms);\n-      }\n-    });\n-\n-  // Long timeout\n-  std::thread spinner([\u0026spin_exited, \u0026executor, \u0026future]() {\n-      auto ret = executor.spin_until_future_complete(future, 1s);\n-      EXPECT_EQ(rclcpp::FutureReturnCode::INTERRUPTED, ret);\n-      spin_exited = true;\n-    });\n-\n-  // Do some minimal work\n-  this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n-  std::this_thread::sleep_for(1ms);\n-\n-  // Force interruption\n-  rclcpp::shutdown();\n-\n-  // Give it time to exit\n-  auto start = std::chrono::steady_clock::now();\n-  while (!spin_exited \u0026\u0026 (std::chrono::steady_clock::now() - start) \u003C 1s) {\n-    std::this_thread::sleep_for(1ms);\n-  }\n-\n-  EXPECT_TRUE(spin_exited);\n-  spinner.join();\n-}\n-\n class TestWaitable : public rclcpp::Waitable\n {\n public:\n@@ -422,10 \u002B379,12 @@ public:\n   add_to_wait_set(rcl_wait_set_t * wait_set) override\n   {\n     rcl_ret_t ret = rcl_wait_set_add_guard_condition(wait_set, \u0026gc_, NULL);\n-    if (RCL_RET_OK != ret) {\n-      return false;\n-    }\n-    ret = rcl_trigger_guard_condition(\u0026gc_);\n\u002B    return RCL_RET_OK == ret;\n\u002B  }\n\u002B\n\u002B  bool trigger()\n\u002B  {\n\u002B    rcl_ret_t ret = rcl_trigger_guard_condition(\u0026gc_);\n     return RCL_RET_OK == ret;\n   }\n \n@@ -447,7 \u002B406,7 @@ public:\n   {\n     (void) data;\n     count_\u002B\u002B;\n-    std::this_thread::sleep_for(1ms);\n\u002B    std::this_thread::sleep_for(3ms);\n   }\n \n   size_t\n@@ -464,7 \u002B423,7 @@ private:\n   rcl_guard_condition_t gc_;\n };\n \n-TYPED_TEST(TestExecutorsStable, spinAll) {\n\u002BTYPED_TEST(TestExecutors, spinAll) {\n   using ExecutorType = TypeParam;\n   ExecutorType executor;\n   auto waitable_interfaces = this-\u003Enode-\u003Eget_node_waitables_interface();\n@@ -488,6 \u002B447,7 @@ TYPED_TEST(TestExecutorsStable, spinAll) {\n     !spin_exited \u0026\u0026\n     (std::chrono::steady_clock::now() - start \u003C 1s))\n   {\n\u002B    my_waitable-\u003Etrigger();\n     this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n     std::this_thread::sleep_for(1ms);\n   }\n@@ -504,7 \u002B464,7 @@ TYPED_TEST(TestExecutorsStable, spinAll) {\n   spinner.join();\n }\n \n-TYPED_TEST(TestExecutorsStable, spinSome) {\n\u002BTYPED_TEST(TestExecutors, spinSome) {\n   using ExecutorType = TypeParam;\n   ExecutorType executor;\n   auto waitable_interfaces = this-\u003Enode-\u003Eget_node_waitables_interface();\n@@ -529,6 \u002B489,7 @@ TYPED_TEST(TestExecutorsStable, spinSome) {\n     !spin_exited \u0026\u0026\n     (std::chrono::steady_clock::now() - start \u003C 1s))\n   {\n\u002B    my_waitable-\u003Etrigger();\n     this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n     std::this_thread::sleep_for(1ms);\n   }\n@@ -543,7 \u002B504,7 @@ TYPED_TEST(TestExecutorsStable, spinSome) {\n }\n \n // Check spin_node_until_future_complete with node base pointer\n-TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodeBasePtr) {\n\u002BTYPED_TEST(TestExecutors, testSpinNodeUntilFutureCompleteNodeBasePtr) {\n   using ExecutorType = TypeParam;\n   ExecutorType executor;\n \n@@ -558,7 \u002B519,7 @@ TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodeBasePtr) {\n }\n \n // Check spin_node_until_future_complete with node pointer\n-TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodePtr) {\n\u002BTYPED_TEST(TestExecutors, testSpinNodeUntilFutureCompleteNodePtr) {\n   using ExecutorType = TypeParam;\n   ExecutorType executor;\n \n@@ -572,6 \u002B533,49 @@ TYPED_TEST(TestExecutorsStable, testSpinNodeUntilFutureCompleteNodePtr) {\n   EXPECT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);\n }\n \n\u002B// Check spin_until_future_complete can be properly interrupted.\n\u002BTYPED_TEST(TestExecutors, testSpinUntilFutureCompleteInterrupted) {\n\u002B  using ExecutorType = TypeParam;\n\u002B  ExecutorType executor;\n\u002B  executor.add_node(this-\u003Enode);\n\u002B\n\u002B  bool spin_exited = false;\n\u002B\n\u002B  // This needs to block longer than it takes to get to the shutdown call below and for\n\u002B  // spin_until_future_complete to return\n\u002B  std::future\u003Cvoid\u003E future = std::async(\n\u002B    std::launch::async,\n\u002B    [\u0026spin_exited]() {\n\u002B      auto start = std::chrono::steady_clock::now();\n\u002B      while (!spin_exited \u0026\u0026 (std::chrono::steady_clock::now() - start) \u003C 1s) {\n\u002B        std::this_thread::sleep_for(1ms);\n\u002B      }\n\u002B    });\n\u002B\n\u002B  // Long timeout\n\u002B  std::thread spinner([\u0026spin_exited, \u0026executor, \u0026future]() {\n\u002B      auto ret = executor.spin_until_future_complete(future, 1s);\n\u002B      EXPECT_EQ(rclcpp::FutureReturnCode::INTERRUPTED, ret);\n\u002B      spin_exited = true;\n\u002B    });\n\u002B\n\u002B  // Do some minimal work\n\u002B  this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B  std::this_thread::sleep_for(1ms);\n\u002B\n\u002B  // Force interruption\n\u002B  rclcpp::shutdown();\n\u002B\n\u002B  // Give it time to exit\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  while (!spin_exited \u0026\u0026 (std::chrono::steady_clock::now() - start) \u003C 1s) {\n\u002B    std::this_thread::sleep_for(1ms);\n\u002B  }\n\u002B\n\u002B  EXPECT_TRUE(spin_exited);\n\u002B  spinner.join();\n\u002B}\n\u002B\n // Check spin_until_future_complete with node base pointer (instantiates its own executor)\n TEST(TestExecutors, testSpinUntilFutureCompleteNodeBasePtr) {\n   rclcpp::init(0, nullptr);\ndiff --git rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\nindex cd47396f..5ca6c1c2 100644\n--- rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\n@@ -45,16 \u002B45,6 @@ public:\n   }\n };\n \n-TEST_F(TestStaticSingleThreadedExecutor, check_unimplemented) {\n-  rclcpp::executors::StaticSingleThreadedExecutor executor;\n-  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n-  executor.add_node(node);\n-\n-  EXPECT_THROW(executor.spin_some(), rclcpp::exceptions::UnimplementedError);\n-  EXPECT_THROW(executor.spin_all(0ns), rclcpp::exceptions::UnimplementedError);\n-  EXPECT_THROW(executor.spin_once(0ns), rclcpp::exceptions::UnimplementedError);\n-}\n-\n TEST_F(TestStaticSingleThreadedExecutor, add_callback_group_trigger_guard_failed) {\n   rclcpp::executors::StaticSingleThreadedExecutor executor;\n   auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_python",
    "SHA": "acf97aa58a1d04280e90b87a72fc245d98a1cef9",
    "RawMessage": "Remove python_cmake_module and set hints (#204)",
    "Changes": "diff --git rosidl_generator_py/CMakeLists.txt rosidl_generator_py/CMakeLists.txt\nindex 07d124a..1f08646 100644\n--- rosidl_generator_py/CMakeLists.txt\n\u002B\u002B\u002B rosidl_generator_py/CMakeLists.txt\n@@ -22,9 \u002B22,6 @@ if(BUILD_TESTING)\n \n   find_package(test_interface_files REQUIRED)\n \n-  find_package(python_cmake_module REQUIRED)\n-  find_package(PythonExtra MODULE REQUIRED)\n-\n   include(cmake/register_py.cmake)\n   include(cmake/rosidl_generator_py_get_typesupports.cmake)\n \ndiff --git rosidl_generator_py/cmake/rosidl_generator_py_generate_interfaces.cmake rosidl_generator_py/cmake/rosidl_generator_py_generate_interfaces.cmake\nindex cfc424a..7db181b 100644\n--- rosidl_generator_py/cmake/rosidl_generator_py_generate_interfaces.cmake\n\u002B\u002B\u002B rosidl_generator_py/cmake/rosidl_generator_py_generate_interfaces.cmake\n@@ -12,13 \u002B12,27 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-find_package(python_cmake_module REQUIRED)\n-find_package(PythonExtra REQUIRED)\n find_package(rmw REQUIRED)\n find_package(rosidl_runtime_c REQUIRED)\n find_package(rosidl_typesupport_c REQUIRED)\n find_package(rosidl_typesupport_interface REQUIRED)\n \n\u002B# By default, without the settings below, find_package(Python3) will attempt\n\u002B# to find the newest python version it can, and additionally will find the\n\u002B# most specific version.  For instance, on a system that has\n\u002B# /usr/bin/python3.10, /usr/bin/python3.11, and /usr/bin/python3, it will find\n\u002B# /usr/bin/python3.11, even if /usr/bin/python3 points to /usr/bin/python3.10.\n\u002B# The behavior we want is to prefer the \u0022system\u0022 installed version unless the\n\u002B# user specifically tells us othewise through the Python3_EXECUTABLE hint.\n\u002B# Setting CMP0094 to NEW means that the search will stop after the first\n\u002B# python version is found.  Setting Python3_FIND_UNVERSIONED_NAMES means that\n\u002B# the search will prefer /usr/bin/python3 over /usr/bin/python3.11.  And that\n\u002B# latter functionality is only available in CMake 3.20 or later, so we need\n\u002B# at least that version.\n\u002Bcmake_minimum_required(VERSION 3.20)\n\u002Bcmake_policy(SET CMP0094 NEW)\n\u002Bset(Python3_FIND_UNVERSIONED_NAMES FIRST)\n\u002B\n find_package(Python3 REQUIRED COMPONENTS Interpreter Development NumPy)\n \n # Get a list of typesupport implementations from valid rmw implementations.\n@@ -184,7 \u002B198,9 @@ foreach(_typesupport_impl ${_typesupport_impls})\n     ${rosidl_generate_interfaces_TARGET}__rosidl_typesupport_c\n   )\n \n-  set_target_properties(${_target_name} PROPERTIES DEBUG_POSTFIX \u0022${PythonExtra_POSTFIX}\u0022)\n\u002B  if(WIN32 AND CMAKE_BUILD_TYPE STREQUAL \u0022Debug\u0022)\n\u002B    set_target_properties(${_target_name} PROPERTIES DEBUG_POSTFIX \u0022_d\u0022)\n\u002B  endif()\n   # target_compile_options(${_target_name} PRIVATE ${_extension_compile_flags})\n   # TODO(sloretz) use target_compile_options when python extension passes -Wpedantic\n   set_target_properties(${_target_name} PROPERTIES COMPILE_OPTIONS \u0022${_extension_compile_flags}\u0022)\ndiff --git rosidl_generator_py/package.xml rosidl_generator_py/package.xml\nindex 3aab7c2..f0454fd 100644\n--- rosidl_generator_py/package.xml\n\u002B\u002B\u002B rosidl_generator_py/package.xml\n@@ -23,7 \u002B23,6 @@\n \n   \u003Cbuildtool_export_depend\u003Eament_cmake\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Eament_index_python\u003C/buildtool_export_depend\u003E\n-  \u003Cbuildtool_export_depend\u003Epython_cmake_module\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_generator_c\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_pycommon\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_typesupport_c\u003C/buildtool_export_depend\u003E\n@@ -53,7 \u002B52,6 @@\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Epython3-numpy\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Epython3-pytest\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Epython_cmake_module\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Ermw\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Erosidl_cmake\u003C/test_depend\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "4532ef69ebe36be9aa6bfc1ed067f90a3267c12a",
    "RawMessage": "Fix the order of destructors (#572)",
    "Changes": "diff --git rviz_common/include/rviz_common/message_filter_display.hpp rviz_common/include/rviz_common/message_filter_display.hpp\nindex 29db6638..bbb79efa 100644\n--- rviz_common/include/rviz_common/message_filter_display.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/message_filter_display.hpp\n@@ -151,8 \u002B151,8 @@ protected:\n \n   virtual void unsubscribe()\n   {\n-    subscription_.reset();\n     tf_filter_.reset();\n\u002B    subscription_.reset();\n   }\n \n   void onEnable() override\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "4d8478c399d6314ae8e31120a62dc3655d3831b8",
    "RawMessage": "Improve rcl init test coverage.",
    "Changes": "diff --git rcl/test/rcl/test_init.cpp rcl/test/rcl/test_init.cpp\nindex da638f1..0ec5df3 100644\n--- rcl/test/rcl/test_init.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_init.cpp\n@@ -14,12 \u002B14,14 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n-#include \u0022rcl/rcl.h\u0022\n-\n #include \u0022./failing_allocator_functions.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/memory_tools/memory_tools.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n\u002B#include \u0022rcl/arguments.h\u0022\n #include \u0022rcl/error_handling.h\u0022\n\u002B#include \u0022rcl/rcl.h\u0022\n\u002B#include \u0022rcl/security.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/format_string.h\u0022\n #include \u0022rcutils/snprintf.h\u0022\n \n@@ -98,65 \u002B100,147 @@ private:\n   FakeTestArgv(const FakeTestArgv \u0026) = delete;\n };\n \n-/* Tests the rcl_init() and rcl_shutdown() functions.\n\u002B/* Tests rcl_init_options_init() and rcl_init_options_fini() functions.\n  */\n-TEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_and_shutdown) {\n-  rcl_ret_t ret;\n\u002BTEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_options_init) {\n   rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n-  ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n\u002B  rcl_ret_t ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n-  rcl_context_t context = rcl_get_zero_initialized_context();\n-  // A shutdown before any init has been called should fail.\n-  ret = rcl_shutdown(\u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n   // Already init\n   ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n   EXPECT_EQ(RCL_RET_ALREADY_INIT, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n-  // If argc is not 0, but argv is, it should be an invalid argument.\n-  ret = rcl_init(42, nullptr, \u0026init_options, \u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n-  // If argc is not 0, argv is not null but contains one, it should be an invalid argument.\n-  const char * invalid_args[] = {\u0022some-arg\u0022, nullptr};\n-  ret = rcl_init(2, invalid_args, \u0026init_options, \u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n-  // If argc is less than 1, argv is not null, it should be an invalid argument.\n-  ret = rcl_init(0, invalid_args, \u0026init_options, \u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n-  // If either the allocate or deallocate function pointers are not set, it should be invalid arg.\n-  init_options.impl-\u003Eallocator.allocate = nullptr;\n-  ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n-  init_options.impl-\u003Eallocator.allocate = rcl_get_default_allocator().allocate;\n-  init_options.impl-\u003Eallocator.deallocate = nullptr;\n-  ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n-  rcl_reset_error();\n-  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n-  // If the malloc call fails (with some valid arguments to copy), it should be a bad alloc.\n\u002B}\n\u002B\n\u002B/* Tests calling rcl_init() with invalid arguments fails.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_invalid_arguments) {\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_ret_t ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  {\n\u002B    // If argc is not 0, but argv is, it should be an invalid argument.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    ret = rcl_init(42, nullptr, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n   {\n\u002B    // If argc is not 0, argv is not null but contains one, it should be an invalid argument.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    const char * null_args[] = {\u0022some-arg\u0022, nullptr};\n\u002B    ret = rcl_init(2, null_args, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If argc is less than 1, argv is not null, it should be an invalid argument.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    const char * some_args[] = {\u0022some-arg\u0022};\n\u002B    ret = rcl_init(0, some_args, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If an invalid ROS arg is given, init should fail.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    const char * bad_remap_args[] = {\n\u002B      \u0022some-arg\u0022, RCL_ROS_ARGS_FLAG, RCL_REMAP_FLAG, \u0022name:=\u0022};\n\u002B    const size_t argc = sizeof(bad_remap_args) / sizeof(const char *);\n\u002B    ret = rcl_init(argc, bad_remap_args, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ROS_ARGS, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If an invalid enclave is given, init should fail.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    const char * bad_enclave_args[] = {\n\u002B      \u0022some-arg\u0022, RCL_ROS_ARGS_FLAG, RCL_ENCLAVE_FLAG, \u00221foo\u0022};\n\u002B    const size_t argc = sizeof(bad_enclave_args) / sizeof(const char *);\n\u002B    ret = rcl_init(argc, bad_enclave_args, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If security keystore is invalid, init should fail.\n\u002B    ASSERT_TRUE(rcutils_set_env(ROS_SECURITY_ENABLE_VAR_NAME, \u0022true\u0022));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B      EXPECT_TRUE(rcutils_set_env(ROS_SECURITY_ENABLE_VAR_NAME, \u0022\u0022));\n\u002B    });\n\u002B    ASSERT_TRUE(rcutils_set_env(ROS_SECURITY_STRATEGY_VAR_NAME, \u0022Enforce\u0022));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B      EXPECT_TRUE(rcutils_set_env(ROS_SECURITY_STRATEGY_VAR_NAME, \u0022\u0022));\n\u002B    });\n\u002B    ASSERT_TRUE(rcutils_set_env(ROS_SECURITY_KEYSTORE_VAR_NAME, \u0022/not/a/real/secure/root\u0022));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B      EXPECT_TRUE(rcutils_set_env(ROS_SECURITY_KEYSTORE_VAR_NAME, \u0022\u0022));\n\u002B    });\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If either the allocate or deallocate function pointers are not set,\n\u002B    // it should be invalid arg.\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B    init_options.impl-\u003Eallocator.allocate = nullptr;\n\u002B    ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B    init_options.impl-\u003Eallocator.allocate = rcl_get_default_allocator().allocate;\n\u002B    init_options.impl-\u003Eallocator.deallocate = nullptr;\n\u002B    ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B    rcl_reset_error();\n\u002B    ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B  {\n\u002B    // If the malloc call fails (with some valid arguments to copy),\n\u002B    // it should be a bad alloc.\n     FakeTestArgv test_args;\n     rcl_allocator_t failing_allocator = rcl_get_default_allocator();\n     failing_allocator.allocate = failing_malloc;\n     failing_allocator.reallocate = failing_realloc;\n     failing_allocator.zero_allocate = failing_calloc;\n     init_options.impl-\u003Eallocator = failing_allocator;\n\u002B    rcl_context_t context = rcl_get_zero_initialized_context();\n     ret = rcl_init(test_args.argc, test_args.argv, \u0026init_options, \u0026context);\n     EXPECT_EQ(RCL_RET_BAD_ALLOC, ret);\n     rcl_reset_error();\n     ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n   }\n-  init_options.impl-\u003Eallocator = rcl_get_default_allocator();\n\u002B}\n\u002B\n\u002B/* Tests the rcl_init() and rcl_shutdown() functions.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_and_shutdown) {\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_ret_t ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT({\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B  // A shutdown before an init should fail.\n\u002B  ret = rcl_shutdown(\u0026context);\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n\u002B  rcl_reset_error();\n\u002B  ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n   // If argc is 0 and argv is nullptr and the allocator is valid, it should succeed.\n   ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n   EXPECT_EQ(RCL_RET_OK, ret);\n@@ -210,10 \u002B294,6 @@ TEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_and_shutdown\n   ret = rcl_context_fini(\u0026context);\n   EXPECT_EQ(ret, RCL_RET_OK);\n   context = rcl_get_zero_initialized_context();\n-  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-  {\n-    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n-  });\n }\n \n /* Tests the rcl_get_instance_id() function.\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "fa7d9eea89b813b7580e52c3d3501b270d767843",
    "RawMessage": "Change maintainer",
    "Changes": "diff --git demo_nodes_cpp_native_gurumdds/package.xml demo_nodes_cpp_native_gurumdds/package.xml\nindex 16a06dd..0877db8 100644\n--- demo_nodes_cpp_native_gurumdds/package.xml\n\u002B\u002B\u002B demo_nodes_cpp_native_gurumdds/package.xml\n@@ -4,7 \u002B4,7 @@\n   \u003Cname\u003Edemo_nodes_cpp_native_gurumdds\u003C/name\u003E\n   \u003Cversion\u003E1.0.0\u003C/version\u003E\n   \u003Cdescription\u003EC\u002B\u002B nodes which access the native handles of the rmw implemenation.\u003C/description\u003E\n-  \u003Cmaintainer email=\u0022junho@gurum.cc\u0022\u003EJunho Lee\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022youngjin@gurum.cc\u0022\u003EYoungjin Yun\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\ndiff --git rmw_gurumdds_cpp/package.xml rmw_gurumdds_cpp/package.xml\nindex 46312ba..600e3ab 100644\n--- rmw_gurumdds_cpp/package.xml\n\u002B\u002B\u002B rmw_gurumdds_cpp/package.xml\n@@ -4,7 \u002B4,7 @@\n   \u003Cname\u003Ermw_gurumdds_cpp\u003C/name\u003E\n   \u003Cversion\u003E2.0.1\u003C/version\u003E\n   \u003Cdescription\u003EImplement the ROS middleware interface using GurumNetworks GurumDDS static code generation in C\u002B\u002B.\u003C/description\u003E\n-  \u003Cmaintainer email=\u0022junho@gurum.cc\u0022\u003EJunho Lee\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022youngjin@gurum.cc\u0022\u003EYoungjin Yun\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\ndiff --git rmw_gurumdds_shared_cpp/package.xml rmw_gurumdds_shared_cpp/package.xml\nindex 659211c..297e15a 100644\n--- rmw_gurumdds_shared_cpp/package.xml\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/package.xml\n@@ -4,7 \u002B4,7 @@\n   \u003Cname\u003Ermw_gurumdds_shared_cpp\u003C/name\u003E\n   \u003Cversion\u003E2.0.1\u003C/version\u003E\n   \u003Cdescription\u003ECode shared on static and dynamic type support of rmw_gurumdds_cpp.\u003C/description\u003E\n-  \u003Cmaintainer email=\u0022junho@gurum.cc\u0022\u003EJunho Lee\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022youngjin@gurum.cc\u0022\u003EYoungjin Yun\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\ndiff --git rmw_gurumdds_static_cpp/package.xml rmw_gurumdds_static_cpp/package.xml\nindex 25c39f4..8e80243 100644\n--- rmw_gurumdds_static_cpp/package.xml\n\u002B\u002B\u002B rmw_gurumdds_static_cpp/package.xml\n@@ -4,7 \u002B4,7 @@\n   \u003Cname\u003Ermw_gurumdds_static_cpp\u003C/name\u003E\n   \u003Cversion\u003E1.0.0\u003C/version\u003E\n   \u003Cdescription\u003EImplement the ROS middleware interface using GurumNetworks GurumDDS static code generation in C\u002B\u002B.\u003C/description\u003E\n-  \u003Cmaintainer email=\u0022junho@gurum.cc\u0022\u003EJunho Lee\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022youngjin@gurum.cc\u0022\u003EYoungjin Yun\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "707ac2f69636eda7a31b9a17ab38b0e603e0d8e8",
    "RawMessage": "add mingw support (#370)",
    "Changes": "diff --git rmw/include/rmw/types.h rmw/include/rmw/types.h\nindex 6a59ae8..30c9b44 100644\n--- rmw/include/rmw/types.h\n\u002B\u002B\u002B rmw/include/rmw/types.h\n@@ -459,7 \u002B459,7 @@ typedef enum RMW_PUBLIC_TYPE rmw_qos_durability_policy_e\n   \u0022RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. \u0022 \\\n   \u0022Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.\u0022\n \n-#ifndef _WIN32\n\u002B#ifndef _MSC_VER\n # define RMW_DECLARE_DEPRECATED(name, msg) name __attribute__((deprecated(msg)))\n #else\n # define RMW_DECLARE_DEPRECATED(name, msg) name __pragma(deprecated(name))\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "27b698421e6a3c935163c3875d8e9c4a724b62d0",
    "RawMessage": "added python3-yaml (#1242)",
    "Changes": "diff --git rclpy/package.xml rclpy/package.xml\nindex 80069b7..65469a8 100644\n--- rclpy/package.xml\n\u002B\u002B\u002B rclpy/package.xml\n@@ -38,6 \u002B38,7 @@\n   \u003Cexec_depend\u003Eaction_msgs\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Eament_index_python\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Ebuiltin_interfaces\u003C/exec_depend\u003E\n\u002B  \u003Cexec_depend\u003Epython3-yaml\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Erosgraph_msgs\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Erpyutils\u003C/exec_depend\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "launch_ros",
    "SHA": "85e5f78b0b12d9c240d0eca052453d2d067c041c",
    "RawMessage": "Add LifecyleTransition action (#317)",
    "Changes": "diff --git launch_ros/launch_ros/actions/__init__.py launch_ros/launch_ros/actions/__init__.py\nindex b7e78fa..3ab836d 100644\n--- launch_ros/launch_ros/actions/__init__.py\n\u002B\u002B\u002B launch_ros/launch_ros/actions/__init__.py\n@@ -16,6 \u002B16,7 @@\n \n from .composable_node_container import ComposableNodeContainer\n from .lifecycle_node import LifecycleNode\n\u002Bfrom .lifecycle_transition import LifecycleTransition\n from .load_composable_nodes import LoadComposableNodes\n from .node import Node\n from .push_ros_namespace import PushROSNamespace\n@@ -32,6 \u002B33,7 @@ from .set_use_sim_time import SetUseSimTime\n __all__ = [\n     \u0027ComposableNodeContainer\u0027,\n     \u0027LifecycleNode\u0027,\n\u002B    \u0027LifecycleTransition\u0027,\n     \u0027LoadComposableNodes\u0027,\n     \u0027Node\u0027,\n     \u0027PushROSNamespace\u0027,\ndiff --git launch_ros/launch_ros/actions/lifecycle_transition.py launch_ros/launch_ros/actions/lifecycle_transition.py\nnew file mode 100644\nindex 0000000..ed54870\n--- /dev/null\n\u002B\u002B\u002B launch_ros/launch_ros/actions/lifecycle_transition.py\n@@ -0,0 \u002B1,245 @@\n\u002B# Copyright 2022 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport functools\n\u002B\n\u002Bfrom typing import Iterable\n\u002Bfrom typing import List\n\u002Bfrom typing import Optional\n\u002Bfrom typing import Union\n\u002B\n\u002B\n\u002Bimport launch\n\u002Bfrom launch import LaunchContext, SomeSubstitutionsType\n\u002Bfrom launch.action import Action\n\u002Bfrom launch.actions import EmitEvent, RegisterEventHandler\n\u002Bfrom launch.utilities import normalize_to_list_of_substitutions\n\u002Bfrom launch.utilities import perform_substitutions\n\u002B\n\u002Bfrom launch_ros.event_handlers import OnStateTransition\n\u002Bfrom launch_ros.events.lifecycle import ChangeState, StateTransition\n\u002Bfrom launch_ros.events.matchers import matches_node_name\n\u002Bfrom lifecycle_msgs.msg import Transition\n\u002B\n\u002B\n\u002Bclass LifecycleTransition(Action):\n\u002B    \u0022\u0022\u0022An action that simplifies execution of lifecyle transitions.\u0022\u0022\u0022\n\u002B\n\u002B    transition_targets = {\n\u002B        Transition.TRANSITION_CONFIGURE:\n\u002B            {\u0027start_state\u0027: \u0027configuring\u0027, \u0027goal_state\u0027: \u0027inactive\u0027},\n\u002B        Transition.TRANSITION_CLEANUP:\n\u002B            {\u0027start_state\u0027: \u0027cleaningup\u0027, \u0027goal_state\u0027: \u0027unconfigured\u0027},\n\u002B        Transition.TRANSITION_ACTIVATE:\n\u002B            {\u0027start_state\u0027: \u0027activating\u0027, \u0027goal_state\u0027: \u0027active\u0027},\n\u002B        Transition.TRANSITION_DEACTIVATE:\n\u002B            {\u0027start_state\u0027: \u0027deactivating\u0027, \u0027goal_state\u0027: \u0027inactive\u0027},\n\u002B        Transition.TRANSITION_UNCONFIGURED_SHUTDOWN:\n\u002B            {\u0027start_state\u0027: \u0027shuttingdown\u0027, \u0027goal_state\u0027: \u0027finalized\u0027},\n\u002B        Transition.TRANSITION_INACTIVE_SHUTDOWN:\n\u002B            {\u0027start_state\u0027: \u0027shuttingdown\u0027, \u0027goal_state\u0027: \u0027finalized\u0027},\n\u002B        Transition.TRANSITION_ACTIVE_SHUTDOWN:\n\u002B            {\u0027start_state\u0027: \u0027shuttingdown\u0027, \u0027goal_state\u0027: \u0027finalized\u0027},\n\u002B    }\n\u002B\n\u002B    def __init__(\n\u002B        self,\n\u002B        *,\n\u002B        lifecycle_node_names: Iterable[SomeSubstitutionsType],\n\u002B        transition_ids: Iterable[Union[int, SomeSubstitutionsType]],\n\u002B        **kwargs\n\u002B    ) -\u003E None:\n\u002B        \u0022\u0022\u0022\n\u002B        Construct a LifecycleTransition action.\n\u002B\n\u002B        The action will execute the passed in lifecycle transition for the\n\u002B        lifecycle nodes with the indicated node names. The action will emit\n\u002B        an event that triggers the first lifecycle transition of each node\n\u002B        wait that the node reaches the transition goal and trigger the next\n\u002B        transition in the list.\n\u002B        You need to make sure, that the sequence of lifecyle transition you\n\u002B        pass in is possible.\n\u002B\n\u002B        :param lifecycle_node_names: The names of the lifecycle nodes to transition\n\u002B        :param transitions_ids: The transitions to be executed.\n\u002B        \u0022\u0022\u0022\n\u002B        super().__init__(**kwargs)\n\u002B        if len(transition_ids) == 0:\n\u002B            raise ValueError(\u0027No transition_ids provided.\u0027)\n\u002B\n\u002B        if len(lifecycle_node_names) == 0:\n\u002B            raise ValueError(\u0027No lifecycle_node_names provided.\u0027)\n\u002B\n\u002B        self.__lifecycle_node_names = [\n\u002B            normalize_to_list_of_substitutions(name)\n\u002B            for name in lifecycle_node_names]\n\u002B        transition_ids = [\n\u002B            str(transition_id)\n\u002B            if isinstance(transition_id, int) else transition_id\n\u002B            for transition_id in transition_ids]\n\u002B        self.__transition_ids = [\n\u002B            normalize_to_list_of_substitutions(transition_id)\n\u002B            for transition_id in transition_ids]\n\u002B\n\u002B        self.__event_handlers = {}\n\u002B        self.__logger = launch.logging.get_logger(__name__)\n\u002B\n\u002B    def _remove_event_handlers(\n\u002B            self,\n\u002B            context: LaunchContext,\n\u002B            node_name: str,\n\u002B            reason: str = None):\n\u002B        \u0022\u0022\u0022Remove all consequent transitions if error occurs.\u0022\u0022\u0022\n\u002B        if reason is not None:\n\u002B            self.__logger.info(\n\u002B                f\u0022Stopping transitions for {node_name} because \u0027{reason}\u0027\u0022)\n\u002B\n\u002B        for event_handler in self.__event_handlers[node_name]:\n\u002B            # Unregister event handlers and ignore failures, as these are\n\u002B            # already unregistered event handlers.\n\u002B            try:\n\u002B                context.unregister_event_handler(event_handler=event_handler)\n\u002B            except ValueError:\n\u002B                pass\n\u002B\n\u002B    def execute(\n\u002B        self,\n\u002B        context: launch.LaunchContext\n\u002B    ) -\u003E Optional[List[Action]]:\n\u002B        \u0022\u0022\u0022\n\u002B        Execute the LifecycleTransition action.\n\u002B\n\u002B        :return Returns a list of actions to be executed to achieve specified transitions.\n\u002B          These are EventHandlers and EventEmitters for ChangeState and\n\u002B          StateTransition events of the nodes indicated.\n\u002B        \u0022\u0022\u0022\n\u002B        lifecycle_node_names = [\n\u002B            perform_substitutions(context, name)\n\u002B            for name in self.__lifecycle_node_names]\n\u002B        subs_transition_ids = [\n\u002B            perform_substitutions(context, id_)\n\u002B            for id_ in self.__transition_ids]\n\u002B        transition_ids = []\n\u002B        for tid in subs_transition_ids:\n\u002B            try:\n\u002B                transition_ids.append(int(tid))\n\u002B            except ValueError:\n\u002B                raise ValueError(\n\u002B                    f\u0027expected integer for lifecycle transition, got {tid}\u0027)\n\u002B\n\u002B        emit_actions = {}\n\u002B        actions: List[Action] = []\n\u002B\n\u002B        # Create EmitEvents for ChangeStates and store\n\u002B        for name in lifecycle_node_names:\n\u002B            own_emit_actions = []\n\u002B            for tid in transition_ids:\n\u002B                change_event = ChangeState(\n\u002B                    lifecycle_node_matcher=matches_node_name(name),\n\u002B                    transition_id=tid)\n\u002B                emit_action = EmitEvent(\n\u002B                    event=change_event\n\u002B                )\n\u002B                own_emit_actions.append(emit_action)\n\u002B            emit_actions[name] = own_emit_actions\n\u002B            self.__event_handlers[name] = []\n\u002B        # Create Transition EventHandlers and Registration actions\n\u002B        i = 1\n\u002B        for tid in transition_ids:\n\u002B            # Create Transition handler for all indicated nodes\n\u002B            for node_name in lifecycle_node_names:\n\u002B\n\u002B                states = self.transition_targets[tid]\n\u002B                event_handler = None\n\u002B                # For all transitions except the last, emit next ChangeState Event\n\u002B                if i \u003C len(transition_ids):\n\u002B                    event_handler = OnStateTransition(\n\u002B                        matcher=match_node_name_start_goal(\n\u002B                            node_name,\n\u002B                            states[\u0027start_state\u0027],\n\u002B                            states[\u0027goal_state\u0027]),\n\u002B                        entities=[\n\u002B                            emit_actions[node_name][i]],\n\u002B                        handle_once=True\n\u002B                    )\n\u002B                # For last transition emit Log message and remove untriggered error handlers\n\u002B                else:\n\u002B                    event_handler = OnStateTransition(\n\u002B                        matcher=match_node_name_start_goal(\n\u002B                            node_name,\n\u002B                            states[\u0027start_state\u0027],\n\u002B                            states[\u0027goal_state\u0027]),\n\u002B                        entities=[\n\u002B                            launch.actions.OpaqueFunction(\n\u002B                                function=functools.partial(\n\u002B                                    self._remove_event_handlers,\n\u002B                                    node_name=node_name\n\u002B                                )\n\u002B                            ),\n\u002B                        ],\n\u002B                        handle_once=True\n\u002B                    )\n\u002B                self.__event_handlers[node_name].append(event_handler)\n\u002B                # Create register event handler action\n\u002B                register_action = RegisterEventHandler(\n\u002B                    event_handler=event_handler)\n\u002B                # Append to actions\n\u002B                actions.append(register_action)\n\u002B            # increment next ChangeState action by one\n\u002B            i \u002B= 1\n\u002B        # Create Error processing event handlers.\n\u002B        for node_name in lifecycle_node_names:\n\u002B            event_handler = \\\n\u002B                launch.EventHandler(\n\u002B                    matcher=match_node_name_goal(node_name, \u0027errorprocessing\u0027),\n\u002B                    entities=[\n\u002B                        launch.actions.OpaqueFunction(\n\u002B                            function=functools.partial(\n\u002B                                self._remove_event_handlers,\n\u002B                                node_name=node_name,\n\u002B                                reason=\u0027error occured during transitions\u0027\n\u002B                            )\n\u002B                        )\n\u002B                    ],\n\u002B                    handle_once=True,\n\u002B                )\n\u002B            self.__event_handlers[node_name].append(event_handler)\n\u002B            context.register_event_handler(event_handler=event_handler)\n\u002B\n\u002B        # Add first Emit actions to actions\n\u002B        for node_name in lifecycle_node_names:\n\u002B            actions.append(emit_actions[node_name][0])\n\u002B\n\u002B        return actions\n\u002B\n\u002B\n\u002Bdef match_node_name_start_goal(node_name: str, start_state: str, goal_state: str):\n\u002B    if not node_name.startswith(\u0027/\u0027):\n\u002B        node_name = f\u0027/{node_name}\u0027\n\u002B    return lambda event: (\n\u002B        isinstance(event, StateTransition) and\n\u002B        (event.action.node_name == node_name) and\n\u002B        (event.goal_state == goal_state) and\n\u002B        (event.start_state == start_state)\n\u002B    )\n\u002B\n\u002B\n\u002Bdef match_node_name_goal(node_name: str, goal_state: str):\n\u002B    if not node_name.startswith(\u0027/\u0027):\n\u002B        node_name = f\u0027/{node_name}\u0027\n\u002B    return lambda event: (\n\u002B        isinstance(event, StateTransition) and\n\u002B        (event.action.node_name == node_name) and\n\u002B        (event.goal_state == goal_state)\n\u002B    )\ndiff --git test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\nindex 319734a..95e317c 100644\n--- test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\n\u002B\u002B\u002B test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\n@@ -123,8 \u002B123,8 @@ def test_composable_node_container_in_group_with_launch_configuration_in_descrip\n \n def test_composable_node_container_if_condition():\n     \u0022\u0022\u0022Nominal test for launching a ComposableNodeContainer.\u0022\u0022\u0022\n-    TEST_NODE_NAME_1 = \u0027test_component_container_node_name_1\u0027\n-    TEST_NODE_NAME_2 = \u0027test_component_container_node_name_2\u0027\n\u002B    test_node_name_1 = \u0027test_component_container_node_name_1\u0027\n\u002B    test_node_name_2 = \u0027test_component_container_node_name_2\u0027\n     actions = [\n         DeclareLaunchArgument(name=\u0027flag\u0027, default_value=\u0027False\u0027),\n         ComposableNodeContainer(\n@@ -160,14 \u002B160,14 @@ def test_composable_node_container_if_condition():\n                 ComposableNode(\n                     package=\u0027composition\u0027,\n                     plugin=\u0027composition::Listener\u0027,\n-                    name=TEST_NODE_NAME_1,\n\u002B                    name=test_node_name_1,\n                     namespace=TEST_NODE_NAMESPACE,\n                     condition=UnlessCondition(LaunchConfiguration(\u0027flag\u0027))\n                 ),\n                 ComposableNode(\n                     package=\u0027composition\u0027,\n                     plugin=\u0027composition::Listener\u0027,\n-                    name=TEST_NODE_NAME_2,\n\u002B                    name=test_node_name_2,\n                     namespace=TEST_NODE_NAMESPACE,\n                     condition=IfCondition(LaunchConfiguration(\u0027flag\u0027))\n                 )\n@@ -179,5 \u002B179,5 @@ def test_composable_node_container_if_condition():\n     context = _assert_launch_no_errors(actions)\n \n     assert get_node_name_count(context, f\u0027/{TEST_CONTAINER_NAMESPACE}/{TEST_CONTAINER_NAME}\u0027) == 1\n-    assert get_node_name_count(context, f\u0027/{TEST_NODE_NAMESPACE}/{TEST_NODE_NAME_1}\u0027) == 1\n-    assert get_node_name_count(context, f\u0027/{TEST_NODE_NAMESPACE}/{TEST_NODE_NAME_2}\u0027) == 0\n\u002B    assert get_node_name_count(context, f\u0027/{TEST_NODE_NAMESPACE}/{test_node_name_1}\u0027) == 1\n\u002B    assert get_node_name_count(context, f\u0027/{TEST_NODE_NAMESPACE}/{test_node_name_2}\u0027) == 0\ndiff --git test_launch_ros/test/test_launch_ros/actions/test_lifecycle_transition.py test_launch_ros/test/test_launch_ros/actions/test_lifecycle_transition.py\nnew file mode 100644\nindex 0000000..c96a5cd\n--- /dev/null\n\u002B\u002B\u002B test_launch_ros/test/test_launch_ros/actions/test_lifecycle_transition.py\n@@ -0,0 \u002B1,61 @@\n\u002B# Copyright 2022 Christoph Hellmann Santos\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002B\u0022\u0022\u0022Tests for the LifcycleTransition action.\u0022\u0022\u0022\n\u002B\n\u002Bfrom launch import LaunchContext\n\u002Bfrom launch.actions import EmitEvent, RegisterEventHandler\n\u002Bfrom launch_ros.actions import LifecycleTransition\n\u002Bfrom lifecycle_msgs.msg import Transition\n\u002B\n\u002Bimport pytest\n\u002B\n\u002B\n\u002Bdef test_lifecycle_transition_constructor():\n\u002B    LifecycleTransition(\n\u002B        lifecycle_node_names=[\u0027talker\u0027],\n\u002B        transition_ids=[Transition.TRANSITION_ACTIVATE]\n\u002B    )\n\u002B    LifecycleTransition(\n\u002B        lifecycle_node_names=[\u0027talker\u0027],\n\u002B        transition_ids=[1]\n\u002B    )\n\u002B    LifecycleTransition(\n\u002B        lifecycle_node_names=[\u0027talker\u0027],\n\u002B        transition_ids=[\u00271\u0027]\n\u002B    )\n\u002B    with pytest.raises(ValueError):\n\u002B        LifecycleTransition(\n\u002B            lifecycle_node_names=[\u0027talker\u0027],\n\u002B            transition_ids=[]\n\u002B        )\n\u002B    with pytest.raises(ValueError):\n\u002B        LifecycleTransition(\n\u002B            lifecycle_node_names=[],\n\u002B            transition_ids=[Transition.TRANSITION_ACTIVATE]\n\u002B        )\n\u002B\n\u002B\n\u002Bdef test_lifecycle_transition_execute():\n\u002B    lc = LaunchContext()\n\u002B    lt = LifecycleTransition(\n\u002B        lifecycle_node_names=[\u0027talker\u0027],\n\u002B        transition_ids=[\u00271\u0027]\n\u002B    )\n\u002B    actions = lt.execute(lc)\n\u002B    # Check that actions are correctly generated\n\u002B    # First action should be RegisterEventHandler for first Transtion\n\u002B    assert isinstance(actions[0], RegisterEventHandler)\n\u002B    # Second action should be EmitEvent for first Transition\n\u002B    assert isinstance(actions[1], EmitEvent)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "4691063a61d39357d2c8ea08359e21bd3da42a29",
    "RawMessage": "Add a custom deleter when constructing rcl_service_t (#2351)",
    "Changes": "diff --git rclcpp/src/rclcpp/node_interfaces/node_type_descriptions.cpp rclcpp/src/rclcpp/node_interfaces/node_type_descriptions.cpp\nindex 2a50230b..fdac4652 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_type_descriptions.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_type_descriptions.cpp\n@@ -85,12 \u002B85,25 @@ public:\n \n     if (enabled) {\n       auto * rcl_node = node_base-\u003Eget_rcl_node_handle();\n-      auto rcl_srv = std::make_shared\u003Crcl_service_t\u003E();\n\u002B      std::shared_ptr\u003Crcl_service_t\u003E rcl_srv(\n\u002B        new rcl_service_t,\n\u002B        [rcl_node, logger = this-\u003Elogger_](rcl_service_t * service)\n\u002B        {\n\u002B          if (rcl_service_fini(service, rcl_node) != RCL_RET_OK) {\n\u002B            RCLCPP_ERROR(\n\u002B              logger,\n\u002B              \u0022Error in destruction of rcl service handle [~/get_type_description]: %s\u0022,\n\u002B              rcl_get_error_string().str);\n\u002B            rcl_reset_error();\n\u002B          }\n\u002B          delete service;\n\u002B        });\n\u002B      *rcl_srv = rcl_get_zero_initialized_service();\n       rcl_ret_t rcl_ret = rcl_node_type_description_service_init(rcl_srv.get(), rcl_node);\n \n       if (rcl_ret != RCL_RET_OK) {\n         RCLCPP_ERROR(\n-          logger_, \u0022Failed to initialize ~/get_type_description_service: %s\u0022,\n\u002B          logger_, \u0022Failed to initialize ~/get_type_description service: %s\u0022,\n           rcl_get_error_string().str);\n         throw std::runtime_error(\n                 \u0022Failed to initialize ~/get_type_description service.\u0022);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "95707009bc1f1a99929d17456bf271836fc7ccda",
    "RawMessage": "Add SHA256 utility implementation (#408)",
    "Changes": "diff --git CMakeLists.txt CMakeLists.txt\nindex 97304d5..35d4df0 100644\n--- CMakeLists.txt\n\u002B\u002B\u002B CMakeLists.txt\n@@ -63,6 \u002B63,7 @@ set(rcutils_sources\n   src/process.c\n   src/qsort.c\n   src/repl_str.c\n\u002B  src/sha256.c\n   src/shared_library.c\n   src/snprintf.c\n   src/split.c\n@@ -362,6 \u002B363,13 @@ if(BUILD_TESTING)\n     target_link_libraries(test_repl_str ${PROJECT_NAME})\n   endif()\n \n\u002B  ament_add_gtest(test_sha256\n\u002B    test/test_sha256.cpp\n\u002B  )\n\u002B  if(TARGET test_sha256)\n\u002B    target_link_libraries(test_sha256 ${PROJECT_NAME})\n\u002B  endif()\n\u002B\n   macro(add_dummy_shared_library target)\n     add_library(${target} test/dummy_shared_library/dummy_shared_library.c)\n     if(WIN32)\ndiff --git include/rcutils/sha256.h include/rcutils/sha256.h\nnew file mode 100644\nindex 0000000..6632f6d\n--- /dev/null\n\u002B\u002B\u002B include/rcutils/sha256.h\n@@ -0,0 \u002B1,94 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B/// \\file Provides a simple SHA256 algorithm for hashing.\n\u002B/// This implementation makes no security guarantees, its use case\n\u002B/// is for non-sensitive comparison of message digests\n\u002B/// Implementation originally copied from Brad Conte\n\u002B/// https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c\n\u002B\n\u002B/** \\file sha256.h\n\u002B *  \\brief SHA256 implementation\n\u002B *\n\u002B *  This contains an implementation of the SHA256 algorithm\n\u002B *  It was originally copied from Brad Conte\n\u002B *  https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c\n\u002B *  and modified to meet ros2 code formatting and compiler warning requirements.\n\u002B *  Algorithm specification can be found here:\n\u002B *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf\n\u002B *  This implementation uses little endian byte order.\n\u002B */\n\u002B\n\u002B#ifndef RCUTILS__SHA256_H_\n\u002B#define RCUTILS__SHA256_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B#include \u003Cstdint.h\u003E\n\u002B\n\u002B#include \u0022rcutils/visibility_control.h\u0022\n\u002B\n\u002B#define RCUTILS_SHA256_BLOCK_SIZE 32\n\u002B\n\u002Btypedef struct RCUTILS_PUBLIC_TYPE rcutils_sha256_ctx_s\n\u002B{\n\u002B  uint8_t data[64];\n\u002B  size_t datalen;\n\u002B  uint64_t bitlen;\n\u002B  uint32_t state[8];\n\u002B} rcutils_sha256_ctx_t;\n\u002B\n\u002B/// Initialize the sha256 algorithm context with starting state.\n\u002B/**\n\u002B * Call this on any new context before starting to input data.\n\u002B *\n\u002B * \\param[inout] ctx\n\u002B * \\return void\n\u002B */\n\u002BRCUTILS_PUBLIC\n\u002Bvoid rcutils_sha256_init(rcutils_sha256_ctx_t * ctx);\n\u002B\n\u002B/// Add data to the sha256 algorithm\n\u002B/**\n\u002B * This may be called repeatedly on an initialized context.\n\u002B *\n\u002B * \\param[inout] ctx Initialized sha256 context struct\n\u002B * \\param[in] data Data to add to the total message being hashed\n\u002B * \\param[in] data_len Size of the input data.\n\u002B * \\return void\n\u002B */\n\u002BRCUTILS_PUBLIC\n\u002Bvoid rcutils_sha256_update(rcutils_sha256_ctx_t * ctx, const uint8_t * data, size_t data_len);\n\u002B\n\u002B/// Finalize and output sha256 hash for all data added.\n\u002B/**\n\u002B * Call only once on a context that has been initialized, and optionally updated with data.\n\u002B *\n\u002B * \\param[inout] ctx Initialized sha256 context struct\n\u002B * \\param[out] output_hash Calculated sha256 message digest to be filled\n\u002B * \\return void\n\u002B */\n\u002BRCUTILS_PUBLIC\n\u002Bvoid rcutils_sha256_final(\n\u002B  rcutils_sha256_ctx_t * ctx,\n\u002B  uint8_t output_hash[RCUTILS_SHA256_BLOCK_SIZE]);\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // RCUTILS__SHA256_H_\ndiff --git src/sha256.c src/sha256.c\nnew file mode 100644\nindex 0000000..515e7a1\n--- /dev/null\n\u002B\u002B\u002B src/sha256.c\n@@ -0,0 \u002B1,199 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//   http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cassert.h\u003E\n\u002B#include \u003Cstring.h\u003E\n\u002B\n\u002B#include \u0022rcutils/sha256.h\u0022\n\u002B\n\u002Bstatic inline size_t min(size_t a, size_t b)\n\u002B{\n\u002B  return a \u003C b ? a : b;\n\u002B}\n\u002B\n\u002Bstatic inline size_t max(size_t a, size_t b)\n\u002B{\n\u002B  return a \u003E b ? a : b;\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t rotright(uint32_t a, const uint8_t b)\n\u002B{\n\u002B  assert(b \u003C 32);\n\u002B  return (a \u003E\u003E b) | (a \u003C\u003C (32 - b));\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t ch(uint32_t x, uint32_t y, uint32_t z)\n\u002B{\n\u002B  return (x \u0026 y) ^ (~x \u0026 z);\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t maj(uint32_t x, uint32_t y, uint32_t z)\n\u002B{\n\u002B  return (x \u0026 y) ^ (x \u0026 z) ^ (y \u0026 z);\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t ep0(uint32_t x)\n\u002B{\n\u002B  return rotright(x, 2) ^ rotright(x, 13) ^ rotright(x, 22);\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t ep1(uint32_t x)\n\u002B{\n\u002B  return rotright(x, 6) ^ rotright(x, 11) ^ rotright(x, 25);\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t sig0(uint32_t x)\n\u002B{\n\u002B  return rotright(x, 7) ^ rotright(x, 18) ^ (x \u003E\u003E 3);\n\u002B}\n\u002B\n\u002Bstatic inline uint32_t sig1(uint32_t x)\n\u002B{\n\u002B  return rotright(x, 17) ^ rotright(x, 19) ^ (x \u003E\u003E 10);\n\u002B}\n\u002B\n\u002Bstatic const uint32_t k[64] = {\n\u002B  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\u002B  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\u002B  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\u002B  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\u002B  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\u002B  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\u002B  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\u002B  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\u002B};\n\u002B\n\u002Bstatic void sha256_transform(rcutils_sha256_ctx_t * ctx)\n\u002B{\n\u002B  uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];\n\u002B  uint8_t * data = ctx-\u003Edata;\n\u002B\n\u002B  for (i = 0, j = 0; i \u003C 16; \u002B\u002Bi, j \u002B= 4) {\n\u002B    m[i] = (data[j] \u003C\u003C 24) | (data[j \u002B 1] \u003C\u003C 16) | (data[j \u002B 2] \u003C\u003C 8) | (data[j \u002B 3]);\n\u002B  }\n\u002B  for ( ; i \u003C 64; \u002B\u002Bi) {\n\u002B    m[i] = sig1(m[i - 2]) \u002B m[i - 7] \u002B sig0(m[i - 15]) \u002B m[i - 16];\n\u002B  }\n\u002B\n\u002B  a = ctx-\u003Estate[0];\n\u002B  b = ctx-\u003Estate[1];\n\u002B  c = ctx-\u003Estate[2];\n\u002B  d = ctx-\u003Estate[3];\n\u002B  e = ctx-\u003Estate[4];\n\u002B  f = ctx-\u003Estate[5];\n\u002B  g = ctx-\u003Estate[6];\n\u002B  h = ctx-\u003Estate[7];\n\u002B\n\u002B  for (i = 0; i \u003C 64; \u002B\u002Bi) {\n\u002B    t1 = h \u002B ep1(e) \u002B ch(e, f, g) \u002B k[i] \u002B m[i];\n\u002B    t2 = ep0(a) \u002B maj(a, b, c);\n\u002B    h = g;\n\u002B    g = f;\n\u002B    f = e;\n\u002B    e = d \u002B t1;\n\u002B    d = c;\n\u002B    c = b;\n\u002B    b = a;\n\u002B    a = t1 \u002B t2;\n\u002B  }\n\u002B\n\u002B  ctx-\u003Estate[0] \u002B= a;\n\u002B  ctx-\u003Estate[1] \u002B= b;\n\u002B  ctx-\u003Estate[2] \u002B= c;\n\u002B  ctx-\u003Estate[3] \u002B= d;\n\u002B  ctx-\u003Estate[4] \u002B= e;\n\u002B  ctx-\u003Estate[5] \u002B= f;\n\u002B  ctx-\u003Estate[6] \u002B= g;\n\u002B  ctx-\u003Estate[7] \u002B= h;\n\u002B}\n\u002B\n\u002Bvoid rcutils_sha256_init(rcutils_sha256_ctx_t * ctx)\n\u002B{\n\u002B  ctx-\u003Edatalen = 0;\n\u002B  ctx-\u003Ebitlen = 0;\n\u002B  ctx-\u003Estate[0] = 0x6a09e667;\n\u002B  ctx-\u003Estate[1] = 0xbb67ae85;\n\u002B  ctx-\u003Estate[2] = 0x3c6ef372;\n\u002B  ctx-\u003Estate[3] = 0xa54ff53a;\n\u002B  ctx-\u003Estate[4] = 0x510e527f;\n\u002B  ctx-\u003Estate[5] = 0x9b05688c;\n\u002B  ctx-\u003Estate[6] = 0x1f83d9ab;\n\u002B  ctx-\u003Estate[7] = 0x5be0cd19;\n\u002B}\n\u002B\n\u002Bvoid rcutils_sha256_update(rcutils_sha256_ctx_t * ctx, const uint8_t * data, size_t len)\n\u002B{\n\u002B  size_t i, data_remaining, block_remaining, copy_len;\n\u002B  i = 0;\n\u002B\n\u002B  while (i \u003C len) {\n\u002B    data_remaining = len - i;\n\u002B    block_remaining = 64 - ctx-\u003Edatalen;\n\u002B    copy_len = min(min(block_remaining, data_remaining), 64);\n\u002B\n\u002B    memcpy(ctx-\u003Edata \u002B ctx-\u003Edatalen, data \u002B i, copy_len);\n\u002B    ctx-\u003Edatalen \u002B= copy_len;\n\u002B    i \u002B= copy_len;\n\u002B\n\u002B    if (ctx-\u003Edatalen \u003E= 64) {\n\u002B      sha256_transform(ctx);\n\u002B      ctx-\u003Ebitlen \u002B= 512;\n\u002B      ctx-\u003Edatalen = 0;\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid rcutils_sha256_final(\n\u002B  rcutils_sha256_ctx_t * ctx, uint8_t output_hash[RCUTILS_SHA256_BLOCK_SIZE])\n\u002B{\n\u002B  size_t i = ctx-\u003Edatalen;\n\u002B\n\u002B  // Pad whatever data is left in the buffer.\n\u002B  if (ctx-\u003Edatalen \u003C 56) {\n\u002B    ctx-\u003Edata[i\u002B\u002B] = 0x80;\n\u002B    memset(ctx-\u003Edata \u002B i, 0x00, 56 - i);\n\u002B  } else {\n\u002B    ctx-\u003Edata[i\u002B\u002B] = 0x80;\n\u002B    if (i \u003C 64) {\n\u002B      memset(ctx-\u003Edata \u002B i, 0x00, 64 - i);\n\u002B    }\n\u002B    sha256_transform(ctx);\n\u002B    memset(ctx-\u003Edata, 0, 56);\n\u002B  }\n\u002B\n\u002B  // Append to the padding the total message\u0027s length in bits and transform.\n\u002B  ctx-\u003Ebitlen \u002B= ctx-\u003Edatalen * 8;\n\u002B  ctx-\u003Edata[63] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 0);\n\u002B  ctx-\u003Edata[62] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 8);\n\u002B  ctx-\u003Edata[61] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 16);\n\u002B  ctx-\u003Edata[60] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 24);\n\u002B  ctx-\u003Edata[59] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 32);\n\u002B  ctx-\u003Edata[58] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 40);\n\u002B  ctx-\u003Edata[57] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 48);\n\u002B  ctx-\u003Edata[56] = (uint8_t)(ctx-\u003Ebitlen \u003E\u003E 56);\n\u002B  sha256_transform(ctx);\n\u002B\n\u002B  // Since this implementation uses little endian byte ordering and SHA uses big endian,\n\u002B  // reverse all the bytes when copying the final state to the output hash.\n\u002B  for (i = 0; i \u003C 4; \u002B\u002Bi) {\n\u002B    output_hash[i \u002B 0] = (ctx-\u003Estate[0] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 4] = (ctx-\u003Estate[1] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 8] = (ctx-\u003Estate[2] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 12] = (ctx-\u003Estate[3] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 16] = (ctx-\u003Estate[4] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 20] = (ctx-\u003Estate[5] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 24] = (ctx-\u003Estate[6] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B    output_hash[i \u002B 28] = (ctx-\u003Estate[7] \u003E\u003E (24 - i * 8)) \u0026 0x000000ff;\n\u002B  }\n\u002B}\ndiff --git test/test_sha256.cpp test/test_sha256.cpp\nnew file mode 100644\nindex 0000000..fda87c8\n--- /dev/null\n\u002B\u002B\u002B test/test_sha256.cpp\n@@ -0,0 \u002B1,75 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022rcutils/sha256.h\u0022\n\u002B\n\u002BTEST(TestSHA256, test_text1) {\n\u002B  uint8_t text1[] = {\u0022abc\u0022};\n\u002B  size_t text1_len = sizeof(text1) - 1;\n\u002B  uint8_t expected_hash1[RCUTILS_SHA256_BLOCK_SIZE] = {\n\u002B    0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,\n\u002B    0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,\n\u002B    0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,\n\u002B    0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad};\n\u002B  uint8_t buf[RCUTILS_SHA256_BLOCK_SIZE];\n\u002B\n\u002B\n\u002B  rcutils_sha256_ctx_t ctx;\n\u002B  rcutils_sha256_init(\u0026ctx);\n\u002B  rcutils_sha256_update(\u0026ctx, text1, text1_len);\n\u002B  rcutils_sha256_final(\u0026ctx, buf);\n\u002B\n\u002B  ASSERT_EQ(0, memcmp(expected_hash1, buf, RCUTILS_SHA256_BLOCK_SIZE));\n\u002B}\n\u002B\n\u002BTEST(TestSHA256, test_text2) {\n\u002B  uint8_t text2[] = {\u0022abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\u0022};\n\u002B  size_t text2_len = sizeof(text2) - 1;\n\u002B  uint8_t expected_hash2[RCUTILS_SHA256_BLOCK_SIZE] = {\n\u002B    0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,\n\u002B    0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,\n\u002B    0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,\n\u002B    0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1};\n\u002B  uint8_t buf[RCUTILS_SHA256_BLOCK_SIZE];\n\u002B\n\u002B  rcutils_sha256_ctx_t ctx;\n\u002B  rcutils_sha256_init(\u0026ctx);\n\u002B  rcutils_sha256_update(\u0026ctx, text2, text2_len);\n\u002B  rcutils_sha256_final(\u0026ctx, buf);\n\u002B\n\u002B  ASSERT_EQ(0, memcmp(expected_hash2, buf, RCUTILS_SHA256_BLOCK_SIZE));\n\u002B}\n\u002B\n\u002BTEST(TestSHA256, test_multi_update) {\n\u002B  uint8_t text[] = {\u0022aaaaaaaaaa\u0022};\n\u002B  size_t text_len = sizeof(text) - 1;\n\u002B\n\u002B  uint8_t expected_hash[RCUTILS_SHA256_BLOCK_SIZE] = {\n\u002B    0x28, 0x16, 0x59, 0x78, 0x88, 0xe4, 0xa0, 0xd3,\n\u002B    0xa3, 0x6b, 0x82, 0xb8, 0x33, 0x16, 0xab, 0x32,\n\u002B    0x68, 0x0e, 0xb8, 0xf0, 0x0f, 0x8c, 0xd3, 0xb9,\n\u002B    0x04, 0xd6, 0x81, 0x24, 0x6d, 0x28, 0x5a, 0x0e};\n\u002B  uint8_t buf[RCUTILS_SHA256_BLOCK_SIZE];\n\u002B\n\u002B  rcutils_sha256_ctx_t ctx;\n\u002B  rcutils_sha256_init(\u0026ctx);\n\u002B  for (int i = 0; i \u003C 10; i\u002B\u002B) {\n\u002B    rcutils_sha256_update(\u0026ctx, text, text_len);\n\u002B  }\n\u002B  rcutils_sha256_final(\u0026ctx, buf);\n\u002B\n\u002B  ASSERT_EQ(0, memcmp(expected_hash, buf, RCUTILS_SHA256_BLOCK_SIZE));\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "93d4074a8bfd4d584cf5fdef22a88121e15e0352",
    "RawMessage": "remove feedback callback when the goal has been completed. (#927)",
    "Changes": "diff --git rclpy/rclpy/action/client.py rclpy/rclpy/action/client.py\nindex c13fbb1..cccc8b8 100644\n--- rclpy/rclpy/action/client.py\n\u002B\u002B\u002B rclpy/rclpy/action/client.py\n@@ -168,11 \u002B168,13 @@ class ActionClient(Waitable):\n         # key: goal request sequence_number, value: Future for goal response\n         self._pending_goal_requests = {}\n         # key: goal request sequence_number, value: UUID\n-        self._sequence_number_to_goal_id = {}\n\u002B        self._goal_sequence_number_to_goal_id = {}\n         # key: cancel request sequence number, value: Future for cancel response\n         self._pending_cancel_requests = {}\n         # key: result request sequence number, value: Future for result response\n         self._pending_result_requests = {}\n\u002B        # key: result request sequence_number, value: UUID\n\u002B        self._result_sequence_number_to_goal_id = {}\n         # key: UUID in bytes, value: callback function\n         self._feedback_callbacks = {}\n \n@@ -208,14 \u002B210,20 @@ class ActionClient(Waitable):\n \n     def _remove_pending_goal_request(self, future):\n         seq = self._remove_pending_request(future, self._pending_goal_requests)\n-        if seq in self._sequence_number_to_goal_id:\n-            del self._sequence_number_to_goal_id[seq]\n\u002B        if seq in self._goal_sequence_number_to_goal_id:\n\u002B            del self._goal_sequence_number_to_goal_id[seq]\n \n     def _remove_pending_cancel_request(self, future):\n         self._remove_pending_request(future, self._pending_cancel_requests)\n \n     def _remove_pending_result_request(self, future):\n-        self._remove_pending_request(future, self._pending_result_requests)\n\u002B        seq = self._remove_pending_request(future, self._pending_result_requests)\n\u002B        if seq in self._result_sequence_number_to_goal_id:\n\u002B            goal_uuid = bytes(self._result_sequence_number_to_goal_id[seq].uuid)\n\u002B            del self._result_sequence_number_to_goal_id[seq]\n\u002B            # remove feeback_callback if user is aware of result and it\u0027s been received\n\u002B            if goal_uuid in self._feedback_callbacks:\n\u002B                del self._feedback_callbacks[goal_uuid]\n \n     # Start Waitable API\n     def is_ready(self, wait_set):\n@@ -277,10 \u002B285,10 @@ class ActionClient(Waitable):\n         \u0022\u0022\u0022\n         if \u0027goal\u0027 in taken_data:\n             sequence_number, goal_response = taken_data[\u0027goal\u0027]\n-            if sequence_number in self._sequence_number_to_goal_id:\n\u002B            if sequence_number in self._goal_sequence_number_to_goal_id:\n                 goal_handle = ClientGoalHandle(\n                     self,\n-                    self._sequence_number_to_goal_id[sequence_number],\n\u002B                    self._goal_sequence_number_to_goal_id[sequence_number],\n                     goal_response)\n \n                 if goal_handle.accepted:\n@@ -440,7 \u002B448,7 @@ class ActionClient(Waitable):\n \n         future = Future()\n         self._pending_goal_requests[sequence_number] = future\n-        self._sequence_number_to_goal_id[sequence_number] = request.goal_id\n\u002B        self._goal_sequence_number_to_goal_id[sequence_number] = request.goal_id\n         future.add_done_callback(self._remove_pending_goal_request)\n         # Add future so executor is aware\n         self.add_future(future)\n@@ -545,6 \u002B553,7 @@ class ActionClient(Waitable):\n \n         future = Future()\n         self._pending_result_requests[sequence_number] = future\n\u002B        self._result_sequence_number_to_goal_id[sequence_number] = result_request.goal_id\n         future.add_done_callback(self._remove_pending_result_request)\n         # Add future so executor is aware\n         self.add_future(future)\ndiff --git rclpy/test/test_action_client.py rclpy/test/test_action_client.py\nindex 8ae4a15..6dfe71b 100644\n--- rclpy/test/test_action_client.py\n\u002B\u002B\u002B rclpy/test/test_action_client.py\n@@ -209,6 \u002B209,32 @@ class TestActionClient(unittest.TestCase):\n         finally:\n             ac.destroy()\n \n\u002B    def test_send_goal_async_with_feedback_after_goal_result_requested(self):\n\u002B        ac = ActionClient(self.node, Fibonacci, \u0027fibonacci\u0027)\n\u002B        try:\n\u002B            self.assertTrue(ac.wait_for_server(timeout_sec=2.0))\n\u002B\n\u002B            # Send a goal and wait for completion\n\u002B            goal_uuid = UUID(uuid=list(uuid.uuid4().bytes))\n\u002B            goal_future = ac.send_goal_async(\n\u002B                Fibonacci.Goal(),\n\u002B                feedback_callback=self.feedback_callback,\n\u002B                goal_uuid=goal_uuid)\n\u002B            rclpy.spin_until_future_complete(self.node, goal_future, self.executor)\n\u002B            self.assertTrue(goal_future.done())\n\u002B            # Then request result\n\u002B            goal_handle = goal_future.result()\n\u002B            result_future = goal_handle.get_result_async()\n\u002B            rclpy.spin_until_future_complete(self.node, result_future, self.executor)\n\u002B            self.assertTrue(result_future.done())\n\u002B\n\u002B            # Publish feedback after goal result is requested\n\u002B            self.mock_action_server.publish_feedback(goal_uuid)\n\u002B            self.timed_spin(1.0)\n\u002B            self.assertEqual(self.feedback, None)\n\u002B        finally:\n\u002B            ac.destroy()\n\u002B\n     def test_send_goal_async_with_feedback_for_another_goal(self):\n         ac = ActionClient(self.node, Fibonacci, \u0027fibonacci\u0027)\n         try:\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "620912fb31716cd62f8f51d8ad249a576166ad07",
    "RawMessage": "Added benchmark test to rosidl_typesupport_fastrtps_c/cpp (#52)",
    "Changes": "diff --git rosidl_typesupport_fastrtps_c/CMakeLists.txt rosidl_typesupport_fastrtps_c/CMakeLists.txt\nindex ef899fb..fa48176 100644\n--- rosidl_typesupport_fastrtps_c/CMakeLists.txt\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/CMakeLists.txt\n@@ -70,6 \u002B70,12 @@ if(BUILD_TESTING)\n   find_package(ament_cmake_gtest REQUIRED)\n   find_package(ament_lint_auto REQUIRED)\n   find_package(osrf_testing_tools_cpp REQUIRED)\n\u002B  find_package(performance_test_fixture REQUIRED)\n\u002B\n\u002B  # Give cppcheck hints about macro definitions coming from outside this package\n\u002B  get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS\n\u002B    performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n\u002B\n   ament_lint_auto_find_test_dependencies()\n \n   get_target_property(memory_tools_ld_preload_env_var\n@@ -97,6 \u002B103,11 @@ if(BUILD_TESTING)\n     target_link_libraries(test_wstring_conversion_mem\n       ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools)\n   endif()\n\u002B\n\u002B  add_performance_test(benchmark_string_conversions test/benchmark/benchmark_string_conversions.cpp)\n\u002B  if(TARGET benchmark_string_conversions)\n\u002B    target_link_libraries(benchmark_string_conversions ${PROJECT_NAME})\n\u002B  endif()\n endif()\n \n ament_package(\ndiff --git rosidl_typesupport_fastrtps_c/package.xml rosidl_typesupport_fastrtps_c/package.xml\nindex 9e02fdd..4a0c001 100644\n--- rosidl_typesupport_fastrtps_c/package.xml\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/package.xml\n@@ -34,6 \u002B34,7 @@\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eosrf_testing_tools_cpp\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eperformance_test_fixture\u003C/test_depend\u003E\n \n   \u003Cmember_of_group\u003Erosidl_typesupport_c_packages\u003C/member_of_group\u003E\n \ndiff --git rosidl_typesupport_fastrtps_c/test/benchmark/benchmark_string_conversions.cpp rosidl_typesupport_fastrtps_c/test/benchmark/benchmark_string_conversions.cpp\nnew file mode 100644\nindex 0000000..f10e8f8\n--- /dev/null\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/test/benchmark/benchmark_string_conversions.cpp\n@@ -0,0 \u002B1,71 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rosidl_runtime_c/string_functions.h\u0022\n\u002B#include \u0022rosidl_runtime_c/u16string_functions.h\u0022\n\u002B\n\u002B#include \u0022rosidl_typesupport_fastrtps_c/wstring_conversion.hpp\u0022\n\u002B\n\u002B#include \u0022performance_test_fixture/performance_test_fixture.hpp\u0022\n\u002B\n\u002Busing performance_test_fixture::PerformanceTest;\n\u002B\n\u002Bnamespace\n\u002B{\n\u002Bconstexpr const uint64_t kSize = 1024;\n\u002B}\n\u002B\n\u002BBENCHMARK_F(PerformanceTest, wstring_to_u16string)(benchmark::State \u0026 st)\n\u002B{\n\u002B  std::wstring wstring(kSize, \u0027*\u0027);\n\u002B\n\u002B  rosidl_runtime_c__U16String s;\n\u002B  if (!rosidl_runtime_c__U16String__init(\u0026s)) {\n\u002B    st.SkipWithError(\u0022String initialization failed\u0022);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  reset_heap_counters();\n\u002B\n\u002B  for (auto _ : st) {\n\u002B    rosidl_typesupport_fastrtps_c::wstring_to_u16string(wstring, s);\n\u002B  }\n\u002B\n\u002B  rosidl_runtime_c__U16String__fini(\u0026s);\n\u002B}\n\u002B\n\u002BBENCHMARK_F(PerformanceTest, u16string_to_wstring)(benchmark::State \u0026 st)\n\u002B{\n\u002B  std::wstring data(kSize, \u0027*\u0027);\n\u002B\n\u002B  rosidl_runtime_c__U16String s;\n\u002B  if (!rosidl_runtime_c__U16String__init(\u0026s)) {\n\u002B    st.SkipWithError(\u0022String initialization failed\u0022);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  // Just do a copy\n\u002B  rosidl_typesupport_fastrtps_c::wstring_to_u16string(data, s);\n\u002B\n\u002B  reset_heap_counters();\n\u002B\n\u002B  for (auto _ : st) {\n\u002B    std::wstring actual;\n\u002B    rosidl_typesupport_fastrtps_c::u16string_to_wstring(s, actual);\n\u002B  }\n\u002B\n\u002B  rosidl_runtime_c__U16String__fini(\u0026s);\n\u002B}\ndiff --git rosidl_typesupport_fastrtps_cpp/CMakeLists.txt rosidl_typesupport_fastrtps_cpp/CMakeLists.txt\nindex 2b6a975..bb9092c 100644\n--- rosidl_typesupport_fastrtps_cpp/CMakeLists.txt\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/CMakeLists.txt\n@@ -63,6 \u002B63,14 @@ if(BUILD_TESTING)\n   find_package(ament_cmake_gtest REQUIRED)\n   find_package(ament_lint_auto REQUIRED)\n   find_package(osrf_testing_tools_cpp REQUIRED)\n\u002B\n\u002B  find_package(performance_test_fixture REQUIRED)\n\u002B\n\u002B  # Give cppcheck hints about macro definitions coming from outside this package\n\u002B  get_target_property(ament_cmake_cppcheck_ADDITIONAL_INCLUDE_DIRS\n\u002B    performance_test_fixture::performance_test_fixture INTERFACE_INCLUDE_DIRECTORIES)\n\u002B\n\u002B  set(ament_cmake_cppcheck_LANGUAGE c\u002B\u002B)\n   ament_lint_auto_find_test_dependencies()\n \n   get_target_property(memory_tools_ld_preload_env_var\n@@ -90,6 \u002B98,11 @@ if(BUILD_TESTING)\n     target_link_libraries(test_wstring_conversion_mem\n       ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools)\n   endif()\n\u002B\n\u002B  add_performance_test(benchmark_string_conversions test/benchmark/benchmark_string_conversions.cpp)\n\u002B  if(TARGET benchmark_string_conversions)\n\u002B    target_link_libraries(benchmark_string_conversions ${PROJECT_NAME})\n\u002B  endif()\n endif()\n \n ament_package(\ndiff --git rosidl_typesupport_fastrtps_cpp/package.xml rosidl_typesupport_fastrtps_cpp/package.xml\nindex c1dd070..4ec2773 100644\n--- rosidl_typesupport_fastrtps_cpp/package.xml\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/package.xml\n@@ -35,6 \u002B35,7 @@\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eosrf_testing_tools_cpp\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eperformance_test_fixture\u003C/test_depend\u003E\n \n   \u003Cmember_of_group\u003Erosidl_typesupport_cpp_packages\u003C/member_of_group\u003E\n \ndiff --git rosidl_typesupport_fastrtps_cpp/test/benchmark/benchmark_string_conversions.cpp rosidl_typesupport_fastrtps_cpp/test/benchmark/benchmark_string_conversions.cpp\nnew file mode 100644\nindex 0000000..6e087f6\n--- /dev/null\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/test/benchmark/benchmark_string_conversions.cpp\n@@ -0,0 \u002B1,50 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rosidl_typesupport_fastrtps_cpp/wstring_conversion.hpp\u0022\n\u002B\n\u002B#include \u0022performance_test_fixture/performance_test_fixture.hpp\u0022\n\u002B\n\u002Busing performance_test_fixture::PerformanceTest;\n\u002B\n\u002Bnamespace\n\u002B{\n\u002Bconstexpr const uint64_t kSize = 1024;\n\u002B}\n\u002B\n\u002BBENCHMARK_F(PerformanceTest, wstring_to_u16string)(benchmark::State \u0026 st)\n\u002B{\n\u002B  std::wstring wstring(kSize, \u0027*\u0027);\n\u002B\n\u002B  reset_heap_counters();\n\u002B\n\u002B  for (auto _ : st) {\n\u002B    std::u16string u16string;\n\u002B    rosidl_typesupport_fastrtps_cpp::wstring_to_u16string(wstring, u16string);\n\u002B  }\n\u002B}\n\u002B\n\u002BBENCHMARK_F(PerformanceTest, u16string_to_wstring)(benchmark::State \u0026 st)\n\u002B{\n\u002B  std::u16string u16string(kSize, \u0027*\u0027);\n\u002B\n\u002B  reset_heap_counters();\n\u002B\n\u002B  for (auto _ : st) {\n\u002B    std::wstring wstring;\n\u002B    rosidl_typesupport_fastrtps_cpp::u16string_to_wstring(u16string, wstring);\n\u002B  }\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "05d524a2fe7cbf2a20745dac21f5c5cb2f80e16b",
    "RawMessage": "Add message lost subscription event",
    "Changes": "diff --git rmw_gurumdds_shared_cpp/src/event_converter.cpp rmw_gurumdds_shared_cpp/src/event_converter.cpp\nindex a7e141c..492fd56 100644\n--- rmw_gurumdds_shared_cpp/src/event_converter.cpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/src/event_converter.cpp\n@@ -24,6 \u002B24,7 @@ g_mask_map_ptr {new std::unordered_map\u003Crmw_event_type_t, dds_StatusKind, std::ha\n     {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n     {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n     {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n\u002B    {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n     {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n     {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n     {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "d15594effa63065a19a9f69960ea80f5ac5be8bd",
    "RawMessage": "use parent logger (#921)",
    "Changes": "diff --git rcl/include/rcl/logging_rosout.h rcl/include/rcl/logging_rosout.h\nindex 4e42629..cc76290 100644\n--- rcl/include/rcl/logging_rosout.h\n\u002B\u002B\u002B rcl/include/rcl/logging_rosout.h\n@@ -188,6 \u002B188,69 @@ rcl_logging_rosout_output_handler(\n   const char * format,\n   va_list * args);\n \n\u002B/// Add a subordinate logger based on a logger\n\u002B/**\n\u002B * Calling this will use the existing publisher of \u0060logger_name\u0060 on a node to create an subordinate\n\u002B * logger that will be used by the logging system to publish all log messages from that Node\u0027s\n\u002B * logger.\n\u002B *\n\u002B * If a subordinate logger already exists, it will NOT be created.\n\u002B *\n\u002B * It is expected that after creating a subordinate logger with this function\n\u002B * rcl_logging_rosout_remove_sublogger() will be called for the node to cleanup\n\u002B * the subordinate logger while the publisher of \u0060logger_name\u0060 is still valid.\n\u002B *\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Yes\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | No\n\u002B * Lock-Free          | Yes\n\u002B *\n\u002B * \\param[in] logger_name a logger_name that has a corresponding rosout publisher on a node\n\u002B * \\param[in] sublogger_name a sublogger name\n\u002B * \\return #RCL_RET_OK if the subordinate logger was created successfully, or\n\u002B * \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n\u002B * \\return #RCL_RET_SUBLOGGER_ALREADY_EXIST if the subordinate logger already exists, or\n\u002B * \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n\u002B * \\return #RCL_RET_ERROR if an unspecified error occurs.\n\u002B */\n\u002BRCL_PUBLIC\n\u002BRCL_WARN_UNUSED\n\u002Brcl_ret_t\n\u002Brcl_logging_rosout_add_sublogger(\n\u002B  const char * logger_name, const char * sublogger_name);\n\u002B\n\u002B/// Remove a subordinate logger and cleans up allocated resources\n\u002B/**\n\u002B * Calling this will destroy the subordinate logger based on\n\u002B * \u0060logger_name\u002BRCUTILS_LOGGING_SEPARATOR_STRING\u002Bsublogger_name\u0060 on that node and remove it from\n\u002B * the logging system so that no more Log messages are published to this function.\n\u002B *\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Yes\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | No\n\u002B * Lock-Free          | Yes\n\u002B *\n\u002B * \\param[in] logger_name a logger_name that has a corresponding rosout publisher on a node\n\u002B * \\param[in] sublogger_name a sublogger name\n\u002B * \\return #RCL_RET_OK if the subordinate logger was finalized successfully, or\n\u002B * \\return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or\n\u002B * \\return #RCL_RET_BAD_ALLOC if allocating memory failed, or\n\u002B * \\return #RCL_RET_ERROR if an unspecified error occurs.\n\u002B */\n\u002BRCL_PUBLIC\n\u002BRCL_WARN_UNUSED\n\u002Brcl_ret_t\n\u002Brcl_logging_rosout_remove_sublogger(\n\u002B  const char * logger_name, const char * sublogger_name);\n\u002B\n #ifdef __cplusplus\n }\n #endif\ndiff --git rcl/src/rcl/logging_rosout.c rcl/src/rcl/logging_rosout.c\nindex 6f602b4..5208502 100644\n--- rcl/src/rcl/logging_rosout.c\n\u002B\u002B\u002B rcl/src/rcl/logging_rosout.c\n@@ -22,6 \u002B22,7 @@\n #include \u0022rcl/visibility_control.h\u0022\n #include \u0022rcl_interfaces/msg/log.h\u0022\n #include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/format_string.h\u0022\n #include \u0022rcutils/logging_macros.h\u0022\n #include \u0022rcutils/macros.h\u0022\n #include \u0022rcutils/types/hash_map.h\u0022\n@@ -75,6 \u002B76,16 @@ static rcutils_hash_map_t __logger_map;\n static bool __is_initialized = false;\n static rcl_allocator_t __rosout_allocator;\n \n\u002Btypedef struct rosout_sublogger_entry_t\n\u002B{\n\u002B  // name is to store the allocated memory, and then finalize it at the end\n\u002B  char * name;\n\u002B  // count is something like a reference count that removes the entry if it is 0\n\u002B  uint64_t * count;\n\u002B} rosout_sublogger_entry_t;\n\u002B\n\u002Bstatic rcutils_hash_map_t __sublogger_map;\n\u002B\n rcl_ret_t rcl_logging_rosout_init(const rcl_allocator_t * allocator)\n {\n   RCL_CHECK_ARGUMENT_FOR_NULL(allocator, RCL_RET_INVALID_ARGUMENT);\n@@ -87,48 \u002B98,135 @@ rcl_ret_t rcl_logging_rosout_init(const rcl_allocator_t * allocator)\n     rcutils_hash_map_init(\n       \u0026__logger_map, 2, sizeof(const char *), sizeof(rosout_map_entry_t),\n       rcutils_hash_map_string_hash_func, rcutils_hash_map_string_cmp_func, allocator));\n-  if (RCL_RET_OK == status) {\n-    __rosout_allocator = *allocator;\n-    __is_initialized = true;\n\u002B  if (RCL_RET_OK != status) {\n\u002B    return status;\n   }\n\u002B\n\u002B  __sublogger_map = rcutils_get_zero_initialized_hash_map();\n\u002B  status = rcl_ret_from_rcutils_ret(\n\u002B    rcutils_hash_map_init(\n\u002B      \u0026__sublogger_map, 2, sizeof(const char *), sizeof(rosout_sublogger_entry_t),\n\u002B      rcutils_hash_map_string_hash_func, rcutils_hash_map_string_cmp_func, allocator));\n\u002B  if (RCL_RET_OK != status) {\n\u002B    rcl_ret_t fini_status = rcl_ret_from_rcutils_ret(rcutils_hash_map_fini(\u0026__logger_map));\n\u002B    if (RCL_RET_OK != fini_status) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022Failed to finalize the hash map for logger: \u0022);\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n\u002B      rcl_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    }\n\u002B    return status;\n\u002B  }\n\u002B\n\u002B  __rosout_allocator = *allocator;\n\u002B  __is_initialized = true;\n\u002B\n   return status;\n }\n \n-rcl_ret_t rcl_logging_rosout_fini()\n\u002Bstatic rcl_ret_t\n\u002B_rcl_logging_rosout_remove_logger_map(rcl_node_t * node)\n {\n-  if (!__is_initialized) {\n-    return RCL_RET_OK;\n-  }\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(node, RCL_RET_INVALID_ARGUMENT);\n\u002B\n   rcl_ret_t status = RCL_RET_OK;\n\u002B  char * previous_key = NULL;\n   char * key = NULL;\n   rosout_map_entry_t entry;\n-\n-  // fini all the outstanding publishers\n   rcutils_ret_t hashmap_ret = rcutils_hash_map_get_next_key_and_data(\n     \u0026__logger_map, NULL, \u0026key, \u0026entry);\n   while (RCL_RET_OK == status \u0026\u0026 RCUTILS_RET_OK == hashmap_ret) {\n-    // Teardown publisher\n-    status = rcl_publisher_fini(\u0026entry.publisher, entry.node);\n-\n-    if (RCL_RET_OK == status) {\n\u002B    if (entry.node == node) {\n       status = rcl_ret_from_rcutils_ret(rcutils_hash_map_unset(\u0026__logger_map, \u0026key));\n\u002B      previous_key = NULL;\n\u002B    } else {\n\u002B      previous_key = key;\n     }\n-\n     if (RCL_RET_OK == status) {\n-      hashmap_ret = rcutils_hash_map_get_next_key_and_data(\u0026__logger_map, NULL, \u0026key, \u0026entry);\n\u002B      hashmap_ret = rcutils_hash_map_get_next_key_and_data(\n\u002B        \u0026__logger_map, previous_key ? \u0026previous_key : NULL, \u0026key, \u0026entry);\n     }\n   }\n\u002B  return RCL_RET_OK;\n\u002B}\n\u002B\n\u002Bstatic rcl_ret_t\n\u002B_rcl_logging_rosout_clear_logger_map_item(void * value)\n\u002B{\n\u002B  rosout_map_entry_t * entry = (rosout_map_entry_t *)value;\n\u002B  // Teardown publisher\n\u002B  rcl_ret_t status = rcl_publisher_fini(\u0026entry-\u003Epublisher, entry-\u003Enode);\n\u002B  if (RCL_RET_OK == status) {\n\u002B    // delete all entries using this node\n\u002B    status = rcl_ret_from_rcutils_ret(_rcl_logging_rosout_remove_logger_map(entry-\u003Enode));\n\u002B  }\n\u002B\n\u002B  return status;\n\u002B}\n\u002B\n\u002Bstatic rcl_ret_t\n\u002B_rcl_logging_rosout_clear_sublogger_map_item(void * value)\n\u002B{\n\u002B  rosout_sublogger_entry_t * entry = (rosout_sublogger_entry_t *)value;\n\u002B  rcl_ret_t status = rcl_ret_from_rcutils_ret(\n\u002B    rcutils_hash_map_unset(\u0026__sublogger_map, \u0026entry-\u003Ename));\n\u002B  __rosout_allocator.deallocate(entry-\u003Ename, __rosout_allocator.state);\n\u002B  __rosout_allocator.deallocate(entry-\u003Ecount, __rosout_allocator.state);\n\u002B\n\u002B  return status;\n\u002B}\n\u002B\n\u002Bstatic rcl_ret_t\n\u002B_rcl_logging_rosout_clear_hashmap(\n\u002B  rcutils_hash_map_t * map, rcl_ret_t (* predicate)(void *), void * entry)\n\u002B{\n\u002B  rcl_ret_t status = RCL_RET_OK;\n\u002B  char * key = NULL;\n\u002B\n\u002B  rcutils_ret_t hashmap_ret = rcutils_hash_map_get_next_key_and_data(\n\u002B    map, NULL, \u0026key, entry);\n\u002B  while (RCUTILS_RET_OK == hashmap_ret) {\n\u002B    status = predicate(entry);\n\u002B    if (RCL_RET_OK != status) {\n\u002B      break;\n\u002B    }\n\u002B\n\u002B    hashmap_ret = rcutils_hash_map_get_next_key_and_data(map, NULL, \u0026key, entry);\n\u002B  }\n   if (RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES != hashmap_ret) {\n     status = rcl_ret_from_rcutils_ret(hashmap_ret);\n   }\n \n   if (RCL_RET_OK == status) {\n-    status = rcl_ret_from_rcutils_ret(rcutils_hash_map_fini(\u0026__logger_map));\n\u002B    status = rcl_ret_from_rcutils_ret(rcutils_hash_map_fini(map));\n   }\n \n-  if (RCL_RET_OK == status) {\n-    __is_initialized = false;\n\u002B  return status;\n\u002B}\n\u002B\n\u002Brcl_ret_t rcl_logging_rosout_fini()\n\u002B{\n\u002B  if (!__is_initialized) {\n\u002B    return RCL_RET_OK;\n\u002B  }\n\u002B  rcl_ret_t status = RCL_RET_OK;\n\u002B  rosout_map_entry_t entry;\n\u002B  rosout_sublogger_entry_t sublogger_entry;\n\u002B\n\u002B  status = _rcl_logging_rosout_clear_hashmap(\n\u002B    \u0026__logger_map, _rcl_logging_rosout_clear_logger_map_item, \u0026entry);\n\u002B  if (RCL_RET_OK != status) {\n\u002B    return status;\n\u002B  }\n\u002B\n\u002B  status = _rcl_logging_rosout_clear_hashmap(\n\u002B    \u0026__sublogger_map, _rcl_logging_rosout_clear_sublogger_map_item, \u0026sublogger_entry);\n\u002B  if (RCL_RET_OK != status) {\n\u002B    return status;\n   }\n\u002B\n\u002B  __is_initialized = false;\n\u002B\n   return status;\n }\n \n@@ -215,11 \u002B313,12 @@ rcl_ret_t rcl_logging_rosout_fini_publisher_for_node(rcl_node_t * node)\n \n   // fini the publisher and remove the entry from the map\n   status = rcl_ret_from_rcutils_ret(rcutils_hash_map_get(\u0026__logger_map, \u0026logger_name, \u0026entry));\n-  if (RCL_RET_OK == status) {\n\u002B  if (RCL_RET_OK == status \u0026\u0026 node == entry.node) {\n     status = rcl_publisher_fini(\u0026entry.publisher, entry.node);\n   }\n   if (RCL_RET_OK == status) {\n-    status = rcl_ret_from_rcutils_ret(rcutils_hash_map_unset(\u0026__logger_map, \u0026logger_name));\n\u002B    // delete all entries using this node\n\u002B    status = rcl_ret_from_rcutils_ret(_rcl_logging_rosout_remove_logger_map(entry.node));\n   }\n \n   return status;\n@@ -292,3 \u002B391,159 @@ void rcl_logging_rosout_output_handler(\n     }\n   }\n }\n\u002B\n\u002Bstatic rcl_ret_t\n\u002B_rcl_logging_rosout_get_full_sublogger_name(\n\u002B  const char * logger_name, const char * sublogger_name, char ** full_sublogger_name)\n\u002B{\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(logger_name, RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(sublogger_name, RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(full_sublogger_name, RCL_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  if (logger_name[0] == \u0027\\0\u0027 || sublogger_name[0] == \u0027\\0\u0027) {\n\u002B    RCL_SET_ERROR_MSG(\u0022logger name or sub-logger name can\u0027t be empty.\u0022);\n\u002B    return RCL_RET_INVALID_ARGUMENT;\n\u002B  }\n\u002B\n\u002B  *full_sublogger_name = rcutils_format_string(\n\u002B    __rosout_allocator, \u0022%s%s%s\u0022,\n\u002B    logger_name, RCUTILS_LOGGING_SEPARATOR_STRING, sublogger_name);\n\u002B  if (NULL == *full_sublogger_name) {\n\u002B    RCL_SET_ERROR_MSG(\u0022Failed to allocate a full sublogger name.\u0022);\n\u002B    return RCL_RET_BAD_ALLOC;\n\u002B  }\n\u002B\n\u002B  return RCL_RET_OK;\n\u002B}\n\u002B\n\u002Brcl_ret_t\n\u002Brcl_logging_rosout_add_sublogger(\n\u002B  const char * logger_name, const char * sublogger_name)\n\u002B{\n\u002B  if (!__is_initialized) {\n\u002B    return RCL_RET_OK;\n\u002B  }\n\u002B\n\u002B  rcl_ret_t status = RCL_RET_OK;\n\u002B  char * full_sublogger_name = NULL;\n\u002B  uint64_t * sublogger_count = NULL;\n\u002B  rosout_map_entry_t entry;\n\u002B  rosout_sublogger_entry_t sublogger_entry;\n\u002B\n\u002B  status =\n\u002B    _rcl_logging_rosout_get_full_sublogger_name(logger_name, sublogger_name, \u0026full_sublogger_name);\n\u002B  if (RCL_RET_OK != status) {\n\u002B    // Error already set\n\u002B    return status;\n\u002B  }\n\u002B\n\u002B  rcutils_ret_t rcutils_ret = rcutils_hash_map_get(\u0026__logger_map, \u0026logger_name, \u0026entry);\n\u002B  if (RCUTILS_RET_OK != rcutils_ret) {\n\u002B    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022The entry of logger \u0027%s\u0027 not exist.\u0022, logger_name);\n\u002B    status = RCL_RET_ERROR;\n\u002B    goto cleanup;\n\u002B  }\n\u002B\n\u002B  if (rcutils_hash_map_key_exists(\u0026__logger_map, \u0026full_sublogger_name)) {\n\u002B    // To get the entry and increase the reference count\n\u002B    status = rcl_ret_from_rcutils_ret(\n\u002B      rcutils_hash_map_get(\u0026__sublogger_map, \u0026full_sublogger_name, \u0026sublogger_entry));\n\u002B    if (RCL_RET_OK != status) {\n\u002B      RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B        \u0022Failed to get item from sublogger map for \u0027%s\u0027.\u0022, full_sublogger_name);\n\u002B      goto cleanup;\n\u002B    }\n\u002B    *sublogger_entry.count \u002B= 1;\n\u002B    goto cleanup;\n\u002B  }\n\u002B\n\u002B  status = rcl_ret_from_rcutils_ret(\n\u002B    rcutils_hash_map_set(\u0026__logger_map, \u0026full_sublogger_name, \u0026entry));\n\u002B  if (RCL_RET_OK != status) {\n\u002B    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022Failed to add publisher to map for logger \u0027%s\u0027.\u0022, full_sublogger_name);\n\u002B    goto cleanup;\n\u002B  }\n\u002B\n\u002B  sublogger_entry.name = full_sublogger_name;\n\u002B  sublogger_count = __rosout_allocator.allocate(sizeof(uint64_t), __rosout_allocator.state);\n\u002B  if (!sublogger_count) {\n\u002B    RCL_SET_ERROR_MSG(\n\u002B      \u0022Failed to allocate memory for count of sublogger entry.\u0022);\n\u002B    goto cleanup;\n\u002B  }\n\u002B  sublogger_entry.count = sublogger_count;\n\u002B  *sublogger_entry.count = 1;\n\u002B\n\u002B  status = rcl_ret_from_rcutils_ret(\n\u002B    rcutils_hash_map_set(\u0026__sublogger_map, \u0026full_sublogger_name, \u0026sublogger_entry));\n\u002B  if (RCL_RET_OK != status) {\n\u002B    // revert the previor set operation for __logger_map\n\u002B    rcutils_ret_t rcutils_ret = rcutils_hash_map_unset(\u0026__logger_map, \u0026full_sublogger_name);\n\u002B    if (RCUTILS_RET_OK != rcutils_ret) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022failed to unset hashmap: \u0022);\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n\u002B      rcl_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    }\n\u002B    goto cleanup_count;\n\u002B  }\n\u002B\n\u002B  return status;\n\u002B\n\u002Bcleanup_count:\n\u002B  __rosout_allocator.deallocate(sublogger_count, __rosout_allocator.state);\n\u002Bcleanup:\n\u002B  __rosout_allocator.deallocate(full_sublogger_name, __rosout_allocator.state);\n\u002B  return status;\n\u002B}\n\u002B\n\u002Brcl_ret_t\n\u002Brcl_logging_rosout_remove_sublogger(\n\u002B  const char * logger_name, const char * sublogger_name)\n\u002B{\n\u002B  if (!__is_initialized) {\n\u002B    return RCL_RET_OK;\n\u002B  }\n\u002B\n\u002B  rcl_ret_t status = RCL_RET_OK;\n\u002B  char * full_sublogger_name = NULL;\n\u002B  rosout_sublogger_entry_t sublogger_entry;\n\u002B\n\u002B  status =\n\u002B    _rcl_logging_rosout_get_full_sublogger_name(logger_name, sublogger_name, \u0026full_sublogger_name);\n\u002B  if (RCL_RET_OK != status) {\n\u002B    // Error already set\n\u002B    return status;\n\u002B  }\n\u002B\n\u002B  // remove the entry from the map\n\u002B  if (!rcutils_hash_map_key_exists(\u0026__logger_map, \u0026full_sublogger_name)) {\n\u002B    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022Sub-logger \u0027%s\u0027 not exist.\u0022, full_sublogger_name);\n\u002B    status = RCL_RET_ERROR;\n\u002B    goto cleanup;\n\u002B  }\n\u002B\n\u002B  status = rcl_ret_from_rcutils_ret(\n\u002B    rcutils_hash_map_get(\u0026__sublogger_map, \u0026full_sublogger_name, \u0026sublogger_entry));\n\u002B  if (RCL_RET_OK != status) {\n\u002B    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022Failed to get item from sublogger map for \u0027%s\u0027.\u0022, full_sublogger_name);\n\u002B    goto cleanup;\n\u002B  }\n\u002B\n\u002B  *sublogger_entry.count -= 1;\n\u002B  if (*sublogger_entry.count == 0) {\n\u002B    status = rcl_ret_from_rcutils_ret(rcutils_hash_map_unset(\u0026__logger_map, \u0026full_sublogger_name));\n\u002B    if (RCL_RET_OK == status) {\n\u002B      status =\n\u002B        rcl_ret_from_rcutils_ret(rcutils_hash_map_unset(\u0026__sublogger_map, \u0026full_sublogger_name));\n\u002B      __rosout_allocator.deallocate(sublogger_entry.name, __rosout_allocator.state);\n\u002B      __rosout_allocator.deallocate(sublogger_entry.count, __rosout_allocator.state);\n\u002B    }\n\u002B  }\n\u002B\n\u002Bcleanup:\n\u002B  __rosout_allocator.deallocate(full_sublogger_name, __rosout_allocator.state);\n\u002B  return status;\n\u002B}\ndiff --git rcl/test/rcl/test_logging_rosout.cpp rcl/test/rcl/test_logging_rosout.cpp\nindex 224d180..50ad8cf 100644\n--- rcl/test/rcl/test_logging_rosout.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_logging_rosout.cpp\n@@ -67,16 \u002B67,14 @@ std::ostream \u0026 operator\u003C\u003C(\n \n class CLASSNAME (TestLogRosoutFixtureNotParam, RMW_IMPLEMENTATION) : public ::testing::Test {};\n \n-class TEST_FIXTURE_P_RMW (TestLoggingRosoutFixture)\n-  : public ::testing::TestWithParam\u003CTestParameters\u003E\n\u002Bclass TestLoggingRosout : public ::testing::Test\n {\n-public:\n\u002Bprotected:\n   void SetUp()\n   {\n-    auto param = GetParam();\n     rcl_ret_t ret;\n     rcl_allocator_t allocator = rcl_get_default_allocator();\n-    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B    init_options = rcl_get_zero_initialized_init_options();\n     ret = rcl_init_options_init(\u0026init_options, allocator);\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n     OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n@@ -85,9 \u002B83,7 @@ public:\n     });\n     this-\u003Econtext_ptr = new rcl_context_t;\n     *this-\u003Econtext_ptr = rcl_get_zero_initialized_context();\n-\n-    ret = rcl_init(param.argc, param.argv, \u0026init_options, this-\u003Econtext_ptr);\n-    ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B    call_rcl_init();\n \n     EXPECT_EQ(\n       RCL_RET_OK,\n@@ -95,15 \u002B91,15 @@ public:\n     ) \u003C\u003C rcl_get_error_string().str;\n \n     // create node\n-    rcl_node_options_t node_options = rcl_node_get_default_options();\n-    if (!param.enable_node_option_rosout) {\n-      node_options.enable_rosout = param.enable_node_option_rosout;\n-    }\n\u002B    node_options = rcl_node_get_default_options();\n\u002B    update_node_option();\n     const char * name = \u0022test_rcl_node_logging_rosout\u0022;\n     const char * namespace_ = \u0022/ns\u0022;\n\u002B\n     this-\u003Enode_ptr = new rcl_node_t;\n     *this-\u003Enode_ptr = rcl_get_zero_initialized_node();\n-    ret = rcl_node_init(this-\u003Enode_ptr, name, namespace_, this-\u003Econtext_ptr, \u0026node_options);\n\u002B    ret = rcl_node_init(\n\u002B      this-\u003Enode_ptr, name, namespace_, this-\u003Econtext_ptr, \u0026node_options);\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n \n     // create rosout subscription\n@@ -134,12 \u002B130,49 @@ public:\n     EXPECT_EQ(RCL_RET_OK, rcl_logging_fini()) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-protected:\n\u002B  virtual void call_rcl_init()\n\u002B  {\n\u002B    rcl_ret_t ret = rcl_init(0, NULL, \u0026init_options, this-\u003Econtext_ptr);\n\u002B    ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  }\n\u002B\n\u002B  virtual void update_node_option() {}\n\u002B\n\u002B  rcl_init_options_t init_options;\n\u002B  rcl_node_options_t node_options;\n   rcl_context_t * context_ptr;\n   rcl_node_t * node_ptr;\n   rcl_subscription_t * subscription_ptr;\n };\n \n\u002Bclass TEST_FIXTURE_P_RMW (TestLoggingRosoutFixture)\n\u002B  : public TestLoggingRosout, public ::testing::WithParamInterface\u003CTestParameters\u003E\n\u002B{\n\u002Bprotected:\n\u002B  void SetUp()\n\u002B  {\n\u002B    param_ = GetParam();\n\u002B    TestLoggingRosout::SetUp();\n\u002B  }\n\u002B\n\u002B  void call_rcl_init()\n\u002B  {\n\u002B    rcl_ret_t ret = rcl_init(param_.argc, param_.argv, \u0026init_options, this-\u003Econtext_ptr);\n\u002B    ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  }\n\u002B\n\u002B  void update_node_option()\n\u002B  {\n\u002B    if (!param_.enable_node_option_rosout) {\n\u002B      node_options.enable_rosout = param_.enable_node_option_rosout;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  TestParameters param_;\n\u002B};\n\u002B\n\u002Bclass CLASSNAME (TestLogRosoutFixtureGeneral, RMW_IMPLEMENTATION) : public TestLoggingRosout {};\n\u002B\n void\n check_if_rosout_subscription_gets_a_message(\n   const char * logger_name,\n@@ -159,8 \u002B192,9 @@ check_if_rosout_subscription_gets_a_message(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   });\n   size_t iteration = 0;\n\u002B  const char * message = \u0022SOMETHING\u0022;\n\u002B  RCUTILS_LOG_INFO_NAMED(logger_name, message);\n   do {\n-    RCUTILS_LOG_INFO_NAMED(logger_name, \u0022SOMETHING\u0022);\n     \u002B\u002Biteration;\n     ret = rcl_wait_set_clear(\u0026wait_set);\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -173,8 \u002B207,16 @@ check_if_rosout_subscription_gets_a_message(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n     for (size_t i = 0; i \u003C wait_set.size_of_subscriptions; \u002B\u002Bi) {\n       if (wait_set.subscriptions[i] \u0026\u0026 wait_set.subscriptions[i] == subscription) {\n-        success = true;\n-        return;\n\u002B        rcl_interfaces__msg__Log * log_message = rcl_interfaces__msg__Log__create();\n\u002B        OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B        {\n\u002B          rcl_interfaces__msg__Log__destroy(log_message);\n\u002B        });\n\u002B        ret = rcl_take(subscription, log_message, nullptr, nullptr);\n\u002B        if (RCL_RET_OK == ret \u0026\u0026 strcmp(message, log_message-\u003Emsg.data) == 0) {\n\u002B          success = true;\n\u002B          return;\n\u002B        }\n       }\n     }\n   } while (iteration \u003C max_tries);\n@@ -315,3 \u002B357,122 @@ TEST_F(\n \n   EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_fini());\n }\n\u002B\n\u002B/* Testing basic of adding and removing sublogger\n\u002B */\n\u002BTEST_F(\n\u002B  CLASSNAME(TestLogRosoutFixtureGeneral, RMW_IMPLEMENTATION), test_add_remove_sublogger_basic)\n\u002B{\n\u002B  const char * logger_name = rcl_node_get_logger_name(this-\u003Enode_ptr);\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_add_sublogger(nullptr, nullptr));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_add_sublogger(nullptr, \u0022child\u0022));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_add_sublogger(logger_name, nullptr));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_add_sublogger(logger_name, \u0022\u0022));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_add_sublogger(\u0022\u0022, \u0022child\u0022));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_ERROR, rcl_logging_rosout_add_sublogger(\u0022no_exist\u0022, \u0022child\u0022));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_remove_sublogger(nullptr, nullptr));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_remove_sublogger(nullptr, \u0022child\u0022));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_remove_sublogger(logger_name, nullptr));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_remove_sublogger(logger_name, \u0022\u0022));\n\u002B  rcl_reset_error();\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_logging_rosout_remove_sublogger(\u0022\u0022, \u0022child\u0022));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, \u0022child\u0022));\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, \u0022child\u0022));\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, \u0022child1\u0022));\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, \u0022child1\u0022));\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, \u0022child1\u0022));\n\u002B  // contine to remove it immediately or call rcl_logging_fini later\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, \u0022child1\u0022));\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, \u0022child2\u0022));\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, \u0022child2\u0022));\n\u002B  EXPECT_EQ(RCL_RET_ERROR, rcl_logging_rosout_remove_sublogger(logger_name, \u0022child2\u0022));\n\u002B  rcl_reset_error();\n\u002B}\n\u002B\n\u002B/* Testing rosout message while adding and removing sublogger\n\u002B */\n\u002BTEST_F(\n\u002B  CLASSNAME(TestLogRosoutFixtureGeneral, RMW_IMPLEMENTATION), test_add_remove_sublogger_message)\n\u002B{\n\u002B  const char * logger_name = rcl_node_get_logger_name(this-\u003Enode_ptr);\n\u002B  const char * sublogger_name = \u0022child\u0022;\n\u002B  std::string full_sublogger_name =\n\u002B    logger_name \u002B std::string(RCUTILS_LOGGING_SEPARATOR_STRING) \u002B sublogger_name;\n\u002B\n\u002B  // not to get the message before adding the sublogger\n\u002B  bool expected;\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_FALSE(expected);\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, sublogger_name));\n\u002B\n\u002B  // to get the message after adding the sublogger\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_TRUE(expected);\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, sublogger_name));\n\u002B  // not to get the message after removing the sublogger\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_FALSE(expected);\n\u002B}\n\u002B\n\u002B/* Testing rosout message while adding and removing sublogger multiple times\n\u002B */\n\u002BTEST_F(\n\u002B  CLASSNAME(TestLogRosoutFixtureGeneral, RMW_IMPLEMENTATION),\n\u002B  test_multi_add_remove_sublogger_message)\n\u002B{\n\u002B  const char * logger_name = rcl_node_get_logger_name(this-\u003Enode_ptr);\n\u002B  const char * sublogger_name = \u0022child\u0022;\n\u002B  std::string full_sublogger_name =\n\u002B    logger_name \u002B std::string(RCUTILS_LOGGING_SEPARATOR_STRING) \u002B sublogger_name;\n\u002B  bool expected;\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, sublogger_name));\n\u002B\n\u002B  // add sublogger twice, expect RCL_RET_OK\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_add_sublogger(logger_name, sublogger_name));\n\u002B\n\u002B  // to get the message after adding the sublogger\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_TRUE(expected);\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, sublogger_name));\n\u002B  // to get the message after removing the sublogger if remove sublogger once\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_TRUE(expected);\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_OK, rcl_logging_rosout_remove_sublogger(logger_name, sublogger_name));\n\u002B  // to get the message after removing the sublogger\n\u002B  check_if_rosout_subscription_gets_a_message(\n\u002B    full_sublogger_name.c_str(), this-\u003Esubscription_ptr,\n\u002B    this-\u003Econtext_ptr, 30, 100, expected);\n\u002B  EXPECT_FALSE(expected);\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "8a8e46d7e92a7f6baf7d5ec655c22ffeee53efb2",
    "RawMessage": "Set CMakeLists to only use default rmw for benchmarks (#1427)",
    "Changes": "diff --git rclcpp/test/benchmark/CMakeLists.txt rclcpp/test/benchmark/CMakeLists.txt\nindex 3cb9e658..d7d7e539 100644\n--- rclcpp/test/benchmark/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/benchmark/CMakeLists.txt\n@@ -1,69 \u002B1,15 @@\n find_package(performance_test_fixture REQUIRED)\n \n-#\n-# Add a rmw-specific performance benchmark test from performance_test_fixture\n-#\n-# :param NAME: the target name which will also be used as the test name\n-# :type NAME: string\n-# :param SOURCE: the benchmark test target\u0027s source file\n-# :type SOURCE: string\n-# :param AMENT_DEPENDS: the ament dependincies for the benchmark test target\n-# :type list of strings\n-# :param LIBRARIES: the additional libraries the target needs to be linked\n-#    against\n-# :type list of strings\n-# :param TEST_OPTIONS: arguments to pass directly to add_performance_test\n-# :type list of strings\n-function(add_rclcpp_benchmark NAME SOURCE)\n-  set(multiValueArgs AMENT_DEPENDS LIBRARIES TEST_OPTIONS)\n-  cmake_parse_arguments(\n-    RCLCPP_BENCHMARK\n-    \u0022\u0022\n-    \u0022\u0022\n-    \u0022${multiValueArgs}\u0022\n-    \u0022${ARGN}\u0022)\n-  if(RCLCPP_BENCHMARK_UNPARSED_ARGUMENTS)\n-    message(\n-      FATAL_ERROR\n-      \u0022Unrecognized arguments for \u0027add_rclcpp_benchmark\u0027\u0022\n-      \u0022 (${RCLCPP_BENCHMARK_UNPARSED_ARGUMENTS})\u0022)\n-    return()\n-  endif()\n-  find_package(${rmw_implementation} REQUIRED)\n-  message(STATUS \u0022Adding ${NAME} for \u0027${rmw_implementation}\u0027\u0022)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-\n-  set(full_benchmark_name ${NAME}${target_suffix})\n-  add_performance_test(\n-    ${full_benchmark_name}\n-    ${SOURCE}\n-    ${RCLCPP_BENCHMARK_TEST_OPTIONS}\n-    ENV ${rmw_implementation_env_var})\n-  if(TARGET ${full_benchmark_name})\n-    if(RCLCPP_BENCHMARK_AMENT_DEPENDS)\n-      ament_target_dependencies(\n-        ${full_benchmark_name}\n-        ${RCLCPP_BENCHMARK_AMENT_DEPENDS})\n-    endif()\n-    target_link_libraries(\n-      ${full_benchmark_name}\n-      ${PROJECT_NAME}\n-      ${RCLCPP_BENCHMARK_LIBRARIES})\n-  endif()\n-endfunction()\n-\n-# Add new benchmarks inside this macro\n-macro(rclcpp_benchmarks)\n-  add_rclcpp_benchmark(benchmark_init_shutdown benchmark_init_shutdown.cpp)\n-\n-  set(SKIP_TEST \u0022\u0022)\n-  if(${rmw_implementation} MATCHES \u0022(.*)connext(.*)\u0022)\n-    set(SKIP_TEST \u0022SKIP_TEST\u0022)\n-  endif()\n-  add_rclcpp_benchmark(\n-    benchmark_node\n-    benchmark_node.cpp\n-    TEST_OPTIONS ${SKIP_TEST})\n-endmacro()\n-\n-call_for_each_rmw_implementation(rclcpp_benchmarks)\n\u002B# These benchmarks are only being created and run for the default RMW\n\u002B# implementation. We are looking to test the performance of the ROS 2 code, not\n\u002B# the underlying middleware.\n\u002B\n\u002Badd_performance_test(benchmark_init_shutdown benchmark_init_shutdown.cpp)\n\u002Bif(TARGET benchmark_init_shutdown)\n\u002B  target_link_libraries(benchmark_init_shutdown ${PROJECT_NAME})\n\u002Bendif()\n\u002B\n\u002Badd_performance_test(benchmark_node benchmark_node.cpp)\n\u002Bif(TARGET benchmark_node)\n\u002B  target_link_libraries(benchmark_node ${PROJECT_NAME})\n\u002Bendif()\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "34fe5795dacb07398e1606f436a77d17b1ed5ae7",
    "RawMessage": "Add types to rcutils_logger.py (#1249)",
    "Changes": "diff --git rclpy/rclpy/impl/rcutils_logger.py rclpy/rclpy/impl/rcutils_logger.py\nindex c14cd79..0415663 100644\n--- rclpy/rclpy/impl/rcutils_logger.py\n\u002B\u002B\u002B rclpy/rclpy/impl/rcutils_logger.py\n@@ -12,23 \u002B12,44 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-\n-from collections import namedtuple\n-from collections import OrderedDict\n\u002Bfrom contextlib import suppress\n import inspect\n import os\n\u002Bimport sys\n\u002Bfrom types import FrameType\n\u002Bfrom typing import cast\n\u002Bfrom typing import ClassVar\n\u002Bfrom typing import Dict\n\u002Bfrom typing import List\n\u002Bfrom typing import Literal\n\u002Bfrom typing import NamedTuple\n\u002Bfrom typing import Optional\n\u002Bfrom typing import OrderedDict\n\u002Bfrom typing import Tuple\n\u002Bfrom typing import Type\n\u002Bfrom typing import TypedDict\n\u002Bfrom typing import Union\n \n from rclpy.clock import Clock\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.impl.logging_severity import LoggingSeverity\n \n\u002Bif sys.version_info \u003E= (3, 12):\n\u002B    from typing import Unpack\n\u002Belse:\n\u002B    with suppress(ModuleNotFoundError):\n\u002B        from typing_extensions import Unpack\n\u002B\n\u002B\n\u002BSupportedFiltersKeys = Literal[\u0027throttle\u0027, \u0027skip_first\u0027, \u0027once\u0027]\n\u002B\n # Known filenames from which logging methods can be called (will be ignored in \u0060_find_caller\u0060).\n-_internal_callers = []\n\u002B_internal_callers: List[str] = []\n # This will cause rclpy filenames to be registered in \u0060_internal_callers\u0060 on first logging call.\n _populate_internal_callers = True\n \n \n-def _find_caller(frame):\n\u002Bdef _find_caller(frame: Optional[FrameType]) -\u003E FrameType:\n     \u0022\u0022\u0022Get the first calling frame that is outside of rclpy.\u0022\u0022\u0022\n     global _populate_internal_callers\n     global _internal_callers\n@@ -44,17 \u002B65,28 @@ def _find_caller(frame):\n         ])\n         _populate_internal_callers = False\n \n\u002B    if frame is None:\n\u002B        raise ValueError(\u0027Cannot get frame info if frame is None\u0027)\n\u002B\n     file_path = os.path.realpath(inspect.getframeinfo(frame).filename)\n     while any(f in file_path for f in _internal_callers):\n         frame = frame.f_back\n\u002B\n\u002B        if frame is None:\n\u002B            raise ValueError(\u0027Cannot get frame info if frame is None\u0027)\n\u002B\n         file_path = os.path.realpath(inspect.getframeinfo(frame).filename)\n     return frame\n \n \n class CallerId(\n-        namedtuple(\u0027CallerId\u0027, [\u0027function_name\u0027, \u0027file_path\u0027, \u0027line_number\u0027, \u0027last_index\u0027])):\n\u002B        NamedTuple(\u0027CallerId\u0027,\n\u002B                   [(\u0027function_name\u0027, str),\n\u002B                    (\u0027file_path\u0027, str),\n\u002B                    (\u0027line_number\u0027, int),\n\u002B                    (\u0027last_index\u0027, int)])):\n \n-    def __new__(cls, frame=None):\n\u002B    def __new__(cls, frame: Optional[FrameType] = None) -\u003E \u0027CallerId\u0027:\n         if not frame:\n             frame = _find_caller(inspect.currentframe())\n         return super(CallerId, cls).__new__(\n@@ -66,6 \u002B98,44 @@ class CallerId(\n         )\n \n \n\u002Bclass RcutilsLoggerContext(TypedDict):\n\u002B    name: str\n\u002B    severity: LoggingSeverity\n\u002B    filters: List[SupportedFiltersKeys]\n\u002B\n\u002B\n\u002Bclass OnceContext(RcutilsLoggerContext):\n\u002B    has_been_logged_once: bool\n\u002B\n\u002B\n\u002Bclass ThrottleContext(RcutilsLoggerContext):\n\u002B    throttle_duration_sec: float\n\u002B    throttle_time_source_type: Clock\n\u002B    throttle_last_logged: int\n\u002B\n\u002B\n\u002Bclass SkipFirstContext(RcutilsLoggerContext):\n\u002B    first_has_been_skipped: bool\n\u002B\n\u002B\n\u002Bclass LoggingFilterArgs(TypedDict, total=False):\n\u002B    once: bool\n\u002B    throttle_duration_sec: float\n\u002B    throttle_time_source_type: Clock\n\u002B    skip_first: bool\n\u002B\n\u002B\n\u002Bclass LoggingFilterParams(TypedDict, total=False):\n\u002B    once: Optional[bool]\n\u002B    throttle_duration_sec: Optional[float]\n\u002B    throttle_time_source_type: Clock\n\u002B    skip_first: Optional[bool]\n\u002B\n\u002B\n\u002Bclass LoggingArgs(LoggingFilterArgs, total=False):\n\u002B    name: str\n\u002B\n\u002B\n class LoggingFilter:\n     \u0022\u0022\u0022Base class for logging filters.\u0022\u0022\u0022\n \n@@ -74,44 \u002B144,49 @@ class LoggingFilter:\n \n     A default value of None makes a parameter required.\n     \u0022\u0022\u0022\n-    params = {}\n\u002B    params: ClassVar[LoggingFilterParams] = {}\n \n     \u0022\u0022\u0022\n     Initialize the context of a logging call, e.g. declare variables needed for\n     determining the log condition and add them to the context.\n     \u0022\u0022\u0022\n     @classmethod\n-    def initialize_context(cls, context, **kwargs):\n\u002B    def initialize_context(cls, context: RcutilsLoggerContext,\n\u002B                           **kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E None:\n         # Store all parameters in the context so we can check that users never try to change them.\n-        for param in cls.params:\n-            context[param] = kwargs.get(param, cls.params[param])\n-            if context[param] is None:\n\u002B        for param_name, param_value in cls.params.items():\n\u002B            kwargs_value = kwargs.get(param_name, param_value)\n\u002B            if kwargs_value is None:\n                 raise TypeError(\n                     \u0027Required parameter \u0022{0}\u0022 was not specified for logging filter \u0022{1}\u0022\u0027\n-                    .format(param, cls.__name__))\n\u002B                    .format(param_name, cls.__name__))\n\u002B            context[param_name] = kwargs_value  # type: ignore[literal-required]\n \n     \u0022\u0022\u0022\n     Decide if it\u0027s appropriate to log given a context, and update the context accordingly.\n     \u0022\u0022\u0022\n     @staticmethod\n-    def should_log(context):\n\u002B    def should_log(context: RcutilsLoggerContext) -\u003E bool:\n         return True\n \n \n class Once(LoggingFilter):\n     \u0022\u0022\u0022Ignore all log calls except the first one.\u0022\u0022\u0022\n \n-    params = {\n\u002B    params: ClassVar[LoggingFilterParams] = {\n         \u0027once\u0027: None,\n     }\n \n     @classmethod\n-    def initialize_context(cls, context, **kwargs):\n\u002B    def initialize_context(cls, context: RcutilsLoggerContext,\n\u002B                           **kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E None:\n\u002B        context = cast(OnceContext, context)\n         super(Once, cls).initialize_context(context, **kwargs)\n         context[\u0027has_been_logged_once\u0027] = False\n \n     @staticmethod\n-    def should_log(context):\n\u002B    def should_log(context: RcutilsLoggerContext) -\u003E bool:\n\u002B        context = cast(OnceContext, context)\n         logging_condition = False\n         if not context[\u0027has_been_logged_once\u0027]:\n             logging_condition = True\n@@ -122,13 \u002B197,15 @@ class Once(LoggingFilter):\n class Throttle(LoggingFilter):\n     \u0022\u0022\u0022Ignore log calls if the last call is not longer ago than the specified duration.\u0022\u0022\u0022\n \n-    params = {\n\u002B    params: ClassVar[LoggingFilterParams] = {\n         \u0027throttle_duration_sec\u0027: None,\n         \u0027throttle_time_source_type\u0027: Clock(),\n     }\n \n     @classmethod\n-    def initialize_context(cls, context, **kwargs):\n\u002B    def initialize_context(cls, context: RcutilsLoggerContext,\n\u002B                           **kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E None:\n\u002B        context = cast(ThrottleContext, context)\n         super(Throttle, cls).initialize_context(context, **kwargs)\n         context[\u0027throttle_last_logged\u0027] = 0\n         if not isinstance(context[\u0027throttle_time_source_type\u0027], Clock):\n@@ -138,7 \u002B215,8 @@ class Throttle(LoggingFilter):\n                 .format(context[\u0027throttle_time_source_type\u0027]))\n \n     @staticmethod\n-    def should_log(context):\n\u002B    def should_log(context: RcutilsLoggerContext) -\u003E bool:\n\u002B        context = cast(ThrottleContext, context)\n         logging_condition = True\n         now = context[\u0027throttle_time_source_type\u0027].now().nanoseconds\n         next_log_time = context[\u0027throttle_last_logged\u0027] \u002B (context[\u0027throttle_duration_sec\u0027] * 1e\u002B9)\n@@ -151,17 \u002B229,20 @@ class Throttle(LoggingFilter):\n class SkipFirst(LoggingFilter):\n     \u0022\u0022\u0022Ignore the first log call but process all subsequent calls.\u0022\u0022\u0022\n \n-    params = {\n\u002B    params: ClassVar[LoggingFilterParams] = {\n         \u0027skip_first\u0027: None,\n     }\n \n     @classmethod\n-    def initialize_context(cls, context, **kwargs):\n\u002B    def initialize_context(cls, context: RcutilsLoggerContext,\n\u002B                           **kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E None:\n\u002B        context = cast(SkipFirstContext, context)\n         super(SkipFirst, cls).initialize_context(context, **kwargs)\n         context[\u0027first_has_been_skipped\u0027] = False\n \n     @staticmethod\n-    def should_log(context):\n\u002B    def should_log(context: RcutilsLoggerContext) -\u003E bool:\n\u002B        context = cast(SkipFirstContext, context)\n         logging_condition = True\n         if not context[\u0027first_has_been_skipped\u0027]:\n             logging_condition = False\n@@ -170,20 \u002B251,20 @@ class SkipFirst(LoggingFilter):\n \n \n # The ordering of this dictionary defines the order in which filters will be processed.\n-supported_filters = OrderedDict()\n\u002Bsupported_filters: OrderedDict[SupportedFiltersKeys, Type[LoggingFilter]] = OrderedDict()\n supported_filters[\u0027throttle\u0027] = Throttle\n supported_filters[\u0027skip_first\u0027] = SkipFirst\n supported_filters[\u0027once\u0027] = Once\n \n \n-def get_filters_from_kwargs(**kwargs):\n\u002Bdef get_filters_from_kwargs(**kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E List[SupportedFiltersKeys]:\n     \u0022\u0022\u0022\n     Determine which filters have had parameters specified in the given keyword arguments.\n \n     Returns the list of filters using the order specified by \u0060supported_filters\u0060.\n     \u0022\u0022\u0022\n-    detected_filters = []\n-    all_supported_params = []\n\u002B    detected_filters: List[SupportedFiltersKeys] = []\n\u002B    all_supported_params: List[str] = []\n     for supported_filter, filter_class in supported_filters.items():\n         filter_params = filter_class.params.keys()\n         all_supported_params.extend(filter_params)\n@@ -201,7 \u002B282,7 @@ def get_filters_from_kwargs(**kwargs):\n                     \u0027required parameter \u0022{0}\u0022 not specified \u0027\n                     \u0027but is required for the the logging filter \u0022{1}\u0022\u0027.format(\n                         param_name, detected_filter))\n-            kwargs[param_name] = default_value\n\u002B            kwargs[param_name] = default_value  # type: ignore\n     for kwarg in kwargs:\n         if kwarg not in all_supported_params:\n             raise TypeError(\n@@ -213,18 \u002B294,18 @@ def get_filters_from_kwargs(**kwargs):\n \n class RcutilsLogger:\n \n-    def __init__(self, name=\u0027\u0027):\n\u002B    def __init__(self, name: str = \u0027\u0027) -\u003E None:\n         self.name = name\n-        self.logger_sublogger_namepair = None\n-        self.contexts = {}\n\u002B        self.logger_sublogger_namepair: Optional[Tuple[str, str]] = None\n\u002B        self.contexts: Dict[CallerId, RcutilsLoggerContext] = {}\n \n-    def __del__(self):\n\u002B    def __del__(self) -\u003E None:\n         if self.logger_sublogger_namepair:\n             _rclpy.rclpy_logging_rosout_remove_sublogger(\n                 self.logger_sublogger_namepair[0], self.logger_sublogger_namepair[1])\n             self.logger_sublogger_namepair = None\n \n-    def get_child(self, name):\n\u002B    def get_child(self, name: str) -\u003E \u0027RcutilsLogger\u0027:\n         if not name:\n             raise ValueError(\u0027Child logger name must not be empty.\u0027)\n \n@@ -239,20 \u002B320,22 @@ class RcutilsLogger:\n             logger.logger_sublogger_namepair = (self.name, name)\n         return logger\n \n-    def set_level(self, level):\n\u002B    def set_level(self, level: Union[int, LoggingSeverity]) -\u003E None:\n         level = LoggingSeverity(level)\n-        return _rclpy.rclpy_logging_set_logger_level(self.name, level)\n\u002B        _rclpy.rclpy_logging_set_logger_level(self.name, level)\n \n-    def get_effective_level(self):\n\u002B    def get_effective_level(self) -\u003E LoggingSeverity:\n         level = LoggingSeverity(\n             _rclpy.rclpy_logging_get_logger_effective_level(self.name))\n         return level\n \n-    def is_enabled_for(self, severity):\n\u002B    def is_enabled_for(self, severity: Union[int, LoggingSeverity]) -\u003E bool:\n         severity = LoggingSeverity(severity)\n-        return _rclpy.rclpy_logging_logger_is_enabled_for(self.name, severity)\n\u002B        result: bool = _rclpy.rclpy_logging_logger_is_enabled_for(self.name, severity)\n\u002B        return result\n \n-    def log(self, message, severity, **kwargs):\n\u002B    def log(self, message: str, severity: Union[int, LoggingSeverity],\n\u002B            name: Optional[str] = None, **kwargs: \u0027Unpack[LoggingFilterArgs]\u0027) -\u003E bool:\n         r\u0022\u0022\u0022\n         Log a message with the specified severity.\n \n@@ -265,10 \u002B348,9 @@ class RcutilsLogger:\n            Logging filters will only be evaluated if the logger is enabled for the message\u0027s\n            severity.\n \n-        :param message str: message to log.\n\u002B        :param message: message to log.\n         :param severity: severity of the message.\n-        :type severity: :py:class:LoggingSeverity\n-        :keyword name str: name of the logger to use.\n\u002B        :keyword name: name of the logger to use.\n         :param \\**kwargs: optional parameters for logging filters (see below).\n \n         :Keyword Arguments:\n@@ -284,7 \u002B366,6 @@ class RcutilsLogger:\n         :returns: False if a filter caused the message to not be logged; True otherwise.\n         :raises: TypeError on invalid filter parameter combinations.\n         :raises: ValueError on invalid parameters values.\n-        :rtype: bool\n         \u0022\u0022\u0022\n         # Gather context info and check filters only if the severity is appropriate.\n         if not self.is_enabled_for(severity):\n@@ -292,7 \u002B373,8 @@ class RcutilsLogger:\n \n         severity = LoggingSeverity(severity)\n \n-        name = kwargs.pop(\u0027name\u0027, self.name)\n\u002B        if name is None:\n\u002B            name = self.name\n \n         # Infer the requested log filters from the keyword arguments\n         detected_filters = get_filters_from_kwargs(**kwargs)\n@@ -300,11 \u002B382,11 @@ class RcutilsLogger:\n         # Get/prepare the context corresponding to the caller.\n         caller_id = CallerId()\n         if caller_id not in self.contexts:\n-            context = {\u0027name\u0027: name, \u0027severity\u0027: severity}\n\u002B            context: RcutilsLoggerContext = {\u0027name\u0027: name, \u0027severity\u0027: severity,\n\u002B                                             \u0027filters\u0027: detected_filters}\n             for detected_filter in detected_filters:\n                 if detected_filter in supported_filters:\n                     supported_filters[detected_filter].initialize_context(context, **kwargs)\n-            context[\u0027filters\u0027] = detected_filters\n             self.contexts[caller_id] = context\n         else:\n             context = self.contexts[caller_id]\n@@ -317,7 \u002B399,9 @@ class RcutilsLogger:\n                 raise ValueError(\u0027Requested logging filters cannot be changed between calls.\u0027)\n             for detected_filter in detected_filters:\n                 filter_params = supported_filters[detected_filter].params\n-                if any(context[p] != kwargs.get(p, filter_params[p]) for p in filter_params):\n\u002B                if any(\n\u002B                    context[p] != kwargs.get(p, filter_params[p])  # type: ignore\n\u002B                        for p in filter_params):\n                     raise ValueError(\n                         \u0027Logging filter parameters cannot be changed between calls.\u0027)\n \n@@ -334,19 \u002B418,19 @@ class RcutilsLogger:\n             caller_id.function_name, caller_id.file_path, caller_id.line_number)\n         return True\n \n-    def debug(self, message, **kwargs):\n\u002B    def debug(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022Log a message with \u0060DEBUG\u0060 severity via :py:classmethod:RcutilsLogger.log:.\u0022\u0022\u0022\n         return self.log(message, LoggingSeverity.DEBUG, **kwargs)\n \n-    def info(self, message, **kwargs):\n\u002B    def info(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022Log a message with \u0060INFO\u0060 severity via :py:classmethod:RcutilsLogger.log:.\u0022\u0022\u0022\n         return self.log(message, LoggingSeverity.INFO, **kwargs)\n \n-    def warning(self, message, **kwargs):\n\u002B    def warning(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022Log a message with \u0060WARN\u0060 severity via :py:classmethod:RcutilsLogger.log:.\u0022\u0022\u0022\n         return self.log(message, LoggingSeverity.WARN, **kwargs)\n \n-    def warn(self, message, **kwargs):\n\u002B    def warn(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022\n         Log a message with \u0060WARN\u0060 severity via :py:classmethod:RcutilsLogger.log:.\n \n@@ -354,10 \u002B438,10 @@ class RcutilsLogger:\n         \u0022\u0022\u0022\n         return self.warning(message, **kwargs)\n \n-    def error(self, message, **kwargs):\n\u002B    def error(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022Log a message with \u0060ERROR\u0060 severity via :py:classmethod:RcutilsLogger.log:.\u0022\u0022\u0022\n         return self.log(message, LoggingSeverity.ERROR, **kwargs)\n \n-    def fatal(self, message, **kwargs):\n\u002B    def fatal(self, message: str, **kwargs: \u0027Unpack[LoggingArgs]\u0027) -\u003E bool:\n         \u0022\u0022\u0022Log a message with \u0060FATAL\u0060 severity via :py:classmethod:RcutilsLogger.log:.\u0022\u0022\u0022\n         return self.log(message, LoggingSeverity.FATAL, **kwargs)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "realtime_support",
    "SHA": "196f68820db20edc15468f07914920fbd9427784",
    "RawMessage": "Fix up nonsensical handling of NULL in rttest_get_{params,statistics} (#107)",
    "Changes": "diff --git rttest/include/rttest/rttest.h rttest/include/rttest/rttest.h\nindex 5b19281..90f64a5 100644\n--- rttest/include/rttest/rttest.h\n\u002B\u002B\u002B rttest/include/rttest/rttest.h\n@@ -172,6 \u002B172,7 @@ int rttest_get_next_rusage(size_t i);\n int rttest_calculate_statistics(struct rttest_results * results);\n \n /// \\brief Get accumulated statistics\n\u002B/// \\return Error code if results struct is NULL\n int rttest_get_statistics(struct rttest_results * results);\n \n /// \\brief Get latency sample at the given iteration.\ndiff --git rttest/src/rttest.cpp rttest/src/rttest.cpp\nindex 0ec8cb6..d2bafa8 100644\n--- rttest/src/rttest.cpp\n\u002B\u002B\u002B rttest/src/rttest.cpp\n@@ -325,17 \u002B325,17 @@ int Rttest::read_args(int argc, char ** argv)\n \n int rttest_get_params(struct rttest_params * params_in)\n {\n\u002B  if (params_in == NULL) {\n\u002B    return -1;\n\u002B  }\n\u002B\n   auto thread_rttest_instance = get_rttest_thread_instance(pthread_self());\n \n   if (!thread_rttest_instance) {\n     return -1;\n   }\n \n-  if (params_in == NULL) {\n-    params_in = thread_rttest_instance-\u003Eget_params();\n-  } else {\n-    *params_in = *thread_rttest_instance-\u003Eget_params();\n-  }\n\u002B  *params_in = *thread_rttest_instance-\u003Eget_params();\n \n   return 0;\n }\n@@ -786,6 \u002B786,10 @@ int rttest_calculate_statistics(struct rttest_results * results)\n \n int rttest_get_statistics(struct rttest_results * output)\n {\n\u002B  if (output == NULL) {\n\u002B    return -1;\n\u002B  }\n\u002B\n   auto thread_rttest_instance = get_rttest_thread_instance(pthread_self());\n   if (!thread_rttest_instance) {\n     return -1;\n@@ -793,12 \u002B797,9 @@ int rttest_get_statistics(struct rttest_results * output)\n   if (!thread_rttest_instance-\u003Eresults_initialized) {\n     return -1;\n   }\n-  if (output == NULL) {\n-    output = \u0026thread_rttest_instance-\u003Eresults;\n-  } else {\n-    // if output is not null, try to copy the results struct into the memory location\n-    *output = thread_rttest_instance-\u003Eresults;\n-  }\n\u002B\n\u002B  // copy the results struct into the memory location\n\u002B  *output = thread_rttest_instance-\u003Eresults;\n \n   return 0;\n }\ndiff --git rttest/test/test_api.cpp rttest/test/test_api.cpp\nindex 32d9be7..10bd1be 100644\n--- rttest/test/test_api.cpp\n\u002B\u002B\u002B rttest/test/test_api.cpp\n@@ -46,6 \u002B46,7 @@ TEST(TestApi, read_args_get_params) {\n   };\n   EXPECT_EQ(0, rttest_read_args(argc, argv));\n   struct rttest_params params;\n\u002B  EXPECT_EQ(-1, rttest_get_params(NULL));\n   EXPECT_EQ(0, rttest_get_params(\u0026params));\n \n   EXPECT_EQ(params.iterations, 4321u);\n@@ -164,6 \u002B165,7 @@ TEST(TestApi, get_statistics) {\n   runtime_min_pgflts = usage.ru_minflt - initial_min_pgflts;\n   runtime_maj_pgflts = usage.ru_majflt - initial_maj_pgflts;\n   struct rttest_results results;\n\u002B  EXPECT_EQ(-1, rttest_get_statistics(NULL));\n   EXPECT_EQ(0, rttest_get_statistics(\u0026results));\n   EXPECT_EQ(runtime_min_pgflts, results.minor_pagefaults);\n   EXPECT_EQ(runtime_maj_pgflts, results.major_pagefaults);\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "launch_ros",
    "SHA": "af784b2f70d649c45330dc321e6101d84d328ef7",
    "RawMessage": "fix: return text value to avoid exception (#338)",
    "Changes": "diff --git launch_ros/launch_ros/substitutions/parameter.py launch_ros/launch_ros/substitutions/parameter.py\nindex 7e9a84f..6bacd04 100644\n--- launch_ros/launch_ros/substitutions/parameter.py\n\u002B\u002B\u002B launch_ros/launch_ros/substitutions/parameter.py\n@@ -95,7 \u002B95,7 @@ class Parameter(Substitution):\n         for param in params_container:\n             if isinstance(param, tuple):\n                 if param[0] == name:\n-                    return param[1]\n\u002B                    return str(param[1])\n \n         if self.__default is None:\n             raise SubstitutionFailure(\u0022parameter \u0027{}\u0027 not found\u0022.format(name))\n",
    "BackportedTo": "humble",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "b9ffd72f42ae44352256f2eab585299bf85c6346",
    "RawMessage": "Fix SEGV caused by order of destruction of Node sub-interfaces (#1469)",
    "Changes": "diff --git rclcpp/include/rclcpp/service.hpp rclcpp/include/rclcpp/service.hpp\nindex 5c741189..d36a18d4 100644\n--- rclcpp/include/rclcpp/service.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/service.hpp\n@@ -180,7 \u002B180,7 @@ public:\n     std::weak_ptr\u003Crcl_node_t\u003E weak_node_handle(node_handle_);\n     // rcl does the static memory allocation here\n     service_handle_ = std::shared_ptr\u003Crcl_service_t\u003E(\n-      new rcl_service_t, [weak_node_handle](rcl_service_t * service)\n\u002B      new rcl_service_t, [weak_node_handle, service_name](rcl_service_t * service)\n       {\n         auto handle = weak_node_handle.lock();\n         if (handle) {\n@@ -192,10 \u002B192,10 @@ public:\n             rcl_reset_error();\n           }\n         } else {\n-          RCLCPP_ERROR(\n\u002B          RCLCPP_ERROR_STREAM(\n             rclcpp::get_logger(\u0022rclcpp\u0022),\n-            \u0022Error in destruction of rcl service handle: \u0022\n-            \u0022the Node Handle was destructed too early. You will leak memory\u0022);\n\u002B            \u0022Error in destruction of rcl service handle \u0022 \u003C\u003C service_name \u003C\u003C\n\u002B              \u0022: the Node Handle was destructed too early. You will leak memory\u0022);\n         }\n         delete service;\n       });\ndiff --git rclcpp/src/rclcpp/node.cpp rclcpp/src/rclcpp/node.cpp\nindex 0ccec6ae..abe7b8fc 100644\n--- rclcpp/src/rclcpp/node.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node.cpp\n@@ -185,7 \u002B185,18 @@ Node::Node(\n }\n \n Node::~Node()\n-{}\n\u002B{\n\u002B  // release sub-interfaces in an order that allows them to consult with node_base during tear-down\n\u002B  node_waitables_.reset();\n\u002B  node_time_source_.reset();\n\u002B  node_parameters_.reset();\n\u002B  node_clock_.reset();\n\u002B  node_services_.reset();\n\u002B  node_topics_.reset();\n\u002B  node_timers_.reset();\n\u002B  node_logging_.reset();\n\u002B  node_graph_.reset();\n\u002B}\n \n const char *\n Node::get_name() const\ndiff --git rclcpp_lifecycle/src/lifecycle_node.cpp rclcpp_lifecycle/src/lifecycle_node.cpp\nindex a82878e8..e7408a35 100644\n--- rclcpp_lifecycle/src/lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node.cpp\n@@ -128,7 \u002B128,18 @@ LifecycleNode::LifecycleNode(\n }\n \n LifecycleNode::~LifecycleNode()\n-{}\n\u002B{\n\u002B  // release sub-interfaces in an order that allows them to consult with node_base during tear-down\n\u002B  node_waitables_.reset();\n\u002B  node_time_source_.reset();\n\u002B  node_parameters_.reset();\n\u002B  node_clock_.reset();\n\u002B  node_services_.reset();\n\u002B  node_topics_.reset();\n\u002B  node_timers_.reset();\n\u002B  node_logging_.reset();\n\u002B  node_graph_.reset();\n\u002B}\n \n const char *\n LifecycleNode::get_name() const\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "73d555b4026fec0c4350e8589571fb58f0e58651",
    "RawMessage": "Fix unnecessary allocations in executor.cpp (#2135)",
    "Changes": "diff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 32b895c1..9bafbe31 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -558,13 \u002B558,14 @@ Executor::execute_any_executable(AnyExecutable \u0026 any_exec)\n   }\n }\n \n\u002Btemplate\u003Ctypename Taker, typename Handler\u003E\n static\n void\n take_and_do_error_handling(\n   const char * action_description,\n   const char * topic_or_service_name,\n-  std::function\u003Cbool()\u003E take_action,\n-  std::function\u003Cvoid()\u003E handle_action)\n\u002B  Taker take_action,\n\u002B  Handler handle_action)\n {\n   bool taken = false;\n   try {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "3c66dee7083534299c8c35047a7fd647ac373003",
    "RawMessage": "Access the sample only when the received sample has the valid data",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex a055506..96bffc2 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -3090,36 \u002B3090,36 @@ static rmw_ret_t rmw_take_loan_int(\n           message_info-\u003Epublisher_gid.data, \u0026info.publication_handle,\n           sizeof(info.publication_handle));\n       }\n-    }\n-    if (d-\u003Eiox_chunk != nullptr) {\n-      *loaned_message = SHIFT_PAST_ICEORYX_HEADER(d-\u003Eiox_chunk);\n-      *taken = true;\n-      // doesn\u0027t allocate, but initialise the allocator to free the chunk later\n-      dds_data_allocator_init(\n-        cdds_subscription-\u003Eenth, \u0026cdds_subscription-\u003Edata_allocator);\n-      return RMW_RET_OK;\n-    } else if (d-\u003Etype-\u003Eiox_size \u003E 0U) {\n-      // allocate on the heap\n-      dds_data_allocator_init_heap(\u0026cdds_subscription-\u003Edata_allocator);\n-      auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(d-\u003Etype-\u003Eiox_size);\n-      auto chunk_ptr = dds_data_allocator_alloc(\n-        \u0026cdds_subscription-\u003Edata_allocator, chunk_size);\n-      RMW_CHECK_FOR_NULL_WITH_MSG(\n-        chunk_ptr,\n-        \u0022Failed to allocate memory for the received sample\u0022,\n-        return RMW_RET_ERROR);\n-      auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n-      ice_hdr-\u003Edata_size = d-\u003Etype-\u003Eiox_size;\n-      auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-      rmw_cyclonedds_cpp::init_message(\u0026cdds_subscription-\u003Etype_supports, ptr);\n-      ddsi_serdata_to_sample(d, ptr, nullptr, nullptr);\n-      *loaned_message = ptr;\n-      *taken = true;\n-      return RMW_RET_OK;\n-    } else {\n-      RMW_SET_ERROR_MSG(\u0022Data nor loan is available to take\u0022);\n-      *taken = false;\n-      return RMW_RET_ERROR;\n\u002B      if (d-\u003Eiox_chunk != nullptr) {\n\u002B        *loaned_message = SHIFT_PAST_ICEORYX_HEADER(d-\u003Eiox_chunk);\n\u002B        *taken = true;\n\u002B        // doesn\u0027t allocate, but initialise the allocator to free the chunk later\n\u002B        dds_data_allocator_init(\n\u002B          cdds_subscription-\u003Eenth, \u0026cdds_subscription-\u003Edata_allocator);\n\u002B        return RMW_RET_OK;\n\u002B      } else if (d-\u003Etype-\u003Eiox_size \u003E 0U) {\n\u002B        // allocate on the heap\n\u002B        dds_data_allocator_init_heap(\u0026cdds_subscription-\u003Edata_allocator);\n\u002B        auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(d-\u003Etype-\u003Eiox_size);\n\u002B        auto chunk_ptr = dds_data_allocator_alloc(\n\u002B          \u0026cdds_subscription-\u003Edata_allocator, chunk_size);\n\u002B        RMW_CHECK_FOR_NULL_WITH_MSG(\n\u002B          chunk_ptr,\n\u002B          \u0022Failed to allocate memory for the received sample\u0022,\n\u002B          return RMW_RET_ERROR);\n\u002B        auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n\u002B        ice_hdr-\u003Edata_size = d-\u003Etype-\u003Eiox_size;\n\u002B        auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n\u002B        rmw_cyclonedds_cpp::init_message(\u0026cdds_subscription-\u003Etype_supports, ptr);\n\u002B        ddsi_serdata_to_sample(d, ptr, nullptr, nullptr);\n\u002B        *loaned_message = ptr;\n\u002B        *taken = true;\n\u002B        return RMW_RET_OK;\n\u002B      } else {\n\u002B        RMW_SET_ERROR_MSG(\u0022Data nor loan is available to take\u0022);\n\u002B        *taken = false;\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n     }\n   }\n   *taken = false;\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "d2901dded38267b59b6d492cb64425c5bcacf650",
    "RawMessage": "Improve documentation in rclpy.utilities (#1038)",
    "Changes": "diff --git rclpy/rclpy/utilities.py rclpy/rclpy/utilities.py\nindex 753a78c..1e6d501 100644\n--- rclpy/rclpy/utilities.py\n\u002B\u002B\u002B rclpy/rclpy/utilities.py\n@@ -18,6 \u002B18,7 @@ import threading\n from typing import List\n from typing import Optional\n from typing import Sequence\n\u002Bfrom typing import Set\n \n import ament_index_python\n \n@@ -28,7 \u002B29,7 @@ g_default_context = None\n g_context_lock = threading.Lock()\n \n \n-def get_default_context(*, shutting_down=False):\n\u002Bdef get_default_context(*, shutting_down=False) -\u003E Context:\n     \u0022\u0022\u0022Return the global default context singleton.\u0022\u0022\u0022\n     global g_context_lock\n     with g_context_lock:\n@@ -47,7 \u002B48,7 @@ def remove_ros_args(args: Optional[Sequence[str]] = None) -\u003E List[str]:\n     Return a list of only the non-ROS command line arguments.\n \n     :param args: A list of command line arguments to filter from. If None then\n-    \u0060\u0060sys.argv\u0060\u0060 is used instead.\n\u002B        \u0060\u0060sys.argv\u0060\u0060 is used instead.\n     :returns: A list of all command line arguments that are not used by ROS.\n     \u0022\u0022\u0022\n     # imported locally to avoid loading extensions on module import\n@@ -56,20 \u002B57,38 @@ def remove_ros_args(args: Optional[Sequence[str]] = None) -\u003E List[str]:\n         args if args is not None else sys.argv)\n \n \n-def ok(*, context=None):\n\u002Bdef ok(*, context: Optional[Context] = None) -\u003E bool:\n\u002B    \u0022\u0022\u0022\n\u002B    Return \u0060\u0060True\u0060\u0060 if the given \u0060\u0060Context\u0060\u0060 is initialized and not shut down.\n\u002B\n\u002B    :param context: a \u0060\u0060Context\u0060\u0060 to check, else the global default context is\n\u002B        used.\n\u002B    :return: \u0060\u0060True\u0060\u0060 if the context is valid.\n\u002B    \u0022\u0022\u0022\n     if context is None:\n         context = get_default_context()\n     return context.ok()\n \n \n-def shutdown(*, context=None):\n\u002Bdef shutdown(*, context=None) -\u003E None:\n\u002B    \u0022\u0022\u0022\n\u002B    Shutdown the given \u0060\u0060Context\u0060\u0060.\n\u002B\n\u002B    :param context: a \u0060\u0060Context\u0060\u0060 to check, else the global default context is\n\u002B        used.\n\u002B    \u0022\u0022\u0022\n     if context is None:\n         context = get_default_context(shutting_down=True)\n-    return context.shutdown()\n\u002B    context.shutdown()\n\u002B\n \n\u002Bdef try_shutdown(*, context=None) -\u003E None:\n\u002B    \u0022\u0022\u0022\n\u002B    Shutdown the given \u0060\u0060Context\u0060\u0060 if not already shutdown.\n \n-def try_shutdown(*, context=None):\n-    \u0022\u0022\u0022Shutdown rclpy if not already shutdown.\u0022\u0022\u0022\n\u002B    :param context: a \u0060\u0060Context\u0060\u0060 to check, else the global default context is\n\u002B        used.\n\u002B    \u0022\u0022\u0022\n     global g_context_lock\n     global g_default_context\n     if context is None:\n@@ -82,16 \u002B101,17 @@ def try_shutdown(*, context=None):\n             if not g_default_context.ok():\n                 g_default_context = None\n     else:\n-        return context.try_shutdown()\n\u002B        context.try_shutdown()\n \n \n-def get_rmw_implementation_identifier():\n\u002Bdef get_rmw_implementation_identifier() -\u003E str:\n\u002B    \u0022\u0022\u0022Return the identifier of the current RMW implementation.\u0022\u0022\u0022\n     # imported locally to avoid loading extensions on module import\n     from rclpy.impl.implementation_singleton import rclpy_implementation\n     return rclpy_implementation.rclpy_get_rmw_implementation_identifier()\n \n \n-def get_available_rmw_implementations():\n\u002Bdef get_available_rmw_implementations() -\u003E Set[str]:\n     \u0022\u0022\u0022\n     Return the set of all available RMW implementations as registered in the ament index.\n \n@@ -99,7 \u002B119,8 @@ def get_available_rmw_implementations():\n     \u0060\u0060RMW_IMPLEMENTATIONS\u0060\u0060.\n     The variable can contain RMW implementation names separated by the platform\n     specific path separator.\n-    Including an unavailable RMW implementation results in a RuntimeError.\n\u002B\n\u002B    :raises RuntimeError: if the environment variable includes a missing RMW implementation.\n     \u0022\u0022\u0022\n     available_rmw_implementations = ament_index_python.get_resources(\n         \u0027rmw_typesupport\u0027)\n@@ -114,6 \u002B135,8 @@ def get_available_rmw_implementations():\n         missing_rmw_implementations = set(rmw_implementations) - \\\n             available_rmw_implementations\n         if missing_rmw_implementations:\n\u002B            # TODO(sloretz) function name suggets to me it would return available ones even\n\u002B            # if some were missing.\n             raise RuntimeError(\n                 f\u0027The RMW implementations {missing_rmw_implementations} \u0027\n                 \u0022specified in \u0027RMW_IMPLEMENTATIONS\u0027 are not available (\u0022 \u002B\n@@ -125,16 \u002B148,14 @@ def get_available_rmw_implementations():\n     return available_rmw_implementations\n \n \n-def timeout_sec_to_nsec(timeout_sec):\n\u002Bdef timeout_sec_to_nsec(timeout_sec: Optional[float]) -\u003E int:\n     \u0022\u0022\u0022\n     Convert timeout in seconds to rcl compatible timeout in nanoseconds.\n \n     Python tends to use floating point numbers in seconds for timeouts. This utility converts a\n-    python-style timeout to an integer in nanoseconds that can be used by rcl_wait.\n\u002B    python-style timeout to an integer in nanoseconds that can be used by \u0060\u0060rcl_wait\u0060\u0060.\n \n     :param timeout_sec: Seconds to wait. Block forever if None or negative. Don\u0027t wait if \u003C 1ns\n-    :type timeout_sec: float or None\n-    :rtype: int\n     :returns: rcl_wait compatible timeout in nanoseconds\n     \u0022\u0022\u0022\n     if timeout_sec is None or timeout_sec \u003C 0:\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "b16b032e79c52302216fae05aeeb97743fc70f09",
    "RawMessage": "rviz_common: Remove variadic macro warning check (#421)",
    "Changes": "diff --git rviz_common/CMakeLists.txt rviz_common/CMakeLists.txt\nindex 5cb81889..e285ace1 100644\n--- rviz_common/CMakeLists.txt\n\u002B\u002B\u002B rviz_common/CMakeLists.txt\n@@ -24,12 \u002B24,6 @@ endif()\n \n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\n-  # TODO(wjwwood): try to remove this -- currently needed to pass on CI\n-  include(CheckCXXCompilerFlag)\n-  check_cxx_compiler_flag(-Wno-gnu-zero-variadic-macro-arguments HAS_W_FLAG)\n-  if(HAS_W_FLAG)\n-    add_compile_options(-Wno-gnu-zero-variadic-macro-arguments)\n-  endif()\n endif()\n \n find_package(ament_cmake REQUIRED)\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "e82b9679952471d365c21c6de90026cf1ee69ee0",
    "RawMessage": "Optimize rcutils_find_lastn where possible.",
    "Changes": "diff --git src/find.c src/find.c\nindex ab39e42..d5dbf7a 100644\n--- src/find.c\n\u002B\u002B\u002B src/find.c\n@@ -12,11 \u002B12,6 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#ifdef __cplusplus\n-extern \u0022C\u0022\n-{\n-#endif\n-\n #include \u003Cstdint.h\u003E\n #include \u003Cstdio.h\u003E\n #include \u003Cstdlib.h\u003E\n@@ -65,14 \u002B60,19 @@ rcutils_find_lastn(const char * str, char delimiter, size_t string_length)\n     return SIZE_MAX;\n   }\n \n\u002B#if defined(_GNU_SOURCE)\n\u002B  const char * ptr = memrchr(str, delimiter, string_length);\n\u002B  if (ptr == NULL) {\n\u002B    return SIZE_MAX;\n\u002B  }\n\u002B\n\u002B  return ptr - str;\n\u002B#else\n   for (size_t i = string_length - 1; i \u003E 0; --i) {\n     if (str[i] == delimiter) {\n       return i;\n     }\n   }\n   return str[0] == delimiter ? 0 : SIZE_MAX;\n-}\n-\n-#ifdef __cplusplus\n-}\n #endif\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "3ac640dddda534745883714171c4c38b12ddd783",
    "RawMessage": "Ensure compliant init options API implementations. (#399)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/rmw_init.cpp rmw_fastrtps_shared_cpp/src/rmw_init.cpp\nindex 84597c3..830dcc6 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n@@ -29,6 \u002B29,7 @@ rmw_ret_t\n rmw_init_options_init(\n   const char * identifier, rmw_init_options_t * init_options, rcutils_allocator_t allocator)\n {\n\u002B  assert(identifier != NULL);\n   RMW_CHECK_ARGUMENT_FOR_NULL(init_options, RMW_RET_INVALID_ARGUMENT);\n   RCUTILS_CHECK_ALLOCATOR(\u0026allocator, return RMW_RET_INVALID_ARGUMENT);\n   if (NULL != init_options-\u003Eimplementation_identifier) {\n@@ -50,8 \u002B51,13 @@ rmw_ret_t\n rmw_init_options_copy(\n   const char * identifier, const rmw_init_options_t * src, rmw_init_options_t * dst)\n {\n\u002B  assert(identifier != NULL);\n   RMW_CHECK_ARGUMENT_FOR_NULL(src, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(dst, RMW_RET_INVALID_ARGUMENT);\n\u002B  if (NULL == src-\u003Eimplementation_identifier) {\n\u002B    RMW_SET_ERROR_MSG(\u0022expected initialized dst\u0022);\n\u002B    return RMW_RET_INVALID_ARGUMENT;\n\u002B  }\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n     src,\n     src-\u003Eimplementation_identifier,\n@@ -62,39 \u002B68,45 @@ rmw_init_options_copy(\n     return RMW_RET_INVALID_ARGUMENT;\n   }\n   const rcutils_allocator_t * allocator = \u0026src-\u003Eallocator;\n-  rmw_ret_t ret = RMW_RET_OK;\n-\n-  allocator-\u003Edeallocate(dst-\u003Eenclave, allocator-\u003Estate);\n-  *dst = *src;\n-  dst-\u003Eenclave = NULL;\n-  dst-\u003Esecurity_options = rmw_get_zero_initialized_security_options();\n\u002B  RCUTILS_CHECK_ALLOCATOR(allocator, return RMW_RET_INVALID_ARGUMENT);\n \n-  dst-\u003Eenclave = rcutils_strdup(src-\u003Eenclave, *allocator);\n-  if (src-\u003Eenclave \u0026\u0026 !dst-\u003Eenclave) {\n-    ret = RMW_RET_BAD_ALLOC;\n-    goto fail;\n\u002B  rmw_init_options_t tmp = *src;\n\u002B  tmp.enclave = rcutils_strdup(tmp.enclave, *allocator);\n\u002B  if (NULL != src-\u003Eenclave \u0026\u0026 NULL == tmp.enclave) {\n\u002B    return RMW_RET_BAD_ALLOC;\n   }\n-  return rmw_security_options_copy(\u0026src-\u003Esecurity_options, allocator, \u0026dst-\u003Esecurity_options);\n-fail:\n-  allocator-\u003Edeallocate(dst-\u003Eenclave, allocator-\u003Estate);\n-  return ret;\n\u002B  tmp.security_options = rmw_get_zero_initialized_security_options();\n\u002B  rmw_ret_t ret =\n\u002B    rmw_security_options_copy(\u0026src-\u003Esecurity_options, allocator, \u0026tmp.security_options);\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    allocator-\u003Edeallocate(tmp.enclave, allocator-\u003Estate);\n\u002B    return ret;\n\u002B  }\n\u002B  *dst = tmp;\n\u002B  return RMW_RET_OK;\n }\n \n rmw_ret_t\n rmw_init_options_fini(const char * identifier, rmw_init_options_t * init_options)\n {\n\u002B  assert(identifier != NULL);\n   RMW_CHECK_ARGUMENT_FOR_NULL(init_options, RMW_RET_INVALID_ARGUMENT);\n-  rcutils_allocator_t \u0026 allocator = init_options-\u003Eallocator;\n-  RCUTILS_CHECK_ALLOCATOR(\u0026allocator, return RMW_RET_INVALID_ARGUMENT);\n\u002B  if (NULL == init_options-\u003Eimplementation_identifier) {\n\u002B    RMW_SET_ERROR_MSG(\u0022expected initialized init_options\u0022);\n\u002B    return RMW_RET_INVALID_ARGUMENT;\n\u002B  }\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n     init_options,\n     init_options-\u003Eimplementation_identifier,\n     identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  allocator.deallocate(init_options-\u003Eenclave, allocator.state);\n-  rmw_security_options_fini(\u0026init_options-\u003Esecurity_options, \u0026allocator);\n\u002B  rcutils_allocator_t * allocator = \u0026init_options-\u003Eallocator;\n\u002B  RCUTILS_CHECK_ALLOCATOR(allocator, return RMW_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  allocator-\u003Edeallocate(init_options-\u003Eenclave, allocator-\u003Estate);\n\u002B  rmw_ret_t ret = rmw_security_options_fini(\u0026init_options-\u003Esecurity_options, allocator);\n   *init_options = rmw_get_zero_initialized_init_options();\n-  return RMW_RET_OK;\n\u002B  return ret;\n }\n \n }  // namespace rmw_fastrtps_shared_cpp\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "31ae9c6a600f77d1566e58fb7fe796be08ab7898",
    "RawMessage": "Expose qos setting for /rosout (#1247)",
    "Changes": "diff --git rclcpp/include/rclcpp/node_options.hpp rclcpp/include/rclcpp/node_options.hpp\nindex 4be29968..e476a4f5 100644\n--- rclcpp/include/rclcpp/node_options.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_options.hpp\n@@ -256,6 \u002B256,19 @@ public:\n   NodeOptions \u0026\n   parameter_event_qos(const rclcpp::QoS \u0026 parameter_event_qos);\n \n\u002B  /// Return a reference to the rosout_qos QoS.\n\u002B  RCLCPP_PUBLIC\n\u002B  const rclcpp::QoS \u0026\n\u002B  rosout_qos() const;\n\u002B\n\u002B  /// Set the rosout_qos QoS.\n\u002B  /**\n\u002B   * The QoS settings to be used for the publisher on /rosout topic, if enabled.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  NodeOptions \u0026\n\u002B  rosout_qos(const rclcpp::QoS \u0026 rosout_qos);\n\u002B\n   /// Return a reference to the parameter_event_publisher_options.\n   RCLCPP_PUBLIC\n   const rclcpp::PublisherOptionsBase \u0026\n@@ -358,6 \u002B371,8 @@ private:\n     rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_parameter_events)\n   );\n \n\u002B  rclcpp::QoS rosout_qos_ = rclcpp::RosoutQoS();\n\u002B\n   rclcpp::PublisherOptionsBase parameter_event_publisher_options_ = rclcpp::PublisherOptionsBase();\n \n   bool allow_undeclared_parameters_ {false};\ndiff --git rclcpp/include/rclcpp/qos.hpp rclcpp/include/rclcpp/qos.hpp\nindex ac016efe..11b80b4e 100644\n--- rclcpp/include/rclcpp/qos.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/qos.hpp\n@@ -19,6 \u002B19,7 @@\n \n #include \u0022rclcpp/duration.hpp\u0022\n #include \u0022rclcpp/visibility_control.hpp\u0022\n\u002B#include \u0022rcl/logging_rosout.h\u0022\n #include \u0022rmw/incompatible_qos_events_statuses.h\u0022\n #include \u0022rmw/qos_profiles.h\u0022\n #include \u0022rmw/types.h\u0022\n@@ -249,6 \u002B250,28 @@ public:\n   ));\n };\n \n\u002B/**\n\u002B * Rosout QoS class\n\u002B *    - History: Keep last,\n\u002B *    - Depth: 1000,\n\u002B *    - Reliability: Reliable,\n\u002B *    - Durability: TRANSIENT_LOCAL,\n\u002B *    - Deadline: Default,\n\u002B *    - Lifespan: {10, 0},\n\u002B *    - Liveliness: System default,\n\u002B *    - Liveliness lease duration: default,\n\u002B *    - Avoid ros namespace conventions: false\n\u002B */\n\u002Bclass RCLCPP_PUBLIC RosoutQoS : public QoS\n\u002B{\n\u002Bpublic:\n\u002B  explicit\n\u002B  RosoutQoS(\n\u002B    const QoSInitialization \u0026 rosout_qos_initialization = (\n\u002B      QoSInitialization::from_rmw(rcl_qos_profile_rosout_default)\n\u002B  ));\n\u002B};\n\u002B\n /**\n  * System defaults QoS class\n  *    - History: System default,\ndiff --git rclcpp/src/rclcpp/node_options.cpp rclcpp/src/rclcpp/node_options.cpp\nindex 179c5bff..017bc35c 100644\n--- rclcpp/src/rclcpp/node_options.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_options.cpp\n@@ -75,6 \u002B75,7 @@ NodeOptions::operator=(const NodeOptions \u0026 other)\n     this-\u003Euse_intra_process_comms_ = other.use_intra_process_comms_;\n     this-\u003Eenable_topic_statistics_ = other.enable_topic_statistics_;\n     this-\u003Estart_parameter_services_ = other.start_parameter_services_;\n\u002B    this-\u003Erosout_qos_ = other.rosout_qos_;\n     this-\u003Eallocator_ = other.allocator_;\n     this-\u003Eallow_undeclared_parameters_ = other.allow_undeclared_parameters_;\n     this-\u003Eautomatically_declare_parameters_from_overrides_ =\n@@ -94,6 \u002B95,7 @@ NodeOptions::get_rcl_node_options() const\n     node_options_-\u003Eallocator = this-\u003Eallocator_;\n     node_options_-\u003Euse_global_arguments = this-\u003Euse_global_arguments_;\n     node_options_-\u003Eenable_rosout = this-\u003Eenable_rosout_;\n\u002B    node_options_-\u003Erosout_qos = this-\u003Erosout_qos_.get_rmw_qos_profile();\n \n     int c_argc = 0;\n     std::unique_ptr\u003Cconst char *[]\u003E c_argv;\n@@ -266,6 \u002B268,20 @@ NodeOptions::parameter_event_qos(const rclcpp::QoS \u0026 parameter_event_qos)\n   return *this;\n }\n \n\u002Bconst rclcpp::QoS \u0026\n\u002BNodeOptions::rosout_qos() const\n\u002B{\n\u002B  return this-\u003Erosout_qos_;\n\u002B}\n\u002B\n\u002BNodeOptions \u0026\n\u002BNodeOptions::rosout_qos(const rclcpp::QoS \u0026 rosout_qos)\n\u002B{\n\u002B  this-\u003Enode_options_.reset();\n\u002B  this-\u003Erosout_qos_ = rosout_qos;\n\u002B  return *this;\n\u002B}\n\u002B\n const rclcpp::PublisherOptionsBase \u0026\n NodeOptions::parameter_event_publisher_options() const\n {\ndiff --git rclcpp/src/rclcpp/qos.cpp rclcpp/src/rclcpp/qos.cpp\nindex b0b39876..9c1565ad 100644\n--- rclcpp/src/rclcpp/qos.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/qos.cpp\n@@ -251,6 \u002B251,10 @@ ParameterEventsQoS::ParameterEventsQoS(const QoSInitialization \u0026 qos_initializat\n : QoS(qos_initialization, rmw_qos_profile_parameter_events)\n {}\n \n\u002BRosoutQoS::RosoutQoS(const QoSInitialization \u0026 rosout_initialization)\n\u002B: QoS(rosout_initialization, rcl_qos_profile_rosout_default)\n\u002B{}\n\u002B\n SystemDefaultsQoS::SystemDefaultsQoS(const QoSInitialization \u0026 qos_initialization)\n : QoS(qos_initialization, rmw_qos_profile_system_default)\n {}\ndiff --git rclcpp/test/CMakeLists.txt rclcpp/test/CMakeLists.txt\nindex 6d538696..3c643c06 100644\n--- rclcpp/test/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/CMakeLists.txt\n@@ -627,6 \u002B627,12 @@ if(TARGET test_rclcpp_gtest_macros)\n   target_link_libraries(test_rclcpp_gtest_macros ${PROJECT_NAME})\n endif()\n \n\u002Bament_add_gtest(test_rosout_qos rclcpp/test_rosout_qos.cpp)\n\u002Bif(TARGET test_rosout_qos)\n\u002B  ament_target_dependencies(test_rosout_qos \u0022rcl\u0022)\n\u002B  target_link_libraries(test_rosout_qos ${PROJECT_NAME})\n\u002Bendif()\n\u002B\n # Install test resources\n install(\n   DIRECTORY resources\ndiff --git rclcpp/test/rclcpp/test_rosout_qos.cpp rclcpp/test/rclcpp/test_rosout_qos.cpp\nnew file mode 100644\nindex 00000000..aacaf841\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_rosout_qos.cpp\n@@ -0,0 \u002B1,79 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022rclcpp/node_options.hpp\u0022\n\u002B#include \u0022rclcpp/qos.hpp\u0022\n\u002B#include \u0022rclcpp/duration.hpp\u0022\n\u002B#include \u0022rcl/logging_rosout.h\u0022\n\u002B#include \u0022rcl/init.h\u0022\n\u002B#include \u0022rmw/types.h\u0022\n\u002B\n\u002Bbool operator==(\n\u002B  const rmw_time_t \u0026 lhs,\n\u002B  const rmw_time_t \u0026 rhs)\n\u002B{\n\u002B  return lhs.sec == rhs.sec \u0026\u0026 lhs.nsec == rhs.nsec;\n\u002B}\n\u002B\n\u002Bbool operator==(\n\u002B  const rmw_qos_profile_t \u0026 lhs,\n\u002B  const rmw_qos_profile_t \u0026 rhs)\n\u002B{\n\u002B  return lhs.history == rhs.history \u0026\u0026\n\u002B         lhs.depth == rhs.depth \u0026\u0026\n\u002B         lhs.reliability == rhs.reliability \u0026\u0026\n\u002B         lhs.durability == rhs.durability \u0026\u0026\n\u002B         lhs.deadline == rhs.deadline \u0026\u0026\n\u002B         lhs.lifespan == rhs.lifespan \u0026\u0026\n\u002B         lhs.liveliness == rhs.liveliness \u0026\u0026\n\u002B         lhs.liveliness_lease_duration == rhs.liveliness_lease_duration \u0026\u0026\n\u002B         lhs.avoid_ros_namespace_conventions == rhs.avoid_ros_namespace_conventions;\n\u002B}\n\u002B\n\u002Bbool operator!=(\n\u002B  const rmw_qos_profile_t \u0026 lhs,\n\u002B  const rmw_qos_profile_t \u0026 rhs)\n\u002B{\n\u002B  return !(lhs == rhs);\n\u002B}\n\u002B\n\u002B/*\n\u002B   Test rosout_qos function with default value.\n\u002B */\n\u002BTEST(TestRosoutQoS, test_rosout_qos_with_default_value) {\n\u002B  rclcpp::NodeOptions node_options;\n\u002B  rclcpp::QoS rosout_qos_profile = node_options.rosout_qos();\n\u002B  rmw_qos_profile_t rmw_qos_profile = rosout_qos_profile.get_rmw_qos_profile();\n\u002B  EXPECT_EQ(rcl_qos_profile_rosout_default, rmw_qos_profile);\n\u002B  EXPECT_EQ(rcl_qos_profile_rosout_default, node_options.get_rcl_node_options()-\u003Erosout_qos);\n\u002B}\n\u002B\n\u002B/*\n\u002B   Test \u0060rosout_qos\u0060 function with custom value.\n\u002B */\n\u002BTEST(TestRosoutQoS, test_rosout_qos_with_custom_value) {\n\u002B  rmw_time_t life_span;\n\u002B  life_span.sec = 10;\n\u002B  life_span.nsec = 0;\n\u002B  auto qos_profile = rclcpp::QoS(rclcpp::KeepLast(1000)).transient_local().lifespan(life_span);\n\u002B  auto options = rclcpp::NodeOptions().rosout_qos(qos_profile);\n\u002B  rclcpp::QoS rosout_qos = options.rosout_qos();\n\u002B  rmw_qos_profile_t rmw_qos_profile = rosout_qos.get_rmw_qos_profile();\n\u002B\n\u002B  EXPECT_EQ(rmw_qos_profile, qos_profile.get_rmw_qos_profile());\n\u002B  EXPECT_EQ(rmw_qos_profile, options.get_rcl_node_options()-\u003Erosout_qos);\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "013ca3e5c591c06af82b951218c541399920a01e",
    "RawMessage": "Update displays_panel.cpp (#745)",
    "Changes": "diff --git rviz_common/src/rviz_common/displays_panel.cpp rviz_common/src/rviz_common/displays_panel.cpp\nindex 9c61b3fd..74a10cf0 100644\n--- rviz_common/src/rviz_common/displays_panel.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/displays_panel.cpp\n@@ -36,6 \u002B36,7 @@\n #include \u003CQApplication\u003E  // NOLINT: cpplint is unable to handle the include order here\n #include \u003CQHBoxLayout\u003E  // NOLINT: cpplint is unable to handle the include order here\n #include \u003CQInputDialog\u003E  // NOLINT: cpplint is unable to handle the include order here\n\u002B#include \u003CQProgressDialog\u003E // NOLINT: cpplint is unable to handle the include order here\n #include \u003CQPushButton\u003E  // NOLINT: cpplint is unable to handle the include order here\n #include \u003CQTimer\u003E  // NOLINT: cpplint is unable to handle the include order here\n #include \u003CQVBoxLayout\u003E  // NOLINT: cpplint is unable to handle the include order here\n@@ -147,7 \u002B148,13 @@ void DisplaysPanel::onDuplicateDisplay()\n   QList\u003CDisplay *\u003E displays_to_duplicate = property_grid_-\u003EgetSelectedObjects\u003CDisplay\u003E();\n \n   QList\u003CDisplay *\u003E duplicated_displays;\n\u002B  QProgressDialog progress_dlg(\u0022Duplicating displays...\u0022, \u0022Cancel\u0022, 0, displays_to_duplicate.size(),\n\u002B    this);\n\u002B  progress_dlg.setWindowModality(Qt::WindowModal);\n\u002B  progress_dlg.show();\n \n\u002B  // duplicate all selected displays\n\u002B  int i = 0;\n   for (const auto \u0026 display_to_duplicate : displays_to_duplicate) {\n     // initialize display\n     QString lookup_name = display_to_duplicate-\u003EgetClassId();\n@@ -158,6 \u002B165,12 @@ void DisplaysPanel::onDuplicateDisplay()\n     display_to_duplicate-\u003Esave(config);\n     disp-\u003Eload(config);\n     duplicated_displays.push_back(disp);\n\u002B    progress_dlg.setValue(i \u002B 1);\n\u002B    i\u002B\u002B;\n\u002B    // push cancel to stop duplicate\n\u002B    if (progress_dlg.wasCanceled()) {\n\u002B      break;\n\u002B    }\n   }\n   // make sure the newly duplicated displays are selected.\n   if (!duplicated_displays.isEmpty()) {\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "3e0c22c5bf341496ab36d781eaa67a7c8cea3ce7",
    "RawMessage": "Convert duration to pybind11 (#716)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 031e9ab..c4d506b 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -174,6 \u002B174,7 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/client.cpp\n   src/rclpy/clock.cpp\n   src/rclpy/context.cpp\n\u002B  src/rclpy/duration.cpp\n   src/rclpy/guard_condition.cpp\n   src/rclpy/publisher.cpp\n   src/rclpy/service.cpp\ndiff --git rclpy/rclpy/duration.py rclpy/rclpy/duration.py\nindex 3ca918d..d95d682 100644\n--- rclpy/rclpy/duration.py\n\u002B\u002B\u002B rclpy/rclpy/duration.py\n@@ -21,7 \u002B21,7 @@ class Duration:\n     def __init__(self, *, seconds=0, nanoseconds=0):\n         total_nanoseconds = int(seconds * 1e9)\n         total_nanoseconds \u002B= int(nanoseconds)\n-        if total_nanoseconds \u003E= 2**63:\n\u002B        if total_nanoseconds \u003E= 2**63 or total_nanoseconds \u003C -2**63:\n             # pybind11 would raise TypeError, but we want OverflowError\n             raise OverflowError(\n                 \u0027Total nanoseconds value is too large to store in C duration.\u0027)\ndiff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 21fe13f..3c041b1 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -2608,73 \u002B2608,6 @@ rclpy_assert_liveliness(PyObject * module, PyObject * args)\n   Py_RETURN_NONE;\n }\n \n-/// Destructor for a duration\n-void\n-_rclpy_destroy_duration(PyObject * pycapsule)\n-{\n-  PyMem_Free(PyCapsule_GetPointer(pycapsule, \u0022rcl_duration_t\u0022));\n-}\n-\n-/// Create a duration\n-/**\n- * On failure, an exception is raised and NULL is returned if:\n- *\n- * Raises RuntimeError on initialization failure\n- * Raises TypeError if argument of invalid type\n- * Raises OverflowError if nanoseconds argument cannot be converted to uint64_t\n- *\n- * \\param[in] nanoseconds unsigned PyLong object storing the nanoseconds value\n- *   of the duration in a 64-bit signed integer\n- * \\return Capsule of the pointer to the created rcl_duration_t * structure, or\n- * \\return NULL on failure\n- */\n-static PyObject *\n-rclpy_create_duration(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  PY_LONG_LONG nanoseconds;\n-\n-  if (!PyArg_ParseTuple(args, \u0022L\u0022, \u0026nanoseconds)) {\n-    return NULL;\n-  }\n-\n-  rcl_duration_t * duration = PyMem_Malloc(sizeof(rcl_duration_t));\n-  if (!duration) {\n-    PyErr_Format(PyExc_MemoryError, \u0022Failed to allocate memory for duration.\u0022);\n-    return NULL;\n-  }\n-\n-  duration-\u003Enanoseconds = nanoseconds;\n-\n-  return PyCapsule_New(duration, \u0022rcl_duration_t\u0022, _rclpy_destroy_duration);\n-}\n-\n-/// Returns the nanoseconds value of the duration\n-/**\n- * On failure, an exception is raised and NULL is returned if:\n- *\n- * Raises ValueError if pyduration is not a duration capsule\n- *\n- * \\param[in] pyduration Capsule pointing to the duration\n- * \\return NULL on failure:\n- *         PyLong integer in nanoseconds on success\n- */\n-static PyObject *\n-rclpy_duration_get_nanoseconds(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  PyObject * pyduration;\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pyduration)) {\n-    return NULL;\n-  }\n-\n-  rcl_duration_t * duration = PyCapsule_GetPointer(\n-    pyduration, \u0022rcl_duration_t\u0022);\n-  if (!duration) {\n-    return NULL;\n-  }\n-\n-  return PyLong_FromLongLong(duration-\u003Enanoseconds);\n-}\n-\n /// Create an rclpy.parameter.Parameter from an rcl_variant_t\n /**\n  * On failure a Python exception is raised and NULL is returned if:\n@@ -3353,16 \u002B3286,6 @@ static PyMethodDef rclpy_methods[] = {\n     \u0022Assert the liveliness of an entity.\u0022\n   },\n \n-  {\n-    \u0022rclpy_create_duration\u0022, rclpy_create_duration, METH_VARARGS,\n-    \u0022Create a duration.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_duration_get_nanoseconds\u0022, rclpy_duration_get_nanoseconds, METH_VARARGS,\n-    \u0022Get the nanoseconds value of a duration.\u0022\n-  },\n-\n   {\n     \u0022rclpy_serialize\u0022, rclpy_serialize, METH_VARARGS,\n     \u0022Serialize a ROS message.\u0022\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex 27aeb93..efdfda6 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -17,6 \u002B17,7 @@\n #include \u0022client.hpp\u0022\n #include \u0022clock.hpp\u0022\n #include \u0022context.hpp\u0022\n\u002B#include \u0022duration.hpp\u0022\n #include \u0022guard_condition.hpp\u0022\n #include \u0022publisher.hpp\u0022\n #include \u0022rclpy_common/exceptions.hpp\u0022\n@@ -84,6 \u002B85,13 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n     \u0022rclpy_ok\u0022, \u0026rclpy::context_is_valid,\n     \u0022Return true if the context is valid\u0022);\n \n\u002B  m.def(\n\u002B    \u0022rclpy_create_duration\u0022, \u0026rclpy::create_duration,\n\u002B    \u0022Create a duration\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_duration_get_nanoseconds\u0022, \u0026rclpy::duration_get_nanoseconds,\n\u002B    \u0022Get the nanoseconds value of a duration\u0022);\n\u002B\n   m.def(\n     \u0022rclpy_create_publisher\u0022, \u0026rclpy::publisher_create,\n     \u0022Create a Publisher\u0022);\ndiff --git rclpy/src/rclpy/duration.cpp rclpy/src/rclpy/duration.cpp\nnew file mode 100644\nindex 0000000..0abcc60\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/duration.cpp\n@@ -0,0 \u002B1,53 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B#include \u003Crcl/time.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022duration.hpp\u0022\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002Bvoid\n\u002B_rclpy_destroy_duration(PyObject * pycapsule)\n\u002B{\n\u002B  PyMem_Free(PyCapsule_GetPointer(pycapsule, \u0022rcl_duration_t\u0022));\n\u002B}\n\u002B\n\u002Bpy::capsule\n\u002Bcreate_duration(int64_t nanoseconds)\n\u002B{\n\u002B  auto duration = static_cast\u003Crcl_duration_t *\u003E(PyMem_Malloc(sizeof(rcl_duration_t)));\n\u002B  if (!duration) {\n\u002B    throw std::bad_alloc();\n\u002B  }\n\u002B\n\u002B  duration-\u003Enanoseconds = nanoseconds;\n\u002B\n\u002B  return py::capsule(duration, \u0022rcl_duration_t\u0022, _rclpy_destroy_duration);\n\u002B}\n\u002B\n\u002Bint64_t\n\u002Bduration_get_nanoseconds(py::capsule pyduration)\n\u002B{\n\u002B  if (0 != strcmp(\u0022rcl_duration_t\u0022, pyduration.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_duration_t\u0022);\n\u002B  }\n\u002B  auto duration = static_cast\u003Crcl_duration_t *\u003E(pyduration);\n\u002B\n\u002B  return duration-\u003Enanoseconds;\n\u002B}\n\u002B}  // namespace rclpy\ndiff --git rclpy/src/rclpy/duration.hpp rclpy/src/rclpy/duration.hpp\nnew file mode 100644\nindex 0000000..0d5fb38\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/duration.hpp\n@@ -0,0 \u002B1,45 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLPY__DURATION_HPP_\n\u002B#define RCLPY__DURATION_HPP_\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B/// Create a duration\n\u002B/**\n\u002B * Raises TypeError if argument is of an invalid type\n\u002B *\n\u002B * \\param[in] nanoseconds The nanoseconds value of the duration in a 64-bit signed integer\n\u002B * \\return Capsule of the pointer to the created rcl_duration_t * structure\n\u002B */\n\u002Bpy::capsule\n\u002Bcreate_duration(int64_t nanoseconds);\n\u002B\n\u002B/// Returns the nanoseconds value of the duration\n\u002B/**\n\u002B * Raises ValueError if pyduration is not a duration capsule\n\u002B *\n\u002B * \\param[in] pyduration Capsule pointing to the duration\n\u002B * \\return integer nanoseconds\n\u002B */\n\u002Bint64_t\n\u002Bduration_get_nanoseconds(py::capsule pyduration);\n\u002B}  // namespace rclpy\n\u002B\n\u002B#endif  // RCLPY__DURATION_HPP_\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "4e51c02c31b0f0958f909e1dfe9c5492661d3fab",
    "RawMessage": "support ros2 topic pub yaml file input (#925)",
    "Changes": "diff --git ros2topic/ros2topic/verb/pub.py ros2topic/ros2topic/verb/pub.py\nindex fce959a..f280f1b 100644\n--- ros2topic/ros2topic/verb/pub.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/pub.py\n@@ -70,6 \u002B70,10 @@ class PubVerb(VerbExtension):\n         group.add_argument(\n             \u0027--stdin\u0027, action=\u0027store_true\u0027,\n             help=\u0027Read values from standard input\u0027)\n\u002B        group.add_argument(\n\u002B            \u0027--yaml-file\u0027, type=str, default=None,\n\u002B            help=\u0027YAML file that has message contents, \u0027\n\u002B                 \u0027e.g STDOUT from ros2 topic echo \u003Ctopic\u003E\u0027)\n         parser.add_argument(\n             \u0027-r\u0027, \u0027--rate\u0027, metavar=\u0027N\u0027, type=positive_float, default=1.0,\n             help=\u0027Publishing rate in Hz (default: 1)\u0027)\n@@ -131,6 \u002B135,7 @@ def main(args):\n             args.message_type,\n             args.topic_name,\n             values,\n\u002B            args.yaml_file,\n             1. / args.rate,\n             args.print,\n             times,\n@@ -146,6 \u002B151,7 @@ def publisher(\n     message_type: MsgType,\n     topic_name: str,\n     values: dict,\n\u002B    yaml_file: str,\n     period: float,\n     print_nth: int,\n     times: int,\n@@ -159,9 \u002B165,14 @@ def publisher(\n         msg_module = get_message(message_type)\n     except (AttributeError, ModuleNotFoundError, ValueError):\n         raise RuntimeError(\u0027The passed message type is invalid\u0027)\n-    values_dictionary = yaml.safe_load(values)\n-    if not isinstance(values_dictionary, dict):\n-        return \u0027The passed value needs to be a dictionary in YAML format\u0027\n\u002B\n\u002B    msg_reader = None\n\u002B    if yaml_file:\n\u002B        msg_reader = read_msg_from_yaml(yaml_file)\n\u002B    else:\n\u002B        values_dictionary = yaml.safe_load(values)\n\u002B        if not isinstance(values_dictionary, dict):\n\u002B            return \u0027The passed value needs to be a dictionary in YAML format\u0027\n \n     pub = node.create_publisher(msg_module, topic_name, qos_profile)\n \n@@ -184,15 \u002B195,38 @@ def publisher(\n         total_wait_time \u002B= DEFAULT_WAIT_TIME\n \n     msg = msg_module()\n-    try:\n-        timestamp_fields = set_message_fields(\n-            msg, values_dictionary, expand_header_auto=True, expand_time_now=True)\n-    except Exception as e:\n-        return \u0027Failed to populate field: {0}\u0027.format(e)\n\u002B    timestamp_fields = None\n\u002B\n\u002B    if not msg_reader:\n\u002B        # Set the static message from specified values once\n\u002B        try:\n\u002B            timestamp_fields = set_message_fields(\n\u002B                msg, values_dictionary, expand_header_auto=True, expand_time_now=True)\n\u002B        except Exception as e:\n\u002B            return \u0027Failed to populate field: {0}\u0027.format(e)\n\u002B\n     print(\u0027publisher: beginning loop\u0027)\n     count = 0\n\u002B    more_message = True\n \n     def timer_callback():\n\u002B        if msg_reader:\n\u002B            # Try to read out the contents for each message\n\u002B            try:\n\u002B                one_msg = next(msg_reader)\n\u002B                if not isinstance(one_msg, dict):\n\u002B                    print(\u0027The contents in YAML file need to be a YAML format\u0027)\n\u002B            except StopIteration:\n\u002B                nonlocal more_message\n\u002B                more_message = False\n\u002B                return\n\u002B            # Set the message with contents\n\u002B            try:\n\u002B                nonlocal timestamp_fields\n\u002B                timestamp_fields = set_message_fields(\n\u002B                    msg, one_msg, expand_header_auto=True, expand_time_now=True)\n\u002B            except Exception as e:\n\u002B                return \u0027Failed to populate field: {0}\u0027.format(e)\n         stamp_now = node.get_clock().now().to_msg()\n         for field_setter in timestamp_fields:\n             field_setter(stamp_now)\n@@ -205,7 \u002B239,7 @@ def publisher(\n     timer_callback()\n     if times != 1:\n         timer = node.create_timer(period, timer_callback)\n-        while times == 0 or count \u003C times:\n\u002B        while (times == 0 or count \u003C times) and more_message:\n             rclpy.spin_once(node)\n         # give some time for the messages to reach the wire before exiting\n         time.sleep(keep_alive)\n@@ -213,3 \u002B247,12 @@ def publisher(\n     else:\n         # give some time for the messages to reach the wire before exiting\n         time.sleep(keep_alive)\n\u002B\n\u002B\n\u002Bdef read_msg_from_yaml(yaml_file):\n\u002B    with open(yaml_file, \u0027r\u0027) as f:\n\u002B        for document in yaml.load_all(f, Loader=yaml.FullLoader):\n\u002B            if document is None:\n\u002B                continue  # Skip if there\u0027s no more document\n\u002B\n\u002B            yield document\ndiff --git ros2topic/test/resources/chatter.yaml ros2topic/test/resources/chatter.yaml\nnew file mode 100644\nindex 0000000..4ac2880\n--- /dev/null\n\u002B\u002B\u002B ros2topic/test/resources/chatter.yaml\n@@ -0,0 \u002B1,10 @@\n\u002B---\n\u002Bdata: \u0027Hello ROS Users\u0027\n\u002B---\n\u002B---\n\u002Bdata: Hello ROS Developers\n\u002B---\n\u002Bdata: Hello ROS Developers\n\u002B---\n\u002B---\n\u002Bdata: \u0027Hello ROS Users\u0027\ndiff --git ros2topic/test/test_echo_pub.py ros2topic/test/test_echo_pub.py\nindex 3058385..b9a0527 100644\n--- ros2topic/test/test_echo_pub.py\n\u002B\u002B\u002B ros2topic/test/test_echo_pub.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import functools\n\u002Bimport pathlib\n import sys\n import unittest\n \n@@ -49,6 \u002B50,8 @@ if sys.platform.startswith(\u0027win\u0027):\n TEST_NODE = \u0027cli_echo_pub_test_node\u0027\n TEST_NAMESPACE = \u0027cli_echo_pub\u0027\n \n\u002BTEST_RESOURCES_DIR = pathlib.Path(__file__).resolve().parent / \u0027resources\u0027\n\u002B\n \n @pytest.mark.rostest\n @launch_testing.markers.keep_alive\n@@ -289,6 \u002B292,42 @@ class TestROS2TopicEchoPub(unittest.TestCase):\n             strict=True\n         )\n \n\u002B    @launch_testing.markers.retry_on_failure(times=5)\n\u002B    def test_pub_yaml(self, launch_service, proc_info, proc_output):\n\u002B        command_action = ExecuteProcess(\n\u002B            # yaml file prevails to the values \u0027data: hello\u0027\n\u002B            cmd=([\u0027ros2\u0027, \u0027topic\u0027, \u0027pub\u0027, \u0027/clitest/topic/chatter\u0027,\n\u002B                  \u0027std_msgs/String\u0027, \u0027--yaml-file\u0027,\n\u002B                  str(TEST_RESOURCES_DIR / \u0027chatter.yaml\u0027)]),\n\u002B            additional_env={\n\u002B                \u0027PYTHONUNBUFFERED\u0027: \u00271\u0027\n\u002B            },\n\u002B            output=\u0027screen\u0027\n\u002B        )\n\u002B        with launch_testing.tools.launch_process(\n\u002B            launch_service, command_action, proc_info, proc_output,\n\u002B            output_filter=launch_testing_ros.tools.basic_output_filter(\n\u002B                filtered_rmw_implementation=get_rmw_implementation_identifier()\n\u002B            )\n\u002B        ) as command:\n\u002B            assert command.wait_for_shutdown(timeout=10)\n\u002B        assert command.exit_code == launch_testing.asserts.EXIT_OK\n\u002B        assert launch_testing.tools.expect_output(\n\u002B            expected_lines=[\n\u002B                \u0027publisher: beginning loop\u0027,\n\u002B                \u0022publishing #1: std_msgs.msg.String(data=\u0027Hello ROS Users\u0027)\u0022,\n\u002B                \u0027\u0027,\n\u002B                \u0022publishing #2: std_msgs.msg.String(data=\u0027Hello ROS Developers\u0027)\u0022,\n\u002B                \u0027\u0027,\n\u002B                \u0022publishing #3: std_msgs.msg.String(data=\u0027Hello ROS Developers\u0027)\u0022,\n\u002B                \u0027\u0027,\n\u002B                \u0022publishing #4: std_msgs.msg.String(data=\u0027Hello ROS Users\u0027)\u0022,\n\u002B                \u0027\u0027,\n\u002B            ],\n\u002B            text=command.output,\n\u002B            strict=True\n\u002B        )\n\u002B\n     @launch_testing.markers.retry_on_failure(times=5)\n     def test_echo_basic(self, launch_service, proc_info, proc_output):\n         params = [\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "466e0855f9b4b87c8e57571aa5c81b02012e95db",
    "RawMessage": "Add service_msgs package (#143)",
    "Changes": "diff --git action_msgs/package.xml action_msgs/package.xml\nindex 4a0873b..6ac1918 100644\n--- action_msgs/package.xml\n\u002B\u002B\u002B action_msgs/package.xml\n@@ -18,6 \u002B18,7 @@\n   \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Eservice_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Eunique_identifier_msgs\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\ndiff --git service_msgs/CMakeLists.txt service_msgs/CMakeLists.txt\nnew file mode 100644\nindex 0000000..06ec2bf\n--- /dev/null\n\u002B\u002B\u002B service_msgs/CMakeLists.txt\n@@ -0,0 \u002B1,36 @@\n\u002Bcmake_minimum_required(VERSION 3.5)\n\u002B\n\u002Bproject(service_msgs)\n\u002B\n\u002B# Default to C\u002B\u002B14\n\u002Bif(NOT CMAKE_CXX_STANDARD)\n\u002B  set(CMAKE_CXX_STANDARD 14)\n\u002Bendif()\n\u002Bif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n\u002B  add_compile_options(-Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)\n\u002Bendif()\n\u002B\n\u002Bfind_package(ament_cmake REQUIRED)\n\u002Bfind_package(builtin_interfaces REQUIRED)\n\u002B# Depend on \u0022core\u0022 generators instead of \u0022default\u0022 generators\n\u002B# because ROS actions depend on this package\n\u002Bfind_package(rosidl_core_generators REQUIRED)\n\u002B\n\u002Bset(msg_files\n\u002B  \u0022msg/ServiceEventInfo.msg\u0022\n\u002B)\n\u002B\n\u002Brosidl_generate_interfaces(${PROJECT_NAME}\n\u002B  ${msg_files}\n\u002B  DEPENDENCIES builtin_interfaces\n\u002B  ADD_LINTER_TESTS\n\u002B)\n\u002B\n\u002Bif(BUILD_TESTING)\n\u002B  find_package(ament_lint_auto REQUIRED)\n\u002B  ament_lint_auto_find_test_dependencies()\n\u002Bendif()\n\u002B\n\u002Bament_export_dependencies(rosidl_core_runtime)\n\u002B\n\u002Bament_package()\ndiff --git service_msgs/QUALITY_DECLARATION.md service_msgs/QUALITY_DECLARATION.md\nnew file mode 100644\nindex 0000000..bb49cbc\n--- /dev/null\n\u002B\u002B\u002B service_msgs/QUALITY_DECLARATION.md\n@@ -0,0 \u002B1,112 @@\n\u002BThis document is a declaration of software quality for the \u0060service_msgs\u0060 package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B# \u0060service_msgs\u0060 Quality Declaration\n\u002B\n\u002BThe package \u0060service_msgs\u0060 claims to be in the **Quality Level 1** category as long as it is used with a **Quality Level 1** middleware.\n\u002B\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 1 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B## Version Policy [1]\n\u002B\n\u002B### Version Scheme [1.i]\n\u002B\n\u002B\u0060service_msgs\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n\u002B\n\u002B### Version Stability [1.ii]\n\u002B\n\u002B\u0060service_msgs\u0060 is at a stable version, i.e. \u0060\u003E= 1.0.0\u0060.\n\u002BIts version can be found in its [package.xml](package.xml) and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n\u002B\n\u002B### Public API Declaration [1.iii]\n\u002B\n\u002BAll message and service definition files located in \u0060msg\u0060 and \u0060srv\u0060 directories are considered part of the public API.\n\u002B\n\u002B### API Stability Within a Released ROS Distribution [1.iv]/[1.vi]\n\u002B\n\u002B\u0060service_msgs\u0060 will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n\u002B\n\u002B### ABI Stability Within a Released ROS Distribution [1.v]/[1.vi]\n\u002B\n\u002B\u0060service_msgs\u0060 does not contain any C or C\u002B\u002B code and therefore will not affect ABI stability.\n\u002B\n\u002B## Change Control Process [2]\n\u002B\n\u002B\u0060service_msgs\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n\u002B\n\u002B### Change Requests [2.i]\n\u002B\n\u002BThis package requires that all changes occur through a pull request.\n\u002B\n\u002B### Contributor Origin [2.ii]\n\u002B\n\u002BThis package uses DCO as its confirmation of contributor origin policy. More information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002B### Peer Review Policy [2.iii]\n\u002B\n\u002BFollowing the recommended guidelines for ROS Core packages, all pull requests must have at least 1 peer review.\n\u002B\n\u002B### Continuous Integration [2.iv]\n\u002B\n\u002BAll pull request must pass CI on all [tier 1 platforms](https://www.ros.org/reps/rep-2000.html#support-tiers)\n\u002B\n\u002B### Documentation Policy [2.v]\n\u002B\n\u002BAll pull requests must resolve related documentation changes before merging.\n\u002B\n\u002B## Documentation\n\u002B\n\u002B### Feature Documentation [3.i]\n\u002B\n\u002B\u0060service_msgs\u0060 has a list of provided [ROS interfaces](README.md).\n\u002BNew interfaces require their own documentation in order to be added.\n\u002B\n\u002B### Public API Documentation [3.ii]\n\u002B\n\u002B\u0060service_msgs\u0060 has embedded API documentation, but it is not currently hosted.\n\u002B\n\u002B### License [3.iii]\n\u002B\n\u002BThe license for \u0060service_msgs\u0060 is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.\n\u002B\n\u002BThere is an automated test which runs a linter that ensures each file has a license statement.\n\u002B\n\u002BThe nightly test can be found at [here](http://build.ros2.org/view/Rpr/job/Rpr__rcl_interfaces__ubuntu_focal_amd64/lastCompletedBuild/testReport/)\n\u002B\n\u002B### Copyright Statements [3.iv]\n\u002B\n\u002BThe copyright holders each provide a statement of copyright in each source code file in \u0060service_msgs\u0060.\n\u002B\n\u002BThere is an automated test which runs a linter that ensures each file has at least one copyright statement.\n\u002B\n\u002BThe nightly test can be found at [here](http://build.ros2.org/view/Rpr/job/Rpr__rcl_interfaces__ubuntu_focal_amd64/lastCompletedBuild/testReport/)\n\u002B\n\u002B## Testing [4]\n\u002B\n\u002B\u0060service_msgs\u0060 is a package providing strictly message and service definitions and therefore does not require associated tests and has no coverage or performance requirements.\n\u002B\n\u002B## Dependencies [5]\n\u002B\n\u002B### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n\u002B\n\u002B\u0060service_msgs\u0060 has the following runtime ROS dependencies, which are at **Quality Level 1**:\n\u002B* \u0060builtin_interfaces\u0060: [QUALITY DECLARATION](../builtin_interfaces/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_core_runtime\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_core/tree/rolling/rosidl_core_runtime/QUALITY_DECLARATION.md)\n\u002B\n\u002BIt has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n\u002B\n\u002B### Direct Runtime Non-ROS Dependencies [5.iii]\n\u002B\n\u002B\u0060service_msgs\u0060 does not have any runtime non-ROS dependencies.\n\u002B\n\u002B## Platform Support [6]\n\u002B\n\u002B\u0060service_msgs\u0060 supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers), and tests each change against all of them.\n\u002B\n\u002BCurrently nightly results can be seen here:\n\u002B* [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/service_msgs/)\n\u002B* [linux_release](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/service_msgs/)\n\u002B* [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/service_msgs/)\n\u002B\n\u002B## Vulnerability Disclosure Policy [7.i]\n\u002B\n\u002BThis package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\ndiff --git service_msgs/README.md service_msgs/README.md\nnew file mode 100644\nindex 0000000..fd99bff\n--- /dev/null\n\u002B\u002B\u002B service_msgs/README.md\n@@ -0,0 \u002B1,18 @@\n\u002B# service_msgs\n\u002B\n\u002BThis package contains message types used by ROS services.\n\u002B\n\u002BFor more information about ROS services, check out the following links:\n\u002B\n\u002B* [About ROS 2 interfaces](https://docs.ros.org/en/rolling/Concepts/About-ROS-Interfaces.html)\n\u002B* [Understanding services](https://docs.ros.org/en/rolling/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services.html)\n\u002B\n\u002B## Messages (.msg)\n\u002B\n\u002B* [ServiceEventInfo](msg/ServiceEventInfo.msg): Part of a service event message that contains information such as timestamp and event type.\n\u002BThis is part of the Service Introspection feature of ROS 2 (see [REP 2012](https://ros.org/reps/rep-2012.html)).\n\u002B\n\u002B\n\u002B## Quality Declaration\n\u002B\n\u002BSee the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git service_msgs/msg/ServiceEventInfo.msg service_msgs/msg/ServiceEventInfo.msg\nnew file mode 100644\nindex 0000000..58eed78\n--- /dev/null\n\u002B\u002B\u002B service_msgs/msg/ServiceEventInfo.msg\n@@ -0,0 \u002B1,21 @@\n\u002Buint8 REQUEST_SENT = 0\n\u002Buint8 REQUEST_RECEIVED = 1\n\u002Buint8 RESPONSE_SENT = 2\n\u002Buint8 RESPONSE_RECEIVED = 3\n\u002B\n\u002B# The type of event this message represents\n\u002Buint8 event_type\n\u002B\n\u002B# Timestamp for when the event occurred (sent or received time)\n\u002Bbuiltin_interfaces/Time stamp\n\u002B\n\u002B# Unique identifier for the client that sent the service request\n\u002B# Note, this is only unique for the current session.\n\u002B# The size here has to match the size of rmw_dds_common/msg/Gid,\n\u002B# but unfortunately we cannot use that message directly due to a\n\u002B# circular dependency.\n\u002Bchar[16] client_gid\n\u002B\n\u002B# Sequence number for the request\n\u002B# Combined with the client ID, this creates a unique ID for the service transaction\n\u002Bint64 sequence_number\ndiff --git service_msgs/package.xml service_msgs/package.xml\nnew file mode 100644\nindex 0000000..a90fda5\n--- /dev/null\n\u002B\u002B\u002B service_msgs/package.xml\n@@ -0,0 \u002B1,29 @@\n\u002B\u003C?xml version=\u00221.0\u0022?\u003E\n\u002B\u003C?xml-model href=\u0022http://download.ros.org/schema/package_format3.xsd\u0022 schematypens=\u0022http://www.w3.org/2001/XMLSchema\u0022?\u003E\n\u002B\u003Cpackage format=\u00223\u0022\u003E\n\u002B  \u003Cname\u003Eservice_msgs\u003C/name\u003E\n\u002B  \u003Cversion\u003E1.3.1\u003C/version\u003E\n\u002B  \u003Cdescription\u003EMessages definitions common among all ROS services\u003C/description\u003E\n\u002B\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B\n\u002B  \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B\n\u002B  \u003Cauthor email=\u0022brian.chen@openrobotics.org\u0022\u003EBrian Chen\u003C/author\u003E\n\u002B\n\u002B  \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n\u002B  \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n\u002B\n\u002B  \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n\u002B\n\u002B  \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\n\u002B\n\u002B  \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n\u002B\n\u002B  \u003Cmember_of_group\u003Erosidl_interface_packages\u003C/member_of_group\u003E\n\u002B\n\u002B  \u003Cexport\u003E\n\u002B    \u003Cbuild_type\u003Eament_cmake\u003C/build_type\u003E\n\u002B  \u003C/export\u003E\n\u002B\u003C/package\u003E\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rosidl_defaults",
    "SHA": "bab051de528d6246ec38493d27e9996aadda3673",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#18)",
    "Changes": "diff --git rosidl_default_runtime/QUALITY_DECLARATION.md rosidl_default_runtime/QUALITY_DECLARATION.md\nindex 4ff2099..b50cb6e 100644\n--- rosidl_default_runtime/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rosidl_default_runtime/QUALITY_DECLARATION.md\n@@ -10,7 \u002B10,7 @@ Below are the rationales, notes, and caveats for this claim, organized by each r\n \n ### Version Scheme [1.i]\n \n-\u0060rosidl_default_runtime\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).\n\u002B\u0060rosidl_default_runtime\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n \n ### Version Stability [1.ii]\n \n@@ -30,11 \u002B30,11 @@ Below are the rationales, notes, and caveats for this claim, organized by each r\n \n ## Change Control Process [2]\n \n-\u0060rosidl_default_runtime\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).\n\u002B\u0060rosidl_default_runtime\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#quality-practices).\n \n ### Change Requests [2.i]\n \n-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n\u002BAll changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n \n ### Contributor Origin [2.ii]\n \n@@ -78,7 \u002B78,7 @@ There are no source code files in this package and therefore no files are curren\n \n ### Linters and Static Analysis [4.v]\n \n-\u0060rmw\u0060 uses and passes all the standard linters and static analysis tools for a CMake package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).\n\u002B\u0060rmw\u0060 uses and passes all the standard linters and static analysis tools for a CMake package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n \n Results of linter tests can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rosidl_default_runtime/).\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "47f41a55021cc38438ac7290f8fecfb51b5cc101",
    "RawMessage": "Remove deprecated header get_env.h (#417)",
    "Changes": "diff --git README.md README.md\nindex 25c1a52..402595d 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -31,7 \u002B31,6 @@ The API is a combination of parts:\n   - rcutils_get_home_dir()\n   - rcutils_set_env()\n   - rcutils/env.h\n-  - rcutils/get_env.h\n - Extensible logging macros:\n   - Some examples (not exhaustive):\n     - RCUTILS_LOG_DEBUG()\ndiff --git include/rcutils/get_env.h include/rcutils/get_env.h\ndeleted file mode 100644\nindex 381f3de..0000000\n--- include/rcutils/get_env.h\n\u002B\u002B\u002B /dev/null\n@@ -1,30 \u002B0,0 @@\n-// Copyright 2017 Open Source Robotics Foundation, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-/// \\file\n-\n-#ifndef RCUTILS__GET_ENV_H_\n-#define RCUTILS__GET_ENV_H_\n-\n-// TODO(christophebedard) remove this header completely in I-turtle\n-\n-#ifdef _MSC_VER\n-#pragma message (\u0022rcutils/get_env.h has been deprecated, please include rcutils/env.h instead\u0022)\n-#else\n-#warning rcutils/get_env.h has been deprecated, please include rcutils/env.h instead\n-#endif\n-\n-#include \u0022rcutils/env.h\u0022\n-\n-#endif  // RCUTILS__GET_ENV_H_\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "7c929473a408fa527879dc5f2bf04419e717a322",
    "RawMessage": "Fix NodeOptions copy constructor (#1376)",
    "Changes": "diff --git rclcpp/src/rclcpp/node_options.cpp rclcpp/src/rclcpp/node_options.cpp\nindex 017bc35c..e3f1b02d 100644\n--- rclcpp/src/rclcpp/node_options.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_options.cpp\n@@ -67,6 \u002B67,7 @@ NodeOptions \u0026\n NodeOptions::operator=(const NodeOptions \u0026 other)\n {\n   if (this != \u0026other) {\n\u002B    this-\u003Enode_options_.reset();\n     this-\u003Econtext_ = other.context_;\n     this-\u003Earguments_ = other.arguments_;\n     this-\u003Eparameter_overrides_ = other.parameter_overrides_;\n@@ -75,12 \u002B76,14 @@ NodeOptions::operator=(const NodeOptions \u0026 other)\n     this-\u003Euse_intra_process_comms_ = other.use_intra_process_comms_;\n     this-\u003Eenable_topic_statistics_ = other.enable_topic_statistics_;\n     this-\u003Estart_parameter_services_ = other.start_parameter_services_;\n\u002B    this-\u003Estart_parameter_event_publisher_ = other.start_parameter_event_publisher_;\n\u002B    this-\u003Eparameter_event_qos_ = other.parameter_event_qos_;\n     this-\u003Erosout_qos_ = other.rosout_qos_;\n-    this-\u003Eallocator_ = other.allocator_;\n\u002B    this-\u003Eparameter_event_publisher_options_ = other.parameter_event_publisher_options_;\n     this-\u003Eallow_undeclared_parameters_ = other.allow_undeclared_parameters_;\n     this-\u003Eautomatically_declare_parameters_from_overrides_ =\n       other.automatically_declare_parameters_from_overrides_;\n-    this-\u003Enode_options_.reset();\n\u002B    this-\u003Eallocator_ = other.allocator_;\n   }\n   return *this;\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcpputils",
    "SHA": "bf2de5e3edd17bbbe5c1aaafdbe29cb53e1c970c",
    "RawMessage": "Update includes after rcutils/get_env.h deprecation (#132)",
    "Changes": "diff --git src/filesystem_helper.cpp src/filesystem_helper.cpp\nindex f04fb22..c89badf 100644\n--- src/filesystem_helper.cpp\n\u002B\u002B\u002B src/filesystem_helper.cpp\n@@ -60,7 \u002B60,7 @@\n #  include \u003Cunistd.h\u003E\n #endif\n \n-#include \u0022rcutils/get_env.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rcpputils/split.hpp\u0022\n \n namespace rcpputils\ndiff --git src/find_library.cpp src/find_library.cpp\nindex 2cb4e23..81e5da6 100644\n--- src/find_library.cpp\n\u002B\u002B\u002B src/find_library.cpp\n@@ -23,7 \u002B23,6 @@\n #include \u003Cvector\u003E\n \n #include \u0022rcutils/filesystem.h\u0022\n-#include \u0022rcutils/get_env.h\u0022\n \n #include \u0022rcpputils/filesystem_helper.hpp\u0022\n #include \u0022rcpputils/split.hpp\u0022\ndiff --git src/get_env.cpp src/get_env.cpp\nindex 44dd3cd..fd7b548 100644\n--- src/get_env.cpp\n\u002B\u002B\u002B src/get_env.cpp\n@@ -33,7 \u002B33,7 @@\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n \n-#include \u0022rcutils/get_env.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n \n #include \u0022rcpputils/get_env.hpp\u0022\n \ndiff --git test/test_find_library.cpp test/test_find_library.cpp\nindex 523c237..6bb1a24 100644\n--- test/test_find_library.cpp\n\u002B\u002B\u002B test/test_find_library.cpp\n@@ -19,7 \u002B19,7 @@\n \n #include \u0022gtest/gtest.h\u0022\n \n-#include \u0022rcutils/get_env.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rcpputils/find_library.hpp\u0022\n \n namespace\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "679b120ca05cee858f4e180cb0dc5c9836190fb8",
    "RawMessage": "Add client/service QoS getters (#196)",
    "Changes": "diff --git rmw_implementation/src/functions.cpp rmw_implementation/src/functions.cpp\nindex e06aec5..6f2ddee 100644\n--- rmw_implementation/src/functions.cpp\n\u002B\u002B\u002B rmw_implementation/src/functions.cpp\n@@ -489,6 \u002B489,16 @@ RMW_INTERFACE_FN(\n   rmw_ret_t, RMW_RET_ERROR,\n   4, ARG_TYPES(const rmw_client_t *, rmw_service_info_t *, void *, bool *))\n \n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_client_request_publisher_get_actual_qos,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  2, ARG_TYPES(const rmw_client_t *, rmw_qos_profile_t *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_client_response_subscription_get_actual_qos,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  2, ARG_TYPES(const rmw_client_t *, rmw_qos_profile_t *))\n\u002B\n RMW_INTERFACE_FN(\n   rmw_create_service,\n   rmw_service_t *, nullptr,\n@@ -511,6 \u002B521,16 @@ RMW_INTERFACE_FN(\n   rmw_ret_t, RMW_RET_ERROR,\n   3, ARG_TYPES(const rmw_service_t *, rmw_request_id_t *, void *))\n \n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_service_response_publisher_get_actual_qos,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  2, ARG_TYPES(const rmw_service_t *, rmw_qos_profile_t *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_service_request_subscription_get_actual_qos,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  2, ARG_TYPES(const rmw_service_t *, rmw_qos_profile_t *))\n\u002B\n RMW_INTERFACE_FN(\n   rmw_take_event,\n   rmw_ret_t, RMW_RET_ERROR,\n@@ -752,6 \u002B772,8 @@ void prefetch_symbols(void)\n   GET_SYMBOL(rmw_count_subscribers)\n   GET_SYMBOL(rmw_get_gid_for_publisher)\n   GET_SYMBOL(rmw_compare_gids_equal)\n\u002B  GET_SYMBOL(rmw_service_response_publisher_get_actual_qos);\n\u002B  GET_SYMBOL(rmw_service_request_subscription_get_actual_qos);\n   GET_SYMBOL(rmw_service_server_is_available)\n   GET_SYMBOL(rmw_set_log_severity)\n   GET_SYMBOL(rmw_get_publishers_info_by_topic)\n@@ -759,6 \u002B781,8 @@ void prefetch_symbols(void)\n   GET_SYMBOL(rmw_qos_profile_check_compatible)\n   GET_SYMBOL(rmw_publisher_get_network_flow_endpoints)\n   GET_SYMBOL(rmw_subscription_get_network_flow_endpoints)\n\u002B  GET_SYMBOL(rmw_client_request_publisher_get_actual_qos);\n\u002B  GET_SYMBOL(rmw_client_response_subscription_get_actual_qos);\n }\n \n void * symbol_rmw_init = nullptr;\n@@ -830,10 \u002B854,14 @@ unload_library()\n   symbol_rmw_return_loaned_message_from_subscription = nullptr;\n   symbol_rmw_create_client = nullptr;\n   symbol_rmw_destroy_client = nullptr;\n\u002B  symbol_rmw_client_request_publisher_get_actual_qos = nullptr;\n\u002B  symbol_rmw_client_response_subscription_get_actual_qos = nullptr;\n   symbol_rmw_send_request = nullptr;\n   symbol_rmw_take_response = nullptr;\n   symbol_rmw_create_service = nullptr;\n   symbol_rmw_destroy_service = nullptr;\n\u002B  symbol_rmw_service_response_publisher_get_actual_qos = nullptr;\n\u002B  symbol_rmw_service_request_subscription_get_actual_qos = nullptr;\n   symbol_rmw_take_request = nullptr;\n   symbol_rmw_send_response = nullptr;\n   symbol_rmw_take_event = nullptr;\ndiff --git test_rmw_implementation/test/test_client.cpp test_rmw_implementation/test/test_client.cpp\nindex 350359d..db79ae3 100644\n--- test_rmw_implementation/test/test_client.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_client.cpp\n@@ -408,3 \u002B408,52 @@ TEST_F(CLASSNAME(TestClientUse, RMW_IMPLEMENTATION), service_server_is_available\n   }\n   ASSERT_TRUE(is_available);\n }\n\u002B\n\u002BTEST_F(CLASSNAME(TestClient, RMW_IMPLEMENTATION), check_qos) {\n\u002B  constexpr char service_name[] = \u0022/test\u0022;\n\u002B  const rosidl_service_type_support_t * ts =\n\u002B    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n\u002B\n\u002B  rmw_qos_profile_t qos_profile = rmw_qos_profile_services_default;\n\u002B  qos_profile.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  uint64_t duration = 1;\n\u002B  qos_profile.deadline = {duration, duration};\n\u002B  qos_profile.lifespan = {duration, duration};\n\u002B  qos_profile.liveliness_lease_duration = {duration, duration};\n\u002B\n\u002B  rmw_client_t * client =\n\u002B    rmw_create_client(node, ts, service_name, \u0026qos_profile);\n\u002B\n\u002B  rmw_qos_profile_t actual_rp_qos;\n\u002B  rmw_ret_t ret = rmw_client_request_publisher_get_actual_qos(\n\u002B    client,\n\u002B    \u0026actual_rp_qos);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(actual_rp_qos.reliability, qos_profile.reliability);\n\u002B  EXPECT_EQ(actual_rp_qos.durability, qos_profile.durability);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness, qos_profile.liveliness);\n\u002B  EXPECT_EQ(actual_rp_qos.history, qos_profile.history);\n\u002B  EXPECT_EQ(actual_rp_qos.depth, qos_profile.depth);\n\u002B  EXPECT_EQ(actual_rp_qos.deadline.sec, qos_profile.deadline.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.deadline.nsec, qos_profile.deadline.nsec);\n\u002B  EXPECT_EQ(actual_rp_qos.lifespan.sec, qos_profile.lifespan.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.lifespan.nsec, qos_profile.lifespan.nsec);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness_lease_duration.sec, qos_profile.liveliness_lease_duration.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness_lease_duration.nsec, qos_profile.liveliness_lease_duration.nsec);\n\u002B\n\u002B  rmw_qos_profile_t actual_rs_qos;\n\u002B  ret = rmw_client_response_subscription_get_actual_qos(\n\u002B    client,\n\u002B    \u0026actual_rs_qos);\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(actual_rs_qos.reliability, qos_profile.reliability);\n\u002B  EXPECT_EQ(actual_rs_qos.durability, qos_profile.durability);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness, qos_profile.liveliness);\n\u002B  EXPECT_EQ(actual_rs_qos.history, qos_profile.history);\n\u002B  EXPECT_EQ(actual_rs_qos.depth, qos_profile.depth);\n\u002B  EXPECT_EQ(actual_rs_qos.deadline.sec, qos_profile.deadline.sec);\n\u002B  EXPECT_EQ(actual_rs_qos.deadline.nsec, qos_profile.deadline.nsec);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness_lease_duration.sec, qos_profile.liveliness_lease_duration.sec);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness_lease_duration.nsec, qos_profile.liveliness_lease_duration.nsec);\n\u002B}\ndiff --git test_rmw_implementation/test/test_service.cpp test_rmw_implementation/test/test_service.cpp\nindex 830a7df..9118087 100644\n--- test_rmw_implementation/test/test_service.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_service.cpp\n@@ -515,3 \u002B515,53 @@ TEST_F(CLASSNAME(TestService, RMW_IMPLEMENTATION), send_reponse_with_client_gone\n   ret = rmw_send_response(srv, \u0026header.request_id, \u0026service_response);\n   EXPECT_EQ(RMW_RET_OK, ret);\n }\n\u002B\n\u002BTEST_F(CLASSNAME(TestService, RMW_IMPLEMENTATION), check_qos) {\n\u002B  constexpr char service_name[] = \u0022/test\u0022;\n\u002B  const rosidl_service_type_support_t * ts =\n\u002B    ROSIDL_GET_SRV_TYPE_SUPPORT(test_msgs, srv, BasicTypes);\n\u002B\n\u002B  rmw_qos_profile_t qos_profile = rmw_qos_profile_services_default;\n\u002B  qos_profile.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  uint64_t duration = 1;\n\u002B  qos_profile.deadline = {duration, duration};\n\u002B  qos_profile.lifespan = {duration, duration};\n\u002B  qos_profile.liveliness_lease_duration = {duration, duration};\n\u002B\n\u002B  rmw_service_t * srv =\n\u002B    rmw_create_service(node, ts, service_name, \u0026qos_profile);\n\u002B\n\u002B  rmw_qos_profile_t actual_rp_qos;\n\u002B  rmw_ret_t ret = rmw_service_response_publisher_get_actual_qos(\n\u002B    srv,\n\u002B    \u0026actual_rp_qos);\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(actual_rp_qos.reliability, qos_profile.reliability);\n\u002B  EXPECT_EQ(actual_rp_qos.durability, qos_profile.durability);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness, qos_profile.liveliness);\n\u002B  EXPECT_EQ(actual_rp_qos.history, qos_profile.history);\n\u002B  EXPECT_EQ(actual_rp_qos.depth, qos_profile.depth);\n\u002B  EXPECT_EQ(actual_rp_qos.deadline.sec, qos_profile.deadline.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.lifespan.sec, qos_profile.lifespan.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness_lease_duration.sec, qos_profile.liveliness_lease_duration.sec);\n\u002B  EXPECT_EQ(actual_rp_qos.deadline.nsec, qos_profile.deadline.nsec);\n\u002B  EXPECT_EQ(actual_rp_qos.lifespan.nsec, qos_profile.lifespan.nsec);\n\u002B  EXPECT_EQ(actual_rp_qos.liveliness_lease_duration.nsec, qos_profile.liveliness_lease_duration.nsec);\n\u002B\n\u002B  rmw_qos_profile_t actual_rs_qos;\n\u002B  ret = rmw_service_request_subscription_get_actual_qos(\n\u002B    srv,\n\u002B    \u0026actual_rs_qos);\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(actual_rs_qos.reliability, qos_profile.reliability);\n\u002B  EXPECT_EQ(actual_rs_qos.durability, qos_profile.durability);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness, qos_profile.liveliness);\n\u002B  EXPECT_EQ(actual_rs_qos.history, qos_profile.history);\n\u002B  EXPECT_EQ(actual_rs_qos.depth, qos_profile.depth);\n\u002B  EXPECT_EQ(actual_rs_qos.deadline.sec, qos_profile.deadline.sec);\n\u002B  EXPECT_EQ(actual_rs_qos.deadline.nsec, qos_profile.deadline.nsec);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness_lease_duration.sec, qos_profile.liveliness_lease_duration.sec);\n\u002B  EXPECT_EQ(actual_rs_qos.liveliness_lease_duration.nsec, qos_profile.liveliness_lease_duration.nsec);\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "04e75b82aa2c931ee51bb7eeec895d1dbcf413a0",
    "RawMessage": "Added shared memory support usage description",
    "Changes": "diff --git shared_memory_support.md shared_memory_support.md\nnew file mode 100644\nindex 0000000..9c095b7\n--- /dev/null\n\u002B\u002B\u002B shared_memory_support.md\n@@ -0,0 \u002B1,218 @@\n\u002B# Using Shared Memory with ROS2\n\u002B\n\u002BThis rmw_cyclonedds implementation uses [cyclonedds](https://projects.eclipse.org/projects/iot.cyclonedds) which includes support for fast Shared Memory data transfer based on [iceoryx](https://projects.eclipse.org/projects/technology.iceoryx). Since this feature is still in an experimental stage, it is disabled by default but can be enabled easily in a cyclonedds.xml configuration file.\n\u002B\n\u002B## Requirements\n\u002B\n\u002BCurrently Shared Memory transport is only supported on Linux. It is available in the rmw_cyclonedds implementation used by the ROS2 Rolling or Galactic Geochelone distribution.\n\u002B\n\u002B## Installation\n\u002B\n\u002BROS2 needs to be installed as described in [Installing ROS2](https://docs.ros.org/en/rolling/Installation/Ubuntu-Install-Binary.html).\n\u002B\n\u002BIt can also be build from sources directly [Building ROS2](https://docs.ros.org/en/rolling/Installation/Ubuntu-Development-Setup.html).\n\u002B\n\u002BIn both cases rmw_cyclonedds is build with Shared Memory support by default.\n\u002B\n\u002B## Configuration\n\u002B\n\u002BIn your ROS2 workspace \u0060ros2_rolling\u0060 create a configuration file \u0060cyclonedds.xml\u0060 with the following content.\n\u002B\n\u002B\u0060\u0060\u0060xml\n\u002B\u003C?xml version=\u00221.0\u0022 encoding=\u0022UTF-8\u0022 ?\u003E\n\u002B\u003CCycloneDDS xmlns=\u0022https://cdds.io/config\u0022 xmlns:xsi=\u0022http://www.w3.org/2001/XMLSchema-instance\u0022 xsi:schemaLocation=\u0022https://cdds.io/config https://raw.githubusercontent.com/eclipse-cyclonedds/cyclonedds/iceoryx/etc/cyclonedds.xsd\u0022\u003E\n\u002B    \u003CDomain id=\u0022any\u0022\u003E\n\u002B        \u003CSharedMemory\u003E\n\u002B            \u003CEnable\u003Etrue\u003C/Enable\u003E\n\u002B            \u003CSubQueueCapacity\u003E256\u003C/SubQueueCapacity\u003E\n\u002B            \u003CSubHistoryRequest\u003E16\u003C/SubHistoryRequest\u003E\n\u002B            \u003CPubHistoryCapacity\u003E16\u003C/PubHistoryCapacity\u003E\n\u002B            \u003CLogLevel\u003Einfo\u003C/LogLevel\u003E\n\u002B        \u003C/SharedMemory\u003E\n\u002B    \u003C/Domain\u003E\n\u002B\u003C/CycloneDDS\u003E\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BEnter your ROS2 workspace and enable this configuration.\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002Bcd ros2_rolling\n\u002Bexport CYCLONEDDS_URI=file://$PWD/cyclonedds.xml\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B### Configuration file options\n\u002B\n\u002BEnabling Shared Memory imposes additional restrictions on publishers and subscriptions in ROS applications if Shared Memory is used for communication. In this case the data is received using an internal queue (per subscription).\n\u002BNote that depending on the QoS settings Shared Memory might not be used (cf. [Restrictions](#Restrictions)).\n\u002B\n\u002B1. *SubQueueCapacity* defines the maximum number of samples a subscription can locally store in Shared Memory. If more samples arrive via Shared Memory, the least recent ones will be discarded.\n\u002B2. *SubHistoryRequest* is the maximum number of samples a late joining subscription will request from a corresponding publisher.\n\u002B3. *PubHistoryCapacity* is the maximum number of samples a publisher will keep for late joining subscriptions.\n\u002B4. *Loglevel* controls the output of the iceoryx runtime and can be set to verbose, debug, info, warn, error, fatal and off in order of decreasing output level.\n\u002B\n\u002BThe settings in the configuration file above are also the default values when left unspecified and setting them any higher is currently not possible.\n\u002BNote that further aligment with DDS QoS is work in progress. Currently these options exist alongside QoS settings as additional limits.\n\u002B\n\u002B## Run an Example\n\u002B\n\u002BWe can now the simple [talker/listener example](https://docs.ros.org/en/rolling/Installation/Ubuntu-Development-Setup.html#id12).\n\u002BIn one terminal start the talker\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002Bexport CYCLONEDDS_URI=file://$PWD/cyclonedds.xml\n\u002B. ~/ros2_rolling/install/local_setup.bash\n\u002Bros2 run demo_nodes_cpp talker\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Band in another terminal start the listener\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002Bexport CYCLONEDDS_URI=file://$PWD/cyclonedds.xml\n\u002B. ~/ros2_rolling/install/local_setup.bash\n\u002Bros2 run demo_nodes_cpp listener\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BIf the Shared Memory configration was successfully activated and recognized, you should get some output containing\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002B[Warning]: RouDi not found - waiting\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Bin both terminals. This is because with Shared Memory enabled, the iceoryx middleware daemon RouDi (abbreviation for Routing and Discovery) needs to be present and was not started yet.\n\u002BWe can do so by simply running\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002B. ~/ros2_rolling/install/local_setup.bash\n\u002Biox-roudi\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Bin a third terminal. Now the talker should start sending data to the listener.\n\u002B\n\u002BIn this example Shared Memory is not actually used for transfer, since the message type contains a string, which is a dynamically sized data type (cf. [Types](#Types)). \n\u002B\n\u002BNote that RouDi is still required whenever we activate a Shared Memory configuration by exporting the configuration file (it is needed by the underlying cyclonedds implementation in this case).\n\u002BWe could also run the listener or talker without exporting the configuration file and it would still receive data (via network interface). By running both without exporting the configuration file we will not need to have RouDi running anymore (this is the regular ROS2 setup).\n\u002B\n\u002B### Using Shared Memory in the example\n\u002B\n\u002BTo actually use Shared Memory the talker/listener example needs to be slightly rewritten to use a fixed size data type such as an unsigned integer. Adapting the publisher and subscription to use messages of type \u0060std_msgs::msg::UInt64\u0060 instead leads to an example which uses Shared Memory to transport the data. See [Restrictions](#Restrictions) for further information about when Shared Memory transfer will be used.\n\u002B\n\u002BIn the talker we use\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002B    std::unique_ptr\u003Cstd_msgs::msg::UInt64\u003E msg_;\n\u002B    rclcpp::Publisher\u003Cstd_msgs::msg::UInt64\u003E::SharedPtr pub_;\n\u002B    rclcpp::TimerBase::SharedPtr timer_;\n\u002B    // ... \n\u002B    pub_ = this-\u003Ecreate_publisher\u003Cstd_msgs::msg::UInt64\u003E(\u0022chatter\u0022, qos);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Band send the data with\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002B    msg_ = std::make_unique\u003Cstd_msgs::msg::UInt64\u003E();\n\u002B    msg_-\u003Edata = count_\u002B\u002B;\n\u002B    RCLCPP_INFO(this-\u003Eget_logger(), \u0022Publishing: \u0027Hello World: %lu\u0027\u0022, msg_-\u003Edata);\n\u002B    pub_-\u003Epublish(std::move(msg_));\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BSimilarly on the listener side we also change the message type of the subscription\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002B    rclcpp::Subscription\u003Cstd_msgs::msg::UInt64\u003E::SharedPtr sub_;\n\u002B    // ...\n\u002B    sub_ = create_subscription\u003Cstd_msgs::msg::UInt64\u003E(\u0022chatter\u0022, 10, callback);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Band can then receive the data with\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bauto callback =\n\u002B      [this](const std::shared_ptr\u003Cstd_msgs::msg::UInt64\u003E msg) -\u003E void\n\u002B      {\n\u002B        RCLCPP_INFO(this-\u003Eget_logger(), \u0022I heard: [Hello World: %lu]\u0022, msg-\u003Edata);\n\u002B      };\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BNote that by just observing the received data it cannot be determined whether Shared Memory is actually used, but for large data the maximum data rate will be significantly faster compared to the network loopback interface.\n\u002B\n\u002B## Zero-Copy Publish-Subscribe Communication\n\u002B\n\u002BWhether true zero-copy publish subscribe communication via Shared Memory is possible depends on several factors. Here zero copy means no copy or serialization is performed.\n\u002B\n\u002B1. Shared Memory has to be enabled in the configuration.\n\u002B2. The subscription has to be local on the same machine (i.e. same or different process, but no remote subscription).\n\u002B3. The QoS settings admit Shared Memory transfer (cf. [QoS settings](#QoS-settings))\n\u002B4. The message type has fixed size (i.e. no strings or sequences of dynamic length)\n\u002B\n\u002BIf these conditions are satisfied we can publish the data in two different ways, but only by using the loan API we will achieve zero-copy transfer.\n\u002B\n\u002B### Regular Publish API\n\u002B\n\u002BWe first create a message, populate it before passing it to the publisher.\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002B    msg_ = std::make_unique\u003Cstd_msgs::msg::UInt64\u003E();\n\u002B    msg_-\u003Edata = count_\u002B\u002B;      \n\u002B    pub_-\u003Epublish(std::move(msg_));\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BIf the Shared Memory transfer conditions are met, publish will internally loan a Shared Memory chunk from iceoryx and copy the message payload into it without the serialization required for network transfer. Any connected subscription has read-only access to this message data.\n\u002B\n\u002BWhile this API will not allow true zero-copy transfer, it still will improve performance for sufficiently large message sizes since it bypasses the loopback interface and does not perform serialization. The actual size where it will outoperform the loopback interface primarily depends on the actual hardware and system load.\n\u002B\n\u002B### Loan API\n\u002B\n\u002BThe loan API allows for true zero-copy transfer by directly consctructing the message data in Shared Memory. To do so, we first have to loan this Shared Memory chunk explicitly.\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bauto loaned_msg = pub_-\u003Eborrow_loaned_message();\n\u002Bloaned_msg.get().data = count_\u002B\u002B;\n\u002Bpub_-\u003Epublish(std::move(loaned_msg));\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BThe publish overload here does not need to copy the data to Shared Memory since it already resides there. Hence no copy or serialization is performed and the data is transferred to any subscription in constant time (i.e. independent of the message size).\n\u002B\n\u002B## Restrictions\n\u002B\n\u002BThe factors listed above govern whether Shared Memory is used, assuming it was enabled in the configuration. Here we summarize those restrictions and provide some additional details.\n\u002B\n\u002B### Local Subscription\n\u002B\n\u002BOnly local subscriptions on the same machine will receive data via Shared Memory and RouDi is required to enable this. Remote subscriptions will always receive the data via the network interface. There can only be one Roudi process be running per machine.\n\u002B\n\u002B### Types\n\u002B\n\u002BThe message types used must be of a fixed size, i.e. the size can be determined at compile time.\n\u002BThis means strings or variable length arrays of the [available message types](http://wiki.ros.org/msg) cannot be used. Nesting types satisfying the fixed size restriction is also possible.\n\u002B\n\u002B### QoS settings\n\u002B\n\u002BOnly a subset of QoS settings supports Shared Memory. Those are:\n\u002B\n\u002B1. Liveliness: Automatic\n\u002B2. Deadline: Infinity (0)\n\u002B3. Reliability: Reliable\n\u002B    - may be extended to Best Effort as well, but Shared Memory transfer is always reliable\n\u002B4. Durability: Volatile\n\u002B5. History: Keep Last\n\u002B    - with history depth no larger than PubHistoryCapacity (in the configuration file)\n\u002B\n\u002BThese settings are used by default and applicable to a large class of applications.\n\u002B\n\u002B### Number of subscriptions per Process\n\u002B\n\u002BCurrently a process can only have up to 127 subscriptions when Shared Memory is enabled.\n\u002B\n\u002B### Number of active Loans\n\u002B\n\u002BA single publisher can only hold up to 8 loaned messages simultaneously.\n\u002BTo obtain more loaned messages, it needs to publish some of the loaned messages.\n\u002B\n\u002B### Iceoryx Shared Memory Configuration\n\u002B\n\u002BIceoryx uses configurable memory pools to define different sizes of memory chunks that will be used to store messages in Shared Memory. These will be obtained when data is send via iceoryx, either when explicitly requested with the [Loan API](#Loan-API) or implicitly by the [Regular Publish API](#Regular-Publish-API).\n\u002B\n\u002BDepending on the size and frequency of messages send, the default configuration may not be sufficient to guarantee that memory can be loaned and hence the data send. In this case it might help to use a custom configuration for the shared memory pools to increase the available Shared Memory. The configuration options are described in the [iceoryx configuration guide](https://github.com/eclipse-iceoryx/iceoryx/blob/master/doc/website/advanced/configuration-guide.md).\n\u002B\n\u002BNote that currently the internal loan call is blocking, which means if no memory is available it will not return (this will change in the future). This may happen if the configured memory is not sufficient for the overall system load, i.e. the memory needed was not available in the first place or is used by other samples which are currently read or written.\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "a38e9af62498fb0453548ddc5fc7980291b81d4e",
    "RawMessage": "Added more time to copyright on Windwos (#1252)",
    "Changes": "diff --git rviz_common/CMakeLists.txt rviz_common/CMakeLists.txt\nindex 3ec7063f..7741c400 100644\n--- rviz_common/CMakeLists.txt\n\u002B\u002B\u002B rviz_common/CMakeLists.txt\n@@ -452,3 \u002B452,7 @@ endif()\n ament_package(\n   CONFIG_EXTRAS \u0022rviz_common-extras.cmake\u0022\n )\n\u002B\n\u002Bif(TEST copyright)\n\u002B  set_tests_properties(copyright PROPERTIES TIMEOUT 600)\n\u002Bendif()\ndiff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex b845f9d8..1bdc96b1 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -1211,3 \u002B1211,7 @@ ament_package(\n if(TEST cpplint)\n   set_tests_properties(cpplint PROPERTIES TIMEOUT 180)\n endif()\n\u002B\n\u002Bif(TEST copyright)\n\u002B  set_tests_properties(copyright PROPERTIES TIMEOUT 600)\n\u002Bendif()\ndiff --git rviz_rendering/CMakeLists.txt rviz_rendering/CMakeLists.txt\nindex fee1258b..b95e0a30 100644\n--- rviz_rendering/CMakeLists.txt\n\u002B\u002B\u002B rviz_rendering/CMakeLists.txt\n@@ -339,3 \u002B339,7 @@ list(APPEND ${PROJECT_NAME}_CONFIG_EXTRAS\n ament_package(\n   CONFIG_EXTRAS \u0022rviz_rendering-extras.cmake\u0022\n )\n\u002B\n\u002Bif(TEST copyright)\n\u002B  set_tests_properties(copyright PROPERTIES TIMEOUT 600)\n\u002Bendif()\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "eefcb1c594fbbc3ed4a498fa00bef7708b716a9d",
    "RawMessage": "Convert more node accessors to pybind11 (#730)",
    "Changes": "diff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 908b381..35b9457 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -616,35 \u002B616,6 @@ rclpy_create_node(PyObject * self, PyObject * args)\n   return rclpy_detail_execute_with_logging_mutex(rclpy_create_node_impl, self, args);\n }\n \n-/// Get the name of the logger associated with a node.\n-/**\n- * Raises ValueError if pynode is not a node capsule\n- *\n- * \\param[in] pynode Capsule pointing to the node to get the logger name of\n- * \\return logger_name, or\n- * \\return None on failure\n- */\n-static PyObject *\n-rclpy_get_node_logger_name(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  PyObject * pynode;\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pynode)) {\n-    return NULL;\n-  }\n-\n-  rcl_node_t * node = rclpy_handle_get_pointer_from_capsule(pynode, \u0022rcl_node_t\u0022);\n-  if (!node) {\n-    return NULL;\n-  }\n-\n-  const char * node_logger_name = rcl_node_get_logger_name(node);\n-  if (!node_logger_name) {\n-    Py_RETURN_NONE;\n-  }\n-\n-  return PyUnicode_FromString(node_logger_name);\n-}\n-\n /// Get the name of the logger associated with the node of the publisher.\n /**\n  * Raises ValueError if pypublisher is not a publisher capsule\n@@ -853,195 \u002B824,6 @@ rclpy_get_rmw_implementation_identifier(PyObject * Py_UNUSED(self), PyObject * P\n   return pyrmw_implementation_identifier;\n }\n \n-/// Get the list of nodes discovered by the provided node\n-/**\n- *  Raises ValueError if pynode is not a node capsule\n- *  Raises RuntimeError  if there is an rcl error\n- *\n- * \\param[in] module the Python module this function is part of\n- * \\param[in] args arguments tuple, composed by only one argument:\n- *  - node: Capsule pointing to the node\n- * \\param[in] get_enclaves specifies if the output includes the enclaves names or not\n- * \\return Python list of tuples, containing:\n- *  node name, node namespace, and\n- *  enclave if \u0060get_enclaves\u0060 is true.\n- */\n-static PyObject *\n-rclpy_get_node_names_impl(PyObject * module, PyObject * args, bool get_enclaves)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pynode;\n-\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pynode)) {\n-    return NULL;\n-  }\n-\n-  rcl_allocator_t allocator = rcl_get_default_allocator();\n-  rcl_node_t * node = rclpy_handle_get_pointer_from_capsule(pynode, \u0022rcl_node_t\u0022);\n-  if (!node) {\n-    return NULL;\n-  }\n-  rcutils_string_array_t node_names = rcutils_get_zero_initialized_string_array();\n-  rcutils_string_array_t node_namespaces = rcutils_get_zero_initialized_string_array();\n-  rcutils_string_array_t enclaves = rcutils_get_zero_initialized_string_array();\n-  rcl_ret_t ret = RCL_RET_OK;\n-  if (get_enclaves) {\n-    ret = rcl_get_node_names_with_enclaves(\n-      node, allocator, \u0026node_names, \u0026node_namespaces, \u0026enclaves);\n-  } else {\n-    ret = rcl_get_node_names(\n-      node, allocator, \u0026node_names, \u0026node_namespaces);\n-  }\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError, \u0022Failed to get node names: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-\n-  rcutils_ret_t fini_names_ret;\n-  rcutils_ret_t fini_namespaces_ret;\n-  rcutils_ret_t fini_enclaves_ret;\n-  PyObject * pynode_names_and_namespaces = PyList_New(node_names.size);\n-  if (!pynode_names_and_namespaces) {\n-    goto cleanup;\n-  }\n-\n-  size_t idx;\n-  for (idx = 0; idx \u003C node_names.size; \u002B\u002Bidx) {\n-    PyObject * pytuple = PyTuple_New(get_enclaves ? 3 : 2);\n-    if (!pytuple) {\n-      goto cleanup;\n-    }\n-    PyObject * pynode_name = PyUnicode_FromString(node_names.data[idx]);\n-    if (!pynode_name) {\n-      Py_DECREF(pytuple);\n-      goto cleanup;\n-    }\n-    // Steals the reference\n-    PyTuple_SET_ITEM(pytuple, 0, pynode_name);\n-    PyObject * pynode_namespace = PyUnicode_FromString(node_namespaces.data[idx]);\n-    if (!pynode_namespace) {\n-      Py_DECREF(pytuple);\n-      goto cleanup;\n-    }\n-    // Steals the reference\n-    PyTuple_SET_ITEM(pytuple, 1, pynode_namespace);\n-    if (get_enclaves) {\n-      PyObject * pynode_enclaves = PyUnicode_FromString(enclaves.data[idx]);\n-      if (!pynode_enclaves) {\n-        Py_DECREF(pytuple);\n-        goto cleanup;\n-      }\n-      // Steals the reference\n-      PyTuple_SET_ITEM(pytuple, 2, pynode_enclaves);\n-    }\n-    // Steals the reference\n-    PyList_SET_ITEM(pynode_names_and_namespaces, idx, pytuple);\n-  }\n-\n-cleanup:\n-  fini_names_ret = rcutils_string_array_fini(\u0026node_names);\n-  fini_namespaces_ret = rcutils_string_array_fini(\u0026node_namespaces);\n-  fini_enclaves_ret = rcutils_string_array_fini(\u0026enclaves);\n-  if (PyErr_Occurred()) {\n-    Py_XDECREF(pynode_names_and_namespaces);\n-    return NULL;\n-  }\n-  if (fini_names_ret != RCUTILS_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to destroy node_names: %s\u0022, rcl_get_error_string().str);\n-    Py_XDECREF(pynode_names_and_namespaces);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  if (fini_namespaces_ret != RCUTILS_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to destroy node_namespaces: %s\u0022, rcl_get_error_string().str);\n-    Py_XDECREF(pynode_names_and_namespaces);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  if (fini_enclaves_ret != RCUTILS_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to destroy enclaves string array: %s\u0022, rcl_get_error_string().str);\n-    Py_XDECREF(pynode_names_and_namespaces);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-\n-  return pynode_names_and_namespaces;\n-}\n-\n-/// Get the list of nodes discovered by the provided node\n-/**\n- *  Raises ValueError if pynode is not a node capsule\n- *  Raises RuntimeError  if there is an rcl error\n- *\n- * \\param[in] pynode Capsule pointing to the node\n- * \\return Python list of tuples where each tuple contains the two strings:\n- *   the node name and node namespace\n- */\n-static PyObject *\n-rclpy_get_node_names_and_namespaces(PyObject * module, PyObject * args)\n-{\n-  return rclpy_get_node_names_impl(module, args, false);\n-}\n-\n-/// Get the list of nodes discovered by the provided node, with their respective enclaves.\n-/**\n- *  Raises ValueError if pynode is not a node capsule\n- *  Raises RuntimeError  if there is an rcl error\n- *\n- * \\param[in] pynode Capsule pointing to the node\n- * \\return Python list of tuples where each tuple contains three strings:\n- *   node name, node namespace, and enclave.\n- */\n-static PyObject *\n-rclpy_get_node_names_and_namespaces_with_enclaves(\n-  PyObject * module, PyObject * args)\n-{\n-  return rclpy_get_node_names_impl(module, args, true);\n-}\n-\n-/// Get the fully qualified name of the node.\n-/**\n- *  Raises ValueError if pynode is not a node capsule\n- *  Raises RuntimeError  if there is an rcl error\n- *\n- * \\param[in] pynode Capsule pointing to the node\n- * \\return None on failure\n- *         String containing the fully qualified name of the node otherwise\n- */\n-static PyObject *\n-rclpy_node_get_fully_qualified_name(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  PyObject * pynode;\n-\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pynode)) {\n-    return NULL;\n-  }\n-\n-  rcl_node_t * node = rclpy_handle_get_pointer_from_capsule(pynode, \u0022rcl_node_t\u0022);\n-  if (!node) {\n-    return NULL;\n-  }\n-\n-  const char * fully_qualified_node_name = rcl_node_get_fully_qualified_name(node);\n-  if (!fully_qualified_node_name) {\n-    Py_RETURN_NONE;\n-  }\n-\n-  return PyUnicode_FromString(fully_qualified_node_name);\n-}\n-\n /// Fill a given rmw_time_t with python Duration info, if possible.\n /**\n   * \\param[in] pyobject Python Object that should be a Duration, error checking is done\n@@ -1270,10 \u002B1052,6 @@ static PyMethodDef rclpy_methods[] = {\n     \u0022rclpy_create_node\u0022, rclpy_create_node, METH_VARARGS,\n     \u0022Create a Node.\u0022\n   },\n-  {\n-    \u0022rclpy_get_node_logger_name\u0022, rclpy_get_node_logger_name, METH_VARARGS,\n-    \u0022Get the logger name associated with a node.\u0022\n-  },\n   {\n     \u0022rclpy_get_publisher_logger_name\u0022, rclpy_get_publisher_logger_name, METH_VARARGS,\n     \u0022Get the logger name associated with the node of a publisher.\u0022\n@@ -1295,23 \u002B1073,6 @@ static PyMethodDef rclpy_methods[] = {\n     \u0022Get subscriptions info for a topic.\u0022\n   },\n \n-  {\n-    \u0022rclpy_get_node_names_and_namespaces\u0022, rclpy_get_node_names_and_namespaces, METH_VARARGS,\n-    \u0022Get node names and namespaces list from graph API.\u0022\n-  },\n-  {\n-    \u0022rclpy_get_node_names_and_namespaces_with_enclaves\u0022,\n-    rclpy_get_node_names_and_namespaces_with_enclaves,\n-    METH_VARARGS,\n-    \u0022Get node names, namespaces, and enclaves list from graph API.\u0022\n-  },\n-  {\n-    \u0022rclpy_node_get_fully_qualified_name\u0022,\n-    rclpy_node_get_fully_qualified_name,\n-    METH_VARARGS,\n-    \u0022Get the fully qualified name of node.\u0022\n-  },\n-\n   {\n     \u0022rclpy_get_rmw_implementation_identifier\u0022, rclpy_get_rmw_implementation_identifier,\n     METH_NOARGS, \u0022Retrieve the identifier for the active RMW implementation.\u0022\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex 206cb27..e1d25f8 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -315,12 \u002B315,25 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n     \u0022rclpy_deserialize\u0022, \u0026rclpy::deserialize,\n     \u0022Deserialize a ROS message.\u0022);\n \n\u002B  m.def(\n\u002B    \u0022rclpy_node_get_fully_qualified_name\u0022, \u0026rclpy::get_node_fully_qualified_name,\n\u002B    \u0022Get the fully qualified name of node.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_get_node_logger_name\u0022, \u0026rclpy::get_node_logger_name,\n\u002B    \u0022Get the logger name associated with a node.\u0022);\n   m.def(\n     \u0022rclpy_get_node_name\u0022, \u0026rclpy::get_node_name,\n     \u0022Get the name of a node.\u0022);\n   m.def(\n     \u0022rclpy_get_node_namespace\u0022, \u0026rclpy::get_node_namespace,\n     \u0022Get the namespace of a node.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_get_node_names_and_namespaces\u0022, \u0026rclpy::get_node_names_and_namespaces,\n\u002B    \u0022Get node names and namespaces list from graph API.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_get_node_names_and_namespaces_with_enclaves\u0022,\n\u002B    \u0026rclpy::get_node_names_and_namespaces_with_enclaves,\n\u002B    \u0022Get node names, namespaces, and enclaves list from graph API.\u0022);\n \n   m.def(\n     \u0022rclpy_create_event\u0022, \u0026rclpy::create_event,\ndiff --git rclpy/src/rclpy/node.cpp rclpy/src/rclpy/node.cpp\nindex f61b727..092f0cb 100644\n--- rclpy/src/rclpy/node.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/node.cpp\n@@ -16,6 \u002B16,7 @@\n #include \u003Cpybind11/pybind11.h\u003E\n \n #include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcl/graph.h\u003E\n #include \u003Crcl/rcl.h\u003E\n #include \u003Crcl/types.h\u003E\n #include \u003Crcl_interfaces/msg/parameter_type.h\u003E\n@@ -27,15 \u002B28,49 @@\n #include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n-#include \u0022rclpy_common/handle.h\u0022\n-\n #include \u0022rclpy_common/exceptions.hpp\u0022\n\u002B#include \u0022rclpy_common/handle.h\u0022\n \n #include \u0022node.hpp\u0022\n\u002B#include \u0022utils.hpp\u0022\n \n \n namespace rclpy\n {\n\u002Bconst char *\n\u002Bget_node_fully_qualified_name(py::capsule pynode)\n\u002B{\n\u002B  auto node = static_cast\u003Crcl_node_t *\u003E(\n\u002B    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n\u002B  if (!node) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  const char * fully_qualified_node_name = rcl_node_get_fully_qualified_name(node);\n\u002B  if (!fully_qualified_node_name) {\n\u002B    throw RCLError(\u0022Fully qualified name not set\u0022);\n\u002B  }\n\u002B\n\u002B  return fully_qualified_node_name;\n\u002B}\n\u002B\n\u002Bconst char *\n\u002Bget_node_logger_name(py::capsule pynode)\n\u002B{\n\u002B  auto node = static_cast\u003Crcl_node_t *\u003E(\n\u002B    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n\u002B  if (!node) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  const char * node_logger_name = rcl_node_get_logger_name(node);\n\u002B  if (!node_logger_name) {\n\u002B    throw RCLError(\u0022Logger name not set\u0022);\n\u002B  }\n\u002B\n\u002B  return node_logger_name;\n\u002B}\n\u002B\n const char *\n get_node_name(py::capsule pynode)\n {\n@@ -70,6 \u002B105,92 @@ get_node_namespace(py::capsule pynode)\n   return node_namespace;\n }\n \n\u002Bpy::list\n\u002Bget_node_names_impl(py::capsule pynode, bool get_enclaves)\n\u002B{\n\u002B  auto node = static_cast\u003Crcl_node_t *\u003E(\n\u002B    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n\u002B  if (!node) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  rcl_allocator_t allocator = rcl_get_default_allocator();\n\u002B  rcutils_string_array_t node_names = rcutils_get_zero_initialized_string_array();\n\u002B  rcutils_string_array_t node_namespaces = rcutils_get_zero_initialized_string_array();\n\u002B  rcutils_string_array_t enclaves = rcutils_get_zero_initialized_string_array();\n\u002B\n\u002B  rcl_ret_t ret = RCL_RET_OK;\n\u002B  if (get_enclaves) {\n\u002B    ret = rcl_get_node_names_with_enclaves(\n\u002B      node, allocator, \u0026node_names, \u0026node_namespaces, \u0026enclaves);\n\u002B  } else {\n\u002B    ret = rcl_get_node_names(\n\u002B      node, allocator, \u0026node_names, \u0026node_namespaces);\n\u002B  }\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw RCLError(\u0022Failed to get node names\u0022);\n\u002B  }\n\u002B\n\u002B  RCPPUTILS_SCOPE_EXIT(\n\u002B    {\n\u002B      rcutils_ret_t fini_ret = rcutils_string_array_fini(\u0026node_names);\n\u002B      if (RCUTILS_RET_OK != fini_ret) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022[rclpy|\u0022 RCUTILS_STRINGIFY(__FILE__) \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022]: \u0022\n\u002B          \u0022failed to fini node names during error handling: \u0022);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B      fini_ret = rcutils_string_array_fini(\u0026node_namespaces);\n\u002B      if (RCUTILS_RET_OK != fini_ret) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022[rclpy|\u0022 RCUTILS_STRINGIFY(__FILE__) \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022]: \u0022\n\u002B          \u0022failed to fini node namespaces during error handling: \u0022);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B      fini_ret = rcutils_string_array_fini(\u0026enclaves);\n\u002B      if (RCUTILS_RET_OK != fini_ret) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022[rclpy|\u0022 RCUTILS_STRINGIFY(__FILE__) \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022]: \u0022\n\u002B          \u0022failed to fini enclaves string array during error handling: \u0022);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(rcl_get_error_string().str);\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B    });\n\u002B\n\u002B  py::list pynode_names_and_namespaces(node_names.size);\n\u002B  for (size_t idx = 0; idx \u003C node_names.size; \u002B\u002Bidx) {\n\u002B    if (get_enclaves) {\n\u002B      pynode_names_and_namespaces[idx] = py::make_tuple(\n\u002B        py::str(node_names.data[idx]),\n\u002B        py::str(node_namespaces.data[idx]),\n\u002B        py::str(enclaves.data[idx]));\n\u002B    } else {\n\u002B      pynode_names_and_namespaces[idx] = py::make_tuple(\n\u002B        py::str(node_names.data[idx]),\n\u002B        py::str(node_namespaces.data[idx]));\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return pynode_names_and_namespaces;\n\u002B}\n\u002B\n\u002Bpy::list\n\u002Bget_node_names_and_namespaces(py::capsule pynode)\n\u002B{\n\u002B  return get_node_names_impl(pynode, false);\n\u002B}\n\u002B\n\u002Bpy::list\n\u002Bget_node_names_and_namespaces_with_enclaves(py::capsule pynode)\n\u002B{\n\u002B  return get_node_names_impl(pynode, true);\n\u002B}\n\u002B\n /// Create an rclpy.parameter.Parameter from an rcl_variant_t\n /**\n  * \\param[in] pyname name of the parameter\n@@ -246,4 \u002B367,5 @@ get_node_parameters(py::object pyparameter_cls, py::capsule pynode)\n \n   return node_params;\n }\n\u002B\n }  // namespace rclpy\ndiff --git rclpy/src/rclpy/node.hpp rclpy/src/rclpy/node.hpp\nindex 4674001..3d1971c 100644\n--- rclpy/src/rclpy/node.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/node.hpp\n@@ -21,6 \u002B21,28 @@ namespace py = pybind11;\n \n namespace rclpy\n {\n\u002B/// Get the fully qualified name of the node.\n\u002B/**\n\u002B * Raises ValueError if pynode is not a node capsule\n\u002B * Raises RCLError if name is not set\n\u002B *\n\u002B * \\param[in] pynode Capsule pointing to the node\n\u002B * \\return String containing the fully qualified name of the node\n\u002B */\n\u002Bconst char *\n\u002Bget_node_fully_qualified_name(py::capsule pynode);\n\u002B\n\u002B/// Get the name of the logger associated with a node.\n\u002B/**\n\u002B * Raises ValueError if pynode is not a node capsule\n\u002B * Raises RCLError if logger name is not set\n\u002B *\n\u002B * \\param[in] pynode Capsule pointing to the node to get the logger name of\n\u002B * \\return logger_name\n\u002B */\n\u002Bconst char *\n\u002Bget_node_logger_name(py::capsule pynode);\n\u002B\n /// Get the name of a node.\n /**\n  * Raises ValueError if pynode is not a node capsule\n@@ -43,6 \u002B65,46 @@ get_node_name(py::capsule pynode);\n const char *\n get_node_namespace(py::capsule pynode);\n \n\u002B/// Get the list of nodes discovered by the provided node\n\u002B/**\n\u002B * Raises ValueError if pynode is not a node capsule\n\u002B * Raises RCLError if the names are unavailable.\n\u002B *\n\u002B * \\param[in] module the Python module this function is part of\n\u002B * \\param[in] pynode Capsule pointing to the node\n\u002B * \\param[in] get_enclaves specifies if the output includes the enclaves names\n\u002B *            or not\n\u002B * \\return Python list of tuples, containing:\n\u002B *  node name, node namespace, and\n\u002B *  enclave if \u0060get_enclaves\u0060 is true.\n\u002B */\n\u002Bpy::list\n\u002Bget_node_names_impl(py::capsule pynode, bool get_enclaves);\n\u002B\n\u002B/// Get the list of nodes discovered by the provided node\n\u002B/**\n\u002B * Raises ValueError if pynode is not a node capsule\n\u002B * Raises RCLError if the names are unavailable.\n\u002B *\n\u002B * \\param[in] pynode Capsule pointing to the node\n\u002B * \\return Python list of tuples where each tuple contains the two strings:\n\u002B *   the node name and node namespace\n\u002B */\n\u002Bpy::list\n\u002Bget_node_names_and_namespaces(py::capsule pynode);\n\u002B\n\u002B/// Get the list of nodes discovered by the provided node, with their respective enclaves.\n\u002B/**\n\u002B * Raises ValueError if pynode is not a node capsule\n\u002B * Raises RCLError if the names are unavailable.\n\u002B *\n\u002B * \\param[in] pynode Capsule pointing to the node\n\u002B * \\return Python list of tuples where each tuple contains three strings:\n\u002B *   node name, node namespace, and enclave.\n\u002B */\n\u002Bpy::list\n\u002Bget_node_names_and_namespaces_with_enclaves(py::capsule pynode);\n\u002B\n /// Get a list of parameters for the current node\n /**\n  * Raises ValueError if the argument is not a node handle\n@@ -56,6 \u002B118,7 @@ get_node_namespace(py::capsule pynode);\n  */\n py::dict\n get_node_parameters(py::object pyparameter_cls, py::capsule pynode);\n\u002B\n }  // namespace rclpy\n \n #endif  // RCLPY__NODE_HPP_\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw",
    "SHA": "eba8048cba9fc7d410bd010fbc23d03b86af93fa",
    "RawMessage": "Fix rmw_validate_namespace{_with_size} error handling. (#386)",
    "Changes": "diff --git rmw/src/validate_namespace.c rmw/src/validate_namespace.c\nindex b078905..4d290a6 100644\n--- rmw/src/validate_namespace.c\n\u002B\u002B\u002B rmw/src/validate_namespace.c\n@@ -29,9 \u002B29,8 @@ rmw_validate_namespace(\n   int * validation_result,\n   size_t * invalid_index)\n {\n-  if (!namespace_) {\n-    return RMW_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(namespace_, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_validate_namespace_with_size(\n     namespace_, strlen(namespace_), validation_result, invalid_index);\n }\n@@ -43,12 \u002B42,8 @@ rmw_validate_namespace_with_size(\n   int * validation_result,\n   size_t * invalid_index)\n {\n-  if (!namespace_) {\n-    return RMW_RET_INVALID_ARGUMENT;\n-  }\n-  if (!validation_result) {\n-    return RMW_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(namespace_, RMW_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(validation_result, RMW_RET_INVALID_ARGUMENT);\n \n   // Special case for root namepsace\n   if (namespace_length == 1 \u0026\u0026 namespace_[0] == \u0027/\u0027) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "9c81f87f0a4c15e5e0c2438b1a658b17c0c0039a",
    "RawMessage": "Handle typesupport errors on fetch. (#271)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 2fbe397..16286ce 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1568,13 \u002B1568,22 @@ static const rosidl_message_type_support_t * get_typesupport(\n   {\n     return ts;\n   } else {\n\u002B    rcutils_error_string_t prev_error_string = rcutils_get_error_string();\n\u002B    rcutils_reset_error();\n     if ((ts =\n       get_message_typesupport_handle(\n         type_supports, rosidl_typesupport_introspection_cpp::typesupport_identifier)) != nullptr)\n     {\n       return ts;\n     } else {\n-      RMW_SET_ERROR_MSG(\u0022type support not from this implementation\u0022);\n\u002B      rcutils_error_string_t error_string = rcutils_get_error_string();\n\u002B      rcutils_reset_error();\n\u002B      RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B        \u0022Type support not from this implementation. Got:\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022while fetching it\u0022,\n\u002B        prev_error_string.str, error_string.str);\n       return nullptr;\n     }\n   }\n@@ -3728,13 \u002B3737,22 @@ static const rosidl_service_type_support_t * get_service_typesupport(\n   {\n     return ts;\n   } else {\n\u002B    rcutils_error_string_t prev_error_string = rcutils_get_error_string();\n\u002B    rcutils_reset_error();\n     if ((ts =\n       get_service_typesupport_handle(\n         type_supports, rosidl_typesupport_introspection_cpp::typesupport_identifier)) != nullptr)\n     {\n       return ts;\n     } else {\n-      RMW_SET_ERROR_MSG(\u0022service type support not from this implementation\u0022);\n\u002B      rcutils_error_string_t error_string = rcutils_get_error_string();\n\u002B      rcutils_reset_error();\n\u002B      RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B        \u0022Service type support not from this implementation. Got:\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022while fetching it\u0022,\n\u002B        prev_error_string.str, error_string.str);\n       return nullptr;\n     }\n   }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "846905073b9d6d4286f9b4c0378a5cc37889133b",
    "RawMessage": "Get rid of unnecessary and unused RMW switching for logging tests.",
    "Changes": "diff --git test/test_logging.cpp test/test_logging.cpp\nindex 3e5fc14..89e7d48 100644\n--- test/test_logging.cpp\n\u002B\u002B\u002B test/test_logging.cpp\n@@ -21,14 \u002B21,7 @@\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n #include \u0022rcutils/logging.h\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logging_initialization) {\n\u002BTEST(TestLogging, test_logging_initialization) {\n   EXPECT_FALSE(g_rcutils_logging_initialized);\n   ASSERT_EQ(RCUTILS_RET_OK, rcutils_logging_initialize());\n   OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n@@ -66,7 \u002B59,7 @@ struct LogEvent\n };\n LogEvent g_last_log_event;\n \n-TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logging) {\n\u002BTEST(TestLogging, test_logging) {\n   EXPECT_FALSE(g_rcutils_logging_initialized);\n   ASSERT_EQ(RCUTILS_RET_OK, rcutils_logging_initialize());\n   OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n@@ -147,7 \u002B140,7 @@ TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logging) {\n   rcutils_logging_set_output_handler(original_function);\n }\n \n-TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_log_severity) {\n\u002BTEST(TestLogging, test_log_severity) {\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n   int severity;\n   // check supported severities\n@@ -187,7 \u002B180,7 @@ TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_log_severity) {\n     rcutils_logging_severity_level_from_string(\u0022Info\u0022, failing_allocator, \u0026severity));\n }\n \n-TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logger_severities) {\n\u002BTEST(TestLogging, test_logger_severities) {\n   ASSERT_EQ(RCUTILS_RET_OK, rcutils_logging_initialize());\n   OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n   {\n@@ -262,7 \u002B255,7 @@ TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logger_severities) {\n     rcutils_logging_set_logger_level(\u0022rcutils_test_loggers\u0022, 51));\n }\n \n-TEST(CLASSNAME(TestLogging, RMW_IMPLEMENTATION), test_logger_severity_hierarchy) {\n\u002BTEST(TestLogging, test_logger_severity_hierarchy) {\n   ASSERT_EQ(RCUTILS_RET_OK, rcutils_logging_initialize());\n   OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n   {\ndiff --git test/test_logging_custom_env.cpp test/test_logging_custom_env.cpp\nindex 71e2fa3..b1efbe6 100644\n--- test/test_logging_custom_env.cpp\n\u002B\u002B\u002B test/test_logging_custom_env.cpp\n@@ -22,14 \u002B22,7 @@\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n #include \u0022rcutils/logging.h\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-TEST(CLASSNAME(TestLoggingCustomEnv, RMW_IMPLEMENTATION), test_logging) {\n\u002BTEST(TestLoggingCustomEnv, test_logging) {\n   EXPECT_FALSE(g_rcutils_logging_initialized);\n   ASSERT_EQ(RCUTILS_RET_OK, rcutils_logging_initialize());\n   OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n@@ -56,7 \u002B49,7 @@ TEST(CLASSNAME(TestLoggingCustomEnv, RMW_IMPLEMENTATION), test_logging) {\n   EXPECT_EQ(RCUTILS_RET_OK, rcutils_char_array_fini(\u0026msg_buf));\n }\n \n-TEST(CLASSNAME(TestLoggingCustomEnv, RMW_IMPLEMENTATION), test_logging_with_buffering_issues) {\n\u002BTEST(TestLoggingCustomEnv, test_logging_with_buffering_issues) {\n   auto mock = mocking_utils::patch(\u0022lib:rcutils\u0022, setvbuf, [](auto \u0026\u0026 ...) {return -1;});\n   EXPECT_FALSE(g_rcutils_logging_initialized);\n   EXPECT_EQ(RCUTILS_RET_ERROR, rcutils_logging_initialize());\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "2a760acf6bc774e315aa46c8d80a3b33084fc801",
    "RawMessage": "Update packages to use gurumdds-3.0 \u0026 Update README",
    "Changes": "diff --git README.md README.md\nindex abc8ada..84f0b23 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -1,5 \u002B1,5 @@\n # rmw_gurumdds\n-Implementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).  \n\u002BImplementation of the ROS middleware interface using [GurumNetworks GurumDDS](https://www.gurum.cc/index_eng).\n [Installation guide](https://docs.ros.org/en/humble/Installation/DDS-Implementations/Working-with-GurumNetworks-GurumDDS.html) is available.\n \n ## Requirements\n@@ -7,6 \u002B7,7 @@ Required version of GurumDDS depends on the version of this project.\n \n | rmw_gurumdds             | GurumDDS                    |\n |--------------------------|-----------------------------|\n\u002B| 3.4.2  or higher         | higher than 3.0.0           |\n | 3.3.0  or higher         | higher than 2.8.3165        |\n | 3.2.0  or higher         | 2.8.3140 or higher          |\n | 3.1.2  or higher         | 2.8.x                       |\n@@ -16,8 \u002B17,8 @@ Required version of GurumDDS depends on the version of this project.\n This project consists of three packages, \u0060gurumdds_camke_module\u0060, \u0060rmw_gurumdds_cpp\u0060 and \u0060demo_nodes_cpp_native_gurumdds\u0060.\n \n ### gurumdds_cmake_module\n-\u0060gurumdds_cmake_module\u0060 looks for GurumDDS, and provides the information to other packages.  \n-For \u0060gurumdds_cmake_module\u0060 to work properly, you need to set \u0060GURUMDDS_HOME\u0060 environment variable to where GurumDDS is located.  \n\u002B\u0060gurumdds_cmake_module\u0060 looks for GurumDDS, and provides the information to other packages.\n\u002BFor \u0060gurumdds_cmake_module\u0060 to work properly, you need to set \u0060GURUMDDS_HOME\u0060 environment variable to where GurumDDS is located.\n If GurumDDS is normally installed through the debian package, \u0060GURUMDDS_HOME\u0060 will be set automatically.\n For example, if \u0060GURUMDDS_HOME=~/gurumdds\u0060 is set, the directory \u0060~/gurumdds\u0060 will be:\n \u0060\u0060\u0060\n@@ -34,10 \u002B35,10 @@ gurumdds\n \u0060\u0060\u0060\n \n ### rmw_gurumdds_cpp\n-\u0060rmw_gurumdds_cpp\u0060 is the rmw implementation. You can use this rmw implementation by setting environment variable \u0060RMW_IMPLEMENTATION=rmw_gurumdds_cpp\u0060 after installation.  \n-For \u0060rmw_gurumdds_cpp\u0060 to work properly, make sure to set environment variable \u0060GURUMDDS_CONFIG=~/gurumdds.yaml\u0060 and set \u0060allow_loopback\u0060 variable in \u0060gurumdds.yaml\u0060 to \u0060true\u0060.   \n-\u0060gurumdds.yaml\u0060 will be located in \u0060/etc/gurumnet/gurumdds\u0060 if gurumdds is installed through the debian package.  \n-If you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.  \n\u002B\u0060rmw_gurumdds_cpp\u0060 is the rmw implementation. You can use this rmw implementation by setting environment variable \u0060RMW_IMPLEMENTATION=rmw_gurumdds_cpp\u0060 after installation.\n\u002BFor \u0060rmw_gurumdds_cpp\u0060 to work properly, make sure to set environment variable \u0060GURUMDDS_CONFIG=~/gurumdds.yaml\u0060 and set \u0060allow_loopback\u0060 variable in \u0060gurumdds.yaml\u0060 to \u0060true\u0060.\n\u002B\u0060gurumdds.yaml\u0060 will be located in \u0060/etc/gurumnet/gurumdds\u0060 if gurumdds is installed through the debian package.\n\u002BIf you are not familiar with [YAML](https://yaml.org/), please note that YAML only supports spaces, not tabs, for indentation.\n \n \u0060\u0060\u0060\n DATA:\n@@ -49,18 \u002B50,18 @@ DATA:\n \u0060\u0060\u0060\n \n ### rmw_gurumdds_shared_cpp\n-~~\u0060rmw_gurumdds_shared_cpp\u0060 contains some functions used by \u0060rmw_gurumdds_cpp\u0060.~~  \n\u002B~~\u0060rmw_gurumdds_shared_cpp\u0060 contains some functions used by \u0060rmw_gurumdds_cpp\u0060.~~\n This package was integrated into \u0060rmw_gurumdds_cpp\u0060.\n \n ### demo_nodes_cpp_native_gurumdds\n-\u0060demo_nodes_cpp_natvie_gurumdds\u0060 is similar to \u0060demo_nodes_cpp_native\u0060 from ROS2 \u0060demos\u0060.  \n-This demo shows how to access the native handles of \u0060rmw_gurumdds_cpp\u0060.  \n\u002B\u0060demo_nodes_cpp_natvie_gurumdds\u0060 is similar to \u0060demo_nodes_cpp_native\u0060 from ROS2 \u0060demos\u0060.\n\u002BThis demo shows how to access the native handles of \u0060rmw_gurumdds_cpp\u0060.\n This package is disabled by default.\n \n ## Branches\n-There are three active branches in this project: master, humble and foxy.  \n-New changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.  \n-If you want to use this project with ROS2 Rolling Ridley or Foxy Fitzroy, please use master or foxy branch, respectively.\n\u002BThere are three active branches in this project: master, iron, humble.\n\u002BNew changes made in [ROS2 repository](https://github.com/ros2) will be applied to the master branch.\n\u002BIf you want to use this project with ROS2 Rolling Ridley or Iron Irwini, please use master or iron branch, respectively.\n \n ## Implementation Status\n Currently some features are not fully implemented.\ndiff --git gurumdds_cmake_module/package.xml gurumdds_cmake_module/package.xml\nindex 786e329..284f405 100644\n--- gurumdds_cmake_module/package.xml\n\u002B\u002B\u002B gurumdds_cmake_module/package.xml\n@@ -10,7 \u002B10,7 @@\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n-  \u003Cbuild_depend\u003Egurumdds-2.8\u003C/build_depend\u003E\n\u002B  \u003Cbuild_depend\u003Egurumdds-3.0\u003C/build_depend\u003E\n \n   \u003Cbuildtool_export_depend\u003Eament_cmake\u003C/buildtool_export_depend\u003E\n \ndiff --git rmw_gurumdds_cpp/package.xml rmw_gurumdds_cpp/package.xml\nindex ef68c00..713613d 100644\n--- rmw_gurumdds_cpp/package.xml\n\u002B\u002B\u002B rmw_gurumdds_cpp/package.xml\n@@ -11,7 \u002B11,7 @@\n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\n   \u003Cbuildtool_depend\u003Erosidl_cmake\u003C/buildtool_depend\u003E\n \n-  \u003Cbuild_depend\u003Egurumdds-2.8\u003C/build_depend\u003E\n\u002B  \u003Cbuild_depend\u003Egurumdds-3.0\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Egurumdds_cmake_module\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Ercutils\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Ermw\u003C/build_depend\u003E\n@@ -22,7 \u002B22,7 @@\n   \u003Cbuild_depend\u003Erosidl_typesupport_introspection_c\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Erosidl_typesupport_introspection_cpp\u003C/build_depend\u003E\n \n-  \u003Cbuild_export_depend\u003Egurumdds-2.8\u003C/build_export_depend\u003E\n\u002B  \u003Cbuild_export_depend\u003Egurumdds-3.0\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Egurumdds_cmake_module\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Ermw_dds_common\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Erosidl_runtime_c\u003C/build_export_depend\u003E\n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "7335b619224d1aac7c515fb324aee7e29acbd0a6",
    "RawMessage": "Fix up the dependencies in test_tf2. (#277)",
    "Changes": "diff --git test_tf2/CMakeLists.txt test_tf2/CMakeLists.txt\nindex 863c9707..e8c47050 100644\n--- test_tf2/CMakeLists.txt\n\u002B\u002B\u002B test_tf2/CMakeLists.txt\n@@ -12,20 \u002B12,19 @@ endif()\n set(CMAKE_CXX_STANDARD 14)\n \n find_package(ament_cmake_gtest REQUIRED)\n\u002Bfind_package(builtin_interfaces REQUIRED)\n find_package(geometry_msgs REQUIRED)\n find_package(launch_testing_ament_cmake REQUIRED)\n find_package(rclcpp REQUIRED)\n-find_package(rclcpp_action REQUIRED)\n find_package(tf2 REQUIRED)\n # TODO (ahcorde): activate when tf2_bullet is merged\n # find_package(tf2_bullet REQUIRED)\n find_package(tf2_geometry_msgs REQUIRED)\n find_package(tf2_kdl REQUIRED)\n\u002Bfind_package(tf2_ros REQUIRED)\n \n ament_find_gtest()\n \n-include_directories(${GTEST_INCLUDE_DIRS})\n-\n # TODO (ahcorde): activate when tf2_bullet is merged\n # find_package(PkgConfig REQUIRED)\n # pkg_check_modules(bullet REQUIRED bullet)\n@@ -34,15 \u002B33,19 @@ include_directories(${GTEST_INCLUDE_DIRS})\n ament_add_gtest(buffer_core_test test/buffer_core_test.cpp)\n if(TARGET buffer_core_test)\n   ament_target_dependencies(buffer_core_test\n\u002B    builtin_interfaces\n\u002B    geometry_msgs\n     rclcpp\n     tf2\n     tf2_geometry_msgs\n\u002B    tf2_ros\n   )\n endif()\n \n ament_add_gtest(test_message_filter test/test_message_filter.cpp)\n if(TARGET test_message_filter)\n   ament_target_dependencies(test_message_filter\n\u002B    builtin_interfaces\n     geometry_msgs\n     rclcpp\n     tf2\n@@ -62,6 \u002B65,7 @@ endif()\n ament_add_gtest(test_utils test/test_utils.cpp)\n if(TARGET test_utils)\n   ament_target_dependencies(test_utils\n\u002B    geometry_msgs\n     tf2\n     tf2_geometry_msgs\n     tf2_kdl\n@@ -73,7 \u002B77,6 @@ endif()\n # if(TARGET test_buffer_server)\n #   ament_target_dependencies(test_buffer_server\n #     rclcpp\n-#     rclcpp_action\n #     tf2_bullet\n #     tf2_ros\n #   )\n@@ -84,7 \u002B87,6 @@ endif()\n # if(TARGET test_buffer_client)\n #   ament_target_dependencies(test_buffer_client\n #     rclcpp\n-#     rclcpp_action\n #     tf2_bullet\n #     tf2_kdl\n #     tf2_ros\n@@ -96,10 \u002B98,12 @@ endif()\n add_executable(test_static_publisher test/test_static_publisher.cpp)\n if(TARGET test_static_publisher)\n   ament_target_dependencies(test_static_publisher\n-    tf2_ros\n\u002B    geometry_msgs\n     rclcpp\n-    rclcpp_action\n\u002B    tf2\n\u002B    tf2_ros\n   )\n\u002B  target_include_directories(test_static_publisher PRIVATE ${GTEST_INCLUDE_DIRS})\n   target_link_libraries(test_static_publisher ${GTEST_LIBRARIES})\n   add_launch_test(test/static_publisher.launch.py)\n endif()\n@@ -109,7 \u002B113,6 @@ endif()\n # if(TARGET test_tf2_bullet)\n #   ament_target_dependencies(test_tf2_bullet\n #       rclcpp\n-#       rclcpp_action\n #       tf2_bullet\n #       tf2_ros\n #   )\ndiff --git test_tf2/package.xml test_tf2/package.xml\nindex c09378be..74b03d53 100644\n--- test_tf2/package.xml\n\u002B\u002B\u002B test_tf2/package.xml\n@@ -13,21 \u002B13,18 @@\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n\u002B  \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n   \u003Cdepend\u003Egeometry_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Erclcpp\u003C/depend\u003E\n-  \u003Cdepend\u003Erclcpp_action\u003C/depend\u003E\n-  \u003Cdepend\u003Ercpputils\u003C/depend\u003E\n-  \u003Cdepend\u003Ercutils\u003C/depend\u003E\n   \u003Cdepend\u003Etf2\u003C/depend\u003E\n   \u003Cdepend\u003Etf2_geometry_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Etf2_kdl\u003C/depend\u003E\n   \u003Cdepend\u003Etf2_ros\u003C/depend\u003E\n-  \u003Cdepend\u003Elaunch_ros\u003C/depend\u003E\n-\n-  \u003Cexec_depend\u003Etf2_ros_py\u003C/exec_depend\u003E\n \n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Elaunch_ros\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Elaunch_testing_ament_cmake\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Etf2_ros_py\u003C/test_depend\u003E\n \n   \u003Cexport\u003E\n     \u003Cbuild_type\u003Eament_cmake\u003C/build_type\u003E\ndiff --git test_tf2/test/buffer_core_test.cpp test_tf2/test/buffer_core_test.cpp\nindex e8bd841e..e4b242c5 100644\n--- test_tf2/test/buffer_core_test.cpp\n\u002B\u002B\u002B test_tf2/test/buffer_core_test.cpp\n@@ -29,18 \u002B29,29 @@\n \n #if _WIN32\n #define _USE_MATH_DEFINES\n-#include \u003Ccmath\u003E\n #endif\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Ccmath\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Climits\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n \n #include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cbuiltin_interfaces/msg/time.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/quaternion.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/transform.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/transform_stamped.hpp\u003E\n\u002B#include \u003Crclcpp/rclcpp.hpp\u003E\n #include \u003Ctf2/buffer_core.h\u003E\n-#include \u0022tf2/exceptions.h\u0022\n-#include \u003Cchrono\u003E\n-#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u003Ctf2/exceptions.h\u003E\n\u002B#include \u003Ctf2/LinearMath/Quaternion.h\u003E\n\u002B#include \u003Ctf2/time.h\u003E\n #include \u003Ctf2_geometry_msgs/tf2_geometry_msgs.h\u003E\n\u002B#include \u003Ctf2_ros/buffer_interface.h\u003E\n\u002B\n #include \u0022permuter.hpp\u0022\n-#include \u0022tf2/LinearMath/Quaternion.h\u0022\n-#include \u0022tf2/exceptions.h\u0022\n \n void seed_rand()\n {\ndiff --git test_tf2/test/permuter.hpp test_tf2/test/permuter.hpp\nindex 07cc57f7..bd8d29d8 100644\n--- test_tf2/test/permuter.hpp\n\u002B\u002B\u002B test_tf2/test/permuter.hpp\n@@ -33,6 \u002B33,7 @@\n #ifndef ROSTEST_PERMUTER_HPP\n #define ROSTEST_PERMUTER_HPP\n \n\u002B#include \u003Cmemory\u003E\n #include \u003Cmutex\u003E\n #include \u003Cvector\u003E\n \ndiff --git test_tf2/test/test_message_filter.cpp test_tf2/test/test_message_filter.cpp\nindex 15397a69..6e2c46e6 100644\n--- test_tf2/test/test_message_filter.cpp\n\u002B\u002B\u002B test_tf2/test/test_message_filter.cpp\n@@ -29,17 \u002B29,25 @@\n \n /** \\author Josh Faust */\n \n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u003Cbuiltin_interfaces/msg/time.hpp\u003E\n #include \u003Cgeometry_msgs/msg/point_stamped.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/transform_stamped.hpp\u003E\n #include \u003Crclcpp/rclcpp.hpp\u003E\n #include \u003Ctf2/buffer_core.h\u003E\n\u002B#include \u003Ctf2/LinearMath/Quaternion.h\u003E\n\u002B#include \u003Ctf2/LinearMath/Vector3.h\u003E\n\u002B#include \u003Ctf2/time.h\u003E\n\u002B#include \u003Ctf2_ros/buffer_interface.h\u003E\n #include \u003Ctf2_ros/create_timer_ros.h\u003E\n #include \u003Ctf2_ros/message_filter.h\u003E\n \n-#include \u003Cfunctional\u003E\n-#include \u003Cmemory\u003E\n-\n class Notification\n {\n public:\ndiff --git test_tf2/test/test_static_publisher.cpp test_tf2/test/test_static_publisher.cpp\nindex 90ec9b69..edcf73e3 100644\n--- test_tf2/test/test_static_publisher.cpp\n\u002B\u002B\u002B test_tf2/test/test_static_publisher.cpp\n@@ -27,14 \u002B27,24 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cthread\u003E\n\u002B\n #include \u003Cgtest/gtest.h\u003E\n \n-#include \u0022permuter.hpp\u0022\n-#include \u0022tf2/exceptions.h\u0022\n-#include \u0022tf2_ros/transform_listener.h\u0022\n\u002B#include \u003Cgeometry_msgs/msg/transform_stamped.hpp\u003E\n #include \u003Crclcpp/rclcpp.hpp\u003E\n #include \u003Ctf2/buffer_core.h\u003E\n\u002B#include \u003Ctf2/exceptions.h\u003E\n\u002B#include \u003Ctf2/time.h\u003E\n\u002B#include \u003Ctf2_ros/buffer.h\u003E\n\u002B#include \u003Ctf2_ros/buffer_interface.h\u003E\n #include \u003Ctf2_ros/static_transform_broadcaster.h\u003E\n\u002B#include \u003Ctf2_ros/transform_listener.h\u003E\n\u002B\n\u002B#include \u0022permuter.hpp\u0022\n \n TEST(StaticTransformPublisher, a_b_different_times)\n {\ndiff --git test_tf2/test/test_utils.cpp test_tf2/test/test_utils.cpp\nindex 9af8e55f..aebeb1f4 100644\n--- test_tf2/test/test_utils.cpp\n\u002B\u002B\u002B test_tf2/test/test_utils.cpp\n@@ -13,7 \u002B13,12 @@\n // limitations under the License.\n \n #include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cgeometry_msgs/msg/quaternion.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/quaternion_stamped.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/transform.hpp\u003E\n #include \u003Ctf2_geometry_msgs/tf2_geometry_msgs.h\u003E\n\u002B#include \u003Ctf2/LinearMath/Quaternion.h\u003E\n #include \u003Ctf2/utils.h\u003E\n #include \u003Ctf2_kdl/tf2_kdl.h\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcpputils",
    "SHA": "99f2644c9dbc5673b4782005abaa7e5622638c71",
    "RawMessage": "Fix include order for cpplint (#158)",
    "Changes": "diff --git test/test_accumulator.cpp test/test_accumulator.cpp\nindex da31676..c4ec50b 100644\n--- test/test_accumulator.cpp\n\u002B\u002B\u002B test/test_accumulator.cpp\n@@ -20,12 \u002B20,12 @@\n #endif\n #endif\n \n-#include \u003Crcppmath/rolling_mean_accumulator.hpp\u003E\n-\n-#include \u003Cgtest/gtest.h\u003E\n #include \u003Ccmath\u003E\n #include \u003Cmemory\u003E\n \n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcppmath/rolling_mean_accumulator.hpp\u0022\n \n TEST(TestAccumulator, test_accumulator)\n {\ndiff --git test/test_env.cpp test/test_env.cpp\nindex 30a3e0e..81ca59c 100644\n--- test/test_env.cpp\n\u002B\u002B\u002B test/test_env.cpp\n@@ -12,13 \u002B12,12 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Cgtest/gtest.h\u003E\n-\n-#include \u003Crcpputils/env.hpp\u003E\n-\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n \n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/env.hpp\u0022\n \n /* Tests get_env_var.\n  *\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "f7185dc129c40388e66813c96f2ac5dbb73ffe00",
    "RawMessage": "Fixup Executor::spin_all() regression fix (#2517)",
    "Changes": "diff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 42a4d274..95b0d7fc 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -366,24 \u002B366,52 @@ Executor::spin_some_impl(std::chrono::nanoseconds max_duration, bool exhaustive)\n   }\n   RCPPUTILS_SCOPE_EXIT(this-\u003Espinning.store(false); );\n \n\u002B  // clear the wait result and wait for work without blocking to collect the work\n\u002B  // for the first time\n\u002B  // both spin_some and spin_all wait for work at the beginning\n\u002B  wait_result_.reset();\n\u002B  wait_for_work(std::chrono::milliseconds(0));\n\u002B  bool just_waited = true;\n\u002B\n\u002B  // The logic of this while loop is as follows:\n\u002B  //\n\u002B  // - while not shutdown, and spinning (not canceled), and not max duration reached...\n\u002B  // - try to get an executable item to execute, and execute it if available\n\u002B  // - otherwise, reset the wait result, and ...\n\u002B  // - if there was no work available just after waiting, break the loop unconditionally\n\u002B  //   - this is appropriate for both spin_some and spin_all which use this function\n\u002B  // - else if exhaustive = true, then wait for work again\n\u002B  //   - this is only used for spin_all and not spin_some\n\u002B  // - else break\n\u002B  //   - this only occurs with spin_some\n\u002B  //\n\u002B  // The logic of this loop is subtle and should be carefully changed if at all.\n\u002B  // See also:\n\u002B  //   https://github.com/ros2/rclcpp/issues/2508\n\u002B  //   https://github.com/ros2/rclcpp/pull/2517\n   while (rclcpp::ok(context_) \u0026\u0026 spinning.load() \u0026\u0026 max_duration_not_elapsed()) {\n-    if (!wait_result_.has_value()) {\n-      wait_for_work(std::chrono::milliseconds(0));\n-    }\n-\n     AnyExecutable any_exec;\n     if (get_next_ready_executable(any_exec)) {\n       execute_any_executable(any_exec);\n\u002B      just_waited = false;\n     } else {\n-      // If nothing is ready, reset the result to signal we are\n-      // ready to wait again\n\u002B      // if nothing is ready, reset the result to clear it\n       wait_result_.reset();\n-    }\n \n-    if (!wait_result_.has_value() \u0026\u0026 !exhaustive) {\n-      // In the case of spin some, then we can exit\n-      // In the case of spin all, then we will allow ourselves to wait again.\n-      break;\n\u002B      if (just_waited) {\n\u002B        // there was no work after just waiting, always exit in this case\n\u002B        // before the exhaustive condition can be checked\n\u002B        break;\n\u002B      }\n\u002B\n\u002B      if (exhaustive) {\n\u002B        // if exhaustive, wait for work again\n\u002B        // this only happens for spin_all; spin_some only waits at the start\n\u002B        wait_for_work(std::chrono::milliseconds(0));\n\u002B        just_waited = true;\n\u002B      } else {\n\u002B        break;\n\u002B      }\n     }\n   }\n }\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 1a538eaa..a82b702d 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -357,6 \u002B357,7 @@ public:\n   bool\n   is_ready(const rcl_wait_set_t \u0026 wait_set) override\n   {\n\u002B    is_ready_count_\u002B\u002B;\n     for (size_t i = 0; i \u003C wait_set.size_of_guard_conditions; \u002B\u002Bi) {\n       auto rcl_guard_condition = wait_set.guard_conditions[i];\n       if (\u0026gc_.get_rcl_guard_condition() == rcl_guard_condition) {\n@@ -424,8 \u002B425,15 @@ public:\n     return count_;\n   }\n \n\u002B  size_t\n\u002B  get_is_ready_call_count() const\n\u002B  {\n\u002B    return is_ready_count_;\n\u002B  }\n\u002B\n private:\n   std::atomic\u003Csize_t\u003E trigger_count_ = 0;\n\u002B  std::atomic\u003Csize_t\u003E is_ready_count_ = 0;\n   std::atomic\u003Csize_t\u003E count_ = 0;\n   rclcpp::GuardCondition gc_;\n   std::function\u003Cvoid()\u003E on_execute_callback_ = nullptr;\n@@ -869,3 \u002B877,155 @@ TEST(TestExecutors, testSpinWithNonDefaultContext)\n \n   rclcpp::shutdown(non_default_context);\n }\n\u002B\n\u002Btemplate\u003Ctypename T\u003E\n\u002Bclass TestBusyWaiting : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp() override\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B\n\u002B    const auto test_info = ::testing::UnitTest::GetInstance()-\u003Ecurrent_test_info();\n\u002B    std::stringstream test_name;\n\u002B    test_name \u003C\u003C test_info-\u003Etest_case_name() \u003C\u003C \u0022_\u0022 \u003C\u003C test_info-\u003Ename();\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, test_name.str());\n\u002B    callback_group = node-\u003Ecreate_callback_group(\n\u002B      rclcpp::CallbackGroupType::MutuallyExclusive,\n\u002B      /* automatically_add_to_executor_with_node =*/ false);\n\u002B\n\u002B    auto waitable_interfaces = node-\u003Eget_node_waitables_interface();\n\u002B    waitable = std::make_shared\u003CTestWaitable\u003E();\n\u002B    waitable_interfaces-\u003Eadd_waitable(waitable, callback_group);\n\u002B\n\u002B    executor = std::make_shared\u003CT\u003E();\n\u002B    executor-\u003Eadd_callback_group(callback_group, node-\u003Eget_node_base_interface());\n\u002B  }\n\u002B\n\u002B  void TearDown() override\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void\n\u002B  set_up_and_trigger_waitable(std::function\u003Cvoid()\u003E extra_callback = nullptr)\n\u002B  {\n\u002B    this-\u003Ehas_executed = false;\n\u002B    this-\u003Ewaitable-\u003Eset_on_execute_callback([this, extra_callback]() {\n\u002B        if (!this-\u003Ehas_executed) {\n\u002B        // trigger once to see if the second trigger is handled or not\n\u002B        // this follow up trigger simulates new entities becoming ready while\n\u002B        // the executor is executing something else, e.g. subscription got data\n\u002B        // or a timer expired, etc.\n\u002B        // spin_some would not handle this second trigger, since it collects\n\u002B        // work only once, whereas spin_all should handle it since it\n\u002B        // collects work multiple times\n\u002B          this-\u003Ewaitable-\u003Etrigger();\n\u002B          this-\u003Ehas_executed = true;\n\u002B        }\n\u002B        if (nullptr != extra_callback) {\n\u002B          extra_callback();\n\u002B        }\n\u002B    });\n\u002B    this-\u003Ewaitable-\u003Etrigger();\n\u002B  }\n\u002B\n\u002B  void\n\u002B  check_for_busy_waits(std::chrono::steady_clock::time_point start_time)\n\u002B  {\n\u002B    // rough time based check, since the work to be done was very small it\n\u002B    // should be safe to check that we didn\u0027t use more than half the\n\u002B    // max duration, which itself is much larger than necessary\n\u002B    // however, it could still produce a false-positive\n\u002B    EXPECT_LT(\n\u002B      std::chrono::steady_clock::now() - start_time,\n\u002B      max_duration / 2)\n\u002B      \u003C\u003C \u0022executor took a long time to execute when it should have done \u0022\n\u002B      \u003C\u003C \u0022nothing and should not have blocked either, but this could be a \u0022\n\u002B      \u003C\u003C \u0022false negative if the computer is really slow\u0022;\n\u002B\n\u002B    // this check is making some assumptions about the implementation of the\n\u002B    // executors, but it should be safe to say that a busy wait may result in\n\u002B    // hundreds or thousands of calls to is_ready(), but \u0022normal\u0022 executor\n\u002B    // behavior should be within an order of magnitude of the number of\n\u002B    // times that the waitable was executed\n\u002B    ASSERT_LT(waitable-\u003Eget_is_ready_call_count(), 10u * this-\u003Ewaitable-\u003Eget_count());\n\u002B  }\n\u002B\n\u002B  static constexpr auto max_duration = 10s;\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B  rclcpp::CallbackGroup::SharedPtr callback_group;\n\u002B  std::shared_ptr\u003CTestWaitable\u003E waitable;\n\u002B  std::chrono::steady_clock::time_point start_time;\n\u002B  std::shared_ptr\u003CT\u003E executor;\n\u002B  bool has_executed;\n\u002B};\n\u002B\n\u002BTYPED_TEST_SUITE(TestBusyWaiting, ExecutorTypes, ExecutorTypeNames);\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin_all)\n\u002B{\n\u002B  this-\u003Eset_up_and_trigger_waitable();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  this-\u003Eexecutor-\u003Espin_all(this-\u003Emax_duration);\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the initial trigger, and the follow up from in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin_some)\n\u002B{\n\u002B  this-\u003Eset_up_and_trigger_waitable();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  this-\u003Eexecutor-\u003Espin_some(this-\u003Emax_duration);\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the inital trigger, but not the follow up in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 1u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin)\n\u002B{\n\u002B  std::condition_variable cv;\n\u002B  std::mutex cv_m;\n\u002B  bool first_check_passed = false;\n\u002B\n\u002B  this-\u003Eset_up_and_trigger_waitable([\u0026cv, \u0026cv_m, \u0026first_check_passed]() {\n\u002B      cv.notify_one();\n\u002B      if (!first_check_passed) {\n\u002B        std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B        cv.wait_for(lk, 1s, [\u0026]() {return first_check_passed;});\n\u002B      }\n\u002B  });\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  std::thread t([this]() {\n\u002B      this-\u003Eexecutor-\u003Espin();\n\u002B    });\n\u002B\n\u002B  // wait until thread has started (first execute of waitable)\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B    cv.wait_for(lk, 10s);\n\u002B  }\n\u002B  EXPECT_GT(this-\u003Ewaitable-\u003Eget_count(), 0u);\n\u002B\n\u002B  first_check_passed = true;\n\u002B  cv.notify_one();\n\u002B\n\u002B  // wait until the executor has finished (second execute of waitable)\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B    cv.wait_for(lk, 10s);\n\u002B  }\n\u002B  EXPECT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B\n\u002B  this-\u003Eexecutor-\u003Ecancel();\n\u002B  t.join();\n\u002B\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the initial trigger, and the follow up from in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B}\n",
    "BackportedTo": "jazzy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "24d9f0c425b8a621daf4131c0bdd8cd9c175063d",
    "RawMessage": "Use the correct type for BufferClient timeout_padding. (#498)",
    "Changes": "diff --git tf2_ros_py/test/test_buffer_client.py tf2_ros_py/test/test_buffer_client.py\nindex e83b02c6..3b1447dc 100644\n--- tf2_ros_py/test/test_buffer_client.py\n\u002B\u002B\u002B tf2_ros_py/test/test_buffer_client.py\n@@ -127,7 \u002B127,7 @@ class TestBufferClient(unittest.TestCase):\n \n     def test_lookup_transform_true(self):\n         buffer_client = BufferClient(\n-            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=0.0)\n\u002B            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))\n \n         result = buffer_client.lookup_transform(\n             \u0027foo\u0027, \u0027bar\u0027, rclpy.time.Time(), rclpy.duration.Duration(seconds=5.0))\n@@ -137,7 \u002B137,7 @@ class TestBufferClient(unittest.TestCase):\n \n     def test_lookup_transform_fail(self):\n         buffer_client = BufferClient(\n-            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=0.0)\n\u002B            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))\n \n         with self.assertRaises(LookupException) as ex:\n             result = buffer_client.lookup_transform(\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "d41705c35b870cdcb4ef5989ee7a2e169b681b00",
    "RawMessage": "avoid using dds common public mutex directly (#474)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 9667d94..0594465 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1450,6 \u002B1450,12 @@ rmw_context_impl_s::init(rmw_init_options_t * options, size_t domain_id)\n     this-\u003Eclean_up();\n     return RMW_RET_ERROR;\n   }\n\u002B  this-\u003Ecommon.publish_callback = [](const rmw_publisher_t * pub, const void * msg) {\n\u002B      return rmw_publish(\n\u002B        pub,\n\u002B        msg,\n\u002B        nullptr);\n\u002B    };\n \n   rmw_subscription_options_t subscription_options = rmw_get_default_subscription_options();\n   subscription_options.ignore_local_publications = true;\n@@ -1512,6 \u002B1518,9 @@ rmw_context_impl_t::clean_up()\n     destroy_publisher(common.pub);\n     common.pub = nullptr;\n   }\n\u002B  if (common.publish_callback) {\n\u002B    common.publish_callback = nullptr;\n\u002B  }\n   if (common.sub) {\n     destroy_subscription(common.sub);\n     common.sub = nullptr;\n@@ -1757,26 \u002B1766,11 @@ extern \u0022C\u0022 rmw_node_t * rmw_create_node(\n   RET_ALLOC_X(node-\u003Enamespace_, return nullptr);\n   memcpy(const_cast\u003Cchar *\u003E(node-\u003Enamespace_), namespace_, strlen(namespace_) \u002B 1);\n \n-  {\n-    // Though graph_cache methods are thread safe, both cache update and publishing have to also\n-    // be atomic.\n-    // If not, the following race condition is possible:\n-    // node1-update-get-message / node2-update-get-message / node2-publish / node1-publish\n-    // In that case, the last message published is not accurate.\n-    auto common = \u0026context-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    rmw_dds_common::msg::ParticipantEntitiesInfo participant_msg =\n-      common-\u003Egraph_cache.add_node(common-\u003Egid, name, namespace_);\n-    if (RMW_RET_OK != rmw_publish(\n-        common-\u003Epub,\n-        static_cast\u003Cvoid *\u003E(\u0026participant_msg),\n-        nullptr))\n-    {\n-      // If publishing the message failed, we don\u0027t have to publish an update\n-      // after removing it from the graph cache */\n-      static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.remove_node(common-\u003Egid, name, namespace_));\n-      return nullptr;\n-    }\n\u002B  auto common = \u0026context-\u003Eimpl-\u003Ecommon;\n\u002B  rmw_ret_t rmw_ret = common-\u003Eadd_node_graph(\n\u002B    name, namespace_);\n\u002B  if (RMW_RET_OK != rmw_ret) {\n\u002B    return nullptr;\n   }\n \n   cleanup_node.cancel();\n@@ -1798,19 \u002B1792,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_node(rmw_node_t * node)\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto node_impl = static_cast\u003CCddsNode *\u003E(node-\u003Edata);\n \n-  {\n-    // Though graph_cache methods are thread safe, both cache update and publishing have to also\n-    // be atomic.\n-    // If not, the following race condition is possible:\n-    // node1-update-get-message / node2-update-get-message / node2-publish / node1-publish\n-    // In that case, the last message published is not accurate.\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    rmw_dds_common::msg::ParticipantEntitiesInfo participant_msg =\n-      common-\u003Egraph_cache.remove_node(common-\u003Egid, node-\u003Ename, node-\u003Enamespace_);\n-    result_ret = rmw_publish(\n-      common-\u003Epub, static_cast\u003Cvoid *\u003E(\u0026participant_msg), nullptr);\n-  }\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  result_ret = common-\u003Eremove_node_graph(\n\u002B    node-\u003Ename, node-\u003Enamespace_);\n \n   rmw_context_t * context = node-\u003Econtext;\n   rmw_free(const_cast\u003Cchar *\u003E(node-\u003Ename));\n@@ -2664,15 \u002B2648,11 @@ extern \u0022C\u0022 rmw_publisher_t * rmw_create_publisher(\n   // Update graph\n   auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n   const auto cddspub = static_cast\u003Cconst CddsPublisher *\u003E(pub-\u003Edata);\n\u002B  if (RMW_RET_OK != common-\u003Eadd_publisher_graph(\n\u002B      cddspub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n   {\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.associate_writer(cddspub-\u003Egid, common-\u003Egid, node-\u003Ename, node-\u003Enamespace_);\n-    if (RMW_RET_OK != rmw_publish(common-\u003Epub, static_cast\u003Cvoid *\u003E(\u0026msg), nullptr)) {\n-      static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.dissociate_writer(\n-        cddspub-\u003Egid, common-\u003Egid, node-\u003Ename, node-\u003Enamespace_));\n-      return nullptr;\n-    }\n\u002B    return nullptr;\n   }\n \n   cleanup_publisher.cancel();\n@@ -2957,21 \u002B2937,15 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_publisher(rmw_node_t * node, rmw_publisher_t *\n \n   rmw_ret_t ret = RMW_RET_OK;\n   rmw_error_state_t error_state;\n-  {\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    const auto cddspub = static_cast\u003Cconst CddsPublisher *\u003E(publisher-\u003Edata);\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.dissociate_writer(\n-      cddspub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    rmw_ret_t publish_ret =\n-      rmw_publish(common-\u003Epub, static_cast\u003Cvoid *\u003E(\u0026msg), nullptr);\n-    if (RMW_RET_OK != publish_ret) {\n-      error_state = *rmw_get_error_state();\n-      ret = publish_ret;\n-      rmw_reset_error();\n-    }\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  const auto cddspub = static_cast\u003Cconst CddsPublisher *\u003E(publisher-\u003Edata);\n\u002B  rmw_ret_t publish_ret = common-\u003Eremove_publisher_graph(\n\u002B    cddspub-\u003Egid,\n\u002B    node-\u003Ename, node-\u003Enamespace_);\n\u002B  if (RMW_RET_OK != publish_ret) {\n\u002B    error_state = *rmw_get_error_state();\n\u002B    ret = publish_ret;\n\u002B    rmw_reset_error();\n   }\n \n   rmw_ret_t inner_ret = destroy_publisher(publisher);\n@@ -3204,16 \u002B3178,10 @@ extern \u0022C\u0022 rmw_subscription_t * rmw_create_subscription(\n   // Update graph\n   auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n   const auto cddssub = static_cast\u003Cconst CddsSubscription *\u003E(sub-\u003Edata);\n-  std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-  rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-    common-\u003Egraph_cache.associate_reader(cddssub-\u003Egid, common-\u003Egid, node-\u003Ename, node-\u003Enamespace_);\n-  if (RMW_RET_OK != rmw_publish(\n-      common-\u003Epub,\n-      static_cast\u003Cvoid *\u003E(\u0026msg),\n-      nullptr))\n\u002B  if (RMW_RET_OK != common-\u003Eadd_subscriber_graph(\n\u002B      cddssub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n   {\n-    static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.dissociate_reader(\n-      cddssub-\u003Egid, common-\u003Egid, node-\u003Ename, node-\u003Enamespace_));\n     return nullptr;\n   }\n \n@@ -3327,20 \u002B3295,15 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_subscription(rmw_node_t * node, rmw_subscriptio\n   rmw_ret_t ret = RMW_RET_OK;\n   rmw_error_state_t error_state;\n   rmw_error_string_t error_string;\n-  {\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    const auto cddssub = static_cast\u003Cconst CddsSubscription *\u003E(subscription-\u003Edata);\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.dissociate_reader(\n-      cddssub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    ret = rmw_publish(common-\u003Epub, static_cast\u003Cvoid *\u003E(\u0026msg), nullptr);\n-    if (RMW_RET_OK != ret) {\n-      error_state = *rmw_get_error_state();\n-      error_string = rmw_get_error_string();\n-      rmw_reset_error();\n-    }\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  const auto cddssub = static_cast\u003Cconst CddsSubscription *\u003E(subscription-\u003Edata);\n\u002B  ret = common-\u003Eremove_publisher_graph(\n\u002B    cddssub-\u003Egid,\n\u002B    node-\u003Ename, node-\u003Enamespace_);\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    error_state = *rmw_get_error_state();\n\u002B    error_string = rmw_get_error_string();\n\u002B    rmw_reset_error();\n   }\n \n   rmw_ret_t local_ret = destroy_subscription(subscription);\n@@ -5097,50 \u002B5060,6 @@ static void rmw_fini_cs(CddsCS * cs)\n   dds_delete(cs-\u003Epub-\u003Eenth);\n }\n \n-static rmw_ret_t destroy_client(const rmw_node_t * node, rmw_client_t * client)\n-{\n-  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    client,\n-    client-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  auto info = static_cast\u003CCddsClient *\u003E(client-\u003Edata);\n-  clean_waitset_caches();\n-\n-  {\n-    // Update graph\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.dissociate_writer(\n-      info-\u003Eclient.pub-\u003Egid, common-\u003Egid,\n-      node-\u003Ename, node-\u003Enamespace_));\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.dissociate_reader(\n-      info-\u003Eclient.sub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    if (RMW_RET_OK != rmw_publish(\n-        common-\u003Epub,\n-        static_cast\u003Cvoid *\u003E(\u0026msg),\n-        nullptr))\n-    {\n-      RMW_SET_ERROR_MSG(\u0022failed to publish ParticipantEntitiesInfo when destroying service\u0022);\n-    }\n-  }\n-\n-  rmw_fini_cs(\u0026info-\u003Eclient);\n-  delete info;\n-  rmw_free(const_cast\u003Cchar *\u003E(client-\u003Eservice_name));\n-  rmw_client_free(client);\n-  return RMW_RET_OK;\n-}\n-\n extern \u0022C\u0022 rmw_client_t * rmw_create_client(\n   const rmw_node_t * node,\n   const rosidl_service_type_support_t * type_supports,\n@@ -5149,6 \u002B5068,11 @@ extern \u0022C\u0022 rmw_client_t * rmw_create_client(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(qos_policies, nullptr);\n   CddsClient * info = new CddsClient();\n\u002B  auto cleanup_info = rcpputils::make_scope_exit(\n\u002B    [info]() {\n\u002B      delete (info);\n\u002B    });\n\u002B\n #if REPORT_BLOCKED_REQUESTS\n   info-\u003Elastcheck = 0;\n #endif\n@@ -5159,53 \u002B5083,52 @@ extern \u0022C\u0022 rmw_client_t * rmw_create_client(\n       \u0026info-\u003Eclient, \u0026info-\u003Euser_callback_data,\n       node, type_supports, service_name, \u0026adapted_qos_policies, false) != RMW_RET_OK)\n   {\n-    delete (info);\n     return nullptr;\n   }\n\u002B  auto cleanup_fini_cs = rcpputils::make_scope_exit(\n\u002B    [info]() {\n\u002B      rmw_fini_cs(\u0026info-\u003Eclient);\n\u002B    });\n\u002B\n   rmw_client_t * rmw_client = rmw_client_allocate();\n-  RET_NULL_X(rmw_client, goto fail_client);\n\u002B  if (!rmw_client) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  auto cleanup_client = rcpputils::make_scope_exit(\n\u002B    [rmw_client]() {\n\u002B      rmw_client_free(rmw_client);\n\u002B    });\n\u002B\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n   rmw_client-\u003Eimplementation_identifier = eclipse_cyclonedds_identifier;\n   rmw_client-\u003Edata = info;\n   rmw_client-\u003Eservice_name = reinterpret_cast\u003Cconst char *\u003E(rmw_allocate(strlen(service_name) \u002B 1));\n-  RET_NULL_X(rmw_client-\u003Eservice_name, goto fail_service_name);\n\u002B  if (!rmw_client-\u003Eservice_name) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  auto cleanup_service_name = rcpputils::make_scope_exit(\n\u002B    [rmw_client]() {\n\u002B      rmw_free(const_cast\u003Cchar *\u003E(rmw_client-\u003Eservice_name));\n\u002B    });\n   memcpy(const_cast\u003Cchar *\u003E(rmw_client-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n \n\u002B  // Update graph\n\u002B  if (RMW_RET_OK != common-\u003Eadd_client_graph(\n\u002B      info-\u003Eclient.pub-\u003Egid,\n\u002B      info-\u003Eclient.sub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n   {\n-    // Update graph\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.associate_writer(\n-      info-\u003Eclient.pub-\u003Egid, common-\u003Egid,\n-      node-\u003Ename, node-\u003Enamespace_));\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.associate_reader(\n-      info-\u003Eclient.sub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    if (RMW_RET_OK != rmw_publish(\n-        common-\u003Epub,\n-        static_cast\u003Cvoid *\u003E(\u0026msg),\n-        nullptr))\n-    {\n-      static_cast\u003Cvoid\u003E(destroy_client(node, rmw_client));\n-      return nullptr;\n-    }\n\u002B    return nullptr;\n   }\n \n\u002B  cleanup_service_name.cancel();\n\u002B  cleanup_client.cancel();\n\u002B  cleanup_fini_cs.cancel();\n\u002B  cleanup_info.cancel();\n   return rmw_client;\n-fail_service_name:\n-  rmw_client_free(rmw_client);\n-fail_client:\n-  rmw_fini_cs(\u0026info-\u003Eclient);\n-  delete info;\n-  return nullptr;\n }\n \n extern \u0022C\u0022 rmw_ret_t rmw_destroy_client(rmw_node_t * node, rmw_client_t * client)\n-{\n-  return destroy_client(node, client);\n-}\n-\n-static rmw_ret_t destroy_service(const rmw_node_t * node, rmw_service_t * service)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n@@ -5213,39 \u002B5136,29 @@ static rmw_ret_t destroy_service(const rmw_node_t * node, rmw_service_t * servic\n     node-\u003Eimplementation_identifier,\n     eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    service,\n-    service-\u003Eimplementation_identifier,\n\u002B    client,\n\u002B    client-\u003Eimplementation_identifier,\n     eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n-  auto info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n\u002B  auto info = static_cast\u003CCddsClient *\u003E(client-\u003Edata);\n   clean_waitset_caches();\n \n\u002B  // Update graph\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  if (RMW_RET_OK != common-\u003Eremove_client_graph(\n\u002B      info-\u003Eclient.pub-\u003Egid,\n\u002B      info-\u003Eclient.sub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n   {\n-    // Update graph\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.dissociate_writer(\n-      info-\u003Eservice.pub-\u003Egid, common-\u003Egid,\n-      node-\u003Ename, node-\u003Enamespace_));\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.dissociate_reader(\n-      info-\u003Eservice.sub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    if (RMW_RET_OK != rmw_publish(\n-        common-\u003Epub,\n-        static_cast\u003Cvoid *\u003E(\u0026msg),\n-        nullptr))\n-    {\n-      RMW_SET_ERROR_MSG(\u0022failed to publish ParticipantEntitiesInfo when destroying service\u0022);\n-    }\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to publish ParticipantEntitiesInfo when destroying client\u0022);\n   }\n \n-  rmw_fini_cs(\u0026info-\u003Eservice);\n\u002B  rmw_fini_cs(\u0026info-\u003Eclient);\n   delete info;\n-  rmw_free(const_cast\u003Cchar *\u003E(service-\u003Eservice_name));\n-  rmw_service_free(service);\n\u002B  rmw_free(const_cast\u003Cchar *\u003E(client-\u003Eservice_name));\n\u002B  rmw_client_free(client);\n   return RMW_RET_OK;\n }\n \n@@ -5257,6 \u002B5170,10 @@ extern \u0022C\u0022 rmw_service_t * rmw_create_service(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(qos_policies, nullptr);\n   CddsService * info = new CddsService();\n\u002B  auto cleanup_info = rcpputils::make_scope_exit(\n\u002B    [info]() {\n\u002B      delete (info);\n\u002B    });\n   rmw_qos_profile_t adapted_qos_policies =\n     rmw_dds_common::qos_profile_update_best_available_for_services(*qos_policies);\n   if (\n@@ -5264,51 \u002B5181,82 @@ extern \u0022C\u0022 rmw_service_t * rmw_create_service(\n       \u0026info-\u003Eservice, \u0026info-\u003Euser_callback_data,\n       node, type_supports, service_name, \u0026adapted_qos_policies, true) != RMW_RET_OK)\n   {\n-    delete (info);\n     return nullptr;\n   }\n\u002B  auto cleanup_fini_cs = rcpputils::make_scope_exit(\n\u002B    [info]() {\n\u002B      rmw_fini_cs(\u0026info-\u003Eservice);\n\u002B    });\n   rmw_service_t * rmw_service = rmw_service_allocate();\n-  RET_NULL_X(rmw_service, goto fail_service);\n\u002B  if (!rmw_service) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  auto cleanup_service = rcpputils::make_scope_exit(\n\u002B    [rmw_service]() {\n\u002B      rmw_service_free(rmw_service);\n\u002B    });\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n   rmw_service-\u003Eimplementation_identifier = eclipse_cyclonedds_identifier;\n   rmw_service-\u003Edata = info;\n   rmw_service-\u003Eservice_name =\n     reinterpret_cast\u003Cconst char *\u003E(rmw_allocate(strlen(service_name) \u002B 1));\n-  RET_NULL_X(rmw_service-\u003Eservice_name, goto fail_service_name);\n\u002B  if (!rmw_service-\u003Eservice_name) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  auto cleanup_service_name = rcpputils::make_scope_exit(\n\u002B    [rmw_service]() {\n\u002B      rmw_free(const_cast\u003Cchar *\u003E(rmw_service-\u003Eservice_name));\n\u002B    });\n   memcpy(const_cast\u003Cchar *\u003E(rmw_service-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n \n\u002B  // Update graph\n\u002B  if (RMW_RET_OK != common-\u003Eadd_service_graph(\n\u002B      info-\u003Eservice.sub-\u003Egid,\n\u002B      info-\u003Eservice.pub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n   {\n-    // Update graph\n-    auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n-    std::lock_guard\u003Cstd::mutex\u003E guard(common-\u003Enode_update_mutex);\n-    static_cast\u003Cvoid\u003E(common-\u003Egraph_cache.associate_writer(\n-      info-\u003Eservice.pub-\u003Egid, common-\u003Egid,\n-      node-\u003Ename, node-\u003Enamespace_));\n-    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n-      common-\u003Egraph_cache.associate_reader(\n-      info-\u003Eservice.sub-\u003Egid, common-\u003Egid, node-\u003Ename,\n-      node-\u003Enamespace_);\n-    if (RMW_RET_OK != rmw_publish(\n-        common-\u003Epub,\n-        static_cast\u003Cvoid *\u003E(\u0026msg),\n-        nullptr))\n-    {\n-      static_cast\u003Cvoid\u003E(destroy_service(node, rmw_service));\n-      return nullptr;\n-    }\n\u002B    return nullptr;\n   }\n \n\u002B  cleanup_service_name.cancel();\n\u002B  cleanup_service.cancel();\n\u002B  cleanup_fini_cs.cancel();\n\u002B  cleanup_info.cancel();\n   return rmw_service;\n-fail_service_name:\n-  rmw_service_free(rmw_service);\n-fail_service:\n-  rmw_fini_cs(\u0026info-\u003Eservice);\n-  delete info;\n-  return nullptr;\n }\n \n extern \u0022C\u0022 rmw_ret_t rmw_destroy_service(rmw_node_t * node, rmw_service_t * service)\n {\n-  return destroy_service(node, service);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node,\n\u002B    node-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    service,\n\u002B    service-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  auto info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n\u002B  clean_waitset_caches();\n\u002B\n\u002B  // Update graph\n\u002B  auto common = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  if (RMW_RET_OK != common-\u003Eremove_service_graph(\n\u002B      info-\u003Eservice.sub-\u003Egid,\n\u002B      info-\u003Eservice.pub-\u003Egid,\n\u002B      node-\u003Ename, node-\u003Enamespace_))\n\u002B  {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to publish ParticipantEntitiesInfo when destroying service\u0022);\n\u002B  }\n\u002B\n\u002B  rmw_fini_cs(\u0026info-\u003Eservice);\n\u002B  delete info;\n\u002B  rmw_free(const_cast\u003Cchar *\u003E(service-\u003Eservice_name));\n\u002B  rmw_service_free(service);\n\u002B  return RMW_RET_OK;\n }\n \n /////////////////////////////////////////////////////////////////////////////////////////\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "0f47e8851b8d83900893672d1eeffbec58b52080",
    "RawMessage": "remove rmw_localhost_only_t. (#773)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/rmw_init.cpp rmw_fastrtps_shared_cpp/src/rmw_init.cpp\nindex fbd72a1..d37cb94 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n@@ -43,7 \u002B43,6 @@ rmw_init_options_init(\n   init_options-\u003Eenclave = NULL;\n   init_options-\u003Edomain_id = RMW_DEFAULT_DOMAIN_ID;\n   init_options-\u003Esecurity_options = rmw_get_default_security_options();\n-  init_options-\u003Elocalhost_only = RMW_LOCALHOST_ONLY_DEFAULT;\n   init_options-\u003Ediscovery_options = rmw_get_zero_initialized_discovery_options();\n   return rmw_discovery_options_init(\u0026(init_options-\u003Ediscovery_options), 0, \u0026allocator);\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "geometry2",
    "SHA": "254748f2e94dc560104f2b74482e05bacaf28132",
    "RawMessage": "More Intuitive CLI for Static Transform Publisher (#392)",
    "Changes": "diff --git test_tf2/test/buffer_client_tester.launch.py test_tf2/test/buffer_client_tester.launch.py\nindex 2632a5e4..5cd426c5 100644\n--- test_tf2/test/buffer_client_tester.launch.py\n\u002B\u002B\u002B test_tf2/test/buffer_client_tester.launch.py\n@@ -22,7 \u002B22,7 @@ def generate_test_description():\n         package=\u0027tf2_ros\u0027,\n         executable=\u0027static_transform_publisher\u0027,\n         output=\u0027screen\u0027,\n-        arguments=[\u00225\u0022, \u00226\u0022, \u00227\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00221\u0022, \u0022a\u0022, \u0022b\u0022]\n\u002B        arguments=[\u0022--x\u0022, \u00225\u0022, \u0022--y\u0022, \u00226\u0022, \u0022--z\u0022, \u00227\u0022, \u0022--qx\u0022, \u00220\u0022, \u0022--qy\u0022, \u00220\u0022, \u0022--qz\u0022, \u00220\u0022, \u0022--qw\u0022, \u00221\u0022, \u0022--frame-id\u0022, \u0022a\u0022, \u0022--child-frame-id\u0022, \u0022b\u0022]\n     )\n \n     node_buffer_server = Node(\ndiff --git test_tf2/test/static_publisher.launch.py test_tf2/test/static_publisher.launch.py\nindex c2ae21e2..a995fa0c 100644\n--- test_tf2/test/static_publisher.launch.py\n\u002B\u002B\u002B test_tf2/test/static_publisher.launch.py\n@@ -21,13 \u002B21,13 @@ def generate_test_description():\n         package=\u0027tf2_ros\u0027,\n         executable=\u0027static_transform_publisher\u0027,\n         output=\u0027screen\u0027,\n-        arguments=[\u00221\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00221\u0022, \u0022a\u0022, \u0022b\u0022]\n\u002B        arguments=[\u0022--x\u0022, \u00221\u0022, \u0022--y\u0022, \u00220\u0022, \u0022--z\u0022, \u00220\u0022, \u0022--qx\u0022, \u00220\u0022, \u0022--qy\u0022, \u00220\u0022, \u0022--qz\u0022, \u00220\u0022, \u0022--qw\u0022, \u00221\u0022, \u0022--frame-id\u0022, \u0022a\u0022, \u0022--child-frame-id\u0022, \u0022b\u0022]\n     )\n     node_static_transform_publisher_2 = Node(\n         package=\u0027tf2_ros\u0027,\n         executable=\u0027static_transform_publisher\u0027,\n         output=\u0027screen\u0027,\n-        arguments=[\u00220\u0022, \u00221\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00221\u0022, \u0022b\u0022, \u0022c\u0022]\n\u002B        arguments=[\u0022--x\u0022, \u00220\u0022, \u0022--y\u0022, \u00221\u0022, \u0022--z\u0022, \u00220\u0022, \u0022--qx\u0022, \u00220\u0022, \u0022--qy\u0022, \u00220\u0022, \u0022--qz\u0022, \u00220\u0022, \u0022--qw\u0022, \u00221\u0022, \u0022--frame-id\u0022, \u0022b\u0022, \u0022--child-frame-id\u0022, \u0022c\u0022]\n     )\n \n     return LaunchDescription([\ndiff --git test_tf2/test/test_buffer_client.launch.py test_tf2/test/test_buffer_client.launch.py\nindex 3a2b82dc..edfa968a 100644\n--- test_tf2/test/test_buffer_client.launch.py\n\u002B\u002B\u002B test_tf2/test/test_buffer_client.launch.py\n@@ -21,7 \u002B21,7 @@ def generate_test_description():\n         package=\u0027tf2_ros\u0027,\n         executable=\u0027static_transform_publisher\u0027,\n         output=\u0027screen\u0027,\n-        arguments=[\u00225\u0022, \u00226\u0022, \u00227\u0022, \u00220\u0022, \u00220\u0022, \u00220\u0022, \u00221\u0022, \u0022a\u0022, \u0022b\u0022]\n\u002B        arguments=[\u0022--x\u0022, \u00225\u0022, \u0022--y\u0022, \u00226\u0022, \u0022--z\u0022, \u00227\u0022, \u0022--qx\u0022, \u00220\u0022, \u0022--qy\u0022, \u00220\u0022, \u0022--qz\u0022, \u00220\u0022, \u0022--qw\u0022, \u00221\u0022, \u0022--frame-id\u0022, \u0022a\u0022, \u0022--child-frame-id\u0022, \u0022b\u0022]\n     )\n \n     node_buffer_server = Node(\ndiff --git tf2_ros/src/static_transform_broadcaster_program.cpp tf2_ros/src/static_transform_broadcaster_program.cpp\nindex 691ef0c4..e3f52368 100644\n--- tf2_ros/src/static_transform_broadcaster_program.cpp\n\u002B\u002B\u002B tf2_ros/src/static_transform_broadcaster_program.cpp\n@@ -28,76 \u002B28,382 @@\n  */\n \n #include \u003Ctf2/LinearMath/Quaternion.h\u003E\n\u002B#include \u003Ctf2/LinearMath/Vector3.h\u003E\n \n #include \u003Crclcpp/rclcpp.hpp\u003E\n #include \u003Ctf2_ros/static_transform_broadcaster_node.hpp\u003E\n \n #include \u003Ccstdio\u003E\n\u002B#include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cunordered_map\u003E\n #include \u003Cvector\u003E\n \n\u002Bstruct Option\n\u002B{\n\u002B  explicit Option(bool has_arg)\n\u002B  : has_argument(has_arg)\n\u002B  {\n\u002B  }\n\u002B\n\u002B  bool has_argument{false};\n\u002B\n\u002B  virtual std::string visit(const std::string \u0026 optname, const std::string \u0026 stringval) = 0;\n\u002B\n\u002B  virtual ~Option() {}\n\u002B};\n\u002B\n\u002Bstruct DoubleOption final : Option\n\u002B{\n\u002B  explicit DoubleOption(bool has_arg, std::function\u003Cvoid(double)\u003E cb)\n\u002B  : Option(has_arg),\n\u002B    callback(cb)\n\u002B  {\n\u002B  }\n\u002B\n\u002B  std::function\u003Cvoid(double)\u003E callback;\n\u002B\n\u002B  std::string visit(const std::string \u0026 optname, const std::string \u0026 stringval) override\n\u002B  {\n\u002B    double value;\n\u002B    try {\n\u002B      value = std::stod(stringval);\n\u002B    } catch (const std::invalid_argument \u0026) {\n\u002B      return \u0022Failed to parse \u0022 \u002B optname \u002B \u0022 argument as float\u0022;\n\u002B    }\n\u002B\n\u002B    callback(value);\n\u002B\n\u002B    return \u0022\u0022;\n\u002B  }\n\u002B};\n\u002B\n\u002Bstruct StringOption final : Option\n\u002B{\n\u002B  explicit StringOption(bool has_arg, std::function\u003Cvoid(const std::string \u0026)\u003E cb)\n\u002B  : Option(has_arg),\n\u002B    callback(cb)\n\u002B  {\n\u002B  }\n\u002B\n\u002B  std::function\u003Cvoid(const std::string \u0026)\u003E callback;\n\u002B\n\u002B  std::string visit(const std::string \u0026 optname, const std::string \u0026 stringval) override\n\u002B  {\n\u002B    (void)optname;\n\u002B    callback(stringval);\n\u002B    return \u0022\u0022;\n\u002B  }\n\u002B};\n\u002B\n\u002Bstatic std::string parse_args(\n\u002B  const std::vector\u003Cstd::string\u003E \u0026 args,\n\u002B  bool \u0026 help,\n\u002B  tf2::Quaternion \u0026 quat,\n\u002B  tf2::Vector3 \u0026 trans,\n\u002B  std::string \u0026 frame_id,\n\u002B  std::string \u0026 child_frame_id)\n\u002B{\n\u002B  size_t size = args.size();\n\u002B\n\u002B  help = false;\n\u002B\n\u002B  if (size \u003C 1) {\n\u002B    return \u0022Not enough arguments to parse\u0022;\n\u002B  }\n\u002B\n\u002B  size_t last_index = size - 1;\n\u002B\n\u002B  bool saw_frame_flag = false;\n\u002B  bool saw_quat_flag = false;\n\u002B  bool saw_rpy_flag = false;\n\u002B  bool saw_trans_flag = false;\n\u002B  double roll = 0.0;\n\u002B  double pitch = 0.0;\n\u002B  double yaw = 0.0;\n\u002B\n\u002B  auto qx_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026quat, \u0026saw_quat_flag](double value) {\n\u002B      quat.setX(value);\n\u002B      saw_quat_flag = true;\n\u002B    });\n\u002B\n\u002B  auto qy_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026quat, \u0026saw_quat_flag](double value) {\n\u002B      quat.setY(value);\n\u002B      saw_quat_flag = true;\n\u002B    });\n\u002B\n\u002B  auto qz_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026quat, \u0026saw_quat_flag](double value) {\n\u002B      quat.setZ(value);\n\u002B      saw_quat_flag = true;\n\u002B    });\n\u002B\n\u002B  auto qw_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026quat, \u0026saw_quat_flag](double value) {\n\u002B      quat.setW(value);\n\u002B      saw_quat_flag = true;\n\u002B    });\n\u002B\n\u002B  auto roll_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026roll, \u0026saw_rpy_flag](double value) {\n\u002B      roll = value;\n\u002B      saw_rpy_flag = true;\n\u002B    });\n\u002B\n\u002B  auto pitch_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026pitch, \u0026saw_rpy_flag](double value) {\n\u002B      pitch = value;\n\u002B      saw_rpy_flag = true;\n\u002B    });\n\u002B\n\u002B  auto yaw_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026yaw, \u0026saw_rpy_flag](double value) {\n\u002B      yaw = value;\n\u002B      saw_rpy_flag = true;\n\u002B    });\n\u002B\n\u002B  auto trans_x_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026trans, \u0026saw_trans_flag](double value) {\n\u002B      trans.setX(value);\n\u002B      saw_trans_flag = true;\n\u002B    });\n\u002B\n\u002B  auto trans_y_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026trans, \u0026saw_trans_flag](double value) {\n\u002B      trans.setY(value);\n\u002B      saw_trans_flag = true;\n\u002B    });\n\u002B\n\u002B  auto trans_z_opt = std::make_shared\u003CDoubleOption\u003E(\n\u002B    true, [\u0026trans, \u0026saw_trans_flag](double value) {\n\u002B      trans.setZ(value);\n\u002B      saw_trans_flag = true;\n\u002B    });\n\u002B\n\u002B  auto frame_id_opt = std::make_shared\u003CStringOption\u003E(\n\u002B    true, [\u0026frame_id, \u0026saw_frame_flag](const std::string \u0026 value) {\n\u002B      frame_id = value;\n\u002B      saw_frame_flag = true;\n\u002B    });\n\u002B\n\u002B  auto child_frame_id_opt = std::make_shared\u003CStringOption\u003E(\n\u002B    true, [\u0026child_frame_id, \u0026saw_frame_flag](const std::string \u0026 value) {\n\u002B      child_frame_id = value;\n\u002B      saw_frame_flag = true;\n\u002B    });\n\u002B\n\u002B  auto help_opt = std::make_shared\u003CStringOption\u003E(\n\u002B    false, [\u0026help](const std::string \u0026 value) {\n\u002B      (void)value;\n\u002B      help = true;\n\u002B    });\n\u002B\n\u002B  std::unordered_map\u003Cstd::string, std::shared_ptr\u003COption\u003E\u003E options = {\n\u002B    {\u0022--qx\u0022, qx_opt},\n\u002B    {\u0022--qy\u0022, qy_opt},\n\u002B    {\u0022--qz\u0022, qz_opt},\n\u002B    {\u0022--qw\u0022, qw_opt},\n\u002B    {\u0022--roll\u0022, roll_opt},\n\u002B    {\u0022--pitch\u0022, pitch_opt},\n\u002B    {\u0022--yaw\u0022, yaw_opt},\n\u002B    {\u0022--x\u0022, trans_x_opt},\n\u002B    {\u0022--y\u0022, trans_y_opt},\n\u002B    {\u0022--z\u0022, trans_z_opt},\n\u002B    {\u0022--frame-id\u0022, frame_id_opt},\n\u002B    {\u0022--child-frame-id\u0022, child_frame_id_opt},\n\u002B    {\u0022--help\u0022, help_opt},\n\u002B    {\u0022-h\u0022, help_opt},\n\u002B  };\n\u002B\n\u002B  std::vector\u003Cstd::string\u003E no_flag_args;\n\u002B\n\u002B  size_t i = 1;\n\u002B  while (i \u003C size) {\n\u002B    const std::string \u0026 optname = args[i];\n\u002B    if (options.count(optname) == 0) {\n\u002B      no_flag_args.push_back(optname);\n\u002B    } else {\n\u002B      std::shared_ptr\u003COption\u003E opt = options[optname];\n\u002B      if (opt-\u003Ehas_argument) {\n\u002B        if (i == last_index) {\n\u002B          return \u0022Not enough arguments for \u0022 \u002B optname;\n\u002B        }\n\u002B\n\u002B        \u002B\u002Bi;\n\u002B      }\n\u002B      std::string result = opt-\u003Evisit(optname, args[i]);\n\u002B      if (result != \u0022\u0022) {\n\u002B        return result;\n\u002B      }\n\u002B    }\n\u002B    \u002B\u002Bi;\n\u002B  }\n\u002B\n\u002B  if (help) {\n\u002B    return \u0022\u0022;\n\u002B  }\n\u002B\n\u002B  if (saw_rpy_flag \u0026\u0026 saw_quat_flag) {\n\u002B    return \u0022Cannot specify both quaternion and Euler rotations\u0022;\n\u002B  } else if (saw_rpy_flag) {\n\u002B    quat.setRPY(roll, pitch, yaw);\n\u002B  }\n\u002B\n\u002B  if (no_flag_args.size() == 8 || no_flag_args.size() == 9) {\n\u002B    RCUTILS_LOG_WARN(\u0022Old-style arguments are deprecated; see --help for new-style arguments\u0022);\n\u002B    if (saw_frame_flag || saw_trans_flag || saw_quat_flag) {\n\u002B      return \u0022Cannot specify both new-style (flags) and old-style (arguments)\u0022;\n\u002B    }\n\u002B\n\u002B    std::string ret;\n\u002B\n\u002B    ret = trans_x_opt-\u003Evisit(\u0022x\u0022, no_flag_args[0]);\n\u002B    if (ret != \u0022\u0022) {\n\u002B      return ret;\n\u002B    }\n\u002B    ret = trans_y_opt-\u003Evisit(\u0022y\u0022, no_flag_args[1]);\n\u002B    if (ret != \u0022\u0022) {\n\u002B      return ret;\n\u002B    }\n\u002B    ret = trans_z_opt-\u003Evisit(\u0022z\u0022, no_flag_args[2]);\n\u002B    if (ret != \u0022\u0022) {\n\u002B      return ret;\n\u002B    }\n\u002B\n\u002B    if (no_flag_args.size() == 8) {\n\u002B      ret = yaw_opt-\u003Evisit(\u0022yaw\u0022, no_flag_args[3]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      ret = pitch_opt-\u003Evisit(\u0022pitch\u0022, no_flag_args[4]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      ret = roll_opt-\u003Evisit(\u0022roll\u0022, no_flag_args[5]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B\n\u002B      quat.setRPY(roll, pitch, yaw);\n\u002B      frame_id = no_flag_args[6];\n\u002B      child_frame_id = no_flag_args[7];\n\u002B    } else {\n\u002B      ret = qx_opt-\u003Evisit(\u0022qx\u0022, no_flag_args[3]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      ret = qy_opt-\u003Evisit(\u0022qy\u0022, no_flag_args[4]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      ret = qz_opt-\u003Evisit(\u0022qz\u0022, no_flag_args[5]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      ret = qw_opt-\u003Evisit(\u0022qw\u0022, no_flag_args[6]);\n\u002B      if (ret != \u0022\u0022) {\n\u002B        return ret;\n\u002B      }\n\u002B      frame_id = no_flag_args[7];\n\u002B      child_frame_id = no_flag_args[8];\n\u002B    }\n\u002B  } else if (no_flag_args.size() != 0) {\n\u002B    return \u0022Extra unparsed arguments on command-line\u0022;\n\u002B  }\n\u002B\n\u002B  if (frame_id == \u0022\u0022) {\n\u002B    return \u0022Frame id must not be empty\u0022;\n\u002B  }\n\u002B\n\u002B  if (child_frame_id == \u0022\u0022) {\n\u002B    return \u0022Child frame id must not be empty\u0022;\n\u002B  }\n\u002B\n\u002B  return \u0022\u0022;\n\u002B}\n\u002B\n\u002Bstatic void print_usage()\n\u002B{\n\u002B  const char * usage =\n\u002B    \u0022usage: static_transform_publisher [--x X] [--y Y] [--z Z] [--qx QX] [--qy QY] \u0022\n\u002B    \u0022[--qz QZ] [--qw QW] [--roll ROLL] [--pitch PITCH] [--yaw YAW] --frame-id FRAME_ID \u0022\n\u002B    \u0022--child-frame-id CHILD_FRAME_ID\\n\\n\u0022\n\u002B    \u0022A command line utility for manually sending a static transform.\\n\\nIf no translation or\u0022\n\u002B    \u0022 orientation is provided, the identity transform will be published.\\n\\nThe translation offsets\u0022\n\u002B    \u0022 are in meters.\\n\\nThe rotation may be provided with roll, pitch, yaw euler angles in radians,\u0022\n\u002B    \u0022 or as a quaternion.\\n\\n\u0022\n\u002B    \u0022required arguments:\\n\u0022\n\u002B    \u0022  --frame-id FRAME_ID parent frame\\n\u0022\n\u002B    \u0022  --child-frame-id CHILD_FRAME_ID child frame id\\n\\n\u0022\n\u002B    \u0022optional arguments:\\n\u0022\n\u002B    \u0022  --x X                 x component of translation\\n\u0022\n\u002B    \u0022  --y Y                 y component of translation\\n\u0022\n\u002B    \u0022  --z Z                 z component of translation\\n\u0022\n\u002B    \u0022  --qx QX               x component of quaternion rotation\\n\u0022\n\u002B    \u0022  --qy QY               y component of quaternion rotation\\n\u0022\n\u002B    \u0022  --qz QZ               z component of quaternion rotation\\n\u0022\n\u002B    \u0022  --qw QW               w component of quaternion rotation\\n\u0022\n\u002B    \u0022  --roll ROLL           roll component Euler rotation\\n\u0022\n\u002B    \u0022  --pitch PITCH         pitch component Euler rotation\\n\u0022\n\u002B    \u0022  --yaw YAW             yaw component Euler rotation\u0022;\n\u002B  printf(\u0022%s\\n\u0022, usage);\n\u002B}\n\u002B\n int main(int argc, char ** argv)\n {\n   // Initialize ROS\n   std::vector\u003Cstd::string\u003E args = rclcpp::init_and_remove_ros_arguments(argc, argv);\n-  rclcpp::NodeOptions options;\n-  std::shared_ptr\u003Ctf2_ros::StaticTransformBroadcasterNode\u003E node;\n\u002B  bool help = false;\n\u002B  tf2::Quaternion rotation(0.0, 0.0, 0.0, 1.0);\n\u002B  tf2::Vector3 translation(0.0, 0.0, 0.0);\n\u002B  std::string frame_id;\n\u002B  std::string child_frame_id;\n \n-  if (args.size() != 9 \u0026\u0026 args.size() != 10) {\n-    printf(\u0022A command line utility for manually sending a transform.\\n\u0022);\n-    printf(\u0022Usage: static_transform_publisher x y z qx qy qz qw frame_id child_frame_id \\n\u0022);\n-    printf(\u0022OR \\n\u0022);\n-    printf(\u0022Usage: static_transform_publisher x y z yaw pitch roll frame_id child_frame_id \\n\u0022);\n-    RCUTILS_LOG_ERROR(\n-      \u0022static_transform_publisher exited due to not having the right number of arguments\u0022);\n-    return 2;\n\u002B  std::string ret = parse_args(args, help, rotation, translation, frame_id, child_frame_id);\n\u002B  if (ret != \u0022\u0022) {\n\u002B    RCUTILS_LOG_ERROR(\u0022error parsing command line arguments: %s\u0022, ret.c_str());\n\u002B    print_usage();\n\u002B    return 1;\n   }\n-  double x = std::stod(args[1]);\n-  double y = std::stod(args[2]);\n-  double z = std::stod(args[3]);\n-  double rx, ry, rz, rw;\n-  std::string frame_id, child_id;\n-\n-  if (args.size() == 9) {\n-    // grab parameters from yaw, pitch, roll\n-    tf2::Quaternion quat;\n-    quat.setRPY(std::stod(args[6]), std::stod(args[5]), std::stod(args[4]));\n-    rx = quat.x();\n-    ry = quat.y();\n-    rz = quat.z();\n-    rw = quat.w();\n-    frame_id = args[7];\n-    child_id = args[8];\n-  } else {\n-    // quaternion supplied directly\n-    rx = std::stod(args[4]);\n-    ry = std::stod(args[5]);\n-    rz = std::stod(args[6]);\n-    rw = std::stod(args[7]);\n-    frame_id = args[8];\n-    child_id = args[9];\n\u002B  if (help) {\n\u002B    print_usage();\n\u002B    return 0;\n   }\n \n\u002B  rclcpp::NodeOptions options;\n   // override default parameters with the desired transform\n   options.parameter_overrides(\n   {\n-    {\u0022translation.x\u0022, x},\n-    {\u0022translation.y\u0022, y},\n-    {\u0022translation.z\u0022, z},\n-    {\u0022rotation.x\u0022, rx},\n-    {\u0022rotation.y\u0022, ry},\n-    {\u0022rotation.z\u0022, rz},\n-    {\u0022rotation.w\u0022, rw},\n\u002B    {\u0022translation.x\u0022, translation.x()},\n\u002B    {\u0022translation.y\u0022, translation.y()},\n\u002B    {\u0022translation.z\u0022, translation.z()},\n\u002B    {\u0022rotation.x\u0022, rotation.x()},\n\u002B    {\u0022rotation.y\u0022, rotation.y()},\n\u002B    {\u0022rotation.z\u0022, rotation.z()},\n\u002B    {\u0022rotation.w\u0022, rotation.w()},\n     {\u0022frame_id\u0022, frame_id},\n-    {\u0022child_frame_id\u0022, child_id},\n\u002B    {\u0022child_frame_id\u0022, child_frame_id},\n   });\n \n\u002B  std::shared_ptr\u003Ctf2_ros::StaticTransformBroadcasterNode\u003E node;\n\u002B\n   node = std::make_shared\u003Ctf2_ros::StaticTransformBroadcasterNode\u003E(options);\n \n   RCLCPP_INFO(\n-    node-\u003Eget_logger(), \u0022Spinning until killed publishing transform from \u0027%s\u0027 to \u0027%s\u0027\u0022,\n-    frame_id.c_str(), child_id.c_str());\n\u002B    node-\u003Eget_logger(),\n\u002B    \u0022Spinning until stopped - publishing transform\\ntranslation: (\u0027%lf\u0027, \u0027%lf\u0027, \u0027%lf\u0027)\\n\u0022\n\u002B    \u0022rotation: (\u0027%lf\u0027, \u0027%lf\u0027, \u0027%lf\u0027, \u0027%lf\u0027)\\nfrom \u0027%s\u0027 to \u0027%s\u0027\u0022,\n\u002B    translation.x(), translation.y(), translation.z(),\n\u002B    rotation.x(), rotation.y(), rotation.z(), rotation.w(),\n\u002B    frame_id.c_str(), child_frame_id.c_str());\n\u002B\n   rclcpp::spin(node);\n\u002B\n\u002B  rclcpp::shutdown();\n\u002B\n   return 0;\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "de353f9e45ca2ef191708e557f217eda843ab46a",
    "RawMessage": "Reserve vector capacities and use emplace_back for constructing vectors (#1464)",
    "Changes": "diff --git rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\nindex 1696e267..107166da 100644\n--- rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\n@@ -265,11 \u002B265,13 @@ public:\n       throw std::runtime_error(\n               \u0022Can\u0027t get available states. State machine is not initialized.\u0022);\n     }\n\u002B\n\u002B    resp-\u003Eavailable_states.resize(state_machine_.transition_map.states_size);\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.states_size; \u002B\u002Bi) {\n-      lifecycle_msgs::msg::State state;\n-      state.id = static_cast\u003Cuint8_t\u003E(state_machine_.transition_map.states[i].id);\n-      state.label = static_cast\u003Cstd::string\u003E(state_machine_.transition_map.states[i].label);\n-      resp-\u003Eavailable_states.push_back(state);\n\u002B      resp-\u003Eavailable_states[i].id =\n\u002B        static_cast\u003Cuint8_t\u003E(state_machine_.transition_map.states[i].id);\n\u002B      resp-\u003Eavailable_states[i].label =\n\u002B        static_cast\u003Cstd::string\u003E(state_machine_.transition_map.states[i].label);\n     }\n   }\n \n@@ -286,16 \u002B288,17 @@ public:\n               \u0022Can\u0027t get available transitions. State machine is not initialized.\u0022);\n     }\n \n\u002B    resp-\u003Eavailable_transitions.resize(state_machine_.current_state-\u003Evalid_transition_size);\n     for (unsigned int i = 0; i \u003C state_machine_.current_state-\u003Evalid_transition_size; \u002B\u002Bi) {\n\u002B      lifecycle_msgs::msg::TransitionDescription \u0026 trans_desc = resp-\u003Eavailable_transitions[i];\n\u002B\n       auto rcl_transition = state_machine_.current_state-\u003Evalid_transitions[i];\n-      lifecycle_msgs::msg::TransitionDescription trans_desc;\n       trans_desc.transition.id = static_cast\u003Cuint8_t\u003E(rcl_transition.id);\n       trans_desc.transition.label = rcl_transition.label;\n       trans_desc.start_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.start-\u003Eid);\n       trans_desc.start_state.label = rcl_transition.start-\u003Elabel;\n       trans_desc.goal_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.goal-\u003Eid);\n       trans_desc.goal_state.label = rcl_transition.goal-\u003Elabel;\n-      resp-\u003Eavailable_transitions.push_back(trans_desc);\n     }\n   }\n \n@@ -312,16 \u002B315,17 @@ public:\n               \u0022Can\u0027t get available transitions. State machine is not initialized.\u0022);\n     }\n \n\u002B    resp-\u003Eavailable_transitions.resize(state_machine_.transition_map.transitions_size);\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.transitions_size; \u002B\u002Bi) {\n\u002B      lifecycle_msgs::msg::TransitionDescription \u0026 trans_desc = resp-\u003Eavailable_transitions[i];\n\u002B\n       auto rcl_transition = state_machine_.transition_map.transitions[i];\n-      lifecycle_msgs::msg::TransitionDescription trans_desc;\n       trans_desc.transition.id = static_cast\u003Cuint8_t\u003E(rcl_transition.id);\n       trans_desc.transition.label = rcl_transition.label;\n       trans_desc.start_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.start-\u003Eid);\n       trans_desc.start_state.label = rcl_transition.start-\u003Elabel;\n       trans_desc.goal_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.goal-\u003Eid);\n       trans_desc.goal_state.label = rcl_transition.goal-\u003Elabel;\n-      resp-\u003Eavailable_transitions.push_back(trans_desc);\n     }\n   }\n \n@@ -336,9 \u002B340,10 @@ public:\n   get_available_states()\n   {\n     std::vector\u003CState\u003E states;\n\u002B    states.reserve(state_machine_.transition_map.states_size);\n\u002B\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.states_size; \u002B\u002Bi) {\n-      State state(\u0026state_machine_.transition_map.states[i]);\n-      states.push_back(state);\n\u002B      states.emplace_back(\u0026state_machine_.transition_map.states[i]);\n     }\n     return states;\n   }\n@@ -347,11 \u002B352,10 @@ public:\n   get_available_transitions()\n   {\n     std::vector\u003CTransition\u003E transitions;\n\u002B    transitions.reserve(state_machine_.transition_map.transitions_size);\n \n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.transitions_size; \u002B\u002Bi) {\n-      Transition transition(\n-        \u0026state_machine_.transition_map.transitions[i]);\n-      transitions.push_back(transition);\n\u002B      transitions.emplace_back(\u0026state_machine_.transition_map.transitions[i]);\n     }\n     return transitions;\n   }\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "3b1144f1e0c775d8e6cee240618a0bc0647ec9db",
    "RawMessage": "Use FindPython3 and make python3 dependency explicit (#1745)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex c1cb8bf3..76876b4b 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -1,4 \u002B1,4 @@\n-cmake_minimum_required(VERSION 3.5)\n\u002Bcmake_minimum_required(VERSION 3.12)\n \n project(rclcpp)\n \n@@ -109,6 \u002B109,8 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/waitable.cpp\n )\n \n\u002Bfind_package(Python3 REQUIRED COMPONENTS Interpreter)\n\u002B\n # \u0022watch\u0022 template for changes\n configure_file(\n   \u0022resource/logging.hpp.em\u0022\n@@ -122,7 \u002B124,7 @@ set(python_code_logging\n string(REPLACE \u0022;\u0022 \u0022$\u003CSEMICOLON\u003E\u0022 python_code_logging \u0022${python_code_logging}\u0022)\n add_custom_command(OUTPUT include/rclcpp/logging.hpp\n   COMMAND ${CMAKE_COMMAND} -E make_directory \u0022include/rclcpp\u0022\n-  COMMAND ${PYTHON_EXECUTABLE} ARGS -c \u0022${python_code_logging}\u0022\n\u002B  COMMAND Python3::Interpreter ARGS -c \u0022${python_code_logging}\u0022\n   DEPENDS \u0022${CMAKE_CURRENT_BINARY_DIR}/logging.hpp.em.watch\u0022\n   COMMENT \u0022Expanding logging.hpp.em\u0022\n   VERBATIM\n@@ -146,7 \u002B148,7 @@ foreach(interface_file ${interface_files})\n   string(REPLACE \u0022;\u0022 \u0022$\u003CSEMICOLON\u003E\u0022 python_${interface_name}_traits \u0022${python_${interface_name}_traits}\u0022)\n   add_custom_command(OUTPUT include/rclcpp/node_interfaces/${interface_name}_traits.hpp\n     COMMAND ${CMAKE_COMMAND} -E make_directory \u0022include/rclcpp/node_interfaces\u0022\n-    COMMAND ${PYTHON_EXECUTABLE} ARGS -c \u0022${python_${interface_name}_traits}\u0022\n\u002B    COMMAND Python3::Interpreter ARGS -c \u0022${python_${interface_name}_traits}\u0022\n     DEPENDS \u0022${CMAKE_CURRENT_BINARY_DIR}/${interface_name}_traits.hpp.em.watch\u0022\n     COMMENT \u0022Expanding interface_traits.hpp.em into ${interface_name}_traits.hpp\u0022\n     VERBATIM\n@@ -166,7 \u002B168,7 @@ foreach(interface_file ${interface_files})\n   string(REPLACE \u0022;\u0022 \u0022$\u003CSEMICOLON\u003E\u0022 python_get_${interface_name} \u0022${python_get_${interface_name}}\u0022)\n   add_custom_command(OUTPUT include/rclcpp/node_interfaces/get_${interface_name}.hpp\n     COMMAND ${CMAKE_COMMAND} -E make_directory \u0022include/rclcpp/node_interfaces\u0022\n-    COMMAND ${PYTHON_EXECUTABLE} ARGS -c \u0022${python_get_${interface_name}}\u0022\n\u002B    COMMAND Python3::Interpreter ARGS -c \u0022${python_get_${interface_name}}\u0022\n     DEPENDS \u0022${CMAKE_CURRENT_BINARY_DIR}/get_${interface_name}.hpp.em.watch\u0022\n     COMMENT \u0022Expanding get_interface.hpp.em into get_${interface_file}.hpp\u0022\n     VERBATIM\ndiff --git rclcpp/package.xml rclcpp/package.xml\nindex 56726b94..ae5228e6 100644\n--- rclcpp/package.xml\n\u002B\u002B\u002B rclcpp/package.xml\n@@ -11,6 \u002B11,7 @@\n   \u003Cauthor email=\u0022dthomas@openrobotics.org\u0022\u003EDirk Thomas\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\n\u002B  \u003Cbuildtool_depend\u003Epython3\u003C/buildtool_depend\u003E\n \n   \u003Cbuild_depend\u003Eament_index_cpp\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Ebuiltin_interfaces\u003C/build_depend\u003E\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "9a8476474c655de908da5ae59374781614d712a4",
    "RawMessage": "Fix memory leak when adding the same key to the logger hash map multiple times (#391)",
    "Changes": "diff --git src/logging.c src/logging.c\nindex 1374ddc..f2656df 100644\n--- src/logging.c\n\u002B\u002B\u002B src/logging.c\n@@ -771,13 \u002B771,20 @@ int rcutils_logging_get_logger_level(const char * name)\n \n static rcutils_ret_t add_key_to_hash_map(const char * name, int level, bool set_by_user)\n {\n-  // Copy the name that we will store, as there is no guarantee that the caller will keep it around.\n-\n-  char * copy_name = rcutils_strdup(name, g_rcutils_logging_allocator);\n-  if (copy_name == NULL) {\n-    // Don\u0027t report an error to the error handling machinery; some uses of this function are for\n-    // caching so this is not necessarily fatal.\n-    return RCUTILS_RET_ERROR;\n\u002B  const char * copy_name = name;\n\u002B  // Check if key already exists, to avoid extra memory allocation\n\u002B  // If the key already exists, then rcutils_hash_map_set will not maintain the key we give it,\n\u002B  // so we do not need to copy the name\n\u002B  bool already_exists = rcutils_hash_map_key_exists(\u0026g_rcutils_logging_severities_map, \u0026copy_name);\n\u002B\n\u002B  if (!already_exists) {\n\u002B    // Copy the name to be stored, as there is no guarantee that the caller will keep it around.\n\u002B    copy_name = rcutils_strdup(name, g_rcutils_logging_allocator);\n\u002B    if (copy_name == NULL) {\n\u002B      // Don\u0027t report an error to the error handling machinery; some uses of this function are for\n\u002B      // caching so this is not necessarily fatal.\n\u002B      return RCUTILS_RET_ERROR;\n\u002B    }\n   }\n \n   if (set_by_user) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "aabd37999dff37888e4b07b12631bfe2afa76adc",
    "RawMessage": "Removed some functions in common.c and replaced them in utils.cpp (#787)",
    "Changes": "diff --git rclpy/src/rclpy/action_client.cpp rclpy/src/rclpy/action_client.cpp\nindex 4a7e1be..a30fcf3 100644\n--- rclpy/src/rclpy/action_client.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_client.cpp\n@@ -49,8 \u002B49,7 @@ ActionClient::ActionClient(\n : node_(node)\n {\n   rosidl_action_type_support_t * ts =\n-    static_cast\u003Crosidl_action_type_support_t *\u003E(rclpy_common_get_type_support(\n-      pyaction_type.ptr()));\n\u002B    static_cast\u003Crosidl_action_type_support_t *\u003E(common_get_type_support(pyaction_type));\n   if (!ts) {\n     throw py::error_already_set();\n   }\ndiff --git rclpy/src/rclpy/action_goal_handle.cpp rclpy/src/rclpy/action_goal_handle.cpp\nindex ac73071..012c00f 100644\n--- rclpy/src/rclpy/action_goal_handle.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_goal_handle.cpp\n@@ -33,19 \u002B33,16 @@ ActionGoalHandle::ActionGoalHandle(\n   rclpy::ActionServer \u0026 action_server, py::object pygoal_info_msg)\n : action_server_(action_server)\n {\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  auto goal_info_msg = static_cast\u003Crcl_action_goal_info_t *\u003E(\n-    rclpy_convert_from_py(pygoal_info_msg.ptr(), \u0026destroy_ros_message));\n\u002B  auto goal_info_msg = convert_from_py(pygoal_info_msg);\n\u002B  rcl_action_goal_info_t * goal_info_msg_ptr =\n\u002B    static_cast\u003Crcl_action_goal_info_t *\u003E(goal_info_msg.get());\n \n   if (!goal_info_msg) {\n     throw py::error_already_set();\n   }\n \n-  auto goal_info_msg_ptr = std::unique_ptr\u003Crcl_action_goal_info_t, decltype(destroy_ros_message)\u003E(\n-    goal_info_msg, destroy_ros_message);\n-\n   auto rcl_handle = rcl_action_accept_new_goal(\n-    action_server.rcl_ptr(), goal_info_msg);\n\u002B    action_server.rcl_ptr(), goal_info_msg_ptr);\n   if (!rcl_handle) {\n     throw rclpy::RCLError(\u0022Failed to accept new goal\u0022);\n   }\ndiff --git rclpy/src/rclpy/action_server.cpp rclpy/src/rclpy/action_server.cpp\nindex f250a1c..16a6a14 100644\n--- rclpy/src/rclpy/action_server.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.cpp\n@@ -53,7 \u002B53,7 @@ ActionServer::ActionServer(\n   rcl_clock_t * clock = rclpy_clock.rcl_ptr();\n \n   rosidl_action_type_support_t * ts = static_cast\u003Crosidl_action_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pyaction_type.ptr()));\n\u002B    common_get_type_support(pyaction_type));\n   if (!ts) {\n     throw py::error_already_set();\n   }\ndiff --git rclpy/src/rclpy/client.cpp rclpy/src/rclpy/client.cpp\nindex 3cf06f7..b3a1ca2 100644\n--- rclpy/src/rclpy/client.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/client.cpp\n@@ -42,7 \u002B42,7 @@ Client::Client(\n : node_(node)\n {\n   auto srv_type = static_cast\u003Crosidl_service_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pysrv_type.ptr()));\n\u002B    common_get_type_support(pysrv_type));\n   if (!srv_type) {\n     throw py::error_already_set();\n   }\n@@ -92,15 \u002B92,13 @@ Client::Client(\n int64_t\n Client::send_request(py::object pyrequest)\n {\n-  destroy_ros_message_signature * destroy_ros_message = nullptr;\n-  void * raw_ros_request = rclpy_convert_from_py(pyrequest.ptr(), \u0026destroy_ros_message);\n\u002B  auto raw_ros_request = convert_from_py(pyrequest);\n   if (!raw_ros_request) {\n     throw py::error_already_set();\n   }\n \n   int64_t sequence_number;\n-  rcl_ret_t ret = rcl_send_request(rcl_client_.get(), raw_ros_request, \u0026sequence_number);\n-  destroy_ros_message(raw_ros_request);\n\u002B  rcl_ret_t ret = rcl_send_request(rcl_client_.get(), raw_ros_request.get(), \u0026sequence_number);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to send request\u0022);\n   }\ndiff --git rclpy/src/rclpy/publisher.cpp rclpy/src/rclpy/publisher.cpp\nindex c735de5..cec229c 100644\n--- rclpy/src/rclpy/publisher.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/publisher.cpp\n@@ -24,6 \u002B24,7 @@\n \n #include \u0022exceptions.hpp\u0022\n #include \u0022publisher.hpp\u0022\n\u002B#include \u0022utils.hpp\u0022\n \n namespace rclpy\n {\n@@ -33,7 \u002B34,7 @@ Publisher::Publisher(\n : node_(node)\n {\n   auto msg_type = static_cast\u003Crosidl_message_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pymsg_type.ptr()));\n\u002B    common_get_type_support(pymsg_type));\n   if (!msg_type) {\n     throw py::error_already_set();\n   }\n@@ -120,14 \u002B121,12 @@ Publisher::get_topic_name()\n void\n Publisher::publish(py::object pymsg)\n {\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  void * raw_ros_message = rclpy_convert_from_py(pymsg.ptr(), \u0026destroy_ros_message);\n\u002B  auto raw_ros_message = convert_from_py(pymsg);\n   if (!raw_ros_message) {\n     throw py::error_already_set();\n   }\n \n-  rcl_ret_t ret = rcl_publish(rcl_publisher_.get(), raw_ros_message, NULL);\n-  destroy_ros_message(raw_ros_message);\n\u002B  rcl_ret_t ret = rcl_publish(rcl_publisher_.get(), raw_ros_message.get(), NULL);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022Failed to publish\u0022);\n   }\ndiff --git rclpy/src/rclpy/serialization.cpp rclpy/src/rclpy/serialization.cpp\nindex 2551be2..6b2228f 100644\n--- rclpy/src/rclpy/serialization.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/serialization.cpp\n@@ -29,6 \u002B29,7 @@\n \n #include \u0022exceptions.hpp\u0022\n #include \u0022serialization.hpp\u0022\n\u002B#include \u0022utils.hpp\u0022\n \n namespace rclpy\n {\n@@ -59,14 \u002B60,12 @@ serialize(py::object pymsg, py::object pymsg_type)\n {\n   // Get type support\n   auto ts = static_cast\u003Crosidl_message_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pymsg_type.ptr()));\n\u002B    common_get_type_support(pymsg_type));\n   if (!ts) {\n     throw py::error_already_set();\n   }\n \n-  destroy_ros_message_signature * destroy_ros_message = nullptr;\n-  auto ros_msg = std::unique_ptr\u003Cvoid, decltype(destroy_ros_message)\u003E(\n-    rclpy_convert_from_py(pymsg.ptr(), \u0026destroy_ros_message), destroy_ros_message);\n\u002B  auto ros_msg = convert_from_py(pymsg);\n   if (!ros_msg) {\n     throw py::error_already_set();\n   }\n@@ -91,7 \u002B90,7 @@ deserialize(py::bytes pybuffer, py::object pymsg_type)\n {\n   // Get type support\n   auto ts = static_cast\u003Crosidl_message_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pymsg_type.ptr()));\n\u002B    common_get_type_support(pymsg_type));\n   if (!ts) {\n     throw py::error_already_set();\n   }\n@@ -111,13 \u002B110,10 @@ deserialize(py::bytes pybuffer, py::object pymsg_type)\n   serialized_msg.buffer_length = length;\n   serialized_msg.buffer = reinterpret_cast\u003Cuint8_t *\u003E(serialized_buffer);\n \n-  destroy_ros_message_signature * destroy_ros_message = nullptr;\n-  void * deserialized_ros_msg_c = rclpy_create_from_py(pymsg_type.ptr(), \u0026destroy_ros_message);\n-  if (!deserialized_ros_msg_c) {\n\u002B  auto deserialized_ros_msg = create_from_py(pymsg_type);\n\u002B  if (!deserialized_ros_msg) {\n     throw py::error_already_set();\n   }\n-  auto deserialized_ros_msg = std::unique_ptr\u003Cvoid, decltype(destroy_ros_message)\u003E(\n-    deserialized_ros_msg_c, destroy_ros_message);\n \n   // Deserialize\n   rmw_ret_t rmw_ret = rmw_deserialize(\u0026serialized_msg, ts, deserialized_ros_msg.get());\n@@ -126,8 \u002B122,6 @@ deserialize(py::bytes pybuffer, py::object pymsg_type)\n     throw RMWError(\u0022failed to deserialize ROS message\u0022);\n   }\n \n-  PyObject * pydeserialized_ros_msg_c =\n-    rclpy_convert_to_py(deserialized_ros_msg.get(), pymsg_type.ptr());\n-  return py::reinterpret_steal\u003Cpy::object\u003E(pydeserialized_ros_msg_c);\n\u002B  return convert_to_py(deserialized_ros_msg.get(), pymsg_type);\n }\n }  // namespace rclpy\ndiff --git rclpy/src/rclpy/service.cpp rclpy/src/rclpy/service.cpp\nindex 7eca981..3f2d481 100644\n--- rclpy/src/rclpy/service.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/service.cpp\n@@ -43,7 \u002B43,7 @@ Service::Service(\n : node_(node)\n {\n   auto srv_type = static_cast\u003Crosidl_service_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pysrv_type.ptr()));\n\u002B    common_get_type_support(pysrv_type));\n   if (!srv_type) {\n     throw py::error_already_set();\n   }\n@@ -93,17 \u002B93,13 @@ Service::Service(\n void\n Service::service_send_response(py::object pyresponse, rmw_request_id_t * header)\n {\n-  destroy_ros_message_signature * destroy_ros_message = nullptr;\n-  void * raw_ros_response = rclpy_convert_from_py(pyresponse.ptr(), \u0026destroy_ros_message);\n\u002B  auto raw_ros_response = convert_from_py(pyresponse);\n   if (!raw_ros_response) {\n     throw py::error_already_set();\n   }\n-  auto message_deleter = [destroy_ros_message](void * ptr) {destroy_ros_message(ptr);};\n-  auto ros_response = std::unique_ptr\u003Cvoid, decltype(message_deleter)\u003E(\n-    raw_ros_response, message_deleter);\n \n-  rcl_ret_t ret = rcl_send_response(rcl_service_.get(), header, ros_response.get());\n-  if (ret != RCL_RET_OK) {\n\u002B  rcl_ret_t ret = rcl_send_response(rcl_service_.get(), header, raw_ros_response.get());\n\u002B  if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to send response\u0022);\n   }\n }\ndiff --git rclpy/src/rclpy/subscription.cpp rclpy/src/rclpy/subscription.cpp\nindex 58f367e..33c025c 100644\n--- rclpy/src/rclpy/subscription.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/subscription.cpp\n@@ -39,7 \u002B39,7 @@ Subscription::Subscription(\n : node_(node)\n {\n   auto msg_type = static_cast\u003Crosidl_message_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pymsg_type.ptr()));\n\u002B    common_get_type_support(pymsg_type));\n   if (!msg_type) {\n     throw py::error_already_set();\n   }\ndiff --git rclpy/src/rclpy/utils.cpp rclpy/src/rclpy/utils.cpp\nindex 999f42b..f17c0e8 100644\n--- rclpy/src/rclpy/utils.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.cpp\n@@ -51,6 \u002B51,17 @@ convert_to_py_names_and_types(const rcl_names_and_types_t * names_and_types)\n   return py_names_and_types;\n }\n \n\u002Bvoid *\n\u002Bcommon_get_type_support(py::object pymessage)\n\u002B{\n\u002B  py::object pymetaclass = pymessage.attr(\u0022__class__\u0022);\n\u002B\n\u002B  py::object value = pymetaclass.attr(\u0022_TYPE_SUPPORT\u0022);\n\u002B  auto capsule_ptr = static_cast\u003Cvoid *\u003E(value.cast\u003Cpy::capsule\u003E());\n\u002B\n\u002B  return capsule_ptr;\n\u002B}\n\u002B\n std::unique_ptr\u003Cvoid, destroy_ros_message_function *\u003E\n create_from_py(py::object pymessage)\n {\ndiff --git rclpy/src/rclpy/utils.hpp rclpy/src/rclpy/utils.hpp\nindex 0f4ae10..b4efb96 100644\n--- rclpy/src/rclpy/utils.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.hpp\n@@ -40,6 \u002B40,14 @@ typedef void destroy_ros_message_function (void *);\n py::list\n convert_to_py_names_and_types(const rcl_names_and_types_t * topic_names_and_types);\n \n\u002B/// Get the type support structure for a Python ROS message type.\n\u002B/**\n\u002B * \\param[in] pymsg_type The Python ROS message type.\n\u002B * \\return The type support structure or NULL if an error occurred.\n\u002B */\n\u002Bvoid *\n\u002Bcommon_get_type_support(py::object pymessage);\n\u002B\n /// Create the equivalent ROS message C type instance for a given Python type.\n /**\n * Raises AttributeError if \\p pyclass is missing a required attribute.\ndiff --git rclpy/src/rclpy_common/include/rclpy_common/common.h rclpy/src/rclpy_common/include/rclpy_common/common.h\nindex db18e95..c819825 100644\n--- rclpy/src/rclpy_common/include/rclpy_common/common.h\n\u002B\u002B\u002B rclpy/src/rclpy_common/include/rclpy_common/common.h\n@@ -27,20 \u002B27,6 @@ extern \u0022C\u0022\n \n #include \u0022rclpy_common/visibility_control.h\u0022\n \n-typedef void * create_ros_message_signature (void);\n-typedef void destroy_ros_message_signature (void *);\n-typedef bool convert_from_py_signature (PyObject *, void *);\n-typedef PyObject * convert_to_py_signature (void *);\n-\n-/// Get the type support structure for a Python ROS message type.\n-/**\n- * \\param[in] pymsg_type The Python ROS message type.\n- * \\return The type support structure or NULL if an error occurred.\n- */\n-RCLPY_COMMON_PUBLIC\n-void *\n-rclpy_common_get_type_support(PyObject * pymsg_type);\n-\n /// Convert a C rmw_qos_profile_t into a Python dictionary with qos profile args.\n /**\n  * \\param[in] profile Pointer to a rmw_qos_profile_t to convert\n@@ -50,39 \u002B36,6 @@ RCLPY_COMMON_PUBLIC\n PyObject *\n rclpy_common_convert_to_qos_dict(const rmw_qos_profile_t * profile);\n \n-RCLPY_COMMON_PUBLIC\n-void *\n-get_capsule_pointer(PyObject * pymetaclass, const char * attr);\n-\n-RCLPY_COMMON_PUBLIC\n-void *\n-rclpy_create_from_py(PyObject * pymessage, destroy_ros_message_signature ** destroy_ros_message);\n-\n-/// Convert a ROS message from a Python type to a C type.\n-/**\n- * Raises AttributeError if the Python message type is missing a required attribute.\n- * Raises MemoryError on a memory allocation failure.\n- *\n- * \\param[in] pymessage The Python message to convert from.\n- * \\param[out] destroy_ros_message The destructor function for finalizing the returned message.\n- * \\return The C version of the input ROS message.\n- */\n-RCLPY_COMMON_PUBLIC\n-void *\n-rclpy_convert_from_py(PyObject * pymessage, destroy_ros_message_signature ** destroy_ros_message);\n-\n-/// Convert a ROS message from a C type to a Python type.\n-/**\n- * Raises AttributeError if the Python type is missing a required attribute.\n- *\n- * \\param[in] message The C message to convert to a Python type\n- * \\param[in] pyclass An instance of the Python type to convert to.\n- * \\return The Python version of the input ROS message.\n- */\n-RCLPY_COMMON_PUBLIC\n-PyObject *\n-rclpy_convert_to_py(void * message, PyObject * pyclass);\n-\n /// Convert a C rmw_topic_endpoint_info_array_t into a Python list.\n /**\n  * \\param[in] info_array a pointer to a rmw_topic_endpoint_info_array_t\ndiff --git rclpy/src/rclpy_common/src/common.c rclpy/src/rclpy_common/src/common.c\nindex e963193..84250a0 100644\n--- rclpy/src/rclpy_common/src/common.c\n\u002B\u002B\u002B rclpy/src/rclpy_common/src/common.c\n@@ -55,25 \u002B55,6 @@ cleanup_rclpy_qos_profile(rclpy_qos_profile_t * profile)\n   Py_XDECREF(profile-\u003Eavoid_ros_namespace_conventions);\n }\n \n-void *\n-rclpy_common_get_type_support(PyObject * pymsg_type)\n-{\n-  PyObject * pymetaclass = PyObject_GetAttrString(pymsg_type, \u0022__class__\u0022);\n-  if (!pymetaclass) {\n-    return NULL;\n-  }\n-\n-  PyObject * pyts = PyObject_GetAttrString(pymetaclass, \u0022_TYPE_SUPPORT\u0022);\n-  Py_DECREF(pymetaclass);\n-  if (!pyts) {\n-    return NULL;\n-  }\n-\n-  void * ts = PyCapsule_GetPointer(pyts, NULL);\n-  Py_DECREF(pyts);\n-  return ts;\n-}\n-\n static\n PyObject *\n _convert_rmw_time_to_py_duration(const rmw_time_t * duration)\n@@ -206,93 \u002B187,6 @@ rclpy_common_convert_to_qos_dict(const rmw_qos_profile_t * qos_profile)\n   return pyqos_kwargs;\n }\n \n-void *\n-get_capsule_pointer(PyObject * pymetaclass, const char * attr)\n-{\n-  PyObject * pyattr = PyObject_GetAttrString(pymetaclass, attr);\n-  if (!pyattr) {\n-    return NULL;\n-  }\n-  void * ptr = PyCapsule_GetPointer(pyattr, NULL);\n-  Py_DECREF(pyattr);\n-  return ptr;\n-}\n-\n-void *\n-rclpy_create_from_py(PyObject * pymessage, destroy_ros_message_signature ** destroy_ros_message)\n-{\n-  PyObject * pymetaclass = PyObject_GetAttrString(pymessage, \u0022__class__\u0022);\n-  if (!pymetaclass) {\n-    return NULL;\n-  }\n-\n-  create_ros_message_signature * create_ros_message = get_capsule_pointer(\n-    pymetaclass, \u0022_CREATE_ROS_MESSAGE\u0022);\n-  if (!create_ros_message) {\n-    Py_DECREF(pymetaclass);\n-    return NULL;\n-  }\n-\n-  *destroy_ros_message = get_capsule_pointer(\n-    pymetaclass, \u0022_DESTROY_ROS_MESSAGE\u0022);\n-  Py_DECREF(pymetaclass);\n-  if (!(*destroy_ros_message)) {\n-    return NULL;\n-  }\n-\n-  void * message = create_ros_message();\n-  if (!message) {\n-    PyErr_NoMemory();\n-    return NULL;\n-  }\n-  return message;\n-}\n-\n-void *\n-rclpy_convert_from_py(PyObject * pymessage, destroy_ros_message_signature ** destroy_ros_message)\n-{\n-  void * message = rclpy_create_from_py(pymessage, destroy_ros_message);\n-  if (!message) {\n-    return NULL;\n-  }\n-\n-  PyObject * pymetaclass = PyObject_GetAttrString(pymessage, \u0022__class__\u0022);\n-  if (!pymetaclass) {\n-    (**destroy_ros_message)(message);\n-    return NULL;\n-  }\n-\n-  convert_from_py_signature * convert = get_capsule_pointer(\n-    pymetaclass, \u0022_CONVERT_FROM_PY\u0022);\n-  Py_DECREF(pymetaclass);\n-  if (!convert) {\n-    (**destroy_ros_message)(message);\n-    return NULL;\n-  }\n-\n-  if (!convert(pymessage, message)) {\n-    (**destroy_ros_message)(message);\n-    return NULL;\n-  }\n-  return message;\n-}\n-\n-PyObject *\n-rclpy_convert_to_py(void * message, PyObject * pyclass)\n-{\n-  PyObject * pymetaclass = PyObject_GetAttrString(pyclass, \u0022__class__\u0022);\n-  if (!pymetaclass) {\n-    return NULL;\n-  }\n-  convert_to_py_signature * convert = get_capsule_pointer(\n-    pymetaclass, \u0022_CONVERT_TO_PY\u0022);\n-  Py_DECREF(pymetaclass);\n-  if (!convert) {\n-    return NULL;\n-  }\n-  return convert(message);\n-}\n-\n PyObject *\n _rclpy_convert_to_py_topic_endpoint_info(const rmw_topic_endpoint_info_t * topic_endpoint_info)\n {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "6e1fea14e1fdab856f31bba6c4030c321afa86f7",
    "RawMessage": "Fix race condition in events-executor (#2177)",
    "Changes": "diff --git rclcpp/include/rclcpp/experimental/executors/events_executor/events_executor.hpp rclcpp/include/rclcpp/experimental/executors/events_executor/events_executor.hpp\nindex 148ede66..2365b676 100644\n--- rclcpp/include/rclcpp/experimental/executors/events_executor/events_executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/executors/events_executor/events_executor.hpp\n@@ -243,6 \u002B243,11 @@ private:\n   std::function\u003Cvoid(size_t, int)\u003E\n   create_waitable_callback(const rclcpp::Waitable * waitable_id);\n \n\u002B  /// Utility to add the notify waitable to an entities collection\n\u002B  void\n\u002B  add_notify_waitable_to_collection(\n\u002B    rclcpp::executors::ExecutorEntitiesCollection::WaitableCollection \u0026 collection);\n\u002B\n   /// Searches for the provided entity_id in the collection and returns the entity if valid\n   template\u003Ctypename CollectionType\u003E\n   typename CollectionType::EntitySharedPtr\ndiff --git rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\nindex 094ff212..33e9cb67 100644\n--- rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n@@ -50,6 \u002B50,9 @@ EventsExecutor::EventsExecutor(\n   timers_manager_ =\n     std::make_shared\u003Crclcpp::experimental::TimersManager\u003E(context_, timer_on_ready_cb);\n \n\u002B  this-\u003Ecurrent_entities_collection_ =\n\u002B    std::make_shared\u003Crclcpp::executors::ExecutorEntitiesCollection\u003E();\n\u002B\n   notify_waitable_ = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(\n     [this]() {\n       // This callback is invoked when:\n@@ -61,6 \u002B64,10 @@ EventsExecutor::EventsExecutor(\n       this-\u003Erefresh_current_collection_from_callback_groups();\n     });\n \n\u002B  // Make sure that the notify waitable is immediately added to the collection\n\u002B  // to avoid missing events\n\u002B  this-\u003Eadd_notify_waitable_to_collection(current_entities_collection_-\u003Ewaitables);\n\u002B\n   notify_waitable_-\u003Eadd_guard_condition(interrupt_guard_condition_);\n   notify_waitable_-\u003Eadd_guard_condition(shutdown_guard_condition_);\n \n@@ -87,9 \u002B94,6 @@ EventsExecutor::EventsExecutor(\n \n   this-\u003Eentities_collector_ =\n     std::make_shared\u003Crclcpp::executors::ExecutorEntitiesCollector\u003E(notify_waitable_);\n-\n-  this-\u003Ecurrent_entities_collection_ =\n-    std::make_shared\u003Crclcpp::executors::ExecutorEntitiesCollection\u003E();\n }\n \n EventsExecutor::~EventsExecutor()\n@@ -395,18 \u002B399,8 @@ EventsExecutor::refresh_current_collection_from_callback_groups()\n   // retrieved in the \u0022standard\u0022 way.\n   // To do it, we need to add the notify waitable as an entry in both the new and\n   // current collections such that it\u0027s neither added or removed.\n-  rclcpp::CallbackGroup::WeakPtr weak_group_ptr;\n-  new_collection.waitables.insert(\n-  {\n-    this-\u003Enotify_waitable_.get(),\n-    {this-\u003Enotify_waitable_, weak_group_ptr}\n-  });\n-\n-  this-\u003Ecurrent_entities_collection_-\u003Ewaitables.insert(\n-  {\n-    this-\u003Enotify_waitable_.get(),\n-    {this-\u003Enotify_waitable_, weak_group_ptr}\n-  });\n\u002B  this-\u003Eadd_notify_waitable_to_collection(new_collection.waitables);\n\u002B  this-\u003Eadd_notify_waitable_to_collection(current_entities_collection_-\u003Ewaitables);\n \n   this-\u003Erefresh_current_collection(new_collection);\n }\n@@ -486,3 \u002B480,16 @@ EventsExecutor::create_waitable_callback(const rclcpp::Waitable * entity_key)\n     };\n   return callback;\n }\n\u002B\n\u002Bvoid\n\u002BEventsExecutor::add_notify_waitable_to_collection(\n\u002B  rclcpp::executors::ExecutorEntitiesCollection::WaitableCollection \u0026 collection)\n\u002B{\n\u002B  // The notify waitable is not associated to any group, so use an invalid one\n\u002B  rclcpp::CallbackGroup::WeakPtr weak_group_ptr;\n\u002B  collection.insert(\n\u002B  {\n\u002B    this-\u003Enotify_waitable_.get(),\n\u002B    {this-\u003Enotify_waitable_, weak_group_ptr}\n\u002B  });\n\u002B}\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 38b6ddf8..232baaac 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -20,12 \u002B20,14 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Calgorithm\u003E\n\u002B#include \u003Catomic\u003E\n #include \u003Cchrono\u003E\n #include \u003Climits\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n #include \u003Cthread\u003E\n #include \u003Cutility\u003E\n\u002B#include \u003Cvector\u003E\n \n #include \u0022rcl/error_handling.h\u0022\n #include \u0022rcl/time.h\u0022\n@@ -43,18 \u002B45,10 @@ template\u003Ctypename T\u003E\n class TestExecutors : public ::testing::Test\n {\n public:\n-  static void SetUpTestCase()\n\u002B  void SetUp()\n   {\n     rclcpp::init(0, nullptr);\n-  }\n-\n-  static void TearDownTestCase()\n-  {\n-    rclcpp::shutdown();\n-  }\n \n-  void SetUp()\n-  {\n     const auto test_info = ::testing::UnitTest::GetInstance()-\u003Ecurrent_test_info();\n     std::stringstream test_name;\n     test_name \u003C\u003C test_info-\u003Etest_case_name() \u003C\u003C \u0022_\u0022 \u003C\u003C test_info-\u003Ename();\n@@ -75,6 \u002B69,8 @@ public:\n     publisher.reset();\n     subscription.reset();\n     node.reset();\n\u002B\n\u002B    rclcpp::shutdown();\n   }\n \n   rclcpp::Node::SharedPtr node;\n@@ -729,6 \u002B725,77 @@ TYPED_TEST(TestExecutors, testSpinUntilFutureCompleteInterrupted)\n   spinner.join();\n }\n \n\u002B// This test verifies that the add_node operation is robust wrt race conditions.\n\u002B// It\u0027s mostly meant to prevent regressions in the events-executor, but the operation should be\n\u002B// thread-safe in all executor implementations.\n\u002B// The initial implementation of the events-executor contained a bug where the executor\n\u002B// would end up in an inconsistent state and stop processing interrupt/shutdown notifications.\n\u002B// Manually adding a node to the executor results in a) producing a notify waitable event\n\u002B// and b) refreshing the executor collections.\n\u002B// The inconsistent state would happen if the event was processed before the collections were\n\u002B// finished to be refreshed: the executor would pick up the event but be unable to process it.\n\u002B// This would leave the \u0060notify_waitable_event_pushed_\u0060 flag to true, preventing additional\n\u002B// notify waitable events to be pushed.\n\u002B// The behavior is observable only under heavy load, so this test spawns several worker\n\u002B// threads. Due to the nature of the bug, this test may still succeed even if the\n\u002B// bug is present. However repeated runs will show its flakiness nature and indicate\n\u002B// an eventual regression.\n\u002BTYPED_TEST(TestExecutors, testRaceConditionAddNode)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B  // rmw_connextdds doesn\u0027t support events-executor\n\u002B  if (\n\u002B    std::is_same\u003CExecutorType, rclcpp::experimental::executors::EventsExecutor\u003E() \u0026\u0026\n\u002B    std::string(rmw_get_implementation_identifier()).find(\u0022rmw_connextdds\u0022) == 0)\n\u002B  {\n\u002B    GTEST_SKIP();\n\u002B  }\n\u002B\n\u002B  // Spawn some threads to do some heavy work\n\u002B  std::atomic\u003Cbool\u003E should_cancel = false;\n\u002B  std::vector\u003Cstd::thread\u003E stress_threads;\n\u002B  for (size_t i = 0; i \u003C 5 * std::thread::hardware_concurrency(); i\u002B\u002B) {\n\u002B    stress_threads.emplace_back(\n\u002B      [\u0026should_cancel, i]() {\n\u002B        // This is just some arbitrary heavy work\n\u002B        volatile size_t total = 0;\n\u002B        for (size_t k = 0; k \u003C 549528914167; k\u002B\u002B) {\n\u002B          if (should_cancel) {\n\u002B            break;\n\u002B          }\n\u002B          total \u002B= k * (i \u002B 42);\n\u002B        }\n\u002B      });\n\u002B  }\n\u002B\n\u002B  // Create an executor\n\u002B  auto executor = std::make_shared\u003CExecutorType\u003E();\n\u002B  // Start spinning\n\u002B  auto executor_thread = std::thread(\n\u002B    [executor]() {\n\u002B      executor-\u003Espin();\n\u002B    });\n\u002B  // Add a node to the executor\n\u002B  executor-\u003Eadd_node(this-\u003Enode);\n\u002B\n\u002B  // Cancel the executor (make sure that it\u0027s already spinning first)\n\u002B  while (!executor-\u003Eis_spinning() \u0026\u0026 rclcpp::ok()) {\n\u002B    continue;\n\u002B  }\n\u002B  executor-\u003Ecancel();\n\u002B\n\u002B  // Try to join the thread after cancelling the executor\n\u002B  // This is the \u0022test\u0022. We want to make sure that we can still cancel the executor\n\u002B  // regardless of the presence of race conditions\n\u002B  executor_thread.join();\n\u002B\n\u002B  // The test is now completed: we can join the stress threads\n\u002B  should_cancel = true;\n\u002B  for (auto \u0026 t : stress_threads) {\n\u002B    t.join();\n\u002B  }\n\u002B}\n\u002B\n // Check spin_until_future_complete with node base pointer (instantiates its own executor)\n TEST(TestExecutors, testSpinUntilFutureCompleteNodeBasePtr)\n {\n",
    "BackportedTo": "iron",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "1ef2df04881ef9e46938005f5301502a08cff066",
    "RawMessage": "Depend on just rmw_dds_common::rmw_dds_common_library (#385)",
    "Changes": "diff --git rmw_cyclonedds_cpp/CMakeLists.txt rmw_cyclonedds_cpp/CMakeLists.txt\nindex 40002fa..f560cc5 100644\n--- rmw_cyclonedds_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_cyclonedds_cpp/CMakeLists.txt\n@@ -89,7 \u002B89,7 @@ target_link_libraries(rmw_cyclonedds_cpp PRIVATE\n   rcpputils::rcpputils\n   rosidl_typesupport_introspection_c::rosidl_typesupport_introspection_c\n   rosidl_typesupport_introspection_cpp::rosidl_typesupport_introspection_cpp\n-  ${rmw_dds_common_TARGETS}\n\u002B  rmw_dds_common::rmw_dds_common_library\n   rosidl_runtime_c::rosidl_runtime_c\n   tracetools::tracetools)\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "2cc43b327405f82d8192267714d509074ef2915f",
    "RawMessage": "update doc section for spin_xxx methods. (#2730)",
    "Changes": "diff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex ae2087bb..4b75cc87 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -287,6 \u002B287,18 @@ public:\n    * Adding subscriptions, timers, services, etc. with blocking or long running\n    * callbacks may cause the function exceed the max_duration significantly.\n    *\n\u002B   * Work that is ready to be done is collected only once, and when collecting that work\n\u002B   * entities which may have multiple pieces of work ready will only be executed at most\n\u002B   * one time.\n\u002B   * The reason for this is that it is not possible to tell if, for example, a ready\n\u002B   * subscription has only one message ready or multiple without checking again.\n\u002B   * Because, in order to find out if there are multiple messages, one message must\n\u002B   * be taken and executed before checking again if that subscription is still ready.\n\u002B   * However, this function only checks for ready entities to work on once,\n\u002B   * and so it will never execute a single entity more than once per call to this function.\n\u002B   * See spin_all() variants for a function that will repeatedly work on a single entity\n\u002B   * in a single call.\n\u002B   *\n    * If there is no work to be done when this called, it will return immediately\n    * because the collecting of available work is non-blocking.\n    * Before each piece of ready work is executed this function checks if the\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "81619d3d6c2afe4b82a8f5163558cf12d64e20d2",
    "RawMessage": "Removed traces in renderPanel (#777)",
    "Changes": "diff --git rviz_common/src/rviz_common/render_panel.cpp rviz_common/src/rviz_common/render_panel.cpp\nindex e83f3b8d..273426aa 100644\n--- rviz_common/src/rviz_common/render_panel.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/render_panel.cpp\n@@ -211,25 \u002B211,21 @@ void RenderPanel::leaveEvent(QEvent * event)\n \n void RenderPanel::mouseMoveEvent(QMouseEvent * event)\n {\n-  printf(\u0022in RenderPanel::mouseMoveEvent()\\n\u0022);\n   onRenderWindowMouseEvents(event);\n }\n \n void RenderPanel::mousePressEvent(QMouseEvent * event)\n {\n-  printf(\u0022in RenderPanel::mousePressEvent()\\n\u0022);\n   onRenderWindowMouseEvents(event);\n }\n \n void RenderPanel::mouseReleaseEvent(QMouseEvent * event)\n {\n-  printf(\u0022in RenderPanel::mouseReleaseEvent()\\n\u0022);\n   onRenderWindowMouseEvents(event);\n }\n \n void RenderPanel::mouseDoubleClickEvent(QMouseEvent * event)\n {\n-  printf(\u0022in RenderPanel::mouseDoubleClickEvent()\\n\u0022);\n   onRenderWindowMouseEvents(event);\n }\n \n",
    "BackportedTo": "galactic",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "61939927d56db49ab9ce7b4904463918b95777d5",
    "RawMessage": "Add EventsExecutor (#161)",
    "Changes": "diff --git rmw_implementation/src/functions.cpp rmw_implementation/src/functions.cpp\nindex 71d039e..c666a81 100644\n--- rmw_implementation/src/functions.cpp\n\u002B\u002B\u002B rmw_implementation/src/functions.cpp\n@@ -698,6 \u002B698,30 @@ RMW_INTERFACE_FN(\n     rcutils_allocator_t *,\n     rmw_network_flow_endpoint_array_t *))\n \n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_subscription_set_on_new_message_callback,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  3, ARG_TYPES(\n\u002B    rmw_subscription_t *, rmw_event_callback_t, const void *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_service_set_on_new_request_callback,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  3, ARG_TYPES(\n\u002B    rmw_service_t *, rmw_event_callback_t, const void *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_client_set_on_new_response_callback,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  3, ARG_TYPES(\n\u002B    rmw_client_t *, rmw_event_callback_t, const void *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_event_set_callback,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  3, ARG_TYPES(\n\u002B    rmw_event_t *, rmw_event_callback_t, const void *))\n\u002B\n #define GET_SYMBOL(x) symbol_ ## x = get_symbol(#x);\n \n void prefetch_symbols(void)\n@@ -783,6 \u002B807,10 @@ void prefetch_symbols(void)\n   GET_SYMBOL(rmw_subscription_get_network_flow_endpoints)\n   GET_SYMBOL(rmw_client_request_publisher_get_actual_qos);\n   GET_SYMBOL(rmw_client_response_subscription_get_actual_qos);\n\u002B  GET_SYMBOL(rmw_subscription_set_on_new_message_callback)\n\u002B  GET_SYMBOL(rmw_service_set_on_new_request_callback)\n\u002B  GET_SYMBOL(rmw_client_set_on_new_response_callback)\n\u002B  GET_SYMBOL(rmw_event_set_callback)\n }\n \n void * symbol_rmw_init = nullptr;\n@@ -891,5 \u002B919,9 @@ unload_library()\n   symbol_rmw_publisher_get_network_flow_endpoints = nullptr;\n   symbol_rmw_subscription_get_network_flow_endpoints = nullptr;\n   symbol_rmw_init = nullptr;\n\u002B  symbol_rmw_subscription_set_on_new_message_callback = nullptr;\n\u002B  symbol_rmw_service_set_on_new_request_callback = nullptr;\n\u002B  symbol_rmw_client_set_on_new_response_callback = nullptr;\n\u002B  symbol_rmw_event_set_callback = nullptr;\n   g_rmw_lib.reset();\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "ebca223c627ec50afee68339b55efb8e69835cdf",
    "RawMessage": "Switch to gz_math_vendor. (#1177)",
    "Changes": "diff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex 2d6c3b6c..064bf05f 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -61,8 \u002B61,8 @@ find_package(Qt5 REQUIRED COMPONENTS Widgets Test)\n \n find_package(geometry_msgs REQUIRED)\n \n-find_package(ignition_math6_vendor REQUIRED)\n-find_package(ignition-math6 REQUIRED)\n\u002Bfind_package(gz_math_vendor REQUIRED)\n\u002Bfind_package(gz-math REQUIRED)\n \n find_package(image_transport REQUIRED)\n find_package(interactive_markers REQUIRED)\n@@ -265,7 \u002B265,7 @@ target_link_libraries(rviz_default_plugins PUBLIC\n )\n \n target_link_libraries(rviz_default_plugins PRIVATE\n-  ignition-math6\n\u002B  gz-math::core\n   resource_retriever::resource_retriever\n )\n \ndiff --git rviz_default_plugins/package.xml rviz_default_plugins/package.xml\nindex 44277cf1..9141b1fb 100644\n--- rviz_default_plugins/package.xml\n\u002B\u002B\u002B rviz_default_plugins/package.xml\n@@ -38,7 \u002B38,7 @@\n   \u003Cexec_depend\u003Erviz_ogre_vendor\u003C/exec_depend\u003E\n \n   \u003Cdepend\u003Egeometry_msgs\u003C/depend\u003E\n-  \u003Cdepend\u003Eignition_math6_vendor\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Egz_math_vendor\u003C/depend\u003E\n   \u003Cdepend\u003Eimage_transport\u003C/depend\u003E\n   \u003Cdepend\u003Einteractive_markers\u003C/depend\u003E\n   \u003Cdepend\u003Elaser_geometry\u003C/depend\u003E\ndiff --git rviz_default_plugins/src/rviz_default_plugins/robot/robot_link.cpp rviz_default_plugins/src/rviz_default_plugins/robot/robot_link.cpp\nindex 8890bc4a..e2dc2652 100644\n--- rviz_default_plugins/src/rviz_default_plugins/robot/robot_link.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/robot/robot_link.cpp\n@@ -50,11 \u002B50,11 @@\n \n #include \u003CQFileInfo\u003E  // NOLINT cpplint cannot handle include order here\n \n-#include \u003Cignition/math/Inertial.hh\u003E\n-#include \u003Cignition/math/MassMatrix3.hh\u003E\n-#include \u003Cignition/math/Pose3.hh\u003E\n-#include \u003Cignition/math/Quaternion.hh\u003E\n-#include \u003Cignition/math/Vector3.hh\u003E\n\u002B#include \u003Cgz/math/Inertial.hh\u003E\n\u002B#include \u003Cgz/math/MassMatrix3.hh\u003E\n\u002B#include \u003Cgz/math/Pose3.hh\u003E\n\u002B#include \u003Cgz/math/Quaternion.hh\u003E\n\u002B#include \u003Cgz/math/Vector3.hh\u003E\n \n #include \u0022resource_retriever/retriever.hpp\u0022\n \n@@ -871,18 \u002B871,18 @@ void RobotLink::createMass(const urdf::LinkConstSharedPtr \u0026 link)\n void RobotLink::createInertia(const urdf::LinkConstSharedPtr \u0026 link)\n {\n   if (link-\u003Einertial) {\n-    const ignition::math::Vector3d i_xx_yy_zz(\n\u002B    const gz::math::Vector3d i_xx_yy_zz(\n       link-\u003Einertial-\u003Eixx,\n       link-\u003Einertial-\u003Eiyy,\n       link-\u003Einertial-\u003Eizz);\n-    const ignition::math::Vector3d Ixyxzyz(\n\u002B    const gz::math::Vector3d Ixyxzyz(\n       link-\u003Einertial-\u003Eixy,\n       link-\u003Einertial-\u003Eixz,\n       link-\u003Einertial-\u003Eiyz);\n-    ignition::math::MassMatrix3d mass_matrix(link-\u003Einertial-\u003Emass, i_xx_yy_zz, Ixyxzyz);\n\u002B    gz::math::MassMatrix3d mass_matrix(link-\u003Einertial-\u003Emass, i_xx_yy_zz, Ixyxzyz);\n \n-    ignition::math::Vector3d box_scale;\n-    ignition::math::Quaterniond box_rot;\n\u002B    gz::math::Vector3d box_scale;\n\u002B    gz::math::Quaterniond box_rot;\n     if (!mass_matrix.EquivalentBox(box_scale, box_rot)) {\n       // Invalid inertia, load with default scale\n       if (link-\u003Eparent_joint \u0026\u0026 link-\u003Eparent_joint-\u003Etype != urdf::Joint::FIXED) {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "77949d2c54b8104e48a94d0ea83c7049e18a8809",
    "RawMessage": "Shutdown asynchronously when sigint is received (#844)",
    "Changes": "diff --git rclpy/src/rclpy/signal_handler.cpp rclpy/src/rclpy/signal_handler.cpp\nindex ec0f12b..9c08e61 100644\n--- rclpy/src/rclpy/signal_handler.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/signal_handler.cpp\n@@ -57,7 \u002B57,6 @@ std::thread g_deferred_signal_handling_thread;\n \n // relying on python GIL for safety\n std::atomic\u003Cbool\u003E g_signal_handler_installed = false;\n-std::atomic\u003Cbool\u003E g_is_sigterm;\n \n void\n notify_signal_handler() noexcept\n@@ -141,9 \u002B140,7 @@ setup_deferred_signal_handler()\n         wait_for_signal();\n         if (g_signal_handler_installed.load()) {\n           trigger_guard_conditions();\n-          if (g_is_sigterm.exchange(false)) {\n-            rclpy::shutdown_contexts();\n-          }\n\u002B          rclpy::shutdown_contexts();\n         }\n       }\n     });\n@@ -328,7 \u002B325,6 @@ DEFINE_SIGNAL_HANDLER(rclpy_sigterm_handler)\n     // Try to unregister again.\n     unregister_sigint_signal_handler();\n   } else {\n-    g_is_sigterm.exchange(true);\n     notify_signal_handler();\n   }\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "98707238ad2564e28cbc987fc3a31ed9a1c86243",
    "RawMessage": "Add convert function from ParameterValue to Python builtin (#819)",
    "Changes": "diff --git rclpy/rclpy/parameter.py rclpy/rclpy/parameter.py\nindex 793dbf0..f65f289 100644\n--- rclpy/rclpy/parameter.py\n\u002B\u002B\u002B rclpy/rclpy/parameter.py\n@@ -172,3 \u002B172,39 @@ class Parameter:\n \n     def to_parameter_msg(self):\n         return ParameterMsg(name=self.name, value=self.get_parameter_value())\n\u002B\n\u002B\n\u002Bdef parameter_value_to_python(parameter_value: ParameterValue):\n\u002B    \u0022\u0022\u0022\n\u002B    Get the value for the Python builtin type from a rcl_interfaces/msg/ParameterValue object.\n\u002B\n\u002B    Returns the value member of the message based on the \u0060\u0060type\u0060\u0060 member.\n\u002B    Returns \u0060\u0060None\u0060\u0060 if the parameter is \u0022NOT_SET\u0022.\n\u002B\n\u002B    :param parameter_value: The message to get the value from.\n\u002B    :raises RuntimeError: if the member \u0060\u0060type\u0060\u0060 has an unexpected value.\n\u002B    \u0022\u0022\u0022\n\u002B    if parameter_value.type == ParameterType.PARAMETER_BOOL:\n\u002B        value = parameter_value.bool_value\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_INTEGER:\n\u002B        value = parameter_value.integer_value\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_DOUBLE:\n\u002B        value = parameter_value.double_value\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_STRING:\n\u002B        value = parameter_value.string_value\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_BYTE_ARRAY:\n\u002B        value = list(parameter_value.byte_array_value)\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_BOOL_ARRAY:\n\u002B        value = list(parameter_value.bool_array_value)\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_INTEGER_ARRAY:\n\u002B        value = list(parameter_value.integer_array_value)\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_DOUBLE_ARRAY:\n\u002B        value = list(parameter_value.double_array_value)\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_STRING_ARRAY:\n\u002B        value = list(parameter_value.string_array_value)\n\u002B    elif parameter_value.type == ParameterType.PARAMETER_NOT_SET:\n\u002B        value = None\n\u002B    else:\n\u002B        raise RuntimeError(f\u0027unexpected parameter type {parameter_value.type}\u0027)\n\u002B\n\u002B    return value\ndiff --git rclpy/test/test_parameter.py rclpy/test/test_parameter.py\nindex 2f3cecd..68a390d 100644\n--- rclpy/test/test_parameter.py\n\u002B\u002B\u002B rclpy/test/test_parameter.py\n@@ -15,9 \u002B15,13 @@\n from array import array\n import unittest\n \n\u002Bimport pytest\n\u002B\n from rcl_interfaces.msg import Parameter as ParameterMsg\n\u002Bfrom rcl_interfaces.msg import ParameterType\n from rcl_interfaces.msg import ParameterValue\n from rclpy.parameter import Parameter\n\u002Bfrom rclpy.parameter import parameter_value_to_python\n \n \n class TestParameter(unittest.TestCase):\n@@ -161,6 \u002B165,54 @@ class TestParameter(unittest.TestCase):\n             value=ParameterValue(type=8, double_array_value=[1.0, 2.0, 3.0])\n         ))\n \n\u002B    def test_parameter_value_to_python(self):\n\u002B        \u0022\u0022\u0022Test the parameter_value_to_python conversion function.\u0022\u0022\u0022\n\u002B        test_cases = [\n\u002B            (ParameterValue(type=int(ParameterType.PARAMETER_NOT_SET)), None),\n\u002B            (ParameterValue(type=int(ParameterType.PARAMETER_INTEGER), integer_value=42), 42),\n\u002B            (ParameterValue(type=int(ParameterType.PARAMETER_DOUBLE), double_value=3.5), 3.5),\n\u002B            (ParameterValue(type=int(ParameterType.PARAMETER_STRING), string_value=\u0027foo\u0027), \u0027foo\u0027),\n\u002B            (\n\u002B                ParameterValue(\n\u002B                    type=int(ParameterType.PARAMETER_BYTE_ARRAY),\n\u002B                    byte_array_value=[b\u0027J\u0027, b\u0027P\u0027]\n\u002B                ),\n\u002B                [b\u0027J\u0027, b\u0027P\u0027]\n\u002B            ),\n\u002B            (\n\u002B                ParameterValue(\n\u002B                    type=int(ParameterType.PARAMETER_INTEGER_ARRAY),\n\u002B                    integer_array_value=[1, 2, 3]),\n\u002B                [1, 2, 3]\n\u002B            ),\n\u002B            (\n\u002B                ParameterValue(\n\u002B                    type=int(ParameterType.PARAMETER_DOUBLE_ARRAY),\n\u002B                    double_array_value=[1.0, 2.0, 3.0]),\n\u002B                [1.0, 2.0, 3.0]\n\u002B            ),\n\u002B            (\n\u002B                ParameterValue(\n\u002B                    type=int(ParameterType.PARAMETER_STRING_ARRAY),\n\u002B                    string_array_value=[\u0027foo\u0027, \u0027bar\u0027]),\n\u002B                [\u0027foo\u0027, \u0027bar\u0027]\n\u002B            ),\n\u002B        ]\n\u002B\n\u002B        for input_value, expected_value in test_cases:\n\u002B            result_value = parameter_value_to_python(input_value)\n\u002B            if isinstance(expected_value, list):\n\u002B                assert len(result_value) == len(expected_value)\n\u002B                # element-wise comparison for lists\n\u002B                assert all([x == y for x, y in zip(result_value, expected_value)])\n\u002B            else:\n\u002B                assert result_value == expected_value\n\u002B\n\u002B        # Test invalid \u0027type\u0027 member\n\u002B        parameter_value = ParameterValue(type=42)\n\u002B        with pytest.raises(RuntimeError):\n\u002B            parameter_value_to_python(parameter_value)\n\u002B\n \n if __name__ == \u0027__main__\u0027:\n     unittest.main()\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "005f6aefe96b7857fd08c99c04a751c5e2f93528",
    "RawMessage": "Modifies timers API to select autostart state (#2005)",
    "Changes": "diff --git rclcpp/include/rclcpp/create_timer.hpp rclcpp/include/rclcpp/create_timer.hpp\nindex d371466f..64d5b8e3 100644\n--- rclcpp/include/rclcpp/create_timer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/create_timer.hpp\n@@ -90,7 \u002B90,8 @@ create_timer(\n   rclcpp::Clock::SharedPtr clock,\n   rclcpp::Duration period,\n   CallbackT \u0026\u0026 callback,\n-  rclcpp::CallbackGroup::SharedPtr group = nullptr)\n\u002B  rclcpp::CallbackGroup::SharedPtr group = nullptr,\n\u002B  bool autostart = true)\n {\n   return create_timer(\n     clock,\n@@ -98,7 \u002B99,8 @@ create_timer(\n     std::forward\u003CCallbackT\u003E(callback),\n     group,\n     node_base.get(),\n-    node_timers.get());\n\u002B    node_timers.get(),\n\u002B    autostart);\n }\n \n /// Create a timer with a given clock\n@@ -109,7 \u002B111,8 @@ create_timer(\n   rclcpp::Clock::SharedPtr clock,\n   rclcpp::Duration period,\n   CallbackT \u0026\u0026 callback,\n-  rclcpp::CallbackGroup::SharedPtr group = nullptr)\n\u002B  rclcpp::CallbackGroup::SharedPtr group = nullptr,\n\u002B  bool autostart = true)\n {\n   return create_timer(\n     clock,\n@@ -117,7 \u002B120,8 @@ create_timer(\n     std::forward\u003CCallbackT\u003E(callback),\n     group,\n     rclcpp::node_interfaces::get_node_base_interface(node).get(),\n-    rclcpp::node_interfaces::get_node_timers_interface(node).get());\n\u002B    rclcpp::node_interfaces::get_node_timers_interface(node).get(),\n\u002B    autostart);\n }\n \n /// Convenience method to create a general timer with node resources.\n@@ -132,6 \u002B136,7 @@ create_timer(\n  * \\param group callback group\n  * \\param node_base node base interface\n  * \\param node_timers node timer interface\n\u002B * \\param autostart defines if the timer should start it\u0027s countdown on initialization or not.\n  * \\return shared pointer to a generic timer\n  * \\throws std::invalid_argument if either clock, node_base or node_timers\n  * are nullptr, or period is negative or too large\n@@ -144,7 \u002B149,8 @@ create_timer(\n   CallbackT callback,\n   rclcpp::CallbackGroup::SharedPtr group,\n   node_interfaces::NodeBaseInterface * node_base,\n-  node_interfaces::NodeTimersInterface * node_timers)\n\u002B  node_interfaces::NodeTimersInterface * node_timers,\n\u002B  bool autostart = true)\n {\n   if (clock == nullptr) {\n     throw std::invalid_argument{\u0022clock cannot be null\u0022};\n@@ -160,7 \u002B166,7 @@ create_timer(\n \n   // Add a new generic timer.\n   auto timer = rclcpp::GenericTimer\u003CCallbackT\u003E::make_shared(\n-    std::move(clock), period_ns, std::move(callback), node_base-\u003Eget_context());\n\u002B    std::move(clock), period_ns, std::move(callback), node_base-\u003Eget_context(), autostart);\n   node_timers-\u003Eadd_timer(timer, group);\n   return timer;\n }\n@@ -187,7 \u002B193,8 @@ create_wall_timer(\n   CallbackT callback,\n   rclcpp::CallbackGroup::SharedPtr group,\n   node_interfaces::NodeBaseInterface * node_base,\n-  node_interfaces::NodeTimersInterface * node_timers)\n\u002B  node_interfaces::NodeTimersInterface * node_timers,\n\u002B  bool autostart = true)\n {\n   if (node_base == nullptr) {\n     throw std::invalid_argument{\u0022input node_base cannot be null\u0022};\n@@ -201,7 \u002B208,7 @@ create_wall_timer(\n \n   // Add a new wall timer.\n   auto timer = rclcpp::WallTimer\u003CCallbackT\u003E::make_shared(\n-    period_ns, std::move(callback), node_base-\u003Eget_context());\n\u002B    period_ns, std::move(callback), node_base-\u003Eget_context(), autostart);\n   node_timers-\u003Eadd_timer(timer, group);\n   return timer;\n }\ndiff --git rclcpp/include/rclcpp/node.hpp rclcpp/include/rclcpp/node.hpp\nindex 7ecb67e9..556a6d03 100644\n--- rclcpp/include/rclcpp/node.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node.hpp\n@@ -232,13 \u002B232,15 @@ public:\n    * \\param[in] period Time interval between triggers of the callback.\n    * \\param[in] callback User-defined callback function.\n    * \\param[in] group Callback group to execute this timer\u0027s callback in.\n\u002B   * \\param[in] autostart The state of the clock on initialization.\n    */\n   template\u003Ctypename DurationRepT = int64_t, typename DurationT = std::milli, typename CallbackT\u003E\n   typename rclcpp::WallTimer\u003CCallbackT\u003E::SharedPtr\n   create_wall_timer(\n     std::chrono::duration\u003CDurationRepT, DurationT\u003E period,\n     CallbackT callback,\n-    rclcpp::CallbackGroup::SharedPtr group = nullptr);\n\u002B    rclcpp::CallbackGroup::SharedPtr group = nullptr,\n\u002B    bool autostart = true);\n \n   /// Create a timer that uses the node clock to drive the callback.\n   /**\ndiff --git rclcpp/include/rclcpp/node_impl.hpp rclcpp/include/rclcpp/node_impl.hpp\nindex d6b090d4..5f1fb7b3 100644\n--- rclcpp/include/rclcpp/node_impl.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_impl.hpp\n@@ -110,14 \u002B110,16 @@ typename rclcpp::WallTimer\u003CCallbackT\u003E::SharedPtr\n Node::create_wall_timer(\n   std::chrono::duration\u003CDurationRepT, DurationT\u003E period,\n   CallbackT callback,\n-  rclcpp::CallbackGroup::SharedPtr group)\n\u002B  rclcpp::CallbackGroup::SharedPtr group,\n\u002B  bool autostart)\n {\n   return rclcpp::create_wall_timer(\n     period,\n     std::move(callback),\n     group,\n     this-\u003Enode_base_.get(),\n-    this-\u003Enode_timers_.get());\n\u002B    this-\u003Enode_timers_.get(),\n\u002B    autostart);\n }\n \n template\u003Ctypename DurationRepT, typename DurationT, typename CallbackT\u003E\ndiff --git rclcpp/include/rclcpp/timer.hpp rclcpp/include/rclcpp/timer.hpp\nindex cc40736e..6060d8bd 100644\n--- rclcpp/include/rclcpp/timer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/timer.hpp\n@@ -53,12 \u002B53,17 @@ public:\n    * \\param clock A clock to use for time and sleeping\n    * \\param period The interval at which the timer fires\n    * \\param context node context\n\u002B   * \\param autostart timer state on initialization\n\u002B   *\n\u002B   * In order to activate a timer that is not started on initialization,\n\u002B   * user should call the reset() method.\n    */\n   RCLCPP_PUBLIC\n   explicit TimerBase(\n     Clock::SharedPtr clock,\n     std::chrono::nanoseconds period,\n-    rclcpp::Context::SharedPtr context);\n\u002B    rclcpp::Context::SharedPtr context,\n\u002B    bool autostart = true);\n \n   /// TimerBase destructor\n   RCLCPP_PUBLIC\n@@ -216,12 \u002B221,13 @@ public:\n    * \\param[in] period The interval at which the timer fires.\n    * \\param[in] callback User-specified callback function.\n    * \\param[in] context custom context to be used.\n\u002B   * \\param autostart timer state on initialization\n    */\n   explicit GenericTimer(\n     Clock::SharedPtr clock, std::chrono::nanoseconds period, FunctorT \u0026\u0026 callback,\n-    rclcpp::Context::SharedPtr context\n\u002B    rclcpp::Context::SharedPtr context, bool autostart = true\n   )\n-  : TimerBase(clock, period, context), callback_(std::forward\u003CFunctorT\u003E(callback))\n\u002B  : TimerBase(clock, period, context, autostart), callback_(std::forward\u003CFunctorT\u003E(callback))\n   {\n     TRACETOOLS_TRACEPOINT(\n       rclcpp_timer_callback_added,\n@@ -330,13 \u002B336,15 @@ public:\n    * \\param period The interval at which the timer fires\n    * \\param callback The callback function to execute every interval\n    * \\param context node context\n\u002B   * \\param autostart timer state on initialization\n    */\n   WallTimer(\n     std::chrono::nanoseconds period,\n     FunctorT \u0026\u0026 callback,\n-    rclcpp::Context::SharedPtr context)\n\u002B    rclcpp::Context::SharedPtr context,\n\u002B    bool autostart = true)\n   : GenericTimer\u003CFunctorT\u003E(\n-      std::make_shared\u003CClock\u003E(RCL_STEADY_TIME), period, std::move(callback), context)\n\u002B      std::make_shared\u003CClock\u003E(RCL_STEADY_TIME), period, std::move(callback), context, autostart)\n   {}\n \n protected:\ndiff --git rclcpp/src/rclcpp/timer.cpp rclcpp/src/rclcpp/timer.cpp\nindex 59ddd5e8..0dceb6b8 100644\n--- rclcpp/src/rclcpp/timer.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/timer.cpp\n@@ -32,7 \u002B32,8 @@ using rclcpp::TimerBase;\n TimerBase::TimerBase(\n   rclcpp::Clock::SharedPtr clock,\n   std::chrono::nanoseconds period,\n-  rclcpp::Context::SharedPtr context)\n\u002B  rclcpp::Context::SharedPtr context,\n\u002B  bool autostart)\n : clock_(clock), timer_handle_(nullptr)\n {\n   if (nullptr == context) {\n@@ -64,9 \u002B65,9 @@ TimerBase::TimerBase(\n   rcl_clock_t * clock_handle = clock_-\u003Eget_clock_handle();\n   {\n     std::lock_guard\u003Cstd::mutex\u003E clock_guard(clock_-\u003Eget_clock_mutex());\n-    rcl_ret_t ret = rcl_timer_init(\n-      timer_handle_.get(), clock_handle, rcl_context.get(), period.count(), nullptr,\n-      rcl_get_default_allocator());\n\u002B    rcl_ret_t ret = rcl_timer_init2(\n\u002B      timer_handle_.get(), clock_handle, rcl_context.get(), period.count(),\n\u002B      nullptr, rcl_get_default_allocator(), autostart);\n     if (ret != RCL_RET_OK) {\n       rclcpp::exceptions::throw_from_rcl_error(ret, \u0022Couldn\u0027t initialize rcl timer handle\u0022);\n     }\ndiff --git rclcpp/test/rclcpp/test_create_timer.cpp rclcpp/test/rclcpp/test_create_timer.cpp\nindex f253af48..c4dc1f7e 100644\n--- rclcpp/test/rclcpp/test_create_timer.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_create_timer.cpp\n@@ -193,3 \u002B193,29 @@ TEST(TestCreateTimer, timer_function_pointer)\n \n   rclcpp::shutdown();\n }\n\u002B\n\u002BTEST(TestCreateTimer, timer_without_autostart)\n\u002B{\n\u002B  rclcpp::init(0, nullptr);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_create_timer_node\u0022);\n\u002B\n\u002B  rclcpp::TimerBase::SharedPtr timer;\n\u002B  timer = rclcpp::create_timer(\n\u002B    node,\n\u002B    node-\u003Eget_clock(),\n\u002B    rclcpp::Duration(0ms),\n\u002B    []() {},\n\u002B    nullptr,\n\u002B    false);\n\u002B\n\u002B  EXPECT_TRUE(timer-\u003Eis_canceled());\n\u002B  EXPECT_EQ(timer-\u003Etime_until_trigger().count(), std::chrono::nanoseconds::max().count());\n\u002B\n\u002B  timer-\u003Ereset();\n\u002B  EXPECT_LE(timer-\u003Etime_until_trigger().count(), std::chrono::nanoseconds::max().count());\n\u002B  EXPECT_FALSE(timer-\u003Eis_canceled());\n\u002B\n\u002B  timer-\u003Ecancel();\n\u002B\n\u002B  rclcpp::shutdown();\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_timer.cpp rclcpp/test/rclcpp/test_timer.cpp\nindex 59a12185..33ded455 100644\n--- rclcpp/test/rclcpp/test_timer.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_timer.cpp\n@@ -73,6 \u002B73,20 @@ protected:\n         EXPECT_FALSE(timer-\u003Eis_steady());\n         break;\n     }\n\u002B    timer_without_autostart = test_node-\u003Ecreate_wall_timer(\n\u002B      100ms,\n\u002B      [this]() -\u003E void\n\u002B      {\n\u002B        this-\u003Ehas_timer_run.store(true);\n\u002B\n\u002B        if (this-\u003Ecancel_timer.load()) {\n\u002B          this-\u003Etimer-\u003Ecancel();\n\u002B        }\n\u002B        // prevent any tests running timer from blocking\n\u002B        this-\u003Eexecutor-\u003Ecancel();\n\u002B      }, nullptr, false);\n\u002B    EXPECT_TRUE(timer_without_autostart-\u003Eis_steady());\n\u002B\n     executor-\u003Eadd_node(test_node);\n     // don\u0027t start spinning, let the test dictate when\n   }\n@@ -93,6 \u002B107,7 @@ protected:\n   std::atomic\u003Cbool\u003E cancel_timer;\n   rclcpp::Node::SharedPtr test_node;\n   std::shared_ptr\u003Crclcpp::TimerBase\u003E timer;\n\u002B  std::shared_ptr\u003Crclcpp::TimerBase\u003E timer_without_autostart;\n   std::shared_ptr\u003Crclcpp::executors::SingleThreadedExecutor\u003E executor;\n };\n \n@@ -334,3 \u002B349,18 @@ INSTANTIATE_TEST_SUITE_P(\n     return std::string(\u0022unknown\u0022);\n   }\n );\n\u002B\n\u002B/// Simple test of a timer without autostart\n\u002BTEST_P(TestTimer, test_timer_without_autostart)\n\u002B{\n\u002B  EXPECT_TRUE(timer_without_autostart-\u003Eis_canceled());\n\u002B  EXPECT_EQ(\n\u002B    timer_without_autostart-\u003Etime_until_trigger().count(),\n\u002B    std::chrono::nanoseconds::max().count());\n\u002B  // Reset to change start timer\n\u002B  timer_without_autostart-\u003Ereset();\n\u002B  EXPECT_LE(\n\u002B    timer_without_autostart-\u003Etime_until_trigger().count(),\n\u002B    std::chrono::nanoseconds::max().count());\n\u002B  EXPECT_FALSE(timer_without_autostart-\u003Eis_canceled());\n\u002B}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "31380f8fe65695d4f92dc2846c29a2f0a982787f",
    "RawMessage": "export image_transport dependency (#813)",
    "Changes": "diff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex 16781008..a4034bf6 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -246,10 \u002B246,11 @@ pluginlib_export_plugin_description_file(rviz_common plugins_description.xml)\n ament_target_dependencies(rviz_default_plugins\n   PUBLIC\n   geometry_msgs\n\u002B  image_transport\n   interactive_markers\n   laser_geometry\n-  nav_msgs\n   map_msgs\n\u002B  nav_msgs\n   rclcpp\n   resource_retriever\n   rviz_common\n@@ -260,20 \u002B261,20 @@ ament_target_dependencies(rviz_default_plugins\n   tf2_ros\n   urdf\n   visualization_msgs\n-  image_transport\n )\n \n ament_export_include_directories(include)\n ament_export_targets(rviz_default_plugins HAS_LIBRARY_TARGET)\n ament_export_dependencies(\n-  rviz_common\n   geometry_msgs\n\u002B  image_transport\n   interactive_markers\n   laser_geometry\n   map_msgs\n   nav_msgs\n   rclcpp\n   resource_retriever\n\u002B  rviz_common\n   rviz_ogre_vendor\n   sensor_msgs\n   tf2\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "253d395d4e3dc6f9491f24e924f88805cd9407a2",
    "RawMessage": "Cleanup flaky timers_manager tests. (#2299)",
    "Changes": "diff --git rclcpp/include/rclcpp/experimental/timers_manager.hpp rclcpp/include/rclcpp/experimental/timers_manager.hpp\nindex e8830c01..68868437 100644\n--- rclcpp/include/rclcpp/experimental/timers_manager.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/timers_manager.hpp\n@@ -527,7 \u002B527,7 @@ private:\n   void execute_ready_timers_unsafe();\n \n   // Callback to be called when timer is ready\n-  std::function\u003Cvoid(const rclcpp::TimerBase *)\u003E on_ready_callback_ = nullptr;\n\u002B  std::function\u003Cvoid(const rclcpp::TimerBase *)\u003E on_ready_callback_;\n \n   // Thread used to run the timers execution task\n   std::thread timers_thread_;\ndiff --git rclcpp/src/rclcpp/experimental/timers_manager.cpp rclcpp/src/rclcpp/experimental/timers_manager.cpp\nindex f4ecd16b..e179787b 100644\n--- rclcpp/src/rclcpp/experimental/timers_manager.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/experimental/timers_manager.cpp\n@@ -28,9 \u002B28,9 @@ using rclcpp::experimental::TimersManager;\n TimersManager::TimersManager(\n   std::shared_ptr\u003Crclcpp::Context\u003E context,\n   std::function\u003Cvoid(const rclcpp::TimerBase *)\u003E on_ready_callback)\n\u002B: on_ready_callback_(on_ready_callback),\n\u002B  context_(context)\n {\n-  context_ = context;\n-  on_ready_callback_ = on_ready_callback;\n }\n \n TimersManager::~TimersManager()\ndiff --git rclcpp/test/rclcpp/test_timers_manager.cpp rclcpp/test/rclcpp/test_timers_manager.cpp\nindex 635ec322..16752393 100644\n--- rclcpp/test/rclcpp/test_timers_manager.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_timers_manager.cpp\n@@ -15,6 \u002B15,7 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Cchrono\u003E\n\u002B#include \u003Ccmath\u003E\n #include \u003Cmemory\u003E\n #include \u003Cutility\u003E\n \n@@ -65,8 \u002B66,10 @@ TEST_F(TestTimersManager, empty_manager)\n TEST_F(TestTimersManager, add_run_remove_timer)\n {\n   size_t t_runs = 0;\n\u002B  std::chrono::milliseconds timer_period(10);\n\u002B\n   auto t = TimerT::make_shared(\n-    10ms,\n\u002B    timer_period,\n     [\u0026t_runs]() {\n       t_runs\u002B\u002B;\n     },\n@@ -79,7 \u002B82,7 @@ TEST_F(TestTimersManager, add_run_remove_timer)\n   timers_manager-\u003Eadd_timer(t);\n \n   // Sleep for more 3 times the timer period\n-  std::this_thread::sleep_for(30ms);\n\u002B  std::this_thread::sleep_for(3 * timer_period);\n \n   // The timer is executed only once, even if we slept 3 times the period\n   execute_all_ready_timers(timers_manager);\n@@ -191,67 \u002B194,6 @@ TEST_F(TestTimersManager, head_not_ready)\n   EXPECT_EQ(0u, t_runs);\n }\n \n-TEST_F(TestTimersManager, timers_order)\n-{\n-  auto timers_manager = std::make_shared\u003CTimersManager\u003E(\n-    rclcpp::contexts::get_global_default_context());\n-\n-  size_t t1_runs = 0;\n-  auto t1 = TimerT::make_shared(\n-    10ms,\n-    [\u0026t1_runs]() {\n-      t1_runs\u002B\u002B;\n-    },\n-    rclcpp::contexts::get_global_default_context());\n-\n-  size_t t2_runs = 0;\n-  auto t2 = TimerT::make_shared(\n-    30ms,\n-    [\u0026t2_runs]() {\n-      t2_runs\u002B\u002B;\n-    },\n-    rclcpp::contexts::get_global_default_context());\n-\n-  size_t t3_runs = 0;\n-  auto t3 = TimerT::make_shared(\n-    100ms,\n-    [\u0026t3_runs]() {\n-      t3_runs\u002B\u002B;\n-    },\n-    rclcpp::contexts::get_global_default_context());\n-\n-  // Add timers in a random order\n-  timers_manager-\u003Eadd_timer(t2);\n-  timers_manager-\u003Eadd_timer(t3);\n-  timers_manager-\u003Eadd_timer(t1);\n-\n-  std::this_thread::sleep_for(10ms);\n-  execute_all_ready_timers(timers_manager);\n-  EXPECT_EQ(1u, t1_runs);\n-  EXPECT_EQ(0u, t2_runs);\n-  EXPECT_EQ(0u, t3_runs);\n-\n-  std::this_thread::sleep_for(30ms);\n-  execute_all_ready_timers(timers_manager);\n-  EXPECT_EQ(2u, t1_runs);\n-  EXPECT_EQ(1u, t2_runs);\n-  EXPECT_EQ(0u, t3_runs);\n-\n-  std::this_thread::sleep_for(100ms);\n-  execute_all_ready_timers(timers_manager);\n-  EXPECT_EQ(3u, t1_runs);\n-  EXPECT_EQ(2u, t2_runs);\n-  EXPECT_EQ(1u, t3_runs);\n-\n-  timers_manager-\u003Eremove_timer(t1);\n-\n-  std::this_thread::sleep_for(30ms);\n-  execute_all_ready_timers(timers_manager);\n-  EXPECT_EQ(3u, t1_runs);\n-  EXPECT_EQ(3u, t2_runs);\n-  EXPECT_EQ(1u, t3_runs);\n-}\n-\n TEST_F(TestTimersManager, start_stop_timers_thread)\n {\n   auto timers_manager = std::make_shared\u003CTimersManager\u003E(\n@@ -274,7 \u002B216,7 @@ TEST_F(TestTimersManager, timers_thread)\n   auto timers_manager = std::make_shared\u003CTimersManager\u003E(\n     rclcpp::contexts::get_global_default_context());\n \n-  size_t t1_runs = 0;\n\u002B  int t1_runs = 0;\n   auto t1 = TimerT::make_shared(\n     1ms,\n     [\u0026t1_runs]() {\n@@ -282,7 \u002B224,7 @@ TEST_F(TestTimersManager, timers_thread)\n     },\n     rclcpp::contexts::get_global_default_context());\n \n-  size_t t2_runs = 0;\n\u002B  int t2_runs = 0;\n   auto t2 = TimerT::make_shared(\n     1ms,\n     [\u0026t2_runs]() {\n@@ -296,12 \u002B238,12 @@ TEST_F(TestTimersManager, timers_thread)\n \n   // Run timers thread for a while\n   timers_manager-\u003Estart();\n-  std::this_thread::sleep_for(5ms);\n\u002B  std::this_thread::sleep_for(50ms);\n   timers_manager-\u003Estop();\n \n   EXPECT_LT(1u, t1_runs);\n   EXPECT_LT(1u, t2_runs);\n-  EXPECT_EQ(t1_runs, t2_runs);\n\u002B  EXPECT_LE(std::abs(t1_runs - t2_runs), 1);\n }\n \n TEST_F(TestTimersManager, destructor)\n@@ -365,13 \u002B307,13 @@ TEST_F(TestTimersManager, add_remove_while_thread_running)\n   timers_manager-\u003Estart();\n \n   // After a while remove t1 and add t2\n-  std::this_thread::sleep_for(5ms);\n\u002B  std::this_thread::sleep_for(50ms);\n   timers_manager-\u003Eremove_timer(t1);\n   size_t tmp_t1 = t1_runs;\n   timers_manager-\u003Eadd_timer(t2);\n \n   // Wait some more time and then stop\n-  std::this_thread::sleep_for(5ms);\n\u002B  std::this_thread::sleep_for(50ms);\n   timers_manager-\u003Estop();\n \n   // t1 has stopped running\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "ros2cli",
    "SHA": "c0575edb2d23bb6598e591e05fa171878efec616",
    "RawMessage": "Remove use of pkg_resources from ros2cli.",
    "Changes": "diff --git ros2cli/package.xml ros2cli/package.xml\nindex 7b33bc4..ecc621d 100644\n--- ros2cli/package.xml\n\u002B\u002B\u002B ros2cli/package.xml\n@@ -9,7 \u002B9,9 @@\n   \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cexec_depend\u003Epython3-importlib-metadata\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Epython3-netifaces\u003C/exec_depend\u003E\n\u002B  \u003Cexec_depend\u003Epython3-packaging\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Epython3-pkg-resources\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Erclpy\u003C/exec_depend\u003E\n \ndiff --git ros2cli/ros2cli/entry_points.py ros2cli/ros2cli/entry_points.py\nindex cb6e8f6..9a9bd7e 100644\n--- ros2cli/ros2cli/entry_points.py\n\u002B\u002B\u002B ros2cli/ros2cli/entry_points.py\n@@ -16,8 \u002B16,7 @@\n from collections import defaultdict\n import logging\n \n-from pkg_resources import iter_entry_points\n-from pkg_resources import WorkingSet\n\u002Bimport importlib_metadata\n \n \u0022\u0022\u0022\n The group name for entry points identifying extension points.\n@@ -41,18 \u002B40,14 @@ def get_all_entry_points():\n     extension_points = get_entry_points(EXTENSION_POINT_GROUP_NAME)\n \n     entry_points = defaultdict(dict)\n-    working_set = WorkingSet()\n-    for dist in sorted(working_set):\n-        entry_map = dist.get_entry_map()\n-        for group_name in entry_map.keys():\n\u002B\n\u002B    for dist in importlib_metadata.distributions():\n\u002B        for ep in dist.entry_points:\n             # skip groups which are not registered as extension points\n-            if group_name not in extension_points:\n\u002B            if ep.group not in extension_points:\n                 continue\n \n-            group = entry_map[group_name]\n-            for entry_point_name, entry_point in group.items():\n-                entry_points[group_name][entry_point_name] = \\\n-                    (dist, entry_point)\n\u002B            entry_points[ep.group][ep.name] = (dist, ep)\n     return entry_points\n \n \n@@ -66,7 \u002B61,7 @@ def get_entry_points(group_name):\n     :rtype: dict\n     \u0022\u0022\u0022\n     entry_points = {}\n-    for entry_point in iter_entry_points(group=group_name):\n\u002B    for entry_point in importlib_metadata.entry_points().get(group_name, []):\n         entry_points[entry_point.name] = entry_point\n     return entry_points\n \ndiff --git ros2cli/ros2cli/plugin_system.py ros2cli/ros2cli/plugin_system.py\nindex 6e5892b..bb794be 100644\n--- ros2cli/ros2cli/plugin_system.py\n\u002B\u002B\u002B ros2cli/ros2cli/plugin_system.py\n@@ -16,7 \u002B16,7 @@\n from collections import OrderedDict\n import logging\n \n-from pkg_resources import parse_version\n\u002Bfrom packaging.version import Version\n \n from ros2cli.entry_points import load_entry_points\n \n@@ -85,8 \u002B85,8 @@ def order_extensions_by_name(extensions):\n \n def satisfies_version(version, caret_range):\n     assert caret_range.startswith(\u0027^\u0027), \u0027Only supports caret ranges\u0027\n-    extension_point_version = parse_version(version)\n-    extension_version = parse_version(caret_range[1:])\n\u002B    extension_point_version = Version(version)\n\u002B    extension_version = Version(caret_range[1:])\n     next_extension_version = get_upper_bound_caret_version(\n         extension_version)\n \n@@ -111,4 \u002B111,4 @@ def get_upper_bound_caret_version(version):\n         minor = 0\n     else:\n         minor \u002B= 1\n-    return parse_version(\u0027%d.%d.0\u0027 % (major, minor))\n\u002B    return Version(\u0027%d.%d.0\u0027 % (major, minor))\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "de026ed2bd70d4fa93855523c773a7cbb9701f8d",
    "RawMessage": "Added rmw_event_type_is_supported (#532)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 3f1aff7..e51123c 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -3910,6 \u002B3910,11 @@ extern \u0022C\u0022 rmw_ret_t rmw_subscription_event_init(\n     event_type);\n }\n \n\u002Bextern \u0022C\u0022 bool rmw_event_type_is_supported(rmw_event_type_t rmw_event_type)\n\u002B{\n\u002B  return is_event_supported(rmw_event_type);\n\u002B}\n\u002B\n extern \u0022C\u0022 rmw_ret_t rmw_take_event(\n   const rmw_event_t * event_handle, void * event_info,\n   bool * taken)\n",
    "BackportedTo": "jazzy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcutils",
    "SHA": "e19b8123cc8dc83548b9f1d055d5417e41316e34",
    "RawMessage": "env.h and get_env.h docblock fixes (#291)",
    "Changes": "diff --git include/rcutils/env.h include/rcutils/env.h\nindex f5f347a..4a469e1 100644\n--- include/rcutils/env.h\n\u002B\u002B\u002B include/rcutils/env.h\n@@ -35,8 \u002B35,7 @@ extern \u0022C\u0022\n  * store.\n  *\n  * \\par Thread Safety:\n- * This function is not thread-safe, particularly when called concurrently with\n- * ::rcutils_get_env. Take care not to modify the environment variables while\n\u002B * This function is not thread-safe. Take care not to modify the environment variables while\n  * another thread might be reading or writing environment variables.\n  *\n  * \\par Platform Consistency:\ndiff --git include/rcutils/get_env.h include/rcutils/get_env.h\nindex 8050309..f1d1e03 100644\n--- include/rcutils/get_env.h\n\u002B\u002B\u002B include/rcutils/get_env.h\n@@ -47,9 \u002B47,8 @@ extern \u0022C\u0022\n  * printf(\u0022Valued of \u0027SOME_ENV_VAR\u0027: %s\\n\u0022, env_value);\n  * \u0060\u0060\u0060\n  *\n- * Environment variables will be truncated at 2048 characters on Windows.\n- *\n- * This function is not thread-safe.\n\u002B * This function cannot be concurrently called together with rcutils_set_env (or any platform specific equivalent)\n\u002B * on different threads, but multiple concurrent calls to this function are thread safe.\n  *\n  * \\param[in] env_name the name of the environment variable\n  * \\param[out] env_value pointer to the value cstring, or \u0022\u0022 if unset\n@@ -74,9 \u002B73,8 @@ rcutils_get_env(const char * env_name, const char ** env_value);\n  * If neither exists, NULL will be returned.\n  * The above algorithm is portable across both Unix and Windows.\n  *\n- * The home directory will be truncated at 2048 characters on Windows.\n- *\n- * This function is not thread-safe.\n\u002B * This function cannot be thread-safely called together with rcutils_set_env\n\u002B * (or any platform specific equivalent), but multiple calls to this function are thread safe.\n  *\n  * \\return The home directory on success, NULL on failure.\n  */\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "d107a844eae6f4d6a86515f0b3e469802ab1e785",
    "RawMessage": "Handle sigterm, in the same way we handle sigint (#1771)",
    "Changes": "diff --git rclcpp/include/rclcpp/context.hpp rclcpp/include/rclcpp/context.hpp\nindex 5d71ffe0..7d7472c8 100644\n--- rclcpp/include/rclcpp/context.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/context.hpp\n@@ -75,7 \u002B75,7 @@ public:\n    * Every context which is constructed is added to a global vector of contexts,\n    * which is used by the signal handler to conditionally shutdown each context\n    * on SIGINT.\n-   * See the shutdown_on_sigint option in the InitOptions class.\n\u002B   * See the shutdown_on_signal option in the InitOptions class.\n    */\n   RCLCPP_PUBLIC\n   Context();\n@@ -93,7 \u002B93,7 @@ public:\n    * Note that this function does not setup any signal handlers, so if you want\n    * it to be shutdown by the signal handler, then you need to either install\n    * them manually with rclcpp::install_signal_handlers() or use rclcpp::init().\n-   * In addition to installing the signal handlers, the shutdown_on_sigint\n\u002B   * In addition to installing the signal handlers, the shutdown_on_signal\n    * of the InitOptions needs to be \u0060true\u0060 for this context to be shutdown by\n    * the signal handler, otherwise it will be passed over.\n    *\n@@ -268,7 \u002B268,7 @@ public:\n    *\n    *   - this context is shutdown()\n    *   - this context is destructed (resulting in shutdown)\n-   *   - this context has shutdown_on_sigint=true and SIGINT occurs (resulting in shutdown)\n\u002B   *   - this context has shutdown_on_signal=true and SIGINT/SIGTERM occurs (resulting in shutdown)\n    *   - interrupt_all_sleep_for() is called\n    *\n    * \\param[in] nanoseconds A std::chrono::duration representing how long to sleep for.\ndiff --git rclcpp/include/rclcpp/init_options.hpp rclcpp/include/rclcpp/init_options.hpp\nindex 6f87904f..ab1346db 100644\n--- rclcpp/include/rclcpp/init_options.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/init_options.hpp\n@@ -29,7 \u002B29,7 @@ class InitOptions\n {\n public:\n   /// If true, the context will be shutdown on SIGINT by the signal handler (if it was installed).\n-  bool shutdown_on_sigint = true;\n\u002B  bool shutdown_on_signal = true;\n \n   /// Constructor\n   /**\ndiff --git rclcpp/include/rclcpp/utilities.hpp rclcpp/include/rclcpp/utilities.hpp\nindex 5011a12c..e9d8408b 100644\n--- rclcpp/include/rclcpp/utilities.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/utilities.hpp\n@@ -42,6 \u002B42,20 @@ std::string to_string(T value)\n \n namespace rclcpp\n {\n\u002B\n\u002B/// Option to indicate which signal handlers rclcpp should install.\n\u002Benum class SignalHandlerOptions\n\u002B{\n\u002B  /// Install both sigint and sigterm, this is the default behavior.\n\u002B  All,\n\u002B  /// Install only a sigint handler.\n\u002B  SigInt,\n\u002B  /// Install only a sigterm handler.\n\u002B  SigTerm,\n\u002B  /// Do not install any signal handler.\n\u002B  None,\n\u002B};\n\u002B\n /// Initialize communications via the rmw implementation and set up a global signal handler.\n /**\n  * Initializes the global context which is accessible via the function\n@@ -50,10 \u002B64,16 @@ namespace rclcpp\n  * rclcpp::install_signal_handlers().\n  *\n  * \\sa rclcpp::Context::init() for more details on arguments and possible exceptions\n\u002B *\n\u002B * \\param signal_handler_options option to indicate which signal handlers should be installed.\n  */\n RCLCPP_PUBLIC\n void\n-init(int argc, char const * const argv[], const InitOptions \u0026 init_options = InitOptions());\n\u002Binit(\n\u002B  int argc,\n\u002B  char const * const argv[],\n\u002B  const InitOptions \u0026 init_options = InitOptions(),\n\u002B  SignalHandlerOptions signal_handler_options = SignalHandlerOptions::All);\n \n /// Install the global signal handler for rclcpp.\n /**\n@@ -67,17 \u002B87,26 @@ init(int argc, char const * const argv[], const InitOptions \u0026 init_options = Ini\n  *\n  * This function is thread-safe.\n  *\n\u002B * \\param signal_handler_options option to indicate which signal handlers should be installed.\n  * \\return true if signal handler was installed by this function, false if already installed.\n  */\n RCLCPP_PUBLIC\n bool\n-install_signal_handlers();\n\u002Binstall_signal_handlers(SignalHandlerOptions signal_handler_options = SignalHandlerOptions::All);\n \n /// Return true if the signal handlers are installed, otherwise false.\n RCLCPP_PUBLIC\n bool\n signal_handlers_installed();\n \n\u002B/// Get the current signal handler options.\n\u002B/**\n\u002B * If no signal handler is installed, SignalHandlerOptions::None is returned.\n\u002B */\n\u002BRCLCPP_PUBLIC\n\u002BSignalHandlerOptions\n\u002Bget_current_signal_handler_options();\n\u002B\n /// Uninstall the global signal handler for rclcpp.\n /**\n  * This function does not necessarily need to be called, but can be used to\ndiff --git rclcpp/src/rclcpp/init_options.cpp rclcpp/src/rclcpp/init_options.cpp\nindex 49b408b8..5b8452c0 100644\n--- rclcpp/src/rclcpp/init_options.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/init_options.cpp\n@@ -43,7 \u002B43,7 @@ InitOptions::InitOptions(const rcl_init_options_t \u0026 init_options)\n InitOptions::InitOptions(const InitOptions \u0026 other)\n : InitOptions(*other.get_rcl_init_options())\n {\n-  shutdown_on_sigint = other.shutdown_on_sigint;\n\u002B  shutdown_on_signal = other.shutdown_on_signal;\n   initialize_logging_ = other.initialize_logging_;\n }\n \n@@ -70,7 \u002B70,7 @@ InitOptions::operator=(const InitOptions \u0026 other)\n     if (RCL_RET_OK != ret) {\n       rclcpp::exceptions::throw_from_rcl_error(ret, \u0022failed to copy rcl init options\u0022);\n     }\n-    this-\u003Eshutdown_on_sigint = other.shutdown_on_sigint;\n\u002B    this-\u003Eshutdown_on_signal = other.shutdown_on_signal;\n     this-\u003Einitialize_logging_ = other.initialize_logging_;\n   }\n   return *this;\ndiff --git rclcpp/src/rclcpp/signal_handler.cpp rclcpp/src/rclcpp/signal_handler.cpp\nindex eda85850..55ef9887 100644\n--- rclcpp/src/rclcpp/signal_handler.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/signal_handler.cpp\n@@ -30,80 \u002B30,131 @@\n #endif\n \n #include \u0022rclcpp/logging.hpp\u0022\n\u002B#include \u0022rclcpp/utilities.hpp\u0022\n #include \u0022rcutils/strerror.h\u0022\n #include \u0022rmw/impl/cpp/demangle.hpp\u0022\n \n using rclcpp::SignalHandler;\n\u002Busing rclcpp::SignalHandlerOptions;\n \n-// initialize static storage in SignalHandler class\n-SignalHandler::signal_handler_type SignalHandler::old_signal_handler_;\n-std::atomic_bool SignalHandler::signal_received_ = ATOMIC_VAR_INIT(false);\n-std::atomic_bool SignalHandler::wait_for_signal_is_setup_ = ATOMIC_VAR_INIT(false);\n-#if defined(_WIN32)\n-HANDLE SignalHandler::signal_handler_sem_;\n-#elif defined(__APPLE__)\n-dispatch_semaphore_t SignalHandler::signal_handler_sem_;\n-#else  // posix\n-sem_t SignalHandler::signal_handler_sem_;\n\u002BSignalHandler::signal_handler_type\n\u002BSignalHandler::set_signal_handler(\n\u002B  int signal_value,\n\u002B  const SignalHandler::signal_handler_type \u0026 signal_handler)\n\u002B{\n\u002B  bool signal_handler_install_failed;\n\u002B  SignalHandler::signal_handler_type old_signal_handler;\n\u002B#if defined(RCLCPP_HAS_SIGACTION)\n\u002B  ssize_t ret = sigaction(signal_value, \u0026signal_handler, \u0026old_signal_handler);\n\u002B  signal_handler_install_failed = (ret == -1);\n\u002B#else\n\u002B  old_signal_handler = std::signal(signal_value, signal_handler);\n\u002B  signal_handler_install_failed = (old_signal_handler == SIG_ERR);\n #endif\n\u002B  if (signal_handler_install_failed) {\n\u002B    char error_string[1024];\n\u002B    rcutils_strerror(error_string, sizeof(error_string));\n\u002B    auto msg =\n\u002B      \u0022Failed to set signal handler (\u0022 \u002B std::to_string(errno) \u002B \u0022): \u0022 \u002B error_string;\n\u002B    throw std::runtime_error(msg);\n\u002B  }\n\u002B  return old_signal_handler;\n\u002B}\n \n-// The logger must be initialized before the local static variable signal_handler,\n-// from the method get_global_signal_handler(), so that it is destructed after\n-// it, because the destructor of SignalHandler uses this logger object.\n-static rclcpp::Logger g_logger = rclcpp::get_logger(\u0022rclcpp\u0022);\n\u002B// Unfortunately macros (or duplicated code) are needed here,\n\u002B// as the signal handler must be a function pointer.\n\u002B#if defined(RCLCPP_HAS_SIGACTION)\n\u002Bvoid\n\u002BSignalHandler::signal_handler(\n\u002B  int signum, siginfo_t * siginfo, void * context)\n\u002B{\n\u002B  RCLCPP_INFO(SignalHandler::get_logger(), \u0022signal_handler(signum=%d)\u0022, signum);\n\u002B  auto \u0026 instance = SignalHandler::get_global_signal_handler();\n\u002B\n\u002B  auto old_signal_handler = instance.get_old_signal_handler(signum);\n\u002B  if (old_signal_handler.sa_flags \u0026 SA_SIGINFO) {\n\u002B    if (old_signal_handler.sa_sigaction != NULL) {\n\u002B      old_signal_handler.sa_sigaction(signum, siginfo, context);\n\u002B    }\n\u002B  } else {\n\u002B    if (\n\u002B      old_signal_handler.sa_handler != NULL \u0026\u0026  /* Is set */\n\u002B      old_signal_handler.sa_handler != SIG_DFL \u0026\u0026  /* Is not default*/\n\u002B      old_signal_handler.sa_handler != SIG_IGN)  /* Is not ignored */\n\u002B    {\n\u002B      old_signal_handler.sa_handler(signum);\n\u002B    }\n\u002B  }\n\u002B  instance.signal_handler_common();\n\u002B}\n\u002B#else\n\u002Bvoid\n\u002BSignalHandler::signal_handler(int signum)\n\u002B{\n\u002B  RCLCPP_INFO(SignalHandler::get_logger(), \u0022signal_handler(signum=%d)\u0022, signum);\n\u002B  auto \u0026 instance = SignalHandler::get_global_signal_handler();\n\u002B  auto old_signal_handler = instance.get_old_signal_handler(signum);\n\u002B  if (\n\u002B    SIG_ERR != old_signal_handler \u0026\u0026 SIG_IGN != old_signal_handler \u0026\u0026\n\u002B    SIG_DFL != old_signal_handler)\n\u002B  {\n\u002B    old_signal_handler(signum);\n\u002B  }\n\u002B  instance.signal_handler_common();\n\u002B}\n\u002B#endif\n \n rclcpp::Logger \u0026\n SignalHandler::get_logger()\n {\n-  return g_logger;\n\u002B  return SignalHandler::get_global_signal_handler().logger_;\n }\n \n SignalHandler \u0026\n SignalHandler::get_global_signal_handler()\n {\n-  // This is initialized after the g_logger static global, ensuring\n-  // SignalHandler::get_logger() may be called from the destructor of\n-  // SignalHandler, according to this:\n-  //\n-  //   Variables declared at block scope with the specifier static have static\n-  //   storage duration but are initialized the first time control passes\n-  //   through their declaration (unless their initialization is zero- or\n-  //   constant-initialization, which can be performed before the block is\n-  //   first entered). On all further calls, the declaration is skipped.\n-  //\n-  // -- https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables\n-  //\n-  // Which is guaranteed to occur after static initialization for global (see:\n-  // https://en.cppreference.com/w/cpp/language/initialization#Static_initialization),\n-  // which is when g_logger will be initialized.\n-  // And destruction will occur in the reverse order.\n   static SignalHandler signal_handler;\n   return signal_handler;\n }\n \n bool\n-SignalHandler::install()\n\u002BSignalHandler::install(SignalHandlerOptions signal_handler_options)\n {\n   std::lock_guard\u003Cstd::mutex\u003E lock(install_mutex_);\n   bool already_installed = installed_.exchange(true);\n   if (already_installed) {\n     return false;\n   }\n\u002B  if (signal_handler_options == SignalHandlerOptions::None) {\n\u002B    return true;\n\u002B  }\n\u002B  signal_handlers_options_ = signal_handler_options;\n   try {\n     setup_wait_for_signal();\n     signal_received_.store(false);\n \n-    SignalHandler::signal_handler_type signal_handler_argument;\n\u002B    SignalHandler::signal_handler_type handler_argument;\n #if defined(RCLCPP_HAS_SIGACTION)\n-    memset(\u0026signal_handler_argument, 0, sizeof(signal_handler_argument));\n-    sigemptyset(\u0026signal_handler_argument.sa_mask);\n-    signal_handler_argument.sa_sigaction = signal_handler;\n-    signal_handler_argument.sa_flags = SA_SIGINFO;\n\u002B    memset(\u0026handler_argument, 0, sizeof(handler_argument));\n\u002B    sigemptyset(\u0026handler_argument.sa_mask);\n\u002B    handler_argument.sa_sigaction = \u0026this-\u003Esignal_handler;\n\u002B    handler_argument.sa_flags = SA_SIGINFO;\n #else\n-    signal_handler_argument = signal_handler;\n\u002B    handler_argument = \u0026this-\u003Esignal_handler;\n #endif\n\u002B    if (\n\u002B      signal_handler_options == SignalHandlerOptions::SigInt ||\n\u002B      signal_handler_options == SignalHandlerOptions::All)\n\u002B    {\n\u002B      old_sigint_handler_ = set_signal_handler(SIGINT, handler_argument);\n\u002B    }\n \n-    old_signal_handler_ = SignalHandler::set_signal_handler(SIGINT, signal_handler_argument);\n\u002B    if (\n\u002B      signal_handler_options == SignalHandlerOptions::SigTerm ||\n\u002B      signal_handler_options == SignalHandlerOptions::All)\n\u002B    {\n\u002B      old_sigterm_handler_ = set_signal_handler(SIGTERM, handler_argument);\n\u002B    }\n \n     signal_handler_thread_ = std::thread(\u0026SignalHandler::deferred_signal_handler, this);\n   } catch (...) {\n@@ -125,7 \u002B176,19 @@ SignalHandler::uninstall()\n   try {\n     // TODO(wjwwood): what happens if someone overrides our signal handler then calls uninstall?\n     //   I think we need to assert that we\u0027re the current signal handler, and mitigate if not.\n-    set_signal_handler(SIGINT, old_signal_handler_);\n\u002B    if (\n\u002B      SignalHandlerOptions::SigInt == signal_handlers_options_ ||\n\u002B      SignalHandlerOptions::All == signal_handlers_options_)\n\u002B    {\n\u002B      set_signal_handler(SIGINT, old_sigint_handler_);\n\u002B    }\n\u002B    if (\n\u002B      SignalHandlerOptions::SigTerm == signal_handlers_options_ ||\n\u002B      SignalHandlerOptions::All == signal_handlers_options_)\n\u002B    {\n\u002B      set_signal_handler(SIGTERM, old_sigterm_handler_);\n\u002B    }\n\u002B    signal_handlers_options_ = SignalHandlerOptions::None;\n     RCLCPP_DEBUG(get_logger(), \u0022SignalHandler::uninstall(): notifying deferred signal handler\u0022);\n     notify_signal_handler();\n     signal_handler_thread_.join();\n@@ -151,98 \u002B214,57 @@ SignalHandler::~SignalHandler()\n   } catch (const std::exception \u0026 exc) {\n     RCLCPP_ERROR(\n       get_logger(),\n-      \u0022caught %s exception when uninstalling the sigint handler in rclcpp::~SignalHandler: %s\u0022,\n\u002B      \u0022caught %s exception when uninstalling signal handlers in rclcpp::~SignalHandler: %s\u0022,\n       rmw::impl::cpp::demangle(exc).c_str(), exc.what());\n   } catch (...) {\n     RCLCPP_ERROR(\n       get_logger(),\n-      \u0022caught unknown exception when uninstalling the sigint handler in rclcpp::~SignalHandler\u0022);\n\u002B      \u0022caught unknown exception when uninstalling signal handlers in rclcpp::~SignalHandler\u0022);\n   }\n }\n \n SignalHandler::signal_handler_type\n-SignalHandler::set_signal_handler(\n-  int signal_value,\n-  const SignalHandler::signal_handler_type \u0026 signal_handler)\n\u002BSignalHandler::get_old_signal_handler(int signum)\n {\n-  bool signal_handler_install_failed;\n-  SignalHandler::signal_handler_type old_signal_handler;\n\u002B  if (SIGINT == signum) {\n\u002B    return old_sigint_handler_;\n\u002B  } else if (SIGTERM == signum) {\n\u002B    return old_sigterm_handler_;\n\u002B  }\n #if defined(RCLCPP_HAS_SIGACTION)\n-  ssize_t ret = sigaction(signal_value, \u0026signal_handler, \u0026old_signal_handler);\n-  signal_handler_install_failed = (ret == -1);\n\u002B  SignalHandler::signal_handler_type ret;\n\u002B  memset(\u0026ret, 0, sizeof(ret));\n\u002B  sigemptyset(\u0026ret.sa_mask);\n\u002B  ret.sa_handler = SIG_DFL;\n\u002B  return ret;\n #else\n-  old_signal_handler = std::signal(signal_value, signal_handler);\n-  signal_handler_install_failed = (old_signal_handler == SIG_ERR);\n\u002B  return SIG_DFL;\n #endif\n-  if (signal_handler_install_failed) {\n-    char error_string[1024];\n-    rcutils_strerror(error_string, sizeof(error_string));\n-    auto msg =\n-      \u0022Failed to set SIGINT signal handler (\u0022 \u002B std::to_string(errno) \u002B \u0022): \u0022 \u002B error_string;\n-    throw std::runtime_error(msg);\n-  }\n-\n-  return old_signal_handler;\n }\n \n void\n SignalHandler::signal_handler_common()\n {\n-  signal_received_.store(true);\n\u002B  auto \u0026 instance = SignalHandler::get_global_signal_handler();\n\u002B  instance.signal_received_.store(true);\n   RCLCPP_DEBUG(\n     get_logger(),\n-    \u0022signal_handler(): SIGINT received, notifying deferred signal handler\u0022);\n-  notify_signal_handler();\n\u002B    \u0022signal_handler(): notifying deferred signal handler\u0022);\n\u002B  instance.notify_signal_handler();\n }\n \n-#if defined(RCLCPP_HAS_SIGACTION)\n-void\n-SignalHandler::signal_handler(int signal_value, siginfo_t * siginfo, void * context)\n-{\n-  RCLCPP_INFO(get_logger(), \u0022signal_handler(signal_value=%d)\u0022, signal_value);\n-\n-  if (old_signal_handler_.sa_flags \u0026 SA_SIGINFO) {\n-    if (old_signal_handler_.sa_sigaction != NULL) {\n-      old_signal_handler_.sa_sigaction(signal_value, siginfo, context);\n-    }\n-  } else {\n-    if (\n-      old_signal_handler_.sa_handler != NULL \u0026\u0026  // Is set\n-      old_signal_handler_.sa_handler != SIG_DFL \u0026\u0026  // Is not default\n-      old_signal_handler_.sa_handler != SIG_IGN)  // Is not ignored\n-    {\n-      old_signal_handler_.sa_handler(signal_value);\n-    }\n-  }\n-\n-  signal_handler_common();\n-}\n-#else\n-void\n-SignalHandler::signal_handler(int signal_value)\n-{\n-  RCLCPP_INFO(get_logger(), \u0022signal_handler(signal_value=%d)\u0022, signal_value);\n-\n-  if (old_signal_handler_) {\n-    old_signal_handler_(signal_value);\n-  }\n-\n-  signal_handler_common();\n-}\n-#endif\n-\n void\n SignalHandler::deferred_signal_handler()\n {\n   while (true) {\n     if (signal_received_.exchange(false)) {\n-      RCLCPP_DEBUG(get_logger(), \u0022deferred_signal_handler(): SIGINT received, shutting down\u0022);\n\u002B      RCLCPP_DEBUG(get_logger(), \u0022deferred_signal_handler(): shutting down\u0022);\n       for (auto context_ptr : rclcpp::get_contexts()) {\n-        if (context_ptr-\u003Eget_init_options().shutdown_on_sigint) {\n\u002B        if (context_ptr-\u003Eget_init_options().shutdown_on_signal) {\n           RCLCPP_DEBUG(\n             get_logger(),\n             \u0022deferred_signal_handler(): \u0022\n-            \u0022shutting down rclcpp::Context @ %p, because it had shutdown_on_sigint == true\u0022,\n\u002B            \u0022shutting down rclcpp::Context @ %p, because it had shutdown_on_signal == true\u0022,\n             static_cast\u003Cvoid *\u003E(context_ptr.get()));\n           context_ptr-\u003Eshutdown(\u0022signal handler\u0022);\n         }\n@@ -252,9 \u002B274,11 @@ SignalHandler::deferred_signal_handler()\n       RCLCPP_DEBUG(get_logger(), \u0022deferred_signal_handler(): signal handling uninstalled\u0022);\n       break;\n     }\n-    RCLCPP_DEBUG(get_logger(), \u0022deferred_signal_handler(): waiting for SIGINT or uninstall\u0022);\n\u002B    RCLCPP_DEBUG(\n\u002B      get_logger(), \u0022deferred_signal_handler(): waiting for SIGINT/SIGTERM or uninstall\u0022);\n     wait_for_signal();\n-    RCLCPP_DEBUG(get_logger(), \u0022deferred_signal_handler(): woken up due to SIGINT or uninstall\u0022);\n\u002B    RCLCPP_DEBUG(\n\u002B      get_logger(), \u0022deferred_signal_handler(): woken up due to SIGINT/SIGTERM or uninstall\u0022);\n   }\n }\n \n@@ -356,3 \u002B380,9 @@ SignalHandler::notify_signal_handler() noexcept\n   }\n #endif\n }\n\u002B\n\u002Brclcpp::SignalHandlerOptions\n\u002BSignalHandler::get_current_signal_handler_options()\n\u002B{\n\u002B  return signal_handlers_options_;\n\u002B}\ndiff --git rclcpp/src/rclcpp/signal_handler.hpp rclcpp/src/rclcpp/signal_handler.hpp\nindex 81cb6e18..0d3c399c 100644\n--- rclcpp/src/rclcpp/signal_handler.hpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/signal_handler.hpp\n@@ -21,6 \u002B21,7 @@\n #include \u003Cthread\u003E\n \n #include \u0022rclcpp/logging.hpp\u0022\n\u002B#include \u0022rclcpp/utilities.hpp\u0022\n \n // includes for semaphore notification code\n #if defined(_WIN32)\n@@ -39,14 \u002B40,14 @@\n namespace rclcpp\n {\n \n-/// Responsible for manaaging the SIGINT signal handling.\n\u002B/// Responsible for managing the SIGINT/SIGTERM signal handling.\n /**\n  * This class is responsible for:\n  *\n- * - installing the signal handler for SIGINT\n- * - uninstalling the signal handler for SIGINT\n- * - creating a thread to execute \u0022on sigint\u0022 work outside of the signal handler\n- * - safely notifying the dedicated signal handling thread when receiving SIGINT\n\u002B * - installing the signal handler for SIGINT/SIGTERM\n\u002B * - uninstalling the signal handler for SIGINT/SIGTERM\n\u002B * - creating a thread to execute \u0022on signal\u0022 work outside of the signal handler\n\u002B * - safely notifying the dedicated signal handling thread when receiving SIGINT/SIGTERM\n  * - implementation of all of the signal handling work, like shutting down contexts\n  *\n  * \\internal\n@@ -64,15 \u002B65,18 @@ public:\n   rclcpp::Logger \u0026\n   get_logger();\n \n-  /// Install the signal handler for SIGINT and start the dedicated signal handling thread.\n\u002B  /// Install the signal handler for SIGINT/SIGTERM and start the dedicated signal handling thread.\n   /**\n-   * Also stores the current signal handler to be called on SIGINT and to\n\u002B   * Also stores the current signal handler to be called on signal and to\n    * restore when uninstalling this signal handler.\n\u002B   *\n\u002B   * \\param signal_handler_options option to indicate which signal handlers should be installed.\n    */\n   bool\n-  install();\n\u002B  install(SignalHandlerOptions signal_handler_options = SignalHandlerOptions::All);\n \n-  /// Uninstall the signal handler for SIGINT and join the dedicated singal handling thread.\n\u002B  /// Uninstall the signal handler for SIGINT/SIGTERM and join the dedicated singal handling\n\u002B  /// thread.\n   /**\n    * Also restores the previous signal handler.\n    */\n@@ -83,26 \u002B87,34 @@ public:\n   bool\n   is_installed();\n \n-private:\n-  SignalHandler() = default;\n-\n-  ~SignalHandler();\n\u002B  /// Get the current signal handler options.\n\u002B  /**\n\u002B   * If no signal handler is installed, SignalHandlerOptions::None is returned.\n\u002B   */\n\u002B  rclcpp::SignalHandlerOptions\n\u002B  get_current_signal_handler_options();\n \n\u002Bprivate:\n\u002B  /// Signal handler type, platform dependent.\n #if defined(RCLCPP_HAS_SIGACTION)\n   using signal_handler_type = struct sigaction;\n #else\n   using signal_handler_type = void (*)(int);\n #endif\n-  // POSIX signal handler structure storage for the existing signal handler.\n-  static SignalHandler::signal_handler_type old_signal_handler_;\n \n-  /// Set the signal handler function.\n-  static\n-  SignalHandler::signal_handler_type\n-  set_signal_handler(int signal_value, const SignalHandler::signal_handler_type \u0026 signal_handler);\n\u002B\n\u002B  SignalHandler() = default;\n\u002B\n\u002B  ~SignalHandler();\n\u002B\n\u002B  SignalHandler(const SignalHandler \u0026) = delete;\n\u002B  SignalHandler(SignalHandler \u0026\u0026) = delete;\n\u002B  SignalHandler \u0026\n\u002B  operator=(const SignalHandler \u0026) = delete;\n\u002B  SignalHandler \u0026\u0026\n\u002B  operator=(SignalHandler \u0026\u0026) = delete;\n \n   /// Common signal handler code between sigaction and non-sigaction versions.\n-  static\n   void\n   signal_handler_common();\n \n@@ -127,7 \u002B139,6 @@ private:\n    * This must be called before wait_for_signal() or notify_signal_handler().\n    * This is not thread-safe.\n    */\n-  static\n   void\n   setup_wait_for_signal();\n \n@@ -137,7 \u002B148,6 @@ private:\n    *\n    * This is not thread-safe.\n    */\n-  static\n   void\n   teardown_wait_for_signal() noexcept;\n \n@@ -147,7 \u002B157,6 @@ private:\n    *\n    * This is not thread-safe.\n    */\n-  static\n   void\n   wait_for_signal();\n \n@@ -158,29 \u002B167,45 @@ private:\n    *\n    * This is thread-safe.\n    */\n-  static\n   void\n   notify_signal_handler() noexcept;\n \n\u002B  static\n\u002B  signal_handler_type\n\u002B  set_signal_handler(\n\u002B    int signal_value,\n\u002B    const signal_handler_type \u0026 signal_handler);\n\u002B\n\u002B  signal_handler_type\n\u002B  get_old_signal_handler(int signum);\n\u002B\n\u002B  rclcpp::SignalHandlerOptions signal_handlers_options_ = rclcpp::SignalHandlerOptions::None;\n\u002B\n\u002B  signal_handler_type old_sigint_handler_;\n\u002B  signal_handler_type old_sigterm_handler_;\n\u002B\n\u002B  // logger instance\n\u002B  rclcpp::Logger logger_ = rclcpp::get_logger(\u0022rclcpp\u0022);\n\u002B\n   // Whether or not a signal has been received.\n-  static std::atomic_bool signal_received_;\n\u002B  std::atomic_bool signal_received_ = false;\n   // A thread to which singal handling tasks are deferred.\n   std::thread signal_handler_thread_;\n \n   // A mutex used to synchronize the install() and uninstall() methods.\n   std::mutex install_mutex_;\n   // Whether or not the signal handler has been installed.\n-  std::atomic_bool installed_{false};\n\u002B  std::atomic_bool installed_ = false;\n \n   // Whether or not the semaphore for wait_for_signal is setup.\n-  static std::atomic_bool wait_for_signal_is_setup_;\n\u002B  std::atomic_bool wait_for_signal_is_setup_;\n   // Storage for the wait_for_signal semaphore.\n #if defined(_WIN32)\n-  static HANDLE signal_handler_sem_;\n\u002B  HANDLE signal_handler_sem_;\n #elif defined(__APPLE__)\n-  static dispatch_semaphore_t signal_handler_sem_;\n\u002B  dispatch_semaphore_t signal_handler_sem_;\n #else  // posix\n-  static sem_t signal_handler_sem_;\n\u002B  sem_t signal_handler_sem_;\n #endif\n };\n \ndiff --git rclcpp/src/rclcpp/utilities.cpp rclcpp/src/rclcpp/utilities.cpp\nindex c3e3915d..dcc79c96 100644\n--- rclcpp/src/rclcpp/utilities.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/utilities.cpp\n@@ -31,18 \u002B31,22 @@ namespace rclcpp\n {\n \n void\n-init(int argc, char const * const argv[], const InitOptions \u0026 init_options)\n\u002Binit(\n\u002B  int argc,\n\u002B  char const * const argv[],\n\u002B  const InitOptions \u0026 init_options,\n\u002B  SignalHandlerOptions signal_handler_options)\n {\n   using rclcpp::contexts::get_global_default_context;\n   get_global_default_context()-\u003Einit(argc, argv, init_options);\n   // Install the signal handlers.\n-  install_signal_handlers();\n\u002B  install_signal_handlers(signal_handler_options);\n }\n \n bool\n-install_signal_handlers()\n\u002Binstall_signal_handlers(SignalHandlerOptions signal_handler_options)\n {\n-  return SignalHandler::get_global_signal_handler().install();\n\u002B  return SignalHandler::get_global_signal_handler().install(signal_handler_options);\n }\n \n bool\n@@ -51,6 \u002B55,13 @@ signal_handlers_installed()\n   return SignalHandler::get_global_signal_handler().is_installed();\n }\n \n\u002BSignalHandlerOptions\n\u002Bget_current_signal_handler_options()\n\u002B{\n\u002B  return SignalHandler::get_global_signal_handler().get_current_signal_handler_options();\n\u002B}\n\u002B\n\u002B\n bool\n uninstall_signal_handlers()\n {\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "a1dabe32f5d6027963df50a6c089ae0f0103605c",
    "RawMessage": "Bump test coverage. (#764)",
    "Changes": "diff --git rcl/src/rcl/arguments.c rcl/src/rcl/arguments.c\nindex cdfc5b4..74c5cc7 100644\n--- rcl/src/rcl/arguments.c\n\u002B\u002B\u002B rcl/src/rcl/arguments.c\n@@ -807,6 \u002B807,9 @@ rcl_arguments_copy(\n   const rcl_arguments_t * args,\n   rcl_arguments_t * args_out)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B\n   RCL_CHECK_ARGUMENT_FOR_NULL(args, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(args-\u003Eimpl, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(args_out, RCL_RET_INVALID_ARGUMENT);\ndiff --git rcl/src/rcl/domain_id.c rcl/src/rcl/domain_id.c\nindex 07f5869..6435e66 100644\n--- rcl/src/rcl/domain_id.c\n\u002B\u002B\u002B rcl/src/rcl/domain_id.c\n@@ -27,12 \u002B27,13 @@ const char * const RCL_DOMAIN_ID_ENV_VAR = \u0022ROS_DOMAIN_ID\u0022;\n rcl_ret_t\n rcl_get_default_domain_id(size_t * domain_id)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n   const char * ros_domain_id = NULL;\n   const char * get_env_error_str = NULL;\n \n-  if (!domain_id) {\n-    return RCL_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(domain_id, RCL_RET_INVALID_ARGUMENT);\n \n   get_env_error_str = rcutils_get_env(RCL_DOMAIN_ID_ENV_VAR, \u0026ros_domain_id);\n   if (NULL != get_env_error_str) {\ndiff --git rcl/src/rcl/expand_topic_name.c rcl/src/rcl/expand_topic_name.c\nindex ab06eb1..313949c 100644\n--- rcl/src/rcl/expand_topic_name.c\n\u002B\u002B\u002B rcl/src/rcl/expand_topic_name.c\n@@ -49,6 \u002B49,13 @@ rcl_expand_topic_name(\n   rcl_allocator_t allocator,\n   char ** output_topic_name)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_TOPIC_NAME_INVALID);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID_NAME);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID_NAMESPACE);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_UNKNOWN_SUBSTITUTION);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B\n   // check arguments that could be null\n   RCL_CHECK_ARGUMENT_FOR_NULL(input_topic_name, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(node_name, RCL_RET_INVALID_ARGUMENT);\ndiff --git rcl/src/rcl/init_options.c rcl/src/rcl/init_options.c\nindex 0c5f2a3..9f88b21 100644\n--- rcl/src/rcl/init_options.c\n\u002B\u002B\u002B rcl/src/rcl/init_options.c\n@@ -21,6 \u002B21,7 @@ extern \u0022C\u0022\n \n #include \u0022./common.h\u0022\n #include \u0022./init_options_impl.h\u0022\n\u002B#include \u0022rcutils/macros.h\u0022\n #include \u0022rcl/error_handling.h\u0022\n #include \u0022rmw/error_handling.h\u0022\n #include \u0022rcutils/logging_macros.h\u0022\n@@ -36,6 \u002B37,11 @@ rcl_get_zero_initialized_init_options(void)\n rcl_ret_t\n rcl_init_options_init(rcl_init_options_t * init_options, rcl_allocator_t allocator)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ALREADY_INIT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n   RCL_CHECK_ARGUMENT_FOR_NULL(init_options, RCL_RET_INVALID_ARGUMENT);\n   if (NULL != init_options-\u003Eimpl) {\n     RCL_SET_ERROR_MSG(\u0022given init_options (rcl_init_options_t) is already initialized\u0022);\n@@ -61,6 \u002B67,11 @@ rcl_init_options_init(rcl_init_options_t * init_options, rcl_allocator_t allocat\n rcl_ret_t\n rcl_init_options_copy(const rcl_init_options_t * src, rcl_init_options_t * dst)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ALREADY_INIT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n   RCL_CHECK_ARGUMENT_FOR_NULL(src, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(src-\u003Eimpl, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(dst, RCL_RET_INVALID_ARGUMENT);\ndiff --git rcl/src/rcl/localhost.c rcl/src/rcl/localhost.c\nindex 6cc0e18..7730b56 100644\n--- rcl/src/rcl/localhost.c\n\u002B\u002B\u002B rcl/src/rcl/localhost.c\n@@ -30,9 \u002B30,9 @@ rcl_get_localhost_only(rmw_localhost_only_t * localhost_only)\n   const char * ros_local_host_env_val = NULL;\n   const char * get_env_error_str = NULL;\n \n-  if (!localhost_only) {\n-    return RCL_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(localhost_only, RCL_RET_INVALID_ARGUMENT);\n \n   get_env_error_str = rcutils_get_env(RCL_LOCALHOST_ENV_VAR, \u0026ros_local_host_env_val);\n   if (NULL != get_env_error_str) {\ndiff --git rcl/src/rcl/node_options.c rcl/src/rcl/node_options.c\nindex 046464e..34408f1 100644\n--- rcl/src/rcl/node_options.c\n\u002B\u002B\u002B rcl/src/rcl/node_options.c\n@@ -17,6 \u002B17,8 @@ extern \u0022C\u0022\n {\n #endif\n \n\u002B#include \u0022rcutils/macros.h\u0022\n\u002B\n #include \u0022rcl/node_options.h\u0022\n \n #include \u0022rcl/arguments.h\u0022\n@@ -43,6 \u002B45,8 @@ rcl_node_options_copy(\n   const rcl_node_options_t * options,\n   rcl_node_options_t * options_out)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B\n   RCL_CHECK_ARGUMENT_FOR_NULL(options, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(options_out, RCL_RET_INVALID_ARGUMENT);\n   if (options_out == options) {\n@@ -58,8 \u002B62,7 @@ rcl_node_options_copy(\n   options_out-\u003Eenable_rosout = options-\u003Eenable_rosout;\n   options_out-\u003Erosout_qos = options-\u003Erosout_qos;\n   if (NULL != options-\u003Earguments.impl) {\n-    rcl_ret_t ret = rcl_arguments_copy(\u0026(options-\u003Earguments), \u0026(options_out-\u003Earguments));\n-    return ret;\n\u002B    return rcl_arguments_copy(\u0026(options-\u003Earguments), \u0026(options_out-\u003Earguments));\n   }\n   return RCL_RET_OK;\n }\ndiff --git rcl/src/rcl/remap.c rcl/src/rcl/remap.c\nindex 950ff97..d8af63f 100644\n--- rcl/src/rcl/remap.c\n\u002B\u002B\u002B rcl/src/rcl/remap.c\n@@ -19,6 \u002B19,7 @@\n #include \u0022rcl/error_handling.h\u0022\n #include \u0022rcl/expand_topic_name.h\u0022\n #include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/macros.h\u0022\n #include \u0022rcutils/strdup.h\u0022\n #include \u0022rcutils/types/string_map.h\u0022\n \n@@ -41,6 \u002B42,9 @@ rcl_remap_copy(\n   const rcl_remap_t * rule,\n   rcl_remap_t * rule_out)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B\n   RCL_CHECK_ARGUMENT_FOR_NULL(rule, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(rule_out, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(rule-\u003Eimpl, RCL_RET_INVALID_ARGUMENT);\n@@ -289,6 \u002B293,11 @@ rcl_remap_node_name(\n   rcl_allocator_t allocator,\n   char ** output_name)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID_NAME);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n   RCL_CHECK_ALLOCATOR_WITH_MSG(\u0026allocator, \u0022allocator is invalid\u0022, return RCL_RET_INVALID_ARGUMENT);\n   return _rcl_remap_name(\n     local_arguments, global_arguments, RCL_NODENAME_REMAP, NULL, node_name, NULL, NULL,\n@@ -303,6 \u002B312,11 @@ rcl_remap_node_namespace(\n   rcl_allocator_t allocator,\n   char ** output_namespace)\n {\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_NODE_INVALID_NAMESPACE);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_BAD_ALLOC);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n   RCL_CHECK_ALLOCATOR_WITH_MSG(\u0026allocator, \u0022allocator is invalid\u0022, return RCL_RET_INVALID_ARGUMENT);\n   return _rcl_remap_name(\n     local_arguments, global_arguments, RCL_NAMESPACE_REMAP, NULL, node_name, NULL, NULL,\ndiff --git rcl/src/rcl/validate_enclave_name.c rcl/src/rcl/validate_enclave_name.c\nindex 0db544d..8cd421c 100644\n--- rcl/src/rcl/validate_enclave_name.c\n\u002B\u002B\u002B rcl/src/rcl/validate_enclave_name.c\n@@ -18,6 \u002B18,7 @@\n #include \u003Cstdio.h\u003E\n #include \u003Cstring.h\u003E\n \n\u002B#include \u003Crcutils/macros.h\u003E\n #include \u003Crcutils/snprintf.h\u003E\n \n #include \u0022rmw/validate_namespace.h\u0022\n@@ -32,9 \u002B33,7 @@ rcl_validate_enclave_name(\n   int * validation_result,\n   size_t * invalid_index)\n {\n-  if (!enclave) {\n-    return RCL_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(enclave, RCL_RET_INVALID_ARGUMENT);\n   return rcl_validate_enclave_name_with_size(\n     enclave, strlen(enclave), validation_result, invalid_index);\n }\n@@ -46,12 \u002B45,11 @@ rcl_validate_enclave_name_with_size(\n   int * validation_result,\n   size_t * invalid_index)\n {\n-  if (!enclave) {\n-    return RCL_RET_INVALID_ARGUMENT;\n-  }\n-  if (!validation_result) {\n-    return RCL_RET_INVALID_ARGUMENT;\n-  }\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CAN_SET_MSG_AND_RETURN_WITH_ERROR_OF(RCL_RET_ERROR);\n\u002B\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(enclave, RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(validation_result, RCL_RET_INVALID_ARGUMENT);\n \n   int tmp_validation_result;\n   size_t tmp_invalid_index;\ndiff --git rcl/test/CMakeLists.txt rcl/test/CMakeLists.txt\nindex 17d9c0a..404cdd1 100644\n--- rcl/test/CMakeLists.txt\n\u002B\u002B\u002B rcl/test/CMakeLists.txt\n@@ -75,7 \u002B75,7 @@ function(test_target_function)\n     SRCS rcl/test_context.cpp\n     ENV ${rmw_implementation_env_var} ${memory_tools_ld_preload_env_var}\n     APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-    LIBRARIES ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools\n\u002B    LIBRARIES ${PROJECT_NAME} mimick osrf_testing_tools_cpp::memory_tools\n     AMENT_DEPENDENCIES ${rmw_implementation}\n   )\n \n@@ -166,8 \u002B166,9 @@ function(test_target_function)\n     SRCS rcl/test_node.cpp\n     ENV ${rmw_implementation_env_var} ${memory_tools_ld_preload_env_var}\n     APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-    LIBRARIES ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools\n\u002B    LIBRARIES ${PROJECT_NAME} mimick osrf_testing_tools_cpp::memory_tools\n     AMENT_DEPENDENCIES ${rmw_implementation} \u0022osrf_testing_tools_cpp\u0022\n\u002B    TIMEOUT 240  # Large timeout to wait for fault injection tests\n   )\n \n   rcl_add_custom_gtest(test_arguments${target_suffix}\n@@ -201,7 \u002B202,7 @@ function(test_target_function)\n     SRCS rcl/test_guard_condition.cpp\n     ENV ${rmw_implementation_env_var} ${memory_tools_ld_preload_env_var}\n     APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-    LIBRARIES ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools\n\u002B    LIBRARIES ${PROJECT_NAME} mimick osrf_testing_tools_cpp::memory_tools\n     AMENT_DEPENDENCIES ${rmw_implementation} \u0022osrf_testing_tools_cpp\u0022\n   )\n \n@@ -392,7 \u002B393,7 @@ rcl_add_custom_gtest(test_expand_topic_name\n rcl_add_custom_gtest(test_security\n   SRCS rcl/test_security.cpp\n   APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-  LIBRARIES ${PROJECT_NAME}\n\u002B  LIBRARIES ${PROJECT_NAME} mimick\n   AMENT_DEPENDENCIES \u0022osrf_testing_tools_cpp\u0022\n )\n \ndiff --git rcl/test/rcl/test_context.cpp rcl/test/rcl/test_context.cpp\nindex 7489e4b..d923048 100644\n--- rcl/test/rcl/test_context.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_context.cpp\n@@ -20,6 \u002B20,10 @@\n #include \u0022rcl/error_handling.h\u0022\n #include \u0022rcl/init.h\u0022\n \n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n #ifdef RMW_IMPLEMENTATION\n # define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n # define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n@@ -170,6 \u002B174,10 @@ TEST_F(CLASSNAME(TestContextFixture, RMW_IMPLEMENTATION), bad_fini) {\n   ret = rcl_shutdown(\u0026context);\n   EXPECT_EQ(ret, RCL_RET_OK);\n \n-  ret = rcl_context_fini(\u0026context);\n-  EXPECT_EQ(ret, RCL_RET_OK);\n\u002B  {\n\u002B    auto mock = mocking_utils::inject_on_return(\n\u002B      \u0022lib:rcl\u0022, rmw_context_fini, RMW_RET_ERROR);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, rcl_context_fini(\u0026context));\n\u002B    rcl_reset_error();\n\u002B  }\n }\ndiff --git rcl/test/rcl/test_guard_condition.cpp rcl/test/rcl/test_guard_condition.cpp\nindex b34e68d..48d4ede 100644\n--- rcl/test/rcl/test_guard_condition.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_guard_condition.cpp\n@@ -24,6 \u002B24,10 @@\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n #include \u0022rcl/error_handling.h\u0022\n \n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n #ifdef RMW_IMPLEMENTATION\n # define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n # define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n@@ -188,6 \u002B192,14 @@ TEST_F(\n   ASSERT_EQ(RCL_RET_BAD_ALLOC, ret) \u003C\u003C \u0022Expected RCL_RET_BAD_ALLOC\u0022;\n   ASSERT_TRUE(rcl_error_is_set());\n   rcl_reset_error();\n\u002B  // Try init but force an internal error.\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_to_fail(\n\u002B      \u0022lib:rcl\u0022, rmw_create_guard_condition, \u0022internal error\u0022, nullptr);\n\u002B    ret = rcl_guard_condition_init(\u0026guard_condition, \u0026context, default_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n \n   // Try fini with invalid arguments.\n   ret = rcl_guard_condition_fini(nullptr);\n@@ -202,6 \u002B214,18 @@ TEST_F(\n   EXPECT_EQ(RCL_RET_OK, ret);\n   ret = rcl_guard_condition_fini(\u0026guard_condition);\n   EXPECT_EQ(RCL_RET_OK, ret);\n\u002B  // Try normal init and fini, but force an internal error on first try.\n\u002B  {\n\u002B    auto mock = mocking_utils::inject_on_return(\n\u002B      \u0022lib:rcl\u0022, rmw_destroy_guard_condition, RMW_RET_ERROR);\n\u002B    ret = rcl_guard_condition_init(\u0026guard_condition, \u0026context, default_options);\n\u002B    EXPECT_EQ(RCL_RET_OK, ret);\n\u002B    ret = rcl_guard_condition_fini(\u0026guard_condition);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  ret = rcl_guard_condition_fini(\u0026guard_condition);\n\u002B  EXPECT_EQ(RCL_RET_OK, ret);\n   // Try repeated init and fini calls.\n   ret = rcl_guard_condition_init(\u0026guard_condition, \u0026context, default_options);\n   EXPECT_EQ(RCL_RET_OK, ret);\ndiff --git rcl/test/rcl/test_init.cpp rcl/test/rcl/test_init.cpp\nindex 1586e32..eb6ffd5 100644\n--- rcl/test/rcl/test_init.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_init.cpp\n@@ -23,6 \u002B23,9 @@\n #include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/format_string.h\u0022\n #include \u0022rcutils/snprintf.h\u0022\n\u002B#include \u0022rcutils/testing/fault_injection.h\u0022\n\u002B\n\u002B#include \u0022rmw/rmw.h\u0022\n \n #include \u0022./allocator_testing_utils.h\u0022\n #include \u0022../mocking_utils/patch.hpp\u0022\n@@ -316,6 \u002B319,76 @@ TEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_and_shutdown\n   context = rcl_get_zero_initialized_context();\n }\n \n\u002B/* Tests rcl_init() deals with internal errors correctly.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_init_internal_error) {\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_ret_t ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  FakeTestArgv test_args;\n\u002B  rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_to_fail(\n\u002B      \u0022lib:rcl\u0022, rmw_init, \u0022internal error\u0022, RMW_RET_ERROR);\n\u002B    ret = rcl_init(test_args.argc, test_args.argv, \u0026init_options, \u0026context);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    EXPECT_TRUE(rcl_error_is_set());\n\u002B    rcl_reset_error();\n\u002B    EXPECT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B  }\n\u002B\n\u002B  RCUTILS_FAULT_INJECTION_TEST(\n\u002B  {\n\u002B    ret = rcl_init(test_args.argc, test_args.argv, \u0026init_options, \u0026context);\n\u002B\n\u002B    int64_t count = rcutils_fault_injection_get_count();\n\u002B    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n\u002B\n\u002B    if (RCL_RET_OK == ret) {\n\u002B      ASSERT_TRUE(rcl_context_is_valid(\u0026context));\n\u002B      EXPECT_EQ(RCL_RET_OK, rcl_shutdown(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B      EXPECT_EQ(RCL_RET_OK, rcl_context_fini(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B    } else {\n\u002B      ASSERT_FALSE(rcl_context_is_valid(\u0026context));\n\u002B      rcl_reset_error();\n\u002B    }\n\u002B\n\u002B    rcutils_fault_injection_set_count(count);\n\u002B  });\n\u002B}\n\u002B\n\u002B/* Tests rcl_shutdown() deals with internal errors correctly.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_shutdown_internal_error) {\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_ret_t ret = rcl_init_options_init(\u0026init_options, rcl_get_default_allocator());\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B\n\u002B  ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B  EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_shutdown(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_context_fini(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  EXPECT_TRUE(rcl_context_is_valid(\u0026context));\n\u002B\n\u002B  auto mock = mocking_utils::patch_to_fail(\n\u002B    \u0022lib:rcl\u0022, rmw_shutdown, \u0022internal error\u0022, RMW_RET_ERROR);\n\u002B  EXPECT_EQ(RCL_RET_ERROR, rcl_shutdown(\u0026context));\n\u002B  rcl_reset_error();\n\u002B}\n\u002B\n /* Tests the rcl_get_instance_id() function.\n  */\n TEST_F(CLASSNAME(TestRCLFixture, RMW_IMPLEMENTATION), test_rcl_get_instance_id) {\ndiff --git rcl/test/rcl/test_node.cpp rcl/test/rcl/test_node.cpp\nindex 7976d7f..2d20306 100644\n--- rcl/test/rcl/test_node.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_node.cpp\n@@ -21,13 \u002B21,19 @@\n #include \u0022rcl/rcl.h\u0022\n #include \u0022rcl/node.h\u0022\n #include \u0022rmw/rmw.h\u0022  // For rmw_get_implementation_identifier.\n\u002B#include \u0022rmw/validate_namespace.h\u0022\n\u002B#include \u0022rmw/validate_node_name.h\u0022\n \n #include \u0022./failing_allocator_functions.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/memory_tools/memory_tools.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n\u002B#include \u0022rcutils/testing/fault_injection.h\u0022\n #include \u0022rcl/error_handling.h\u0022\n\u002B#include \u0022rcl/logging.h\u0022\n #include \u0022rcl/logging_rosout.h\u0022\n \n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n #ifdef RMW_IMPLEMENTATION\n # define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n # define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n@@ -393,24 \u002B399,6 @@ TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_life_cycle)\n   EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret);\n   ASSERT_TRUE(rcl_error_is_set());\n   rcl_reset_error();\n-  // Try with invalid allocator.\n-  rcl_node_options_t options_with_invalid_allocator = rcl_node_get_default_options();\n-  options_with_invalid_allocator.allocator.allocate = nullptr;\n-  options_with_invalid_allocator.allocator.deallocate = nullptr;\n-  options_with_invalid_allocator.allocator.reallocate = nullptr;\n-  ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options_with_invalid_allocator);\n-  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret) \u003C\u003C \u0022Expected RCL_RET_INVALID_ARGUMENT\u0022;\n-  ASSERT_TRUE(rcl_error_is_set());\n-  rcl_reset_error();\n-  // Try with failing allocator.\n-  rcl_node_options_t options_with_failing_allocator = rcl_node_get_default_options();\n-  options_with_failing_allocator.allocator.allocate = failing_malloc;\n-  options_with_failing_allocator.allocator.reallocate = failing_realloc;\n-  ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options_with_failing_allocator);\n-  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret) \u003C\u003C \u0022Expected RCL_RET_BAD_ALLOC\u0022;\n-  ASSERT_TRUE(rcl_error_is_set());\n-  rcl_reset_error();\n-\n   // Try fini with invalid arguments.\n   ret = rcl_node_fini(nullptr);\n   EXPECT_EQ(RCL_RET_NODE_INVALID, ret) \u003C\u003C \u0022Expected RCL_RET_NODE_INVALID\u0022;\n@@ -437,6 \u002B425,121 @@ TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_life_cycle)\n   EXPECT_EQ(RCL_RET_OK, ret);\n }\n \n\u002BTEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_init_with_internal_errors) {\n\u002B  rcl_ret_t ret;\n\u002B  rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B  rcl_node_t node = rcl_get_zero_initialized_node();\n\u002B  const char * name = \u0022test_rcl_node_init_with_internal_errors\u0022;\n\u002B  const char * namespace_ = \u0022ns\u0022;  // force non-absolute namespace handling\n\u002B  rcl_node_options_t options = rcl_node_get_default_options();\n\u002B  options.enable_rosout = true;  // enable logging to cover more ground\n\u002B  // Initialize rcl with rcl_init().\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_allocator_t allocator = rcl_get_default_allocator();\n\u002B  ret = rcl_init_options_init(\u0026init_options, allocator);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_init_options_fini(\u0026init_options)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  ret = rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_shutdown(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_context_fini(\u0026context)) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  // Initialize logging and rosout.\n\u002B  ret = rcl_logging_configure(\u0026context.global_arguments, \u0026allocator);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_logging_fini()) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  ret = rcl_logging_rosout_init(\u0026allocator);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_logging_rosout_fini()) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B  // Try with invalid allocator.\n\u002B  rcl_node_options_t options_with_invalid_allocator = rcl_node_get_default_options();\n\u002B  options_with_invalid_allocator.allocator.allocate = nullptr;\n\u002B  options_with_invalid_allocator.allocator.deallocate = nullptr;\n\u002B  options_with_invalid_allocator.allocator.reallocate = nullptr;\n\u002B  ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options_with_invalid_allocator);\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, ret) \u003C\u003C \u0022Expected RCL_RET_INVALID_ARGUMENT\u0022;\n\u002B  ASSERT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B  // Try with failing allocator.\n\u002B  rcl_node_options_t options_with_failing_allocator = rcl_node_get_default_options();\n\u002B  options_with_failing_allocator.allocator.allocate = failing_malloc;\n\u002B  options_with_failing_allocator.allocator.reallocate = failing_realloc;\n\u002B  ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options_with_failing_allocator);\n\u002B  EXPECT_EQ(RCL_RET_BAD_ALLOC, ret) \u003C\u003C \u0022Expected RCL_RET_BAD_ALLOC\u0022;\n\u002B  ASSERT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B  // Try init but force internal errors.\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\u0022lib:rcl\u0022, rmw_create_node, nullptr);\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rmw_node_get_graph_guard_condition, nullptr);\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_node_name, RMW_RET_ERROR);\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_namespace, RMW_RET_ERROR);\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  // Try normal init but force an internal error on fini.\n\u002B  {\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B    EXPECT_EQ(RCL_RET_OK, ret);\n\u002B    auto mock = mocking_utils::inject_on_return(\u0022lib:rcl\u0022, rmw_destroy_node, RMW_RET_ERROR);\n\u002B    ret = rcl_node_fini(\u0026node);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  // Battle test node init.\n\u002B  RCUTILS_FAULT_INJECTION_TEST(\n\u002B  {\n\u002B    ret = rcl_node_init(\u0026node, name, namespace_, \u0026context, \u0026options);\n\u002B\n\u002B    int64_t count = rcutils_fault_injection_get_count();\n\u002B    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);\n\u002B\n\u002B    if (RCL_RET_OK == ret) {\n\u002B      ASSERT_TRUE(rcl_node_is_valid(\u0026node));\n\u002B      EXPECT_EQ(RCL_RET_OK, rcl_node_fini(\u0026node)) \u003C\u003C rcl_get_error_string().str;\n\u002B    } else {\n\u002B      ASSERT_FALSE(rcl_node_is_valid(\u0026node));\n\u002B      rcl_reset_error();\n\u002B    }\n\u002B\n\u002B    rcutils_fault_injection_set_count(count);\n\u002B  });\n\u002B}\n\u002B\n /* Tests the node name restrictions enforcement.\n  */\n TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_name_restrictions) {\ndiff --git rcl/test/rcl/test_security.cpp rcl/test/rcl/test_security.cpp\nindex 9fbf28d..cea6b00 100644\n--- rcl/test/rcl/test_security.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_security.cpp\n@@ -16,17 \u002B16,22 @@\n \n #include \u003Calgorithm\u003E\n #include \u003Ccstring\u003E\n\u002B#include \u003Cmap\u003E\n #include \u003Cstring\u003E\n \n #include \u0022rcl/security.h\u0022\n #include \u0022rcl/error_handling.h\u0022\n \n #include \u0022rcutils/filesystem.h\u0022\n\u002B#include \u0022rcutils/get_env.h\u0022\n \n #include \u0022rmw/error_handling.h\u0022\n\u002B#include \u0022rmw/rmw.h\u0022\n \n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n \n\u002B#include \u0022./allocator_testing_utils.h\u0022\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n \n #define TEST_SECURITY_DIRECTORY_RESOURCES_DIR_NAME \u0022/test_security_directory\u0022\n #define TEST_ENCLAVE \u0022dummy_enclave\u0022\n@@ -253,3 \u002B258,148 @@ TEST_F(TestGetSecureRoot, test_get_security_options) {\n     PATH_SEPARATOR \u0022enclaves\u0022 PATH_SEPARATOR TEST_ENCLAVE,\n     options.security_root_path);\n }\n\u002B\n\u002BTEST_F(TestGetSecureRoot, test_rcl_security_enabled) {\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_security_enabled(nullptr));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  {\n\u002B    bool use_security;\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rcutils_get_env, \u0022internal error\u0022);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, rcl_security_enabled(\u0026use_security));\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    bool use_security = false;\n\u002B    putenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME \u0022=true\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_security_enabled(\u0026use_security));\n\u002B    EXPECT_TRUE(use_security);\n\u002B    unsetenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    bool use_security = true;\n\u002B    putenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME \u0022=false\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_security_enabled(\u0026use_security));\n\u002B    EXPECT_FALSE(use_security);\n\u002B    unsetenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    bool use_security = true;\n\u002B    putenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME \u0022=foo\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_security_enabled(\u0026use_security));\n\u002B    EXPECT_FALSE(use_security);\n\u002B    unsetenv_wrapper(ROS_SECURITY_ENABLE_VAR_NAME);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    bool use_security = true;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_security_enabled(\u0026use_security));\n\u002B    EXPECT_FALSE(use_security);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestGetSecureRoot, test_rcl_get_enforcement_policy) {\n\u002B  EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_get_enforcement_policy(nullptr));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  {\n\u002B    rmw_security_enforcement_policy_t policy;\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rcutils_get_env, \u0022internal error\u0022);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, rcl_get_enforcement_policy(\u0026policy));\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    rmw_security_enforcement_policy_t policy = RMW_SECURITY_ENFORCEMENT_PERMISSIVE;\n\u002B    putenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME \u0022=Enforce\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_enforcement_policy(\u0026policy));\n\u002B    EXPECT_EQ(RMW_SECURITY_ENFORCEMENT_ENFORCE, policy);\n\u002B    unsetenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    rmw_security_enforcement_policy_t policy = RMW_SECURITY_ENFORCEMENT_ENFORCE;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_enforcement_policy(\u0026policy));\n\u002B    EXPECT_EQ(RMW_SECURITY_ENFORCEMENT_PERMISSIVE, policy);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    rmw_security_enforcement_policy_t policy = RMW_SECURITY_ENFORCEMENT_ENFORCE;\n\u002B    putenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME \u0022=foo\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_enforcement_policy(\u0026policy));\n\u002B    EXPECT_EQ(RMW_SECURITY_ENFORCEMENT_PERMISSIVE, policy);\n\u002B    unsetenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    rmw_security_enforcement_policy_t policy = RMW_SECURITY_ENFORCEMENT_ENFORCE;\n\u002B    putenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME \u0022=ENFORCE\u0022);\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_enforcement_policy(\u0026policy));\n\u002B    EXPECT_EQ(RMW_SECURITY_ENFORCEMENT_PERMISSIVE, policy);\n\u002B    unsetenv_wrapper(ROS_SECURITY_STRATEGY_VAR_NAME);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestGetSecureRoot, test_rcl_get_secure_root_with_bad_arguments) {\n\u002B  rcl_allocator_t allocator = rcl_get_default_allocator();\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(nullptr, \u0026allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, nullptr));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rcl_allocator_t invalid_allocator = rcutils_get_zero_initialized_allocator();\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, \u0026invalid_allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(TestGetSecureRoot, test_rcl_get_secure_root_with_internal_errors) {\n\u002B  rcl_allocator_t allocator = rcl_get_default_allocator();\n\u002B  rcl_allocator_t failing_allocator = get_time_bombed_allocator();\n\u002B\n\u002B  std::map\u003Cstd::string, std::string\u003E env;\n\u002B  auto mock = mocking_utils::patch(\n\u002B    \u0022lib:rcl\u0022, rcutils_get_env,\n\u002B    [\u0026](const char * name, const char ** value) -\u003E const char * {\n\u002B      if (env.count(name) == 0) {\n\u002B        return \u0022internal error\u0022;\n\u002B      }\n\u002B      *value = env[name].c_str();\n\u002B      return nullptr;\n\u002B    });\n\u002B\n\u002B  // fail to get ROS_SECURITY_KEYSTORE_VAR_NAME from environment\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, \u0026allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B\n\u002B  env[ROS_SECURITY_KEYSTORE_VAR_NAME] =\n\u002B    TEST_RESOURCES_DIRECTORY TEST_SECURITY_DIRECTORY_RESOURCES_DIR_NAME;\n\u002B\n\u002B  // fail to copy ROS_SECURITY_KEYSTORE_VAR_NAME value\n\u002B  set_time_bombed_allocator_count(failing_allocator, 0);\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, \u0026failing_allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B\n\u002B  // fail to get ROS_SECURITY_ENCLAVE_OVERRIDE from environment\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, \u0026allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B\n\u002B  env[ROS_SECURITY_ENCLAVE_OVERRIDE] = TEST_ENCLAVE_ABSOLUTE;\n\u002B\n\u002B  // fail to copy ROS_SECURITY_ENCLAVE_OVERRIDE value\n\u002B  set_time_bombed_allocator_count(failing_allocator, 1);\n\u002B  EXPECT_EQ(nullptr, rcl_get_secure_root(\u0022test\u0022, \u0026failing_allocator));\n\u002B  EXPECT_TRUE(rcl_error_is_set());\n\u002B  rcl_reset_error();\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true,
    "Analysis": {
      "ChatGPTResponse": "no",
      "PredictsBackported": false,
      "Compressed": false
    }
  },
  {
    "Repository": "rclcpp",
    "SHA": "34cc960124af07be717b77e0c6781ef57308aebe",
    "RawMessage": "Cleanup of https://github.com/ros2/rclcpp/pull/2683 (#2714)",
    "Changes": "diff --git rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp\nindex 0b37c0da..41f6de6b 100644\n--- rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp\n@@ -42,7 \u002B42,9 @@ public:\n    *   of this waitable has signaled the wait_set.\n    */\n   RCLCPP_PUBLIC\n-  explicit ExecutorNotifyWaitable(std::function\u003Cvoid(void)\u003E on_execute_callback = {});\n\u002B  explicit ExecutorNotifyWaitable(\n\u002B    std::function\u003Cvoid(void)\u003E on_execute_callback = {}, const rclcpp::Context::SharedPtr \u0026 context =\n\u002B    rclcpp::contexts::get_global_default_context());\n \n   // Destructor\n   RCLCPP_PUBLIC\n@@ -167,8 \u002B169,17 @@ private:\n   std::function\u003Cvoid(size_t)\u003E on_ready_callback_;\n \n   /// The collection of guard conditions to be waited on.\n-  std::set\u003Crclcpp::GuardCondition::WeakPtr,\n-    std::owner_less\u003Crclcpp::GuardCondition::WeakPtr\u003E\u003E notify_guard_conditions_;\n\u002B  std::set\u003Crclcpp::GuardCondition::SharedPtr\u003E notify_guard_conditions_;\n\u002B\n\u002B  /// The indixes were our guard conditions were stored in the\n\u002B  /// rcl waitset\n\u002B  std::vector\u003Csize_t\u003E idxs_of_added_guard_condition_;\n\u002B\n\u002B  /// set to true, if we got a pending trigger\n\u002B  bool needs_processing = false;\n\u002B\n\u002B  /// A guard condition needed to generate wakeups\n\u002B  rclcpp::GuardCondition::SharedPtr guard_condition_;\n };\n \n }  // namespace executors\ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex e551b4aa..e7b79959 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -66,7 \u002B66,7 @@ Executor::Executor(const rclcpp::ExecutorOptions \u0026 options)\n   notify_waitable_(std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(\n       [this]() {\n         this-\u003Eentities_need_rebuild_.store(true);\n-      })),\n\u002B      }, options.context)),\n   entities_need_rebuild_(true),\n   collector_(notify_waitable_),\n   wait_set_({}, {}, {}, {}, {}, {}, options.context),\n@@ -84,7 \u002B84,9 @@ Executor::Executor(const rclcpp::ExecutorOptions \u0026 options)\n   notify_waitable_-\u003Eadd_guard_condition(interrupt_guard_condition_);\n   notify_waitable_-\u003Eadd_guard_condition(shutdown_guard_condition_);\n \n-  wait_set_.add_waitable(notify_waitable_);\n\u002B  // we need to initially rebuild the collection,\n\u002B  // so that the notify_waitable_ is added\n\u002B  collect_entities();\n }\n \n Executor::~Executor()\n@@ -745,33 \u002B747,16 @@ Executor::wait_for_work(std::chrono::nanoseconds timeout)\n   // Clear any previous wait result\n   this-\u003Ewait_result_.reset();\n \n-  // we need to make sure that callback groups don\u0027t get out of scope\n-  // during the wait. As in jazzy, they are not covered by the DynamicStorage,\n-  // we explicitly hold them here as a bugfix\n-  std::vector\u003Crclcpp::CallbackGroup::SharedPtr\u003E cbgs;\n-\n   {\n     std::lock_guard\u003Cstd::mutex\u003E guard(mutex_);\n \n     if (this-\u003Eentities_need_rebuild_.exchange(false) || current_collection_.empty()) {\n       this-\u003Ecollect_entities();\n     }\n-\n-    auto callback_groups = this-\u003Ecollector_.get_all_callback_groups();\n-    cbgs.resize(callback_groups.size());\n-    for(const auto \u0026 w_ptr : callback_groups) {\n-      auto shr_ptr = w_ptr.lock();\n-      if(shr_ptr) {\n-        cbgs.push_back(std::move(shr_ptr));\n-      }\n-    }\n   }\n \n   this-\u003Ewait_result_.emplace(wait_set_.wait(timeout));\n \n-  // drop references to the callback groups, before trying to execute anything\n-  cbgs.clear();\n-\n   if (!this-\u003Ewait_result_ || this-\u003Ewait_result_-\u003Ekind() == WaitResultKind::Empty) {\n     RCUTILS_LOG_WARN_NAMED(\n       \u0022rclcpp\u0022,\ndiff --git rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\nindex d827528b..43850179 100644\n--- rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\n@@ -20,8 \u002B20,11 @@ namespace rclcpp\n namespace executors\n {\n \n-ExecutorNotifyWaitable::ExecutorNotifyWaitable(std::function\u003Cvoid(void)\u003E on_execute_callback)\n-: execute_callback_(on_execute_callback)\n\u002BExecutorNotifyWaitable::ExecutorNotifyWaitable(\n\u002B  std::function\u003Cvoid(void)\u003E on_execute_callback,\n\u002B  const rclcpp::Context::SharedPtr \u0026 context)\n\u002B: execute_callback_(on_execute_callback),\n\u002B  guard_condition_(std::make_shared\u003Crclcpp::GuardCondition\u003E(context))\n {\n }\n \n@@ -30,6 \u002B33,9 @@ ExecutorNotifyWaitable::ExecutorNotifyWaitable(ExecutorNotifyWaitable \u0026 other)\n   std::lock_guard\u003Cstd::mutex\u003E lock(other.guard_condition_mutex_);\n   this-\u003Eexecute_callback_ = other.execute_callback_;\n   this-\u003Enotify_guard_conditions_ = other.notify_guard_conditions_;\n\u002B  this-\u003Eguard_condition_ = other.guard_condition_;\n\u002B  this-\u003Eidxs_of_added_guard_condition_ = other.idxs_of_added_guard_condition_;\n\u002B  this-\u003Eneeds_processing = other.needs_processing;\n }\n \n ExecutorNotifyWaitable \u0026 ExecutorNotifyWaitable::operator=(ExecutorNotifyWaitable \u0026 other)\n@@ -38,6 \u002B44,9 @@ ExecutorNotifyWaitable \u0026 ExecutorNotifyWaitable::operator=(ExecutorNotifyWaitabl\n     std::lock_guard\u003Cstd::mutex\u003E lock(other.guard_condition_mutex_);\n     this-\u003Eexecute_callback_ = other.execute_callback_;\n     this-\u003Enotify_guard_conditions_ = other.notify_guard_conditions_;\n\u002B    this-\u003Eguard_condition_ = other.guard_condition_;\n\u002B    this-\u003Eidxs_of_added_guard_condition_ = other.idxs_of_added_guard_condition_;\n\u002B    this-\u003Eneeds_processing = other.needs_processing;\n   }\n   return *this;\n }\n@@ -47,21 \u002B56,42 @@ ExecutorNotifyWaitable::add_to_wait_set(rcl_wait_set_t \u0026 wait_set)\n {\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n \n\u002B  idxs_of_added_guard_condition_.clear();\n\u002B  idxs_of_added_guard_condition_.reserve(notify_guard_conditions_.size());\n\u002B\n\u002B  if(needs_processing) {\n\u002B    rcl_guard_condition_t * cond = \u0026guard_condition_-\u003Eget_rcl_guard_condition();\n\u002B    size_t rcl_index;\n\u002B    rcl_ret_t ret = rcl_wait_set_add_guard_condition(\u0026wait_set, cond, \u0026rcl_index);\n\u002B\n\u002B    if (RCL_RET_OK != ret) {\n\u002B      rclcpp::exceptions::throw_from_rcl_error(\n\u002B        ret, \u0022failed to add guard condition to wait set\u0022);\n\u002B    }\n\u002B\n\u002B    idxs_of_added_guard_condition_.push_back(rcl_index);\n\u002B\n\u002B    // we want to directly wake up any way, not need to add the other guard conditions\n\u002B    guard_condition_-\u003Etrigger();\n\u002B\n\u002B    return;\n\u002B  }\n\u002B\n   // Note: no guard conditions need to be re-triggered, since the guard\n   // conditions in this class are not tracking a stateful condition, but instead\n   // only serve to interrupt the wait set when new information is available to\n   // consider.\n-  for (auto weak_guard_condition : this-\u003Enotify_guard_conditions_) {\n-    auto guard_condition = weak_guard_condition.lock();\n-    if (!guard_condition) {continue;}\n-\n\u002B  for (const auto \u0026 guard_condition : this-\u003Enotify_guard_conditions_) {\n     rcl_guard_condition_t * cond = \u0026guard_condition-\u003Eget_rcl_guard_condition();\n-    rcl_ret_t ret = rcl_wait_set_add_guard_condition(\u0026wait_set, cond, NULL);\n\u002B    size_t rcl_index;\n\u002B    rcl_ret_t ret = rcl_wait_set_add_guard_condition(\u0026wait_set, cond, \u0026rcl_index);\n \n     if (RCL_RET_OK != ret) {\n       rclcpp::exceptions::throw_from_rcl_error(\n         ret, \u0022failed to add guard condition to wait set\u0022);\n     }\n\u002B\n\u002B    idxs_of_added_guard_condition_.push_back(rcl_index);\n   }\n }\n \n@@ -71,20 \u002B101,23 @@ ExecutorNotifyWaitable::is_ready(const rcl_wait_set_t \u0026 wait_set)\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n \n   bool any_ready = false;\n-  for (size_t ii = 0; ii \u003C wait_set.size_of_guard_conditions; \u002B\u002Bii) {\n-    const auto * rcl_guard_condition = wait_set.guard_conditions[ii];\n\u002B  for (size_t rcl_index : idxs_of_added_guard_condition_) {\n\u002B    if(rcl_index \u003E= wait_set.size_of_guard_conditions) {\n\u002B      throw std::runtime_error(\n\u002B            \u0022ExecutorNotifyWaitable::is_ready: Internal error, got index out of range\u0022);\n\u002B    }\n\u002B\n\u002B    const auto * rcl_guard_condition = wait_set.guard_conditions[rcl_index];\n \n     if (nullptr == rcl_guard_condition) {\n       continue;\n     }\n-    for (const auto \u0026 weak_guard_condition : this-\u003Enotify_guard_conditions_) {\n-      auto guard_condition = weak_guard_condition.lock();\n-      if (guard_condition \u0026\u0026 \u0026guard_condition-\u003Eget_rcl_guard_condition() == rcl_guard_condition) {\n-        any_ready = true;\n-        break;\n-      }\n-    }\n\u002B\n\u002B    any_ready = true;\n\u002B    needs_processing = true;\n\u002B    break;\n   }\n\u002B\n   return any_ready;\n }\n \n@@ -92,6 \u002B125,9 @@ void\n ExecutorNotifyWaitable::execute(const std::shared_ptr\u003Cvoid\u003E \u0026 /*data*/)\n {\n   std::lock_guard\u003Cstd::mutex\u003E lock(execute_mutex_);\n\u002B\n\u002B  needs_processing = false;\n\u002B\n   this-\u003Eexecute_callback_();\n }\n \n@@ -122,11 \u002B158,7 @@ ExecutorNotifyWaitable::set_on_ready_callback(std::function\u003Cvoid(size_t, int)\u003E c\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n \n   on_ready_callback_ = gc_callback;\n-  for (auto weak_gc : notify_guard_conditions_) {\n-    auto gc = weak_gc.lock();\n-    if (!gc) {\n-      continue;\n-    }\n\u002B  for (const auto \u0026 gc : notify_guard_conditions_) {\n     gc-\u003Eset_on_trigger_callback(on_ready_callback_);\n   }\n }\n@@ -138,11 \u002B170,7 @@ ExecutorNotifyWaitable::clear_on_ready_callback()\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n \n   on_ready_callback_ = nullptr;\n-  for (auto weak_gc : notify_guard_conditions_) {\n-    auto gc = weak_gc.lock();\n-    if (!gc) {\n-      continue;\n-    }\n\u002B  for (const auto \u0026 gc : notify_guard_conditions_) {\n     gc-\u003Eset_on_trigger_callback(nullptr);\n   }\n }\n@@ -159,9 \u002B187,9 @@ void\n ExecutorNotifyWaitable::add_guard_condition(rclcpp::GuardCondition::WeakPtr weak_guard_condition)\n {\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n-  auto guard_condition = weak_guard_condition.lock();\n-  if (guard_condition \u0026\u0026 notify_guard_conditions_.count(weak_guard_condition) == 0) {\n-    notify_guard_conditions_.insert(weak_guard_condition);\n\u002B  const auto \u0026 guard_condition = weak_guard_condition.lock();\n\u002B  if (guard_condition \u0026\u0026 notify_guard_conditions_.count(guard_condition) == 0) {\n\u002B    notify_guard_conditions_.insert(guard_condition);\n     if (on_ready_callback_) {\n       guard_condition-\u003Eset_on_trigger_callback(on_ready_callback_);\n     }\n@@ -172,11 \u002B200,17 @@ void\n ExecutorNotifyWaitable::remove_guard_condition(rclcpp::GuardCondition::WeakPtr weak_guard_condition)\n {\n   std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n-  if (notify_guard_conditions_.count(weak_guard_condition) != 0) {\n-    notify_guard_conditions_.erase(weak_guard_condition);\n-    auto guard_condition = weak_guard_condition.lock();\n\u002B  const auto \u0026 guard_condition = weak_guard_condition.lock();\n\u002B  if (!guard_condition) {\n\u002B    // If the lock did not work, the guard condition can\u0027t be\n\u002B    // saved in the sets, therefore we don\u0027t need to remove it\n\u002B    return;\n\u002B  }\n\u002B  auto it = notify_guard_conditions_.find(guard_condition);\n\u002B  if (it != notify_guard_conditions_.end()) {\n\u002B    notify_guard_conditions_.erase(it);\n     // If this notify waitable doesn\u0027t have an on_ready_callback, then there\u0027s nothing to unset\n-    if (guard_condition \u0026\u0026 on_ready_callback_) {\n\u002B    if (on_ready_callback_) {\n       guard_condition-\u003Eset_on_trigger_callback(nullptr);\n     }\n   }\ndiff --git rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp\nindex ab7f730a..92b64454 100644\n--- rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp\n@@ -76,8 \u002B76,7 @@ TEST_F(TestExecutorNotifyWaitable, wait) {\n     std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(on_execute_callback);\n \n   auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n-  auto notify_guard_condition =\n-    node-\u003Eget_node_base_interface()-\u003Eget_shared_notify_guard_condition();\n\u002B  auto notify_guard_condition = std::make_shared\u003Crclcpp::GuardCondition\u003E();\n   EXPECT_NO_THROW(waitable-\u003Eadd_guard_condition(notify_guard_condition));\n \n   auto default_cbg = node-\u003Eget_node_base_interface()-\u003Eget_default_callback_group();\n@@ -86,12 \u002B85,15 @@ TEST_F(TestExecutorNotifyWaitable, wait) {\n   auto waitables = node-\u003Eget_node_waitables_interface();\n   waitables-\u003Eadd_waitable(std::static_pointer_cast\u003Crclcpp::Waitable\u003E(waitable), default_cbg);\n \n\u002B  // notify the guard condition, this should trigger the on_execute_callback\n\u002B  notify_guard_condition-\u003Etrigger();\n\u002B\n   rclcpp::executors::SingleThreadedExecutor executor;\n   executor.add_node(node);\n   executor.spin_all(std::chrono::seconds(1));\n   EXPECT_EQ(1u, on_execute_calls);\n \n-  // on_execute_callback doesn\u0027t change if the topology doesn\u0027t change\n\u002B  // no further trigger, therefore no further callback\n   executor.spin_all(std::chrono::seconds(1));\n   EXPECT_EQ(1u, on_execute_calls);\n }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclpy",
    "SHA": "573d9c88904e574aa0b333afa2cf68e6c4997971",
    "RawMessage": "Add types to task.py (#1254)",
    "Changes": "diff --git rclpy/rclpy/task.py rclpy/rclpy/task.py\nindex 8e701ac..81a56ab 100644\n--- rclpy/rclpy/task.py\n\u002B\u002B\u002B rclpy/rclpy/task.py\n@@ -15,74 \u002B15,80 @@\n import inspect\n import sys\n import threading\n\u002Bfrom typing import (Callable, cast, Coroutine, Dict, Generator, Generic, List,\n\u002B                    Optional, TYPE_CHECKING, TypeVar, Union)\n import warnings\n import weakref\n \n\u002Bif TYPE_CHECKING:\n\u002B    from rclpy.executors import Executor\n \n-def _fake_weakref():\n\u002BT = TypeVar(\u0027T\u0027)\n\u002B\n\u002B\n\u002Bdef _fake_weakref() -\u003E None:\n     \u0022\u0022\u0022Return None when called to simulate a weak reference that has been garbage collected.\u0022\u0022\u0022\n     return None\n \n \n-class Future:\n\u002Bclass Future(Generic[T]):\n     \u0022\u0022\u0022Represent the outcome of a task in the future.\u0022\u0022\u0022\n \n-    def __init__(self, *, executor=None):\n\u002B    def __init__(self, *, executor: Optional[\u0027Executor\u0027] = None) -\u003E None:\n         # true if the task is done or cancelled\n         self._done = False\n         # true if the task is cancelled\n         self._cancelled = False\n         # the final return value of the handler\n-        self._result = None\n\u002B        self._result: Optional[T] = None\n         # An exception raised by the handler when called\n-        self._exception = None\n\u002B        self._exception: Optional[Exception] = None\n         self._exception_fetched = False\n         # callbacks to be scheduled after this task completes\n-        self._callbacks = []\n\u002B        self._callbacks: List[Callable[[\u0027Future[T]\u0027], None]] = []\n         # Lock for threadsafety\n         self._lock = threading.Lock()\n         # An executor to use when scheduling done callbacks\n-        self._executor = None\n\u002B        self._executor: Optional[Union[weakref.ReferenceType[\u0027Executor\u0027],\n\u002B                                       Callable[[], None]]] = None\n         self._set_executor(executor)\n \n-    def __del__(self):\n\u002B    def __del__(self) -\u003E None:\n         if self._exception is not None and not self._exception_fetched:\n             print(\n                 \u0027The following exception was never retrieved: \u0027 \u002B str(self._exception),\n                 file=sys.stderr)\n \n-    def __await__(self):\n\u002B    def __await__(self) -\u003E Generator[None, None, Optional[T]]:\n         # Yield if the task is not finished\n         while not self._done:\n             yield\n         return self.result()\n \n-    def cancel(self):\n\u002B    def cancel(self) -\u003E None:\n         \u0022\u0022\u0022Request cancellation of the running task if it is not done already.\u0022\u0022\u0022\n         with self._lock:\n             if not self._done:\n                 self._cancelled = True\n         self._schedule_or_invoke_done_callbacks()\n \n-    def cancelled(self):\n\u002B    def cancelled(self) -\u003E bool:\n         \u0022\u0022\u0022\n         Indicate if the task has been cancelled.\n \n         :return: True if the task was cancelled\n-        :rtype: bool\n         \u0022\u0022\u0022\n         return self._cancelled\n \n-    def done(self):\n\u002B    def done(self) -\u003E bool:\n         \u0022\u0022\u0022\n         Indicate if the task has finished executing.\n \n         :return: True if the task is finished or raised while it was executing\n-        :rtype: bool\n         \u0022\u0022\u0022\n         return self._done\n \n-    def result(self):\n\u002B    def result(self) -\u003E Optional[T]:\n         \u0022\u0022\u0022\n         Get the result of a done task.\n \n@@ -90,11 \u002B96,12 @@ class Future:\n \n         :return: The result set by the task, or None if no result was set.\n         \u0022\u0022\u0022\n-        if self._exception:\n-            raise self.exception()\n\u002B        exception = self.exception()\n\u002B        if exception:\n\u002B            raise exception\n         return self._result\n \n-    def exception(self):\n\u002B    def exception(self) -\u003E Optional[Exception]:\n         \u0022\u0022\u0022\n         Get an exception raised by a done task.\n \n@@ -103,7 \u002B110,7 @@ class Future:\n         self._exception_fetched = True\n         return self._exception\n \n-    def set_result(self, result):\n\u002B    def set_result(self, result: T) -\u003E None:\n         \u0022\u0022\u0022\n         Set the result returned by a task.\n \n@@ -115,7 \u002B122,7 @@ class Future:\n             self._cancelled = False\n         self._schedule_or_invoke_done_callbacks()\n \n-    def set_exception(self, exception):\n\u002B    def set_exception(self, exception: Exception) -\u003E None:\n         \u0022\u0022\u0022\n         Set the exception raised by the task.\n \n@@ -128,13 \u002B135,14 @@ class Future:\n             self._cancelled = False\n         self._schedule_or_invoke_done_callbacks()\n \n-    def _schedule_or_invoke_done_callbacks(self):\n\u002B    def _schedule_or_invoke_done_callbacks(self) -\u003E None:\n         \u0022\u0022\u0022\n         Schedule done callbacks on the executor if possible, else run them directly.\n \n         This function assumes self._lock is not held.\n         \u0022\u0022\u0022\n         with self._lock:\n\u002B            assert self._executor is not None\n             executor = self._executor()\n             callbacks = self._callbacks\n             self._callbacks = []\n@@ -152,7 \u002B160,7 @@ class Future:\n                     # Don\u0027t let exceptions be raised because there may be more callbacks to call\n                     warnings.warn(\u0027Unhandled exception in done callback: {}\u0027.format(e))\n \n-    def _set_executor(self, executor):\n\u002B    def _set_executor(self, executor: Optional[\u0027Executor\u0027]) -\u003E None:\n         \u0022\u0022\u0022Set the executor this future is associated with.\u0022\u0022\u0022\n         with self._lock:\n             if executor is None:\n@@ -160,7 \u002B168,7 @@ class Future:\n             else:\n                 self._executor = weakref.ref(executor)\n \n-    def add_done_callback(self, callback):\n\u002B    def add_done_callback(self, callback: Callable[[\u0027Future[T]\u0027], None]) -\u003E None:\n         \u0022\u0022\u0022\n         Add a callback to be executed when the task is done.\n \n@@ -174,6 \u002B182,7 @@ class Future:\n         invoke = False\n         with self._lock:\n             if self._done:\n\u002B                assert self._executor is not None\n                 executor = self._executor()\n                 if executor is not None:\n                     executor.create_task(callback, self)\n@@ -187,7 \u002B196,7 @@ class Future:\n             callback(self)\n \n \n-class Task(Future):\n\u002Bclass Task(Future[T]):\n     \u0022\u0022\u0022\n     Execute a function or coroutine.\n \n@@ -197,17 \u002B206,21 @@ class Task(Future):\n     This class should only be instantiated by :class:\u0060rclpy.executors.Executor\u0060.\n     \u0022\u0022\u0022\n \n-    def __init__(self, handler, args=None, kwargs=None, executor=None):\n\u002B    def __init__(self,\n\u002B                 handler: Union[Callable[[], T], Coroutine[None, None, T], None],\n\u002B                 args: Optional[List[object]] = None,\n\u002B                 kwargs: Optional[Dict[str, object]] = None,\n\u002B                 executor: Optional[\u0027Executor\u0027] = None) -\u003E None:\n         super().__init__(executor=executor)\n         # _handler is either a normal function or a coroutine\n         self._handler = handler\n         # Arguments passed into the function\n         if args is None:\n             args = []\n-        self._args = args\n\u002B        self._args: Optional[List[object]] = args\n         if kwargs is None:\n             kwargs = {}\n-        self._kwargs = kwargs\n\u002B        self._kwargs: Optional[Dict[str, object]] = kwargs\n         if inspect.iscoroutinefunction(handler):\n             self._handler = handler(*args, **kwargs)\n             self._args = None\n@@ -217,7 \u002B230,7 @@ class Task(Future):\n         # Lock acquired to prevent task from executing in parallel with itself\n         self._task_lock = threading.Lock()\n \n-    def __call__(self):\n\u002B    def __call__(self) -\u003E None:\n         \u0022\u0022\u0022\n         Run or resume a task.\n \n@@ -235,11 \u002B248,12 @@ class Task(Future):\n \n             if inspect.iscoroutine(self._handler):\n                 # Execute a coroutine\n\u002B                handler = cast(Coroutine[None, None, T], self._handler)\n                 try:\n-                    self._handler.send(None)\n\u002B                    handler.send(None)\n                 except StopIteration as e:\n                     # The coroutine finished; store the result\n-                    self._handler.close()\n\u002B                    handler.close()\n                     self.set_result(e.value)\n                     self._complete_task()\n                 except Exception as e:\n@@ -248,6 \u002B262,7 @@ class Task(Future):\n             else:\n                 # Execute a normal function\n                 try:\n\u002B                    assert self._handler is not None and callable(self._handler)\n                     self.set_result(self._handler(*self._args, **self._kwargs))\n                 except Exception as e:\n                     self.set_exception(e)\n@@ -257,17 \u002B272,16 @@ class Task(Future):\n         finally:\n             self._task_lock.release()\n \n-    def _complete_task(self):\n\u002B    def _complete_task(self) -\u003E None:\n         \u0022\u0022\u0022Cleanup after task finished.\u0022\u0022\u0022\n         self._handler = None\n         self._args = None\n         self._kwargs = None\n \n-    def executing(self):\n\u002B    def executing(self) -\u003E bool:\n         \u0022\u0022\u0022\n         Check if the task is currently being executed.\n \n         :return: True if the task is currently executing.\n-        :rtype: bool\n         \u0022\u0022\u0022\n         return self._executing\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclc",
    "SHA": "555192cd831eb9974018d5191fa52c0c6238c603",
    "RawMessage": "update ros-tooling versions (#361)",
    "Changes": "diff --git .github/workflows/ci.yml .github/workflows/ci.yml\nindex 2822b9b..346aeb0 100644\n--- .github/workflows/ci.yml\n\u002B\u002B\u002B .github/workflows/ci.yml\n@@ -24,7 \u002B24,7 @@ jobs:\n       image: ${{ matrix.docker_image }}\n     steps:\n     - uses: actions/checkout@v2\n-    - uses: ros-tooling/setup-ros@0.4.2\n\u002B    - uses: ros-tooling/setup-ros@0.6.2\n       with:\n         use-ros2-testing: true\n         required-ros-distributions: ${{ matrix.ros_distribution }}\n@@ -35,7 \u002B35,7 @@ jobs:\n         apt-get install ros-${{ matrix.ros_distribution }}-rclcpp-action\n         apt-get install ros-${{ matrix.ros_distribution }}-mimick-vendor\n         apt-get -y install ros-${{ matrix.ros_distribution }}-performance-test-fixture\n-    - uses : ros-tooling/action-ros-ci@0.2.7\n\u002B    - uses : ros-tooling/action-ros-ci@0.3.2\n       with:\n         package-name: \u0022rclc rclc_examples rclc_lifecycle rclc_parameter\u0022\n         target-ros2-distro: ${{ matrix.ros_distribution }}\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rcl",
    "SHA": "9f21d1f8db3244eeab458da505379c87703ec88d",
    "RawMessage": "Cope with base function restrictions in mocks. (#753)",
    "Changes": "diff --git rcl/test/mocking_utils/patch.hpp rcl/test/mocking_utils/patch.hpp\nindex 8bb67d5..7b0d8d8 100644\n--- rcl/test/mocking_utils/patch.hpp\n\u002B\u002B\u002B rcl/test/mocking_utils/patch.hpp\n@@ -473,10 \u002B473,22 @@ auto make_patch(const std::string \u0026 target, std::function\u003CSignatureT\u003E proxy)\n \n /// Patch a \u0060function\u0060 to execute normally but always yield a given \u0060return_code\u0060\n /// in a given \u0060scope\u0060.\n\u002B/**\n\u002B * \\warning On some Linux distributions (e.g. CentOS), pointers to function\n\u002B *   reference their PLT trampolines. In such cases, it is not possible to\n\u002B *   call \u0060function\u0060 from within the mock.\n\u002B */\n #define inject_on_return(scope, function, return_code) \\\n   patch( \\\n     scope, function, ([\u0026, base = function](auto \u0026\u0026 ... __args) { \\\n-      static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      if (base != function) { \\\n\u002B        static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      } else { \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n\u002B          \u0022[WARNING] mocking_utils::inject_on_return() cannot forward call to \u0022 \\\n\u002B          \u0022original \u0027\u0022 RCUTILS_STRINGIFY(function) \u0022\u0027 function before injection\\n\u0022 \\\n\u002B          \u0022    at \u0022 __FILE__ \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022\\n\u0022); \\\n\u002B      } \\\n       return return_code; \\\n     }))\n \ndiff --git rcl/test/rcl/test_logging.cpp rcl/test/rcl/test_logging.cpp\nindex 5ffb95e..1ce2eda 100644\n--- rcl/test/rcl/test_logging.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_logging.cpp\n@@ -242,14 \u002B242,13 @@ TEST(TestLogging, test_failing_external_logging) {\n   std::stringstream stderr_sstream;\n   auto fwrite_mock = mocking_utils::patch(\n     \u0022lib:rcl\u0022, fwrite,\n-    ([\u0026, base = fwrite](const void * ptr, size_t size,\n-    size_t count, FILE * stream)\n\u002B    [\u0026](const void * ptr, size_t size, size_t count, FILE * stream)\n     {\n       if (sizeof(char) == size \u0026\u0026 stderr == stream) {\n         stderr_sstream \u003C\u003C std::string(reinterpret_cast\u003Cconst char *\u003E(ptr), count);\n       }\n-      return base(ptr, size, count, stream);\n-    }));\n\u002B      return count;\n\u002B    });\n \n   constexpr char stderr_message[] = \u0022internal error\u0022;\n #ifdef MOCKING_UTILS_SUPPORT_VA_LIST\ndiff --git rcl/test/rcl/test_rmw_impl_id_check_func.cpp rcl/test/rcl/test_rmw_impl_id_check_func.cpp\nindex 7d576f3..62c3f2e 100644\n--- rcl/test/rcl/test_rmw_impl_id_check_func.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_rmw_impl_id_check_func.cpp\n@@ -128,12 \u002B128,15 @@ TEST(TestRmwCheck, test_mock_rmw_impl_check) {\n \n     auto mock = mocking_utils::patch(\n       \u0022lib:rcl\u0022, rcutils_strdup,\n-      [base = rcutils_strdup](const char * str, auto allocator)\n\u002B      [](const char * str, auto allocator)\n       {\n         static int counter = 1;\n         if (counter == 1) {\n           counter\u002B\u002B;\n-          return base(str, allocator);\n\u002B          char * dup = static_cast\u003Cchar *\u003E(\n\u002B            allocator.allocate(strlen(str) \u002B 1, allocator.state));\n\u002B          memcpy(dup, str, strlen(str) \u002B 1);\n\u002B          return dup;\n         } else {\n           return static_cast\u003Cchar *\u003E(NULL);\n         }\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rclc",
    "SHA": "4b8ef7b3e0dcfe77e67707d30d67ec94e1597f68",
    "RawMessage": "Data structures interfaces for multi-threaded executor (#355)",
    "Changes": "diff --git rclc/include/rclc/executor.h rclc/include/rclc/executor.h\nindex 398a36e..39cb94e 100644\n--- rclc/include/rclc/executor.h\n\u002B\u002B\u002B rclc/include/rclc/executor.h\n@@ -50,15 \u002B50,29 @@ typedef enum\n   LET\n } rclc_executor_semantics_t;\n \n\u002Btypedef enum\n\u002B{\n\u002B  NONE,\n\u002B  SINGLE_THREADED,\n\u002B  MULTI_THREADED,\n\u002B  NON_POSIX,\n\u002B} rclc_executor_type_t;\n\u002B\n /// Type definition for trigger function. With the parameters:\n /// - array of executor_handles\n /// - size of array\n /// - application specific struct used in the trigger function\n typedef bool (* rclc_executor_trigger_t)(rclc_executor_handle_t *, unsigned int, void *);\n \n\u002B/// function pointer specification\n\u002Btypedef struct rclc_executor_t_s rclc_executor_t;\n\u002Btypedef rcl_ret_t (* rclc_executor_func_t)(rclc_executor_t *);\n\u002B\n /// Container for RCLC-Executor\n-typedef struct\n\u002Bstruct rclc_executor_t_s\n {\n\u002B  /// Type of Executor\n\u002B  rclc_executor_type_t type;\n   /// Context (to get information if ROS is up-and-running)\n   rcl_context_t * context;\n   /// Container for dynamic array for DDS-handles\n@@ -83,7 \u002B97,9 @@ typedef struct\n   void * trigger_object;\n   /// data communication semantics\n   rclc_executor_semantics_t data_comm_semantics;\n-} rclc_executor_t;\n\u002B  /// pointer to custom executor data structure\n\u002B  void * custom;\n\u002B};\n \n /**\n  *  Return a rclc_executor_t struct with pointer members initialized to \u0060NULL\u0060\ndiff --git rclc/include/rclc/executor_handle.h rclc/include/rclc/executor_handle.h\nindex 444a4ff..844b046 100644\n--- rclc/include/rclc/executor_handle.h\n\u002B\u002B\u002B rclc/include/rclc/executor_handle.h\n@@ -165,6 \u002B165,8 @@ typedef struct\n   /// Interval variable. Flag, which is true, if new data is available from DDS queue\n   /// (is set after calling rcl_take)\n   bool data_available;\n\u002B  /// pointer to custom handle\n\u002B  void * custom;\n } rclc_executor_handle_t;\n \n /// Information about total number of subscriptions, guard_conditions, timers, subscription etc.\n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  },
  {
    "Repository": "rviz",
    "SHA": "8a50fe72a0763aa35c46964c80b6946d9d99712a",
    "RawMessage": "Added common test to rviz_rendering_tests (#1234)",
    "Changes": "diff --git rviz_rendering_tests/package.xml rviz_rendering_tests/package.xml\nindex d8a62273..5eefc432 100644\n--- rviz_rendering_tests/package.xml\n\u002B\u002B\u002B rviz_rendering_tests/package.xml\n@@ -27,14 \u002B27,9 @@\n   \u003Cdepend\u003Erviz_rendering\u003C/depend\u003E\n   \u003Cdepend\u003Eresource_retriever\u003C/depend\u003E\n \n-  \u003C!-- TODO(jacobperron): Replace with ament_lint_common when ament_copyright is working --\u003E\n-  \u003Ctest_depend\u003Eament_cmake_cppcheck\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_cpplint\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_cmake_gmock\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_lint_cmake\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_uncrustify\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_xmllint\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_index_cpp\u003C/test_depend\u003E\n \ndiff --git rviz_rendering_tests/test/mesh_loader_test.cpp rviz_rendering_tests/test/mesh_loader_test.cpp\nindex 3916a32c..507559de 100644\n--- rviz_rendering_tests/test/mesh_loader_test.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/mesh_loader_test.cpp\n@@ -1,31 \u002B1,31 @@\n-/*\n- * Copyright (c) 2018, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the copyright holder, nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2018, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n \n #include \u003Cgtest/gtest.h\u003E\n #include \u003Cgmock/gmock.h\u003E\ndiff --git rviz_rendering_tests/test/ogre_testing_environment.cpp rviz_rendering_tests/test/ogre_testing_environment.cpp\nindex dc8e884a..bb790c76 100644\n--- rviz_rendering_tests/test/ogre_testing_environment.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/ogre_testing_environment.cpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #include \u0022ogre_testing_environment.hpp\u0022\n \ndiff --git rviz_rendering_tests/test/ogre_testing_environment.hpp rviz_rendering_tests/test/ogre_testing_environment.hpp\nindex 6cc8e541..54f70678 100644\n--- rviz_rendering_tests/test/ogre_testing_environment.hpp\n\u002B\u002B\u002B rviz_rendering_tests/test/ogre_testing_environment.hpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #ifndef OGRE_TESTING_ENVIRONMENT_HPP_\n #define OGRE_TESTING_ENVIRONMENT_HPP_\ndiff --git rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\nindex 6fad5d08..2916113b 100644\n--- rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #include \u003Cgtest/gtest.h\u003E\n \n",
    "IsBackported": false,
    "Analysis": {
      "ChatGPTResponse": "yes",
      "PredictsBackported": true,
      "Compressed": false
    }
  }
]