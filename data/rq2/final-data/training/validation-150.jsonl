{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  this->domain_id = static_cast<dds_domainid_t>(options->domain_id);\n+  this->domain_id = static_cast<dds_domainid_t>(\n+    // No custom handling of RMW_DEFAULT_DOMAIN_ID. Simply use a reasonable domain id.\n+    options->domain_id != RMW_DEFAULT_DOMAIN_ID ? options->domain_id : 0u);\n+"},{"role":"user","content":"-  /* domain_id = UINT32_MAX = Cyclone DDS' \"default domain id\".*/\n-  if (options->domain_id >= UINT32_MAX) {\n+  if (options->domain_id >= UINT32_MAX && options->domain_id != RMW_DEFAULT_DOMAIN_ID) {"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-cmake_minimum_required(VERSION 3.12)\n+cmake_minimum_required(VERSION 3.20)"},{"role":"user","content":"+# By default, without the settings below, find_package(Python3) will attempt\n+# to find the newest python version it can, and additionally will find the\n+# most specific version.  For instance, on a system that has\n+# /usr/bin/python3.10, /usr/bin/python3.11, and /usr/bin/python3, it will find\n+# /usr/bin/python3.11, even if /usr/bin/python3 points to /usr/bin/python3.10.\n+# The behavior we want is to prefer the \"system\" installed version unless the\n+# user specifically tells us othewise through the Python3_EXECUTABLE hint.\n+# Setting CMP0094 to NEW means that the search will stop after the first\n+# python version is found.  Setting Python3_FIND_UNVERSIONED_NAMES means that\n+# the search will prefer /usr/bin/python3 over /usr/bin/python3.11.  And that\n+# latter functionality is only available in CMake 3.20 or later, so we need\n+# at least that version.\n+cmake_policy(SET CMP0094 NEW)\n+set(Python3_FIND_UNVERSIONED_NAMES FIRST)\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+    resp->available_states.resize(state_machine_.transition_map.states_size);"},{"role":"user","content":"-      lifecycle_msgs::msg::State state;\n-      state.id = static_cast<uint8_t>(state_machine_.transition_map.states[i].id);\n-      state.label = static_cast<std::string>(state_machine_.transition_map.states[i].label);\n-      resp->available_states.push_back(state);\n+      resp->available_states[i].id =\n+        static_cast<uint8_t>(state_machine_.transition_map.states[i].id);\n+      resp->available_states[i].label =\n+        static_cast<std::string>(state_machine_.transition_map.states[i].label);"},{"role":"user","content":"+    resp->available_transitions.resize(state_machine_.current_state->valid_transition_size);"},{"role":"user","content":"+      lifecycle_msgs::msg::TransitionDescription & trans_desc = resp->available_transitions[i];\n+"},{"role":"user","content":"-      lifecycle_msgs::msg::TransitionDescription trans_desc;"},{"role":"user","content":"-      resp->available_transitions.push_back(trans_desc);"},{"role":"user","content":"+    resp->available_transitions.resize(state_machine_.transition_map.transitions_size);"},{"role":"user","content":"+      lifecycle_msgs::msg::TransitionDescription & trans_desc = resp->available_transitions[i];\n+"},{"role":"user","content":"-      lifecycle_msgs::msg::TransitionDescription trans_desc;"},{"role":"user","content":"-      resp->available_transitions.push_back(trans_desc);"},{"role":"user","content":"+    states.reserve(state_machine_.transition_map.states_size);\n+"},{"role":"user","content":"-      State state(&state_machine_.transition_map.states[i]);\n-      states.push_back(state);\n+      states.emplace_back(&state_machine_.transition_map.states[i]);"},{"role":"user","content":"+    transitions.reserve(state_machine_.transition_map.transitions_size);"},{"role":"user","content":"-      Transition transition(\n-        &state_machine_.transition_map.transitions[i]);\n-      transitions.push_back(transition);\n+      transitions.emplace_back(&state_machine_.transition_map.transitions[i]);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  ament_add_test_label(test_strerror mimick)"},{"role":"user","content":"+  ament_add_test_label(test_filesystem mimick)"},{"role":"user","content":"+  ament_add_test_label(test_time mimick)"},{"role":"user","content":"+  ament_add_test_label(test_logging_custom_env mimick)"},{"role":"user","content":"+  ament_add_test_label(test_logging_custom_env2 mimick)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            return (True, msg_info[0])\n+            if msg_info is not None:\n+                return (True, msg_info[0])"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-def _assert_launch_no_errors(actions, *, timeout_sec=1):\n+def _assert_launch_no_errors(actions, *, timeout_sec=5):"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <stdexcept>"},{"role":"user","content":"+ *\n+ * \\tparam MessageT\n+ * \\tparam CallbackT\n+ * \\tparam AllocatorT\n+ * \\tparam CallbackMessageT\n+ * \\tparam SubscriptionT\n+ * \\tparam MessageMemoryStrategyT\n+ * \\tparam NodeT\n+ * \\param node\n+ * \\param topic_name\n+ * \\param qos\n+ * \\param callback\n+ * \\param options\n+ * \\param msg_mem_strat\n+ * \\return the created subscription\n+ * \\throws std::invalid_argument if topic statistics is enabled and the publish period is\n+ * less than or equal to zero."},{"role":"user","content":"+    if (options.topic_stats_options.publish_period <= std::chrono::milliseconds(0)) {\n+      throw std::invalid_argument(\n+              \"topic_stats_options.publish_period must be greater than 0, specified value of \" +\n+              std::to_string(options.topic_stats_options.publish_period.count()) +\n+              \" ms\");\n+    }\n+"},{"role":"user","content":"-    // Topic statistics publication period in ms. Defaults to one minute.\n+    // Topic statistics publication period in ms. Defaults to one second.\n+    // Only values greater than zero are allowed."},{"role":"user","content":"+#include <stdexcept>"},{"role":"user","content":"+TEST(TestSubscriptionTopicStatistics, test_invalid_publish_period)\n+{\n+  rclcpp::init(0 /* argc */, nullptr /* argv */);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"test_period_node\");\n+\n+  auto options = rclcpp::SubscriptionOptions();\n+  options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n+  options.topic_stats_options.publish_period = std::chrono::milliseconds(0);\n+\n+  auto callback = [](Empty::UniquePtr msg) {\n+      (void) msg;\n+    };\n+\n+  ASSERT_THROW(\n+    (node->create_subscription<Empty, std::function<void(Empty::UniquePtr)>>(\n+      \"should_throw_invalid_arg\",\n+      rclcpp::QoS(rclcpp::KeepAll()),\n+      callback,\n+      options)), std::invalid_argument);\n+\n+  rclcpp::shutdown();\n+}\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-- The service response topics are prefixed with `rr` and suffixed with `Response`. e.g.: `/my/fully/qualified/ros/service` response topic is `rr/my/fully/qualified/ros/serviceResponse`.\n+- The service response topics are prefixed with `rr` and suffixed with `Reply`. e.g.: `/my/fully/qualified/ros/service` response topic is `rr/my/fully/qualified/ros/serviceReply`."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+# Re-export exception defined in _rclpy C extension.\n+RCLError = _rclpy.RCLError\n+"},{"role":"user","content":"-                goal_handle._update_state(_rclpy.GoalEvent.CANCEL_GOAL)\n+                try:\n+                    # If the goal's just succeeded after user cancel callback\n+                    # that will generate an exception from invalid transition.\n+                    goal_handle._update_state(GoalEvent.CANCEL_GOAL)\n+                except RCLError as ex:\n+                    self._node.get_logger().debug(\n+                        'Failed to cancel goal in cancel callback: {0}'.format(ex))\n+                    # Remove from response since goal has been succeeded\n+                    cancel_response.goals_canceling.remove(goal_info)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# Default to C++14\n+# TODO(wjwwood): remove this when gtest can build on its own, when using target_compile_features()\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)"},{"role":"user","content":"-add_library(${PROJECT_NAME}\n-  ${${PROJECT_NAME}_SRCS})\n+add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})\n+target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_17)\n+# TODO(wjwwood): address all deprecation warnings and then remove this\n+if(WIN32)\n+  target_compile_definitions(${PROJECT_NAME} PUBLIC \"_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\")\n+endif()"},{"role":"user","content":"-#include <rmw/types.h>\n-"},{"role":"user","content":"+#include <variant>  // NOLINT[build/include_order]\n+\n+#include \"tracetools/tracetools.h\"\n+#include \"tracetools/utils.hpp\""},{"role":"user","content":"+#include \"rclcpp/detail/subscription_callback_type_helper.hpp\""},{"role":"user","content":"-#include \"rclcpp/visibility_control.hpp\"\n-#include \"tracetools/tracetools.h\"\n-#include \"tracetools/utils.hpp\"\n+\n+template<class>\n+inline constexpr bool always_false_v = false;"},{"role":"user","content":"-template<typename MessageT, typename Alloc>\n-class AnySubscriptionCallback\n+namespace detail"},{"role":"user","content":"-  using MessageAllocTraits = allocator::AllocRebind<MessageT, Alloc>;\n+\n+template<typename MessageT, typename AllocatorT>\n+struct MessageDeleterHelper\n+{\n+  using MessageAllocTraits = allocator::AllocRebind<MessageT, AllocatorT>;"},{"role":"user","content":"-  using ConstMessageSharedPtr = std::shared_ptr<const MessageT>;\n-  using MessageUniquePtr = std::unique_ptr<MessageT, MessageDeleter>;\n+};"},{"role":"user","content":"-  using SharedPtrCallback = std::function<void (const std::shared_ptr<MessageT>)>;\n-  using SharedPtrWithInfoCallback =\n-    std::function<void (const std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)>;\n-  using ConstSharedPtrCallback = std::function<void (const std::shared_ptr<const MessageT>)>;\n-  using ConstSharedPtrWithInfoCallback =\n-    std::function<void (const std::shared_ptr<const MessageT>, const rclcpp::MessageInfo &)>;\n-  using UniquePtrCallback = std::function<void (MessageUniquePtr)>;\n+template<typename MessageT, typename AllocatorT>\n+struct AnySubscriptionCallbackHelper\n+{\n+  using MessageDeleter = typename MessageDeleterHelper<MessageT, AllocatorT>::MessageDeleter;\n+\n+  using ConstRefCallback =\n+    std::function<void (const MessageT &)>;\n+  using ConstRefWithInfoCallback =\n+    std::function<void (const MessageT &, const rclcpp::MessageInfo &)>;\n+\n+  using UniquePtrCallback =\n+    std::function<void (std::unique_ptr<MessageT, MessageDeleter>)>;"},{"role":"user","content":"-    std::function<void (MessageUniquePtr, const rclcpp::MessageInfo &)>;\n+    std::function<void (std::unique_ptr<MessageT, MessageDeleter>, const rclcpp::MessageInfo &)>;\n+\n+  using SharedConstPtrCallback =\n+    std::function<void (std::shared_ptr<const MessageT>)>;\n+  using SharedConstPtrWithInfoCallback =\n+    std::function<void (std::shared_ptr<const MessageT>, const rclcpp::MessageInfo &)>;\n+\n+  using ConstRefSharedConstPtrCallback =\n+    std::function<void (const std::shared_ptr<const MessageT> &)>;\n+  using ConstRefSharedConstPtrWithInfoCallback =\n+    std::function<void (const std::shared_ptr<const MessageT> &, const rclcpp::MessageInfo &)>;"},{"role":"user","content":"-  SharedPtrCallback shared_ptr_callback_;\n-  SharedPtrWithInfoCallback shared_ptr_with_info_callback_;\n-  ConstSharedPtrCallback const_shared_ptr_callback_;\n-  ConstSharedPtrWithInfoCallback const_shared_ptr_with_info_callback_;\n-  UniquePtrCallback unique_ptr_callback_;\n-  UniquePtrWithInfoCallback unique_ptr_with_info_callback_;\n+  // Deprecated signatures:\n+  using SharedPtrCallback =\n+    std::function<void (std::shared_ptr<MessageT>)>;\n+  using SharedPtrWithInfoCallback =\n+    std::function<void (std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)>;\n+\n+  using variant_type = std::variant<\n+    ConstRefCallback,\n+    ConstRefWithInfoCallback,\n+    UniquePtrCallback,\n+    UniquePtrWithInfoCallback,\n+    SharedConstPtrCallback,\n+    SharedConstPtrWithInfoCallback,\n+    ConstRefSharedConstPtrCallback,\n+    ConstRefSharedConstPtrWithInfoCallback,\n+    SharedPtrCallback,\n+    SharedPtrWithInfoCallback\n+  >;\n+};\n+\n+}  // namespace detail\n+\n+template<\n+  typename MessageT,\n+  typename AllocatorT = std::allocator<void>\n+>\n+class AnySubscriptionCallback\n+{\n+private:\n+  using HelperT = typename rclcpp::detail::AnySubscriptionCallbackHelper<MessageT, AllocatorT>;\n+  using MessageDeleterHelper = rclcpp::detail::MessageDeleterHelper<MessageT, AllocatorT>;\n+\n+  using MessageAllocTraits = typename MessageDeleterHelper::MessageAllocTraits;\n+  using MessageAlloc = typename MessageDeleterHelper::MessageAlloc;\n+  using MessageDeleter = typename MessageDeleterHelper::MessageDeleter;\n+\n+  // See AnySubscriptionCallbackHelper for the types of these.\n+  using ConstRefCallback = typename HelperT::ConstRefCallback;\n+  using ConstRefWithInfoCallback = typename HelperT::ConstRefWithInfoCallback;\n+\n+  using UniquePtrCallback = typename HelperT::UniquePtrCallback;\n+  using UniquePtrWithInfoCallback = typename HelperT::UniquePtrWithInfoCallback;\n+\n+  using SharedConstPtrCallback = typename HelperT::SharedConstPtrCallback;\n+  using SharedConstPtrWithInfoCallback = typename HelperT::SharedConstPtrWithInfoCallback;\n+\n+  using ConstRefSharedConstPtrCallback =\n+    typename HelperT::ConstRefSharedConstPtrCallback;\n+  using ConstRefSharedConstPtrWithInfoCallback =\n+    typename HelperT::ConstRefSharedConstPtrWithInfoCallback;\n+\n+  using SharedPtrCallback = typename HelperT::SharedPtrCallback;\n+  using SharedPtrWithInfoCallback = typename HelperT::SharedPtrWithInfoCallback;"},{"role":"user","content":"-  explicit AnySubscriptionCallback(std::shared_ptr<Alloc> allocator)\n-  : shared_ptr_callback_(nullptr), shared_ptr_with_info_callback_(nullptr),\n-    const_shared_ptr_callback_(nullptr), const_shared_ptr_with_info_callback_(nullptr),\n-    unique_ptr_callback_(nullptr), unique_ptr_with_info_callback_(nullptr)\n+  explicit\n+  AnySubscriptionCallback(const AllocatorT & allocator = AllocatorT())  // NOLINT[runtime/explicit]\n+  {\n+    message_allocator_ = allocator;\n+    allocator::set_allocator_for_deleter(&message_deleter_, &message_allocator_);\n+  }\n+\n+  [[deprecated(\"use AnySubscriptionCallback(const AllocatorT & allocator) instead\")]]\n+  explicit\n+  AnySubscriptionCallback(std::shared_ptr<AllocatorT> allocator)  // NOLINT[runtime/explicit]"},{"role":"user","content":"-    message_allocator_ = std::make_shared<MessageAlloc>(*allocator.get());\n-    allocator::set_allocator_for_deleter(&message_deleter_, message_allocator_.get());\n+    message_allocator_ = *allocator;\n+    allocator::set_allocator_for_deleter(&message_deleter_, &message_allocator_);"},{"role":"user","content":"-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n-      rclcpp::function_traits::same_arguments<\n-        CallbackT,\n-        SharedPtrCallback\n-      >::value\n-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n+  /// Generic function for setting the callback.\n+  /**\n+   * There are specializations that overload this in order to deprecate some\n+   * callback signatures, and also to fix ambiguity between shared_ptr and\n+   * unique_ptr callback signatures when using them with lambda functions.\n+   */\n+  template<typename CallbackT>\n+  AnySubscriptionCallback<MessageT, AllocatorT>\n+  set(CallbackT callback)"},{"role":"user","content":"-    shared_ptr_callback_ = callback;\n-  }\n+    // Use the SubscriptionCallbackTypeHelper to determine the actual type of\n+    // the CallbackT, in terms of std::function<...>, which does not happen\n+    // automatically with lambda functions in cases where the arguments can be\n+    // converted to one another, e.g. shared_ptr and unique_ptr.\n+    using scbth = detail::SubscriptionCallbackTypeHelper<MessageT, CallbackT>;"},{"role":"user","content":"-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n+    // Determine if the given CallbackT is a deprecated signature or not.\n+    constexpr auto is_deprecated ="},{"role":"user","content":"-        CallbackT,\n-        SharedPtrWithInfoCallback\n+      typename scbth::callback_type,\n+      std::function<void(std::shared_ptr<MessageT>)>"},{"role":"user","content":"-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n-  {\n-    shared_ptr_with_info_callback_ = callback;\n-  }\n-\n-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n+      ||"},{"role":"user","content":"-        CallbackT,\n-        ConstSharedPtrCallback\n-      >::value\n-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n-  {\n-    const_shared_ptr_callback_ = callback;\n+      typename scbth::callback_type,\n+      std::function<void(std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)>\n+      >::value;\n+\n+    // Use the discovered type to force the type of callback when assigning\n+    // into the variant.\n+    if constexpr (is_deprecated) {\n+      // If deprecated, call sub-routine that is deprecated.\n+      set_deprecated(static_cast<typename scbth::callback_type>(callback));\n+    } else {\n+      // Otherwise just assign it.\n+      callback_variant_ = static_cast<typename scbth::callback_type>(callback);\n+    }\n+\n+    // Return copy of self for easier testing, normally will be compiled out.\n+    return *this;"},{"role":"user","content":"-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n-      rclcpp::function_traits::same_arguments<\n-        CallbackT,\n-        ConstSharedPtrWithInfoCallback\n-      >::value\n-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n+  /// Function for shared_ptr to non-const MessageT, which is deprecated.\n+  // TODO(wjwwood): enable this deprecation after Galactic\n+  // [[deprecated(\n+  //   \"use 'void (std::shared_ptr<const MessageT>)' instead\"\n+  // )]]\n+  void\n+  set_deprecated(std::function<void(std::shared_ptr<MessageT>)> callback)\n+  // set(CallbackT callback)"},{"role":"user","content":"-    const_shared_ptr_with_info_callback_ = callback;\n+    callback_variant_ = callback;"},{"role":"user","content":"-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n-      rclcpp::function_traits::same_arguments<\n-        CallbackT,\n-        UniquePtrCallback\n-      >::value\n-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n+  /// Function for shared_ptr to non-const MessageT with MessageInfo, which is deprecated.\n+  // TODO(wjwwood): enable this deprecation after Galactic\n+  // [[deprecated(\n+  //   \"use 'void (std::shared_ptr<const MessageT>, const rclcpp::MessageInfo &)' instead\"\n+  // )]]\n+  void\n+  set_deprecated(\n+    std::function<void(std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)> callback)"},{"role":"user","content":"-    unique_ptr_callback_ = callback;\n+    callback_variant_ = callback;"},{"role":"user","content":"-  template<\n-    typename CallbackT,\n-    typename std::enable_if<\n-      rclcpp::function_traits::same_arguments<\n-        CallbackT,\n-        UniquePtrWithInfoCallback\n-      >::value\n-    >::type * = nullptr\n-  >\n-  void set(CallbackT callback)\n+  std::unique_ptr<MessageT, MessageDeleter>\n+  create_unique_ptr_from_shared_ptr_message(const std::shared_ptr<const MessageT> & message)"},{"role":"user","content":"-    unique_ptr_with_info_callback_ = callback;\n+    auto ptr = MessageAllocTraits::allocate(message_allocator_, 1);\n+    MessageAllocTraits::construct(message_allocator_, ptr, *message);\n+    return std::unique_ptr<MessageT, MessageDeleter>(ptr, message_deleter_);"},{"role":"user","content":"-  void dispatch(\n-    std::shared_ptr<MessageT> message, const rclcpp::MessageInfo & message_info)\n+  void\n+  dispatch(\n+    std::shared_ptr<MessageT> message,\n+    const rclcpp::MessageInfo & message_info)"},{"role":"user","content":"-    if (shared_ptr_callback_) {\n-      shared_ptr_callback_(message);\n-    } else if (shared_ptr_with_info_callback_) {\n-      shared_ptr_with_info_callback_(message, message_info);\n-    } else if (const_shared_ptr_callback_) {\n-      const_shared_ptr_callback_(message);\n-    } else if (const_shared_ptr_with_info_callback_) {\n-      const_shared_ptr_with_info_callback_(message, message_info);\n-    } else if (unique_ptr_callback_) {\n-      auto ptr = MessageAllocTraits::allocate(*message_allocator_.get(), 1);\n-      MessageAllocTraits::construct(*message_allocator_.get(), ptr, *message);\n-      unique_ptr_callback_(MessageUniquePtr(ptr, message_deleter_));\n-    } else if (unique_ptr_with_info_callback_) {\n-      auto ptr = MessageAllocTraits::allocate(*message_allocator_.get(), 1);\n-      MessageAllocTraits::construct(*message_allocator_.get(), ptr, *message);\n-      unique_ptr_with_info_callback_(MessageUniquePtr(ptr, message_deleter_), message_info);\n-    } else {\n-      throw std::runtime_error(\"unexpected message without any callback set\");\n+    // Check if the variant is \"unset\", throw if it is.\n+    if (callback_variant_.index() == 0) {\n+      if (std::get<0>(callback_variant_) == nullptr) {\n+        // This can happen if it is default initialized, or if it is assigned nullptr.\n+        throw std::runtime_error(\"dispatch called on an unset AnySubscriptionCallback\");\n+      }"},{"role":"user","content":"+    // Dispatch.\n+    std::visit(\n+      [&message, &message_info, this](auto && callback) {\n+        using T = std::decay_t<decltype(callback)>;\n+\n+        if constexpr (std::is_same_v<T, ConstRefCallback>) {\n+          callback(*message);\n+        } else if constexpr (std::is_same_v<T, ConstRefWithInfoCallback>) {\n+          callback(*message, message_info);\n+        } else if constexpr (std::is_same_v<T, UniquePtrCallback>) {\n+          callback(create_unique_ptr_from_shared_ptr_message(message));\n+        } else if constexpr (std::is_same_v<T, UniquePtrWithInfoCallback>) {\n+          callback(create_unique_ptr_from_shared_ptr_message(message), message_info);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, SharedConstPtrCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrCallback>||\n+          std::is_same_v<T, SharedPtrCallback>)\n+        {\n+          callback(message);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, SharedConstPtrWithInfoCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrWithInfoCallback>||\n+          std::is_same_v<T, SharedPtrWithInfoCallback>)\n+        {\n+          callback(message, message_info);\n+        } else {\n+          static_assert(always_false_v<T>, \"unhandled callback type\");\n+        }\n+      }, callback_variant_);"},{"role":"user","content":"-  void dispatch_intra_process(\n-    ConstMessageSharedPtr message, const rclcpp::MessageInfo & message_info)\n+  void\n+  dispatch_intra_process(\n+    std::shared_ptr<const MessageT> message,\n+    const rclcpp::MessageInfo & message_info)"},{"role":"user","content":"-    if (const_shared_ptr_callback_) {\n-      const_shared_ptr_callback_(message);\n-    } else if (const_shared_ptr_with_info_callback_) {\n-      const_shared_ptr_with_info_callback_(message, message_info);\n-    } else {\n-      if (\n-        unique_ptr_callback_ || unique_ptr_with_info_callback_ ||\n-        shared_ptr_callback_ || shared_ptr_with_info_callback_)\n-      {\n-        throw std::runtime_error(\n-                \"unexpected dispatch_intra_process const shared \"\n-                \"message call with no const shared_ptr callback\");\n-      } else {\n-        throw std::runtime_error(\"unexpected message without any callback set\");\n+    // Check if the variant is \"unset\", throw if it is.\n+    if (callback_variant_.index() == 0) {\n+      if (std::get<0>(callback_variant_) == nullptr) {\n+        // This can happen if it is default initialized, or if it is assigned nullptr.\n+        throw std::runtime_error(\"dispatch called on an unset AnySubscriptionCallback\");"},{"role":"user","content":"+    // Dispatch.\n+    std::visit(\n+      [&message, &message_info, this](auto && callback) {\n+        using T = std::decay_t<decltype(callback)>;\n+\n+        if constexpr (std::is_same_v<T, ConstRefCallback>) {\n+          callback(*message);\n+        } else if constexpr (std::is_same_v<T, ConstRefWithInfoCallback>) {\n+          callback(*message, message_info);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, UniquePtrCallback>||\n+          std::is_same_v<T, SharedPtrCallback>)\n+        {\n+          callback(create_unique_ptr_from_shared_ptr_message(message));\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, UniquePtrWithInfoCallback>||\n+          std::is_same_v<T, SharedPtrWithInfoCallback>)\n+        {\n+          callback(create_unique_ptr_from_shared_ptr_message(message), message_info);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, SharedConstPtrCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrCallback>)\n+        {\n+          callback(message);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, SharedConstPtrWithInfoCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrWithInfoCallback>)\n+        {\n+          callback(message, message_info);\n+        } else {\n+          static_assert(always_false_v<T>, \"unhandled callback type\");\n+        }\n+      }, callback_variant_);"},{"role":"user","content":"-  void dispatch_intra_process(\n-    MessageUniquePtr message, const rclcpp::MessageInfo & message_info)\n+  void\n+  dispatch_intra_process(\n+    std::unique_ptr<MessageT, MessageDeleter> message,\n+    const rclcpp::MessageInfo & message_info)"},{"role":"user","content":"-    if (shared_ptr_callback_) {\n-      typename std::shared_ptr<MessageT> shared_message = std::move(message);\n-      shared_ptr_callback_(shared_message);\n-    } else if (shared_ptr_with_info_callback_) {\n-      typename std::shared_ptr<MessageT> shared_message = std::move(message);\n-      shared_ptr_with_info_callback_(shared_message, message_info);\n-    } else if (unique_ptr_callback_) {\n-      unique_ptr_callback_(std::move(message));\n-    } else if (unique_ptr_with_info_callback_) {\n-      unique_ptr_with_info_callback_(std::move(message), message_info);\n-    } else if (const_shared_ptr_callback_ || const_shared_ptr_with_info_callback_) {\n-      throw std::runtime_error(\n-              \"unexpected dispatch_intra_process unique message call\"\n-              \" with const shared_ptr callback\");\n-    } else {\n-      throw std::runtime_error(\"unexpected message without any callback set\");\n+    // Check if the variant is \"unset\", throw if it is.\n+    if (callback_variant_.index() == 0) {\n+      if (std::get<0>(callback_variant_) == nullptr) {\n+        // This can happen if it is default initialized, or if it is assigned nullptr.\n+        throw std::runtime_error(\"dispatch called on an unset AnySubscriptionCallback\");\n+      }"},{"role":"user","content":"+    // Dispatch.\n+    std::visit(\n+      [&message, &message_info](auto && callback) {\n+        using T = std::decay_t<decltype(callback)>;\n+\n+        if constexpr (std::is_same_v<T, ConstRefCallback>) {\n+          callback(*message);\n+        } else if constexpr (std::is_same_v<T, ConstRefWithInfoCallback>) {\n+          callback(*message, message_info);\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, UniquePtrCallback>||\n+          std::is_same_v<T, SharedConstPtrCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrCallback>||\n+          std::is_same_v<T, SharedPtrCallback>)\n+        {\n+          callback(std::move(message));\n+        } else if constexpr (  // NOLINT[readability/braces]\n+          std::is_same_v<T, UniquePtrWithInfoCallback>||\n+          std::is_same_v<T, SharedConstPtrWithInfoCallback>||\n+          std::is_same_v<T, ConstRefSharedConstPtrWithInfoCallback>||\n+          std::is_same_v<T, SharedPtrWithInfoCallback>)\n+        {\n+          callback(std::move(message), message_info);\n+        } else {\n+          static_assert(always_false_v<T>, \"unhandled callback type\");\n+        }\n+      }, callback_variant_);"},{"role":"user","content":"-  bool use_take_shared_method() const\n+  constexpr\n+  bool\n+  use_take_shared_method() const"},{"role":"user","content":"-    return const_shared_ptr_callback_ || const_shared_ptr_with_info_callback_;\n+    return\n+      std::holds_alternative<SharedConstPtrCallback>(callback_variant_) ||\n+      std::holds_alternative<SharedConstPtrWithInfoCallback>(callback_variant_) ||\n+      std::holds_alternative<ConstRefSharedConstPtrCallback>(callback_variant_) ||\n+      std::holds_alternative<ConstRefSharedConstPtrWithInfoCallback>(callback_variant_);"},{"role":"user","content":"-  void register_callback_for_tracing()\n+  void\n+  register_callback_for_tracing()"},{"role":"user","content":"-    if (shared_ptr_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast<const void *>(this),\n-        tracetools::get_symbol(shared_ptr_callback_));\n-    } else if (shared_ptr_with_info_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast<const void *>(this),\n-        tracetools::get_symbol(shared_ptr_with_info_callback_));\n-    } else if (unique_ptr_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast<const void *>(this),\n-        tracetools::get_symbol(unique_ptr_callback_));\n-    } else if (unique_ptr_with_info_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast<const void *>(this),\n-        tracetools::get_symbol(unique_ptr_with_info_callback_));\n-    }\n+    std::visit(\n+      [this](auto && callback) {\n+        TRACEPOINT(\n+          rclcpp_callback_register,\n+          static_cast<const void *>(this),\n+          tracetools::get_symbol(callback));\n+      }, callback_variant_);"},{"role":"user","content":"+  typename HelperT::variant_type &\n+  get_variant()\n+  {\n+    return callback_variant_;\n+  }\n+\n+  const typename HelperT::variant_type &\n+  get_variant() const\n+  {\n+    return callback_variant_;\n+  }\n+"},{"role":"user","content":"-  std::shared_ptr<MessageAlloc> message_allocator_;\n+  // TODO(wjwwood): switch to inheriting from std::variant (i.e. HelperT::variant_type) once\n+  // inheriting from std::variant is realistic (maybe C++23?), see:\n+  //   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r0.html\n+  // For now, compose the variant into this class as a private attribute.\n+  typename HelperT::variant_type callback_variant_;\n+\n+  MessageAlloc message_allocator_;"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_\n+#define RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_\n+\n+#include <memory>\n+#include <type_traits>\n+\n+#include \"rclcpp/function_traits.hpp\"\n+#include \"rclcpp/message_info.hpp\"\n+\n+namespace rclcpp\n+{\n+namespace detail\n+{\n+\n+/// Template metaprogramming helper used to resolve the callback argument into a std::function.\n+/**\n+ * Sometimes the CallbackT is a std::function already, but it could also be a\n+ * function pointer, lambda, bind, or some variant of those.\n+ * In some cases, like a lambda where the arguments can be converted between one\n+ * another, e.g. std::function<void (shared_ptr<...>)> and\n+ * std::function<void (unique_ptr<...>)>, you need to make that not ambiguous\n+ * by checking the arguments independently using function traits rather than\n+ * rely on overloading the two std::function types.\n+ *\n+ * This issue, with the lambda's, can be demonstrated with this minimal program:\n+ *\n+ *   #include <functional>\n+ *   #include <memory>\n+ *\n+ *   void f(std::function<void (std::shared_ptr<int>)>) {}\n+ *   void f(std::function<void (std::unique_ptr<int>)>) {}\n+ *\n+ *   int main() {\n+ *     // Fails to compile with an \"ambiguous call\" error.\n+ *     f([](std::shared_ptr<int>){});\n+ *\n+ *     // Works.\n+ *     std::function<void (std::shared_ptr<int>)> cb = [](std::shared_ptr<int>){};\n+ *     f(cb);\n+ *   }\n+ *\n+ * If this program ever starts working in a future version of C++, this class\n+ * may become redundant.\n+ *\n+ * This helper works by using SFINAE with rclcpp::function_traits::same_arguments<>\n+ * to narrow down the exact std::function<> type for the given CallbackT.\n+ */\n+template<typename MessageT, typename CallbackT, typename Enable = void>\n+struct SubscriptionCallbackTypeHelper\n+{\n+  using callback_type = typename rclcpp::function_traits::as_std_function<CallbackT>::type;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(std::shared_ptr<const MessageT>)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type = std::function<void (std::shared_ptr<const MessageT>)>;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(std::shared_ptr<const MessageT>, const rclcpp::MessageInfo &)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type =\n+    std::function<void (std::shared_ptr<const MessageT>, const rclcpp::MessageInfo &)>;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(const std::shared_ptr<const MessageT> &)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type = std::function<void (const std::shared_ptr<const MessageT> &)>;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(const std::shared_ptr<const MessageT> &, const rclcpp::MessageInfo &)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type =\n+    std::function<void (const std::shared_ptr<const MessageT> &, const rclcpp::MessageInfo &)>;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(std::shared_ptr<MessageT>)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type = std::function<void (std::shared_ptr<MessageT>)>;\n+};\n+\n+template<typename MessageT, typename CallbackT>\n+struct SubscriptionCallbackTypeHelper<\n+  MessageT,\n+  CallbackT,\n+  typename std::enable_if_t<\n+    rclcpp::function_traits::same_arguments<\n+      CallbackT,\n+      std::function<void(std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)>\n+    >::value\n+  >\n+>\n+{\n+  using callback_type =\n+    std::function<void (std::shared_ptr<MessageT>, const rclcpp::MessageInfo &)>;\n+};\n+\n+}  // namespace detail\n+}  // namespace rclcpp\n+\n+#endif  // RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_"},{"role":"user","content":"+namespace detail\n+{\n+\n+template<typename ReturnTypeT, typename ... Args>\n+struct as_std_function_helper;\n+\n+template<typename ReturnTypeT, typename ... Args>\n+struct as_std_function_helper<ReturnTypeT, std::tuple<Args ...>>\n+{\n+  using type = std::function<ReturnTypeT(Args ...)>;\n+};\n+\n+}  // namespace detail\n+\n+template<\n+  typename FunctorT,\n+  typename FunctionTraits = function_traits<FunctorT>\n+>\n+struct as_std_function\n+{\n+  using type = typename detail::as_std_function_helper<\n+    typename FunctionTraits::return_type,\n+    typename FunctionTraits::arguments\n+    >::type;\n+};\n+"},{"role":"user","content":"-    std::function<void (const rcl_interfaces::msg::ParameterEvent::SharedPtr &)>;\n+    std::function<void (const rcl_interfaces::msg::ParameterEvent &)>;"},{"role":"user","content":"- *     [fqn, remote_param_name, &node](const rcl_interfaces::msg::ParameterEvent::SharedPtr & event) {\n+ *     [fqn, remote_param_name, &node](const rcl_interfaces::msg::ParameterEvent & event) {"},{"role":"user","content":"- *       if (regex_match(event->node, re)) {\n+ *       if (regex_match(event.node, re)) {"},{"role":"user","content":"- *             *event, p, remote_param_name, fqn))\n+ *             event, p, remote_param_name, fqn))"},{"role":"user","content":"- *         auto params = rclcpp::ParameterEventsSubscriber::get_parameters_from_event(*event);\n+ *         auto params = rclcpp::ParameterEventsSubscriber::get_parameters_from_event(event);"},{"role":"user","content":"-  event_callback(const rcl_interfaces::msg::ParameterEvent::SharedPtr event);\n+  event_callback(const rcl_interfaces::msg::ParameterEvent & event);"},{"role":"user","content":"-  using EventPair = std::pair<EventType, rcl_interfaces::msg::Parameter *>;\n+  using EventPair = std::pair<EventType, const rcl_interfaces::msg::Parameter *>;"},{"role":"user","content":"-    rcl_interfaces::msg::ParameterEvent::SharedPtr event,\n+    std::shared_ptr<const rcl_interfaces::msg::ParameterEvent> event,"},{"role":"user","content":"-  rcl_interfaces::msg::ParameterEvent::SharedPtr event_;  ///< Keep event in scope\n+  std::shared_ptr<const rcl_interfaces::msg::ParameterEvent> event_;  ///< Keep event in scope"},{"role":"user","content":"-  AnySubscriptionCallback<CallbackMessageT, AllocatorT> any_subscription_callback(allocator);\n+  AnySubscriptionCallback<CallbackMessageT, AllocatorT> any_subscription_callback(*allocator);"},{"role":"user","content":"-  using type = typename std::remove_cv<MessageT>::type;\n+  using type = typename std::remove_cv_t<std::remove_reference_t<MessageT>>;"},{"role":"user","content":"-  void clock_cb(const rosgraph_msgs::msg::Clock::SharedPtr msg);\n+  void clock_cb(std::shared_ptr<const rosgraph_msgs::msg::Clock> msg);"},{"role":"user","content":"-  void on_parameter_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event);\n+  void on_parameter_event(std::shared_ptr<const rcl_interfaces::msg::ParameterEvent> event);"},{"role":"user","content":"-  rosgraph_msgs::msg::Clock::SharedPtr last_msg_set_;\n+  std::shared_ptr<const rosgraph_msgs::msg::Clock> last_msg_set_;"},{"role":"user","content":"-struct HandleCompare\n-  : public std::unary_function<OnSetParametersCallbackHandle::WeakPtr, bool>\n-{\n-  explicit HandleCompare(const OnSetParametersCallbackHandle * const base)\n-  : base_(base) {}\n-  bool operator()(const OnSetParametersCallbackHandle::WeakPtr & handle)\n-  {\n-    auto shared_handle = handle.lock();\n-    if (base_ == shared_handle.get()) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  const OnSetParametersCallbackHandle * const base_;\n-};\n-"},{"role":"user","content":"-    HandleCompare(handle));\n+    [handle](const auto & weak_handle) {\n+      return handle == weak_handle.lock().get();\n+    });"},{"role":"user","content":"-template<typename CallbackHandleT>\n-struct HandleCompare\n-  : public std::unary_function<typename CallbackHandleT::WeakPtr, bool>\n-{\n-  explicit HandleCompare(const CallbackHandleT * const base)\n-  : base_(base) {}\n-  bool operator()(const typename CallbackHandleT::WeakPtr & handle)\n-  {\n-    auto shared_handle = handle.lock();\n-    if (base_ == shared_handle.get()) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  const CallbackHandleT * const base_;\n-};\n-"},{"role":"user","content":"-    HandleCompare<ParameterEventCallbackHandle>(callback_handle.get()));\n+    [callback_handle](const auto & weak_handle) {\n+      return callback_handle.get() == weak_handle.lock().get();\n+    });"},{"role":"user","content":"-    HandleCompare<ParameterCallbackHandle>(handle));\n+    [handle](const auto & weak_handle) {\n+      return handle == weak_handle.lock().get();\n+    });"},{"role":"user","content":"-ParameterEventHandler::event_callback(\n-  const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n+ParameterEventHandler::event_callback(const rcl_interfaces::msg::ParameterEvent & event)"},{"role":"user","content":"-    if (get_parameter_from_event(*event, p, it->first.first, it->first.second)) {\n+    if (get_parameter_from_event(event, p, it->first.first, it->first.second)) {"},{"role":"user","content":"+#include <memory>"},{"role":"user","content":"-  rcl_interfaces::msg::ParameterEvent::SharedPtr event,\n+  std::shared_ptr<const rcl_interfaces::msg::ParameterEvent> event,"},{"role":"user","content":"-void TimeSource::clock_cb(const rosgraph_msgs::msg::Clock::SharedPtr msg)\n+void TimeSource::clock_cb(std::shared_ptr<const rosgraph_msgs::msg::Clock> msg)"},{"role":"user","content":"-void TimeSource::on_parameter_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n+void TimeSource::on_parameter_event(\n+  std::shared_ptr<const rcl_interfaces::msg::ParameterEvent> event)"},{"role":"user","content":"-      auto callback = [this](test_msgs::msg::Empty::SharedPtr) {this->callback_count++;};\n+      auto callback = [this](test_msgs::msg::Empty::ConstSharedPtr) {this->callback_count++;};"},{"role":"user","content":"-    auto callback = [this](test_msgs::msg::Empty::SharedPtr) {this->callback_count++;};\n+    auto callback = [this](test_msgs::msg::Empty::ConstSharedPtr) {this->callback_count++;};"},{"role":"user","content":"-    \"topic\", rclcpp::QoS(10), [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", rclcpp::QoS(10), [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", rclcpp::QoS(10), [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", rclcpp::QoS(10), [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-    auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+    auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-    auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+    auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"+#include <string>"},{"role":"user","content":"-  TestAnySubscriptionCallback()\n-  : allocator_(std::make_shared<std::allocator<void>>()),\n-    any_subscription_callback_(allocator_) {}\n-  void SetUp()\n+  TestAnySubscriptionCallback() {}\n+\n+  static\n+  std::unique_ptr<test_msgs::msg::Empty>\n+  get_unique_ptr_msg()"},{"role":"user","content":"-    msg_shared_ptr_ = std::make_shared<test_msgs::msg::Empty>();\n-    msg_const_shared_ptr_ = std::make_shared<const test_msgs::msg::Empty>();\n-    msg_unique_ptr_ = std::make_unique<test_msgs::msg::Empty>();\n+    return std::make_unique<test_msgs::msg::Empty>();"},{"role":"user","content":"-  std::shared_ptr<std::allocator<void>> allocator_;\n-  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty, std::allocator<void>>\n-  any_subscription_callback_;\n-\n-  std::shared_ptr<test_msgs::msg::Empty> msg_shared_ptr_;\n-  std::shared_ptr<const test_msgs::msg::Empty> msg_const_shared_ptr_;\n-  std::unique_ptr<test_msgs::msg::Empty> msg_unique_ptr_;\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> any_subscription_callback_;\n+  std::shared_ptr<test_msgs::msg::Empty> msg_shared_ptr_{std::make_shared<test_msgs::msg::Empty>()};"},{"role":"user","content":"+// suppress deprecated function warning\n+#if !defined(_WIN32)\n+# pragma GCC diagnostic push\n+# pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n+#else  // !defined(_WIN32)\n+# pragma warning(push)\n+# pragma warning(disable: 4996)\n+#endif\n+"},{"role":"user","content":"-  rclcpp::AnySubscriptionCallback<\n-    test_msgs::msg::Empty, std::allocator<void>> any_subscription_callback_(nullptr);\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> any_subscription_callback(nullptr);\n+\n+// remove warning suppression\n+#if !defined(_WIN32)\n+# pragma GCC diagnostic pop\n+#else  // !defined(_WIN32)\n+# pragma warning(pop)\n+#endif"},{"role":"user","content":"-TEST(AnySubscription, null_allocator) {\n+TEST(AnySubscriptionCallback, null_allocator) {"},{"role":"user","content":"+  // Default constructor.\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> asc1;\n+\n+  // Constructor with allocator.\n+  std::allocator<void> allocator;\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> asc2(allocator);"},{"role":"user","content":"-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n+    any_subscription_callback_.dispatch_intra_process(msg_shared_ptr_, message_info_),"},{"role":"user","content":"-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n+    any_subscription_callback_.dispatch_intra_process(get_unique_ptr_msg(), message_info_),"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_shared_ptr) {\n-  int callback_count = 0;\n-  auto shared_ptr_callback = [&callback_count](\n-    const std::shared_ptr<test_msgs::msg::Empty>) {\n-      callback_count++;\n-    };\n-\n-  any_subscription_callback_.set(shared_ptr_callback);\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+//\n+// Parameterized test to test across all callback types and dispatch types.\n+//"},{"role":"user","content":"-  // Can't convert ConstSharedPtr to SharedPtr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n+class InstanceContextImpl\n+{\n+public:\n+  InstanceContextImpl() = default;\n+  virtual ~InstanceContextImpl() = default;"},{"role":"user","content":"-  // Promotes Unique into SharedPtr\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n+  explicit InstanceContextImpl(rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> asc)\n+  : any_subscription_callback_(asc)\n+  {}"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_shared_ptr_w_info) {\n-  int callback_count = 0;\n-  auto shared_ptr_w_info_callback = [&callback_count](\n-    const std::shared_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {\n-      callback_count++;\n-    };\n+  virtual\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>\n+  get_any_subscription_callback_to_test() const\n+  {\n+    return any_subscription_callback_;\n+  }"},{"role":"user","content":"-  any_subscription_callback_.set(shared_ptr_w_info_callback);\n+protected:\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> any_subscription_callback_;\n+};"},{"role":"user","content":"-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+class InstanceContext\n+{\n+public:\n+  InstanceContext(const std::string & name, std::shared_ptr<InstanceContextImpl> impl)\n+  : name(name), impl_(impl)\n+  {}"},{"role":"user","content":"-  // Can't convert ConstSharedPtr to SharedPtr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n+  InstanceContext(\n+    const std::string & name,\n+    rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty> asc)\n+  : name(name), impl_(std::make_shared<InstanceContextImpl>(asc))\n+  {}"},{"role":"user","content":"-  // Promotes Unique into SharedPtr\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n+  InstanceContext(const InstanceContext & other)\n+  : InstanceContext(other.name, other.impl_) {}"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_const_shared_ptr) {\n-  int callback_count = 0;\n-  auto const_shared_ptr_callback = [&callback_count](\n-    std::shared_ptr<const test_msgs::msg::Empty>) {\n-      callback_count++;\n-    };\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>\n+  get_any_subscription_callback_to_test() const\n+  {\n+    return impl_->get_any_subscription_callback_to_test();\n+  }"},{"role":"user","content":"-  any_subscription_callback_.set(const_shared_ptr_callback);\n+  std::string name;"},{"role":"user","content":"-  // Ok to promote shared_ptr to ConstSharedPtr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+protected:\n+  std::shared_ptr<InstanceContextImpl> impl_;\n+};"},{"role":"user","content":"-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 2);\n+class DispatchTests\n+  : public TestAnySubscriptionCallback,\n+  public ::testing::WithParamInterface<InstanceContext>\n+{};"},{"role":"user","content":"-  // Not allowed to convert unique_ptr to const shared_ptr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 2);\n+auto\n+format_parameter(const ::testing::TestParamInfo<DispatchTests::ParamType> & info)\n+{\n+  return info.param.name;"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_const_shared_ptr_w_info) {\n-  int callback_count = 0;\n-  auto const_shared_ptr_callback = [&callback_count](\n-    std::shared_ptr<const test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {\n-      callback_count++;\n-    };\n-\n-  any_subscription_callback_.set(\n-    std::move(const_shared_ptr_callback));\n-\n-  // Ok to promote shared_ptr to ConstSharedPtr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+// Testing dispatch with shared_ptr<MessageT> as input\n+TEST_P(DispatchTests, test_inter_shared_dispatch) {\n+  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n+  any_subscription_callback_to_test.dispatch(msg_shared_ptr_, message_info_);\n+}"},{"role":"user","content":"-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 2);\n+// Testing dispatch with shared_ptr<const MessageT> as input\n+TEST_P(DispatchTests, test_intra_shared_dispatch) {\n+  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n+  any_subscription_callback_to_test.dispatch_intra_process(msg_shared_ptr_, message_info_);\n+}"},{"role":"user","content":"-  // Not allowed to convert unique_ptr to const shared_ptr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 2);\n+// Testing dispatch with unique_ptr<MessageT> as input\n+TEST_P(DispatchTests, test_intra_unique_dispatch) {\n+  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n+  any_subscription_callback_to_test.dispatch_intra_process(get_unique_ptr_msg(), message_info_);"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_unique_ptr) {\n-  int callback_count = 0;\n-  auto unique_ptr_callback = [&callback_count](\n-    std::unique_ptr<test_msgs::msg::Empty>) {\n-      callback_count++;\n-    };\n+// Generic classes for testing callbacks using std::bind to class methods.\n+template<typename ... CallbackArgs>\n+class BindContextImpl : public InstanceContextImpl\n+{\n+  static constexpr size_t number_of_callback_args{sizeof...(CallbackArgs)};"},{"role":"user","content":"-  any_subscription_callback_.set(unique_ptr_callback);\n+public:\n+  using InstanceContextImpl::InstanceContextImpl;\n+  virtual ~BindContextImpl() = default;"},{"role":"user","content":"-  // Message is copied into unique_ptr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+  void on_message(CallbackArgs ...) const {}"},{"role":"user","content":"-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n+  rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>\n+  get_any_subscription_callback_to_test() const override\n+  {\n+    if constexpr (number_of_callback_args == 1) {\n+      return rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        std::bind(&BindContextImpl::on_message, this, std::placeholders::_1)\n+      );\n+    } else {\n+      return rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        std::bind(&BindContextImpl::on_message, this, std::placeholders::_1, std::placeholders::_2)\n+      );\n+    }\n+  }\n+};"},{"role":"user","content":"-  // Unique_ptr is_moved\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n+template<typename ... CallbackArgs>\n+class BindContext : public InstanceContext\n+{\n+public:\n+  explicit BindContext(const std::string & name)\n+  : InstanceContext(name, std::make_shared<BindContextImpl<CallbackArgs ...>>())\n+  {}\n+};"},{"role":"user","content":"-TEST_F(TestAnySubscriptionCallback, set_dispatch_unique_ptr_w_info) {\n-  int callback_count = 0;\n-  auto unique_ptr_callback = [&callback_count](\n-    std::unique_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {\n-      callback_count++;\n-    };\n+//\n+// Versions of `const MessageT &`\n+//\n+void const_ref_free_func(const test_msgs::msg::Empty &) {}\n+void const_ref_w_info_free_func(const test_msgs::msg::Empty &, const rclcpp::MessageInfo &) {}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  ConstRefCallbackTests,\n+  DispatchTests,\n+  ::testing::Values(\n+    // lambda\n+    InstanceContext{\"lambda\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](const test_msgs::msg::Empty &) {})},\n+    InstanceContext{\"lambda_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](const test_msgs::msg::Empty &, const rclcpp::MessageInfo &) {})},\n+    // free function\n+    InstanceContext{\"free_function\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        const_ref_free_func)},\n+    InstanceContext{\"free_function_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        const_ref_w_info_free_func)},\n+    // bind function\n+    BindContext<const test_msgs::msg::Empty &>(\"bind_method\"),\n+    BindContext<const test_msgs::msg::Empty &, const rclcpp::MessageInfo &>(\n+      \"bind_method_with_info\")\n+  ),\n+  format_parameter\n+);"},{"role":"user","content":"-  any_subscription_callback_.set(unique_ptr_callback);\n+//\n+// Versions of `std::unique_ptr<MessageT, MessageDeleter>`\n+//\n+void unique_ptr_free_func(std::unique_ptr<test_msgs::msg::Empty>) {}\n+void unique_ptr_w_info_free_func(\n+  std::unique_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &)\n+{}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  UniquePtrCallbackTests,\n+  DispatchTests,\n+  ::testing::Values(\n+    // lambda\n+    InstanceContext{\"lambda\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::unique_ptr<test_msgs::msg::Empty>) {})},\n+    InstanceContext{\"lambda_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::unique_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {})},\n+    // free function\n+    InstanceContext{\"free_function\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        unique_ptr_free_func)},\n+    InstanceContext{\"free_function_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        unique_ptr_w_info_free_func)},\n+    // bind function\n+    BindContext<std::unique_ptr<test_msgs::msg::Empty>>(\"bind_method\"),\n+    BindContext<std::unique_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &>(\n+      \"bind_method_with_info\")\n+  ),\n+  format_parameter\n+);"},{"role":"user","content":"-  // Message is copied into unique_ptr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n+//\n+// Versions of `std::shared_ptr<const MessageT>`\n+//\n+void shared_const_ptr_free_func(std::shared_ptr<const test_msgs::msg::Empty>) {}\n+void shared_const_ptr_w_info_free_func(\n+  std::shared_ptr<const test_msgs::msg::Empty>, const rclcpp::MessageInfo &)\n+{}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  SharedConstPtrCallbackTests,\n+  DispatchTests,\n+  ::testing::Values(\n+    // lambda\n+    InstanceContext{\"lambda\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::shared_ptr<const test_msgs::msg::Empty>) {})},\n+    InstanceContext{\"lambda_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::shared_ptr<const test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {})},\n+    // free function\n+    InstanceContext{\"free_function\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        shared_const_ptr_free_func)},\n+    InstanceContext{\"free_function_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        shared_const_ptr_w_info_free_func)},\n+    // bind function\n+    BindContext<std::shared_ptr<const test_msgs::msg::Empty>>(\"bind_method\"),\n+    BindContext<std::shared_ptr<const test_msgs::msg::Empty>, const rclcpp::MessageInfo &>(\n+      \"bind_method_with_info\")\n+  ),\n+  format_parameter\n+);"},{"role":"user","content":"-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n+//\n+// Versions of `const std::shared_ptr<const MessageT> &`\n+//\n+void const_ref_shared_const_ptr_free_func(const std::shared_ptr<const test_msgs::msg::Empty> &) {}\n+void const_ref_shared_const_ptr_w_info_free_func(\n+  const std::shared_ptr<const test_msgs::msg::Empty> &, const rclcpp::MessageInfo &)\n+{}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  ConstRefSharedConstPtrCallbackTests,\n+  DispatchTests,\n+  ::testing::Values(\n+    // lambda\n+    InstanceContext{\"lambda\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](const std::shared_ptr<const test_msgs::msg::Empty> &) {})},\n+    InstanceContext{\"lambda_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](const std::shared_ptr<const test_msgs::msg::Empty> &, const rclcpp::MessageInfo &) {})},\n+    // free function\n+    InstanceContext{\"free_function\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        const_ref_shared_const_ptr_free_func)},\n+    InstanceContext{\"free_function_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        const_ref_shared_const_ptr_w_info_free_func)},\n+    // bind function\n+    BindContext<const std::shared_ptr<const test_msgs::msg::Empty> &>(\"bind_method\"),\n+    BindContext<const std::shared_ptr<const test_msgs::msg::Empty> &, const rclcpp::MessageInfo &>(\n+      \"bind_method_with_info\")\n+  ),\n+  format_parameter\n+);"},{"role":"user","content":"-  // Unique_ptr is_moved\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n+//\n+// Versions of `std::shared_ptr<MessageT>`\n+//\n+void shared_ptr_free_func(std::shared_ptr<test_msgs::msg::Empty>) {}\n+void shared_ptr_w_info_free_func(\n+  std::shared_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &)\n+{}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  SharedPtrCallbackTests,\n+  DispatchTests,\n+  ::testing::Values(\n+    // lambda\n+    InstanceContext{\"lambda\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::shared_ptr<test_msgs::msg::Empty>) {})},\n+    InstanceContext{\"lambda_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        [](std::shared_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &) {})},\n+    // free function\n+    InstanceContext{\"free_function\", rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        shared_ptr_free_func)},\n+    InstanceContext{\"free_function_with_info\",\n+      rclcpp::AnySubscriptionCallback<test_msgs::msg::Empty>().set(\n+        shared_ptr_w_info_free_func)},\n+    // bind function\n+    BindContext<std::shared_ptr<test_msgs::msg::Empty>>(\"bind_method\"),\n+    BindContext<std::shared_ptr<test_msgs::msg::Empty>, const rclcpp::MessageInfo &>(\n+      \"bind_method_with_info\")\n+  ),\n+  format_parameter\n+);"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+      auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+      auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  auto callback = [](const test_msgs::msg::BasicTypes::SharedPtr msg) {\n+  auto callback = [](test_msgs::msg::BasicTypes::ConstSharedPtr msg) {"},{"role":"user","content":"-  void OnMessage(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n+  void OnMessage(rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)"},{"role":"user","content":"-  void test_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n+  void test_event(rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)"},{"role":"user","content":"-    event_callback(event);\n+    event_callback(*event);"},{"role":"user","content":"-      this](const rcl_interfaces::msg::ParameterEvent::SharedPtr & event)\n+      this](const rcl_interfaces::msg::ParameterEvent & event)"},{"role":"user","content":"-      if (event->node == node_name) {\n+      if (event.node == node_name) {"},{"role":"user","content":"-      if (ParameterEventHandler::get_parameter_from_event(*event, p, \"my_int\", node_name)) {\n+      if (ParameterEventHandler::get_parameter_from_event(event, p, \"my_int\", node_name)) {"},{"role":"user","content":"-        p = ParameterEventHandler::get_parameter_from_event(*event, \"my_double\", node_name);\n+        p = ParameterEventHandler::get_parameter_from_event(event, \"my_double\", node_name);"},{"role":"user","content":"-    [&bool_param, this](const rcl_interfaces::msg::ParameterEvent::SharedPtr & event)\n+    [&bool_param, this](const rcl_interfaces::msg::ParameterEvent & event)"},{"role":"user","content":"-      if (event->node == diff_ns_name) {\n+      if (event.node == diff_ns_name) {"},{"role":"user","content":"-            *event, p, \"my_bool\", diff_ns_name))\n+            event, p, \"my_bool\", diff_ns_name))"},{"role":"user","content":"-    [this, &time_1](const rcl_interfaces::msg::ParameterEvent::SharedPtr &)\n+    [this, &time_1](const rcl_interfaces::msg::ParameterEvent &)"},{"role":"user","content":"-    [this, &time_2](const rcl_interfaces::msg::ParameterEvent::SharedPtr &)\n+    [this, &time_2](const rcl_interfaces::msg::ParameterEvent &)"},{"role":"user","content":"-  static void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-    message_callback = [node = node.get()](const test_msgs::msg::Empty::SharedPtr /*msg*/) {\n+    message_callback = [node = node.get()](test_msgs::msg::Empty::ConstSharedPtr /*msg*/) {"},{"role":"user","content":"-  std::function<void(const test_msgs::msg::Empty::SharedPtr)> message_callback;\n+  std::function<void(test_msgs::msg::Empty::ConstSharedPtr)> message_callback;"},{"role":"user","content":"-    [](std::shared_ptr<test_msgs::msg::Empty> test_msg) {(void) test_msg;});\n+    [](std::shared_ptr<const test_msgs::msg::Empty> test_msg) {(void) test_msg;});"},{"role":"user","content":"-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-  auto callback = [](const Empty::SharedPtr msg) {\n+  auto callback = [](Empty::ConstSharedPtr msg) {"},{"role":"user","content":"-    EXPECT_FALSE(sub->use_take_shared_method());\n+    EXPECT_TRUE(sub->use_take_shared_method());"},{"role":"user","content":"-  auto callback = [](const Empty::SharedPtr msg) {\n+  auto callback = [](Empty::ConstSharedPtr msg) {"},{"role":"user","content":"-  auto cb = [](test_msgs::msg::Empty::SharedPtr) {};\n+  auto cb = [](test_msgs::msg::Empty::ConstSharedPtr) {};"},{"role":"user","content":"-  static void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n+  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)"},{"role":"user","content":"-    auto do_nothing = [](const std::shared_ptr<test_msgs::msg::BasicTypes>) {};\n+    auto do_nothing = [](std::shared_ptr<const test_msgs::msg::BasicTypes>) {};"},{"role":"user","content":"-  auto do_nothing = [](const std::shared_ptr<test_msgs::msg::BasicTypes>) {};\n+  auto do_nothing = [](std::shared_ptr<const test_msgs::msg::BasicTypes>) {};"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {}, options);\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {}, options);"},{"role":"user","content":"-      \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+      \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {}, options);\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {}, options);"},{"role":"user","content":"-      \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+      \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"user","content":"-    \"topic\", 10, [](test_msgs::msg::Empty::SharedPtr) {});\n+    \"topic\", 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#if defined(_MSC_VER)\n+#include <BaseTsd.h>\n+typedef SSIZE_T ssize_t;\n+#endif\n+"},{"role":"user","content":"+RMW_GURUMDDS_SHARED_CPP_PUBLIC"},{"role":"user","content":"+RMW_GURUMDDS_SHARED_CPP_PUBLIC"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+int8 STATUS_UNKNOWN = -2        # status is not yet set"},{"role":"user","content":"-int8 status\n+int8 status -2 # STATUS_UNKNOWN"},{"role":"user","content":"+uint16 SERVICE_UNKNOWN = 0  # Remember service is a bitfield, so checking (service & SERVICE_UNKNOWN) will not work. Use == instead."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        # skip zenoh because of the QoS compatibility\n+        if rmw_implementation == 'rmw_zenoh_cpp':\n+            raise unittest.SkipTest()\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-set(RVIZ_VERSION \"Alpha\")\n-set(ROS_DISTRO \"ROS 2.0\")\n+ament_package_xml()\n+set(RVIZ_VERSION \"${rviz_common_VERSION}\")\n+set(ROS_DISTRO \"ROS 2\")"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+\n+#pragma warning(push)\n+#pragma warning(disable : 5105)"},{"role":"user","content":"+#pragma warning(pop)"},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)"},{"role":"user","content":"+#pragma warning(pop)"},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+# pragma warning(push)\n+# pragma warning(disable : 5105)"},{"role":"user","content":"+# pragma warning(pop)"},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)"},{"role":"user","content":"+#pragma warning(pop)"},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)"},{"role":"user","content":"+#pragma warning(pop)"},{"role":"user","content":"+// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n+// there appears to be a problem with winbase.h (which is included by\n+// Windows.h).  In particular, warnings of the form:\n+//\n+// warning C5105: macro expansion producing 'defined' has undefined behavior\n+//\n+// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n+// for more information.  For now disable that warning when including windows.h\n+#pragma warning(push)\n+#pragma warning(disable : 5105)"},{"role":"user","content":"+#pragma warning(pop)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  ament_target_dependencies(test_publisher_with_type_adapter\n-    \"rcutils\"\n-    \"rcl_interfaces\"\n-    \"rmw\"\n-    \"rosidl_runtime_cpp\"\n-    \"rosidl_typesupport_cpp\"\n-    \"test_msgs\"\n-  )"},{"role":"user","content":"-    mimick"},{"role":"user","content":"-  ament_target_dependencies(test_subscription_with_type_adapter\n-    \"rcutils\"\n-    \"rcl_interfaces\"\n-    \"rmw\"\n-    \"rosidl_runtime_cpp\"\n-    \"rosidl_typesupport_cpp\"\n-    \"test_msgs\"\n-  )"},{"role":"user","content":"-    mimick"},{"role":"user","content":"-#include <functional>"},{"role":"user","content":"-#include <vector>"},{"role":"user","content":"-#include \"../mocking_utils/patch.hpp\"\n-#include \"../utils/rclcpp_gtest_macros.hpp\"\n-\n-#include \"test_msgs/msg/empty.hpp\""},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-"},{"role":"user","content":"-protected:\n-  void initialize(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions())\n-  {\n-    node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", node_options);\n-  }\n-\n-  void TearDown()\n-  {\n-    node.reset();\n-  }\n-\n-  rclcpp::Node::SharedPtr node;\n-};\n-\n-class CLASSNAME (test_intra_process_within_one_node, RMW_IMPLEMENTATION) : public ::testing::Test\n-{\n-public:\n-  static void SetUpTestCase()\n-  {\n-    rclcpp::init(0, nullptr);\n-  }\n-"},{"role":"user","content":"-    throw std::runtime_error(\"This should happen\");\n+    throw std::runtime_error(\"This should not happen\");"},{"role":"user","content":"-    initialize(options);\n+    auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", options);"},{"role":"user","content":"-    initialize(options);\n+    auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", options);"},{"role":"user","content":"-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n+  TestPublisher,"},{"role":"user","content":"-  initialize();\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", rclcpp::NodeOptions());"},{"role":"user","content":"-#include <functional>"},{"role":"user","content":"-#include <utility>\n-#include <vector>"},{"role":"user","content":"-#include \"rclcpp/loaned_message.hpp\""},{"role":"user","content":"-#include \"../mocking_utils/patch.hpp\"\n-#include \"../utils/rclcpp_gtest_macros.hpp\"\n-\n-#include \"test_msgs/msg/empty.hpp\""},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-"},{"role":"user","content":"-public:\n-  static void SetUpTestCase()\n-  {\n-    if (!rclcpp::ok()) {\n-      rclcpp::init(0, nullptr);\n-    }\n-  }\n-\n-protected:\n-  void initialize(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions())\n-  {\n-    node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", node_options);\n-  }\n-\n-  void TearDown()\n-  {\n-    node.reset();\n-  }\n-\n-  rclcpp::Node::SharedPtr node;\n-};\n-\n-class CLASSNAME (test_intra_process_within_one_node, RMW_IMPLEMENTATION) : public ::testing::Test\n-{"},{"role":"user","content":"-  initialize();\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\", rclcpp::NodeOptions());"},{"role":"user","content":"-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n+  TestSubscription,"},{"role":"user","content":"-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n+  TestSubscription,"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-      entities_need_rebuild_ = false;"},{"role":"user","content":"+  // If this spin is not exhaustive (e.g. spin_some), we need to explicitly check\n+  // if entities need to be rebuilt here rather than letting the notify waitable event do it.\n+  // A non-exhaustive spin would not check for work a second time, thus delaying the execution\n+  // of some entities to the next invocation of spin.\n+  if (!exhaustive) {\n+    this->handle_updated_entities(false);\n+  }\n+"},{"role":"user","content":"+\n+  // Do not rebuild if we don't need to.\n+  // A rebuild event could be generated, but then\n+  // this function could end up being called from somewhere else\n+  // before that event gets processed, for example if\n+  // a node or callback group is manually added to the executor.\n+  const bool notify_waitable_triggered = entities_need_rebuild_.exchange(false);\n+  if (!notify_waitable_triggered && !this->collector_.has_pending()) {\n+    return;\n+  }\n+"},{"role":"user","content":"+ament_add_gtest(\n+  test_executors_warmup\n+  executors/test_executors_warmup.cpp\n+  executors/test_waitable.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\"\n+  TIMEOUT 180)\n+if(TARGET test_executors_warmup)\n+  target_link_libraries(test_executors_warmup ${PROJECT_NAME} ${test_msgs_TARGETS})\n+endif()\n+"},{"role":"user","content":"+// Copyright 2024 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/**\n+ * This test checks all implementations of rclcpp::executor to check they pass they basic API\n+ * tests. Anything specific to any executor in particular should go in a separate test file.\n+ */\n+\n+#include <gtest/gtest.h>\n+\n+#include <chrono>\n+#include <cstddef>\n+#include <memory>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+#include \"test_msgs/msg/empty.hpp\"\n+\n+#include \"./executor_types.hpp\"\n+\n+using namespace std::chrono_literals;\n+\n+template<typename T>\n+class TestExecutorsWarmup : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestExecutorsWarmup, ExecutorTypes, ExecutorTypeNames);\n+\n+// This test verifies that spin_all is correctly collecting work multiple times\n+// even when one of the items of work is a notifier waitable event and thus results in\n+// rebuilding the entities collection.\n+// When spin_all goes back to collect more work, it should see the ready items from\n+// the new added entities\n+TYPED_TEST(TestExecutorsWarmup, spin_all_doesnt_require_warmup)\n+{\n+  using ExecutorType = TypeParam;\n+  ExecutorType executor;\n+\n+  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n+  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"test_node\", node_options);\n+\n+  // Add node to the executor before creating the entities\n+  executor.add_node(node);\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback));\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // We need to select a duration that is greater than\n+  // the time taken to refresh the entities collection and rebuild the waitset.\n+  // spin-all is expected to process the notifier waitable event, rebuild the collection,\n+  // and then collect more work, finding the subscription message event.\n+  // This duration has been selected empirically.\n+  executor.spin_all(std::chrono::milliseconds(500));\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}\n+\n+// Same test as `spin_all_doesnt_require_warmup`, but uses a callback group\n+// This test reproduces the bug reported by https://github.com/ros2/rclcpp/issues/2589\n+TYPED_TEST(TestExecutorsWarmup, spin_all_doesnt_require_warmup_with_cbgroup)\n+{\n+  using ExecutorType = TypeParam;\n+\n+  // TODO(alsora): Enable when https://github.com/ros2/rclcpp/pull/2595 gets merged\n+  if (\n+    std::is_same<ExecutorType, rclcpp::executors::SingleThreadedExecutor>() ||\n+    std::is_same<ExecutorType, rclcpp::executors::MultiThreadedExecutor>())\n+  {\n+    GTEST_SKIP();\n+  }\n+\n+  ExecutorType executor;\n+\n+  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n+  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"test_node\", node_options);\n+\n+  auto callback_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive,\n+    false);\n+\n+  // Add callback group to the executor before creating the entities\n+  executor.add_callback_group(callback_group, node->get_node_base_interface());\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  rclcpp::SubscriptionOptions sub_options;\n+  sub_options.callback_group = callback_group;\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback), sub_options);\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // We need to select a duration that is greater than\n+  // the time taken to refresh the entities collection and rebuild the waitset.\n+  // spin-all is expected to process the notifier waitable event, rebuild the collection,\n+  // and then collect more work, finding the subscription message event.\n+  // This duration has been selected empirically.\n+  executor.spin_all(std::chrono::milliseconds(500));\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}\n+\n+TYPED_TEST(TestExecutorsWarmup, spin_some_doesnt_require_warmup)\n+{\n+  using ExecutorType = TypeParam;\n+\n+  // TODO(alsora): currently only the events-executor passes this test.\n+  // Enable single-threaded and multi-threaded executors\n+  // when https://github.com/ros2/rclcpp/pull/2595 gets merged\n+  if (\n+    !std::is_same<ExecutorType, rclcpp::experimental::executors::EventsExecutor>())\n+  {\n+    GTEST_SKIP();\n+  }\n+\n+  ExecutorType executor;\n+\n+  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n+  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"test_node\", node_options);\n+\n+  // Add node to the executor before creating the entities\n+  executor.add_node(node);\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback));\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n+  // the new message, no risk of race conditions where spin_some gets called before the\n+  // message has been delivered.\n+  executor.spin_some();\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}\n+\n+TYPED_TEST(TestExecutorsWarmup, spin_some_doesnt_require_warmup_with_cbgroup)\n+{\n+  using ExecutorType = TypeParam;\n+\n+  // TODO(alsora): currently only the events-executor passes this test.\n+  // Enable single-threaded and multi-threaded executors\n+  // when https://github.com/ros2/rclcpp/pull/2595 gets merged\n+  if (\n+    !std::is_same<ExecutorType, rclcpp::experimental::executors::EventsExecutor>())\n+  {\n+    GTEST_SKIP();\n+  }\n+\n+  ExecutorType executor;\n+\n+  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n+  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"test_node\", node_options);\n+\n+  auto callback_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive,\n+    false);\n+\n+  // Add callback group to the executor before creating the entities\n+  executor.add_callback_group(callback_group, node->get_node_base_interface());\n+\n+  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n+  // the entities collection\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"test_topic\", rclcpp::QoS(10));\n+  size_t callback_count = 0;\n+  auto callback = [&callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count++;};\n+  rclcpp::SubscriptionOptions sub_options;\n+  sub_options.callback_group = callback_group;\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"test_topic\", rclcpp::QoS(10), std::move(callback), sub_options);\n+\n+  ASSERT_EQ(callback_count, 0u);\n+\n+  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n+  publisher->publish(test_msgs::msg::Empty());\n+\n+  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n+  // the new message, no risk of race conditions where spin_some gets called before the\n+  // message has been delivered.\n+  executor.spin_some();\n+\n+  // Verify that the callback is called as part of the spin above\n+  EXPECT_EQ(callback_count, 1u);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    max_wait_time: float | None,\n+    max_wait_time: Optional[float],"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-The current version can be found in its [package.xml](rmw_implementation/package.xml), and its change history can be found in its [CHANGELOG](rmw_implementation/CHANGELOG.rst).\n+The current version can be found in its [package.xml](./package.xml), and its change history can be found in its [CHANGELOG](./CHANGELOG.rst)."},{"role":"user","content":"+"},{"role":"user","content":"-This package has a confirmation of contributor origin policy, which can be found in [CONTRIBUTING](./CONTRIBUTING.md).\n+This package has a confirmation of contributor origin policy, which can be found in [CONTRIBUTING](../CONTRIBUTING.md)."},{"role":"user","content":"-The license for `rmw_implementation` is Apache 2.0, and a summary is in each source file, the type is declared in the [package.xml](rmw_implementation/package.xml) manifest file, and a full copy of the license is in the [LICENSE](./LICENSE) file.\n+The license for `rmw_implementation` is Apache 2.0, and a summary is in each source file, the type is declared in the [package.xml](./package.xml) manifest file, and a full copy of the license is in the [LICENSE](../LICENSE) file."},{"role":"user","content":"-The chart below compares the requirements in the REP-2004 with the current state of the rcutils package.\n+The chart below compares the requirements in the REP-2004 with the current state of the rmw_implementation package."},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"rclcpp/logging.hpp\""},{"role":"user","content":"-  number_of_threads_ = number_of_threads ? number_of_threads : std::thread::hardware_concurrency();\n-  if (number_of_threads_ == 0) {\n-    number_of_threads_ = 1;\n+  number_of_threads_ = number_of_threads > 0 ?\n+    number_of_threads :\n+    std::max(std::thread::hardware_concurrency(), 2U);\n+\n+  if (number_of_threads_ == 1) {\n+    RCLCPP_WARN(\n+      rclcpp::get_logger(\"rclcpp\"),\n+      \"MultiThreadedExecutor is used with a single thread.\\n\"\n+      \"Use the SingleThreadedExecutor instead.\");"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    - uses: ros-tooling/setup-ros@0.3.0\n+    - uses: ros-tooling/setup-ros@0.3.3"},{"role":"user","content":"-    - uses : ros-tooling/action-ros-ci@0.2.4\n+    - uses : ros-tooling/action-ros-ci@0.2.5"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  <!-- TODO(jacobperron): Replace with ament_lint_common when ament_copyright is working -->\n-  <test_depend>ament_cmake_cppcheck</test_depend>\n-  <test_depend>ament_cmake_cpplint</test_depend>\n+  <test_depend>ament_lint_common</test_depend>"},{"role":"user","content":"-  <test_depend>ament_cmake_lint_cmake</test_depend>\n-  <test_depend>ament_cmake_uncrustify</test_depend>\n-  <test_depend>ament_cmake_xmllint</test_depend>"},{"role":"user","content":"-/*\n- * Copyright (c) 2018, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the copyright holder, nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n+// Copyright (c) 2018, Bosch Software Innovations GmbH.\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the copyright holder nor the names of its\n+//      contributors may be used to endorse or promote products derived from\n+//      this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE."},{"role":"user","content":"-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n+// Copyright (c) 2017, Bosch Software Innovations GmbH.\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the copyright holder nor the names of its\n+//      contributors may be used to endorse or promote products derived from\n+//      this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE.\n+"},{"role":"user","content":"-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n+// Copyright (c) 2017, Bosch Software Innovations GmbH.\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the copyright holder nor the names of its\n+//      contributors may be used to endorse or promote products derived from\n+//      this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE.\n+"},{"role":"user","content":"-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n+// Copyright (c) 2017, Bosch Software Innovations GmbH.\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+//    * Redistributions of source code must retain the above copyright\n+//      notice, this list of conditions and the following disclaimer.\n+//\n+//    * Redistributions in binary form must reproduce the above copyright\n+//      notice, this list of conditions and the following disclaimer in the\n+//      documentation and/or other materials provided with the distribution.\n+//\n+//    * Neither the name of the copyright holder nor the names of its\n+//      contributors may be used to endorse or promote products derived from\n+//      this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE.\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-                if second_arg.value == Parameter.Type.NOT_SET:\n+                if second_arg == Parameter.Type.NOT_SET:"},{"role":"user","content":"+        # Declare a parameter with parameter type 'Not Set'\n+        with self.assertRaises(ValueError):\n+            self.node.declare_parameter(\n+                'wrong_parameter_value_type_not_set', Parameter.Type.NOT_SET)\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from types import TracebackType"},{"role":"user","content":"+from typing import ContextManager"},{"role":"user","content":"+from typing import Type"},{"role":"user","content":"-class Context:\n+class Context(ContextManager['Context']):"},{"role":"user","content":"+\n+    :Example:\n+        >>> from rclpy.context import Context\n+        >>> with Context() as context:\n+        >>>     context.ok()\n+        True\n+"},{"role":"user","content":"+\n+    def __enter__(self) -> 'Context':\n+        # We do not accept parameters here. If one wants to customize the init() call,\n+        # they would have to call it manaully and not use the ContextManager convenience\n+        self.init()\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        self.try_shutdown()"},{"role":"user","content":"+\n+\n+def test_context_manager():\n+    context = Context()\n+\n+    assert not context.ok(), 'the context should not be ok() before init() is called'\n+\n+    with context as the_context:\n+        # Make sure the correct instance is returned\n+        assert the_context is context\n+\n+        assert context.ok(), 'the context should now be initialized'\n+\n+    assert not context.ok(), 'the context should now be shut down'\n+\n+    # Make sure it does not raise (smoke test)\n+    context.try_shutdown()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+    client->impl = NULL;"},{"role":"user","content":"+    client->impl = NULL;"},{"role":"user","content":"+    publisher->impl = NULL;"},{"role":"user","content":"+    service->impl = NULL;"},{"role":"user","content":"+    service->impl = NULL;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-from typing import Generic, List, Type, TypeVar, Union\n+from types import TracebackType\n+from typing import Generic, List, Optional, Type, TypeVar, Union"},{"role":"user","content":"+\n+    def __enter__(self) -> 'Publisher':\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        self.destroy()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"- * The given context must be zero initialized, and is filled with\n- * middleware specific data upon success of this function.\n+ * Context is filled with middleware specific data upon success of this function."},{"role":"user","content":"- * guard conditions, and is also required to properly call rmw_shutdown().\n+ * guard conditions, and is also required to properly call `rmw_shutdown()`.\n+ *\n+ * \\pre The given options must have been initialized\n+ *   i.e. `rmw_init_options_init()` called on it.\n+ * \\pre The given context must be zero initialized.\n+ *\n+ * \\post If initialization fails, context will remain zero initialized.\n+ *\n+ * \\remarks If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n+ *   If context has been already initialized (`rmw_init()` was called on it), then\n+ *   `RMW_RET_INVALID_ARGUMENT` is returned."},{"role":"user","content":"+ * \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or"},{"role":"user","content":"- * \\return `RMW_RET_INVALID_ARGUMENT` if any arguments are null or invalid, or"},{"role":"user","content":"- * The given context must be a valid context which has been initialized\n- * with rmw_init().\n+ * \\pre The given context must be a valid context which has been initialized with `rmw_init()`.\n+ *\n+ * \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n+ *   If context has been already invalidated (`rmw_shutdown()` was called on it), then\n+ *   this function is a no-op and `RMW_RET_OK` is returned."},{"role":"user","content":"+ * \\return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or"},{"role":"user","content":"- * \\return `RMW_RET_INVALID_ARGUMENT` if the argument is null or invalid, or"},{"role":"user","content":"- * The context to be finalized must have been previously initialized with\n- * `rmw_init()`, and then later invalidated with `rmw_shutdown()`.\n- * If context is `NULL`, then `RMW_RET_INVALID_ARGUMENT` is returned.\n- * If context is zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n- * If context is initialized and valid (`rmw_shutdown()` was not called on it),\n- * then `RMW_RET_INVALID_ARGUMENT` is returned.\n+ * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged.\n+ * Otherwise, it will proceed despite errors, freeing as much resources as it can and zero\n+ * initializing the given context.\n+ *\n+ * \\pre The context to be finalized must have been previously initialized with\n+ *   `rmw_init()`, and then later invalidated with `rmw_shutdown()`.\n+ *\n+ * \\remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.\n+ *   If context is initialized and valid (`rmw_shutdown()` was not called on it), then\n+ *   `RMW_RET_INVALID_ARGUMENT` is returned."},{"role":"user","content":"- * \\return `RMW_RET_OK` if the shutdown was completed successfully, or\n+ * This should be defined by the rmw implementation.\n+ *\n+ * \\return `RMW_RET_OK` if successful, or"},{"role":"user","content":"+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation\n+ *   identifier does not match, or"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    DESTINATION bin\n+    DESTINATION lib/${PROJECT_NAME}"},{"role":"user","content":"+Note that if this is run in a Docker container, the `IPC_LOCK` capability must be added to the container capabilities.\n+This can be managed via the `--cap-add` flag:\n+```\n+docker run --cap-add IPC_LOCK\n+```\n+"},{"role":"user","content":"--f Specify the name of the file for writing the collected data. Plot this data file using the `rttest_plot.py` script provided in `scripts`.\n+-f Specify the name of the file for writing the collected data. Plot this data file using the `rttest_plot` script provided in `scripts`."},{"role":"user","content":"-link_directories(${rttest_LIBRARY_DIR})\n-include_directories(${rttest_INCLUDE_DIRS})\n-"},{"role":"user","content":"-target_link_libraries(example_loop ${rttest_LIBRARIES})\n+target_link_libraries(example_loop rttest::rttest)"},{"role":"user","content":"-install(TARGETS tlsf_allocator_example\n-  DESTINATION bin)\n+install(TARGETS\n+  tlsf_allocator_example\n+  DESTINATION lib/${PROJECT_NAME})"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+    auto offset = update->data.begin() + y * update->width;"},{"role":"user","content":"-      update->data.begin(),\n-      update->data.begin() + update->width,\n+      offset,\n+      offset + update->width,"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-from typing import Callable, Generic, List, Type, TypeVar\n+from types import TracebackType\n+from typing import Callable, Generic, List, Optional, Type, TypeVar"},{"role":"user","content":"+\n+    def __enter__(self) -> 'Subscription':\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        self.destroy()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ament_export_include_directories(\"include/${PROJECT_NAME}\")"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    return *_type_support_fastrtps->type_hash;\n+    return *_type_support_fastrtps->get_type_hash_func(_type_support_fastrtps);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n-"},{"role":"user","content":"-  if (info == nullptr) {\n-    return RMW_RET_ERROR;\n-  }"},{"role":"user","content":"-  if (fastrtps_pub == nullptr) {\n-    return RMW_RET_ERROR;\n-  }"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#ifndef __clang_analyzer__"},{"role":"user","content":"+#endif"},{"role":"user","content":"+#ifndef __clang_analyzer__"},{"role":"user","content":"+#endif"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  static void assign(eprosima::fastcdr::Cdr & deser, void * field, bool)\n+  static void assign(eprosima::fastcdr::Cdr & deser, void * field)"},{"role":"user","content":"-  static void assign(eprosima::fastcdr::Cdr & deser, void * field, bool call_new)\n+  static void assign(eprosima::fastcdr::Cdr & deser, void * field)"},{"role":"user","content":"-    if (call_new) {\n-      new(&str) std::string;\n-    }"},{"role":"user","content":"-    void * ros_message,\n-    bool call_new) const;\n+    void * ros_message) const;"},{"role":"user","content":"+\n+#include \"rmw/error_handling.h\"\n+"},{"role":"user","content":"-typedef struct rosidl_runtime_c__void__Sequence\n-{\n-  void * data;\n-  /// The number of valid items in data\n-  size_t size;\n-  /// The number of allocated items in data\n-  size_t capacity;\n-} rosidl_runtime_c__void__Sequence;\n-\n-inline\n-bool\n-rosidl_runtime_c__void__Sequence__init(\n-  rosidl_runtime_c__void__Sequence * sequence, size_t size, size_t member_size)\n-{\n-  if (!sequence) {\n-    return false;\n-  }\n-  void * data = nullptr;\n-  if (size) {\n-    data = static_cast<void *>(calloc(size, member_size));\n-    if (!data) {\n-      return false;\n-    }\n-  }\n-  sequence->data = data;\n-  sequence->size = size;\n-  sequence->capacity = size;\n-  return true;\n-}\n-\n-inline\n-void\n-rosidl_runtime_c__void__Sequence__fini(rosidl_runtime_c__void__Sequence * sequence)\n-{\n-  if (!sequence) {\n-    return;\n-  }\n-  if (sequence->data) {\n-    // ensure that data and capacity values are consistent\n-    assert(sequence->capacity > 0);\n-    // finalize all sequence elements\n-    free(sequence->data);\n-    sequence->data = nullptr;\n-    sequence->size = 0;\n-    sequence->capacity = 0;\n-  } else {\n-    // ensure that data, size, and capacity values are consistent\n-    assert(0 == sequence->size);\n-    assert(0 == sequence->capacity);\n-  }\n-}\n-"},{"role":"user","content":"-static inline void *\n-align_(size_t __align, void * & __ptr) noexcept\n-{\n-  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);\n-  const auto __aligned = (__intptr - 1u + __align) & ~(__align - 1);\n-  return __ptr = reinterpret_cast<void *>(__aligned);\n-}\n-\n-template<typename MembersType>\n-static size_t calculateMaxAlign(const MembersType * members)\n-{\n-  size_t max_align = 0;\n-\n-  for (uint32_t i = 0; i < members->member_count_; ++i) {\n-    size_t alignment = 0;\n-    const auto & member = members->members_[i];\n-\n-    if (member.is_array_ && (!member.array_size_ || member.is_upper_bound_)) {\n-      alignment = alignof(std::vector<unsigned char>);\n-    } else {\n-      switch (member.type_id_) {\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BOOL:\n-          alignment = alignof(bool);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BYTE:\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT8:\n-          alignment = alignof(uint8_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT8:\n-          alignment = alignof(char);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT32:\n-          alignment = alignof(float);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT64:\n-          alignment = alignof(double);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT16:\n-          alignment = alignof(int16_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT16:\n-          alignment = alignof(uint16_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT32:\n-          alignment = alignof(int32_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT32:\n-          alignment = alignof(uint32_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT64:\n-          alignment = alignof(int64_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT64:\n-          alignment = alignof(uint64_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n-          // Note: specialization needed because calculateMaxAlign is called before\n-          // casting submembers as std::string, returned value is the same on i386\n-          if (std::is_same<MembersType,\n-            rosidl_typesupport_introspection_c__MessageMembers>::value)\n-          {\n-            alignment = alignof(rosidl_runtime_c__String);\n-          } else {\n-            alignment = alignof(std::string);\n-          }\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n-          if (std::is_same<MembersType,\n-            rosidl_typesupport_introspection_c__MessageMembers>::value)\n-          {\n-            alignment = alignof(rosidl_runtime_c__U16String);\n-          } else {\n-            alignment = alignof(std::u16string);\n-          }\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE:\n-          {\n-            auto sub_members = (const MembersType *)member.members_->data;\n-            alignment = calculateMaxAlign(sub_members);\n-          }\n-          break;\n-      }\n-    }\n-\n-    if (alignment > max_align) {\n-      max_align = alignment;\n-    }\n-  }\n-\n-  return max_align;\n-}\n-"},{"role":"user","content":"+"},{"role":"user","content":"-size_t get_array_size_and_assign_field(\n+void * get_subros_message("},{"role":"user","content":"-  void * & subros_message,\n-  size_t sub_members_size,\n-  size_t max_align)\n+  size_t index,\n+  size_t,\n+  bool)"},{"role":"user","content":"-  auto vector = reinterpret_cast<std::vector<unsigned char> *>(field);\n-  void * ptr = reinterpret_cast<void *>(sub_members_size);\n-  size_t vsize = vector->size() / reinterpret_cast<size_t>(align_(max_align, ptr));\n-  if (member->is_upper_bound_ && vsize > member->array_size_) {\n-    throw std::runtime_error(\"vector overcomes the maximum length\");\n-  }\n-  subros_message = reinterpret_cast<void *>(vector->data());\n-  return vsize;\n+  return member->get_function(field, index);"},{"role":"user","content":"-size_t get_array_size_and_assign_field(\n+void * get_subros_message("},{"role":"user","content":"-  void * & subros_message,\n-  size_t, size_t)\n+  size_t index,\n+  size_t array_size,\n+  bool is_upper_bound)"},{"role":"user","content":"-  auto tmpsequence = static_cast<rosidl_runtime_c__void__Sequence *>(field);\n-  if (member->is_upper_bound_ && tmpsequence->size > member->array_size_) {\n-    throw std::runtime_error(\"vector overcomes the maximum length\");\n+  if (array_size && !is_upper_bound) {\n+    return member->get_function(&field, index);"},{"role":"user","content":"-  subros_message = reinterpret_cast<void *>(tmpsequence->data);\n-  return tmpsequence->size;\n+\n+  return member->get_function(field, index);"},{"role":"user","content":"-            void * subros_message = nullptr;"},{"role":"user","content":"-            size_t sub_members_size = sub_members->size_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);"},{"role":"user","content":"-              subros_message = field;"},{"role":"user","content":"-              array_size = get_array_size_and_assign_field(\n-                member, field, subros_message, sub_members_size, max_align);\n+              if (!member->size_function) {\n+                RMW_SET_ERROR_MSG(\"unexpected error: size function is null\");\n+                return false;\n+              }\n+              array_size = member->size_function(field);"},{"role":"user","content":"+            if (array_size != 0 && !member->get_function) {\n+              RMW_SET_ERROR_MSG(\"unexpected error: get_function function is null\");\n+              return false;\n+            }"},{"role":"user","content":"-              serializeROSmessage(ser, sub_members, subros_message);\n-              subros_message = static_cast<char *>(subros_message) + sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n+              serializeROSmessage(\n+                ser, sub_members,\n+                get_subros_message(\n+                  member, field, index, member->array_size_,\n+                  member->is_upper_bound_));"},{"role":"user","content":"-            void * subros_message = nullptr;"},{"role":"user","content":"-            size_t sub_members_size = sub_members->size_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);"},{"role":"user","content":"-              subros_message = field;"},{"role":"user","content":"-              array_size = get_array_size_and_assign_field(\n-                member, field, subros_message, sub_members_size, max_align);\n+              if (!member->size_function) {\n+                RMW_SET_ERROR_MSG(\"unexpected error: size function is null\");\n+                return false;\n+              }\n+              array_size = member->size_function(field);"},{"role":"user","content":"+            if (array_size != 0 && !member->get_function) {\n+              RMW_SET_ERROR_MSG(\"unexpected error: get_function function is null\");\n+              return false;\n+            }"},{"role":"user","content":"-                sub_members, subros_message, current_alignment);\n-              subros_message = static_cast<char *>(subros_message) + sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n+                sub_members,\n+                get_subros_message(\n+                  member, field, index, member->array_size_,\n+                  member->is_upper_bound_),\n+                current_alignment);"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-    if (call_new) {\n-      new(&vector) std::vector<T>;\n-    }"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-    if (call_new) {\n-      // Because std::string is a complex datatype, we need to make sure that\n-      // the memory is initialized to something reasonable before eventually\n-      // passing it as a reference to Fast-CDR.\n-      new(field) std::string();\n-    }"},{"role":"user","content":"-    if (call_new) {\n-      for (size_t i = 0; i < member->array_size_; ++i) {\n-        new(&array[i]) std::string();\n-      }\n-    }"},{"role":"user","content":"-    if (call_new) {\n-      new(&vector) std::vector<std::string>;\n-    }"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-  (void)call_new;"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-  (void)call_new;"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-  (void)call_new;"},{"role":"user","content":"-    CStringHelper::assign(deser, field, call_new);\n+    CStringHelper::assign(deser, field);"},{"role":"user","content":"-  eprosima::fastcdr::Cdr & deser,\n-  bool call_new)\n+  eprosima::fastcdr::Cdr & deser)"},{"role":"user","content":"-  (void)call_new;"},{"role":"user","content":"-inline size_t get_submessage_array_deserialize(\n-  const rosidl_typesupport_introspection_cpp::MessageMember * member,\n-  eprosima::fastcdr::Cdr & deser,\n-  void * field,\n-  void * & subros_message,\n-  bool call_new,\n-  size_t sub_members_size,\n-  size_t max_align)\n-{\n-  (void)member;\n-  uint32_t vsize = 0;\n-  // Deserialize length\n-  deser >> vsize;\n-  auto vector = reinterpret_cast<std::vector<unsigned char> *>(field);\n-  if (call_new) {\n-    new(vector) std::vector<unsigned char>;\n-  }\n-  void * ptr = reinterpret_cast<void *>(sub_members_size);\n-  vector->resize(vsize * (size_t)align_(max_align, ptr));\n-  subros_message = reinterpret_cast<void *>(vector->data());\n-  return vsize;\n-}\n-\n-inline size_t get_submessage_array_deserialize(\n-  const rosidl_typesupport_introspection_c__MessageMember * member,\n-  eprosima::fastcdr::Cdr & deser,\n-  void * field,\n-  void * & subros_message,\n-  bool,\n-  size_t sub_members_size,\n-  size_t)\n-{\n-  (void)member;\n-  // Deserialize length\n-  uint32_t vsize = 0;\n-  deser >> vsize;\n-  auto tmpsequence = static_cast<rosidl_runtime_c__void__Sequence *>(field);\n-  rosidl_runtime_c__void__Sequence__init(tmpsequence, vsize, sub_members_size);\n-  subros_message = reinterpret_cast<void *>(tmpsequence->data);\n-  return vsize;\n-}\n-"},{"role":"user","content":"-  void * ros_message,\n-  bool call_new) const\n+  void * ros_message) const"},{"role":"user","content":"-        deserialize_field<bool>(member, field, deser, call_new);\n+        deserialize_field<bool>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<uint8_t>(member, field, deser, call_new);\n+        deserialize_field<uint8_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<char>(member, field, deser, call_new);\n+        deserialize_field<char>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<float>(member, field, deser, call_new);\n+        deserialize_field<float>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<double>(member, field, deser, call_new);\n+        deserialize_field<double>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<int16_t>(member, field, deser, call_new);\n+        deserialize_field<int16_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<uint16_t>(member, field, deser, call_new);\n+        deserialize_field<uint16_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<int32_t>(member, field, deser, call_new);\n+        deserialize_field<int32_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<uint32_t>(member, field, deser, call_new);\n+        deserialize_field<uint32_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<int64_t>(member, field, deser, call_new);\n+        deserialize_field<int64_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<uint64_t>(member, field, deser, call_new);\n+        deserialize_field<uint64_t>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<std::string>(member, field, deser, call_new);\n+        deserialize_field<std::string>(member, field, deser);"},{"role":"user","content":"-        deserialize_field<std::wstring>(member, field, deser, call_new);\n+        deserialize_field<std::wstring>(member, field, deser);"},{"role":"user","content":"-          auto sub_members = (const MembersType *)member->members_->data;\n+          auto sub_members = static_cast<const MembersType *>(member->members_->data);"},{"role":"user","content":"-            deserializeROSmessage(deser, sub_members, field, call_new);\n+            deserializeROSmessage(deser, sub_members, field);"},{"role":"user","content":"-            void * subros_message = nullptr;"},{"role":"user","content":"-            size_t sub_members_size = sub_members->size_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);\n-            bool recall_new = call_new;"},{"role":"user","content":"-              subros_message = field;"},{"role":"user","content":"-              array_size = get_submessage_array_deserialize(\n-                member, deser, field, subros_message,\n-                call_new, sub_members_size, max_align);\n-              recall_new = true;\n+              uint32_t num_elems = 0;\n+              deser >> num_elems;\n+              array_size = static_cast<size_t>(num_elems);\n+\n+              if (!member->resize_function) {\n+                RMW_SET_ERROR_MSG(\"unexpected error: resize function is null\");\n+                return false;\n+              }\n+              member->resize_function(field, array_size);"},{"role":"user","content":"+            if (array_size != 0 && !member->get_function) {\n+              RMW_SET_ERROR_MSG(\"unexpected error: get_function function is null\");\n+              return false;\n+            }"},{"role":"user","content":"-              deserializeROSmessage(deser, sub_members, subros_message, recall_new);\n-              subros_message = static_cast<char *>(subros_message) + sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n+              deserializeROSmessage(\n+                deser, sub_members,\n+                get_subros_message(\n+                  member, field, index, member->array_size_,\n+                  member->is_upper_bound_));"},{"role":"user","content":"-    TypeSupport::deserializeROSmessage(deser, members_, ros_message, false);\n+    TypeSupport::deserializeROSmessage(deser, members_, ros_message);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+      if (security_files_paths.count(\"CRL\") > 0) {\n+        property_policy.properties().emplace_back(\n+          \"dds.sec.auth.builtin.PKI-DH.identity_crl\", security_files_paths[\"CRL\"]);\n+      }\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+Check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information."},{"role":"user","content":"-* `fastrtps_cmake_module`\n-* `rcpputils`\n-* `rcutils`\n-* `rmw`\n-* `rmw_dds_common`\n-* `rmw_fastrtps_shared_cpp`\n-* `rosidl_runtime_c`\n-* `rosidl_typesupport_fastrtps_c`\n-* `rosidl_typesupport_fastrtps_cpp`\n+* `fastrtps_cmake_module`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/fastrtps_cmake_module/QUALITY_DECLARATION.md)\n+* `rcpputils`: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n+* `rcutils`: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n+* `rmw`: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n+* `rmw_dds_common`: [QUALITY DECLARATION](https://github.com/ros2/rmw_dds_common/blob/master/rmw_dds_common/QUALITY_DECLARATION.md)\n+* `rmw_fastrtps_shared_cpp`: [QUALITY DECLARATION](https://github.com/ros2/rmw_fastrtps/blob/master/rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md)\n+* `rosidl_runtime_c`: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_runtime_c/QUALITY_DECLARATION.md)\n+* `rosidl_typesupport_fastrtps_c`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_c/QUALITY_DECLARATION.md)\n+* `rosidl_typesupport_fastrtps_cpp`: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_cpp/QUALITY_DECLARATION.md)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <OgreSceneNode.h>"},{"role":"user","content":"+#include <QMenu>\n+"},{"role":"user","content":"+#include \"rviz_common/display_context.hpp\""},{"role":"user","content":"-namespace Ogre\n-{\n-class SceneNode;\n-}\n-\n-class QMenu;\n-\n-namespace rviz_common\n-{\n-class DisplayContext;\n-}\n-"},{"role":"user","content":"-class InteractiveMarkerDisplay;\n-"},{"role":"user","content":"+#include \"rviz_common/properties/bool_property.hpp\""},{"role":"user","content":"-\n-namespace rviz_common\n-{\n-class BoolProperty;\n-class Object;\n-}\n+#include \"./interactive_marker_namespace_property.hpp\"\n+#include \"rviz_default_plugins/displays/marker/markers/marker_base.hpp\""},{"role":"user","content":"-class InteractiveMarkerNamespaceProperty;"},{"role":"user","content":"-class MarkerBase;\n-"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from collections import deque"},{"role":"user","content":"+            print(wait_for_topics.messages_received('topic_1')) # Should be [message_1, ...]"},{"role":"user","content":"-    def __init__(self, topic_tuples, timeout=5.0):\n+    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):"},{"role":"user","content":"+        self.messages_received_buffer_length = messages_received_buffer_length"},{"role":"user","content":"-        node_name = '_test_node_' +\\\n-            ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))\n-        self.__ros_node = _WaitForTopicsNode(name=node_name, node_context=self.__ros_context)\n+        node_name = '_test_node_' + ''.join(\n+            random.choices(string.ascii_uppercase + string.digits, k=10)\n+        )\n+        self.__ros_node = _WaitForTopicsNode(\n+            name=node_name,\n+            node_context=self.__ros_context,\n+            messages_received_buffer_length=self.messages_received_buffer_length,\n+        )"},{"role":"user","content":"+    def received_messages(self, topic_name):\n+        \"\"\"List of received messages of a specific topic.\"\"\"\n+        if topic_name not in self.__ros_node.received_messages_buffer:\n+            raise KeyError('No messages received for topic: ' + topic_name)\n+        return list(self.__ros_node.received_messages_buffer[topic_name])\n+"},{"role":"user","content":"-    def __init__(self, name='test_node', node_context=None):\n-        super().__init__(node_name=name, context=node_context)\n+    def __init__(\n+            self, name='test_node', node_context=None, messages_received_buffer_length=None\n+    ):\n+        super().__init__(node_name=name, context=node_context)  # type: ignore"},{"role":"user","content":"-\n-    def start_subscribers(self, topic_tuples):\n+        self.messages_received_buffer_length = messages_received_buffer_length"},{"role":"user","content":"-        self.expected_topics = {name for name, _ in topic_tuples}\n+        self.topic_tuples = []\n+        self.expected_topics = set()\n+        self.received_topics = set()\n+        self.received_messages_buffer = {}\n+\n+    def _reset(self):\n+        self.msg_event_object.clear()"},{"role":"user","content":"+        for buffer in self.received_messages_buffer.values():\n+            buffer.clear()"},{"role":"user","content":"+    def start_subscribers(self, topic_tuples):\n+        self._reset()"},{"role":"user","content":"-            # Create a subscriber\n-            self.subscriber_list.append(\n-                self.create_subscription(\n-                    topic_type,\n-                    topic_name,\n-                    self.callback_template(topic_name),\n-                    10\n+            if (topic_name, topic_type) not in self.topic_tuples:\n+                self.topic_tuples.append((topic_name, topic_type))\n+                self.expected_topics.add(topic_name)\n+                # Initialize ring buffer of received messages\n+                self.received_messages_buffer[topic_name] = deque(\n+                    maxlen=self.messages_received_buffer_length\n+                )\n+                # Create a subscriber\n+                self.subscriber_list.append(\n+                    self.create_subscription(\n+                        topic_type,\n+                        topic_name,\n+                        self.callback_template(topic_name),\n+                        10\n+                    )"},{"role":"user","content":"-            )"},{"role":"user","content":"-"},{"role":"user","content":"+            self.get_logger().debug('Message received for ' + topic_name)\n+            self.received_messages_buffer[topic_name].append(data)"},{"role":"user","content":"-                self.get_logger().debug('Message received for ' + topic_name)"},{"role":"user","content":"+import re"},{"role":"user","content":"+"},{"role":"user","content":"+"},{"role":"user","content":"+            message_pattern = re.compile(r'Hello World: \\d+')"},{"role":"user","content":"-            with WaitForTopics(topic_list, timeout=10.0) as wait_for_node_object_1:\n+            with WaitForTopics(\n+                topic_list, timeout=2.0, messages_received_buffer_length=10\n+            ) as wait_for_node_object_1:"},{"role":"user","content":"+                for topic_name, _ in topic_list:\n+                    assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                    message = wait_for_node_object_1.received_messages(topic_name).pop().data\n+                    assert message_pattern.match(message)"},{"role":"user","content":"+            for topic_name, _ in topic_list:\n+                assert len(wait_for_node_object_1.received_messages(topic_name)) >= 1\n+                message = wait_for_node_object_2.received_messages(topic_name).pop().data\n+                assert message_pattern.match(message)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  const dds_UserDataQosPolicy& user_data,"},{"role":"user","content":"-get_datawriter_qos(\n-  dds_Publisher * publisher,\n+get_datawriter_qos(dds_Publisher * publisher,"},{"role":"user","content":"+  const rosidl_type_hash_t & type_hash,"},{"role":"user","content":"+  const rosidl_type_hash_t & type_hash,"},{"role":"user","content":"+#include \"rmw_dds_common/qos.hpp\""},{"role":"user","content":"-static rmw_ret_t\n-__add_entity(\n+\n+namespace rmw_gurumdds::graph {\n+rmw_ret_t add_entity("},{"role":"user","content":"+  const rosidl_type_hash_s & type_hash,"},{"role":"user","content":"-  const bool local)\n-{\n+  const bool local) {"},{"role":"user","content":"-  rmw_qos_profile_t qos_profile = {};\n-\n+  size_t history_depth = RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT;\n+  rmw_qos_history_policy_e history_kind = RMW_QOS_POLICY_HISTORY_UNKNOWN;"},{"role":"user","content":"-    qos_profile = {\n-      convert_history(history),\n-      static_cast<size_t>(history->depth),\n-      convert_reliability(reliability),\n-      convert_durability(durability),\n-      convert_deadline(deadline),\n-      convert_lifespan(lifespan),\n-      convert_liveliness(liveliness),\n-      convert_liveliness_lease_duration(liveliness),\n-      false,\n-    };\n-  } else {\n-    qos_profile = {\n-      RMW_QOS_POLICY_HISTORY_UNKNOWN,\n-      RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT,\n-      convert_reliability(reliability),\n-      convert_durability(durability),\n-      convert_deadline(deadline),\n-      convert_lifespan(lifespan),\n-      convert_liveliness(liveliness),\n-      convert_liveliness_lease_duration(liveliness),\n-      false,\n-    };\n-  }\n+    history_depth = static_cast<size_t>(history->depth);\n+    history_kind = convert_history(history);\n+  }\n+\n+  rmw_qos_profile_t qos_profile{\n+    history_kind,\n+    history_depth,\n+    convert_reliability(reliability),\n+    convert_durability(durability),\n+    convert_deadline(deadline),\n+    convert_lifespan(lifespan),\n+    convert_liveliness(liveliness),\n+    convert_liveliness_lease_duration(liveliness),\n+    false,\n+  };"},{"role":"user","content":"+  const uint32_t * const dp_gid_32_arr = reinterpret_cast<const uint32_t *>(dp_gid->data);\n+  const uint32_t * const endp_gid_32_arr = reinterpret_cast<const uint32_t *>(endp_gid->data);"},{"role":"user","content":"-    reinterpret_cast<const uint32_t *>(dp_gid->data)[0],\n-    reinterpret_cast<const uint32_t *>(dp_gid->data)[1],\n-    reinterpret_cast<const uint32_t *>(dp_gid->data)[2],\n-    reinterpret_cast<const uint32_t *>(dp_gid->data)[3],\n-    reinterpret_cast<const uint32_t *>(endp_gid->data)[0],\n-    reinterpret_cast<const uint32_t *>(endp_gid->data)[1],\n-    reinterpret_cast<const uint32_t *>(endp_gid->data)[2],\n-    reinterpret_cast<const uint32_t *>(endp_gid->data)[3],\n+    dp_gid_32_arr[0],\n+    dp_gid_32_arr[1],\n+    dp_gid_32_arr[2],\n+    dp_gid_32_arr[3],\n+    endp_gid_32_arr[0],\n+    endp_gid_32_arr[1],\n+    endp_gid_32_arr[2],\n+    endp_gid_32_arr[3],"},{"role":"user","content":"-      *endp_gid,\n-      std::string(topic_name),\n-      std::string(type_name),\n-      *dp_gid,\n-      qos_profile,\n-      is_reader))\n-  {\n+    *endp_gid,\n+    std::string(topic_name),\n+    std::string(type_name),\n+    type_hash,\n+    *dp_gid,\n+    qos_profile,\n+    is_reader)) {"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(endp_gid->data)[0],\n-      reinterpret_cast<const uint32_t *>(endp_gid->data)[1],\n-      reinterpret_cast<const uint32_t *>(endp_gid->data)[2],\n-      reinterpret_cast<const uint32_t *>(endp_gid->data)[3],\n+      endp_gid_32_arr[0],\n+      endp_gid_32_arr[1],\n+      endp_gid_32_arr[2],\n+      endp_gid_32_arr[3],"},{"role":"user","content":"-static rmw_ret_t\n-__remove_entity(\n+rmw_ret_t remove_entity("},{"role":"user","content":"-  const bool is_reader)\n-{\n+  const bool is_reader) {"},{"role":"user","content":"-static rmw_ret_t\n-__add_local_publisher(\n+rmw_ret_t\n+add_local_publisher("},{"role":"user","content":"-  const rmw_gid_t gid)\n-{\n+  const rosidl_type_hash_s & type_hash,\n+  const rmw_gid_t gid) {"},{"role":"user","content":"-  auto scope_exit_qos_reset = rcpputils::make_scope_exit(\n-    [dw_qos_ptr]()\n-    {\n-      if (dds_RETCODE_OK != dds_DataWriterQos_finalize(dw_qos_ptr)) {\n-        RMW_SET_ERROR_MSG(\"failed to finalize DataWriterQos\");\n-      }\n-    });\n+  auto scope_exit_qos_reset = rcpputils::make_scope_exit([dw_qos_ptr]() {\n+    if (dds_RETCODE_OK != dds_DataWriterQos_finalize(dw_qos_ptr)) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize DataWriterQos\");\n+    }\n+  });"},{"role":"user","content":"-  return __add_entity(\n+  return add_entity("},{"role":"user","content":"+    type_hash,"},{"role":"user","content":"-static rmw_ret_t\n-__add_local_subscriber(\n+rmw_ret_t add_local_subscriber("},{"role":"user","content":"-  const rmw_gid_t gid)\n-{\n+  const rosidl_type_hash_s & type_hash,\n+  const rmw_gid_t gid) {"},{"role":"user","content":"-    node->namespace_,\n-    node->name,\n+    node->namespace_, node->name,"},{"role":"user","content":"-  dds_Topic * topic =\n-    reinterpret_cast<dds_Topic *>(dds_DataReader_get_topicdescription(datareader));\n+  dds_Topic * topic = reinterpret_cast<dds_Topic *>(dds_DataReader_get_topicdescription(datareader));"},{"role":"user","content":"-  auto scope_exit_qos_reset = rcpputils::make_scope_exit(\n-    [dr_qos_ptr]()\n-    {\n-      if (dds_RETCODE_OK != dds_DataReaderQos_finalize(dr_qos_ptr)) {\n-        RMW_SET_ERROR_MSG(\"failed to finalize DataReaderQos\");\n-      }\n-    });\n+  auto scope_exit_qos_reset = rcpputils::make_scope_exit([dr_qos_ptr]() {\n+    if (dds_RETCODE_OK != dds_DataReaderQos_finalize(dr_qos_ptr)) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize DataReaderQos\");\n+    }\n+  });"},{"role":"user","content":"-  return __add_entity(\n+  return rmw_gurumdds::graph::add_entity("},{"role":"user","content":"+    type_hash,"},{"role":"user","content":"+}"},{"role":"user","content":"-  if (__add_local_publisher(ctx, node, pub->topic_writer, pub->publisher_gid) != RMW_RET_OK) {\n+  const rosidl_type_hash_s& type_hash = *pub->rosidl_message_typesupport->get_type_hash_func(pub->rosidl_message_typesupport);\n+  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, pub->topic_writer, type_hash, pub->publisher_gid) != RMW_RET_OK) {"},{"role":"user","content":"-    __remove_entity(ctx, pub->publisher_gid, false);\n+    rmw_gurumdds::graph::remove_entity(ctx, pub->publisher_gid, false);"},{"role":"user","content":"-  if (__remove_entity(ctx, pub->publisher_gid, false) != RMW_RET_OK) {\n+  if (rmw_gurumdds::graph::remove_entity(ctx, pub->publisher_gid, false) != RMW_RET_OK) {"},{"role":"user","content":"-  if (__add_local_subscriber(ctx, node, sub->topic_reader, sub->subscriber_gid) != RMW_RET_OK) {\n+  const rosidl_type_hash_s& type_hash = *sub->rosidl_message_typesupport->get_type_hash_func(sub->rosidl_message_typesupport);\n+  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, sub->topic_reader, type_hash, sub->subscriber_gid) != RMW_RET_OK) {"},{"role":"user","content":"-    __remove_entity(ctx, sub->subscriber_gid, true);\n+    rmw_gurumdds::graph::remove_entity(ctx, sub->subscriber_gid, true);"},{"role":"user","content":"-  if (__remove_entity(ctx, sub->subscriber_gid, true) != RMW_RET_OK) {\n+  if (rmw_gurumdds::graph::remove_entity(ctx, sub->subscriber_gid, true) != RMW_RET_OK) {"},{"role":"user","content":"-        __remove_entity(ctx, sub_gid, true);\n+        rmw_gurumdds::graph::remove_entity(ctx, sub_gid, true);"},{"role":"user","content":"-        __remove_entity(ctx, pub_gid, false);\n+        rmw_gurumdds::graph::remove_entity(ctx, pub_gid, false);"},{"role":"user","content":"-  if (__add_local_subscriber(ctx, node, svc->request_reader, sub_gid) != RMW_RET_OK) {\n+  const rosidl_message_type_support_t* type_support;\n+  const rosidl_type_hash_s* type_hash;\n+  type_support = svc->service_typesupport->request_typesupport;\n+  type_hash = type_support->get_type_hash_func(type_support);\n+  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, svc->request_reader, *type_hash,  sub_gid) != RMW_RET_OK) {"},{"role":"user","content":"-  if (__add_local_publisher(ctx, node, svc->response_writer, pub_gid) != RMW_RET_OK) {\n+  type_support = svc->service_typesupport->response_typesupport;\n+  type_hash = type_support->get_type_hash_func(type_support);\n+  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, svc->response_writer, *type_hash, pub_gid) != RMW_RET_OK) {"},{"role":"user","content":"-  rmw_ret_t rc = __remove_entity(\n+  rmw_ret_t rc = rmw_gurumdds::graph::remove_entity("},{"role":"user","content":"-  rc = __remove_entity(\n+  rc = rmw_gurumdds::graph::remove_entity("},{"role":"user","content":"-        __remove_entity(ctx, sub_gid, true);\n+        rmw_gurumdds::graph::remove_entity(ctx, sub_gid, true);"},{"role":"user","content":"-        __remove_entity(ctx, pub_gid, false);\n+        rmw_gurumdds::graph::remove_entity(ctx, pub_gid, false);"},{"role":"user","content":"-  if (__add_local_subscriber(ctx, node, client->response_reader, sub_gid) != RMW_RET_OK) {\n+\n+  const rosidl_message_type_support_t* type_support;\n+  const rosidl_type_hash_s* type_hash;\n+  type_support = client->service_typesupport->response_typesupport;\n+  type_hash = type_support->get_type_hash_func(type_support);\n+  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, client->response_reader, *type_hash, sub_gid) != RMW_RET_OK) {"},{"role":"user","content":"-  if (__add_local_publisher(ctx, node, client->request_writer, pub_gid) != RMW_RET_OK) {\n+  type_support = client->service_typesupport->request_typesupport;\n+  type_hash = type_support->get_type_hash_func(type_support);\n+  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, client->request_writer, *type_hash, pub_gid) != RMW_RET_OK) {"},{"role":"user","content":"-  rmw_ret_t rc = __remove_entity(\n+  rmw_ret_t rc = rmw_gurumdds::graph::remove_entity("},{"role":"user","content":"-  rc = __remove_entity(\n+  rc = rmw_gurumdds::graph::remove_entity("},{"role":"user","content":"+  const dds_UserDataQosPolicy& user_data,"},{"role":"user","content":"-  if (RMW_RET_OK != __add_entity(\n+\n+  rosidl_type_hash_s type_hash;\n+  if(RMW_RET_OK != rmw_dds_common::parse_type_hash_from_user_data(\n+    user_data.value, user_data.size, type_hash)) {\n+    type_hash = rosidl_get_zero_initialized_type_hash();\n+    rmw_reset_error();\n+  }\n+\n+  if (RMW_RET_OK != rmw_gurumdds::graph::add_entity("},{"role":"user","content":"+      type_hash,"},{"role":"user","content":"-  return __remove_entity(ctx, gid, is_reader);\n+  return rmw_gurumdds::graph::remove_entity(ctx, gid, is_reader);"},{"role":"user","content":"+#include <string>\n+\n+#include \"rosidl_runtime_c/type_hash.h\"\n+"},{"role":"user","content":"+#include \"rmw_dds_common/qos.hpp\"\n+"},{"role":"user","content":"-  dds_DataWriterQos * datawriter_qos)\n-{\n+  const rosidl_type_hash_t & type_hash,\n+  dds_DataWriterQos * datawriter_qos) {"},{"role":"user","content":"+  std::string user_data_str;\n+  if (RMW_RET_OK != rmw_dds_common::encode_type_hash_for_user_data_qos(type_hash, user_data_str)) {\n+    user_data_str.clear();\n+    // Since we are going to go on without a hash, we clear the error so other\n+    // code won't overwrite it.\n+    rmw_reset_error();\n+  }\n+\n+  memcpy(datawriter_qos->user_data.value, user_data_str.data(), user_data_str.size());\n+"},{"role":"user","content":"+  const rosidl_type_hash_t & type_hash,"},{"role":"user","content":"+\n+  std::string user_data_str;\n+  if (RMW_RET_OK != rmw_dds_common::encode_type_hash_for_user_data_qos(type_hash, user_data_str)) {\n+    user_data_str.clear();\n+    // Since we are going to go on without a hash, we clear the error so other\n+    // code won't overwrite it.\n+    rmw_reset_error();\n+  }\n+\n+  memcpy(datareader_qos->user_data.value, user_data_str.data(), user_data_str.size());\n+"},{"role":"user","content":"+  const rosidl_type_hash_t* type_hash;"},{"role":"user","content":"-  if (!get_datawriter_qos(publisher, qos_policies, &datawriter_qos)) {\n+  type_hash = type_support->request_typesupport->get_type_hash_func(type_support->request_typesupport);\n+  if (!get_datawriter_qos(publisher, qos_policies, *type_hash, &datawriter_qos)) {"},{"role":"user","content":"-  if (!get_datareader_qos(subscriber, qos_policies, &datareader_qos)) {\n+  type_hash = type_support->response_typesupport->get_type_hash_func(type_support->response_typesupport);\n+  if (!get_datareader_qos(subscriber, qos_policies, *type_hash, &datareader_qos)) {"},{"role":"user","content":"-  if (!get_datawriter_qos(pub, qos_policies, &datawriter_qos)) {\n+  const rosidl_type_hash_t& type_hash = *type_support->get_type_hash_func(type_support);\n+  if (!get_datawriter_qos(pub, qos_policies, type_hash, &datawriter_qos)) {"},{"role":"user","content":"+  const rosidl_type_hash_t* type_hash;\n+"},{"role":"user","content":"-  if (!get_datareader_qos(subscriber, qos_policies, &datareader_qos)) {\n+  type_hash = type_support->request_typesupport->get_type_hash_func(type_support->request_typesupport);\n+  if (!get_datareader_qos(subscriber, qos_policies, *type_hash, &datareader_qos)) {"},{"role":"user","content":"-  if (!get_datawriter_qos(publisher, qos_policies, &datawriter_qos)) {\n+  type_hash = type_support->response_typesupport->get_type_hash_func(type_support->response_typesupport);\n+  if (!get_datawriter_qos(publisher, qos_policies, *type_hash, &datawriter_qos)) {"},{"role":"user","content":"-  if (!get_datareader_qos(sub, qos_policies, &datareader_qos)) {\n+  const rosidl_type_hash_t& type_hash = *type_support->get_type_hash_func(type_support);\n+  if (!get_datareader_qos(sub, qos_policies, type_hash, &datareader_qos)) {"},{"role":"user","content":"+      data->user_data,"},{"role":"user","content":"+      data->user_data,"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+  ament_add_gtest(test_clamp test/test_clamp.cpp)"},{"role":"user","content":"+// Copyright 2020 PAL Robotics S.L.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*! \\file clamp.hpp\n+ * \\brief Restrict a value between two bounds\n+ */\n+\n+#ifndef RCPPMATH__CLAMP_HPP_\n+#define RCPPMATH__CLAMP_HPP_\n+\n+#include <cassert>\n+\n+namespace rcppmath\n+{\n+/// If v compares less than lo, returns lo; otherwise if hi compares less\n+//  than v, returns hi; otherwise returns v. Uses operator< to compare the values\n+/**\n+ * \\param[in] v the value to clamp\n+ * \\param[in] lo the lower boundary\n+ * \\param[in] hi the higher boundary\n+ * \\return Reference to lo if v is less than lo, reference to hi if hi is less than v, otherwise\n+ * reference to v.\n+ * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp\n+ * \\warning Capturing the result of clamp by reference if one of the parameters is rvalue produces\n+ *  a dangling reference if that parameter is returned\n+ **/\n+template<class T>\n+constexpr const T & clamp(const T & v, const T & lo, const T & hi)\n+{\n+  assert(!(hi < lo) );\n+  return (v < lo) ? lo : (hi < v) ? hi : v;\n+}\n+\n+/// Like the function above, but uses comp to compare the values.\n+/**\n+ * \\param[in] comp Comparison object that returns true if the first argument is\n+ * less than the second\n+ **/\n+template<class T, class Compare>\n+constexpr const T & clamp(const T & v, const T & lo, const T & hi, Compare comp)\n+{\n+  assert(!comp(hi, lo) );\n+  return comp(v, lo) ? lo : comp(hi, v) ? hi : v;\n+}\n+\n+}  // namespace rcppmath\n+\n+#endif  // RCPPMATH__CLAMP_HPP_"},{"role":"user","content":"+// Copyright 2020 PAL Robotics S.L.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+#include <limits>\n+\n+#include \"rcppmath/clamp.hpp\"\n+\n+TEST(test_clamp, test_basic) {\n+  EXPECT_EQ(rcppmath::clamp(1, 2, 5), 2);\n+  EXPECT_EQ(rcppmath::clamp(2, 2, 5), 2);\n+  EXPECT_EQ(rcppmath::clamp(5, 2, 5), 5);\n+  EXPECT_EQ(rcppmath::clamp(6, 2, 5), 5);\n+  EXPECT_EQ(rcppmath::clamp(3, 2, 5), 3);\n+  EXPECT_EQ(rcppmath::clamp(4, 2, 5), 4);\n+}\n+\n+TEST(test_clamp, test_cmp) {\n+  auto cmp = [](const int & a, const int & b)\n+    {\n+      return a < b;\n+    };\n+  EXPECT_EQ(rcppmath::clamp(1, 2, 5, cmp), 2);\n+  EXPECT_EQ(rcppmath::clamp(2, 2, 5, cmp), 2);\n+  EXPECT_EQ(rcppmath::clamp(5, 2, 5, cmp), 5);\n+  EXPECT_EQ(rcppmath::clamp(6, 2, 5, cmp), 5);\n+  EXPECT_EQ(rcppmath::clamp(3, 2, 5, cmp), 3);\n+  EXPECT_EQ(rcppmath::clamp(4, 2, 5, cmp), 4);\n+}\n+TEST(test_clamp, test_limits) {\n+  EXPECT_EQ(rcppmath::clamp(std::numeric_limits<double>::infinity(), 0.0, 1.0), 1.0);\n+  EXPECT_EQ(rcppmath::clamp(-std::numeric_limits<double>::infinity(), 0.0, 1.0), 0.0);\n+\n+  // Nan's are not limited by clamp, and return a nan, which is not comparable to itself\n+  EXPECT_NE(rcppmath::clamp(std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0), 0.0);\n+  EXPECT_NE(rcppmath::clamp(std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0), 1.0);\n+  EXPECT_NE(\n+    rcppmath::clamp(\n+      std::numeric_limits<double>::quiet_NaN(), 0.0, 1.0),\n+    std::numeric_limits<double>::quiet_NaN());\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    __slots__ = [\n-        '_version',\n-        '_value',\n-    ]\n-\n-    def __init__(self, **kwargs):\n-        assert all('_' + key in self.__slots__ for key in kwargs.keys()), \\\n-            'Invalid arguments passed to constructor: %r' % kwargs.keys()\n-\n-        self.version = kwargs.get('version', -1)\n-        self.value = kwargs.get('value', bytes(self._TYPE_HASH_SIZE))\n+    def __init__(self, version: int = -1, value: bytes = bytes(_TYPE_HASH_SIZE)):\n+        self.version = version\n+        self.value = value"},{"role":"user","content":"-    def version(self):\n+    def version(self) -> int:"},{"role":"user","content":"-        :rtype: int"},{"role":"user","content":"-    def version(self, value):\n+    def version(self, value: int) -> None:"},{"role":"user","content":"-    def value(self):\n+    def value(self) -> bytes:"},{"role":"user","content":"-        :rtype: bytes"},{"role":"user","content":"-    def value(self, value):\n+    def value(self, value: bytes) -> None:"},{"role":"user","content":"-    def __eq__(self, other):\n+    def __eq__(self, other: object) -> bool:"},{"role":"user","content":"-        return all(\n-            self.__getattribute__(slot) == other.__getattribute__(slot)\n-            for slot in self.__slots__)\n+        return self.__dict__ == other.__dict__"},{"role":"user","content":"-    def __str__(self):\n+    def __str__(self) -> str:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+            for event_handler in publisher.event_handlers:\n+                self.__waitables.remove(event_handler)"},{"role":"user","content":"+            for event_handler in subscription.event_handlers:\n+                self.__waitables.remove(event_handler)"},{"role":"user","content":"+from rclpy.qos_event import QoSEventHandler"},{"role":"user","content":"-        self.event_handlers = event_callbacks.create_event_handlers(\n+        self.event_handlers: QoSEventHandler = event_callbacks.create_event_handlers("},{"role":"user","content":"+        for handler in self.event_handlers:\n+            handler.destroy()"},{"role":"user","content":"-    # End Waitable API\n+\n+    def destroy(self):\n+        self._event_handle.destroy()"},{"role":"user","content":"+from rclpy.qos_event import QoSEventHandler"},{"role":"user","content":"-        self.event_handlers = event_callbacks.create_event_handlers(\n+        self.event_handlers: QoSEventHandler = event_callbacks.create_event_handlers("},{"role":"user","content":"+        for handler in self.event_handlers:\n+            handler.destroy()"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-                    [git, 'config', '--global', 'user.email'],\n+                    [git, 'config', 'user.email'],"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <unordered_map>\n-#include <memory>"},{"role":"user","content":"-static std::shared_ptr<std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>>>\n-g_mask_map_ptr {new std::unordered_map<rmw_event_type_t, dds_StatusKind, std::hash<int>> {\n-    {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n-    {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n-    {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n-    {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n-    {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n-  }};\n+static const dds_StatusKind g_mask_map[] {\n+  dds_LIVELINESS_CHANGED_STATUS,  // RMW_EVENT_LIVELINESS_CHANGED\n+  dds_REQUESTED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_REQUESTED_DEADLINE_MISSED\n+  dds_REQUESTED_INCOMPATIBLE_QOS_STATUS,  // RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE\n+  dds_SAMPLE_LOST_STATUS,  // RMW_EVENT_MESSAGE_LOST\n+  dds_LIVELINESS_LOST_STATUS,  // RMW_EVENT_LIVELINESS_LOST\n+  dds_OFFERED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_OFFERED_DEADLINE_MISSED\n+  dds_OFFERED_INCOMPATIBLE_QOS_STATUS  // RMW_EVENT_OFFERED_QOS_INCOMPATIBLE\n+};"},{"role":"user","content":"-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n+  if (!is_event_supported(event_t)) {"},{"role":"user","content":"-  return mask_map_ptr->at(event_t);\n+\n+  return g_mask_map[static_cast<int>(event_t)];"},{"role":"user","content":"-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n-    return false;\n-  }\n-  return mask_map_ptr->count(event_t) > 0;\n+  return 0 <= event_t && event_t < RMW_EVENT_INVALID;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  virtual size_t available_capacity() const = 0;"},{"role":"user","content":"+  virtual size_t available_capacity() const = 0;"},{"role":"user","content":"+  size_t available_capacity() const override\n+  {\n+    return buffer_->available_capacity();\n+  }\n+"},{"role":"user","content":"+  /// Get the remaining capacity to store messages\n+  /**\n+   * This member function is thread-safe.\n+   *\n+   * \\return the number of free capacity for new messages\n+   */\n+  size_t available_capacity() const\n+  {\n+    std::lock_guard<std::mutex> lock(mutex_);\n+    return available_capacity_();\n+  }\n+"},{"role":"user","content":"+  /// Get the remaining capacity to store messages\n+  /**\n+   * This member function is not thread-safe.\n+   *\n+   * \\return the number of free capacity for new messages\n+   */\n+  inline size_t available_capacity_() const\n+  {\n+    return capacity_ - size_;\n+  }\n+"},{"role":"user","content":"+  /// Return the lowest available capacity for all subscription buffers for a publisher id.\n+  RCLCPP_PUBLIC\n+  size_t\n+  lowest_available_capacity(const uint64_t intra_process_publisher_id) const;\n+"},{"role":"user","content":"+  RCLCPP_PUBLIC\n+  virtual\n+  size_t\n+  available_capacity() const = 0;\n+"},{"role":"user","content":"+  size_t available_capacity() const override\n+  {\n+    return buffer_->available_capacity();\n+  }\n+"},{"role":"user","content":"+  /// Return the lowest available capacity for all subscription buffers.\n+  /**\n+   * For intraprocess communication return the lowest buffer capacity for all subscriptions.\n+   * If intraprocess is disabled or no intraprocess subscriptions present, return maximum of size_t.\n+   * On failure return 0.\n+   * \\return lowest buffer capacity for all subscriptions\n+   */\n+  RCLCPP_PUBLIC\n+  size_t\n+  lowest_available_ipm_capacity() const;\n+"},{"role":"user","content":"+size_t\n+IntraProcessManager::lowest_available_capacity(const uint64_t intra_process_publisher_id) const\n+{\n+  size_t capacity = std::numeric_limits<size_t>::max();\n+\n+  auto publisher_it = pub_to_subs_.find(intra_process_publisher_id);\n+  if (publisher_it == pub_to_subs_.end()) {\n+    // Publisher is either invalid or no longer exists.\n+    RCLCPP_WARN(\n+      rclcpp::get_logger(\"rclcpp\"),\n+      \"Calling lowest_available_capacity for invalid or no longer existing publisher id\");\n+    return 0u;\n+  }\n+\n+  if (publisher_it->second.take_shared_subscriptions.empty() &&\n+    publisher_it->second.take_ownership_subscriptions.empty())\n+  {\n+    // no subscriptions available\n+    return 0u;\n+  }\n+\n+  auto available_capacity = [this, &capacity](const uint64_t intra_process_subscription_id)\n+    {\n+      auto subscription_it = subscriptions_.find(intra_process_subscription_id);\n+      if (subscription_it != subscriptions_.end()) {\n+        auto subscription = subscription_it->second.lock();\n+        if (subscription) {\n+          capacity = std::min(capacity, subscription->available_capacity());\n+        }\n+      } else {\n+        // Subscription is either invalid or no longer exists.\n+        RCLCPP_WARN(\n+          rclcpp::get_logger(\"rclcpp\"),\n+          \"Calling available_capacity for invalid or no longer existing subscription id\");\n+      }\n+    };\n+\n+  for (const auto sub_id : publisher_it->second.take_shared_subscriptions) {\n+    available_capacity(sub_id);\n+  }\n+\n+  for (const auto sub_id : publisher_it->second.take_ownership_subscriptions) {\n+    available_capacity(sub_id);\n+  }\n+\n+  return capacity;\n+}"},{"role":"user","content":"+\n+size_t PublisherBase::lowest_available_ipm_capacity() const\n+{\n+  if (!intra_process_is_enabled_) {\n+    return 0u;\n+  }\n+\n+  auto ipm = weak_ipm_.lock();\n+\n+  if (!ipm) {\n+    // TODO(ivanpauno): should this raise an error?\n+    RCLCPP_WARN(\n+      rclcpp::get_logger(\"rclcpp\"),\n+      \"Intra process manager died for a publisher.\");\n+    return 0u;\n+  }\n+\n+  return ipm->lowest_available_capacity(intra_process_publisher_id_);\n+}"},{"role":"user","content":"+\n+/*\n+  Check the available buffer capacity while storing and consuming data from an intra-process\n+  buffer.\n+  The initial available buffer capacity should equal the buffer size.\n+  Inserting a message should decrease the available buffer capacity by 1.\n+  Consuming a message should increase the available buffer capacity by 1.\n+ */\n+TEST(TestIntraProcessBuffer, available_capacity) {\n+  using MessageT = char;\n+  using Alloc = std::allocator<void>;\n+  using Deleter = std::default_delete<MessageT>;\n+  using SharedMessageT = std::shared_ptr<const MessageT>;\n+  using UniqueMessageT = std::unique_ptr<MessageT, Deleter>;\n+  using UniqueIntraProcessBufferT = rclcpp::experimental::buffers::TypedIntraProcessBuffer<\n+    MessageT, Alloc, Deleter, UniqueMessageT>;\n+\n+  constexpr auto history_depth = 5u;\n+\n+  auto buffer_impl =\n+    std::make_unique<rclcpp::experimental::buffers::RingBufferImplementation<UniqueMessageT>>(\n+    history_depth);\n+\n+  UniqueIntraProcessBufferT intra_process_buffer(std::move(buffer_impl));\n+\n+  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n+\n+  auto original_unique_msg = std::make_unique<char>('a');\n+  auto original_message_pointer = reinterpret_cast<std::uintptr_t>(original_unique_msg.get());\n+  auto original_value = *original_unique_msg;\n+\n+  intra_process_buffer.add_unique(std::move(original_unique_msg));\n+\n+  EXPECT_EQ(history_depth - 1u, intra_process_buffer.available_capacity());\n+\n+  SharedMessageT popped_shared_msg;\n+  popped_shared_msg = intra_process_buffer.consume_shared();\n+  auto popped_message_pointer = reinterpret_cast<std::uintptr_t>(popped_shared_msg.get());\n+\n+  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n+  EXPECT_EQ(original_value, *popped_shared_msg);\n+  EXPECT_EQ(original_message_pointer, popped_message_pointer);\n+\n+  original_unique_msg = std::make_unique<char>('b');\n+  original_message_pointer = reinterpret_cast<std::uintptr_t>(original_unique_msg.get());\n+  original_value = *original_unique_msg;\n+\n+  intra_process_buffer.add_unique(std::move(original_unique_msg));\n+\n+  auto second_unique_msg = std::make_unique<char>('c');\n+  auto second_message_pointer = reinterpret_cast<std::uintptr_t>(second_unique_msg.get());\n+  auto second_value = *second_unique_msg;\n+\n+  intra_process_buffer.add_unique(std::move(second_unique_msg));\n+\n+  EXPECT_EQ(history_depth - 2u, intra_process_buffer.available_capacity());\n+\n+  UniqueMessageT popped_unique_msg;\n+  popped_unique_msg = intra_process_buffer.consume_unique();\n+  popped_message_pointer = reinterpret_cast<std::uintptr_t>(popped_unique_msg.get());\n+\n+  EXPECT_EQ(history_depth - 1u, intra_process_buffer.available_capacity());\n+  EXPECT_EQ(original_value, *popped_unique_msg);\n+  EXPECT_EQ(original_message_pointer, popped_message_pointer);\n+\n+  popped_unique_msg = intra_process_buffer.consume_unique();\n+  popped_message_pointer = reinterpret_cast<std::uintptr_t>(popped_unique_msg.get());\n+\n+  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n+  EXPECT_EQ(second_value, *popped_unique_msg);\n+  EXPECT_EQ(second_message_pointer, popped_message_pointer);\n+}"},{"role":"user","content":"+    ++num_msgs;"},{"role":"user","content":"+    ++num_msgs;"},{"role":"user","content":"+    --num_msgs;\n+  }\n+\n+  size_t size() const\n+  {\n+    return num_msgs;"},{"role":"user","content":"+  // count add and pop\n+  size_t num_msgs = 0u;"},{"role":"user","content":"+  virtual\n+  size_t\n+  available_capacity() const = 0;\n+"},{"role":"user","content":"+  size_t\n+  available_capacity() const override\n+  {\n+    return qos_profile.depth() - buffer->size();\n+  }\n+"},{"role":"user","content":"+\n+/*\n+   This tests the method \"lowest_available_capacity\":\n+   - Creates 1 publisher.\n+   - The available buffer capacity should be at least history size.\n+   - Add 2 subscribers.\n+   - Add everything to the intra-process manager.\n+   - All the entities are expected to have different ids.\n+   - Check the subscriptions count for the publisher.\n+   - The available buffer capacity should be the history size.\n+   - Publish one message (without receiving it).\n+   - The available buffer capacity should decrease by 1.\n+   - Publish another message (without receiving it).\n+   - The available buffer capacity should decrease by 1.\n+   - One subscriber receives one message.\n+   - The available buffer capacity should stay the same,\n+     as the other subscriber still has not freed its buffer.\n+   - The other subscriber receives one message.\n+   - The available buffer capacity should increase by 1.\n+   - One subscription goes out of scope.\n+   - The available buffer capacity should not change.\n+ */\n+TEST(TestIntraProcessManager, lowest_available_capacity) {\n+  using IntraProcessManagerT = rclcpp::experimental::IntraProcessManager;\n+  using MessageT = rcl_interfaces::msg::Log;\n+  using PublisherT = rclcpp::mock::Publisher<MessageT>;\n+  using SubscriptionIntraProcessT = rclcpp::experimental::mock::SubscriptionIntraProcess<MessageT>;\n+\n+  constexpr auto history_depth = 10u;\n+\n+  auto ipm = std::make_shared<IntraProcessManagerT>();\n+\n+  auto p1 = std::make_shared<PublisherT>(rclcpp::QoS(history_depth).best_effort());\n+\n+  auto s1 = std::make_shared<SubscriptionIntraProcessT>(rclcpp::QoS(history_depth).best_effort());\n+  auto s2 = std::make_shared<SubscriptionIntraProcessT>(rclcpp::QoS(history_depth).best_effort());\n+\n+  auto p1_id = ipm->add_publisher(p1);\n+  p1->set_intra_process_manager(p1_id, ipm);\n+\n+  auto c1 = ipm->lowest_available_capacity(p1_id);\n+\n+  ASSERT_LE(0u, c1);\n+\n+  auto s1_id = ipm->add_subscription(s1);\n+  auto s2_id = ipm->add_subscription(s2);\n+\n+  bool unique_ids = s1_id != s2_id && p1_id != s1_id;\n+  ASSERT_TRUE(unique_ids);\n+\n+  size_t p1_subs = ipm->get_subscription_count(p1_id);\n+  size_t non_existing_pub_subs = ipm->get_subscription_count(42);\n+  ASSERT_EQ(2u, p1_subs);\n+  ASSERT_EQ(0u, non_existing_pub_subs);\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  auto non_existing_pub_c = ipm->lowest_available_capacity(42);\n+\n+  ASSERT_EQ(history_depth, c1);\n+  ASSERT_EQ(0u, non_existing_pub_c);\n+\n+  auto unique_msg = std::make_unique<MessageT>();\n+  p1->publish(std::move(unique_msg));\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  ASSERT_EQ(history_depth - 1u, c1);\n+\n+  unique_msg = std::make_unique<MessageT>();\n+  p1->publish(std::move(unique_msg));\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  ASSERT_EQ(history_depth - 2u, c1);\n+\n+  s1->pop();\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  ASSERT_EQ(history_depth - 2u, c1);\n+\n+  s2->pop();\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  ASSERT_EQ(history_depth - 1u, c1);\n+\n+  ipm->get_subscription_intra_process(s1_id).reset();\n+\n+  c1 = ipm->lowest_available_capacity(p1_id);\n+  ASSERT_EQ(history_depth - 1u, c1);\n+}"},{"role":"user","content":"+TEST_F(TestPublisher, lowest_available_ipm_capacity) {\n+  constexpr auto history_depth = 10u;\n+\n+  initialize(rclcpp::NodeOptions().use_intra_process_comms(true));\n+\n+  rclcpp::PublisherOptionsWithAllocator<std::allocator<void>> options_ipm_disabled;\n+  options_ipm_disabled.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;\n+\n+  rclcpp::PublisherOptionsWithAllocator<std::allocator<void>> options_ipm_enabled;\n+  options_ipm_enabled.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n+\n+  auto do_nothing = [](std::shared_ptr<const test_msgs::msg::Strings>) {};\n+  auto pub_ipm_disabled = node->create_publisher<test_msgs::msg::Strings>(\n+    \"topic\", history_depth,\n+    options_ipm_disabled);\n+  auto pub_ipm_enabled = node->create_publisher<test_msgs::msg::Strings>(\n+    \"topic\", history_depth,\n+    options_ipm_enabled);\n+  auto sub = node->create_subscription<test_msgs::msg::Strings>(\n+    \"topic\",\n+    history_depth,\n+    do_nothing);\n+\n+  ASSERT_EQ(1, pub_ipm_enabled->get_intra_process_subscription_count());\n+  ASSERT_EQ(0, pub_ipm_disabled->lowest_available_ipm_capacity());\n+  ASSERT_EQ(history_depth, pub_ipm_enabled->lowest_available_ipm_capacity());\n+\n+  auto msg = std::make_shared<test_msgs::msg::Strings>();\n+  ASSERT_NO_THROW(pub_ipm_disabled->publish(*msg));\n+  ASSERT_NO_THROW(pub_ipm_enabled->publish(*msg));\n+\n+  ASSERT_EQ(0, pub_ipm_disabled->lowest_available_ipm_capacity());\n+  ASSERT_EQ(history_depth - 1u, pub_ipm_enabled->lowest_available_ipm_capacity());\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+This package has testing coverage of at least 95%."},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-                durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL))\n+                durability=QoSDurabilityPolicy.TRANSIENT_LOCAL))"},{"role":"user","content":"-                durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_VOLATILE))\n+                durability=QoSDurabilityPolicy.VOLATILE))"},{"role":"user","content":"-                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE))\n+                reliability=QoSReliabilityPolicy.RELIABLE))"},{"role":"user","content":"-                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT))\n+                reliability=QoSReliabilityPolicy.BEST_EFFORT))"},{"role":"user","content":"-                re.compile(r'  Reliability: RMW_QOS_POLICY_RELIABILITY_\\w+'),\n-                re.compile(r'  Durability: RMW_QOS_POLICY_DURABILITY_\\w+'),\n+                re.compile(r'  Reliability: (RELIABLE|BEST_EFFORT|SYSTEM_DEFAULT|UNKNOWN)'),\n+                re.compile(r'  Durability: (VOLATILE|TRANSIENT_LOCAL|SYSTEM_DEFAULT|UNKNOWN)'),"},{"role":"user","content":"-                re.compile(r'  Liveliness: RMW_QOS_POLICY_LIVELINESS_\\w+'),\n+                re.compile(r'  Liveliness: (AUTOMATIC|MANUAL_BY_TOPIC|SYSTEM_DEFAULT|UNKNOWN)'),"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+        // cancled timer are not handled, return success\n+        if (rc == RCL_RET_TIMER_CANCELED) {\n+          rc = RCL_RET_OK;\n+          break;\n+        }\n+"},{"role":"user","content":"+TEST_F(TestDefaultExecutor, executor_spin_publisher_timer_cancelled) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  unsigned int expected_msg;\n+\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  _executor_results_init();\n+\n+  rc = rclc_executor_add_subscription(\n+    &executor, &this->sub1, &this->sub1_msg,\n+    &CALLBACK_1, ON_NEW_DATA);\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+\n+  for (unsigned int i = 0; i < TC_SPIN_SOME_PUBLISHED_MSGS; i++) {\n+    rc = rcl_publish(&this->pub1, &this->pub1_msg, nullptr);\n+    EXPECT_EQ(RCL_RET_OK, rc) << \" pub1 not published\";\n+  }\n+\n+  // wait until messages are received\n+  bool success = false;\n+  unsigned int tries;\n+  unsigned int max_tries = 100;\n+  uint64_t timeout_ns = 100000000;  // 100ms\n+\n+  rc = rcl_timer_cancel(&this->timer1);\n+  // process subscriptions. Assumption: messages for sub1 available\n+  for (unsigned int i = 0; i < 100; i++) {\n+    // Assumption: messages for all sub1, sub2 and sub3 are available\n+    _wait_for_msg(\n+      &this->sub1, &this->context, max_tries, timeout_ns, &tries,\n+      &success);\n+    ASSERT_TRUE(success);\n+\n+\n+    EXPECT_EQ(RCL_RET_OK, rc) << \"failed to cancel timer\";\n+\n+    rc = rclc_executor_spin_some(&executor, rclc_test_timeout_ns);\n+    if ((rc == RCL_RET_OK) || (rc == RCL_RET_TIMEOUT)) {\n+      // valid return values\n+    } else {\n+      // any other error\n+      EXPECT_EQ(RCL_RET_OK, rc) << \"spin_some error\";\n+    }\n+    if (_cb1_cnt == TC_SPIN_SOME_PUBLISHED_MSGS) {\n+      break;\n+    }\n+  }\n+\n+  expected_msg = TC_SPIN_SOME_PUBLISHED_MSGS;\n+  EXPECT_EQ(_cb1_cnt, expected_msg) << \"cb1 msg does not match\";\n+\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+  rcutils_reset_error();\n+}\n+\n+TEST_F(TestDefaultExecutor, executor_spin_timer_cancelled) {\n+  rcl_ret_t rc;\n+  rclc_executor_t executor;\n+  rc = rclc_executor_init(&executor, &this->context, 10, this->allocator_ptr);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  // spin_timeout must be < timer1_timeout\n+  const unsigned int spin_timeout = 50;\n+  const unsigned int spin_repeat = 10;\n+  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n+  _cbt_cnt = 0;\n+\n+  rc = rclc_executor_add_timer(&executor, &this->timer1);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+\n+  for (size_t i = 0; i < spin_repeat; i++) {\n+    rclc_executor_spin_some(&executor, RCL_MS_TO_NS(spin_timeout));\n+    if (i > spin_repeat / 2) {\n+      rc = rcl_timer_cancel(&this->timer1);\n+      EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+    }\n+  }\n+\n+  EXPECT_LT(_cbt_cnt, expected_callbacks);\n+\n+  // tear down\n+  rc = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, rc) << rcl_get_error_string().str;\n+}\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+                    self.assertTrue(header is not None)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+  ament/ament_lint:\n+    type: git\n+    url: https://github.com/ament/ament_lint.git\n+    version: pull/268/merge"},{"role":"user","content":"+    - name: Set up git to see all pull requests\n+      run: git config --global --add remote.origin.fetch '+refs/pull/*:refs/remotes/origin/pull/*'"},{"role":"user","content":"-          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/suppress_other_rmw.repos\n+          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/local.repos"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-include_directories(include)\n-"},{"role":"user","content":"-target_include_directories(${PROJECT_NAME} PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\")\n+target_include_directories(${PROJECT_NAME} PUBLIC\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\"\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n+  \"$<INSTALL_INTERFACE:include/${PROJECT_NAME}>\")"},{"role":"user","content":"+  EXPORT export_${PROJECT_NAME}"},{"role":"user","content":"-  DESTINATION include)\n+  DESTINATION include/${PROJECT_NAME})"},{"role":"user","content":"-  DESTINATION include/${PROJECT_NAME})\n+  DESTINATION include/${PROJECT_NAME}/${PROJECT_NAME})"},{"role":"user","content":"-ament_export_include_directories(include)\n+# Export old-style CMake variables\n+ament_export_include_directories(\"include/${PROJECT_NAME}\")"},{"role":"user","content":"+\n+# Export modern CMake targets\n+ament_export_targets(export_${PROJECT_NAME})\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories) of the ROS2 developer guide.\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html) of the ROS2 developer guide."},{"role":"user","content":"-`rcutils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning)\n+`rcutils` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning)"},{"role":"user","content":"-`rcutils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n+`rcutils` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process)."},{"role":"user","content":"-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information."},{"role":"user","content":"-All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n+All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information."},{"role":"user","content":"-`rcutils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n+`rcutils` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage."},{"role":"user","content":"-A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n+A description of how coverage statistics are summarized from this page, can be found in the [\"ROS 2 Onboarding Guide\"](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs)."},{"role":"user","content":"-`rcutils` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n+`rcutils` follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change."},{"role":"user","content":"-`rcutils` uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n+`rcutils` uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms."},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <utility>"},{"role":"user","content":"+#include <random>"},{"role":"user","content":"-#include <random>"},{"role":"user","content":"-  tf_msg.transform.translation.x = this->declare_parameter(\"/translation/x\", 0.0, descriptor);\n-  tf_msg.transform.translation.y = this->declare_parameter(\"/translation/y\", 0.0, descriptor);\n-  tf_msg.transform.translation.z = this->declare_parameter(\"/translation/z\", 0.0, descriptor);\n-  tf_msg.transform.rotation.x = this->declare_parameter(\"/rotation/x\", 0.0, descriptor);\n-  tf_msg.transform.rotation.y = this->declare_parameter(\"/rotation/y\", 0.0, descriptor);\n-  tf_msg.transform.rotation.z = this->declare_parameter(\"/rotation/z\", 0.0, descriptor);\n-  tf_msg.transform.rotation.w = this->declare_parameter(\"/rotation/w\", 1.0, descriptor);\n+  tf_msg.transform.translation.x = this->declare_parameter(\"translation.x\", 0.0, descriptor);\n+  tf_msg.transform.translation.y = this->declare_parameter(\"translation.y\", 0.0, descriptor);\n+  tf_msg.transform.translation.z = this->declare_parameter(\"translation.z\", 0.0, descriptor);\n+  tf_msg.transform.rotation.x = this->declare_parameter(\"rotation.x\", 0.0, descriptor);\n+  tf_msg.transform.rotation.y = this->declare_parameter(\"rotation.y\", 0.0, descriptor);\n+  tf_msg.transform.rotation.z = this->declare_parameter(\"rotation.z\", 0.0, descriptor);\n+  tf_msg.transform.rotation.w = this->declare_parameter(\"rotation.w\", 1.0, descriptor);"},{"role":"user","content":"-    this->declare_parameter(\"/frame_id\", std::string(\"/frame\"), descriptor);\n+    this->declare_parameter(\"frame_id\", std::string(\"/frame\"), descriptor);"},{"role":"user","content":"-    this->declare_parameter(\"/child_frame_id\", std::string(\"/child\"), descriptor);\n+    this->declare_parameter(\"child_frame_id\", std::string(\"/child\"), descriptor);"},{"role":"user","content":"-#include <cstring>\n+#include <memory>"},{"role":"user","content":"-#include \"rclcpp/clock.hpp\"\n-#include \"rclcpp/time_source.hpp\""},{"role":"user","content":"-#include \"builtin_interfaces/msg/time.hpp\"\n-\n-#include \"rcutils/logging_macros.h\"\n-\n-//TODO(clalancette re-enable this)\n-// bool validateXmlRpcTf(XmlRpc::XmlRpcValue tf_data) {\n-//   // Validate a TF stored in XML RPC format: ensures the appropriate fields\n-//   // exist. Note this does not check data types.\n-//   return tf_data.hasMember(\"child_frame_id\") &&\n-//          tf_data.hasMember(\"header\") &&\n-//          tf_data[\"header\"].hasMember(\"frame_id\") &&\n-//          tf_data.hasMember(\"transform\") &&\n-//          tf_data[\"transform\"].hasMember(\"translation\") &&\n-//          tf_data[\"transform\"][\"translation\"].hasMember(\"x\") &&\n-//          tf_data[\"transform\"][\"translation\"].hasMember(\"y\") &&\n-//          tf_data[\"transform\"][\"translation\"].hasMember(\"z\") &&\n-//          tf_data[\"transform\"].hasMember(\"rotation\") &&\n-//          tf_data[\"transform\"][\"rotation\"].hasMember(\"x\") &&\n-//          tf_data[\"transform\"][\"rotation\"].hasMember(\"y\") &&\n-//          tf_data[\"transform\"][\"rotation\"].hasMember(\"z\") &&\n-//          tf_data[\"transform\"][\"rotation\"].hasMember(\"w\");\n-// };\n-"},{"role":"user","content":"-    //printf(\"It will periodicaly republish the given transform. \\n\");"},{"role":"user","content":"-    //printf(\"OR \\n\");\n-    //printf(\"Usage: static_transform_publisher /param_name \\n\");\n-    //printf(\"\\nThis transform is the transform of the coordinate frame from frame_id into the coordinate frame \\n\");\n-    //printf(\"of the child_frame_id.  \\n\");"},{"role":"user","content":"-    {\"/translation/x\", x},\n-    {\"/translation/y\", y},\n-    {\"/translation/z\", z},\n-    {\"/rotation/x\", rx},\n-    {\"/rotation/y\", ry},\n-    {\"/rotation/z\", rz},\n-    {\"/rotation/w\", rw},\n-    {\"/frame_id\", frame_id},\n-    {\"/child_frame_id\", child_id},\n+    {\"translation.x\", x},\n+    {\"translation.y\", y},\n+    {\"translation.z\", z},\n+    {\"rotation.x\", rx},\n+    {\"rotation.y\", ry},\n+    {\"rotation.z\", rz},\n+    {\"rotation.w\", rw},\n+    {\"frame_id\", frame_id},\n+    {\"child_frame_id\", child_id},"},{"role":"user","content":"-  // else if (args.size() == 2) {\n-  //   const std::string param_name = args[1];\n-  //   ROS_INFO_STREAM(\"Looking for TF in parameter: \" << param_name);\n-  //   XmlRpc::XmlRpcValue tf_data;\n-\n-  //   if (!ros::param::has(param_name) || !ros::param::get(param_name, tf_data)) {\n-  //     ROS_FATAL_STREAM(\"Could not read TF from parameter server: \" << param_name);\n-  //     return -1;\n-  //   }\n-\n-  //   // Check that all required members are present & of the right type.\n-  //   if (!validateXmlRpcTf(tf_data)) {\n-  //     ROS_FATAL_STREAM(\"Could not validate XmlRpcC for TF data: \" << tf_data);\n-  //     return -1;\n-  //   }\n-\n-  //   msg.transform.translation.x = (double) tf_data[\"transform\"][\"translation\"][\"x\"];\n-  //   msg.transform.translation.y = (double) tf_data[\"transform\"][\"translation\"][\"y\"];\n-  //   msg.transform.translation.z = (double) tf_data[\"transform\"][\"translation\"][\"z\"];\n-  //   msg.transform.rotation.x = (double) tf_data[\"transform\"][\"rotation\"][\"x\"];\n-  //   msg.transform.rotation.y = (double) tf_data[\"transform\"][\"rotation\"][\"y\"];\n-  //   msg.transform.rotation.z = (double) tf_data[\"transform\"][\"rotation\"][\"z\"];\n-  //   msg.transform.rotation.w = (double) tf_data[\"transform\"][\"rotation\"][\"w\"];\n-  //   msg.header.stamp = clock->now();\n-  //   msg.header.frame_id = (std::string) tf_data[\"header\"][\"frame_id\"];\n-  //   msg.child_frame_id = (std::string) tf_data[\"child_frame_id\"];\n-  // }"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  LIBRARIES ${PROJECT_NAME}\n+  LIBRARIES ${PROJECT_NAME} mimick"},{"role":"user","content":"+#include \"rcutils/snprintf.h\"\n+"},{"role":"user","content":"+#include \"rmw/validate_namespace.h\"\n+\n+#include \"../mocking_utils/patch.hpp\"\n+"},{"role":"user","content":"+\n+  {\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_validate_namespace_with_size,\n+      [&](auto, auto, int * result, size_t * index) {\n+        if (index) {\n+          *index = 0u;\n+        }\n+        *result = RMW_NAMESPACE_INVALID_TOO_LONG;\n+        return RMW_RET_OK;\n+      });\n+\n+    // When applying RMW namespace validation rules, an enclave name may be too\n+    // long for an RMW namespace but not necessarily for an enclave name.\n+    EXPECT_EQ(\n+      RCL_RET_OK,\n+      rcl_validate_enclave_name(\"/foo/baz\", &validation_result, &invalid_index));\n+    EXPECT_EQ(RCL_ENCLAVE_NAME_VALID, validation_result);\n+  }\n+}\n+\n+TEST(TestValidateEnclaveName, test_validate_on_internal_error) {\n+  int validation_result;\n+  size_t invalid_index;\n+\n+  {\n+    auto mock = mocking_utils::patch_to_fail(\n+      \"lib:rcl\", rmw_validate_namespace_with_size, \"internal error\", RMW_RET_ERROR);\n+\n+    EXPECT_EQ(\n+      RCL_RET_ERROR,\n+      rcl_validate_enclave_name(\"/foo\", &validation_result, &invalid_index));\n+    EXPECT_TRUE(rcl_error_is_set());\n+    rcl_reset_error();\n+  }\n+\n+  {\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_validate_namespace_with_size,\n+      [&](auto, auto, int * result, size_t * index) {\n+        if (index) {\n+          *index = 0u;\n+        }\n+        *result = -1;\n+        return RMW_RET_OK;\n+      });\n+\n+    EXPECT_EQ(\n+      RCL_RET_ERROR,\n+      rcl_validate_enclave_name(\"/foo\", &validation_result, &invalid_index));\n+    EXPECT_TRUE(rcl_error_is_set());\n+    rcl_reset_error();\n+  }"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <utility>"},{"role":"user","content":"+#include \"rclcpp/node_interfaces/get_node_base_interface.hpp\"\n+#include \"rclcpp/node_interfaces/get_node_services_interface.hpp\"\n+#include \"rclcpp/node_interfaces/get_node_logging_interface.hpp\"\n+#include \"rclcpp/node_interfaces/node_logging_interface.hpp\""},{"role":"user","content":"+   * \\param  qos If passed change the quality of service of the frames_server_ service"},{"role":"user","content":"-  TF2_ROS_PUBLIC Buffer(\n+  template<typename NodeT = rclcpp::Node::SharedPtr>\n+  Buffer("},{"role":"user","content":"-    rclcpp::Node::SharedPtr node = rclcpp::Node::SharedPtr());\n+    NodeT && node = NodeT(),\n+    const rclcpp::QoS & qos = rclcpp::ServicesQoS())\n+  : BufferCore(cache_time), clock_(clock), timer_interface_(nullptr)\n+  {\n+    if (nullptr == clock_) {\n+      throw std::invalid_argument(\"clock must be a valid instance\");\n+    }\n+\n+    auto post_jump_cb = [this](const rcl_time_jump_t & jump_info) {onTimeJump(jump_info);};\n+\n+    rcl_jump_threshold_t jump_threshold;\n+    // Disable forward jump callbacks\n+    jump_threshold.min_forward.nanoseconds = 0;\n+    // Anything backwards is a jump\n+    jump_threshold.min_backward.nanoseconds = -1;\n+    // Callback if the clock changes too\n+    jump_threshold.on_clock_change = true;\n+\n+    jump_handler_ = clock_->create_jump_callback(nullptr, post_jump_cb, jump_threshold);\n+\n+    if (node) {\n+      node_logging_interface_ = rclcpp::node_interfaces::get_node_logging_interface(node);\n+\n+      frames_server_ = rclcpp::create_service<tf2_msgs::srv::FrameGraph>(\n+        rclcpp::node_interfaces::get_node_base_interface(node),\n+        rclcpp::node_interfaces::get_node_services_interface(node),\n+        \"tf2_frames\", std::bind(\n+          &Buffer::getFrames, this, std::placeholders::_1,\n+          std::placeholders::_2), qos, nullptr);\n+    }\n+  }"},{"role":"user","content":"+  TF2_ROS_PUBLIC"},{"role":"user","content":"+  TF2_ROS_PUBLIC"},{"role":"user","content":"-  /// \\brief A node to advertise the view_frames service\n-  rclcpp::Node::SharedPtr node_;\n+  /// \\brief A node logging interface to access the buffer node's logger\n+  rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_interface_;"},{"role":"user","content":"-\n-Buffer::Buffer(\n-  rclcpp::Clock::SharedPtr clock, tf2::Duration cache_time,\n-  rclcpp::Node::SharedPtr node)\n-: BufferCore(cache_time), clock_(clock), node_(node), timer_interface_(nullptr)\n-{\n-  if (nullptr == clock_) {\n-    throw std::invalid_argument(\"clock must be a valid instance\");\n-  }\n-\n-  auto post_jump_cb = [this](const rcl_time_jump_t & jump_info) {onTimeJump(jump_info);};\n-\n-  rcl_jump_threshold_t jump_threshold;\n-  // Disable forward jump callbacks\n-  jump_threshold.min_forward.nanoseconds = 0;\n-  // Anything backwards is a jump\n-  jump_threshold.min_backward.nanoseconds = -1;\n-  // Callback if the clock changes too\n-  jump_threshold.on_clock_change = true;\n-\n-  jump_handler_ = clock_->create_jump_callback(nullptr, post_jump_cb, jump_threshold);\n-\n-  if (node_) {\n-    frames_server_ = node_->create_service<tf2_msgs::srv::FrameGraph>(\n-      \"tf2_frames\", std::bind(\n-        &Buffer::getFrames, this, std::placeholders::_1,\n-        std::placeholders::_2));\n-  }\n-}\n-"},{"role":"user","content":"-  return node_ ? node_->get_logger() : rclcpp::get_logger(\"tf2_buffer\");\n+  return node_logging_interface_ ? node_logging_interface_->get_logger() : rclcpp::get_logger(\n+    \"tf2_buffer\");"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+# Avoid DOWNLOAD_EXTRACT_TIMESTAMP warning for CMake >= 3.24\n+if(POLICY CMP0135)\n+  cmake_policy(SET CMP0135 NEW)\n+endif()\n+"},{"role":"user","content":"+# Avoid DOWNLOAD_EXTRACT_TIMESTAMP warning for CMake >= 3.24\n+if(POLICY CMP0135)\n+  cmake_policy(SET CMP0135 NEW)\n+endif()\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <message_filters/subscriber.h>"},{"role":"user","content":"-"},{"role":"user","content":"+#include <message_filters/subscriber.hpp>\n+"},{"role":"user","content":"-#include <message_filters/cache.h>\n+#include <message_filters/cache.hpp>"},{"role":"user","content":"-#include <message_filters/subscriber.h>\n-#include <message_filters/synchronizer.h>\n-#include <message_filters/sync_policies/approximate_time.h>"},{"role":"user","content":"+#include <message_filters/subscriber.hpp>\n+#include <message_filters/synchronizer.hpp>\n+#include <message_filters/sync_policies/approximate_time.hpp>\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  ${geometry_msgs_TARGETS}\n+  image_transport::image_transport\n+  interactive_markers::interactive_markers\n+  laser_geometry::laser_geometry\n+  ${map_msgs_TARGETS}\n+  ${nav_msgs_TARGETS}\n+  rclcpp::rclcpp\n+  rviz_common::rviz_common"},{"role":"user","content":"+  rviz_rendering::rviz_rendering\n+  ${sensor_msgs_TARGETS}\n+  tf2::tf2\n+  ${tf2_geometry_msgs_TARGETS}\n+  tf2_ros::tf2_ros\n+  urdf::urdf\n+  ${visualization_msgs_TARGETS}"},{"role":"user","content":"+  resource_retriever::resource_retriever"},{"role":"user","content":"-ament_target_dependencies(rviz_default_plugins\n-  PUBLIC\n-  geometry_msgs\n-  image_transport\n-  interactive_markers\n-  laser_geometry\n-  map_msgs\n-  nav_msgs\n-  rclcpp\n-  resource_retriever\n-  rviz_common\n-  rviz_rendering\n-  sensor_msgs\n-  tf2\n-  tf2_geometry_msgs\n-  tf2_ros\n-  urdf\n-  visualization_msgs\n-)\n-"},{"role":"user","content":"-  resource_retriever"},{"role":"user","content":"-  find_package(sensor_msgs REQUIRED)\n-  find_package(visualization_msgs REQUIRED)"},{"role":"user","content":"-  set(TEST_INCLUDE_DIRS\n-    test\n-    ${GMOCK_INCLUDE_DIRS}\n-    ${OGRE_INCLUDE_DIRS}\n-    ${Qt5Widgets_INCLUDE_DIRS}\n-  )\n-  ament_include_directories_order(TEST_INCLUDE_DIRS ${TEST_INCLUDE_DIRS})\n-\n-  set(TEST_TARGET_DEPENDENCIES\n-    map_msgs\n-    nav_msgs\n-    rclcpp\n-    rviz_common\n-    rviz_rendering\n-    sensor_msgs\n-    urdf\n-    visualization_msgs\n-  )"},{"role":"user","content":"-  # We can't compile the fixtures into a library to be used by every test because that would require\n-  # linking against gtest/gmock libraries, which would cause ODR violations down the line with\n-  # ament_add_gmock.\n+  add_library(ogre_testing_environment STATIC test/rviz_default_plugins/ogre_testing_environment.cpp)\n+  target_link_libraries(ogre_testing_environment PRIVATE rviz_ogre_vendor::OgreMain rviz_rendering::rviz_rendering)\n+\n+  # We can't compile these fixtures into a library to be used by every test because that would\n+  # require linking against gtest/gmock libraries, which would cause ODR violations down the line\n+  # with ament_add_gmock."},{"role":"user","content":"-  set(TEST_FIXTURE_SOURCES\n-    test/rviz_default_plugins/ogre_testing_environment.cpp\n-  )\n-"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-  set(TEST_LINK_LIBRARIES\n-    rviz_default_plugins\n-    Qt5::Widgets\n+  set(TEST_FIXTURE_WITH_MOCK_LIBRARIES\n+    rclcpp::rclcpp\n+    rviz_common::rviz_common\n+    rviz_ogre_vendor::OgreMain\n+    ogre_testing_environment"},{"role":"user","content":"-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp"},{"role":"user","content":"-    target_include_directories(fps_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(fps_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(fps_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(fps_view_controller_test PRIVATE ${TEST_INCLUDE_DIRS})\n+    target_link_libraries(fps_view_controller_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      rviz_default_plugins\n+      Qt5::Widgets\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(frame_info_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(frame_info_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(frame_info_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(frame_info_test PRIVATE test)\n+    target_link_libraries(frame_info_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-  ${TEST_FIXTURE_SOURCES_WITH_MOCK})\n+    ${TEST_FIXTURE_SOURCES_WITH_MOCK})"},{"role":"user","content":"-    target_include_directories(get_transport_from_topic_test PUBLIC ${TEST_INCLUDE_DIRS} ${rviz_common_INCLUDE_DIRS})\n-    target_link_libraries(get_transport_from_topic_test ${TEST_LINK_LIBRARIES} ${rviz_common})\n+    target_include_directories(get_transport_from_topic_test PRIVATE test)\n+    target_link_libraries(get_transport_from_topic_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(grid_cells_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(grid_cells_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(grid_cells_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(grid_cells_display_test PRIVATE test)\n+    target_link_libraries(grid_cells_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(image_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(image_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(image_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(image_display_test PRIVATE test)\n+    target_link_libraries(image_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} Qt5::Widgets rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"+  add_library(marker_messages STATIC test/rviz_default_plugins/displays/marker/marker_messages.cpp)\n+  target_link_libraries(marker_messages PRIVATE\n+    ${geometry_msgs_TARGETS}\n+    rclcpp::rclcpp\n+    ${std_msgs_TARGETS}\n+    ${visualization_msgs_TARGETS}\n+    rviz_ogre_vendor::OgreMain\n+  )\n+"},{"role":"user","content":"-    test/rviz_default_plugins/displays/marker/marker_messages.cpp"},{"role":"user","content":"-    target_include_directories(marker_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(marker_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(marker_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(marker_test PRIVATE test)\n+    target_link_libraries(marker_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      rviz_default_plugins\n+      marker_messages\n+      ${visualization_msgs_TARGETS}\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/displays/marker/marker_messages.cpp"},{"role":"user","content":"-    target_include_directories(marker_common_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(marker_common_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(marker_common_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(marker_common_test PRIVATE test)\n+    target_link_libraries(marker_common_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      ${visualization_msgs_TARGETS}\n+      rviz_default_plugins\n+      marker_messages\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(map_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(map_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(map_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(map_display_test PRIVATE test)\n+    target_link_libraries(map_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(measure_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(measure_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(measure_tool_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(measure_tool_test PRIVATE test)\n+    target_link_libraries(measure_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(odometry_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(odometry_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(odometry_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(odometry_display_test PRIVATE test)\n+    target_link_libraries(odometry_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(odometry_ogre_helper_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(odometry_ogre_helper_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(odometry_ogre_helper_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(odometry_ogre_helper_test PRIVATE test)\n+    target_link_libraries(odometry_ogre_helper_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} ogre_testing_environment)"},{"role":"user","content":"-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp"},{"role":"user","content":"-    target_include_directories(orbit_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(orbit_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(orbit_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(orbit_view_controller_test PRIVATE test)\n+    target_link_libraries(orbit_view_controller_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      Qt5::Widgets\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp"},{"role":"user","content":"-    target_include_directories(ortho_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(ortho_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(ortho_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(ortho_view_controller_test PRIVATE test)\n+    target_link_libraries(ortho_view_controller_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      Qt5::Widgets\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(palette_builder_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(palette_builder_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(palette_builder_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(palette_builder_test PRIVATE test)\n+    target_link_libraries(palette_builder_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(path_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(path_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(path_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(path_display_test PRIVATE test)\n+    target_link_libraries(path_display_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      ${visualization_msgs_TARGETS}\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"+  add_library(pointcloud_messages STATIC test/rviz_default_plugins/pointcloud_messages.cpp)\n+  target_link_libraries(pointcloud_messages PRIVATE\n+    ${sensor_msgs_TARGETS}\n+    ${geometry_msgs_TARGETS}\n+    rclcpp::rclcpp\n+    ${sensor_msgs_TARGETS}\n+    ${std_msgs_TARGETS}\n+  )\n+"},{"role":"user","content":"-    test/rviz_default_plugins/pointcloud_messages.cpp"},{"role":"user","content":"-    target_include_directories(point_cloud2_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n+    target_include_directories(point_cloud2_display_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud2_display_test ${TEST_TARGET_DEPENDENCIES})\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      rviz_default_plugins\n+      pointcloud_messages\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/pointcloud_messages.cpp"},{"role":"user","content":"-    target_include_directories(point_cloud_common_test PUBLIC ${TEST_INCLUDE_DIRS})\n+    target_include_directories(point_cloud_common_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_common_test ${TEST_TARGET_DEPENDENCIES})\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      rviz_default_plugins\n+      pointcloud_messages\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(point_cloud_scalar_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(point_cloud_scalar_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_scalar_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(point_cloud_scalar_display_test PRIVATE test)\n+    target_link_libraries(point_cloud_scalar_display_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      rviz_default_plugins\n+      ${sensor_msgs_TARGETS}\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/pointcloud_messages.cpp"},{"role":"user","content":"-    target_include_directories(point_cloud_transformers_test PUBLIC ${TEST_INCLUDE_DIRS})\n+    target_include_directories(point_cloud_transformers_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_transformers_test ${TEST_TARGET_DEPENDENCIES})\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      Qt5::Widgets\n+      rviz_default_plugins\n+      pointcloud_messages\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(point_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(point_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(point_display_test PRIVATE test)\n+    target_link_libraries(point_display_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      ${geometry_msgs_TARGETS}\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(pose_array_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(pose_array_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(pose_array_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(pose_array_display_test PRIVATE test)\n+    target_link_libraries(pose_array_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(pose_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(pose_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(pose_tool_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(pose_tool_test PRIVATE test)\n+    target_link_libraries(pose_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(range_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(range_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(range_display_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(range_display_test PRIVATE test)\n+    target_link_libraries(range_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    target_include_directories(robot_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    # TODO(clalancette): Figure out why putting resource_retriever in the\n-    # TEST_TARGET_DEPENDENCIES doesn't work.\n-    target_link_libraries(robot_test resource_retriever::resource_retriever ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(robot_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(robot_test PRIVATE test)\n+    target_link_libraries(robot_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      resource_retriever::resource_retriever\n+      Qt5::Widgets\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(ros_image_texture_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(ros_image_texture_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(ros_image_texture_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(ros_image_texture_test PRIVATE test)\n+    target_link_libraries(ros_image_texture_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      ${sensor_msgs_TARGETS}\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(selection_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(selection_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(selection_tool_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(selection_tool_test PRIVATE test)\n+    target_link_libraries(selection_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)"},{"role":"user","content":"-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp"},{"role":"user","content":"-    target_include_directories(xy_orbit_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(xy_orbit_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(xy_orbit_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(xy_orbit_view_controller_test PRIVATE test)\n+    target_link_libraries(xy_orbit_view_controller_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      Qt5::Widgets\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(frame_transformer_tf_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(frame_transformer_tf_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(frame_transformer_tf_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(frame_transformer_tf_test PRIVATE test)\n+    target_link_libraries(frame_transformer_tf_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      tf2_ros::tf2_ros\n+      ${geometry_msgs_TARGETS}\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    target_include_directories(transformer_guard_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(transformer_guard_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(transformer_guard_test ${TEST_TARGET_DEPENDENCIES})\n+    target_include_directories(transformer_guard_test PRIVATE test)\n+    target_link_libraries(transformer_guard_test\n+      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n+      tf2_ros::tf2_ros\n+      rviz_default_plugins\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(axes_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(axes_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"+  add_library(point_cloud_common_page_object STATIC test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp)\n+  target_link_libraries(point_cloud_common_page_object PRIVATE Qt5::Test rviz_visual_testing_framework::rviz_visual_testing_framework)\n+"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/camera_info_publisher.hpp"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/publishers/image_publisher.hpp\n-    test/rviz_default_plugins/publishers/point_cloud_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(camera_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(camera_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      rclcpp::rclcpp\n+      ${sensor_msgs_TARGETS}\n+      ${std_msgs_TARGETS}\n+      Qt5::Test\n+      ${geometry_msgs_TARGETS}\n+      tf2::tf2\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/fluid_pressure_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(fluid_pressure_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(fluid_pressure_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Test\n+      rclcpp::rclcpp\n+      pointcloud_messages\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(grid_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(grid_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(grid_cells_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(grid_cells_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ${nav_msgs_TARGETS}\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/illuminance_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(illuminance_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(illuminance_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      pointcloud_messages\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/image_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(image_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(image_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      rclcpp::rclcpp\n+      ${sensor_msgs_TARGETS}\n+      ${std_msgs_TARGETS}\n+    )"},{"role":"user","content":"-  ${TEST_FIXTURE_SOURCES})\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)"},{"role":"user","content":"-    target_include_directories(interactive_marker_namespace_property_test PUBLIC\n-      ${TEST_INCLUDE_DIRS})\n+    target_include_directories(interactive_marker_namespace_property_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(interactive_marker_namespace_property_test\n-      ${TEST_TARGET_DEPENDENCIES})\n+      rviz_default_plugins\n+      Qt5::Widgets\n+      ogre_testing_environment\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(laser_scan_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(laser_scan_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Test\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"+  add_library(marker_display_page_object STATIC test/rviz_default_plugins/page_objects/marker_display_page_object.cpp)\n+  target_link_libraries(marker_display_page_object PRIVATE Qt5::Widgets rviz_visual_testing_framework::rviz_visual_testing_framework)\n+"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/map_publisher.hpp\n-    test/rviz_default_plugins/publishers/single_marker_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(map_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(map_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${geometry_msgs_TARGETS}\n+      ${nav_msgs_TARGETS}\n+      ${visualization_msgs_TARGETS}\n+      marker_display_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/marker_array_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(marker_array_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(marker_array_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${visualization_msgs_TARGETS}\n+      marker_display_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/marker_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(marker_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(marker_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${visualization_msgs_TARGETS}\n+      marker_display_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/odometry_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(odometry_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(odometry_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${geometry_msgs_TARGETS}\n+      ${nav_msgs_TARGETS}\n+      tf2_ros::tf2_ros\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/path_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(path_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(path_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${geometry_msgs_TARGETS}\n+      ${nav_msgs_TARGETS}\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/point_stamped_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(point_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(point_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      ${geometry_msgs_TARGETS}\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/publishers/point_cloud_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(point_cloud_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(point_cloud_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ${geometry_msgs_TARGETS}\n+      tf2::tf2\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${sensor_msgs_TARGETS}\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/point_cloud2_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(point_cloud2_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(point_cloud2_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      pointcloud_messages\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"+  add_library(pose_display_page_object STATIC test/rviz_default_plugins/page_objects/pose_display_page_object.cpp)\n+  target_link_libraries(pose_display_page_object PRIVATE Qt5::Widgets rviz_visual_testing_framework::rviz_visual_testing_framework)\n+"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/pose_array_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(pose_array_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(pose_array_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      ${geometry_msgs_TARGETS}\n+      pose_display_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/pose_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(pose_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(pose_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      ${geometry_msgs_TARGETS}\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      pose_display_page_object\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/publishers/pose_with_covariance_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(pose_with_covariance_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(pose_with_covariance_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+      ${geometry_msgs_TARGETS}\n+      rclcpp::rclcpp\n+      ${std_msgs_TARGETS}\n+      tf2_ros::tf2_ros\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(range_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(range_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/relative_humidity_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(relative_humidity_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(relative_humidity_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(robot_model_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(robot_model_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}"},{"role":"user","content":"-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+    )"},{"role":"user","content":"-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/temperature_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(temperature_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(temperature_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      Qt5::Test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      point_cloud_common_page_object\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(tf_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(tf_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+    )"},{"role":"user","content":"-    ${TEST_FIXTURE_SOURCES}"},{"role":"user","content":"-    target_include_directories(wrench_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n+    target_include_directories(wrench_display_visual_test PRIVATE test)"},{"role":"user","content":"-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      Qt5::Widgets\n+    )"},{"role":"user","content":"+#include \"rclcpp/clock.hpp\"\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include \"geometry_msgs/msg/point.hpp\""},{"role":"user","content":"+#include \"std_msgs/msg/color_rgba.hpp\"\n+#include \"std_msgs/msg/header.hpp\"\n+#include \"visualization_msgs/msg/marker.hpp\""},{"role":"user","content":"+#include \"geometry_msgs/msg/point.hpp\"\n+#include \"std_msgs/msg/color_rgba.hpp\""},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include <QString>\n+"},{"role":"user","content":"+#include \"geometry_msgs/msg/point32.hpp\""},{"role":"user","content":"+#include \"sensor_msgs/msg/point_cloud2.hpp\"\n+#include \"sensor_msgs/msg/point_field.hpp\"\n+#include \"std_msgs/msg/header.hpp\""},{"role":"user","content":"+#include \"geometry_msgs/msg/pose.hpp\""},{"role":"user","content":"-\n+find_package(geometry_msgs REQUIRED)\n+find_package(Qt5 REQUIRED COMPONENTS Widgets Test)\n+find_package(rclcpp REQUIRED)"},{"role":"user","content":"-"},{"role":"user","content":"-"},{"role":"user","content":"-\n-find_package(Qt5 REQUIRED COMPONENTS Widgets Test)\n+find_package(rviz_rendering REQUIRED)\n+find_package(std_msgs REQUIRED)\n+find_package(tf2 REQUIRED)\n+find_package(tf2_ros REQUIRED)"},{"role":"user","content":"-set(visual_test_framework_source_files\n-  include/rviz_visual_testing_framework/page_objects/base_page_object.hpp\n-  src/page_objects/base_page_object.cpp\n-  include/rviz_visual_testing_framework/page_objects/page_object_with_window.hpp\n-  src/page_objects/page_object_with_window.cpp\n-  src/internal/rviz_scene_test.cpp\n-  include/rviz_visual_testing_framework/internal/rviz_scene_test.hpp\n-  include/rviz_visual_testing_framework/internal/display_handler.hpp\n-  src/internal/display_handler.cpp\n-  src/internal/image_tester.cpp\n-  include/rviz_visual_testing_framework/internal/image_tester.hpp\n-  include/rviz_visual_testing_framework/test_helpers.hpp\n-  src/test_helpers.cpp\n-  include/rviz_visual_testing_framework/internal/executor.hpp\n-  src/internal/executor.cpp\n-  include/rviz_visual_testing_framework/internal/transform_message_creator.hpp\n-  src/internal/transform_message_creator.cpp\n-  include/rviz_visual_testing_framework/internal/visual_test.hpp\n-  src/internal/visual_test.cpp\n-  include/rviz_visual_testing_framework/visual_test_fixture.hpp\n-  src/visual_test_fixture.cpp\n-  include/rviz_visual_testing_framework/visual_test_publisher.hpp\n-)\n-\n-set(visual_tests_target_libaries\n-  rviz_common::rviz_common\n-  Qt5::Widgets\n-  Qt5::Test)\n-"},{"role":"user","content":"-add_library(rviz_visual_testing_framework STATIC ${visual_test_framework_source_files})\n+add_library(rviz_visual_testing_framework STATIC\n+  src/page_objects/base_page_object.cpp\n+  src/page_objects/page_object_with_window.cpp\n+  src/internal/rviz_scene_test.cpp\n+  src/internal/display_handler.cpp\n+  src/internal/image_tester.cpp\n+  src/test_helpers.cpp\n+  src/internal/executor.cpp\n+  src/internal/transform_message_creator.cpp\n+  src/internal/visual_test.cpp\n+  src/visual_test_fixture.cpp\n+)"},{"role":"user","content":"-target_link_libraries(rviz_visual_testing_framework\n-  ${visual_tests_target_libaries})\n+target_link_libraries(rviz_visual_testing_framework PUBLIC\n+  ${geometry_msgs_TARGETS}\n+  Qt5::Test\n+  Qt5::Widgets\n+  rclcpp::rclcpp\n+  rcutils::rcutils\n+  rviz_common::rviz_common\n+  rviz_ogre_vendor::OgreMain\n+  rviz_rendering::rviz_rendering\n+  ${std_msgs_TARGETS}\n+  tf2::tf2\n+  tf2_ros::tf2_ros\n+)"},{"role":"user","content":"-ament_export_dependencies(Qt5)\n-ament_export_dependencies(rviz_common)\n+ament_export_dependencies(geometry_msgs Qt5 rclcpp rcutils rviz_common rviz_ogre_vendor rviz_rendering std_msgs tf2 tf2_ros)"},{"role":"user","content":"+  <depend>geometry_msgs</depend>\n+  <depend>rclcpp</depend>"},{"role":"user","content":"+  <depend>rviz_ogre_vendor</depend>\n+  <depend>rviz_rendering</depend>\n+  <depend>std_msgs</depend>\n+  <depend>tf2</depend>\n+  <depend>tf2_ros</depend>"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-from types import TracebackType"},{"role":"user","content":"-from typing import Callable\n-from typing import Dict\n-from typing import Generic\n-from typing import Optional\n-from typing import Tuple\n-from typing import Type\n-from typing import TYPE_CHECKING"},{"role":"user","content":"-from typing import TypeVar"},{"role":"user","content":"-from action_msgs.msg._goal_status_array import GoalStatusArray"},{"role":"user","content":"-from builtin_interfaces.msg import Time\n+"},{"role":"user","content":"-from rclpy.type_support import Action"},{"role":"user","content":"-from rclpy.type_support import FeedbackMessage\n-from rclpy.type_support import FeedbackT\n-from rclpy.type_support import GetResultServiceResponse\n-from rclpy.type_support import GoalT\n-from rclpy.type_support import ResultT\n-from rclpy.type_support import SendGoalServiceResponse"},{"role":"user","content":"-from unique_identifier_msgs.msg import UUID\n-\n-if TYPE_CHECKING:\n-    from rclpy.node import Node\n-    from rclpy.callback_groups import CallbackGroup\n-    from typing_extensions import Unpack, TypeAlias\n-\n-    ClientGoalHandleDictResultT = TypeVar('ClientGoalHandleDictResultT')\n-    ClientGoalHandleDictFeedbackT = TypeVar('ClientGoalHandleDictFeedbackT')\n-\n-    class ClientGoalHandleDict(TypedDict,\n-                               Generic[ClientGoalHandleDictResultT, ClientGoalHandleDictFeedbackT],\n-                               total=False):\n-        goal: Tuple[int, SendGoalServiceResponse]\n-        cancel: Tuple[int, CancelGoal.Response]\n-        result: Tuple[int, GetResultServiceResponse[ClientGoalHandleDictResultT]]\n-        feedback: FeedbackMessage[ClientGoalHandleDictFeedbackT]\n-        status: GoalStatusArray\n-else:\n-    ClientGoalHandleDict: 'TypeAlias' = Dict[str, object]"},{"role":"user","content":"-\n-T = TypeVar('T')\n+from unique_identifier_msgs.msg import UUID"},{"role":"user","content":"-class SendGoalKWargs(TypedDict):\n-    feedback_callback: Optional[Callable[[FeedbackT], None]]\n-    goal_uuid: Optional[UUID]\n+class ClientGoalHandleDict(TypedDict, total=False):\n+    goal: Any\n+    cancel: Any\n+    result: Any\n+    feedback: Any\n+    status: Any"},{"role":"user","content":"-class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n+class ClientGoalHandle():"},{"role":"user","content":"-    def __init__(self, action_client: 'ActionClient[GoalT, ResultT, FeedbackT]',\n-                 goal_id: UUID, goal_response: SendGoalServiceResponse):\n+    def __init__(self, action_client, goal_id, goal_response):"},{"role":"user","content":"-    def __eq__(self, other: object) -> bool:\n-        if not isinstance(other, ClientGoalHandle):\n-            return False\n+    def __eq__(self, other):"},{"role":"user","content":"-    def __ne__(self, other: object) -> bool:\n-        if not isinstance(other, ClientGoalHandle):\n-            return True\n+    def __ne__(self, other):"},{"role":"user","content":"-    def __repr__(self) -> str:\n+    def __repr__(self):"},{"role":"user","content":"-    def goal_id(self) -> UUID:\n+    def goal_id(self):"},{"role":"user","content":"-    def stamp(self) -> Time:\n+    def stamp(self):"},{"role":"user","content":"-    def accepted(self) -> bool:\n+    def accepted(self):"},{"role":"user","content":"-    def status(self) -> int:\n+    def status(self):"},{"role":"user","content":"-    def cancel_goal(self) -> Optional[CancelGoal.Response]:\n+    def cancel_goal(self):"},{"role":"user","content":"-    def cancel_goal_async(self) -> Future[CancelGoal.Response]:\n+    def cancel_goal_async(self):"},{"role":"user","content":"-    def get_result(self) -> Optional[GetResultServiceResponse[ResultT]]:\n+    def get_result(self):"},{"role":"user","content":"-    def get_result_async(self) -> Future[GetResultServiceResponse[ResultT]]:\n+    def get_result_async(self):"},{"role":"user","content":"-class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n-                   Waitable['ClientGoalHandleDict[ResultT, FeedbackT]']):\n+class ActionClient(Waitable[ClientGoalHandleDict]):"},{"role":"user","content":"-        node: 'Node',\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n+        node,\n+        action_type,\n+        action_name,"},{"role":"user","content":"-        callback_group: 'Optional[CallbackGroup]' = None,\n-        goal_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        result_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        cancel_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        feedback_sub_qos_profile: QoSProfile = QoSProfile(depth=10),\n-        status_sub_qos_profile: QoSProfile = qos_profile_action_status_default\n-    ) -> None:\n+        callback_group=None,\n+        goal_service_qos_profile=qos_profile_services_default,\n+        result_service_qos_profile=qos_profile_services_default,\n+        cancel_service_qos_profile=qos_profile_services_default,\n+        feedback_sub_qos_profile=QoSProfile(depth=10),\n+        status_sub_qos_profile=qos_profile_action_status_default\n+    ):"},{"role":"user","content":"-        self._goal_handles: Dict[bytes,\n-                                 weakref.ReferenceType[ClientGoalHandle[GoalT,\n-                                                                        ResultT,\n-                                                                        FeedbackT]]] = {}\n+        self._goal_handles = {}"},{"role":"user","content":"-        self._pending_goal_requests: Dict[int, Future[ClientGoalHandle[GoalT,\n-                                                                       ResultT,\n-                                                                       FeedbackT]]] = {}\n+        self._pending_goal_requests = {}"},{"role":"user","content":"-        self._goal_sequence_number_to_goal_id: Dict[int, UUID] = {}\n+        self._goal_sequence_number_to_goal_id = {}"},{"role":"user","content":"-        self._pending_cancel_requests: Dict[int, Future[CancelGoal.Response]] = {}\n+        self._pending_cancel_requests = {}"},{"role":"user","content":"-        self._pending_result_requests: Dict[int, Future[GetResultServiceResponse[ResultT]]] = {}\n+        self._pending_result_requests = {}"},{"role":"user","content":"-        self._result_sequence_number_to_goal_id: Dict[int, UUID] = {}\n+        self._result_sequence_number_to_goal_id = {}"},{"role":"user","content":"-        self._feedback_callbacks: Dict[bytes, Callable[[FeedbackT], None]] = {}\n+        self._feedback_callbacks = {}"},{"role":"user","content":"-    def _generate_random_uuid(self) -> UUID:\n+    def _generate_random_uuid(self):"},{"role":"user","content":"-    def _remove_pending_request(self, future: Future[T], pending_requests: Dict[int, Future[T]]\n-                                ) -> Optional[int]:\n+    def _remove_pending_request(self, future, pending_requests):"},{"role":"user","content":"-    def _remove_pending_goal_request(self,\n-                                     future: Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]]\n-                                     ) -> None:\n+    def _remove_pending_goal_request(self, future):"},{"role":"user","content":"-    def _remove_pending_cancel_request(self, future: Future[CancelGoal.Response]) -> None:\n+    def _remove_pending_cancel_request(self, future):"},{"role":"user","content":"-    def _remove_pending_result_request(self, future: Future[GetResultServiceResponse[ResultT]]\n-                                       ) -> None:\n+    def _remove_pending_result_request(self, future):"},{"role":"user","content":"-    def is_ready(self, wait_set: _rclpy.WaitSet) -> bool:\n+    def is_ready(self, wait_set):"},{"role":"user","content":"-    def take_data(self) -> 'ClientGoalHandleDict[ResultT, FeedbackT]':\n+    def take_data(self) -> ClientGoalHandleDict:"},{"role":"user","content":"-        data: 'ClientGoalHandleDict[ResultT, FeedbackT]' = {}\n+        data: ClientGoalHandleDict = {}"},{"role":"user","content":"-    async def execute(self, taken_data: 'ClientGoalHandleDict[ResultT, FeedbackT]') -> None:\n+    async def execute(self, taken_data: ClientGoalHandleDict) -> None:"},{"role":"user","content":"-                    status_goal_handle = self._goal_handles[goal_uuid]()\n-                    if status_goal_handle is not None:\n-                        status_goal_handle._status = status\n+                    goal_handle = self._goal_handles[goal_uuid]()\n+                    if goal_handle is not None:\n+                        goal_handle._status = status"},{"role":"user","content":"-    def get_num_entities(self) -> NumberOfEntities:\n+    def get_num_entities(self):"},{"role":"user","content":"-    def add_to_wait_set(self, wait_set: _rclpy.WaitSet) -> None:\n+    def add_to_wait_set(self, wait_set):"},{"role":"user","content":"-    def __enter__(self) -> None:\n-        self._client_handle.__enter__()\n+    def __enter__(self):\n+        return self._client_handle.__enter__()"},{"role":"user","content":"-    def __exit__(self, t: Optional[Type[BaseException]], v: Optional[BaseException],\n-                 tb: Optional[TracebackType]) -> None:\n+    def __exit__(self, t, v, tb):"},{"role":"user","content":"-    def send_goal(self, goal: GoalT, **kwargs: 'Unpack[SendGoalKWargs]'\n-                  ) -> Optional[GetResultServiceResponse[ResultT]]:\n+    def send_goal(self, goal, **kwargs):"},{"role":"user","content":"-        def unblock(future: Future[Any]) -> None:\n+        def unblock(future):"},{"role":"user","content":"-        exeception = send_goal_future.exception()\n-        if exeception is not None:\n-            raise exeception\n+        if send_goal_future.exception() is not None:\n+            raise send_goal_future.exception()"},{"role":"user","content":"-        if goal_handle is None:\n-            return None"},{"role":"user","content":"-    def send_goal_async(\n-        self,\n-        goal: GoalT,\n-        feedback_callback: Optional[Callable[[FeedbackT], None]] = None,\n-        goal_uuid: Optional[UUID] = None\n-    ) -> Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]]:\n+    def send_goal_async(self, goal, feedback_callback=None, goal_uuid=None):"},{"role":"user","content":"-        future: Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]] = Future()\n+        future = Future()"},{"role":"user","content":"-    def _cancel_goal(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                     ) -> Optional[CancelGoal.Response]:\n+    def _cancel_goal(self, goal_handle):"},{"role":"user","content":"-        def unblock(future: Future[Any]) -> None:\n+        def unblock(future):"},{"role":"user","content":"-        exeception = future.exception()\n-        if exeception is not None:\n-            raise exeception\n+        if future.exception() is not None:\n+            raise future.exception()"},{"role":"user","content":"-    def _cancel_goal_async(\n-        self,\n-        goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-    ) -> Future[CancelGoal.Response]:\n+    def _cancel_goal_async(self, goal_handle):"},{"role":"user","content":"-        future: Future[CancelGoal.Response] = Future()\n+        future = Future()"},{"role":"user","content":"-    def _get_result(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                    ) -> Optional[GetResultServiceResponse[ResultT]]:\n+    def _get_result(self, goal_handle):"},{"role":"user","content":"-        def unblock(future: Future[Any]) -> None:\n+        def unblock(future):"},{"role":"user","content":"-        exception = future.exception()\n-        if exception is not None:\n-            raise exception\n+        if future.exception() is not None:\n+            raise future.exception()"},{"role":"user","content":"-    def _get_result_async(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                          ) -> Future[GetResultServiceResponse[ResultT]]:\n+    def _get_result_async(self, goal_handle):"},{"role":"user","content":"-        future: Future[GetResultServiceResponse[ResultT]] = Future()\n+        future = Future()"},{"role":"user","content":"-    def server_is_ready(self) -> bool:\n+    def server_is_ready(self):"},{"role":"user","content":"-    def wait_for_server(self, timeout_sec: Optional[float] = None) -> bool:\n+    def wait_for_server(self, timeout_sec=None):"},{"role":"user","content":"-    def destroy(self) -> None:\n+    def destroy(self):"},{"role":"user","content":"-from types import TracebackType\n-from typing import (Any, Callable, Dict, Generic, Literal, Optional, Tuple, Type,\n-                    TYPE_CHECKING, TypedDict, TypeVar)\n-\n+from typing import Any, TypedDict"},{"role":"user","content":"-from action_msgs.srv._cancel_goal import CancelGoal\n+"},{"role":"user","content":"-from rclpy.type_support import (Action, check_for_type_support, FeedbackMessage, FeedbackT,\n-                                GetResultServiceRequest, GetResultServiceResponse, GoalT, ResultT,\n-                                SendGoalServiceRequest)\n+from rclpy.type_support import check_for_type_support"},{"role":"user","content":"-from unique_identifier_msgs.msg import UUID\n-\n-\n-if TYPE_CHECKING:\n-    from typing_extensions import TypeAlias\n-\n-    from rclpy.callback_groups import CallbackGroup\n-    from rclpy.node import Node\n-\n-    ServerGoalHandleDictGoalT = TypeVar('ServerGoalHandleDictGoalT')\n-\n-    class ServerGoalHandleDict(TypedDict,\n-                               Generic[ServerGoalHandleDictGoalT],\n-                               total=False):\n-        goal: Tuple['_rclpy.rmw_request_id_t', SendGoalServiceRequest[ServerGoalHandleDictGoalT]]\n-        cancel: Tuple['_rclpy.rmw_request_id_t', CancelGoal.Request]\n-        result: Tuple['_rclpy.rmw_request_id_t', GetResultServiceRequest]\n-        expired: Tuple[GoalInfo, ...]\n-else:\n-    ServerGoalHandleDict: 'TypeAlias' = Dict[str, object]\n-"},{"role":"user","content":"-class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n+class ServerGoalHandleDict(TypedDict, total=False):\n+    goal: Any\n+    cancel: Any\n+    result: Any\n+    expired: Any\n+\n+\n+class ServerGoalHandle:"},{"role":"user","content":"-    def __init__(\n-        self,\n-        action_server: 'ActionServer[GoalT, ResultT, FeedbackT]',\n-        goal_info: GoalInfo,\n-        goal_request: GoalT\n-    ) -> None:\n+    def __init__(self, action_server, goal_info, goal_request):"},{"role":"user","content":"-    def __eq__(self, other: object) -> bool:\n-        if isinstance(other, ServerGoalHandle):\n-            return self.goal_id == other.goal_id\n-        return False\n+    def __eq__(self, other):\n+        return self.goal_id == other.goal_id"},{"role":"user","content":"-    def __ne__(self, other: object) -> bool:\n-        if isinstance(other, ServerGoalHandle):\n-            return self.goal_id != other.goal_id\n-        return True\n+    def __ne__(self, other):\n+        return self.goal_id != other.goal_id"},{"role":"user","content":"-    def request(self) -> GoalT:\n+    def request(self):"},{"role":"user","content":"-    def goal_id(self) -> UUID:\n+    def goal_id(self):"},{"role":"user","content":"-    def is_active(self) -> bool:\n+    def is_active(self):"},{"role":"user","content":"-    def is_cancel_requested(self) -> bool:\n+    def is_cancel_requested(self):"},{"role":"user","content":"-    def status(self) -> int:\n+    def status(self):"},{"role":"user","content":"-    def _update_state(self, event: _rclpy.GoalEvent) -> None:\n+    def _update_state(self, event):"},{"role":"user","content":"-    def execute(\n-        self,\n-        execute_callback: Optional[Callable[['ServerGoalHandle[GoalT, ResultT, FeedbackT]'],\n-                                   ResultT]] = None\n-    ) -> None:\n+    def execute(self, execute_callback=None):"},{"role":"user","content":"-    def publish_feedback(self, feedback: FeedbackMessage[FeedbackT]) -> None:\n+    def publish_feedback(self, feedback):"},{"role":"user","content":"-    def succeed(self) -> None:\n+    def succeed(self):"},{"role":"user","content":"-    def abort(self) -> None:\n+    def abort(self):"},{"role":"user","content":"-    def canceled(self) -> None:\n+    def canceled(self):"},{"role":"user","content":"-    def destroy(self) -> None:\n+    def destroy(self):"},{"role":"user","content":"-def default_handle_accepted_callback(goal_handle: ServerGoalHandle[Any, Any, Any]) -> None:\n+def default_handle_accepted_callback(goal_handle):"},{"role":"user","content":"-def default_goal_callback(\n-    goal_request: SendGoalServiceRequest[Any]\n-) -> Literal[GoalResponse.ACCEPT]:\n+def default_goal_callback(goal_request):"},{"role":"user","content":"-def default_cancel_callback(cancel_request: CancelGoal.Request) -> Literal[CancelResponse.REJECT]:\n+def default_cancel_callback(cancel_request):"},{"role":"user","content":"-class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable['ServerGoalHandleDict[GoalT]']):\n+class ActionServer(Waitable[ServerGoalHandleDict]):"},{"role":"user","content":"-        node: 'Node',\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT],\n+        node,\n+        action_type,\n+        action_name,\n+        execute_callback,"},{"role":"user","content":"-        callback_group: 'Optional[CallbackGroup]' = None,\n-        goal_callback: Callable[[CancelGoal.Request], GoalResponse] = default_goal_callback,\n-        handle_accepted_callback: Callable[[ServerGoalHandle[GoalT,\n-                                                             ResultT,\n-                                                             FeedbackT]],\n-                                           None] = default_handle_accepted_callback,\n-        cancel_callback: Callable[[CancelGoal.Request], CancelResponse] = default_cancel_callback,\n-        goal_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        result_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        cancel_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        feedback_pub_qos_profile: QoSProfile = QoSProfile(depth=10),\n-        status_pub_qos_profile: QoSProfile = qos_profile_action_status_default,\n-        result_timeout: int = 10\n-    ) -> None:\n+        callback_group=None,\n+        goal_callback=default_goal_callback,\n+        handle_accepted_callback=default_handle_accepted_callback,\n+        cancel_callback=default_cancel_callback,\n+        goal_service_qos_profile=qos_profile_services_default,\n+        result_service_qos_profile=qos_profile_services_default,\n+        cancel_service_qos_profile=qos_profile_services_default,\n+        feedback_pub_qos_profile=QoSProfile(depth=10),\n+        status_pub_qos_profile=qos_profile_action_status_default,\n+        result_timeout=10\n+    ):"},{"role":"user","content":"-        self._goal_handles: Dict[bytes, ServerGoalHandle[GoalT, ResultT, FeedbackT]] = {}\n+        self._goal_handles = {}"},{"role":"user","content":"-        self._result_futures: Dict[bytes, Future[GetResultServiceResponse[ResultT]]] = {}\n+        self._result_futures = {}"},{"role":"user","content":"-    async def _execute_goal_request(\n-        self,\n-        request_header_and_message: Tuple['_rclpy.rmw_request_id_t',\n-                                          SendGoalServiceRequest[GoalT]]\n-    ) -> None:\n+    async def _execute_goal_request(self, request_header_and_message):"},{"role":"user","content":"-    async def _execute_goal(\n-        self,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT],\n-        goal_handle: ServerGoalHandle[GoalT, ResultT, FeedbackT]\n-    ) -> None:\n+    async def _execute_goal(self, execute_callback, goal_handle):"},{"role":"user","content":"-    async def _execute_cancel_request(\n-        self,\n-        request_header_and_message: Tuple['_rclpy.rmw_request_id_t', CancelGoal.Request]\n-    ) -> None:\n+    async def _execute_cancel_request(self, request_header_and_message):"},{"role":"user","content":"-    async def _execute_get_result_request(\n-        self,\n-        request_header_and_message: Tuple['_rclpy.rmw_request_id_t', GetResultServiceRequest]\n-    ) -> None:\n+    async def _execute_get_result_request(self, request_header_and_message):"},{"role":"user","content":"-    async def _execute_expire_goals(self, expired_goals: Tuple[GoalInfo, ...]) -> None:\n+    async def _execute_expire_goals(self, expired_goals):"},{"role":"user","content":"-    def _send_result_response(\n-        self,\n-        request_header: '_rclpy.rmw_request_id_t',\n-        future: Future[GetResultServiceResponse[ResultT]]\n-    ) -> None:\n+    def _send_result_response(self, request_header, future):"},{"role":"user","content":"-    def action_type(self) -> Type[Action[GoalT, ResultT, FeedbackT]]:\n+    def action_type(self):"},{"role":"user","content":"-    def is_ready(self, wait_set: _rclpy.WaitSet) -> bool:\n+    def is_ready(self, wait_set):"},{"role":"user","content":"-    def take_data(self) -> 'ServerGoalHandleDict[GoalT]':\n+    def take_data(self) -> ServerGoalHandleDict:"},{"role":"user","content":"-        data: 'ServerGoalHandleDict[GoalT]' = {}\n+        data: ServerGoalHandleDict = {}"},{"role":"user","content":"-    async def execute(self, taken_data: 'ServerGoalHandleDict[GoalT]') -> None:\n+    async def execute(self, taken_data: ServerGoalHandleDict) -> None:"},{"role":"user","content":"-    def get_num_entities(self) -> NumberOfEntities:\n+    def get_num_entities(self):"},{"role":"user","content":"-    def add_to_wait_set(self, wait_set: _rclpy.WaitSet) -> None:\n+    def add_to_wait_set(self, wait_set):"},{"role":"user","content":"-    def __enter__(self) -> None:\n-        self._handle.__enter__()\n+    def __enter__(self):\n+        return self._handle.__enter__()"},{"role":"user","content":"-    def __exit__(self, t: Optional[Type[BaseException]],\n-                 v: Optional[BaseException], tb: Optional[TracebackType]) -> None:\n+    def __exit__(self, t, v, tb):"},{"role":"user","content":"-    def notify_execute(\n-        self,\n-        goal_handle: ServerGoalHandle[GoalT, ResultT, FeedbackT],\n-        execute_callback: Optional[Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]],\n-                                            ResultT]]\n-    ) -> None:\n+    def notify_execute(self, goal_handle, execute_callback):"},{"role":"user","content":"-        if self._node.executor:\n-            self._node.executor.create_task(self._execute_goal, execute_callback, goal_handle)\n+        self._node.executor.create_task(self._execute_goal, execute_callback, goal_handle)"},{"role":"user","content":"-    def notify_goal_done(self) -> None:\n+    def notify_goal_done(self):"},{"role":"user","content":"-    def register_handle_accepted_callback(\n-        self,\n-        handle_accepted_callback: Optional[Callable[[\n-            ServerGoalHandle[GoalT, ResultT, FeedbackT]], None]]\n-    ) -> None:\n+    def register_handle_accepted_callback(self, handle_accepted_callback):"},{"role":"user","content":"-    def register_goal_callback(\n-        self,\n-        goal_callback: Optional[Callable[[SendGoalServiceRequest[GoalT]], GoalResponse]]\n-    ) -> None:\n+    def register_goal_callback(self, goal_callback):"},{"role":"user","content":"-    def register_cancel_callback(\n-        self,\n-        cancel_callback: Optional[Callable[[CancelGoal.Request], CancelResponse]]\n-    ) -> None:\n+    def register_cancel_callback(self, cancel_callback):"},{"role":"user","content":"-    def register_execute_callback(\n-        self,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT]\n-    ) -> None:\n+    def register_execute_callback(self, execute_callback):"},{"role":"user","content":"-    def destroy(self) -> None:\n+    def destroy(self):"},{"role":"user","content":"-from rclpy.type_support import Srv, SrvRequestT, SrvResponseT\n+from rclpy.type_support import Srv, SrvEventT, SrvRequestT, SrvResponseT"},{"role":"user","content":"-class Client(Generic[SrvRequestT, SrvResponseT]):\n+class Client(Generic[SrvRequestT, SrvResponseT, SrvEventT]):"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],"},{"role":"user","content":"-    def __enter__(self) -> 'Client[SrvRequestT, SrvResponseT]':\n+    def __enter__(self) -> 'Client[SrvRequestT, SrvResponseT, SrvEventT]':"},{"role":"user","content":"-\n-from action_msgs.msg import GoalInfo\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal"},{"role":"user","content":"-from type_support import (MsgT, Action, GoalT, ResultT, FeedbackT, SendGoalServiceResponse,\n-                          GetResultServiceResponse, FeedbackMessage, SendGoalServiceRequest, GetResultServiceRequest)\n+from rclpy.type_support import MsgT"},{"role":"user","content":"-class ActionClient(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n-\n-    def __init__(\n-            self,\n-            node: Node,\n-            pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n-            goal_service_qos: rmw_qos_profile_t,\n-            result_service_qos: rmw_qos_profile_t,\n-            cancel_service_qos: rmw_qos_profile_t,\n-            feedback_service_qos: rmw_qos_profile_t,\n-            status_topci_qos: rmw_qos_profile_t\n-        ) -> None: ...\n-\n-    @property\n-    def pointer(self) -> int:\n-        \"\"\"Get the address of the entity as an integer.\"\"\"\n-\n-    def take_goal_response(self, pymsg_type: type[SendGoalServiceResponse]\n-                           ) -> tuple[int, SendGoalServiceResponse] | tuple[None, None]:\n-        \"\"\"Take an action goal response.\"\"\"\n-\n-    def send_result_request(self, pyrequest: GetResultServiceRequest) -> int:\n-        \"\"\"Send an action result requst.\"\"\"\n-\n-    def take_cancel_response(self, pymsg_type: type[CancelGoal.Response]\n-                             ) -> tuple[int, CancelGoal.Response] | tuple[None, None]:\n-        \"\"\"Take an action cancel response.\"\"\"\n-    \n-    def take_feedback(self, pymsg_type: type[FeedbackMessage[FeedbackT]]\n-                      ) -> FeedbackMessage[FeedbackT] | None:\n-        \"\"\"Take a feedback message from a given action client.\"\"\"\n-\n-    def send_cancel_request(self: CancelGoal.Request) -> int:\n-        \"\"\"Send an action cancel request.\"\"\"\n-\n-    def send_goal_request(self: SendGoalServiceRequest[GoalT]) -> int:\n-        \"\"\"Send an action goal request.\"\"\"\n-    \n-    def take_result_response(self, pymsg_type: type[GetResultServiceResponse[ResultT]]\n-                             ) -> tuple[int, GetResultServiceResponse[ResultT]] | tuple[None, None]:\n-        \"\"\"Take an action result response.\"\"\"\n-\n-    def get_num_entities(self) -> tuple[int, int, int, int, int]:\n-        \"\"\"Get the number of wait set entities that make up an action entity.\"\"\"\n-\n-    def is_action_server_available(self) -> bool:\n-        \"\"\"Check if an action server is available for the given action client.\"\"\"   \n-\n-    def add_to_waitset(self, waitset: WaitSet) -> None:\n-        \"\"\"Add an action entity to a wait set.\"\"\"\n-\n-    def is_ready(self) -> bool:\n-        \"\"\"Check if an action entity has any ready wait set entities.\"\"\"\n-\n-    def take_status(self, pymsg_type: type[GoalStatusArray]) -> GoalStatusArray | None:\n-        \"\"\"Take an action status response.\"\"\"\n-\n-\n-class GoalEvent(Enum):\n-    _value_: int\n-    EXECUTE = ...\n-    CANCEL_GOAL = ...\n-    SUCCEED = ...\n-    ABORT = ...\n-    CANCELED = ...\n-\n-\n-class rmw_request_id_t:\n-    writer_guid: list[int]\n-    sequence_number: int\n-\n-\n-class ActionServer(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n-\n-    def __init__(\n-        self,\n-        node: Node,\n-        rclpy_clock: Clock,\n-        pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n-        goal_service_qos: rmw_qos_profile_t,\n-        result_service_qos: rmw_qos_profile_t,\n-        cancel_service_qos: rmw_qos_profile_t,\n-        feedback_topic_qos: rmw_qos_profile_t,\n-        status_topic_qos: rmw_qos_profile_t,\n-        result_timeout: float\n-    ) -> None: ...\n-\n-    @property\n-    def pointer(self) -> int:\n-        \"\"\"Get the address of the entity as an integer.\"\"\"\n-\n-    def take_goal_request(\n-        self,\n-        pymsg_type: type[SendGoalServiceRequest[GoalT]]\n-    ) -> tuple[rmw_request_id_t, SendGoalServiceRequest[GoalT]] | tuple[None, None]:\n-        \"\"\"Take an action goal request.\"\"\"\n-\n-    def send_goal_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: SendGoalServiceResponse\n-    ) -> None:\n-        \"\"\"Send an action goal response.\"\"\"\n-\n-    def send_result_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: GetResultServiceResponse[ResultT]\n-    ) -> None:\n-        \"\"\"Send an action result response.\"\"\"\n-\n-    def take_cancel_request(\n-        self,\n-        pymsg_type: type[CancelGoal.Request]\n-    ) -> tuple[rmw_request_id_t, CancelGoal.Request] | tuple[None, None]:\n-        \"\"\"Take an action cancel request.\"\"\"\n-\n-    def take_result_request(\n-        self,\n-        pymsg_type: type[GetResultServiceRequest]\n-    ) -> tuple[rmw_request_id_t, GetResultServiceRequest] | tuple[None, None]:\n-        \"\"\"Take an action result request.\"\"\"\n-\n-    def send_cancel_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: int\n-    ) -> None:\n-        \"\"\"Send an action cancel response.\"\"\"\n-\n-    def publish_feedback(\n-        self,\n-        pymsg: FeedbackMessage[FeedbackT]\n-    ) -> None:\n-        \"\"\"Publish a feedback message from a given action server.\"\"\"\n-    \n-    def publish_status(self) -> None:\n-        \"\"\"Publish a status message from a given action server.\"\"\"\n-\n-    def notify_goal_done(self) -> None:\n-        \"\"\"Notify goal is done.\"\"\"\n-\n-    def goal_exists(self, pygoal_info: GoalInfo) -> bool:\n-        \"\"\"Check is a goal exists in the server.\"\"\"\n-\n-    def process_cancel_request(\n-        self,\n-        pycancel_request: CancelGoal.Request,\n-        pycancel_response_tpye: type[CancelGoal.Response]\n-    ) -> CancelGoal.Response:\n-        \"\"\"Process a cancel request\"\"\"\n-\n-    def expire_goals(self, max_num_goals: int) -> tuple[GoalInfo, ...]:\n-        \"\"\"Expired goals.\"\"\"\n-\n-    def get_num_entities(self) -> tuple[int, int, int, int, int]:\n-        \"\"\"Get the number of wait set entities that make up an action entity.\"\"\"\n-\n-    def is_ready(self, wait_set: WaitSet) -> tuple[bool, bool, bool, bool]:\n-        \"\"\"Check if an action entity has any ready wait set entities.\"\"\"\n-\n-    def add_to_waitset(self, wait_set: WaitSet) -> None:\n-        \"\"\"Add an action entity to a wait set.\"\"\"\n-\n-\n-class ActionGoalHandle:\n-\n-    def __init__(self, action_server: ActionServer, pygoal_info_msg: GoalInfo) -> None:\n-        ...\n-\n-    @property\n-    def pointer(self) -> int:\n-        \"\"\"Get the address of the entity as an integer.\"\"\"\n-\n-    def get_status(self) -> GoalEvent:\n-        \"\"\"Get the status of a goal.\"\"\"\n-\n-    def update_goal_state(self, event: GoalEvent) -> None:\n-        \"\"\"Update a goal state.\"\"\"\n-\n-    def is_active(self) -> bool:\n-        \"\"\"Check if a goal is active.\"\"\"\n-\n-"},{"role":"user","content":"-\n+  "},{"role":"user","content":"-from impl import _rclpy_pybind11\n+from rclpy.impl import _rclpy_pybind11"},{"role":"user","content":"+from rclpy.type_support import SrvEventT"},{"role":"user","content":"-        self._clients: List[Client[Any, Any]] = []\n-        self._services: List[Service[Any, Any]] = []\n+        self._clients: List[Client[Any, Any, Any]] = []\n+        self._services: List[Service[Any, Any, Any]] = []"},{"role":"user","content":"-    def clients(self) -> Iterator[Client[Any, Any]]:\n+    def clients(self) -> Iterator[Client[Any, Any, Any]]:"},{"role":"user","content":"-    def services(self) -> Iterator[Service[Any, Any]]:\n+    def services(self) -> Iterator[Service[Any, Any, Any]]:"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],"},{"role":"user","content":"-    ) -> Client[SrvRequestT, SrvResponseT]:\n+    ) -> Client[SrvRequestT, SrvResponseT, SrvEventT]:"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],"},{"role":"user","content":"-    ) -> Service[SrvRequestT, SrvResponseT]:\n+    ) -> Service[SrvRequestT, SrvResponseT, SrvEventT]:"},{"role":"user","content":"-    def destroy_client(self, client: Client[Any, Any]) -> bool:\n+    def destroy_client(self, client: Client[Any, Any, Any]) -> bool:"},{"role":"user","content":"-    def destroy_service(self, service: Service[Any, Any]) -> bool:\n+    def destroy_service(self, service: Service[Any, Any, Any]) -> bool:"},{"role":"user","content":"-from rclpy.type_support import Srv, SrvRequestT, SrvResponseT\n+from rclpy.type_support import Srv, SrvEventT, SrvRequestT, SrvResponseT"},{"role":"user","content":"-class Service(Generic[SrvRequestT, SrvResponseT]):\n+class Service(Generic[SrvRequestT, SrvResponseT, SrvEventT]):"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],"},{"role":"user","content":"-    def __enter__(self) -> 'Service[SrvRequestT, SrvResponseT]':\n+    def __enter__(self) -> 'Service[SrvRequestT, SrvResponseT, SrvEventT]':"},{"role":"user","content":"-from typing import Any, ClassVar, Iterable, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union\n+from typing import NoReturn, Optional, Protocol, Type, TypeVar, Union"},{"role":"user","content":"-\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal\n-from builtin_interfaces.msg import Time"},{"role":"user","content":"-from service_msgs.msg._service_event_info import ServiceEventInfo\n-from unique_identifier_msgs.msg import UUID\n-\n-\n-if TYPE_CHECKING:\n-    from typing_extensions import TypeAlias"},{"role":"user","content":"-    _TYPE_SUPPORT: ClassVar[Optional[PyCapsule]]\n+    _TYPE_SUPPORT: Optional[PyCapsule]"},{"role":"user","content":"-    _CREATE_ROS_MESSAGE:  ClassVar[Optional[PyCapsule]]\n-    _CONVERT_FROM_PY:  ClassVar[Optional[PyCapsule]]\n-    _CONVERT_TO_PY:  ClassVar[Optional[PyCapsule]]\n-    _DESTROY_ROS_MESSAGE:  ClassVar[Optional[PyCapsule]]\n+    _CREATE_ROS_MESSAGE:  Optional[PyCapsule]\n+    _CONVERT_FROM_PY:  Optional[PyCapsule]\n+    _CONVERT_TO_PY:  Optional[PyCapsule]\n+    _DESTROY_ROS_MESSAGE:  Optional[PyCapsule]"},{"role":"user","content":"+SrvEventT = TypeVar('SrvEventT', bound=Msg)"},{"role":"user","content":"-class EventMessage(Msg, Protocol[SrvRequestT, SrvResponseT]):\n-    info: ServiceEventInfo\n-    request: Iterable[SrvRequestT]\n-    response: Iterable[SrvResponseT]\n-\n-\n-class Srv(Protocol[SrvRequestT, SrvResponseT], metaclass=CommonMsgSrvMetaClass):\n+class Srv(Protocol[SrvRequestT, SrvResponseT, SrvEventT], metaclass=CommonMsgSrvMetaClass):"},{"role":"user","content":"-    Event: Type[EventMessage[SrvRequestT, SrvResponseT]]\n-\n-\n-GoalT = TypeVar('GoalT', bound=Msg)\n-ResultT = TypeVar('ResultT', bound=Msg)\n-FeedbackT = TypeVar('FeedbackT', bound=Msg)\n-\n-\n-class SendGoalServiceRequest(Msg, Protocol[GoalT]):\n-    goal_id: UUID\n-    goal: GoalT\n-\n-\n-class SendGoalServiceResponse(Msg, Protocol):\n-    accepted: bool\n-    stamp: Time\n-\n-\n-SendGoalService: 'TypeAlias' = Srv[SendGoalServiceRequest[GoalT], SendGoalServiceResponse]\n-\n-\n-class GetResultServiceRequest(Msg, Protocol):\n-    goal_id: UUID\n-\n-\n-class GetResultServiceResponse(Msg, Protocol[ResultT]):\n-    status: int\n-    result: ResultT\n-\n-\n-GetResultService: 'TypeAlias' = Srv[GetResultServiceRequest, GetResultServiceResponse[ResultT]]\n-\n-\n-class FeedbackMessage(Msg, Protocol[FeedbackT]):\n-    goal_id: UUID\n-    feedback: FeedbackT\n-\n-\n-class Impl(Protocol[GoalT, ResultT, FeedbackT]):\n-\n-    SendGoalService: Type[SendGoalService[GoalT]]\n-    GetResultService: Type[GetResultService[ResultT]]\n-    FeedbackMessage: Type[FeedbackMessage[FeedbackT]]\n-    CancelGoalService: ClassVar[Type[CancelGoal]]\n-    GoalStatusMessage: ClassVar[Type[GoalStatusArray]]\n-\n-\n-class Action(Protocol[GoalT,\n-                      ResultT,\n-                      FeedbackT],\n-             metaclass=CommonMsgSrvMetaClass):\n-    Goal: Type[GoalT]\n-    Result: Type[ResultT]\n-    Feedback: Type[FeedbackT]\n+    Event: Type[SrvEventT]"},{"role":"user","content":"-    Impl: Type[Impl[GoalT, ResultT, FeedbackT]]\n+    def __init__(self) -> NoReturn: ..."},{"role":"user","content":"-SrvT = TypeVar('SrvT', bound=Srv)\n-ActionT = TypeVar('ActionT', bound=Action)\n+SrvT = TypeVar('SrvT', bound=Type[Srv])"},{"role":"user","content":"-def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv[Any, Any],\n-                                                       Action[Any, Any, Any]]]) -> None:\n+def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv]]) -> None:"},{"role":"user","content":"-def check_is_valid_srv_type(srv_type: Type[Srv[Any, Any]]) -> None:\n+def check_is_valid_srv_type(srv_type: Type[Srv]) -> None:"},{"role":"user","content":"+    from typing_extensions import Self\n+"},{"role":"user","content":"-    def __enter__(self) -> None:\n+    def __enter__(self) -> 'Self':"},{"role":"user","content":"-    \"Publish a feedback message from a given action server.\")\n+    \" Publish a feedback message from a given action server.\")"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  static void enable_ros_time(rclcpp::Clock::SharedPtr clock);\n-  static void disable_ros_time(rclcpp::Clock::SharedPtr clock);"},{"role":"user","content":"+  std::lock_guard<std::mutex> clock_guard(clock->get_clock_mutex());\n+"},{"role":"user","content":"-    disable_ros_time(clock);\n+    auto ret = rcl_disable_ros_time_override(clock->get_clock_handle());\n+    if (ret != RCL_RET_OK) {\n+      rclcpp::exceptions::throw_from_rcl_error(\n+        ret, \"Failed to disable ros_time_override_status\");\n+    }"},{"role":"user","content":"-    enable_ros_time(clock);\n+    auto ret = rcl_enable_ros_time_override(clock->get_clock_handle());\n+    if (ret != RCL_RET_OK) {\n+      rclcpp::exceptions::throw_from_rcl_error(\n+        ret, \"Failed to enable ros_time_override_status\");\n+    }"},{"role":"user","content":"-void TimeSource::enable_ros_time(std::shared_ptr<rclcpp::Clock> clock)\n-{\n-  auto ret = rcl_enable_ros_time_override(clock->get_clock_handle());\n-  if (ret != RCL_RET_OK) {\n-    rclcpp::exceptions::throw_from_rcl_error(\n-      ret, \"Failed to enable ros_time_override_status\");\n-  }\n-}\n-\n-void TimeSource::disable_ros_time(std::shared_ptr<rclcpp::Clock> clock)\n-{\n-  auto ret = rcl_disable_ros_time_override(clock->get_clock_handle());\n-  if (ret != RCL_RET_OK) {\n-    rclcpp::exceptions::throw_from_rcl_error(\n-      ret, \"Failed to enable ros_time_override_status\");\n-  }\n-}\n-"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from rclpy.qos import QoSDurabilityPolicy\n+from rclpy.qos import QoSPresetProfiles\n+from rclpy.qos import QoSReliabilityPolicy"},{"role":"user","content":"+\n+\n+def choose_qos(node, topic_name: str, qos_args):\n+    if (qos_args.qos_reliability is not None or\n+            qos_args.qos_durability is not None or\n+            qos_args.qos_depth is not None or\n+            qos_args.qos_history is not None or\n+            qos_args.qos_liveliness is not None or\n+            qos_args.qos_liveliness_lease_duration_seconds is not None):\n+\n+        return qos_profile_from_short_keys(\n+            qos_args.qos_profile,\n+            reliability=qos_args.qos_reliability,\n+            durability=qos_args.qos_durability,\n+            depth=qos_args.qos_depth,\n+            history=qos_args.qos_history,\n+            liveliness=qos_args.qos_liveliness,\n+            liveliness_lease_duration_s=qos_args.qos_liveliness_lease_duration_seconds)\n+\n+    qos_profile = QoSPresetProfiles.get_from_short_key(qos_args.qos_profile)\n+    reliability_reliable_endpoints_count = 0\n+    durability_transient_local_endpoints_count = 0\n+\n+    pubs_info = node.get_publishers_info_by_topic(topic_name)\n+    publishers_count = len(pubs_info)\n+    if publishers_count == 0:\n+        return qos_profile\n+\n+    for info in pubs_info:\n+        if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n+            reliability_reliable_endpoints_count += 1\n+        if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n+            durability_transient_local_endpoints_count += 1\n+\n+    # If all endpoints are reliable, ask for reliable\n+    if reliability_reliable_endpoints_count == publishers_count:\n+        qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n+    else:\n+        if reliability_reliable_endpoints_count > 0:\n+            print(\n+                'Some, but not all, publishers are offering '\n+                'QoSReliabilityPolicy.RELIABLE. Falling back to '\n+                'QoSReliabilityPolicy.BEST_EFFORT as it will connect '\n+                'to all publishers'\n+            )\n+        qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n+\n+    # If all endpoints are transient_local, ask for transient_local\n+    if durability_transient_local_endpoints_count == publishers_count:\n+        qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n+    else:\n+        if durability_transient_local_endpoints_count > 0:\n+            print(\n+                'Some, but not all, publishers are offering '\n+                'QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to '\n+                'QoSDurabilityPolicy.VOLATILE as it will connect '\n+                'to all publishers'\n+            )\n+        qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n+\n+    return qos_profile"},{"role":"user","content":"-from rclpy.qos import qos_profile_sensor_data"},{"role":"user","content":"+from ros2topic.api import add_qos_arguments\n+from ros2topic.api import choose_qos"},{"role":"user","content":"-            'topic',\n+            'topic_name',"},{"role":"user","content":"+        add_qos_arguments(parser, 'subscribe', 'sensor_data')"},{"role":"user","content":"-            '--window', '-w', type=positive_int, default=DEFAULT_WINDOW_SIZE,\n+            '--window', '-w', dest='window_size', type=positive_int, default=DEFAULT_WINDOW_SIZE,"},{"role":"user","content":"-            _rostopic_bw(node.node, args.topic, window_size=args.window)\n+            qos_profile = choose_qos(node.node, topic_name=args.topic_name, qos_args=args)\n+            _rostopic_bw(node.node, args.topic_name, qos_profile, window_size=args.window_size)"},{"role":"user","content":"-def _rostopic_bw(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n+def _rostopic_bw(node, topic, qos_profile, window_size=DEFAULT_WINDOW_SIZE):"},{"role":"user","content":"-        qos_profile_sensor_data,\n+        qos_profile,"},{"role":"user","content":"-from rclpy.qos import qos_profile_sensor_data"},{"role":"user","content":"+from ros2topic.api import add_qos_arguments\n+from ros2topic.api import choose_qos"},{"role":"user","content":"-            'topic',\n+            'topic_name',"},{"role":"user","content":"+        add_qos_arguments(parser, 'subscribe', 'sensor_data')"},{"role":"user","content":"-            '--window', '-w', type=positive_int, default=DEFAULT_WINDOW_SIZE,\n+            '--window', '-w', dest='window_size', type=positive_int, default=DEFAULT_WINDOW_SIZE,"},{"role":"user","content":"-        _rostopic_delay(\n-            node.node, args.topic, window_size=args.window)\n+        qos_profile = choose_qos(node.node, topic_name=args.topic_name, qos_args=args)\n+        _rostopic_delay(node.node, args.topic_name, qos_profile, window_size=args.window_size)"},{"role":"user","content":"-def _rostopic_delay(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n+def _rostopic_delay(node, topic, qos_profile, window_size=DEFAULT_WINDOW_SIZE):"},{"role":"user","content":"+    :param qos_profile: qos profile of the subscriber"},{"role":"user","content":"-        qos_profile_sensor_data)\n+        qos_profile)"},{"role":"user","content":"-from rclpy.qos import QoSDurabilityPolicy\n-from rclpy.qos import QoSPresetProfiles"},{"role":"user","content":"-from rclpy.qos import QoSReliabilityPolicy"},{"role":"user","content":"+from ros2topic.api import choose_qos"},{"role":"user","content":"-from ros2topic.api import qos_profile_from_short_keys"},{"role":"user","content":"-    def choose_qos(self, node, args):\n-\n-        if (args.qos_reliability is not None or\n-                args.qos_durability is not None or\n-                args.qos_depth is not None or\n-                args.qos_history is not None or\n-                args.qos_liveliness is not None or\n-                args.qos_liveliness_lease_duration_seconds is not None):\n-\n-            return qos_profile_from_short_keys(\n-                args.qos_profile,\n-                reliability=args.qos_reliability,\n-                durability=args.qos_durability,\n-                depth=args.qos_depth,\n-                history=args.qos_history,\n-                liveliness=args.qos_liveliness,\n-                liveliness_lease_duration_s=args.qos_liveliness_lease_duration_seconds)\n-\n-        qos_profile = QoSPresetProfiles.get_from_short_key(args.qos_profile)\n-        reliability_reliable_endpoints_count = 0\n-        durability_transient_local_endpoints_count = 0\n-\n-        pubs_info = node.get_publishers_info_by_topic(args.topic_name)\n-        publishers_count = len(pubs_info)\n-        if publishers_count == 0:\n-            return qos_profile\n-\n-        for info in pubs_info:\n-            if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n-                reliability_reliable_endpoints_count += 1\n-            if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n-                durability_transient_local_endpoints_count += 1\n-\n-        # If all endpoints are reliable, ask for reliable\n-        if reliability_reliable_endpoints_count == publishers_count:\n-            qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n-        else:\n-            if reliability_reliable_endpoints_count > 0:\n-                print(\n-                    'Some, but not all, publishers are offering '\n-                    'QoSReliabilityPolicy.RELIABLE. Falling back to '\n-                    'QoSReliabilityPolicy.BEST_EFFORT as it will connect '\n-                    'to all publishers'\n-                )\n-            qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n-\n-        # If all endpoints are transient_local, ask for transient_local\n-        if durability_transient_local_endpoints_count == publishers_count:\n-            qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n-        else:\n-            if durability_transient_local_endpoints_count > 0:\n-                print(\n-                    'Some, but not all, publishers are offering '\n-                    'QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to '\n-                    'QoSDurabilityPolicy.VOLATILE as it will connect '\n-                    'to all publishers'\n-                )\n-            qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n-\n-        return qos_profile\n-"},{"role":"user","content":"-            qos_profile = self.choose_qos(node, args)\n+            qos_profile = choose_qos(node, topic_name=args.topic_name, qos_args=args)"},{"role":"user","content":"-from rclpy.qos import qos_profile_sensor_data"},{"role":"user","content":"+from ros2topic.api import add_qos_arguments\n+from ros2topic.api import choose_qos"},{"role":"user","content":"+        add_qos_arguments(parser, 'subscribe', 'sensor_data')"},{"role":"user","content":"-        _rostopic_hz(node.node, topics, window_size=args.window_size, filter_expr=filter_expr,\n-                     use_wtime=args.use_wtime)\n+        _rostopic_hz(node.node, topics, qos_args=args, window_size=args.window_size,\n+                     filter_expr=filter_expr, use_wtime=args.use_wtime)"},{"role":"user","content":"-def _rostopic_hz(node, topics, window_size=DEFAULT_WINDOW_SIZE, filter_expr=None, use_wtime=False):\n+def _rostopic_hz(node, topics, qos_args, window_size=DEFAULT_WINDOW_SIZE, filter_expr=None,\n+                 use_wtime=False):"},{"role":"user","content":"+    :param qos_args: qos arguments used to pick the qos profile of the subscriber"},{"role":"user","content":"+        qos_profile = choose_qos(node, topic_name=topic, qos_args=qos_args)\n+"},{"role":"user","content":"-            qos_profile_sensor_data)\n+            qos_profile)"},{"role":"user","content":"+# Copyright 2025 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import re\n+import sys\n+import unittest\n+\n+from geometry_msgs.msg import PointStamped  # Used because delay requires a message with a header\n+\n+from launch import LaunchDescription\n+from launch.actions import ExecuteProcess\n+\n+import launch_testing\n+import launch_testing.actions\n+import launch_testing.asserts\n+import launch_testing.markers\n+import launch_testing.tools\n+import launch_testing_ros.tools\n+\n+import pytest\n+\n+import rclpy\n+from rclpy.executors import SingleThreadedExecutor\n+from rclpy.qos import DurabilityPolicy\n+from rclpy.qos import QoSProfile\n+from rclpy.qos import ReliabilityPolicy\n+from rclpy.utilities import get_rmw_implementation_identifier\n+\n+\n+# Skip cli tests on Windows while they exhibit pathological behavior\n+# https://github.com/ros2/build_farmer/issues/248\n+if sys.platform.startswith('win'):\n+    pytest.skip(\n+            'CLI tests can block for a pathological amount of time on Windows.',\n+            allow_module_level=True)\n+\n+\n+TEST_NODE = 'cli_bw_delay_hz_test_node'\n+TEST_NAMESPACE = 'cli_bw_delay_hz'\n+\n+\n+@pytest.mark.rostest\n+@launch_testing.markers.keep_alive\n+def generate_test_description():\n+    return LaunchDescription([\n+        # Always restart daemon to isolate tests.\n+        ExecuteProcess(\n+            cmd=['ros2', 'daemon', 'stop'],\n+            name='daemon-stop',\n+            on_exit=[\n+                ExecuteProcess(\n+                    cmd=['ros2', 'daemon', 'start'],\n+                    name='daemon-start',\n+                    on_exit=[\n+                        launch_testing.actions.ReadyToTest()\n+                    ],\n+                )\n+            ]\n+        )\n+    ])\n+\n+\n+class TestROS2TopicBwDelayHz(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.context = rclpy.context.Context()\n+        rclpy.init(context=self.context)\n+        self.node = rclpy.create_node(\n+            TEST_NODE, namespace=TEST_NAMESPACE, context=self.context\n+        )\n+        self.executor = SingleThreadedExecutor(context=self.context)\n+        self.executor.add_node(self.node)\n+\n+    def tearDown(self):\n+        self.node.destroy_node()\n+        rclpy.shutdown(context=self.context)\n+\n+    def helper_verb_basic(self, launch_service, proc_info, proc_output, verb, success_regex):\n+        params = [\n+            (f'/clitest/topic/{verb}_basic', False, True),\n+            (f'/clitest/topic/{verb}_compatible_qos', True, True),\n+            (f'/clitest/topic/{verb}_incompatible_qos', True, False),\n+        ]\n+        for topic, provide_qos, compatible_qos in params:\n+            with self.subTest(topic=topic, provide_qos=provide_qos, compatible_qos=compatible_qos):\n+                # Check for inconsistent arguments\n+                assert provide_qos if not compatible_qos else True\n+                verb_extra_options = []\n+                publisher_qos_profile = 10\n+                if provide_qos:\n+                    if compatible_qos:\n+                        # For compatible test, put publisher at very high quality\n+                        # and subscription at low\n+                        verb_extra_options = [\n+                            '--qos-reliability', 'best_effort',\n+                            '--qos-durability', 'volatile']\n+                        publisher_qos_profile = QoSProfile(\n+                            depth=10,\n+                            reliability=ReliabilityPolicy.RELIABLE,\n+                            durability=DurabilityPolicy.TRANSIENT_LOCAL)\n+                    else:\n+                        # For an incompatible example, reverse the quality extremes\n+                        # and expect no messages to arrive\n+                        verb_extra_options = [\n+                            '--qos-reliability', 'reliable',\n+                            '--qos-durability', 'transient_local']\n+                        publisher_qos_profile = QoSProfile(\n+                            depth=10,\n+                            reliability=ReliabilityPolicy.BEST_EFFORT,\n+                            durability=DurabilityPolicy.VOLATILE)\n+                publisher = self.node.create_publisher(PointStamped, topic, publisher_qos_profile)\n+                assert publisher\n+\n+                def publish_message():\n+                    msg = PointStamped()\n+                    # msg.header.stamp = self.node.get_clock().now()\n+                    publisher.publish(msg)\n+\n+                publish_timer = self.node.create_timer(0.5, publish_message)\n+\n+                try:\n+                    command_action = ExecuteProcess(\n+                        cmd=(['ros2', 'topic', verb] +\n+                             verb_extra_options +\n+                             [topic]),\n+                        additional_env={\n+                            'PYTHONUNBUFFERED': '1'\n+                        },\n+                        output='screen'\n+                    )\n+                    with launch_testing.tools.launch_process(\n+                        launch_service, command_action, proc_info, proc_output,\n+                        output_filter=launch_testing_ros.tools.basic_output_filter(\n+                            filtered_rmw_implementation=get_rmw_implementation_identifier()\n+                        )\n+                    ) as command:\n+                        # The future won't complete - we will hit the timeout\n+                        self.executor.spin_until_future_complete(\n+                            rclpy.task.Future(), timeout_sec=5\n+                        )\n+                    command.wait_for_shutdown(timeout=10)\n+                    # Check results\n+                    if compatible_qos:\n+                        assert command.output, f'{verb} CLI printed no output'\n+                        assert re.search(success_regex, command.output, flags=re.MULTILINE), (\n+                            f'{verb} CLI did not print expected message'\n+                        )\n+                    else:\n+                        assert command.output, (\n+                            f'{verb} CLI did not print incompatible QoS warning'\n+                        )\n+                        assert (\"New publisher discovered on topic '{}', offering incompatible\"\n+                                ' QoS.'.format(topic) in command.output), (\n+                                f'{verb} CLI did not print expected incompatible QoS warning'\n+                            )\n+                finally:\n+                    # Cleanup\n+                    self.node.destroy_timer(publish_timer)\n+                    self.node.destroy_publisher(publisher)\n+\n+    @launch_testing.markers.retry_on_failure(times=5)\n+    def test_bw_basic(self, launch_service, proc_info, proc_output):\n+        self.helper_verb_basic(\n+            launch_service,\n+            proc_info,\n+            proc_output,\n+            'bw',\n+            r'^[0-9]+ B/s from [0-9]+ messages$'\n+        )\n+\n+    @launch_testing.markers.retry_on_failure(times=5)\n+    def test_delay_basic(self, launch_service, proc_info, proc_output):\n+        self.helper_verb_basic(\n+            launch_service,\n+            proc_info,\n+            proc_output,\n+            'delay',\n+            r'^average delay: [0-9\\.]+$'\n+        )\n+\n+    @launch_testing.markers.retry_on_failure(times=5)\n+    def test_hw_basic(self, launch_service, proc_info, proc_output):\n+        self.helper_verb_basic(\n+            launch_service,\n+            proc_info,\n+            proc_output,\n+            'hz',\n+            r'^average rate: [0-9\\.]+$'\n+        )"},{"role":"user","content":"-                    re.compile(r'\\d{2} B/s from \\d+ messages'),\n+                    re.compile(r'\\d{2,3} B/s from \\d+ messages'),"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-/// Create and return an rmw publisher.\n+/// Create a publisher and return a handle to that publisher."},{"role":"user","content":"- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n+ * This function can fail, and therefore return `NULL`, if:\n+ *   - node is not a valid non-null handle for this rmw implementation,\n+ *     as returned by `rmw_create_node()`\n+ *   - type_support is a not valid non-null message type support, as returned by\n+ *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n+ *   - topic_name is not a valid non-null topic name, according to\n+ *     `rmw_validate_full_topic_name()`\n+ *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n+ *   - publisher_options is not a valid non-null option set, as returned by\n+ *     `rmw_get_default_publisher_options()`\n+ *   - memory allocation fails during publisher creation\n+ *   - an unspecified error occurs"},{"role":"user","content":"- * The argument `publisher_options` must not be nullptr.\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>"},{"role":"user","content":"- * \\param[in] publisher_options options for configuring the publisher\n+ * \\param[in] node Handle to node with which to register this publisher\n+ * \\param[in] type_support Type support for the messages to be published\n+ * \\param[in] topic_name Name of the topic to publish to, often a fully qualified\n+ *   topic name unless `qos_profile` is configured to avoid ROS namespace conventions\n+ *   i.e. to create a native topic publisher\n+ * \\param[in] qos_profile QoS policies for this publisher\n+ * \\param[in] publisher_options Options to configure this publisher\n+ * \\return rmw publisher handle, or `NULL` if there was an error"},{"role":"user","content":"-  const rmw_qos_profile_t * qos_policies,\n+  const rmw_qos_profile_t * qos_profile,"},{"role":"user","content":"+/// Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.\n+/**\n+ * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.\n+ * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n+ * the publisher handle. Usage of a deallocated publisher handle is undefined behavior.\n+ *\n+ * \\pre Given node must be the one the publisher was registered with.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\param[in] node Handle to node with which the given publisher is registered\n+ * \\param[in] publisher Handle to publisher to be finalized\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher\n+ *   implementation identifier does not match, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs.\n+ */"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            while self._context.ok() and not future.done():\n+            while self._context.ok() and not future.done() and not self._is_shutdown:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  // No custom handling of RMW_DEFAULT_DOMAIN_ID. Simply use a reasonable domain id."},{"role":"user","content":"-  participantAttrs.rtps.builtin.domainId = static_cast<uint32_t>(domain_id);\n+  participantAttrs.rtps.builtin.domainId =\n+    static_cast<uint32_t>(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);"},{"role":"user","content":"-  participantAttrs.domainId = static_cast<uint32_t>(domain_id);\n+  participantAttrs.domainId =\n+    static_cast<uint32_t>(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        parser.add_argument(\n+            '--flow-style', action='store_true',\n+            help='Print collections in the block style (not available with csv format)')"},{"role":"user","content":"-        if args.csv:\n+        self.csv = args.csv\n+        if self.csv:"},{"role":"user","content":"+        self.flow_style = args.flow_style"},{"role":"user","content":"-        self.print_func(submsg, self.truncate_length, self.no_arr, self.no_str)\n+        if self.csv:\n+            self.print_func(submsg, self.truncate_length, self.no_arr, self.no_str)\n+        else:\n+            self.print_func(\n+                submsg, self.truncate_length, self.no_arr, self.no_str, self.flow_style)"},{"role":"user","content":"-def _print_yaml(msg, truncate_length, noarr, nostr):\n+def _print_yaml(msg, truncate_length, noarr, nostr, flowstyle):"},{"role":"user","content":"-                msg, truncate_length=truncate_length, no_arr=noarr, no_str=nostr),\n+                msg, truncate_length=truncate_length,\n+                no_arr=noarr, no_str=nostr, flow_style=flowstyle),"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  - \"rclc_examples\"\n-  - \"rclc/test\"\n-  - \"rclc_lifecycle/test\"\n+  - \"rclc_examples/**/*\"\n+  - \"rclc/test/**/*\"\n+  - \"rclc_lifecycle/test/**/*\"\n+  - \"rclc_parameter/test/**/*\""},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  add_compile_options(-Wall -Wextra -Wpedantic)\n+  add_compile_options(\n+    -Wall -Wextra -Wpedantic\n+    -Wformat=2 -Wconversion -Wsign-conversion\n+  )"},{"role":"user","content":"-    char * namespace_ = rcutils_strndup(name, separator_pos - name + 1, allocator);\n+    char * namespace_ = rcutils_strndup(name, ((size_t) (separator_pos - name)) + 1, allocator);"},{"role":"user","content":"-        size_t len = separator_pos - absolute_namespace - i;\n+        size_t len = ((size_t) (separator_pos - absolute_namespace)) - i;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <chrono>\n+#include <iomanip>"},{"role":"user","content":"+using namespace std::literals::chrono_literals;\n+"},{"role":"user","content":"+  rmw_gid_t ppant_gid;"},{"role":"user","content":"+  /* suffix for GUIDs to construct unique client/service ids\n+     (protected by initialization_mutex) */\n+  uint32_t client_service_id;\n+"},{"role":"user","content":"-  : common(), domain_id(UINT32_MAX), ppant(0)\n+  : common(), domain_id(UINT32_MAX), ppant(0), client_service_id(0)"},{"role":"user","content":"+struct client_service_id_t\n+{\n+  // strangely, the writer_guid in an rmw_request_id_t is smaller than the identifier in\n+  // an rmw_gid_t\n+  uint8_t data[sizeof((reinterpret_cast<rmw_request_id_t *>(0))->writer_guid)]; // NOLINT\n+};\n+"},{"role":"user","content":"+  client_service_id_t id;"},{"role":"user","content":"+static std::map<std::string, std::vector<uint8_t>> parse_user_data(const dds_qos_t * qos)\n+{\n+  std::map<std::string, std::vector<uint8_t>> map;\n+  void * ud;\n+  size_t udsz;\n+  if (dds_qget_userdata(qos, &ud, &udsz)) {\n+    std::vector<uint8_t> udvec(static_cast<uint8_t *>(ud), static_cast<uint8_t *>(ud) + udsz);\n+    dds_free(ud);\n+    map = rmw::impl::cpp::parse_key_value(udvec);\n+  }\n+  return map;\n+}\n+\n+static bool get_user_data_key(const dds_qos_t * qos, const std::string key, std::string & value)\n+{\n+  if (qos != nullptr) {\n+    auto map = parse_user_data(qos);\n+    auto name_found = map.find(key);\n+    if (name_found != map.end()) {\n+      value = std::string(name_found->second.begin(), name_found->second.end());\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+"},{"role":"user","content":"-      void * ud;\n-      size_t udsz;\n-      if (dds_qget_userdata(s->qos, &ud, &udsz)) {\n-        std::vector<uint8_t> udvec(static_cast<uint8_t *>(ud), static_cast<uint8_t *>(ud) + udsz);\n-        dds_free(ud);\n-        auto map = rmw::impl::cpp::parse_key_value(udvec);\n-        auto name_found = map.find(\"enclave\");\n-        if (name_found != map.end()) {\n-          auto enclave =\n-            std::string(name_found->second.begin(), name_found->second.end());\n-          impl->common.graph_cache.add_participant(gid, enclave);\n-        }\n+      std::string enclave;\n+      if (get_user_data_key(s->qos, \"enclave\", enclave)) {\n+        impl->common.graph_cache.add_participant(gid, enclave);"},{"role":"user","content":"+  get_entity_gid(this->ppant, this->ppant_gid);"},{"role":"user","content":"+using get_matched_endpoints_fn_t = dds_return_t (*)(\n+  dds_entity_t h,\n+  dds_instance_handle_t * xs, size_t nxs);\n+using BuiltinTopicEndpoint = std::unique_ptr<dds_builtintopic_endpoint_t,\n+    std::function<void (dds_builtintopic_endpoint_t *)>>;\n+\n+static rmw_ret_t get_matched_endpoints(\n+  dds_entity_t h, get_matched_endpoints_fn_t fn, std::vector<dds_instance_handle_t> & res)\n+{\n+  dds_return_t ret;\n+  if ((ret = fn(h, res.data(), res.size())) < 0) {\n+    return RMW_RET_ERROR;\n+  }\n+  while ((size_t) ret >= res.size()) {\n+    // 128 is a completely arbitrary margin to reduce the risk of having to retry\n+    // when matches are create/deleted in parallel\n+    res.resize((size_t) ret + 128);\n+    if ((ret = fn(h, res.data(), res.size())) < 0) {\n+      return RMW_RET_ERROR;\n+    }\n+  }\n+  res.resize((size_t) ret);\n+  return RMW_RET_OK;\n+}\n+\n+static void free_builtintopic_endpoint(dds_builtintopic_endpoint_t * e)\n+{\n+  dds_delete_qos(e->qos);\n+  dds_free(e->topic_name);\n+  dds_free(e->type_name);\n+  dds_free(e);\n+}\n+\n+static BuiltinTopicEndpoint get_matched_subscription_data(\n+  dds_entity_t writer, dds_instance_handle_t readerih)\n+{\n+  BuiltinTopicEndpoint ep(dds_get_matched_subscription_data(writer, readerih),\n+    free_builtintopic_endpoint);\n+  return ep;\n+}\n+\n+static BuiltinTopicEndpoint get_matched_publication_data(\n+  dds_entity_t reader, dds_instance_handle_t writerih)\n+{\n+  BuiltinTopicEndpoint ep(dds_get_matched_publication_data(reader, writerih),\n+    free_builtintopic_endpoint);\n+  return ep;\n+}\n+\n+static const std::string csid_to_string(const client_service_id_t & id)\n+{\n+  std::ostringstream os;\n+  os << std::hex;\n+  os << std::setw(2) << static_cast<int>(id.data[0]);\n+  for (size_t i = 1; i < sizeof(id.data); i++) {\n+    os << \".\" << static_cast<int>(id.data[i]);\n+  }\n+  return os.str();\n+}\n+"},{"role":"user","content":"-      memset(request_header, 0, sizeof(wrap.header));\n-      assert(sizeof(wrap.header.guid) <= sizeof(request_header->request_id.writer_guid));\n-      memcpy(request_header->request_id.writer_guid, &wrap.header.guid, sizeof(wrap.header.guid));\n+      static_assert(\n+        sizeof(request_header->request_id.writer_guid) ==\n+        sizeof(wrap.header.guid) + sizeof(info.publication_handle),\n+        \"request header size assumptions not met\");\n+      memcpy(\n+        static_cast<void *>(request_header->request_id.writer_guid),\n+        static_cast<const void *>(&wrap.header.guid), sizeof(wrap.header.guid));\n+      memcpy(\n+        static_cast<void *>(request_header->request_id.writer_guid + sizeof(wrap.header.guid)),\n+        static_cast<const void *>(&info.publication_handle), sizeof(info.publication_handle));"},{"role":"user","content":"-  return rmw_take_response_request(&info->service, request_header, ros_request, taken, nullptr, 0);\n+  return rmw_take_response_request(\n+    &info->service, request_header, ros_request, taken, nullptr,\n+    false);"},{"role":"user","content":"+enum class client_present_t\n+{\n+  FAILURE,  // an error occurred when checking\n+  MAYBE,    // reader not matched, writer still present\n+  YES,      // reader matched\n+  GONE      // neither reader nor writer\n+};\n+\n+static bool check_client_service_endpoint(\n+  const dds_builtintopic_endpoint_t * ep,\n+  const std::string key, const std::string needle)\n+{\n+  if (ep != nullptr) {\n+    std::string clientid;\n+    get_user_data_key(ep->qos, key, clientid);\n+    return clientid == needle;\n+  }\n+  return false;\n+}\n+\n+static client_present_t check_for_response_reader(\n+  const CddsCS & service,\n+  const dds_instance_handle_t reqwrih)\n+{\n+  auto reqwr = get_matched_publication_data(service.sub->enth, reqwrih);\n+  std::string clientid;\n+  if (reqwr == nullptr) {\n+    return client_present_t::GONE;\n+  } else if (!get_user_data_key(reqwr->qos, \"clientid\", clientid)) {\n+    // backwards-compatibility: a client without a client id, assume all is well\n+    return client_present_t::YES;\n+  } else {\n+    // look for this client's reader: if we have matched it, all is well;\n+    // if not, continue waiting\n+    std::vector<dds_instance_handle_t> rds;\n+    if (get_matched_endpoints(service.pub->enth, dds_get_matched_subscriptions, rds) < 0) {\n+      RMW_SET_ERROR_MSG(\"rmw_send_response: failed to get reader/writer matches\");\n+      return client_present_t::FAILURE;\n+    }\n+    // if we have matched this client's reader, all is well\n+    for (const auto & rdih : rds) {\n+      auto rd = get_matched_subscription_data(service.pub->enth, rdih);\n+      if (check_client_service_endpoint(rd.get(), \"clientid\", clientid)) {\n+        return client_present_t::YES;\n+      }\n+    }\n+    return client_present_t::MAYBE;\n+  }\n+}\n+"},{"role":"user","content":"-  memcpy(&header.guid, request_header->writer_guid, sizeof(header.guid));\n+  dds_instance_handle_t reqwrih;\n+  static_assert(\n+    sizeof(request_header->writer_guid) == sizeof(header.guid) + sizeof(reqwrih),\n+    \"request header size assumptions not met\");\n+  memcpy(\n+    static_cast<void *>(&header.guid), static_cast<const void *>(request_header->writer_guid),\n+    sizeof(header.guid));\n+  memcpy(\n+    static_cast<void *>(&reqwrih),\n+    static_cast<const void *>(request_header->writer_guid + sizeof(header.guid)), sizeof(reqwrih));"},{"role":"user","content":"-  return rmw_send_response_request(&info->service, header, ros_response);\n+  // Block until the response reader has been matched by the response writer (this is a\n+  // workaround: rmw_service_server_is_available should keep returning false until this\n+  // is a given).\n+  // TODO(eboasson): rmw_service_server_is_available should block the request instead (#191)\n+  client_present_t st;\n+  std::chrono::system_clock::time_point tnow = std::chrono::system_clock::now();\n+  std::chrono::system_clock::time_point tend = tnow + 100ms;\n+  while ((st =\n+    check_for_response_reader(\n+      info->service,\n+      reqwrih)) == client_present_t::MAYBE && tnow < tend)\n+  {\n+    dds_sleepfor(DDS_MSECS(10));\n+    tnow = std::chrono::system_clock::now();\n+  }\n+  switch (st) {\n+    case client_present_t::FAILURE:\n+      break;\n+    case client_present_t::MAYBE:\n+      return RMW_RET_TIMEOUT;\n+    case client_present_t::YES:\n+      return rmw_send_response_request(&info->service, header, ros_response);\n+    case client_present_t::GONE:\n+      return RMW_RET_OK;\n+  }\n+  return RMW_RET_ERROR;"},{"role":"user","content":"+static void get_unique_csid(const rmw_node_t * node, client_service_id_t & id)\n+{\n+  auto impl = node->context->impl;\n+  static_assert(\n+    sizeof(dds_guid_t) <= sizeof(id.data),\n+    \"client/service id assumed it can hold a DDSI GUID\");\n+  static_assert(\n+    sizeof(dds_guid_t) <= sizeof((reinterpret_cast<rmw_gid_t *>(0))->data),\n+    \"client/service id assumes rmw_gid_t can hold a DDSI GUID\");\n+  uint32_t x;\n+\n+  {\n+    std::lock_guard<std::mutex> guard(impl->initialization_mutex);\n+    x = ++impl->client_service_id;\n+  }\n+\n+  // construct id by taking the entity prefix (which is just the first 12\n+  // bytes of the GID, which itself is just the GUID padded with 0's; then\n+  // overwriting the entity id with the big-endian counter value\n+  memcpy(id.data, impl->ppant_gid.data, 12);\n+  for (size_t i = 0, s = 24; i < 4; i++, s -= 8) {\n+    id.data[12 + i] = static_cast<uint8_t>(x >> s);\n+  }\n+}\n+"},{"role":"user","content":"+\n+  // store a unique identifier for this client/service in the user\n+  // data of the reader and writer so that we can always determine\n+  // which pairs belong together\n+  get_unique_csid(node, cs->id);\n+  {\n+    std::string user_data = std::string(is_service ? \"serviceid=\" : \"clientid=\") + csid_to_string(\n+      cs->id) + std::string(\";\");\n+    dds_qset_userdata(qos, user_data.c_str(), user_data.size());\n+  }"},{"role":"user","content":"+static rmw_ret_t check_for_service_reader_writer(const CddsCS & client, bool * is_available)\n+{\n+  std::vector<dds_instance_handle_t> rds, wrs;\n+  assert(is_available != nullptr && !*is_available);\n+  if (get_matched_endpoints(client.pub->enth, dds_get_matched_subscriptions, rds) < 0 ||\n+    get_matched_endpoints(client.sub->enth, dds_get_matched_publications, wrs) < 0)\n+  {\n+    RMW_SET_ERROR_MSG(\"rmw_service_server_is_available: failed to get reader/writer matches\");\n+    return RMW_RET_ERROR;\n+  }\n+  // first extract all service ids from matched readers\n+  std::set<std::string> needles;\n+  for (const auto & rdih : rds) {\n+    auto rd = get_matched_subscription_data(client.pub->enth, rdih);\n+    std::string serviceid;\n+    if (rd && get_user_data_key(rd->qos, \"serviceid\", serviceid)) {\n+      needles.insert(serviceid);\n+    }\n+  }\n+  if (needles.empty()) {\n+    // if no services advertising a serviceid have been matched, but there\n+    // are matched request readers and response writers, then we fall back\n+    // to the old method of simply requiring the existence of matches.\n+    *is_available = !rds.empty() && !wrs.empty();\n+  } else {\n+    // scan the writers to see if there is at least one response writer\n+    // matching a discovered request reader\n+    for (const auto & wrih : wrs) {\n+      auto wr = get_matched_publication_data(client.sub->enth, wrih);\n+      std::string serviceid;\n+      if (wr &&\n+        get_user_data_key(\n+          wr->qos, \"serviceid\",\n+          serviceid) && needles.find(serviceid) != needles.end())\n+      {\n+        *is_available = true;\n+        break;\n+      }\n+    }\n+  }\n+  return RMW_RET_OK;\n+}\n+"},{"role":"user","content":"-  dds_publication_matched_status_t ps;\n-  dds_subscription_matched_status_t cs;\n-  if (dds_get_publication_matched_status(info->client.pub->enth, &ps) < 0 ||\n-    dds_get_subscription_matched_status(info->client.sub->enth, &cs) < 0)\n-  {\n-    RMW_SET_ERROR_MSG(\"rmw_service_server_is_available: get_..._matched_status failed\");\n-    return RMW_RET_ERROR;\n-  }\n-  *is_available = ps.current_count > 0 && cs.current_count > 0;\n-  return RMW_RET_OK;\n+  return check_for_service_reader_writer(info->client, is_available);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+name: Mirror rolling to master\n+\n+on:\n+  push:\n+    branches: [ rolling ]\n+\n+jobs:\n+  mirror-to-master:\n+    runs-on: ubuntu-latest\n+    steps:\n+    - uses: zofrex/mirror-branch@v1\n+      with:\n+        target-branch: master"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());"},{"role":"user","content":"-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());"},{"role":"user","content":"-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());"},{"role":"user","content":"-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());"},{"role":"user","content":"-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());"},{"role":"user","content":"-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n+  dds_typesupport = dds_TypeSupport_create(metastring.c_str());"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  // This is a duration in nanoseconds.\n-  atomic_uint_least64_t period;\n+  // This is a duration in nanoseconds, which is initialized as int64_t\n+  // to be used for internal time calculation.\n+  atomic_int_least64_t period;"},{"role":"user","content":"-    const int64_t period = rcutils_atomic_load_uint64_t(&timer->impl->period);\n+    const int64_t period = rcutils_atomic_load_int64_t(&timer->impl->period);"},{"role":"user","content":"-  int64_t period = rcutils_atomic_load_uint64_t(&timer->impl->period);\n+  int64_t period = rcutils_atomic_load_int64_t(&timer->impl->period);"},{"role":"user","content":"-  *period = rcutils_atomic_load_uint64_t(&timer->impl->period);\n+  *period = rcutils_atomic_load_int64_t(&timer->impl->period);"},{"role":"user","content":"-  *old_period = rcutils_atomic_exchange_uint64_t(&timer->impl->period, new_period);\n+  *old_period = rcutils_atomic_exchange_int64_t(&timer->impl->period, new_period);"},{"role":"user","content":"-  int64_t period = rcutils_atomic_load_uint64_t(&timer->impl->period);\n+  int64_t period = rcutils_atomic_load_int64_t(&timer->impl->period);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  if (service_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+"},{"role":"user","content":"+  if (client_info->message_queue.empty()) {\n+    return RMW_RET_OK;\n+  }\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-function(test_add_callback_groups_to_executor_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_add_callback_groups_to_executor${target_suffix} test_add_callback_groups_to_executor.cpp\n-    ENV ${rmw_implementation_env_var}\n-    TIMEOUT 120\n-  )\n-  if(TARGET test_add_callback_groups_to_executor${target_suffix})\n-    target_link_libraries(test_add_callback_groups_to_executor${target_suffix} ${PROJECT_NAME} ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_add_callback_groups_to_executor_for_rmw_implementation)"},{"role":"user","content":"-function(test_generic_pubsub_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_generic_pubsub${target_suffix} test_generic_pubsub.cpp\n-    ENV ${rmw_implementation_env_var}\n-  )\n-  if(TARGET test_generic_pubsub${target_suffix})\n-    target_link_libraries(test_generic_pubsub${target_suffix} ${PROJECT_NAME} rcl::rcl ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_generic_pubsub_for_rmw_implementation)\n-\n-function(test_qos_event_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_qos_event${target_suffix} test_qos_event.cpp\n-    ENV ${rmw_implementation_env_var}\n-  )\n-  ament_add_test_label(test_qos_event${target_suffix} mimick)\n-  if(TARGET test_qos_event${target_suffix})\n-    target_link_libraries(test_qos_event${target_suffix} ${PROJECT_NAME} mimick rcutils::rcutils rmw::rmw ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_qos_event_for_rmw_implementation)"},{"role":"user","content":"-function(test_subscription_content_filter_for_rmw_implementation)\n+ament_add_gmock_executable(test_qos_event test_qos_event.cpp)\n+if(TARGET test_qos_event)\n+  target_link_libraries(test_qos_event ${PROJECT_NAME} mimick rcutils::rcutils rmw::rmw ${test_msgs_TARGETS})\n+endif()\n+\n+ament_add_gmock_executable(test_generic_pubsub test_generic_pubsub.cpp)\n+if(TARGET test_generic_pubsub)\n+  target_link_libraries(test_generic_pubsub ${PROJECT_NAME} rcl::rcl ${test_msgs_TARGETS})\n+endif()\n+\n+ament_add_gmock_executable(test_add_callback_groups_to_executor test_add_callback_groups_to_executor.cpp)\n+if(TARGET test_add_callback_groups_to_executor)\n+  target_link_libraries(test_add_callback_groups_to_executor ${PROJECT_NAME} ${test_msgs_TARGETS})\n+endif()\n+\n+ament_add_gmock_executable(test_subscription_content_filter test_subscription_content_filter.cpp)\n+if(TARGET test_subscription_content_filter)\n+  target_link_libraries(test_subscription_content_filter ${PROJECT_NAME} mimick ${test_msgs_TARGETS})\n+endif()\n+\n+function(test_on_all_rmws)"},{"role":"user","content":"-  ament_add_gmock(test_subscription_content_filter${target_suffix}\n-    test_subscription_content_filter.cpp\n+\n+  ament_add_gmock_test(test_qos_event\n+    TEST_NAME test_qos_event${target_suffix}\n+    ENV ${rmw_implementation_env_var}\n+  )\n+  ament_add_test_label(test_qos_event${target_suffix} mimick)\n+\n+  ament_add_gmock_test(test_generic_pubsub\n+    TEST_NAME test_generic_pubsub${target_suffix}\n+    ENV ${rmw_implementation_env_var}\n+  )\n+\n+  ament_add_gmock_test(test_add_callback_groups_to_executor\n+    TEST_NAME test_add_callback_groups_to_executor${target_suffix}\n+    ENV ${rmw_implementation_env_var}\n+    TIMEOUT 120\n+  )\n+\n+  ament_add_gmock_test(test_subscription_content_filter\n+    TEST_NAME test_subscription_content_filter${target_suffix}"},{"role":"user","content":"-  if(TARGET test_subscription_content_filter${target_suffix})\n-    target_link_libraries(test_subscription_content_filter${target_suffix} ${PROJECT_NAME} mimick ${test_msgs_TARGETS})\n-  endif()"},{"role":"user","content":"-call_for_each_rmw_implementation(test_subscription_content_filter_for_rmw_implementation)\n+call_for_each_rmw_implementation(test_on_all_rmws)"},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-class CLASSNAME (TestContentFilterSubscription, RMW_IMPLEMENTATION) : public ::testing::Test\n+class TestContentFilterSubscription : public ::testing::Test"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), is_cft_enabled) {\n+TEST_F(TestContentFilterSubscription, is_cft_enabled)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content_filter_error) {\n+TEST_F(TestContentFilterSubscription, get_content_filter_error)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content_filter_error) {\n+TEST_F(TestContentFilterSubscription, set_content_filter_error)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content_filter) {\n+TEST_F(TestContentFilterSubscription, get_content_filter)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content_filter) {\n+TEST_F(TestContentFilterSubscription, set_content_filter)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_get_begin) {\n+TEST_F(TestContentFilterSubscription, content_filter_get_begin)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_get_later) {\n+TEST_F(TestContentFilterSubscription, content_filter_get_later)\n+{"},{"role":"user","content":"-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_reset) {\n+TEST_F(TestContentFilterSubscription, content_filter_reset)\n+{"},{"role":"user","content":"-TEST_F(\n-  CLASSNAME(\n-    TestContentFilterSubscription,\n-    RMW_IMPLEMENTATION), create_two_content_filters_with_same_topic_name_and_destroy) {\n-\n+TEST_F(TestContentFilterSubscription, create_two_content_filters_with_same_topic_name_and_destroy)\n+{"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+    ament_add_gtest(test_init_options${target_suffix}\n+      test/test_init_options.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_init_options${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_init_options${target_suffix}\n+      osrf_testing_tools_cpp rcutils rmw rmw_implementation\n+    )"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef ALLOCATOR_TESTING_UTILS_H_\n+#define ALLOCATOR_TESTING_UTILS_H_\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#include <stddef.h>\n+\n+#include \"rcutils/allocator.h\"\n+\n+typedef struct __failing_allocator_state\n+{\n+  bool is_failing;\n+} __failing_allocator_state;\n+\n+void *\n+failing_malloc(size_t size, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().allocate(size, rcutils_get_default_allocator().state);\n+}\n+\n+void *\n+failing_realloc(void * pointer, size_t size, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().reallocate(\n+    pointer, size, rcutils_get_default_allocator().state);\n+}\n+\n+void\n+failing_free(void * pointer, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return;\n+  }\n+  rcutils_get_default_allocator().deallocate(pointer, rcutils_get_default_allocator().state);\n+}\n+\n+void *\n+failing_calloc(size_t number_of_elements, size_t size_of_element, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().zero_allocate(\n+    number_of_elements, size_of_element, rcutils_get_default_allocator().state);\n+}\n+\n+static inline rcutils_allocator_t\n+get_failing_allocator(void)\n+{\n+  static __failing_allocator_state state;\n+  state.is_failing = true;\n+  auto failing_allocator = rcutils_get_default_allocator();\n+  failing_allocator.allocate = failing_malloc;\n+  failing_allocator.deallocate = failing_free;\n+  failing_allocator.reallocate = failing_realloc;\n+  failing_allocator.zero_allocate = failing_calloc;\n+  failing_allocator.state = &state;\n+  return failing_allocator;\n+}\n+\n+static inline void\n+set_failing_allocator_is_failing(rcutils_allocator_t & failing_allocator, bool state)\n+{\n+  ((__failing_allocator_state *)failing_allocator.state)->is_failing = state;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif  // ALLOCATOR_TESTING_UTILS_H_"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"osrf_testing_tools_cpp/scope_exit.hpp\"\n+\n+#include \"rcutils/allocator.h\"\n+#include \"rcutils/error_handling.h\"\n+\n+#include \"rmw/rmw.h\"\n+\n+#include \"./allocator_testing_utils.h\"\n+\n+#ifdef RMW_IMPLEMENTATION\n+# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n+# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n+#else\n+# define CLASSNAME(NAME, SUFFIX) NAME\n+#endif\n+\n+class CLASSNAME (TestInitOptions, RMW_IMPLEMENTATION) : public ::testing::Test {};\n+\n+TEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), init_copy_fini) {\n+  rmw_init_options_t src_options = rmw_get_zero_initialized_init_options();\n+  rmw_ret_t ret = rmw_init_options_init(&src_options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  // Initializing twice fails.\n+  ret = rmw_init_options_init(&src_options, rcutils_get_default_allocator());\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  rmw_init_options_t dst_options = rmw_get_zero_initialized_init_options();\n+  ret = rmw_init_options_copy(&src_options, &dst_options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  // Copying twice fails.\n+  ret = rmw_init_options_copy(&src_options, &dst_options);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) << rcutils_get_error_string().str;\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_fini(&dst_options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  ret = rmw_init_options_fini(&src_options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  // Finalizing twice fails.\n+  ret = rmw_init_options_fini(&src_options);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+}\n+\n+TEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), init_with_bad_arguments) {\n+  rmw_init_options_t options = rmw_get_zero_initialized_init_options();\n+  rmw_ret_t ret = rmw_init_options_init(&options, rcutils_get_zero_initialized_allocator());\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_init(nullptr, rcutils_get_default_allocator());\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  // Initialization and finalization should still succeed.\n+  ret = rmw_init_options_init(&options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  ret = rmw_init_options_fini(&options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), copy_with_bad_arguments) {\n+  rmw_init_options_t src_options = rmw_get_zero_initialized_init_options();\n+  rmw_init_options_t dst_options = rmw_get_zero_initialized_init_options();\n+\n+  rmw_ret_t ret = rmw_init_options_copy(nullptr, &dst_options);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_copy(&src_options, nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_copy(&src_options, &dst_options);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_init(&src_options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rmw_ret_t ret = rmw_init_options_fini(&src_options);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  });\n+\n+  const char * implementation_identifier = src_options.implementation_identifier;\n+  src_options.implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_init_options_copy(&src_options, &dst_options);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n+  src_options.implementation_identifier = implementation_identifier;\n+  rcutils_reset_error();\n+\n+  // Initialization and finalization should still succeed.\n+  ret = rmw_init_options_init(&dst_options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  ret = rmw_init_options_fini(&dst_options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), fini_with_bad_arguments) {\n+  rmw_init_options_t options = rmw_get_zero_initialized_init_options();\n+  rmw_ret_t ret = rmw_init_options_fini(&options);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_fini(nullptr);\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_init(&options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  const char * implementation_identifier = options.implementation_identifier;\n+  options.implementation_identifier = \"not-an-rmw-implementation-identifier\";\n+  ret = rmw_init_options_fini(&options);\n+  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n+  options.implementation_identifier = implementation_identifier;\n+  rcutils_reset_error();\n+\n+  ret = rmw_init_options_fini(&options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+\n+  // Initialization and finalization should still succeed.\n+  ret = rmw_init_options_init(&options, rcutils_get_default_allocator());\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+  ret = rmw_init_options_fini(&options);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rcutils_get_error_string().str;\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-from typing import Callable, Optional, Protocol, Type, TYPE_CHECKING, TypedDict\n+from typing import Callable, Optional, Type, TYPE_CHECKING, TypedDict"},{"role":"user","content":"-from .destroyable import DestroyableType"},{"role":"user","content":"-from .time import Time, TimeHandle\n+from .time import Time"},{"role":"user","content":"-class ClockHandle(DestroyableType, Protocol):\n-    \"\"\"Generic alias of _rclpy.Clock.\"\"\"\n-\n-    def get_now(self) -> TimeHandle:\n-        \"\"\"Value of the clock.\"\"\"\n-        ...\n-\n-    def get_ros_time_override_is_enabled(self) -> bool:\n-        \"\"\"Return if a clock using ROS time has the ROS time override enabled.\"\"\"\n-        ...\n-\n-    def set_ros_time_override_is_enabled(self, enabled: bool) -> None:\n-        \"\"\"Set if a clock using ROS time has the ROS time override enabled.\"\"\"\n-        ...\n-\n-    def set_ros_time_override(self, time_point: TimeHandle) -> None:\n-        \"\"\"Set the ROS time override for a clock using ROS time.\"\"\"\n-        ...\n-\n-    def add_clock_callback(self, pyjump_handle: JumpHandle,\n-                           on_clock_change: bool, min_forward: int, min_backward: int) -> None:\n-        \"\"\"Add a time jump callback to a clock.\"\"\"\n-        ...\n-\n-    def remove_clock_callback(self, pyjump_handle: JumpHandle) -> None:\n-        \"\"\"Remove a time jump callback from a clock.\"\"\"\n-        ...\n-\n-"},{"role":"user","content":"-        __clock: ClockHandle\n+        __clock: _rclpy.Clock"},{"role":"user","content":"-    def handle(self) -> ClockHandle:\n+    def handle(self) -> _rclpy.Clock:"},{"role":"user","content":"-from typing import Protocol"},{"role":"user","content":"-from rclpy.destroyable import DestroyableType\n+from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy"},{"role":"user","content":"-\n-class ContextHandle(DestroyableType, Protocol):\n-\n-    def ok(self) -> bool:\n-        ...\n-\n-    def get_domain_id(self) -> int:\n-        ...\n-\n-    def shutdown(self) -> None:\n-        ...\n-\n-"},{"role":"user","content":"-        self.__context: Optional[ContextHandle] = None\n+        self.__context: Optional[_rclpy.Context] = None"},{"role":"user","content":"-    def handle(self) -> Optional[ContextHandle]:\n+    def handle(self) -> Optional[_rclpy.Context]:"},{"role":"user","content":"-# Copyright 2024 Open Source Robotics Foundation, Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-from types import TracebackType\n-from typing import Optional, Protocol, Type\n-\n-\n-class DestroyableType(Protocol):\n-\n-    def __enter__(self) -> None:\n-        ...\n-\n-    def __exit__(self, exc_type: Optional[Type[BaseException]],\n-                 exc_val: Optional[BaseException], exctb: Optional[TracebackType]) -> None:\n-        ...\n-\n-    def destroy_when_not_in_use(self) -> None:\n-        ..."},{"role":"user","content":"-from typing import Protocol, Union\n+from typing import Union"},{"role":"user","content":"-class DurationHandle(Protocol):\n-    \"\"\"Type alias of _rclpy.rcl_duration_t.\"\"\"\n-\n-    nanoseconds: int\n-\n-"},{"role":"user","content":"-        self._duration_handle: DurationHandle = _rclpy.rcl_duration_t(total_nanoseconds)\n+        self._duration_handle = _rclpy.rcl_duration_t(total_nanoseconds)"},{"role":"user","content":"-    def get_c_duration(self) -> DurationHandle:\n+    def get_c_duration(self) -> _rclpy.rcl_duration_t:"},{"role":"user","content":"-if TYPE_CHECKING:\n-    from rclpy.subscription import SubscriptionHandle\n-\n-"},{"role":"user","content":"-        self, callback_group: CallbackGroup, subscription: 'SubscriptionHandle',\n+        self, callback_group: CallbackGroup, subscription: '_rclpy.Subscription',"},{"role":"user","content":"-from typing import Callable, Optional, Protocol\n+from typing import Callable, Optional"},{"role":"user","content":"-from rclpy.destroyable import DestroyableType"},{"role":"user","content":"-class GuardConditionHandle(DestroyableType, Protocol):\n-\n-    def trigger_guard_condition(self) -> None:\n-        ...\n-\n-"},{"role":"user","content":"-            self.__gc: GuardConditionHandle = _rclpy.GuardCondition(self._context.handle)\n+            self.__gc = _rclpy.GuardCondition(self._context.handle)"},{"role":"user","content":"-    def handle(self) -> GuardConditionHandle:\n+    def handle(self) -> _rclpy.GuardCondition:"},{"role":"user","content":"-from typing import Sequence\n+from __future__ import annotations"},{"role":"user","content":"+from enum import IntEnum\n+from types import TracebackType\n+from typing import Any, Generic, Literal, overload, Sequence, TypedDict"},{"role":"user","content":"-def rclpy_remove_ros_args(pycli_args: Sequence[str]) -> list[str]: ...\n-\"\"\"Remove ROS-specific arguments from argument vector.\"\"\"\n+from rclpy.clock import JumpHandle\n+from rclpy.clock_type import ClockType\n+from rclpy.qos import (QoSDurabilityPolicy, QoSHistoryPolicy, QoSLivelinessPolicy,\n+                       QoSReliabilityPolicy)\n+from rclpy.subscription import MessageInfo\n+from rclpy.type_support import MsgT"},{"role":"user","content":"-def rclpy_get_rmw_implementation_identifier() -> str: ...\n-\"\"\"Retrieve the identifier for the active RMW implementation.\"\"\"\n+\n+def rclpy_remove_ros_args(pycli_args: Sequence[str]) -> list[str]:\n+    \"\"\"Remove ROS-specific arguments from argument vector.\"\"\"\n+\n+\n+def rclpy_get_rmw_implementation_identifier() -> str:\n+    \"\"\"Retrieve the identifier for the active RMW implementation.\"\"\"\n+\n+\n+class Client:\n+    pass\n+\n+\n+class rcl_time_point_t:\n+    nanoseconds: int\n+    clock_type: ClockType\n+\n+\n+class Destroyable:\n+\n+    def __enter__(self) -> None: ...\n+\n+    def __exit__(self, exc_type: type[BaseException] | None,\n+                 exc_val: BaseException | None, exctb: TracebackType | None) -> None: ...\n+\n+    def destroy_when_not_in_use(self) -> None:\n+        \"\"\"Destroy the rcl object as soon as it's not actively being used.\"\"\"\n+\n+\n+class Clock(Destroyable):\n+\n+    def __init__(self, clock_type: int) -> None: ...\n+\n+    def get_now(self) -> rcl_time_point_t:\n+        \"\"\"Value of the clock.\"\"\"\n+\n+    def get_ros_time_override_is_enabled(self) -> bool:\n+        \"\"\"Return if a clock using ROS time has the ROS time override enabled.\"\"\"\n+\n+    def set_ros_time_override_is_enabled(self, enabled: bool) -> None:\n+        \"\"\"Set if a clock using ROS time has the ROS time override enabled.\"\"\"\n+\n+    def set_ros_time_override(self, time_point: rcl_time_point_t) -> None:\n+        \"\"\"Set the ROS time override for a clock using ROS time.\"\"\"\n+\n+    def add_clock_callback(self, pyjump_handle: JumpHandle,\n+                           on_clock_change: bool, min_forward: int,\n+                           min_backward: int) -> None:\n+        \"\"\"Add a time jump callback to a clock.\"\"\"\n+\n+    def remove_clock_callback(self, pyjump_handle: JumpHandle) -> None:\n+        \"\"\"Remove a time jump callback from a clock.\"\"\"\n+\n+\n+class Context(Destroyable):\n+\n+    def __init__(self, pyargs: list[str], domain_id: int) -> None: ...\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def get_domain_id(self) -> int:\n+        \"\"\"Retrieve domain id from init_options of context.\"\"\"\n+\n+    def ok(self) -> bool:\n+        \"\"\"Status of the the client library.\"\"\"\n+\n+    def shutdown(self) -> None:\n+        \"\"\"Shutdown context.\"\"\"\n+\n+\n+class rcl_duration_t:\n+    nanoseconds: int\n+\n+\n+class rcl_subscription_event_type_t(IntEnum):\n+    RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED: int\n+    RCL_SUBSCRIPTION_LIVELINESS_CHANGED: int\n+    RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS: int\n+    RCL_SUBSCRIPTION_MESSAGE_LOST: int\n+    RCL_SUBSCRIPTION_INCOMPATIBLE_TYPE: int\n+    RCL_SUBSCRIPTION_MATCHED: int\n+\n+\n+class rcl_publisher_event_type_t(IntEnum):\n+    RCL_PUBLISHER_OFFERED_DEADLINE_MISSED: int\n+    RCL_PUBLISHER_LIVELINESS_LOST: int\n+    RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS: int\n+    RCL_PUBLISHER_INCOMPATIBLE_TYPE: int\n+    RCL_PUBLISHER_MATCHED: int\n+\n+\n+class EventHandle(Destroyable):\n+\n+    @overload\n+    def __init__(self, subcription: Subscription,\n+                 event_type: rcl_subscription_event_type_t) -> None: ...\n+\n+    @overload\n+    def __init__(self, publisher: Publisher, event_type: rcl_publisher_event_type_t) -> None: ...\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def take_event(self) -> Any | None:\n+        \"\"\"Get pending data from a ready event.\"\"\"\n+\n+\n+class GuardCondition(Destroyable):\n+\n+    def __init__(self, context: Context) -> None: ...\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def trigger_guard_condition(self) -> None:\n+        \"\"\"Trigger a general purpose guard condition.\"\"\"\n+\n+\n+class Service:\n+    pass\n+\n+\n+class Subscription(Destroyable, Generic[MsgT]):\n+\n+    def __init__(self, node: Node, pymsg_type: type[MsgT], topic: str,\n+                 pyqos_profile: rmw_qos_profile_t) -> None: ...\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def take_message(self, pymsg_type: type[MsgT], raw: bool) -> tuple[MsgT, MessageInfo]:\n+        \"\"\"Take a message and its metadata from a subscription.\"\"\"\n+\n+    def get_logger_name(self) -> str:\n+        \"\"\"Get the name of the logger associated with the node of the subscription.\"\"\"\n+\n+    def get_topic_name(self) -> str:\n+        \"\"\"Return the resolved topic name of a subscription.\"\"\"\n+\n+    def get_publisher_count(self) -> int:\n+        \"\"\"Count the publishers from a subscription.\"\"\"\n+\n+\n+class Node:\n+    pass\n+\n+\n+class Publisher(Destroyable, Generic[MsgT]):\n+\n+    def __init__(self, arg0: Node, arg1: type[MsgT], arg2: str, arg3: rmw_qos_profile_t) -> None:\n+        \"\"\"Create _rclpy.Publisher.\"\"\"\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def get_logger_name(self) -> str:\n+        \"\"\"Get the name of the logger associated with the node of the publisher.\"\"\"\n+\n+    def get_subscription_count(self) -> int:\n+        \"\"\"Count subscribers from a publisher.\"\"\"\n+\n+    def get_topic_name(self) -> str:\n+        \"\"\"Retrieve the topic name from a Publisher.\"\"\"\n+\n+    def publish(self, arg0: MsgT) -> None:\n+        \"\"\"Publish a message.\"\"\"\n+\n+    def publish_raw(self, arg0: bytes) -> None:\n+        \"\"\"Publish a serialized message.\"\"\"\n+\n+    def wait_for_all_acked(self, arg0: rcl_duration_t) -> bool:\n+        \"\"\"Wait until all published message data is acknowledged.\"\"\"\n+\n+\n+class TimeInfoDict(TypedDict):\n+    expected_call_time: int\n+    actual_call_time: int\n+\n+\n+class Timer(Destroyable):\n+\n+    def __init__(self, clock: Clock, context: Context, period_nsec: int,\n+                 autostart: bool) -> None: ...\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def reset_timer(self) -> None:\n+        \"\"\"Reset a timer.\"\"\"\n+\n+    def is_timer_ready(self) -> bool:\n+        \"\"\"Check if a timer as reached timeout.\"\"\"\n+\n+    def call_timer(self) -> None:\n+        \"\"\"Call a timer and starts counting again.\"\"\"\n+\n+    def call_timer_with_info(self) -> TimeInfoDict:\n+        \"\"\"Call a timer and starts counting again, retrieves actual and expected call time.\"\"\"\n+\n+    def change_timer_period(self, period_nsec: int) -> None:\n+        \"\"\"Set the period of a timer.\"\"\"\n+\n+    def time_until_next_call(self) -> int | None:\n+        \"\"\"Get the remaining time before timer is ready.\"\"\"\n+\n+    def time_since_last_call(self) -> int:\n+        \"\"\"Get the elapsed time since last timer call.\"\"\"\n+\n+    def get_timer_period(self) -> int:\n+        \"\"\"Get the period of a timer.\"\"\"\n+\n+    def cancel_timer(self) -> None:\n+        \"\"\"Cancel a timer.\"\"\"\n+\n+    def is_timer_canceled(self) -> bool:\n+        \"\"\"Check if a timer is canceled.\"\"\"\n+\n+\n+PredefinedQosProfileTNames = Literal['qos_profile_sensor_data', 'qos_profile_default',\n+                                     'qos_profile_system_default', 'qos_profile_services_default',\n+                                     'qos_profile_unknown', 'qos_profile_parameters',\n+                                     'qos_profile_parameter_events', 'qos_profile_best_available']\n+\n+\n+class rmw_qos_profile_dict(TypedDict):\n+    qos_history: QoSHistoryPolicy | int\n+    qos_depth: int\n+    qos_reliability: QoSReliabilityPolicy | int\n+    qos_durability: QoSDurabilityPolicy | int\n+    pyqos_lifespan: rcl_duration_t\n+    pyqos_deadline: rcl_duration_t\n+    qos_liveliness: QoSLivelinessPolicy | int\n+    pyqos_liveliness_lease_duration: rcl_duration_t\n+    avoid_ros_namespace_conventions: bool\n+\n+\n+class rmw_qos_profile_t:\n+\n+    def __init__(\n+        self,\n+        qos_history: int,\n+        qos_depth: int,\n+        qos_reliability: int,\n+        qos_durability: int,\n+        pyqos_lifespan: rcl_duration_t,\n+        pyqos_deadline: rcl_duration_t,\n+        qos_liveliness: int,\n+        pyqos_liveliness_lease_duration: rcl_duration_t,\n+        avoid_ros_namespace_conventions: bool\n+    ) -> None: ...\n+\n+    def to_dict(self) -> rmw_qos_profile_dict: ...\n+\n+    @staticmethod\n+    def predefined(qos_profile_name: PredefinedQosProfileTNames) -> rmw_qos_profile_t: ...\n+\n+\n+IsReadyValues = Literal['subscription', 'client', 'service', 'timer', 'guard_condition', 'event']\n+GetReadyEntityValues = Literal['subscription', 'client', 'service', 'timer', 'guard_condition']\n+\n+\n+class WaitSet(Destroyable):\n+\n+    def __init__(self, number_of_subscriptions: int, number_of_guard_conditions: int,\n+                 number_of_timers: int, number_of_clients: int, number_of_services: int,\n+                 number_of_events: int, context: Context) -> None:\n+        \"\"\"Construct a WaitSet.\"\"\"\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def clear_entities(self) -> None:\n+        \"\"\"Clear all the pointers in the wait set.\"\"\"\n+\n+    def add_service(self, service: Service) -> int:\n+        \"\"\"Add a service to the wait set structure.\"\"\"\n+\n+    def add_subscription(self, subscription: Subscription[Any]) -> int:\n+        \"\"\"Add a subcription to the wait set structure.\"\"\"\n+\n+    def add_client(self, client: Client) -> int:\n+        \"\"\"Add a client to the wait set structure.\"\"\"\n+\n+    def add_guard_condition(self, guard_condition: GuardCondition) -> int:\n+        \"\"\"Add a guard condition to the wait set structure.\"\"\"\n+\n+    def add_timer(self, timer: Timer) -> int:\n+        \"\"\"Add a timer to the wait set structure.\"\"\"\n+\n+    def add_event(self, event: EventHandle) -> int:\n+        \"\"\"Add an event to the wait set structure.\"\"\"\n+\n+    def is_ready(self, entity_type: IsReadyValues, index: int) -> bool:\n+        \"\"\"Check if an entity in the wait set is ready by its index.\"\"\"\n+\n+    def get_ready_entities(self, entity_type: GetReadyEntityValues) -> list[int]:\n+        \"\"\"Get list of entities ready by entity type.\"\"\"\n+\n+    def wait(self, timeout: int) -> None:\n+        \"\"\"Wait until timeout is reached or event happened.\"\"\""},{"role":"user","content":"+"},{"role":"user","content":"-from rclpy.subscription import SubscriptionHandle"},{"role":"user","content":"-class NodeHandle:\n-    pass\n-\n-"},{"role":"user","content":"-                subscription_object: SubscriptionHandle[MsgT] = _rclpy.Subscription(\n+                subscription_object = _rclpy.Subscription("},{"role":"user","content":"-from typing import Generic, List, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union\n+from typing import Generic, List, Optional, Type, TypeVar, Union"},{"role":"user","content":"-from rclpy.destroyable import DestroyableType\n-from rclpy.duration import Duration, DurationHandle\n+from rclpy.duration import Duration"},{"role":"user","content":"-if TYPE_CHECKING:\n-    from rclpy.node import NodeHandle\n-\n-\n-class PublisherHandle(DestroyableType, Protocol[MsgT]):\n-\n-    def __init__(self, arg0: 'NodeHandle', arg1: Type[MsgT], arg2: str, arg3: object) -> None:\n-        \"\"\"Create PublisherHandle.\"\"\"\n-\n-    @property\n-    def pointer(self) -> int:\n-        \"\"\"Get the address of the entity as an integer.\"\"\"\n-\n-    def get_logger_name(self) -> str:\n-        \"\"\"Get the name of the logger associated with the node of the publisher.\"\"\"\n-\n-    def get_subscription_count(self) -> int:\n-        \"\"\"Count subscribers from a publisher.\"\"\"\n-\n-    def get_topic_name(self) -> str:\n-        \"\"\"Retrieve the topic name from a Publisher.\"\"\"\n-\n-    def publish(self, arg0: MsgT) -> None:\n-        \"\"\"Publish a message.\"\"\"\n-\n-    def publish_raw(self, arg0: bytes) -> None:\n-        \"\"\"Publish a serialized message.\"\"\"\n-\n-    def wait_for_all_acked(self, arg0: DurationHandle) -> bool:\n-        \"\"\"Wait until all published message data is acknowledged.\"\"\"\n-"},{"role":"user","content":"-        publisher_impl: PublisherHandle[MsgT],\n+        publisher_impl: '_rclpy.Publisher[MsgT]',"},{"role":"user","content":"-    def handle(self) -> PublisherHandle[MsgT]:\n+    def handle(self) -> '_rclpy.Publisher[MsgT]':"},{"role":"user","content":"-from typing import (Callable, Iterable, List, Optional, Protocol, Tuple, Type, TYPE_CHECKING,\n+from typing import (Callable, Iterable, List, Optional, Tuple, Type, TYPE_CHECKING,"},{"role":"user","content":"-from rclpy.duration import Duration, DurationHandle\n+from rclpy.duration import Duration"},{"role":"user","content":"-class QoSProfileHandle(Protocol):\n-    qos_history: Union['QoSHistoryPolicy', int]\n-    qos_depth: int\n-    qos_reliability: Union['QoSReliabilityPolicy', int]\n-    qos_durability: Union['QoSDurabilityPolicy', int]\n-    pyqos_lifespan: DurationHandle\n-    pyqos_deadline: DurationHandle\n-    qos_liveliness: Union['QoSLivelinessPolicy', int]\n-    pyqos_liveliness_lease_duration: DurationHandle\n-    avoid_ros_namespace_conventions: bool\n-\n-"},{"role":"user","content":"-    def get_c_qos_profile(self) -> QoSProfileHandle:\n+    def get_c_qos_profile(self) -> _rclpy.rmw_qos_profile_t:"},{"role":"user","content":"-from typing import Callable, Generic, Optional, Protocol, Tuple, Type, TypedDict, TypeVar, Union\n+from typing import Callable, Generic, Optional, Type, TypedDict, TypeVar, Union"},{"role":"user","content":"-from rclpy.destroyable import DestroyableType"},{"role":"user","content":"+from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy"},{"role":"user","content":"-class SubscriptionHandle(DestroyableType, Protocol[MsgT]):\n-\n-    @property\n-    def pointer(self) -> int:\n-        \"\"\"Get the address of the entity as an integer.\"\"\"\n-        ...\n-\n-    def take_message(self, pymsg_type: Type[MsgT], raw: bool) -> Tuple[MsgT, MessageInfo]:\n-        \"\"\"Take a message and its metadata from a subscription.\"\"\"\n-        ...\n-\n-    def get_logger_name(self) -> str:\n-        \"\"\"Get the name of the logger associated with the node of the subscription.\"\"\"\n-        ...\n-\n-    def get_topic_name(self) -> str:\n-        \"\"\"Return the resolved topic name of a subscription.\"\"\"\n-        ...\n-\n-    def get_publisher_count(self) -> int:\n-        \"\"\"Count the publishers from a subscription.\"\"\"\n-        ...\n-\n-"},{"role":"user","content":"-         subscription_impl: SubscriptionHandle[MsgT],\n+         subscription_impl: '_rclpy.Subscription[MsgT]',"},{"role":"user","content":"-    def handle(self) -> SubscriptionHandle[MsgT]:\n+    def handle(self) -> '_rclpy.Subscription[MsgT]':"},{"role":"user","content":"-    def __enter__(self) -> 'Subscription':\n+    def __enter__(self) -> 'Subscription[MsgT]':"},{"role":"user","content":"-from typing import overload, Protocol, Tuple, Union\n+from typing import overload, Tuple, Union"},{"role":"user","content":"-class TimeHandle(Protocol):\n-    \"\"\"Type alias of _rclpy.rcl_time_point_t.\"\"\"\n-\n-    nanoseconds: int\n-    clock_type: ClockType\n-\n-"},{"role":"user","content":"-        self._time_handle: TimeHandle = _rclpy.rcl_time_point_t(total_nanoseconds, clock_type)\n+        self._time_handle = _rclpy.rcl_time_point_t(total_nanoseconds, clock_type)"},{"role":"user","content":"-    def __eq__(self, other: object) -> bool:\n+    def __eq__(self, other: 'Time') -> bool:"},{"role":"user","content":"-    def __ne__(self, other: object) -> bool:\n+    def __ne__(self, other: 'Time') -> bool:"},{"role":"user","content":"-    def __lt__(self, other: object) -> bool:\n+    def __lt__(self, other: 'Time') -> bool:"},{"role":"user","content":"-    def __le__(self, other: object) -> bool:\n+    def __le__(self, other: 'Time') -> bool:"},{"role":"user","content":"-    def __gt__(self, other: object) -> bool:\n+    def __gt__(self, other: 'Time') -> bool:"},{"role":"user","content":"-    def __ge__(self, other: object) -> bool:\n+    def __ge__(self, other: 'Time') -> bool:"},{"role":"user","content":"-from typing import Protocol"},{"role":"user","content":"-from rclpy.destroyable import DestroyableType"},{"role":"user","content":"-class TimerHandle(DestroyableType, Protocol):\n-    \"\"\"Type alias of _rclpy.Timer.\"\"\"\n-\n-    def reset_timer(self) -> None:\n-        ...\n-\n-    def is_timer_ready(self) -> bool:\n-        ...\n-\n-    def call_timer(self) -> None:\n-        ...\n-\n-    def change_timer_period(self, period_nsec: int) -> None:\n-        ...\n-\n-    def time_until_next_call(self) -> Optional[int]:\n-        ...\n-\n-    def time_since_last_call(self) -> int:\n-        ...\n-\n-    def get_timer_period(self) -> int:\n-        ...\n-\n-    def cancel_timer(self) -> None:\n-        ...\n-\n-    def is_timer_canceled(self) -> bool:\n-        ...\n-\n-"},{"role":"user","content":"-            raise RuntimeError('Context must be initialized before create a TimerHandle.')\n+            raise RuntimeError('Context must be initialized before create a _rclpy.Timer.')"},{"role":"user","content":"-            self.__timer: TimerHandle = _rclpy.Timer(\n+            self.__timer = _rclpy.Timer("},{"role":"user","content":"-    def handle(self) -> TimerHandle:\n+    def handle(self) -> _rclpy.Timer:"},{"role":"user","content":"-from typing import Union\n+from typing import Literal, Tuple, Type, Union"},{"role":"user","content":"+from rclpy.type_support import MsgT"},{"role":"user","content":"-    msg_type,\n+    msg_type: Type[MsgT],"},{"role":"user","content":"-    time_to_wait=-1\n-):\n+    time_to_wait: Union[int, float] = -1\n+) -> Union[Tuple[Literal[True], MsgT], Tuple[Literal[False], None]]:"},{"role":"user","content":"+\n+    if context.handle is None:\n+        raise RuntimeError('Cannot create Waitset without a context.handle')\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  message(STATUS \"Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\")\n+  message(STATUS\n+    \"Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\")"},{"role":"user","content":"-  message(STATUS \"Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\")\n+  message(STATUS\n+    \"Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\")"},{"role":"user","content":"-  target_sources(${PROJECT_NAME} PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)\n+  target_sources(${PROJECT_NAME}\n+    PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)"},{"role":"user","content":"-  set(ament_cmake_copyright_FOUND TRUE) # No copyright header check since link to NOTICE file is not recognized properly."},{"role":"user","content":"+  # No copyright header check since link to NOTICE file is not recognized properly.\n+  set(ament_cmake_copyright_FOUND TRUE)\n+"},{"role":"user","content":"-  rcl_node_t node = rcl_get_zero_initialized_node();\n+  rcl_node_t node;"},{"role":"user","content":"+#include <rclc/executor.h>\n+"},{"role":"user","content":"+#define RCCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n+        \"Failed status on line %d: %d. Aborting.\\n\", __LINE__, (int)temp_rc); return 1;}}\n+#define RCSOFTCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n+        \"Failed status on line %d: %d. Continuing.\\n\", __LINE__, (int)temp_rc);}}\n+"},{"role":"user","content":"-  rcl_node_t my_node = rcl_get_zero_initialized_node();\n+  rcl_node_t my_node;"},{"role":"user","content":"-  printf(\"make it a lifecycle node...\\n\");\n+  printf(\"creating lifecycle node...\\n\");"},{"role":"user","content":"-  // register callbacks\n+  // Executor\n+  rclc_executor_t executor;\n+  RCCHECK(rclc_executor_init(\n+    &executor,\n+    &support.context,\n+    4,  // 1 for the node + 1 for each lifecycle service\n+    &allocator));\n+\n+  unsigned int rcl_wait_timeout = 1000;  // in ms\n+  RCCHECK(rclc_executor_set_timeout(&executor, RCL_MS_TO_NS(rcl_wait_timeout)));\n+\n+  // Register lifecycle services\n+  printf(\"registering lifecycle services...\\n\");\n+  RCCHECK(rclc_lifecycle_init_get_state_server(&lifecycle_node, &executor));\n+  RCCHECK(rclc_lifecycle_init_get_available_states_server(&lifecycle_node, &executor));\n+  RCCHECK(rclc_lifecycle_init_change_state_server(&lifecycle_node, &executor));\n+\n+  // Register lifecycle service callbacks\n+  printf(\"registering callbacks...\\n\");"},{"role":"user","content":"+  rclc_lifecycle_register_on_activate(&lifecycle_node, &my_on_activate);"},{"role":"user","content":"+  rclc_lifecycle_register_on_cleanup(&lifecycle_node, &my_on_cleanup);"},{"role":"user","content":"-  printf(\" >configuring lifecycle node...\\n\");\n-  rc = rclc_lifecycle_change_state(\n-    &lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\"Error in TRANSITION_CONFIGURE\\n\");\n-    return -1;\n-  }\n-\n-  printf(\" >activating lifecycle node...\\n\");\n-  rc = rclc_lifecycle_change_state(\n-    &lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\"Error in TRANSITION_ACTIVATE\\n\");\n-    return -1;\n-  }\n-\n-  printf(\" >deactivating lifecycle node...\\n\");\n-  rc = rclc_lifecycle_change_state(\n-    &lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_DEACTIVATE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\"Error in TRANSITION_DEACTIVATE\\n\");\n-    return -1;\n-  }\n-\n-  printf(\" >cleaning rcl node up...\\n\");\n-  rc = rclc_lifecycle_change_state(\n-    &lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_CLEANUP,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\"Error in TRANSITION_CLEANUP\\n\");\n-    return -1;\n-  }\n-\n-  printf(\" >destroying lifecycle node...\\n\");\n-  rc = rclc_lifecycle_change_state(\n-    &lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_UNCONFIGURED_SHUTDOWN,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\"Error in TRANSITION_UNCONFIGURED_SHUTDOWN\\n\");\n-    return -1;\n-  }\n+  // Run\n+  RCSOFTCHECK(rclc_executor_spin(&executor));"},{"role":"user","content":"+  // Cleanup"},{"role":"user","content":"-  rc = rcl_lifecycle_node_fini(&lifecycle_node, &allocator);\n+  rc = rclc_lifecycle_node_fini(&lifecycle_node, &allocator);\n+  rc += rcl_node_fini(&my_node);\n+  rc += rclc_executor_fini(&executor);"},{"role":"user","content":"-  rcl_node_t node = rcl_get_zero_initialized_node();\n+  rcl_node_t node;"},{"role":"user","content":"-  unsigned int rcl_wait_timeout = 10;         // in ms\n+  unsigned int rcl_wait_timeout = 1000;  // in ms"},{"role":"user","content":"+# maximum string length - should cover all lifecycle state and transition names\n+set(RCLC_LIFECYCLE_MAX_STRING_LENGTH 20 CACHE STRING \"Set the maximum length for strings.\")\n+add_definitions(-DRCLC_LIFECYCLE_MAX_STRING_LENGTH=${RCLC_LIFECYCLE_MAX_STRING_LENGTH})\n+"},{"role":"user","content":"+find_package(std_msgs REQUIRED)"},{"role":"user","content":"+  std_msgs"},{"role":"user","content":"-Creation of a lifecycle node as a bundle of an rcl node and the rcl Node Lifecycle state machine.\n+Creation of a lifecycle node as a bundle of an rcl node and the rcl Node Lifecycle state machine:  "},{"role":"user","content":"-rcl_node_t my_node = rcl_get_zero_initialized_node();\n+rcl_node_t my_node;"},{"role":"user","content":"-rcl_lifecycle_state_machine_t state_machine_ =   \n+rcl_lifecycle_state_machine_t state_machine_ ="},{"role":"user","content":"-Optionally create hooks for lifecycle state changes.\n+Register lifecycle services and optionally create callbacks for state changes. Executor needsto be equipped with 1 handle per node _and_ per service:  "},{"role":"user","content":"-// declare callback\n-rcl_ret_t my_on_configure() {\n-  printf(\"  >>> lifecycle_node: on_configure() callback called.\\n\");\n-  return RCL_RET_OK;\n-}\n+// Executor\n+rclc_executor_t executor = rclc_executor_get_zero_initialized_executor();\n+rclc_executor_init(\n+  &executor,\n+  &support.context,\n+  4,  // 1 for the node + 1 for each lifecycle service\n+  &allocator));"},{"role":"user","content":"-// register callbacks\n-rclc_lifecycle_register_on_configure(&lifecycle_node, &my_on_configure);\n-```\n-\n-### Running\n+// Register lifecycle services\n+rclc_lifecycle_add_get_state_service(&lifecycle_node, &executor);\n+rclc_lifecycle_add_get_available_states_service(&lifecycle_node, &executor);\n+rclc_lifecycle_add_change_state_service(&lifecycle_node, &executor);"},{"role":"user","content":"-Change states of the lifecycle node, e.g.\n-\n-```C\n-bool publish_transition = true;\n-rc += rclc_lifecycle_change_state(\n-  &lifecycle_node,\n-  lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n-  publish_transition);\n-rc += rclc_lifecycle_change_state(\n-  &lifecycle_node,\n-  lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n-  publish_transition);\n+// Register lifecycle service callbacks\n+rclc_lifecycle_register_on_configure(&lifecycle_node, &my_on_configure);\n+rclc_lifecycle_register_on_activate(&lifecycle_node, &my_on_activate);"},{"role":"user","content":"-Except for error processing transitions, transitions are usually triggered from outside, e.g., by ROS 2 services.\n-"},{"role":"user","content":"-To clean everything up, simply do\n+To clean everything up, do:  "},{"role":"user","content":"+..."},{"role":"user","content":"-The state machine publishes state changes, however, lifecycle services are not yet exposed via ROS 2 services (tbd).\n+* Lifecycle services cannot yet be called via `ros2 lifecycle` CLI, e.g., `ros2 lifecycle set /node configure`. Instead use the `ros2 service` CLI, e.g., `ros2 service call /node/change_state lifecycle_msgs/ChangeState \"{transition: {id: 1, label: configure}}\"`."},{"role":"user","content":"-#include \"rclc/node.h\"\n+#include <lifecycle_msgs/srv/change_state.h>\n+#include <lifecycle_msgs/srv/get_state.h>\n+#include <lifecycle_msgs/srv/get_available_states.h>\n+\n+#include <rclc/node.h>\n+#include <rclc/executor.h>"},{"role":"user","content":"+  bool publish_transitions;\n+\n+  lifecycle_msgs__srv__ChangeState_Request cs_req;\n+  lifecycle_msgs__srv__ChangeState_Response cs_res;\n+  lifecycle_msgs__srv__GetState_Request gs_req;\n+  lifecycle_msgs__srv__GetState_Response gs_res;\n+  lifecycle_msgs__srv__GetAvailableStates_Request gas_req;\n+  lifecycle_msgs__srv__GetAvailableStates_Response gas_res;"},{"role":"user","content":"+/// Structure which encapsulates a ROS Lifecycle Node.\n+typedef struct rclc_lifecycle_service_context_t\n+{\n+  rclc_lifecycle_node_t * lifecycle_node;\n+} rclc_lifecycle_service_context_t;\n+\n+RCLC_LIFECYCLE_PUBLIC\n+rcl_ret_t\n+rclc_lifecycle_init_get_state_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor);\n+\n+RCLC_LIFECYCLE_PUBLIC\n+rcl_ret_t\n+rclc_lifecycle_init_get_available_states_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor);\n+\n+RCLC_LIFECYCLE_PUBLIC\n+rcl_ret_t\n+rclc_lifecycle_init_change_state_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor);\n+\n+RCLC_LIFECYCLE_PUBLIC\n+void\n+rclc_lifecycle_get_state_callback(\n+  const void * req,\n+  void * res,\n+  void * context);\n+\n+RCLC_LIFECYCLE_PUBLIC\n+void\n+rclc_lifecycle_get_available_states_callback(\n+  const void * req,\n+  void * res,\n+  void * context);\n+\n+RCLC_LIFECYCLE_PUBLIC\n+void\n+rclc_lifecycle_change_state_callback(\n+  const void * req,\n+  void * res,\n+  void * context);\n+"},{"role":"user","content":"-rcl_lifecycle_node_fini(\n+rclc_lifecycle_node_fini("},{"role":"user","content":"-  \n+"},{"role":"user","content":"+  <depend>std_msgs</depend>"},{"role":"user","content":"+#include <rclc/types.h>"},{"role":"user","content":"+#include <rosidl_runtime_c/string_functions.h>\n+#include <std_msgs/msg/string.h>\n+#include <lifecycle_msgs/msg/state.h>"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    node, \"node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    allocator, \"allocator is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+\n+  lifecycle_node->node = node;\n+"},{"role":"user","content":"-    // @todo(anordman): how/what to return in this case?"},{"role":"user","content":"-  lifecycle_node->node = node;"},{"role":"user","content":"+  // Pre-init messages and strings\n+  static char empty_string[RCLC_LIFECYCLE_MAX_STRING_LENGTH];\n+  memset(empty_string, ' ', RCLC_LIFECYCLE_MAX_STRING_LENGTH);\n+  empty_string[RCLC_LIFECYCLE_MAX_STRING_LENGTH - 1] = '\\0';\n+\n+  lifecycle_msgs__srv__ChangeState_Request__init(&lifecycle_node->cs_req);\n+  lifecycle_msgs__srv__ChangeState_Response__init(&lifecycle_node->cs_res);\n+\n+  lifecycle_msgs__srv__GetState_Request__init(&lifecycle_node->gs_req);\n+  lifecycle_msgs__srv__GetState_Response__init(&lifecycle_node->gs_res);\n+  rosidl_runtime_c__String__assign(\n+    &lifecycle_node->gs_res.current_state.label,\n+    (const char *) empty_string);\n+\n+  lifecycle_msgs__srv__GetAvailableStates_Request__init(&lifecycle_node->gas_req);\n+  lifecycle_msgs__srv__GetAvailableStates_Response__init(&lifecycle_node->gas_res);\n+  lifecycle_msgs__msg__State__Sequence__init(\n+    &lifecycle_node->gas_res.available_states,\n+    state_machine->transition_map.states_size);\n+  lifecycle_node->gas_res.available_states.size = 0;\n+  for (size_t i = 0; i < state_machine->transition_map.states_size; ++i) {\n+    rosidl_runtime_c__String__assign(\n+      &lifecycle_node->gas_res.available_states.data[i].label,\n+      (const char *) empty_string);\n+  }\n+"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    node, \"node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    node, \"node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    node, \"node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    node, \"node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"-rcl_lifecycle_node_fini(\n+rclc_lifecycle_node_fini("},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    allocator, \"allocator is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+    RCUTILS_LOG_ERROR(\n+      \"Unable to clean up state machine: %s\",\n+      rcl_get_error_string().str);\n+    rcutils_reset_error();"},{"role":"user","content":"-  // Cleanup node\n-  rcl_ret = rcl_node_fini(lifecycle_node->node);\n-  if (rcl_ret != RCL_RET_OK) {\n-    return RCL_RET_ERROR;\n-  }\n+  // Cleanup service messages\n+  lifecycle_msgs__srv__GetState_Request__fini(&lifecycle_node->gs_req);\n+  lifecycle_msgs__srv__GetState_Response__fini(&lifecycle_node->gs_res);\n+  lifecycle_msgs__srv__ChangeState_Request__fini(&lifecycle_node->cs_req);\n+  lifecycle_msgs__srv__ChangeState_Response__fini(&lifecycle_node->cs_res);\n+  lifecycle_msgs__srv__GetAvailableStates_Request__fini(&lifecycle_node->gas_req);\n+  lifecycle_msgs__srv__GetAvailableStates_Response__fini(&lifecycle_node->gas_res);"},{"role":"user","content":"+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+\n+rcl_ret_t\n+rclc_lifecycle_init_get_state_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor)\n+{\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    executor, \"executor is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  rclc_lifecycle_service_context_t context;\n+  context.lifecycle_node = lifecycle_node;\n+\n+  rcl_ret_t rc = rclc_executor_add_service_with_context(\n+    executor,\n+    &lifecycle_node->state_machine->com_interface.srv_get_state,\n+    &lifecycle_node->gs_req,\n+    &lifecycle_node->gs_res,\n+    rclc_lifecycle_get_state_callback,\n+    &context);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n+    return RCL_RET_ERROR;\n+  }\n+\n+  return rc;\n+}\n+\n+void\n+rclc_lifecycle_get_state_callback(\n+  const void * req,\n+  void * res,\n+  void * context)\n+{\n+  RCL_UNUSED(req);\n+  lifecycle_msgs__srv__GetState_Response * res_in =\n+    (lifecycle_msgs__srv__GetState_Response *) res;\n+  rclc_lifecycle_service_context_t * context_in =\n+    (rclc_lifecycle_service_context_t *) context;\n+\n+  rcl_lifecycle_state_machine_t * sm =\n+    context_in->lifecycle_node->state_machine;\n+\n+  res_in->current_state.id = sm->current_state->id;\n+  bool success = rosidl_runtime_c__String__assign(\n+    &res_in->current_state.label,\n+    sm->current_state->label);\n+  if (!success) {\n+    PRINT_RCLC_ERROR(\n+      rclc_lifecycle_get_state_callback,\n+      rosidl_runtime_c__String__assign);\n+  }\n+}\n+\n+rcl_ret_t\n+rclc_lifecycle_init_get_available_states_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor)\n+{\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    executor, \"executor is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+\n+  rclc_lifecycle_service_context_t context;\n+  context.lifecycle_node = lifecycle_node;\n+\n+  rcl_ret_t rc = rclc_executor_add_service_with_context(\n+    executor,\n+    &lifecycle_node->state_machine->com_interface.srv_get_available_states,\n+    &lifecycle_node->gas_req,\n+    &lifecycle_node->gas_res,\n+    rclc_lifecycle_get_available_states_callback,\n+    &context);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n+    return RCL_RET_ERROR;\n+  }\n+\n+  return rc;\n+}\n+\n+void\n+rclc_lifecycle_get_available_states_callback(\n+  const void * req,\n+  void * res,\n+  void * context)\n+{\n+  RCL_UNUSED(req);\n+  lifecycle_msgs__srv__GetAvailableStates_Response * res_in =\n+    (lifecycle_msgs__srv__GetAvailableStates_Response *) res;\n+  rclc_lifecycle_service_context_t * context_in =\n+    (rclc_lifecycle_service_context_t *) context;\n+\n+  rcl_lifecycle_state_machine_t * sm =\n+    context_in->lifecycle_node->state_machine;\n+\n+  bool success = true;\n+  res_in->available_states.size = sm->transition_map.states_size;\n+  for (unsigned int i = 0; i < sm->transition_map.states_size; ++i) {\n+    res_in->available_states.data[i].id = sm->transition_map.states[i].id;\n+    success &= rosidl_runtime_c__String__assign(\n+      &res_in->available_states.data[i].label,\n+      sm->transition_map.states[i].label);\n+  }\n+\n+  if (!success) {\n+    PRINT_RCLC_ERROR(\n+      rclc_lifecycle_get_available_states_callback,\n+      rosidl_runtime_c__String__assign);\n+  }\n+}\n+\n+rcl_ret_t\n+rclc_lifecycle_init_change_state_server(\n+  rclc_lifecycle_node_t * lifecycle_node,\n+  rclc_executor_t * executor)\n+{\n+  RCL_CHECK_FOR_NULL_WITH_MSG(\n+    lifecycle_node, \"lifecycle_node is a null pointer\", return RCL_RET_INVALID_ARGUMENT);\n+\n+  rclc_lifecycle_service_context_t context;\n+  context.lifecycle_node = lifecycle_node;\n+\n+  rcl_ret_t rc = rclc_executor_add_service_with_context(\n+    executor,\n+    &lifecycle_node->state_machine->com_interface.srv_change_state,\n+    &lifecycle_node->cs_req,\n+    &lifecycle_node->cs_res,\n+    rclc_lifecycle_change_state_callback,\n+    &context);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n+    return RCL_RET_ERROR;\n+  }\n+\n+  return rc;\n+}\n+\n+void\n+rclc_lifecycle_change_state_callback(\n+  const void * req,\n+  void * res,\n+  void * context)\n+{\n+  lifecycle_msgs__srv__ChangeState_Request * req_in =\n+    (lifecycle_msgs__srv__ChangeState_Request *) req;\n+  lifecycle_msgs__srv__ChangeState_Response * res_in =\n+    (lifecycle_msgs__srv__ChangeState_Response *) res;\n+  rclc_lifecycle_service_context_t * context_in =\n+    (rclc_lifecycle_service_context_t *) context;\n+\n+  rclc_lifecycle_node_t * ln = context_in->lifecycle_node;\n+  rcl_ret_t rc = rclc_lifecycle_change_state(ln, req_in->transition.id, true);\n+\n+  lifecycle_msgs__srv__ChangeState_Response__init(res_in);\n+  if (rc != RCL_RET_OK) {\n+    PRINT_RCLC_ERROR(\n+      rclc_lifecycle_change_state_callback,\n+      rclc_lifecycle_change_state);\n+    res_in->success = false;\n+  } else {\n+    res_in->success = true;\n+  }\n+}"},{"role":"user","content":"-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n+  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();"},{"role":"user","content":"-    &state_machine_,\n+    &state_machine,"},{"role":"user","content":"-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n+  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();"},{"role":"user","content":"-    &state_machine_,\n+    &state_machine,"},{"role":"user","content":"-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n+  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();"},{"role":"user","content":"-    &state_machine_,\n+    &state_machine,"},{"role":"user","content":"+  EXPECT_EQ(RCL_RET_OK, res);\n+  EXPECT_EQ(1, callback_mockup_counter);\n+"},{"role":"user","content":"+  EXPECT_EQ(RCL_RET_OK, res);\n+  EXPECT_EQ(3, callback_mockup_counter);\n+"},{"role":"user","content":"+  EXPECT_EQ(RCL_RET_OK, res);\n+  EXPECT_EQ(7, callback_mockup_counter);\n+"},{"role":"user","content":"-"},{"role":"user","content":"+\n+TEST(TestRclcLifecycle, lifecycle_node_servers) {\n+  rcl_context_t context = rcl_get_zero_initialized_context();\n+  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n+  rcl_allocator_t allocator = rcl_get_default_allocator();\n+\n+  rcl_ret_t res = rcl_init_options_init(&init_options, allocator);\n+  res += rcl_init(0, nullptr, &init_options, &context);\n+\n+  rcl_node_t my_node = rcl_get_zero_initialized_node();\n+  rcl_node_options_t node_ops = rcl_node_get_default_options();\n+  res += rcl_node_init(&my_node, \"lifecycle_node\", \"rclc\", &context, &node_ops);\n+\n+  rclc_lifecycle_node_t lifecycle_node;\n+  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();\n+\n+  res += rclc_make_node_a_lifecycle_node(\n+    &lifecycle_node,\n+    &my_node,\n+    &state_machine,\n+    &allocator,\n+    true);\n+\n+  // register callbacks\n+  rclc_lifecycle_register_on_configure(&lifecycle_node, &callback_mockup_0);\n+  rclc_lifecycle_register_on_activate(&lifecycle_node, &callback_mockup_1);\n+  rclc_lifecycle_register_on_deactivate(&lifecycle_node, &callback_mockup_2);\n+  rclc_lifecycle_register_on_cleanup(&lifecycle_node, &callback_mockup_3);\n+\n+  // create lifecycle servers\n+  rclc_executor_t executor;\n+  res = rclc_executor_init(\n+    &executor,\n+    &context,\n+    1,  // too little\n+    &allocator);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+\n+  // Too little executor handles\n+  res = rclc_lifecycle_init_get_state_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_get_available_states_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_ERROR, res);\n+\n+  // Now with correct number of handles\n+  rclc_executor_init(\n+    &executor,\n+    &context,\n+    3,  // 1 for each lifecycle service\n+    &allocator);\n+  res = rclc_lifecycle_init_get_state_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_get_available_states_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_lifecycle_init_change_state_server(&lifecycle_node, &executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+\n+  // Cleanup\n+  res = rclc_lifecycle_node_fini(&lifecycle_node, &allocator);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rcl_node_fini(&my_node);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+  res = rclc_executor_fini(&executor);\n+  EXPECT_EQ(RCL_RET_OK, res);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <unordered_map>"},{"role":"user","content":"+#include \"rmw_dds_common/security.hpp\"\n+"},{"role":"user","content":"-  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n-  rcutils_allocator_t * const allocator_ptr = &allocator;\n-  std::ostringstream ss;\n-  std::string prop_uri;"},{"role":"user","content":"-  char * const prop_identity_ca =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"identity_ca.cert.pem\",\n-    allocator);\n-  auto scope_exit_prop_identity_ca = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_identity_ca]()\n-    {\n-      allocator_ptr->deallocate(prop_identity_ca, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_identity_ca;\n-  prop_uri = ss.str();\n-  ss.str(\"\");\n+  std::unordered_map<std::string, std::string> security_files;\n+  if (!rmw_dds_common::get_security_files(\n+      uri_prefix, ctx->base->options.security_options.security_root_path, security_files))\n+  {\n+    RMW_CONNEXT_LOG_ERROR(\"couldn't find all security files\");\n+    return RMW_RET_ERROR;\n+  }\n+"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"IDENTITY_CA\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_IDENTITY_CA_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_IDENTITY_CA_PROPERTY, security_files[\"IDENTITY_CA\"].c_str())"},{"role":"user","content":"-  char * const prop_perm_ca =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"permissions_ca.cert.pem\",\n-    allocator);\n-  auto scope_exit_prop_perm_ca = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_perm_ca]()\n-    {\n-      allocator_ptr->deallocate(prop_perm_ca, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_perm_ca;\n-  prop_uri = ss.str();\n-  ss.str(\"\");"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"PERMISSIONS_CA\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_PERMISSIONS_CA_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_PERMISSIONS_CA_PROPERTY, security_files[\"PERMISSIONS_CA\"].c_str())"},{"role":"user","content":"-  char * const prop_peer_key =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"key.pem\",\n-    allocator);\n-  auto scope_exit_prop_peer_key = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_peer_key]()\n-    {\n-      allocator_ptr->deallocate(prop_peer_key, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_peer_key;\n-  prop_uri = ss.str();\n-  ss.str(\"\");"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"PRIVATE_KEY\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_PRIVATE_KEY_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_PRIVATE_KEY_PROPERTY, security_files[\"PRIVATE_KEY\"].c_str())"},{"role":"user","content":"-  char * const prop_peer_cert =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"cert.pem\",\n-    allocator);\n-  auto scope_exit_prop_peer_cert = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_peer_cert]()\n-    {\n-      allocator_ptr->deallocate(prop_peer_cert, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_peer_cert;\n-  prop_uri = ss.str();\n-  ss.str(\"\");"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"CERTIFICATE\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY, security_files[\"CERTIFICATE\"].c_str())"},{"role":"user","content":"-\n-  char * const prop_governance =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"governance.p7s\",\n-    allocator);\n-  auto scope_exit_prop_governance = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_governance]()\n-    {\n-      allocator_ptr->deallocate(prop_governance, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_governance;\n-  prop_uri = ss.str();\n-  ss.str(\"\");"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"GOVERNANCE\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_GOVERNANCE_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_GOVERNANCE_PROPERTY, security_files[\"GOVERNANCE\"].c_str())"},{"role":"user","content":"-  char * const prop_permissions =\n-    rcutils_join_path(\n-    ctx->base->options.security_options.security_root_path,\n-    \"permissions.p7s\",\n-    allocator);\n-  auto scope_exit_prop_permissions = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_permissions]()\n-    {\n-      allocator_ptr->deallocate(prop_permissions, allocator_ptr->state);\n-    });\n-  ss << uri_prefix << prop_permissions;\n-  prop_uri = ss.str();\n-  ss.str(\"\");"},{"role":"user","content":"-      prop_uri.c_str(),\n+      security_files[\"PERMISSIONS\"].c_str(),"},{"role":"user","content":"-      DDS_SECURITY_PERMISSIONS_PROPERTY, prop_uri.c_str())\n+      DDS_SECURITY_PERMISSIONS_PROPERTY, security_files[\"PERMISSIONS\"].c_str())"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-ament_python_install_package(${PROJECT_NAME}\n-     PACKAGE_DIR src/${PROJECT_NAME})\n+# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n+# ament_python_install_package(${PROJECT_NAME}\n+#      PACKAGE_DIR src/${PROJECT_NAME})"},{"role":"user","content":"-# TODO (ahcorde) Port python once https://github.com/ros2/orocos_kinematics_dynamics/pull/4 is merged\n+# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  bool ret = true;"},{"role":"user","content":"-      ret &= false;  // type is not self contained\n+      return false;  // type is not self contained"},{"role":"user","content":"-      ret &= is_type_self_contained(sub_members);\n+      if (!is_type_self_contained(sub_members)) {\n+        return false;\n+      }"},{"role":"user","content":"-  return ret;\n+  return true;"},{"role":"user","content":"-  auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n+  auto ptr = SHIFT_PAST_ICEORYX_HEADER(chunk_ptr);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+* [Enable Zero Copy Data Sharing](#enable-zero-copy-data-sharing)"},{"role":"user","content":"+### Enable Zero Copy Data Sharing\n+\n+ROS 2 provides [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) that allows the user application to loan the message memory from the RMW implementation to eliminate the copy between the ROS 2 application and RMW implementation.\n+And Fast DDS `rmw_fastrtps_cpp` provides [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) features to speed up the localhost communication.\n+Taking advantage of these features all together, it provides significant performance improvement to ROS 2 application.\n+\n+By default, `rmw_fastrtps_cpp` tries to use [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) for localhost communication along with network communication if the message data type is a bounded type (a fixed sized data object).\n+\n+To enable [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) with `rmw_fastrtps_cpp`, [Plain Old Data](https://en.wikipedia.org/wiki/Passive_data_structure) is the only requirement to `Iron Irwini` or later.\n+For `Humble Hawksbill`, the following XML file needs to be applied to set Fast-DDS `data_sharing` is explicitly enabled. (see more details for https://github.com/ros2/rmw_fastrtps/pull/568)\n+\n+```xml\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\">\n+\n+  <!-- Default publisher profile -->\n+  <data_writer profile_name=\"default publisher profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_writer>\n+\n+  <data_reader profile_name=\"default subscription profile\" is_default_profile=\"true\">\n+    <qos>\n+      <data_sharing>\n+        <kind>AUTOMATIC</kind>\n+      </data_sharing>\n+    </qos>\n+  </data_reader>\n+</profiles>\n+```\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        fixed_frame_.toStdString(), 10, rviz_ros_node_.lock()->get_raw_node());\n+        fixed_frame_.toStdString(),\n+        static_cast<uint32_t>(message_queue_property_->getInt()),\n+        rviz_ros_node_.lock()->get_raw_node());"},{"role":"user","content":"-    tf_filter_->setQueueSize(static_cast<uint32_t>(message_queue_property_->getInt()));\n+    if (tf_filter_) {\n+      tf_filter_->setQueueSize(static_cast<uint32_t>(message_queue_property_->getInt()));\n+    }"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <set>\n+#include <sstream>"},{"role":"user","content":"+  using ns_type = decltype(visualization_msgs::msg::Marker::ns);\n+  using id_type = decltype(visualization_msgs::msg::Marker::id);\n+  using pair_type = std::pair<id_type, const ns_type &>;\n+\n+  // Keep track of unique markers\n+  std::set<pair_type> unique_markers;\n+  bool found_duplicate = false;\n+  std::string offending_ns;\n+  id_type offending_id = 0;\n+"},{"role":"user","content":"+    if (!found_duplicate) {\n+      pair_type pair(marker.id, marker.ns);\n+      found_duplicate = !unique_markers.insert(pair).second;\n+      if (found_duplicate) {\n+        offending_ns = marker.ns;\n+        offending_id = marker.id;\n+      }\n+    }"},{"role":"user","content":"+\n+  // Can't use setMarkerStatus on individual markers because processAdd would clear it.\n+  const char * kDuplicateStatus = \"Duplicate Marker Check\";\n+  if (found_duplicate) {\n+    std::stringstream error_stream;\n+    error_stream << \"Multiple Markers in the same MarkerArray message had the same ns and id: \";\n+    error_stream << \"(\" << offending_ns << \", \" << offending_id << \")\";\n+    display_->setStatusStd(\n+      rviz_common::properties::StatusProperty::Error,\n+      kDuplicateStatus,\n+      error_stream.str());\n+  } else {\n+    display_->deleteStatusStd(kDuplicateStatus);\n+  }"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# Nanoseconds component in the range of [0, 10e9).\n+# Nanoseconds component in the range of [0, 1e9)."},{"role":"user","content":"-# The nanoseconds component, valid in the range [0, 10e9).\n+# The nanoseconds component, valid in the range [0, 1e9)."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+      current_width = 0;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  # get the rmw implementations ahead of time\n-  find_package(rmw_implementation_cmake REQUIRED)\n-  get_available_rmw_implementations(rmw_implementations)\n-  foreach(rmw_implementation ${rmw_implementations})\n-    find_package(\"${rmw_implementation}\" REQUIRED)\n-  endforeach()\n-\n-  function(custom_test_c target)\n-    ament_add_gtest(\n-      \"${target}${target_suffix}\" ${ARGN}\n-      TIMEOUT 180\n-      ENV\n-      RCL_ASSERT_RMW_ID_MATCHES=${rmw_implementation}\n-      RMW_IMPLEMENTATION=${rmw_implementation}\n+  ament_add_gtest_executable(test_action_communication test/rcl_action/test_action_communication.cpp)\n+  target_link_libraries(test_action_communication\n+    ${PROJECT_NAME}\n+    ${action_msgs_TARGETS}\n+    osrf_testing_tools_cpp::memory_tools\n+    rcl::rcl\n+    rosidl_runtime_c::rosidl_runtime_c\n+    ${test_msgs_TARGETS})\n+\n+  ament_add_gtest_executable(test_action_interaction test/rcl_action/test_action_interaction.cpp)\n+  target_link_libraries(test_action_interaction\n+    ${PROJECT_NAME}\n+    ${action_msgs_TARGETS}\n+    osrf_testing_tools_cpp::memory_tools\n+    rcl::rcl\n+    rosidl_runtime_c::rosidl_runtime_c\n+    ${test_msgs_TARGETS})\n+\n+  ament_add_gtest_executable(test_graph test/rcl_action/test_graph.cpp)\n+  target_compile_definitions(test_graph PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n+  target_link_libraries(test_graph\n+    ${PROJECT_NAME}\n+    ${action_msgs_TARGETS}\n+    osrf_testing_tools_cpp::memory_tools\n+    rcl::rcl\n+    rcutils::rcutils\n+    rosidl_runtime_c::rosidl_runtime_c\n+    ${test_msgs_TARGETS})\n+\n+  function(test_targets)\n+    message(STATUS \"Creating tests for '${rmw_implementation}'\")\n+    set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n+\n+    ament_add_gtest_test(test_action_communication\n+      TEST_NAME test_action_communication${target_suffix}\n+      ENV ${rmw_implementation_env_var}"},{"role":"user","content":"-    if(TARGET ${target}${target_suffix})\n-      target_compile_definitions(${target}${target_suffix}\n-        PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n-        target_compile_definitions(${target}${target_suffix}\n-          PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n-      target_link_libraries(${target}${target_suffix}\n-        ${PROJECT_NAME}\n-        osrf_testing_tools_cpp::memory_tools\n-        rcl::rcl\n-        rosidl_runtime_c::rosidl_runtime_c\n-        ${test_msgs_TARGETS}\n-      )\n-    endif()\n-  endfunction()"},{"role":"user","content":"-  macro(targets)\n-    custom_test_c(test_action_communication\n-      \"test/rcl_action/test_action_communication.cpp\")\n-    custom_test_c(test_action_interaction\n-      \"test/rcl_action/test_action_interaction.cpp\")\n+    ament_add_gtest_test(test_action_interaction\n+      TEST_NAME test_action_interaction${target_suffix}\n+      ENV ${rmw_implementation_env_var}\n+    )"},{"role":"user","content":"-    custom_test_c(test_graph\n-      \"test/rcl_action/test_graph.cpp\")\n-  endmacro()\n+    ament_add_gtest_test(test_graph\n+      TEST_NAME test_graph${target_suffix}\n+      ENV ${rmw_implementation_env_var}\n+    )\n+  endfunction()"},{"role":"user","content":"-  call_for_each_rmw_implementation(targets)\n+  call_for_each_rmw_implementation(test_targets)"},{"role":"user","content":"-#include \"test_msgs/action/fibonacci.h\"\n+#include \"action_msgs/srv/cancel_goal.h\""},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n+#include \"test_msgs/action/fibonacci.h\""},{"role":"user","content":"-class CLASSNAME (TestActionCommunication, RMW_IMPLEMENTATION) : public ::testing::Test\n+class TestActionCommunication : public ::testing::Test"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_goal_comm)\n+TEST_F(TestActionCommunication, test_valid_goal_comm)"},{"role":"user","content":"-\n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_cancel_comm)\n+TEST_F(TestActionCommunication, test_valid_cancel_comm)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_result_comm)\n+TEST_F(TestActionCommunication, test_valid_result_comm)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_status_comm)\n+TEST_F(TestActionCommunication, test_valid_status_comm)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_feedback_comm)\n+TEST_F(TestActionCommunication, test_valid_feedback_comm)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal_request_opts)\n+TEST_F(TestActionCommunication, test_invalid_goal_request_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal_response_opts)\n+TEST_F(TestActionCommunication, test_invalid_goal_response_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_cancel_request_opts)\n+TEST_F(TestActionCommunication, test_invalid_cancel_request_opts)"},{"role":"user","content":"-\n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_cancel_response_opts)\n+TEST_F(TestActionCommunication, test_invalid_cancel_response_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_result_request_opts)\n+TEST_F(TestActionCommunication, test_invalid_result_request_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_result_response_opts)\n+TEST_F(TestActionCommunication, test_invalid_result_response_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_feedback_opts)\n+TEST_F(TestActionCommunication, test_invalid_feedback_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_status_opts)\n+TEST_F(TestActionCommunication, test_invalid_status_opts)"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_feedback_comm_maybe_fail)\n+TEST_F(TestActionCommunication, test_valid_feedback_comm_maybe_fail)"},{"role":"user","content":"-#include \"test_msgs/action/fibonacci.h\"\n+#include \"action_msgs/srv/cancel_goal.h\""},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n+#include \"test_msgs/action/fibonacci.h\""},{"role":"user","content":"-class CLASSNAME (TestActionClientServerInteraction, RMW_IMPLEMENTATION) : public ::testing::Test\n+class TestActionClientServerInteraction : public ::testing::Test"},{"role":"user","content":"-TEST_F(CLASSNAME(TestActionClientServerInteraction, RMW_IMPLEMENTATION), test_interaction)\n+TEST_F(TestActionClientServerInteraction, test_interaction)"},{"role":"user","content":"-TEST_F(\n-  CLASSNAME(TestActionClientServerInteraction, RMW_IMPLEMENTATION), test_interaction_with_cancel)\n+TEST_F(TestActionClientServerInteraction, test_interaction_with_cancel)"},{"role":"user","content":"-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-"},{"role":"user","content":"-class CLASSNAME (TestActionGraphFixture, RMW_IMPLEMENTATION) : public ::testing::Test\n+class TestActionGraphFixture : public ::testing::Test"},{"role":"user","content":"-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_client_names_and_types_by_node)\n+TEST_F(TestActionGraphFixture, test_action_get_client_names_and_types_by_node)"},{"role":"user","content":"-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_server_names_and_types_by_node)\n+TEST_F(TestActionGraphFixture, test_action_get_server_names_and_types_by_node)"},{"role":"user","content":"-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_names_and_types)\n+TEST_F(TestActionGraphFixture, test_action_get_names_and_types)"},{"role":"user","content":"-class TestActionGraphMultiNodeFixture : public CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION)\n+class TestActionGraphMultiNodeFixture : public TestActionGraphFixture"},{"role":"user","content":"-    CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION) ::SetUp();\n+    TestActionGraphFixture::SetUp();"},{"role":"user","content":"-    CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION) ::TearDown();\n+    TestActionGraphFixture::TearDown();"},{"role":"user","content":"-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_names_and_types) {\n+TEST_F(TestActionGraphMultiNodeFixture, test_action_get_names_and_types)\n+{"},{"role":"user","content":"-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_server_names_and_types_by_node) {\n+TEST_F(TestActionGraphMultiNodeFixture, test_action_get_server_names_and_types_by_node)\n+{"},{"role":"user","content":"-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_client_names_and_types_by_node) {\n+TEST_F(TestActionGraphMultiNodeFixture, test_action_get_client_names_and_types_by_node)\n+{"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  setRenderModeAndDimensions(new_message, scale);\n+  points_->clearAndRemoveAllPoints();"},{"role":"user","content":"-  points_->clear();\n+  setRenderModeAndDimensions(new_message, scale);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+/**\n+ * \\warning On some Linux distributions (e.g. CentOS), pointers to function\n+ *   reference their PLT trampolines. In such cases, it is not possible to\n+ *   call `function` from within the mock.\n+ */"},{"role":"user","content":"-      static_cast<void>(base(std::forward<decltype(__args)>(__args)...)); \\\n+      if (base != function) { \\\n+        static_cast<void>(base(std::forward<decltype(__args)>(__args)...)); \\\n+      } else { \\\n+        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n+          \"[WARNING] mocking_utils::inject_on_return() cannot forward call to \" \\\n+          \"original '\" RCUTILS_STRINGIFY(function) \"' function before injection\\n\" \\\n+          \"    at \" __FILE__ \":\" RCUTILS_STRINGIFY(__LINE__) \"\\n\"); \\\n+      } \\"},{"role":"user","content":"-    ([&, base = fwrite](const void * ptr, size_t size,\n-    size_t count, FILE * stream)\n+    [&](const void * ptr, size_t size, size_t count, FILE * stream)"},{"role":"user","content":"-      return base(ptr, size, count, stream);\n-    }));\n+      return count;\n+    });"},{"role":"user","content":"-      [base = rcutils_strdup](const char * str, auto allocator)\n+      [](const char * str, auto allocator)"},{"role":"user","content":"-          return base(str, allocator);\n+          char * dup = static_cast<char *>(\n+            allocator.allocate(strlen(str) + 1, allocator.state));\n+          memcpy(dup, str, strlen(str) + 1);\n+          return dup;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <queue>\n+"},{"role":"user","content":"-  dds_ReadCondition * read_condition;\n+  std::queue<GurumddsMessage> message_queue;\n+  dds_GuardCondition * queue_guard_condition;\n+  std::mutex queue_mutex;"},{"role":"user","content":"+  std::queue<GurumddsMessage> message_queue;\n+  dds_GuardCondition * queue_guard_condition;\n+  std::mutex queue_mutex;\n+"},{"role":"user","content":"-  dds_ReadCondition * read_condition;"},{"role":"user","content":"+  std::queue<GurumddsMessage> message_queue;\n+  dds_GuardCondition * queue_guard_condition;\n+  std::mutex queue_mutex;\n+"},{"role":"user","content":"-  dds_ReadCondition * read_condition;"},{"role":"user","content":"+  dds_DataReaderListener datareader_listener = {};"},{"role":"user","content":"-  dds_ReadCondition * read_condition = nullptr;\n+  dds_GuardCondition * queue_guard_condition = nullptr;"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"+  ret = dds_DataWriterQos_finalize(&datawriter_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datawriter qos\");\n+    goto fail;\n+  }\n+"},{"role":"user","content":"+  datareader_listener.on_data_available = reader_on_data_available<GurumddsClientInfo>;\n+"},{"role":"user","content":"-    dds_subscriber, response_topic, &datareader_qos, nullptr, 0);\n+    dds_subscriber, response_topic, &datareader_qos, &datareader_listener,\n+    dds_DATA_AVAILABLE_STATUS);"},{"role":"user","content":"-  read_condition = dds_DataReader_create_readcondition(\n-    response_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create read condition\");\n+  ret = dds_DataReaderQos_finalize(&datareader_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datareader qos\");"},{"role":"user","content":"-  client_info->read_condition = read_condition;\n+\n+  dds_DataReader_set_listener_context(client_info->response_reader, client_info);\n+\n+  queue_guard_condition = dds_GuardCondition_create();\n+  if (queue_guard_condition == nullptr) {\n+    RMW_SET_ERROR_MSG(\"failed to create guard condition\");\n+    goto fail;\n+  }\n+  client_info->queue_guard_condition = queue_guard_condition;"},{"role":"user","content":"-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(response_reader, read_condition);\n+      if (queue_guard_condition != nullptr) {\n+        dds_GuardCondition_delete(queue_guard_condition);"},{"role":"user","content":"-          if (client_info->read_condition != nullptr) {\n-            ret = dds_DataReader_delete_readcondition(\n-              client_info->response_reader, client_info->read_condition);\n-            if (ret != dds_RETCODE_OK) {\n-              RMW_SET_ERROR_MSG(\"failed to delete readcondition\");\n-              rmw_ret = RMW_RET_ERROR;\n-            }\n-          }"},{"role":"user","content":"-        } else if (client_info->read_condition != nullptr) {\n-          RMW_SET_ERROR_MSG(\"cannot delete readcondition because the datareader is null\");\n-          rmw_ret = RMW_RET_ERROR;"},{"role":"user","content":"+    if (client_info->queue_guard_condition != nullptr) {\n+      dds_GuardCondition_delete(client_info->queue_guard_condition);\n+      client_info->queue_guard_condition = nullptr;\n+    }\n+\n+    while (!client_info->message_queue.empty()) {\n+      auto msg = client_info->message_queue.front();\n+      if (msg.sample != nullptr) {\n+        free(msg.sample);\n+      }\n+      if (msg.info != nullptr) {\n+        free(msg.info);\n+      }\n+      client_info->message_queue.pop();\n+    }\n+"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"+  ret = dds_DataWriterQos_finalize(&datawriter_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datawriter qos\");\n+    goto fail;\n+  }\n+"},{"role":"user","content":"+  ret = dds_DataWriterQos_finalize(&dds_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datawriter qos\");\n+    return RMW_RET_ERROR;\n+  }\n+"},{"role":"user","content":"-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create data sequence\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info->valid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+  service_info->queue_mutex.lock();\n+  auto msg = service_info->message_queue.front();\n+  service_info->message_queue.pop();\n+  if (service_info->message_queue.empty()) {\n+    dds_GuardCondition_set_trigger_value(service_info->queue_guard_condition, false);\n+  }\n+  service_info->queue_mutex.unlock();\n+\n+  if (msg.info->valid_data) {\n+    if (msg.sample == nullptr) {\n+      RMW_SET_ERROR_MSG(\"Received invalid message\");\n+      free(msg.info);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-      sample,\n-      static_cast<size_t>(size),\n+      msg.sample,\n+      static_cast<size_t>(msg.size),"},{"role":"user","content":"-      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n+      free(msg.sample);\n+      free(msg.info);"},{"role":"user","content":"-      sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-      sample_info->source_timestamp.nanosec;\n+      msg.info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+      msg.info->source_timestamp.nanosec;"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n+  if (msg.sample != nullptr) {\n+    free(msg.sample);\n+  }\n+  if (msg.info != nullptr) {\n+    free(msg.info);\n+  }"},{"role":"user","content":"-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create data sequence\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info->valid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+  client_info->queue_mutex.lock();\n+  auto msg = client_info->message_queue.front();\n+  client_info->message_queue.pop();\n+  if (client_info->message_queue.empty()) {\n+    dds_GuardCondition_set_trigger_value(client_info->queue_guard_condition, false);\n+  }\n+  client_info->queue_mutex.unlock();\n+\n+  if (msg.info->valid_data) {\n+    if (msg.sample == nullptr) {\n+      RMW_SET_ERROR_MSG(\"Received invalid message\");\n+      free(msg.info);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-      sample,\n-      static_cast<size_t>(size),\n+      msg.sample,\n+      static_cast<size_t>(msg.size),"},{"role":"user","content":"-      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n+      free(msg.sample);\n+      free(msg.info);"},{"role":"user","content":"-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n+        msg.info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        msg.info->source_timestamp.nanosec;"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n+  if (msg.sample != nullptr) {\n+    free(msg.sample);\n+  }\n+  if (msg.info != nullptr) {\n+    free(msg.info);\n+  }"},{"role":"user","content":"+  dds_DataReaderListener datareader_listener = {};"},{"role":"user","content":"-  dds_ReadCondition * read_condition = nullptr;\n+  dds_GuardCondition * queue_guard_condition = nullptr;"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"+  datareader_listener.on_data_available = reader_on_data_available<GurumddsServiceInfo>;\n+"},{"role":"user","content":"-    dds_subscriber, request_topic, &datareader_qos, nullptr, 0);\n+    dds_subscriber, request_topic, &datareader_qos, &datareader_listener,\n+    dds_DATA_AVAILABLE_STATUS);"},{"role":"user","content":"-  read_condition = dds_DataReader_create_readcondition(\n-    request_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create read condition\");\n+  ret = dds_DataReaderQos_finalize(&datareader_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datareader qos\");\n+    goto fail;\n+  }\n+\n+  queue_guard_condition = dds_GuardCondition_create();\n+  if (queue_guard_condition == nullptr) {\n+    RMW_SET_ERROR_MSG(\"failed to create guard condition\");"},{"role":"user","content":"-  service_info->read_condition = read_condition;\n+  service_info->queue_guard_condition = queue_guard_condition;"},{"role":"user","content":"+  ret = dds_DataWriterQos_finalize(&datawriter_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datawriter qos\");\n+    goto fail;\n+  }\n+\n+  dds_DataReader_set_listener_context(service_info->request_reader, service_info);\n+"},{"role":"user","content":"-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(request_reader, read_condition);\n+      if (queue_guard_condition != nullptr) {\n+        dds_GuardCondition_delete(queue_guard_condition);"},{"role":"user","content":"-          if (service_info->read_condition != nullptr) {\n-            ret = dds_DataReader_delete_readcondition(\n-              service_info->request_reader, service_info->read_condition);\n-            if (ret != dds_RETCODE_OK) {\n-              RMW_SET_ERROR_MSG(\"failed to delete readcondition\");\n-              rmw_ret = RMW_RET_ERROR;\n-            }\n-          }"},{"role":"user","content":"-        } else if (service_info->read_condition != nullptr) {\n-          RMW_SET_ERROR_MSG(\"cannot delete readcondition because the datareader is null\");\n-          rmw_ret = RMW_RET_ERROR;"},{"role":"user","content":"+    if (service_info->queue_guard_condition != nullptr) {\n+      dds_GuardCondition_delete(service_info->queue_guard_condition);\n+      service_info->queue_guard_condition = nullptr;\n+    }\n+\n+    while (!service_info->message_queue.empty()) {\n+      auto msg = service_info->message_queue.front();\n+      if (msg.sample != nullptr) {\n+        free(msg.sample);\n+      }\n+      if (msg.info != nullptr) {\n+        free(msg.info);\n+      }\n+      service_info->message_queue.pop();\n+    }\n+"},{"role":"user","content":"+  dds_DataReaderListener datareader_listener = {};"},{"role":"user","content":"-  dds_ReadCondition * read_condition = nullptr;\n+  dds_GuardCondition * queue_guard_condition = nullptr;"},{"role":"user","content":"+\n+    ret = dds_TopicQos_finalize(&topic_qos);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to finalize topic qos\");\n+      goto fail;\n+    }"},{"role":"user","content":"-  topic_reader =\n-    dds_Subscriber_create_datareader(dds_subscriber, topic, &datareader_qos, nullptr, 0);\n+  datareader_listener.on_data_available = reader_on_data_available<GurumddsSubscriberInfo>;\n+\n+  topic_reader = dds_Subscriber_create_datareader(\n+    dds_subscriber, topic, &datareader_qos, &datareader_listener,\n+    dds_DATA_AVAILABLE_STATUS);"},{"role":"user","content":"-  read_condition = dds_DataReader_create_readcondition(\n-    topic_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create read condition\");\n+  ret = dds_DataReaderQos_finalize(&datareader_qos);\n+  if (ret != dds_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to finalize datareader qos\");\n+    goto fail;\n+  }\n+\n+  queue_guard_condition = dds_GuardCondition_create();\n+  if (queue_guard_condition == nullptr) {\n+    RMW_SET_ERROR_MSG(\"failed to create guard condition\");"},{"role":"user","content":"-  subscriber_info->read_condition = read_condition;\n+  subscriber_info->queue_guard_condition = queue_guard_condition;"},{"role":"user","content":"+  dds_DataReader_set_listener_context(subscriber_info->topic_reader, subscriber_info);\n+"},{"role":"user","content":"-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(topic_reader, read_condition);\n+      if (queue_guard_condition != nullptr) {\n+        dds_GuardCondition_delete(queue_guard_condition);"},{"role":"user","content":"-        dds_ReadCondition * read_condition = subscriber_info->read_condition;\n-        if (read_condition != nullptr) {\n-          ret = dds_DataReader_delete_readcondition(topic_reader, read_condition);\n-          if (ret != dds_RETCODE_OK) {\n-            RMW_SET_ERROR_MSG(\"failed to delete readcondition\");\n-            rmw_ret = RMW_RET_ERROR;\n-          }\n-          subscriber_info->read_condition = nullptr;\n-        }\n-"},{"role":"user","content":"-      } else if (subscriber_info->read_condition != nullptr) {\n-        RMW_SET_ERROR_MSG(\"cannot delete readcondition because the datareader is null\");\n-        rmw_ret = RMW_RET_ERROR;"},{"role":"user","content":"+    if (subscriber_info->queue_guard_condition != nullptr) {\n+      dds_GuardCondition_delete(subscriber_info->queue_guard_condition);\n+      subscriber_info->queue_guard_condition = nullptr;\n+    }\n+\n+    while (!subscriber_info->message_queue.empty()) {\n+      auto msg = subscriber_info->message_queue.front();\n+      if (msg.sample != nullptr) {\n+        free(msg.sample);\n+      }\n+      if (msg.info != nullptr) {\n+        free(msg.info);\n+      }\n+      subscriber_info->message_queue.pop();\n+    }\n+"},{"role":"user","content":"-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create data sequence\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample size sequence\");\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"rmw_gurumdds_cpp\", \"No data on topic %s\", topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n+  if (info->message_queue.empty()) {"},{"role":"user","content":"-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);"},{"role":"user","content":"-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n+  info->queue_mutex.lock();\n+  auto msg = info->message_queue.front();\n+  info->message_queue.pop();\n+  if (info->message_queue.empty()) {\n+    dds_GuardCondition_set_trigger_value(info->queue_guard_condition, false);"},{"role":"user","content":"-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+  info->queue_mutex.unlock();"},{"role":"user","content":"-  if (!sample_info->valid_data) {\n+  if (!msg.info->valid_data) {"},{"role":"user","content":"-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n-      RMW_SET_ERROR_MSG(\"failed to get message\");\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n+    if (msg.sample == nullptr) {\n+      RMW_SET_ERROR_MSG(\"Received invalid message\");\n+      free(msg.info);"},{"role":"user","content":"-    uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, 0);"},{"role":"user","content":"-      sample,\n-      static_cast<size_t>(sample_size)\n+      msg.sample,\n+      static_cast<size_t>(msg.size)"},{"role":"user","content":"-      RMW_SET_ERROR_MSG(\"failed to deserialize message\");\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n+      RMW_SET_ERROR_MSG(\"Failed to deserialize message\");\n+      free(msg.sample);\n+      free(msg.info);"},{"role":"user","content":"-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n+        msg.info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        msg.info->source_timestamp.nanosec;"},{"role":"user","content":"-        topic_reader, sample_info->publication_handle, custom_gid->publication_handle);\n+        topic_reader, msg.info->publication_handle, custom_gid->publication_handle);"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n+  if (msg.sample != nullptr) {\n+    free(msg.sample);\n+  }\n+  if (msg.info != nullptr) {\n+    free(msg.info);\n+  }"},{"role":"user","content":"-  dds_DataSeq * data_values = dds_DataSeq_create(count);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create data sequence\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(count);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(count);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample size sequence\");\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"rmw_gurumdds_cpp\", \"No data on topic %s\", topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n+  if (info->message_queue.empty()) {"},{"role":"user","content":"-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);\n-\n-  for (uint32_t i = 0; i < dds_SampleInfoSeq_length(sample_infos); i++) {\n-    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n-\n+  info->queue_mutex.lock();\n+  while (!info->message_queue.empty()) {\n+    auto msg = info->message_queue.front();\n+    info->message_queue.pop();\n+    if (info->message_queue.empty()) {\n+      dds_GuardCondition_set_trigger_value(info->queue_guard_condition, false);\n+    }"},{"role":"user","content":"-    if (!sample_info->valid_data) {\n+    if (!msg.info->valid_data) {"},{"role":"user","content":"-      void * sample = dds_DataSeq_get(data_values, i);\n-      if (sample == nullptr) {\n-        RMW_SET_ERROR_MSG(\"failed to get message\");\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n+      if (msg.sample == nullptr) {\n+        RMW_SET_ERROR_MSG(\"Received invalid message\");\n+        free(msg.info);"},{"role":"user","content":"-      uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);"},{"role":"user","content":"-        sample,\n-        static_cast<size_t>(sample_size)\n+        msg.sample,\n+        static_cast<size_t>(msg.size)"},{"role":"user","content":"-        RMW_SET_ERROR_MSG(\"failed to deserialize message\");\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n+        RMW_SET_ERROR_MSG(\"Failed to deserialize message\");\n+        free(msg.sample);\n+        free(msg.info);"},{"role":"user","content":"-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n+        msg.info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        msg.info->source_timestamp.nanosec;"},{"role":"user","content":"-        topic_reader, sample_info->publication_handle, custom_gid->publication_handle);\n+        topic_reader, msg.info->publication_handle, custom_gid->publication_handle);"},{"role":"user","content":"+\n+    if (msg.sample != nullptr) {\n+      free(msg.sample);\n+    }\n+    if (msg.info != nullptr) {\n+      free(msg.info);\n+    }"},{"role":"user","content":"+  info->queue_mutex.unlock();\n+\n+  // ============================================================================================="},{"role":"user","content":"-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n-"},{"role":"user","content":"-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create data sequence\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample info sequence\");\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\"failed to create sample size sequence\");\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"rmw_gurumdds_cpp\", \"No data on topic %s\", topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n+  if (info->message_queue.empty()) {"},{"role":"user","content":"-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \"rmw_gurumdds_cpp\", \"Received data on topic %s\", topic_name);"},{"role":"user","content":"-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n+  info->queue_mutex.lock();\n+  auto msg = info->message_queue.front();\n+  info->message_queue.pop();\n+  if (info->message_queue.empty()) {\n+    dds_GuardCondition_set_trigger_value(info->queue_guard_condition, false);"},{"role":"user","content":"-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+  info->queue_mutex.unlock();"},{"role":"user","content":"-  if (!sample_info->valid_data) {\n+  if (!msg.info->valid_data) {"},{"role":"user","content":"-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n-      RMW_SET_ERROR_MSG(\"failed to take data\");\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n+    if (msg.sample == nullptr) {\n+      RMW_SET_ERROR_MSG(\"Received invalid message\");\n+      free(msg.info);"},{"role":"user","content":"-    uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    serialized_message->buffer_length = sample_size;\n-    if (serialized_message->buffer_capacity < sample_size) {\n-      rmw_ret_t rmw_ret = rmw_serialized_message_resize(serialized_message, sample_size);\n+    serialized_message->buffer_length = msg.size;\n+    if (serialized_message->buffer_capacity < msg.size) {\n+      rmw_ret_t rmw_ret = rmw_serialized_message_resize(serialized_message, msg.size);"},{"role":"user","content":"-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n+        free(msg.sample);\n+        free(msg.info);"},{"role":"user","content":"-    memcpy(serialized_message->buffer, sample, sample_size);\n+    memcpy(serialized_message->buffer, msg.sample, msg.size);"},{"role":"user","content":"-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n+        msg.info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        msg.info->source_timestamp.nanosec;"},{"role":"user","content":"-        topic_reader, sample_info->publication_handle, custom_gid->publication_handle);\n+        topic_reader, msg.info->publication_handle, custom_gid->publication_handle);"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n+  if (msg.sample != nullptr) {\n+    free(msg.sample);\n+  }\n+  if (msg.info != nullptr) {\n+    free(msg.info);\n+  }"},{"role":"user","content":"-      dds_ReadCondition * read_condition = subscriber_info->read_condition;\n-      if (read_condition == nullptr) {\n+      dds_GuardCondition * queue_guard_condition = subscriber_info->queue_guard_condition;\n+      if (queue_guard_condition == nullptr) {"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"-      dds_ReadCondition * read_condition = service_info->read_condition;\n-      if (read_condition == nullptr) {\n+      dds_GuardCondition * queue_guard_condition = service_info->queue_guard_condition;\n+      if (queue_guard_condition == nullptr) {"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"-      dds_ReadCondition * read_condition = client_info->read_condition;\n-      if (read_condition == nullptr) {\n+      dds_GuardCondition * queue_guard_condition = client_info->queue_guard_condition;\n+      if (queue_guard_condition == nullptr) {"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"-      dds_ReadCondition * read_condition = subscriber_info->read_condition;\n-      if (!read_condition) {\n+      dds_GuardCondition * queue_guard_condition = subscriber_info->queue_guard_condition;\n+      if (!queue_guard_condition) {"},{"role":"user","content":"-          reinterpret_cast<dds_Condition *>(read_condition))\n+          reinterpret_cast<dds_Condition *>(queue_guard_condition))"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"-      dds_ReadCondition * read_condition = service_info->read_condition;\n-      if (read_condition == nullptr) {\n+      dds_GuardCondition * queue_guard_condition = service_info->queue_guard_condition;\n+      if (queue_guard_condition == nullptr) {"},{"role":"user","content":"-          reinterpret_cast<dds_Condition *>(read_condition))\n+          reinterpret_cast<dds_Condition *>(queue_guard_condition))"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"-      dds_ReadCondition * read_condition = client_info->read_condition;\n-      if (read_condition == nullptr) {\n+      dds_GuardCondition * queue_guard_condition = client_info->queue_guard_condition;\n+      if (queue_guard_condition == nullptr) {"},{"role":"user","content":"-          reinterpret_cast<dds_Condition *>(read_condition))\n+          reinterpret_cast<dds_Condition *>(queue_guard_condition))"},{"role":"user","content":"-        dds_wait_set, reinterpret_cast<dds_Condition *>(read_condition));\n+        dds_wait_set, reinterpret_cast<dds_Condition *>(queue_guard_condition));"},{"role":"user","content":"+#include <atomic>"},{"role":"user","content":"-#include <atomic>\n+#include <utility>"},{"role":"user","content":"+typedef struct _GurumddsMessage\n+{\n+  void * sample;\n+  dds_SampleInfo * info;\n+  dds_UnsignedLong size;\n+} GurumddsMessage;\n+"},{"role":"user","content":"+template<typename SubscriberInfo>\n+static void reader_on_data_available(const dds_DataReader * a_reader)\n+{\n+  const uint32_t MAX_SAMPLES = 64;\n+  dds_DataReader * reader = const_cast<dds_DataReader *>(a_reader);\n+  SubscriberInfo * subscriber_info =\n+    reinterpret_cast<SubscriberInfo *>(dds_DataReader_get_listener_context(reader));\n+  if (subscriber_info == nullptr) {\n+    RCUTILS_LOG_ERROR_NAMED(\"rmw_gurumdds_cpp\", \"Failed to take data: listener context is not set\");\n+    return;\n+  }\n+\n+  dds_DataSeq * sample_seq = dds_DataSeq_create(MAX_SAMPLES);\n+  if (sample_seq == nullptr) {\n+    return;\n+  }\n+\n+  dds_SampleInfoSeq * info_seq = dds_SampleInfoSeq_create(MAX_SAMPLES);\n+  if (info_seq == nullptr) {\n+    dds_DataSeq_delete(sample_seq);\n+    return;\n+  }\n+\n+  dds_UnsignedLongSeq * size_seq = dds_UnsignedLongSeq_create(MAX_SAMPLES);\n+  if (size_seq == nullptr) {\n+    dds_DataSeq_delete(sample_seq);\n+    dds_SampleInfoSeq_delete(info_seq);\n+    return;\n+  }\n+\n+  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n+    reader, dds_HANDLE_NIL, sample_seq, info_seq, size_seq, MAX_SAMPLES,\n+    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n+  if (ret != dds_RETCODE_OK) {\n+    if (ret != dds_RETCODE_NO_DATA) {\n+      RCUTILS_LOG_ERROR_NAMED(\"rmw_gurumdds_cpp\", \"Failed to take data\");\n+    }\n+    dds_DataSeq_delete(sample_seq);\n+    dds_SampleInfoSeq_delete(info_seq);\n+    dds_UnsignedLongSeq_delete(size_seq);\n+    return;\n+  }\n+\n+  subscriber_info->queue_mutex.lock();\n+  dds_GuardCondition_set_trigger_value(subscriber_info->queue_guard_condition, true);\n+  for (uint32_t i = 0; i < dds_DataSeq_length(sample_seq); i++) {\n+    GurumddsMessage msg;\n+    msg.sample = dds_DataSeq_get(sample_seq, i);\n+    msg.info = dds_SampleInfoSeq_get(info_seq, i);\n+    msg.size = dds_UnsignedLongSeq_get(size_seq, i);\n+    subscriber_info->message_queue.push(std::move(msg));\n+  }\n+  subscriber_info->queue_mutex.unlock();\n+\n+  // return loan manually after deserialization\n+  // or before destruction of the queue using free()\n+  dds_DataSeq_delete(sample_seq);\n+  dds_SampleInfoSeq_delete(info_seq);\n+  dds_UnsignedLongSeq_delete(size_seq);\n+}\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+  if(TEST cpplint_rosidl_generated_cpp)\n+    set_tests_properties(cpplint_rosidl_generated_cpp PROPERTIES TIMEOUT 180)\n+  endif()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <functional>\n+#include <memory>"},{"role":"user","content":"-#include <string>"},{"role":"user","content":"+#include \"rclcpp/context.hpp\"\n+#include \"rclcpp/guard_condition.hpp\""},{"role":"user","content":"+  /// Default destructor.\n+  RCLCPP_PUBLIC\n+  ~CallbackGroup();\n+"},{"role":"user","content":"+  /// Defer creating the notify guard condition and return it.\n+  RCLCPP_PUBLIC\n+  rclcpp::GuardCondition::SharedPtr\n+  get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr);\n+\n+  /// Trigger the notify guard condition.\n+  RCLCPP_PUBLIC\n+  void\n+  trigger_notify_guard_condition();\n+"},{"role":"user","content":"+  // defer the creation of the guard condition\n+  std::shared_ptr<rclcpp::GuardCondition> notify_guard_condition_ = nullptr;\n+  std::recursive_mutex notify_guard_condition_mutex_;"},{"role":"user","content":"-  typedef std::map<rclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n+  typedef std::map<rclcpp::CallbackGroup::WeakPtr,"},{"role":"user","content":"-      std::owner_less<rclcpp::node_interfaces::NodeBaseInterface::WeakPtr>>\n-    WeakNodesToGuardConditionsMap;\n+      std::owner_less<rclcpp::CallbackGroup::WeakPtr>>\n+    WeakCallbackGroupsToGuardConditionsMap;"},{"role":"user","content":"-  /// maps nodes to guard conditions\n-  WeakNodesToGuardConditionsMap\n-  weak_nodes_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+  /// maps callback groups to guard conditions\n+  WeakCallbackGroupsToGuardConditionsMap\n+  weak_groups_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);"},{"role":"user","content":"-#include \"rclcpp/callback_group.hpp\"\n+#include <algorithm>\n+#include <atomic>\n+#include <functional>\n+#include <memory>\n+#include <mutex>\n+#include <stdexcept>"},{"role":"user","content":"-#include <vector>\n+#include \"rclcpp/callback_group.hpp\"\n+#include \"rclcpp/client.hpp\"\n+#include \"rclcpp/service.hpp\"\n+#include \"rclcpp/subscription_base.hpp\"\n+#include \"rclcpp/timer.hpp\"\n+#include \"rclcpp/waitable.hpp\""},{"role":"user","content":"+CallbackGroup::~CallbackGroup()\n+{\n+  trigger_notify_guard_condition();\n+}"},{"role":"user","content":"+rclcpp::GuardCondition::SharedPtr\n+CallbackGroup::get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr)\n+{\n+  std::lock_guard<std::recursive_mutex> lock(notify_guard_condition_mutex_);\n+  if (notify_guard_condition_ && context_ptr != notify_guard_condition_->get_context()) {\n+    if (associated_with_executor_) {\n+      trigger_notify_guard_condition();\n+    }\n+    notify_guard_condition_ = nullptr;\n+  }\n+\n+  if (!notify_guard_condition_) {\n+    notify_guard_condition_ = std::make_shared<rclcpp::GuardCondition>(context_ptr);\n+  }\n+\n+  return notify_guard_condition_;\n+}\n+\n+void\n+CallbackGroup::trigger_notify_guard_condition()\n+{\n+  std::lock_guard<std::recursive_mutex> lock(notify_guard_condition_mutex_);\n+  if (notify_guard_condition_) {\n+    notify_guard_condition_->trigger();\n+  }\n+}\n+"},{"role":"user","content":"-  for (const auto & pair : weak_nodes_to_guard_conditions_) {\n+  for (const auto & pair : weak_groups_to_guard_conditions_) {"},{"role":"user","content":"-  weak_nodes_to_guard_conditions_.clear();\n+  weak_groups_to_guard_conditions_.clear();"},{"role":"user","content":"-  bool is_new_node = !has_node(node_ptr, weak_groups_to_nodes_associated_with_executor_) &&\n-    !has_node(node_ptr, weak_groups_associated_with_executor_to_nodes_);\n+"},{"role":"user","content":"-  if (is_new_node) {\n-    const auto & gc = node_ptr->get_notify_guard_condition();\n-    weak_nodes_to_guard_conditions_[node_ptr] = &gc;\n-    if (notify) {\n-      // Interrupt waiting to handle new node\n-      try {\n-        interrupt_guard_condition_.trigger();\n-      } catch (const rclcpp::exceptions::RCLError & ex) {\n-        throw std::runtime_error(\n-                std::string(\n-                  \"Failed to trigger guard condition on callback group add: \") + ex.what());\n-      }\n+\n+  if (node_ptr->get_context()->is_valid()) {\n+    auto callback_group_guard_condition =\n+      group_ptr->get_notify_guard_condition(node_ptr->get_context());\n+    weak_groups_to_guard_conditions_[weak_group_ptr] = callback_group_guard_condition.get();\n+    // Add the callback_group's notify condition to the guard condition handles\n+    memory_strategy_->add_guard_condition(*callback_group_guard_condition);\n+  }\n+\n+  if (notify) {\n+    // Interrupt waiting to handle new node\n+    try {\n+      interrupt_guard_condition_.trigger();\n+    } catch (const rclcpp::exceptions::RCLError & ex) {\n+      throw std::runtime_error(\n+              std::string(\n+                \"Failed to trigger guard condition on callback group add: \") + ex.what());"},{"role":"user","content":"-    // Add the node's notify condition to the guard condition handles\n-    memory_strategy_->add_guard_condition(gc);"},{"role":"user","content":"-    weak_nodes_to_guard_conditions_.erase(node_ptr);\n+    auto iter = weak_groups_to_guard_conditions_.find(weak_group_ptr);\n+    if (iter != weak_groups_to_guard_conditions_.end()) {\n+      memory_strategy_->remove_guard_condition(iter->second);\n+    }\n+    weak_groups_to_guard_conditions_.erase(weak_group_ptr);\n+"},{"role":"user","content":"-    memory_strategy_->remove_guard_condition(&node_ptr->get_notify_guard_condition());"},{"role":"user","content":"-          auto node_guard_pair = weak_nodes_to_guard_conditions_.find(weak_node_ptr);\n-          if (node_guard_pair != weak_nodes_to_guard_conditions_.end()) {\n-            auto guard_condition = node_guard_pair->second;\n-            weak_nodes_to_guard_conditions_.erase(weak_node_ptr);\n-            memory_strategy_->remove_guard_condition(guard_condition);\n-          }"},{"role":"user","content":"+          auto callback_guard_pair = weak_groups_to_guard_conditions_.find(group_ptr);\n+          if (callback_guard_pair != weak_groups_to_guard_conditions_.end()) {\n+            auto guard_condition = callback_guard_pair->second;\n+            weak_groups_to_guard_conditions_.erase(group_ptr);\n+            memory_strategy_->remove_guard_condition(guard_condition);\n+          }"},{"role":"user","content":"-    group->add_service(service_base_ptr);"},{"role":"user","content":"-    node_base_->get_default_callback_group()->add_service(service_base_ptr);\n+    group = node_base_->get_default_callback_group();"},{"role":"user","content":"+  group->add_service(service_base_ptr);\n+"},{"role":"user","content":"+    group->trigger_notify_guard_condition();"},{"role":"user","content":"-    group->add_client(client_base_ptr);"},{"role":"user","content":"-    node_base_->get_default_callback_group()->add_client(client_base_ptr);\n+    group = node_base_->get_default_callback_group();"},{"role":"user","content":"+  group->add_client(client_base_ptr);\n+"},{"role":"user","content":"+    group->trigger_notify_guard_condition();"},{"role":"user","content":"-    callback_group->add_timer(timer);"},{"role":"user","content":"-    node_base_->get_default_callback_group()->add_timer(timer);\n+    callback_group = node_base_->get_default_callback_group();"},{"role":"user","content":"+  callback_group->add_timer(timer);"},{"role":"user","content":"+    callback_group->trigger_notify_guard_condition();"},{"role":"user","content":"+    callback_group->trigger_notify_guard_condition();"},{"role":"user","content":"+    callback_group->trigger_notify_guard_condition();"},{"role":"user","content":"-    group->add_waitable(waitable_ptr);"},{"role":"user","content":"-    node_base_->get_default_callback_group()->add_waitable(waitable_ptr);\n+    group = node_base_->get_default_callback_group();"},{"role":"user","content":"+  group->add_waitable(waitable_ptr);\n+"},{"role":"user","content":"+    group->trigger_notify_guard_condition();"},{"role":"user","content":"-ament_add_gtest(test_add_callback_groups_to_executor\n-  test_add_callback_groups_to_executor.cpp\n-  TIMEOUT 120)\n-if(TARGET test_add_callback_groups_to_executor)\n-  target_link_libraries(test_add_callback_groups_to_executor ${PROJECT_NAME})\n-  ament_target_dependencies(test_add_callback_groups_to_executor\n-    \"test_msgs\"\n+function(test_add_callback_groups_to_executor_for_rmw_implementation)\n+  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n+  ament_add_gmock(test_add_callback_groups_to_executor${target_suffix} test_add_callback_groups_to_executor.cpp\n+    ENV ${rmw_implementation_env_var}\n+    TIMEOUT 120"},{"role":"user","content":"-endif()\n+  if(TARGET test_add_callback_groups_to_executor${target_suffix})\n+    target_link_libraries(test_add_callback_groups_to_executor${target_suffix} ${PROJECT_NAME})\n+    ament_target_dependencies(test_add_callback_groups_to_executor${target_suffix}\n+      \"test_msgs\"\n+    )\n+  endif()\n+endfunction()\n+call_for_each_rmw_implementation(test_add_callback_groups_to_executor_for_rmw_implementation)"},{"role":"user","content":"+/*\n+ * Test callback groups from one node to many executors.\n+ * A subscriber on a new executor with a callback group not received a message\n+ * because the executor can't be triggered while a subscriber created, see\n+ * https://github.com/ros2/rclcpp/issues/1611\n+*/\n+TYPED_TEST(TestAddCallbackGroupsToExecutor, subscriber_triggered_to_receive_message)\n+{\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\");\n+\n+  // create a thread running an executor with a new callback group for a coming subscriber\n+  rclcpp::CallbackGroup::SharedPtr cb_grp = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive, false);\n+  rclcpp::executors::SingleThreadedExecutor cb_grp_executor;\n+\n+  std::promise<bool> received_message_promise;\n+  auto received_message_future = received_message_promise.get_future();\n+  rclcpp::FutureReturnCode return_code = rclcpp::FutureReturnCode::TIMEOUT;\n+  std::thread cb_grp_thread = std::thread(\n+    [&cb_grp, &node, &cb_grp_executor, &received_message_future, &return_code]() {\n+      cb_grp_executor.add_callback_group(cb_grp, node->get_node_base_interface());\n+      return_code = cb_grp_executor.spin_until_future_complete(received_message_future, 10s);\n+    });\n+\n+  // expect the subscriber to receive a message\n+  auto sub_callback = [&received_message_promise](test_msgs::msg::Empty::ConstSharedPtr) {\n+      received_message_promise.set_value(true);\n+    };\n+\n+  rclcpp::Subscription<test_msgs::msg::Empty>::SharedPtr subscription;\n+  rclcpp::Publisher<test_msgs::msg::Empty>::SharedPtr publisher;\n+  // to create a timer with a callback run on another executor\n+  rclcpp::TimerBase::SharedPtr timer = nullptr;\n+  std::promise<void> timer_promise;\n+  auto timer_callback =\n+    [&subscription, &publisher, &timer, &cb_grp, &node, &sub_callback, &timer_promise]() {\n+      if (timer) {\n+        timer.reset();\n+      }\n+\n+      // create a subscription using the `cb_grp` callback group\n+      rclcpp::QoS qos = rclcpp::QoS(1).reliable();\n+      auto options = rclcpp::SubscriptionOptions();\n+      options.callback_group = cb_grp;\n+      subscription =\n+        node->create_subscription<test_msgs::msg::Empty>(\"topic_name\", qos, sub_callback, options);\n+      // create a publisher to send data\n+      publisher =\n+        node->create_publisher<test_msgs::msg::Empty>(\"topic_name\", qos);\n+      publisher->publish(test_msgs::msg::Empty());\n+      timer_promise.set_value();\n+    };\n+\n+  rclcpp::executors::SingleThreadedExecutor timer_executor;\n+  timer = node->create_wall_timer(100ms, timer_callback);\n+  timer_executor.add_node(node);\n+  auto future = timer_promise.get_future();\n+  timer_executor.spin_until_future_complete(future);\n+  cb_grp_thread.join();\n+\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  EXPECT_TRUE(received_message_future.get());\n+}\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  /**\n+   * Cancels an ongoing or future sleep operation of one thread.\n+   *\n+   * This function can be used by one thread, to wakeup another thread that is\n+   * blocked using any of the sleep_ or wait_ methods of this class.\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  cancel_sleep_or_wait();\n+"},{"role":"user","content":"-  void\n+  virtual void"},{"role":"user","content":"-  void\n+  virtual void"},{"role":"user","content":"-  void\n+  virtual void"},{"role":"user","content":"-  void\n+  virtual void"},{"role":"user","content":"-    // TODO(wjwwood): does not work recursively; can't call spin_node_until_future_complete\n-    // inside a callback executed by an executor.\n-\n-    // Check the future before entering the while loop.\n-    // If the future is already complete, don't try to spin.\n-    std::future_status status = future.wait_for(std::chrono::seconds(0));\n-    if (status == std::future_status::ready) {\n-      return FutureReturnCode::SUCCESS;\n-    }\n-\n-    auto end_time = std::chrono::steady_clock::now();\n-    std::chrono::nanoseconds timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(\n-      timeout);\n-    if (timeout_ns > std::chrono::nanoseconds::zero()) {\n-      end_time += timeout_ns;\n-    }\n-    std::chrono::nanoseconds timeout_left = timeout_ns;\n-\n-    if (spinning.exchange(true)) {\n-      throw std::runtime_error(\"spin_until_future_complete() called while already spinning\");\n-    }\n-    RCPPUTILS_SCOPE_EXIT(this->spinning.store(false); );\n-    while (rclcpp::ok(this->context_) && spinning.load()) {\n-      // Do one item of work.\n-      spin_once_impl(timeout_left);\n-\n-      // Check if the future is set, return SUCCESS if it is.\n-      status = future.wait_for(std::chrono::seconds(0));\n-      if (status == std::future_status::ready) {\n-        return FutureReturnCode::SUCCESS;\n-      }\n-      // If the original timeout is < 0, then this is blocking, never TIMEOUT.\n-      if (timeout_ns < std::chrono::nanoseconds::zero()) {\n-        continue;\n+    return spin_until_future_complete_impl(\n+      std::chrono::duration_cast<std::chrono::nanoseconds>(timeout),\n+      [&future](std::chrono::nanoseconds wait_time) {\n+        return future.wait_for(wait_time);"},{"role":"user","content":"-      // Otherwise check if we still have time to wait, return TIMEOUT if not.\n-      auto now = std::chrono::steady_clock::now();\n-      if (now >= end_time) {\n-        return FutureReturnCode::TIMEOUT;\n-      }\n-      // Subtract the elapsed time from the original timeout.\n-      timeout_left = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time - now);\n-    }\n-\n-    // The future did not complete before ok() returned false, return INTERRUPTED.\n-    return FutureReturnCode::INTERRUPTED;\n+    );"},{"role":"user","content":"-  void\n+  virtual void"},{"role":"user","content":"+  /// Constructor that will not initialize any non-trivial members.\n+  /**\n+  * This constructor is intended to be used by any derived executor\n+  * that explicitly does not want to use the default implementation provided\n+  * by this class.\n+  */\n+  explicit Executor(const std::shared_ptr<rclcpp::Context> & context);\n+"},{"role":"user","content":"+  /// Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.\n+  /**\n+   * \\sa spin_until_future_complete()\n+   * The only difference with spin_until_future_complete() is that the future's\n+   * type is obscured through a std::function which lets you wait on it\n+   * reguardless of type.\n+   *\n+   * \\param[in] timeout see spin_until_future_complete() for details\n+   * \\param[in] wait_for_future function to wait on the future and get the\n+   *   status after waiting\n+   */\n+  RCLCPP_PUBLIC\n+  virtual FutureReturnCode\n+  spin_until_future_complete_impl(\n+    std::chrono::nanoseconds timeout,\n+    const std::function<std::future_status(std::chrono::nanoseconds wait_time)> & wait_for_future);\n+"},{"role":"user","content":"+  bool stop_sleeping_ = false;\n+  bool shutdown_ = false;\n+  std::condition_variable cv_;\n+  std::mutex wait_mutex_;"},{"role":"user","content":"+void\n+Clock::cancel_sleep_or_wait()\n+{\n+  {\n+    std::unique_lock lock(impl_->wait_mutex_);\n+    impl_->stop_sleeping_ = true;\n+  }\n+  impl_->cv_.notify_one();\n+}\n+"},{"role":"user","content":"-Clock::sleep_until(Time until, Context::SharedPtr context)\n+Clock::sleep_until(\n+  Time until,\n+  Context::SharedPtr context)"},{"role":"user","content":"-  std::condition_variable cv;\n-"},{"role":"user","content":"-    [&cv]() {\n-      cv.notify_one();\n+    [this]() {\n+      {\n+        std::unique_lock lock(impl_->wait_mutex_);\n+        impl_->shutdown_ = true;\n+      }\n+      impl_->cv_.notify_one();"},{"role":"user","content":"-    // loop over spurious wakeups but notice shutdown\n-    std::unique_lock lock(impl_->clock_mutex_);\n-    while (now() < until && context->is_valid()) {\n-      cv.wait_until(lock, chrono_until);\n+    // loop over spurious wakeups but notice shutdown or stop of sleep\n+    std::unique_lock lock(impl_->wait_mutex_);\n+    while (now() < until && !impl_->stop_sleeping_ && !impl_->shutdown_ && context->is_valid()) {\n+      impl_->cv_.wait_until(lock, chrono_until);"},{"role":"user","content":"+    impl_->stop_sleeping_ = false;"},{"role":"user","content":"-    // loop over spurious wakeups but notice shutdown\n-    std::unique_lock lock(impl_->clock_mutex_);\n-    while (now() < until && context->is_valid()) {\n-      cv.wait_until(lock, system_time);\n+    // loop over spurious wakeups but notice shutdown or stop of sleep\n+    std::unique_lock lock(impl_->wait_mutex_);\n+    while (now() < until && !impl_->stop_sleeping_ && !impl_->shutdown_ && context->is_valid()) {\n+      impl_->cv_.wait_until(lock, system_time);"},{"role":"user","content":"+    impl_->stop_sleeping_ = false;"},{"role":"user","content":"-      [&cv, &time_source_changed](const rcl_time_jump_t & jump) {\n+      [this, &time_source_changed](const rcl_time_jump_t & jump) {"},{"role":"user","content":"+          std::lock_guard<std::mutex> lk(impl_->wait_mutex_);"},{"role":"user","content":"-        cv.notify_one();\n+        impl_->cv_.notify_one();"},{"role":"user","content":"-      // loop over spurious wakeups but notice shutdown or time source change\n-      std::unique_lock lock(impl_->clock_mutex_);\n-      while (now() < until && context->is_valid() && !time_source_changed) {\n-        cv.wait_until(lock, system_time);\n+      // loop over spurious wakeups but notice shutdown, stop of sleep or time source change\n+      std::unique_lock lock(impl_->wait_mutex_);\n+      while (now() < until && !impl_->stop_sleeping_ && !impl_->shutdown_ && context->is_valid() &&\n+        !time_source_changed)\n+      {\n+        impl_->cv_.wait_until(lock, system_time);"},{"role":"user","content":"+      impl_->stop_sleeping_ = false;"},{"role":"user","content":"-      std::unique_lock lock(impl_->clock_mutex_);\n-      while (now() < until && context->is_valid() && !time_source_changed) {\n-        cv.wait(lock);\n+      std::unique_lock lock(impl_->wait_mutex_);\n+      while (now() < until && !impl_->stop_sleeping_ && !impl_->shutdown_ && context->is_valid() &&\n+        !time_source_changed)\n+      {\n+        impl_->cv_.wait(lock);"},{"role":"user","content":"+      impl_->stop_sleeping_ = false;"},{"role":"user","content":"+Executor::Executor(const std::shared_ptr<rclcpp::Context> & context)\n+: spinning(false),\n+  entities_need_rebuild_(true),\n+  collector_(nullptr),\n+  wait_set_({}, {}, {}, {}, {}, {}, context)\n+{\n+}\n+"},{"role":"user","content":"-void Executor::trigger_entity_recollect(bool notify)\n+void\n+Executor::trigger_entity_recollect(bool notify)"},{"role":"user","content":"+rclcpp::FutureReturnCode\n+Executor::spin_until_future_complete_impl(\n+  std::chrono::nanoseconds timeout,\n+  const std::function<std::future_status(std::chrono::nanoseconds wait_time)> & wait_for_future)\n+{\n+  // TODO(wjwwood): does not work recursively; can't call spin_node_until_future_complete\n+  // inside a callback executed by an executor.\n+\n+  // Check the future before entering the while loop.\n+  // If the future is already complete, don't try to spin.\n+  std::future_status status = wait_for_future(std::chrono::seconds(0));\n+  if (status == std::future_status::ready) {\n+    return FutureReturnCode::SUCCESS;\n+  }\n+\n+  auto end_time = std::chrono::steady_clock::now();\n+  std::chrono::nanoseconds timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(\n+    timeout);\n+  if (timeout_ns > std::chrono::nanoseconds::zero()) {\n+    end_time += timeout_ns;\n+  }\n+  std::chrono::nanoseconds timeout_left = timeout_ns;\n+\n+  if (spinning.exchange(true)) {\n+    throw std::runtime_error(\"spin_until_future_complete() called while already spinning\");\n+  }\n+  RCPPUTILS_SCOPE_EXIT(this->spinning.store(false); );\n+  while (rclcpp::ok(this->context_) && spinning.load()) {\n+    // Do one item of work.\n+    spin_once_impl(timeout_left);\n+\n+    // Check if the future is set, return SUCCESS if it is.\n+    status = wait_for_future(std::chrono::seconds(0));\n+    if (status == std::future_status::ready) {\n+      return FutureReturnCode::SUCCESS;\n+    }\n+    // If the original timeout is < 0, then this is blocking, never TIMEOUT.\n+    if (timeout_ns < std::chrono::nanoseconds::zero()) {\n+      continue;\n+    }\n+    // Otherwise check if we still have time to wait, return TIMEOUT if not.\n+    auto now = std::chrono::steady_clock::now();\n+    if (now >= end_time) {\n+      return FutureReturnCode::TIMEOUT;\n+    }\n+    // Subtract the elapsed time from the original timeout.\n+    timeout_left = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time - now);\n+  }\n+\n+  // The future did not complete before ok() returned false, return INTERRUPTED.\n+  return FutureReturnCode::INTERRUPTED;\n+}\n+"},{"role":"user","content":"+ament_add_gtest(test_clock test_clock.cpp)\n+if(TARGET test_clock)\n+  target_link_libraries(test_clock ${PROJECT_NAME} mimick ${rcl_interfaces_TARGETS} ${test_msgs_TARGETS})\n+endif()"},{"role":"user","content":"+// Copyright 2024 Cellumation GmbH\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <chrono>\n+\n+#include \"rcl/error_handling.h\"\n+#include \"rcl/time.h\"\n+#include \"rclcpp/clock.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+#include \"rclcpp/time_source.hpp\"\n+\n+#include \"../utils/rclcpp_gtest_macros.hpp\"\n+\n+using namespace std::chrono_literals;\n+\n+class TestClockWakeup : public ::testing::TestWithParam<rcl_clock_type_e>\n+{\n+public:\n+  void test_wakeup_before_sleep(const rclcpp::Clock::SharedPtr & clock)\n+  {\n+    std::atomic_bool thread_finished = false;\n+\n+    std::thread wait_thread = std::thread(\n+      [&clock, &thread_finished]()\n+      {\n+        // make sure the thread starts sleeping late\n+        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+        clock->sleep_until(clock->now() + std::chrono::seconds(3));\n+        thread_finished = true;\n+      });\n+\n+    // notify the clock, that the sleep shall be interrupted\n+    clock->cancel_sleep_or_wait();\n+\n+    auto start_time = std::chrono::steady_clock::now();\n+    auto cur_time = start_time;\n+    while (!thread_finished && start_time + std::chrono::seconds(1) > cur_time) {\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+      cur_time = std::chrono::steady_clock::now();\n+    }\n+\n+    wait_thread.join();\n+\n+    EXPECT_TRUE(thread_finished);\n+    EXPECT_LT(cur_time, start_time + std::chrono::seconds(1));\n+  }\n+\n+  void test_wakeup_after_sleep(const rclcpp::Clock::SharedPtr & clock)\n+  {\n+    std::atomic_bool thread_finished = false;\n+\n+    std::thread wait_thread = std::thread(\n+      [&clock, &thread_finished]()\n+      {\n+        clock->sleep_until(clock->now() + std::chrono::seconds(3));\n+        thread_finished = true;\n+      });\n+\n+    // make sure the thread is already sleeping before we send the cancel\n+    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+\n+    // notify the clock, that the sleep shall be interrupted\n+    clock->cancel_sleep_or_wait();\n+\n+    auto start_time = std::chrono::steady_clock::now();\n+    auto cur_time = start_time;\n+    while (!thread_finished && start_time + std::chrono::seconds(1) > cur_time) {\n+      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+      cur_time = std::chrono::steady_clock::now();\n+    }\n+\n+    wait_thread.join();\n+\n+    EXPECT_TRUE(thread_finished);\n+    EXPECT_LT(cur_time, start_time + std::chrono::seconds(1));\n+  }\n+\n+protected:\n+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  void SetUp()\n+  {\n+    node = std::make_shared<rclcpp::Node>(\"my_node\");\n+  }\n+\n+  void TearDown()\n+  {\n+    node.reset();\n+  }\n+\n+  rclcpp::Node::SharedPtr node;\n+};\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  Clocks,\n+  TestClockWakeup,\n+  ::testing::Values(\n+    RCL_SYSTEM_TIME, RCL_ROS_TIME, RCL_STEADY_TIME\n+));\n+\n+TEST_P(TestClockWakeup, wakeup_sleep) {\n+  auto clock = std::make_shared<rclcpp::Clock>(GetParam());\n+  test_wakeup_after_sleep(clock);\n+  test_wakeup_before_sleep(clock);\n+}\n+\n+TEST_F(TestClockWakeup, wakeup_sleep_ros_time_active) {\n+  node->set_parameter({\"use_sim_time\", true});\n+  auto clock = std::make_shared<rclcpp::Clock>(RCL_ROS_TIME);\n+  rclcpp::TimeSource time_source(node);\n+  time_source.attachClock(clock);\n+\n+  EXPECT_TRUE(clock->ros_time_is_active());\n+\n+  test_wakeup_after_sleep(clock);\n+  test_wakeup_before_sleep(clock);\n+}\n+\n+TEST_F(TestClockWakeup, no_wakeup_on_sim_time) {\n+  node->set_parameter({\"use_sim_time\", true});\n+  auto clock = std::make_shared<rclcpp::Clock>(RCL_ROS_TIME);\n+  rclcpp::TimeSource time_source(node);\n+  time_source.attachClock(clock);\n+\n+  EXPECT_TRUE(clock->ros_time_is_active());\n+\n+  std::atomic_bool thread_finished = false;\n+\n+  std::thread wait_thread = std::thread(\n+    [&clock, &thread_finished]()\n+    {\n+      // make sure the thread starts sleeping late\n+      clock->sleep_until(clock->now() + std::chrono::milliseconds(10));\n+      thread_finished = true;\n+    });\n+\n+  // make sure, that the sim time clock does not wakeup, as no clock is provided\n+  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n+  EXPECT_FALSE(thread_finished);\n+\n+  // notify the clock, that the sleep shall be interrupted\n+  clock->cancel_sleep_or_wait();\n+\n+  auto start_time = std::chrono::steady_clock::now();\n+  auto cur_time = start_time;\n+  while (!thread_finished && start_time + std::chrono::seconds(1) > cur_time) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+    cur_time = std::chrono::steady_clock::now();\n+  }\n+\n+  wait_thread.join();\n+\n+  EXPECT_TRUE(thread_finished);\n+  EXPECT_LT(cur_time, start_time + std::chrono::seconds(1));\n+}\n+\n+TEST_F(TestClockWakeup, multiple_threads_wait_on_one_clock) {\n+  auto clock = std::make_shared<rclcpp::Clock>(RCL_ROS_TIME);\n+\n+  std::vector<bool> thread_finished(10, false);\n+\n+  std::vector<std::thread> threads;\n+\n+  for (size_t nr = 0; nr < thread_finished.size(); nr++) {\n+    threads.push_back(\n+      std::thread(\n+        [&clock, &thread_finished, nr]()\n+        {\n+          // make sure the thread starts sleeping late\n+          clock->sleep_until(clock->now() + std::chrono::seconds(10));\n+          thread_finished[nr] = true;\n+        }));\n+  }\n+\n+  // wait a bit so all threads can execute the sleep_until\n+  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n+\n+  for (const bool & finished : thread_finished) {\n+    EXPECT_FALSE(finished);\n+  }\n+\n+  rclcpp::shutdown();\n+\n+  auto start_time = std::chrono::steady_clock::now();\n+  auto cur_time = start_time;\n+  bool threads_finished = false;\n+  while (!threads_finished && start_time + std::chrono::seconds(1) > cur_time) {\n+    threads_finished = true;\n+    for (const bool finished : thread_finished) {\n+      if (!finished) {\n+        threads_finished = false;\n+      }\n+    }\n+\n+    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+    cur_time = std::chrono::steady_clock::now();\n+  }\n+\n+  for (const bool finished : thread_finished) {\n+    EXPECT_TRUE(finished);\n+  }\n+\n+  for (auto & thread : threads) {\n+    thread.join();\n+  }\n+\n+  EXPECT_LT(cur_time, start_time + std::chrono::seconds(1));\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  // result_tuple now owns the message\n-  taken_response.release();"},{"role":"user","content":"-  taken_request.release();"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+TEST_F(TestExecutor, spin_until_future_complete_in_spin_until_future_complete) {\n+  DummyExecutor dummy;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  bool spin_until_future_complete_in_spin_until_future_complete = false;\n+  auto timer =\n+    node->create_wall_timer(\n+    std::chrono::milliseconds(1), [&]() {\n+      try {\n+        std::promise<void> promise;\n+        std::future<void> future = promise.get_future();\n+        dummy.spin_until_future_complete(future, std::chrono::milliseconds(1));\n+      } catch (const std::runtime_error & err) {\n+        if (err.what() == std::string(\n+          \"spin_until_future_complete() called while already spinning\"))\n+        {\n+          spin_until_future_complete_in_spin_until_future_complete = true;\n+        }\n+      }\n+    });\n+\n+  dummy.add_node(node);\n+  // Wait for the wall timer to have expired.\n+  std::this_thread::sleep_for(std::chrono::milliseconds(50));\n+  EXPECT_FALSE(spin_until_future_complete_in_spin_until_future_complete);\n+  std::promise<void> promise;\n+  std::future<void> future = promise.get_future();\n+  dummy.spin_until_future_complete(future, std::chrono::milliseconds(1));\n+  EXPECT_TRUE(spin_until_future_complete_in_spin_until_future_complete);\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff\n+      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff &&\n+      ${Patch_EXECUTABLE} -p1 -N < ${CMAKE_CURRENT_SOURCE_DIR}/relocatable.patch"},{"role":"user","content":"+diff -uNr a/CMake/InstallResources.cmake b/CMake/InstallResources.cmake\n+--- a/CMake/InstallResources.cmake\t2022-05-09 17:30:13.273565553 -0700\n++++ b/CMake/InstallResources.cmake\t2022-05-09 17:29:53.013345872 -0700\n+@@ -59,6 +59,20 @@\n+   endif()\n+ endif()\n+ \n++# ensure installation is relocatable\n++if (IS_ABSOLUTE \"${OGRE_MEDIA_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_MEDIA_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_MEDIA_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_TEST_MEDIA_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_TEST_MEDIA_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_TEST_MEDIA_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_PLUGIN_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_PLUGIN_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_PLUGIN_DIR_REL}\")\n++endif ()\n++if (IS_ABSOLUTE \"${OGRE_SAMPLES_DIR_REL}\")\n++  file(RELATIVE_PATH OGRE_SAMPLES_DIR_REL \"${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\" \"${OGRE_SAMPLES_DIR_REL}\")\n++endif ()\n++\n+ # configure plugins.cfg\n+ if (NOT OGRE_BUILD_RENDERSYSTEM_D3D9)\n+   set(OGRE_COMMENT_RENDERSYSTEM_D3D9 \"#\")"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-      RMW_SET_ERROR_MSG(\"Failed to deserialize sample into laoned memory\");\n+      RMW_SET_ERROR_MSG(\"Failed to deserialize sample into loaned memory\");"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-target_link_libraries(test_loaned_message ${PROJECT_NAME})\n+target_link_libraries(test_loaned_message ${PROJECT_NAME} mimick)"},{"role":"user","content":"+#include \"../mocking_utils/patch.hpp\"\n+"},{"role":"user","content":"+\n+TEST_F(TestLoanedMessage, construct_with_loaned_message_publisher) {\n+  auto node = std::make_shared<rclcpp::Node>(\"loaned_message_test_node\");\n+  auto publisher = node->create_publisher<MessageT>(\"topic\", 10);\n+  std::allocator<MessageT> allocator;\n+\n+  auto mock_can_loan = mocking_utils::patch_and_return(\n+    \"lib:rclcpp\", rcl_publisher_can_loan_messages, true);\n+\n+  {\n+    auto mock_borrow_loaned = mocking_utils::patch_and_return(\n+      \"self\", rcl_borrow_loaned_message, RCL_RET_ERROR);\n+\n+    EXPECT_THROW(\n+      std::make_shared<LoanedMessageT>(*publisher.get(), allocator).reset(),\n+      rclcpp::exceptions::RCLError);\n+  }\n+\n+  MessageT message;\n+  auto borrow_loaned_message_callback =\n+    [&message](\n+    const rcl_publisher_t *, const rosidl_message_type_support_t *, void ** ros_message) {\n+      *ros_message = &message;\n+      return RCL_RET_OK;\n+    };\n+  auto mock_borrow_loaned = mocking_utils::patch(\n+    \"self\", rcl_borrow_loaned_message, borrow_loaned_message_callback);\n+\n+  {\n+    auto mock_return_loaned = mocking_utils::patch_and_return(\n+      \"self\", rcl_return_loaned_message_from_publisher, RCL_RET_OK);\n+\n+    auto loaned_message = std::make_shared<LoanedMessageT>(*publisher.get(), allocator);\n+    EXPECT_TRUE(loaned_message->is_valid());\n+    EXPECT_NO_THROW(loaned_message.reset());\n+  }\n+\n+  {\n+    auto loaned_message = std::make_shared<LoanedMessageT>(*publisher.get(), allocator);\n+    EXPECT_TRUE(loaned_message->is_valid());\n+\n+    auto mock_return_loaned = mocking_utils::patch_and_return(\n+      \"self\", rcl_return_loaned_message_from_publisher, RCL_RET_ERROR);\n+\n+    // No exception, it just logs an error\n+    EXPECT_NO_THROW(loaned_message.reset());\n+  }\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+typedef enum RMW_PUBLIC_TYPE rmw_qos_compatibility_type_t\n+{\n+  /// QoS policies are compatible\n+  RMW_QOS_COMPATIBILITY_OK = 0,\n+\n+  /// QoS policies may not be compatible\n+  RMW_QOS_COMPATIBILITY_WARNING,\n+\n+  /// QoS policies are not compatible\n+  RMW_QOS_COMPATIBILITY_ERROR\n+} rmw_qos_compatibility_type_t;\n+\n+\n+/// Check if two QoS profiles are compatible.\n+/**\n+ * Two QoS profiles are compatible if a publisher and subcription\n+ * using the QoS policies can communicate with each other.\n+ *\n+ * If any of the profile policies has the value \"system default\" or \"unknown\", then it may not be\n+ * possible to determine the compatibilty.\n+ * In this case, the output parameter `compatibility` is set to `RMW_QOS_COMPATIBILITY_WARNING`\n+ * and `reason` is populated.\n+ *\n+ * If there is a compatibility warning or error, and a buffer is provided for `reason`, then an\n+ * explanation of all warnings and errors will be populated into the buffer, separated by\n+ * semi-colons (`;`).\n+ * Errors will appear before warnings in the string buffer.\n+ * If the provided buffer is not large enough, this function will still write to the buffer, up to\n+ * the `reason_size` number of characters.\n+ * Therefore, it is possible that not all errors and warnings are communicated if the buffer size limit\n+ * is reached.\n+ * A buffer size of 2048 should be more than enough to capture all possible errors and warnings.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | No\n+ * Lock-Free          | Yes\n+ *\n+ * \\param[in] publisher_profile: The QoS profile used for a publisher.\n+ * \\param[in] subscription_profile: The QoS profile used for a subscription.\n+ * \\param[out] compatibility: `RMW_QOS_COMPATIBILITY_OK` if the QoS profiles are compatible, or\n+ *   `RMW_QOS_COMPATIBILITY_WARNING` if the QoS profiles might be compatible, or\n+ *   `RMW_QOS_COMPATIBILITY_ERROR` if the QoS profiles are not compatible.\n+ * \\param[out] reason: A detailed reason for a QoS incompatibility or potential incompatibility.\n+ *   Must be pre-allocated by the caller.\n+ *   This parameter is optional and may be set to `NULL` if the reason information is not\n+ *   desired.\n+ * \\param[in] reason_size: Size of the string buffer `reason`, if one is provided.\n+ *   If `reason` is `nullptr`, then this parameter must be zero.\n+ * \\return `RMW_RET_OK` if the check was successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `compatiblity` is `nullptr`, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `reason` is `NULL` and  `reason_size` is not zero, or\n+ * \\return `RMW_RET_ERROR` if there is an unexpected error.\n+ */\n+RMW_PUBLIC\n+RMW_WARN_UNUSED\n+rmw_ret_t\n+rmw_qos_profile_check_compatible(\n+  const rmw_qos_profile_t publisher_profile,\n+  const rmw_qos_profile_t subscription_profile,\n+  rmw_qos_compatibility_type_t * compatibility,\n+  char * reason,\n+  size_t reason_size);\n+"},{"role":"user","content":"+ * - A function to validate the compatibility of two QoS profiles\n+ *   - rmw_qos_profile_check_compatible()\n+ *   - rmw/qos_profiles.h"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <string>\n+#include <chrono>\n+#include <functional>\n+#include <future>"},{"role":"user","content":"+#include <stdexcept>\n+#include <string>\n+#include <vector>"},{"role":"user","content":"+\n+/*\n+  Coverage for async get_parameter_types\n+ */\n+TEST_F(TestParameterClient, async_parameter_get_parameter_types) {\n+  auto asynchronous_client = std::make_shared<rclcpp::AsyncParametersClient>(node);\n+  bool callback_called = false;\n+  auto callback = [&callback_called](std::shared_future<std::vector<rclcpp::ParameterType>> result)\n+    {\n+      // We expect the result to be empty since we tried to get a parameter that didn't exist.\n+      if (result.valid() && result.get().size() == 0) {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<std::string> names{\"foo\"};\n+  std::shared_future<std::vector<rclcpp::ParameterType>> future =\n+    asynchronous_client->get_parameter_types(names, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n+    node, future, std::chrono::milliseconds(100));\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  ASSERT_TRUE(callback_called);\n+}\n+\n+/*\n+  Coverage for async get_parameters\n+ */\n+TEST_F(TestParameterClient, async_parameter_get_parameters) {\n+  auto asynchronous_client = std::make_shared<rclcpp::AsyncParametersClient>(node);\n+  bool callback_called = false;\n+  auto callback = [&callback_called](std::shared_future<std::vector<rclcpp::Parameter>> result)\n+    {\n+      if (result.valid() && result.get().size() == 1 && result.get()[0].get_name() == \"foo\") {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<std::string> names{\"foo\"};\n+  std::shared_future<std::vector<rclcpp::Parameter>> future = asynchronous_client->get_parameters(\n+    names, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n+    node, future, std::chrono::milliseconds(100));\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  ASSERT_TRUE(callback_called);\n+}\n+\n+/*\n+  Coverage for async set_parameters_atomically\n+ */\n+TEST_F(TestParameterClient, async_parameter_set_parameters_atomically) {\n+  auto asynchronous_client = std::make_shared<rclcpp::AsyncParametersClient>(node);\n+  bool callback_called = false;\n+  auto callback =\n+    [&callback_called](std::shared_future<rcl_interfaces::msg::SetParametersResult> result)\n+    {\n+      // We expect this to fail since we didn't declare the parameter first.\n+      if (result.valid() && !result.get().successful &&\n+        result.get().reason == \"One or more parameters were not declared before setting\")\n+      {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<rclcpp::Parameter> parameters;\n+  parameters.emplace_back(rclcpp::Parameter(\"foo\"));\n+  std::shared_future<rcl_interfaces::msg::SetParametersResult> future =\n+    asynchronous_client->set_parameters_atomically(parameters, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n+    node, future, std::chrono::milliseconds(100));\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  ASSERT_TRUE(callback_called);\n+}\n+\n+/*\n+  Coverage for async list_parameters\n+ */\n+TEST_F(TestParameterClient, async_parameter_list_parameters) {\n+  auto asynchronous_client = std::make_shared<rclcpp::AsyncParametersClient>(node);\n+  bool callback_called = false;\n+  auto callback =\n+    [&callback_called](std::shared_future<rcl_interfaces::msg::ListParametersResult> result)\n+    {\n+      if (result.valid() && result.get().names.size() == 0 && result.get().prefixes.size() == 0) {\n+        callback_called = true;\n+      }\n+    };\n+  std::vector<std::string> prefixes{\"foo\"};\n+  std::shared_future<rcl_interfaces::msg::ListParametersResult> future =\n+    asynchronous_client->list_parameters(prefixes, 0, callback);\n+  auto return_code = rclcpp::spin_until_future_complete(\n+    node, future, std::chrono::milliseconds(100));\n+  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n+  ASSERT_TRUE(callback_called);\n+}\n+\n+/*\n+  Coverage for sync get_parameter_types\n+ */\n+TEST_F(TestParameterClient, sync_parameter_get_parameter_types) {\n+  node->declare_parameter(\"foo\", 4);\n+  auto synchronous_client = std::make_shared<rclcpp::SyncParametersClient>(node);\n+  std::vector<std::string> names{\"foo\"};\n+  std::vector<rclcpp::ParameterType> parameter_types =\n+    synchronous_client->get_parameter_types(names);\n+  ASSERT_EQ(1u, parameter_types.size());\n+  ASSERT_EQ(rclcpp::ParameterType::PARAMETER_INTEGER, parameter_types[0]);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  }\n-  rcutils_atomic_store(&(storage->current_time), time_value);\n-  if (storage->active) {\n+    rcutils_atomic_store(&(storage->current_time), time_value);"},{"role":"user","content":"+  } else {\n+    rcutils_atomic_store(&(storage->current_time), time_value);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;"},{"role":"user","content":"+  } catch (const std::bad_alloc &) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"'Bad alloc' exception deserializing message of type %s.\",\n+      getName());\n+    return false;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-ament_export_dependencies(rosidl_default_runtime)"},{"role":"user","content":"-ament_target_dependencies(${PROJECT_NAME}_library\n-  \"rcpputils\"\n-  \"rcutils\"\n-  \"rmw\"\n-  \"rosidl_runtime_cpp\")\n-add_dependencies(${PROJECT_NAME}_library\n-  ${PROJECT_NAME})\n+target_link_libraries(${PROJECT_NAME}_library PUBLIC\n+  rcutils::rcutils\n+  rmw::rmw)\n+target_link_libraries(${PROJECT_NAME}_library PRIVATE\n+  rcpputils::rcpputils)"},{"role":"user","content":"-  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_c>\"\n-  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp>\""},{"role":"user","content":"+# Wait for all rosidl generators to finish before building this library\n+add_dependencies(${PROJECT_NAME}_library\n+  ${PROJECT_NAME})\n+\n+# Depend on the generated C++ messages\n+rosidl_get_typesupport_target(cpp_typesupport_target \"${PROJECT_NAME}\" \"rosidl_generator_cpp\")\n+target_link_libraries(${PROJECT_NAME}_library PUBLIC\n+  ${cpp_typesupport_target})\n+"},{"role":"user","content":"-    target_link_libraries(test_security ${PROJECT_NAME}_library)\n+    target_link_libraries(test_security\n+      ${PROJECT_NAME}_library\n+      rcpputils::rcpputils)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    2);\n+    4);"},{"role":"user","content":"-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());"},{"role":"user","content":"-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());"},{"role":"user","content":"+  bool any_samples = false;"},{"role":"user","content":"+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;"},{"role":"user","content":"+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";"},{"role":"user","content":"-    2);\n+    4);"},{"role":"user","content":"-  EXPECT_EQ(2, statistics_listener->GetNumberOfMessagesReceived());\n+  EXPECT_EQ(4, statistics_listener->GetNumberOfMessagesReceived());"},{"role":"user","content":"-  EXPECT_EQ(2u, received_messages.size());\n+  EXPECT_EQ(4u, received_messages.size());"},{"role":"user","content":"+  bool any_samples = false;"},{"role":"user","content":"+    // skip messages without samples\n+    bool has_samples = false;\n+    for (const auto & stats_point : msg.statistics) {\n+      const auto type = stats_point.data_type;\n+      if (\n+        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type &&\n+        stats_point.data > 0)\n+      {\n+        has_samples = true;\n+        break;\n+      }\n+    }\n+    if (!has_samples) {\n+      continue;\n+    }\n+    any_samples = true;"},{"role":"user","content":"+  EXPECT_TRUE(any_samples) << \"All received metrics messages had zero samples\";"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  if(NOT WIN32)\n-    set_target_properties(test_validate_namespace PROPERTIES COMPILE_FLAGS \"-std=c++14\")\n-  endif()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-pybind11_add_module(_rclpy_pybind11 SHARED\n+pybind11_add_module(_rclpy_pybind11"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  RCLCPP_PUBLIC\n+  RCLCPP_LIFECYCLE_PUBLIC"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):"},{"role":"user","content":"-            while self._context.ok() and not future.done() and not self._is_shutdown:\n+            while (\n+                self._context.ok()\n+                and not future.done()\n+                and not future.cancelled()\n+                and not self._is_shutdown\n+            ):"},{"role":"user","content":"+                    # Get rid of any tasks that are cancelled\n+                    self._tasks = list(filter(lambda t_e_n: not t_e_n[0].cancelled(), self._tasks))"},{"role":"user","content":"+from enum import Enum"},{"role":"user","content":"+class FutureState(Enum):\n+    \"\"\"States defining the lifecycle of a future.\"\"\"\n+\n+    PENDING = 'PENDING'\n+    CANCELLED = 'CANCELLED'\n+    FINISHED = 'FINISHED'\n+\n+"},{"role":"user","content":"-        # true if the task is done or cancelled\n-        self._done = False\n-        # true if the task is cancelled\n-        self._cancelled = False\n+        self._state = FutureState.PENDING"},{"role":"user","content":"-        while not self._done:\n+        while self._pending():"},{"role":"user","content":"+    def _pending(self) -> bool:\n+        return self._state == FutureState.PENDING\n+"},{"role":"user","content":"-            if not self._done:\n-                self._cancelled = True\n+            if not self._pending():\n+                return\n+\n+        self._state = FutureState.CANCELLED"},{"role":"user","content":"-        return self._cancelled\n+        return self._state == FutureState.CANCELLED"},{"role":"user","content":"-        return self._done\n+        return self._state == FutureState.FINISHED"},{"role":"user","content":"-            self._done = True\n-            self._cancelled = False\n+            self._state = FutureState.FINISHED\n+"},{"role":"user","content":"-            self._done = True\n-            self._cancelled = False\n+            self._state = FutureState.FINISHED\n+"},{"role":"user","content":"-            if self._done:\n+            if not self._pending():"},{"role":"user","content":"-        if self._done or self._executing or not self._task_lock.acquire(blocking=False):\n+        if (\n+            not self._pending() or\n+            self._executing or\n+            not self._task_lock.acquire(blocking=False)\n+        ):"},{"role":"user","content":"-            if self._done:\n+            if not self._pending():"},{"role":"user","content":"-                    handler.close()"},{"role":"user","content":"+\n+    def cancel(self) -> None:\n+        if self._pending() and inspect.iscoroutine(self._handler):\n+            self._handler.close()\n+\n+        super().cancel()"},{"role":"user","content":"+    def test_create_task_coroutine_cancel(self) -> None:\n+        self.assertIsNotNone(self.node.handle)\n+        executor = SingleThreadedExecutor(context=self.context)\n+        executor.add_node(self.node)\n+\n+        async def coroutine():\n+            return 'Sentinel Result'\n+\n+        future = executor.create_task(coroutine)\n+        self.assertFalse(future.done())\n+        self.assertFalse(future.cancelled())\n+\n+        future.cancel()\n+        self.assertTrue(future.cancelled())\n+\n+        executor.spin_until_future_complete(future)\n+        self.assertFalse(future.done())\n+        self.assertTrue(future.cancelled())\n+        self.assertEqual(None, future.result())\n+"},{"role":"user","content":"+    def test_set_result_on_done_future_without_exception(self) -> None:\n+        f = Future()\n+        f.set_result(None)\n+        self.assertTrue(f.done())\n+        self.assertFalse(f.cancelled())\n+        f.set_result(None)\n+        self.assertTrue(f.done())\n+        self.assertFalse(f.cancelled())\n+\n+    def test_set_result_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertFalse(f.done())\n+        f.set_result(None)\n+        self.assertTrue(f.done())\n+\n+    def test_set_exception_on_done_future_without_exception(self) -> None:\n+        f = Future()\n+        f.set_result(None)\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        f.set_result(None)\n+        self.assertIsNotNone(f.exception())\n+\n+    def test_set_exception_on_cancelled_future_without_exception(self) -> None:\n+        f = Future()\n+        f.cancel()\n+        self.assertTrue(f.cancelled())\n+        self.assertIsNone(f.exception())\n+        f.set_exception(Exception())\n+        self.assertIsNotNone(f.exception())\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-   * \\param[in] max_duration The maximum amount of time to spend executing work. Must be positive.\n+   * \\param[in] max_duration The maximum amount of time to spend executing work, must be >= 0.\n+   *   `0` is potentially block forever until no more work is available.\n+   * \\throw throw std::invalid_argument if max_duration is less than 0."},{"role":"user","content":"-   * This non-blocking function will execute entities until\n-   * timeout or no more work available. If new entities get ready\n-   * while executing work available, they will be executed\n+   * This non-blocking function will execute entities until timeout (must be >= 0)\n+   * or no more work available.\n+   * If timeout is `0`, potentially it blocks forever until no more work is available.\n+   * If new entities get ready while executing work available, they will be executed"},{"role":"user","content":"-  if (max_duration <= 0ns) {\n-    throw std::invalid_argument(\"max_duration must be positive\");\n+  if (max_duration < 0ns) {\n+    throw std::invalid_argument(\"max_duration must be greater than or equal to 0\");"},{"role":"user","content":"-  if (max_duration <= std::chrono::nanoseconds(0)) {\n-    throw std::invalid_argument(\"max_duration must be positive\");\n+  if (max_duration < std::chrono::nanoseconds(0)) {\n+    throw std::invalid_argument(\"max_duration must be greater than or equal to 0\");"},{"role":"user","content":"-    std::invalid_argument(\"max_duration must be positive\"));\n+    std::invalid_argument(\"max_duration must be greater than or equal to 0\"));"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  float linear_scale = linear_scale_property_->getFloat();\n-  float angular_scale = angular_scale_property_->getFloat();\n-  float width = width_property_->getFloat();"},{"role":"user","content":"-  visual->setLinearScale(linear_scale);\n-  visual->setAngularScale(angular_scale);\n-  visual->setWidth(width);\n-  visual->setScrew(\n-    Ogre::Vector3(linear.x, linear.y, linear.z),\n-    Ogre::Vector3(angular.x, angular.y, angular.z));\n+  visual->setLinearScale(linear_scale_property_->getFloat());\n+  visual->setAngularScale(angular_scale_property_->getFloat());\n+  visual->setWidth(width_property_->getFloat());\n+  visual->setHideSmallValues(hide_small_values_property_->getBool());"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    There's not other way of popping it.\n+    There's no other way of popping it."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-/// Thrown when a parameter override wasn't provided and one was required.\n-class NoParameterOverrideProvided : public std::runtime_error\n+/// Thrown when an uninitialized parameter is accessed.\n+class ParameterUninitializedException : public std::runtime_error"},{"role":"user","content":"-  explicit NoParameterOverrideProvided(const std::string & name)\n-  : std::runtime_error(\"parameter '\" + name + \"' requires an user provided parameter override\")\n+  explicit ParameterUninitializedException(const std::string & name)\n+  : std::runtime_error(\"parameter '\" + name + \"' is not initialized\")"},{"role":"user","content":"+  // If there is no initial value, then skip initialization\n+  if (initial_value->get_type() == rclcpp::PARAMETER_NOT_SET) {\n+    // Add declared parameters to storage (without a value)\n+    parameter_infos[name].descriptor.name = name;\n+    if (parameter_descriptor.dynamic_typing) {\n+      parameter_infos[name].descriptor.type = rclcpp::PARAMETER_NOT_SET;\n+    } else {\n+      parameter_infos[name].descriptor.type = parameter_descriptor.type;\n+    }\n+    parameters_out[name] = parameter_infos.at(name);\n+    rcl_interfaces::msg::SetParametersResult result;\n+    result.successful = true;\n+    return result;\n+  }\n+"},{"role":"user","content":"-  if (\n-    rclcpp::PARAMETER_NOT_SET == default_value.get_type() &&\n-    overrides.find(name) == overrides.end() &&\n-    parameter_descriptor.dynamic_typing == false)\n-  {\n-    throw rclcpp::exceptions::NoParameterOverrideProvided(name);\n-  }\n-"},{"role":"user","content":"-  rclcpp::Parameter parameter;\n+  std::lock_guard<std::recursive_mutex> lock(mutex_);"},{"role":"user","content":"-  if (get_parameter(name, parameter)) {\n-    return parameter;\n+  auto param_iter = parameters_.find(name);\n+  if (\n+    parameters_.end() != param_iter &&\n+    (param_iter->second.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n+    param_iter->second.descriptor.dynamic_typing))\n+  {\n+    return rclcpp::Parameter{name, param_iter->second.value};"},{"role":"user","content":"-    return parameter;\n-  } else {\n+    return rclcpp::Parameter{};\n+  } else if (parameters_.end() == param_iter) {"},{"role":"user","content":"+  } else {\n+    throw rclcpp::exceptions::ParameterUninitializedException(name);"},{"role":"user","content":"+    const std::string parameter_name = \"parameter\"_unq;"},{"role":"user","content":"-      \"parameter\"_unq, rclcpp::ParameterValue{}, descriptor);\n+      parameter_name, rclcpp::ParameterValue{}, descriptor);"},{"role":"user","content":"+    // Does not throw if unset before access\n+    EXPECT_EQ(\n+      rclcpp::PARAMETER_NOT_SET,\n+      node->get_parameter(parameter_name).get_parameter_value().get_type());"},{"role":"user","content":"+    auto param = node->declare_parameter(\"integer_override_not_given\", rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n+    // Throws if not set before access"},{"role":"user","content":"-      node->declare_parameter(\"integer_override_not_given\", rclcpp::PARAMETER_INTEGER),\n-      rclcpp::exceptions::NoParameterOverrideProvided);\n+      node->get_parameter(\"integer_override_not_given\"),\n+      rclcpp::exceptions::ParameterUninitializedException);\n+  }\n+  {\n+    auto param = node->declare_parameter(\"integer_set_after_declare\", rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n+    auto result = node->set_parameter(rclcpp::Parameter{\"integer_set_after_declare\", 44});\n+    ASSERT_TRUE(result.successful) << result.reason;\n+    auto get_param = node->get_parameter(\"integer_set_after_declare\");\n+    EXPECT_EQ(44, get_param.as_int());"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-The package `action_msgs` claims to be in the **Quality Level 4** category.\n+The package `action_msgs` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`action_msgs` has the following runtime ROS dependencies:\n-* `builtin_interfaces`\n-* `rosidl_default_runtime`\n-* `unique_identifier_msgs`\n+`action_msgs` has the following runtime ROS dependencies, which are at or above QL 3:\n+* `builtin_interfaces`: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n+* `unique_identifier_msgs`: [QL 3](https://github.com/ros2/unique_identifier_msgs/tree/master/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `builtin_interfaces` claims to be in the **Quality Level 4** category.\n+The package `builtin_interfaces` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`builtin_interfaces` has the following ROS dependencies:\n-* `rosidl_default_runtime`\n+`builtin_interfaces` has the following ROS dependencies, which are at or above QL 3:\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `composition_interfaces` claims to be in the **Quality Level 4** category.\n+The package `composition_interfaces` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`composition_interfaces` has the following ROS dependencies:\n-* `rosidl_default_runtime`\n+`composition_interfaces` has the following ROS dependencies, which are at or above QL 3:\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `lifecycle_msgs` claims to be in the **Quality Level 4** category.\n+The package `lifecycle_msgs` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`lifecycle_msgs` has the following ROS dependencies:\n-* `rosidl_default_runtime`\n+`lifecycle_msgs` has the following ROS dependencies, which are at or above QL 3:\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `rcl_interfaces` claims to be in the **Quality Level 4** category.\n+The package `rcl_interfaces` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`rcl_interfaces` has the following ROS dependencies:\n-* `builtin_interfaces`\n-* `rosidl_default_runtime`\n+`rcl_interfaces` has the following ROS dependencies, which are at or above QL 3:\n+* `builtin_interfaces`: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `rosgraph_msgs` claims to be in the **Quality Level 4** category.\n+The package `rosgraph_msgs` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`rosgraph_msgs` has the following ROS dependencies:\n-* `builtin_interfaces`\n-* `rosidl_default_runtime`\n+`rosgraph_msgs` has the following ROS dependencies, which are at or above QL 3:\n+* `builtin_interfaces`: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"user","content":"-The package `statistics_msgs` claims to be in the **Quality Level 4** category.\n+The package `statistics_msgs` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-`statistics_msgs` has the following ROS dependencies:\n-* `builtin_interfaces`\n-* `rosidl_default_runtime`\n+`statistics_msgs` has the following ROS dependencies, which are at or above QL 3:\n+* `builtin_interfaces`: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n+* `rosidl_default_runtime`: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  std::stringstream ss;\n+  ss << not_set_variant;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"\\\", \\\"type\\\": \\\"not set\\\", \\\"value\\\": \\\"not set\\\"}\", ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(not_set_variant, not_set_variant);\n+  rclcpp::Parameter not_set_variant2;\n+  EXPECT_EQ(not_set_variant, not_set_variant2);\n+  rclcpp::Parameter bool_variant(\"bool_param\", true);\n+  EXPECT_NE(not_set_variant, bool_variant);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << bool_variant_true;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"bool_param\\\", \\\"type\\\": \\\"bool\\\", \\\"value\\\": \\\"true\\\"}\", ss.str());\n+"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(bool_variant_true, bool_variant_true);\n+  EXPECT_NE(bool_variant_false, bool_variant_true);\n+  EXPECT_EQ(bool_variant_true, from_msg_true);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << integer_variant;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"integer_param\\\", \\\"type\\\": \\\"integer\\\", \\\"value\\\": \\\"42\\\"}\", ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(integer_variant, integer_variant);\n+  EXPECT_NE(integer_variant, rclcpp::Parameter(\"integer_param\", 41));\n+  EXPECT_EQ(integer_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << long_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"long_integer_param\\\", \\\"type\\\": \\\"integer\\\", \\\"value\\\": \"\n+    \"\\\"9223372036854775807\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(long_variant, long_variant);\n+  EXPECT_NE(long_variant, rclcpp::Parameter(\"long_integer_param\", 41));\n+  EXPECT_EQ(long_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << float_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"float_param\\\", \\\"type\\\": \\\"double\\\", \\\"value\\\": \\\"42.000000\\\"}\", ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(float_variant, float_variant);\n+  EXPECT_NE(float_variant, rclcpp::Parameter(\"float_param\", 41.0));\n+  EXPECT_EQ(float_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << double_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"double_param\\\", \\\"type\\\": \\\"double\\\", \\\"value\\\": \\\"-42.100000\\\"}\", ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(double_variant, double_variant);\n+  EXPECT_NE(double_variant, rclcpp::Parameter(\"double_param\", -41.2));\n+  EXPECT_EQ(double_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << string_variant;\n+  EXPECT_EQ(\"{\\\"name\\\": \\\"string_param\\\", \\\"type\\\": \\\"string\\\", \\\"value\\\": \\\"ROS2\\\"}\", ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  EXPECT_EQ(string_variant, string_variant);\n+  EXPECT_NE(string_variant, rclcpp::Parameter(\"string_param\", \"ROS1\"));\n+  EXPECT_EQ(string_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << byte_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"byte_array_param\\\", \\\"type\\\": \\\"byte_array\\\", \\\"value\\\": \"\n+    \"\\\"[0x52, 0x4f, 0x53, 0x32]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<uint8_t> TEST_VALUE2 {0x1, 0x2, 0x3, 0x4};\n+  EXPECT_EQ(byte_array_variant, byte_array_variant);\n+  EXPECT_NE(byte_array_variant, rclcpp::Parameter(\"byte_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(byte_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << bool_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"bool_array_param\\\", \\\"type\\\": \\\"bool_array\\\", \\\"value\\\": \"\n+    \"\\\"[false, true, true, false, false, true]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<bool> TEST_VALUE2 {true, true, true};\n+  EXPECT_EQ(bool_array_variant, bool_array_variant);\n+  EXPECT_NE(bool_array_variant, rclcpp::Parameter(\"bool_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(bool_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << integer_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"integer_array_param\\\", \\\"type\\\": \\\"integer_array\\\", \\\"value\\\": \"\n+    \"\\\"[42, -99, 2147483647, -2147483648, 0]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<int> TEST_VALUE2{1, 2, 3, 4, 5};\n+  EXPECT_EQ(integer_array_variant, integer_array_variant);\n+  EXPECT_NE(integer_array_variant, rclcpp::Parameter(\"integer_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(integer_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << long_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"long_integer_array_param\\\", \\\"type\\\": \\\"integer_array\\\", \\\"value\\\": \"\n+    \"\\\"[42, -99, 9223372036854775807, -9223372036854775808, 0]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<int64_t> TEST_VALUE2{1, 2, 3, 4, 5};\n+  EXPECT_EQ(long_array_variant, long_array_variant);\n+  EXPECT_NE(long_array_variant, rclcpp::Parameter(\"long_integer_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(long_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << float_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"float_array_param\\\", \\\"type\\\": \\\"double_array\\\", \\\"value\\\": \"\n+    \"\\\"[42.1, -99.1, 3.40282e+38, -3.40282e+38, 0.1]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<float> TEST_VALUE2{1.0, 2.0, 3.0, 4.0};\n+  EXPECT_EQ(float_array_variant, float_array_variant);\n+  EXPECT_NE(float_array_variant, rclcpp::Parameter(\"float_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(float_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << double_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"double_array_param\\\", \\\"type\\\": \\\"double_array\\\", \\\"value\\\": \"\n+    \"\\\"[42.1, -99.1, 1.79769e+308, -1.79769e+308, 0.1]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<double> TEST_VALUE2{1.0, 2.0, 3.0, 4.0};\n+  EXPECT_EQ(double_array_variant, double_array_variant);\n+  EXPECT_NE(double_array_variant, rclcpp::Parameter(\"double_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(double_array_variant, from_msg);"},{"role":"user","content":"+  std::stringstream ss;\n+  ss << string_array_variant;\n+  EXPECT_EQ(\n+    \"{\\\"name\\\": \\\"string_array_param\\\", \\\"type\\\": \\\"string_array\\\", \\\"value\\\": \\\"[R, O, S2]\\\"}\",\n+    ss.str());"},{"role":"user","content":"+\n+  // Check == and != operators work as expected\n+  const std::vector<std::string> TEST_VALUE2{\"R\", \"O\", \"S1\"};\n+  EXPECT_EQ(string_array_variant, string_array_variant);\n+  EXPECT_NE(string_array_variant, rclcpp::Parameter(\"string_array_param\", TEST_VALUE2));\n+  EXPECT_EQ(string_array_variant, from_msg);\n+}\n+\n+TEST_F(TestParameter, parameter_vector_stringification) {\n+  const std::vector<rclcpp::Parameter> parameters = {\n+    rclcpp::Parameter(),\n+    rclcpp::Parameter(\"bool_param\", true),\n+    rclcpp::Parameter(\"integer_param\", 42),\n+    rclcpp::Parameter(\"double_param\", 3.14159),\n+    rclcpp::Parameter(\"string_param\", \"I'm a string\"),\n+  };\n+\n+  std::stringstream ss;\n+  ss << parameters;\n+  EXPECT_EQ(\n+    \"{\"\n+    \"\\\"\\\": {\\\"type\\\": \\\"not set\\\", \\\"value\\\": \\\"not set\\\"}, \"\n+    \"\\\"bool_param\\\": {\\\"type\\\": \\\"bool\\\", \\\"value\\\": \\\"true\\\"}, \"\n+    \"\\\"integer_param\\\": {\\\"type\\\": \\\"integer\\\", \\\"value\\\": \\\"42\\\"}, \"\n+    \"\\\"double_param\\\": {\\\"type\\\": \\\"double\\\", \\\"value\\\": \\\"3.141590\\\"}, \"\n+    \"\\\"string_param\\\": {\\\"type\\\": \\\"string\\\", \\\"value\\\": \\\"I'm a string\\\"}}\",\n+    ss.str());"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclpy/clock_event.cpp"},{"role":"user","content":"+from .exceptions import NotInitializedException"},{"role":"user","content":"+from .utilities import get_default_context"},{"role":"user","content":"+    def sleep_until(self, until: Time, context=None) -> bool:\n+        \"\"\"\n+        Sleep until a Time on this Clock is reached.\n+\n+        When using a ROSClock, this may sleep forever if the TimeSource is misconfigured and the\n+        context is never shut down.\n+        ROS time being activated or deactivated causes this function to cease sleeping and return\n+        False.\n+\n+        :param until: Time at which this function should stop sleeping.\n+        :param context: Context which when shut down will cause this sleep to wake early.\n+            If context is None, then the default context is used.\n+        :return: True if until was reached, or False if it woke for another reason.\n+        :raises ValueError: until is specified for a different type of clock than this one.\n+        :raises NotInitializedException: context has not been initialized or is shutdown.\n+        \"\"\"\n+        if context is None:\n+            context = get_default_context()\n+\n+        if not context.ok():\n+            raise NotInitializedException()\n+\n+        if until.clock_type != self._clock_type:\n+            raise ValueError(\"until's clock type does not match this clock's type\")\n+\n+        event = _rclpy.ClockEvent()\n+        time_source_changed = False\n+\n+        def on_time_jump(time_jump: TimeJump):\n+            \"\"\"Wake when time jumps and is past target time.\"\"\"\n+            nonlocal time_source_changed\n+\n+            # ROS time being activated or deactivated changes the epoch, so sleep\n+            # time loses its meaning\n+            time_source_changed = (\n+                time_source_changed or\n+                ClockChange.ROS_TIME_ACTIVATED == time_jump.clock_change or\n+                ClockChange.ROS_TIME_DEACTIVATED == time_jump.clock_change)\n+\n+            if time_source_changed or self.now() >= until:\n+                event.set()\n+\n+        # Wake when context is shut down\n+        context.on_shutdown(event.set)\n+\n+        threshold = JumpThreshold(\n+            min_forward=Duration(nanoseconds=1),\n+            min_backward=None,\n+            on_clock_change=True)\n+        with self.create_jump_callback(threshold, post_callback=on_time_jump):\n+            if ClockType.SYSTEM_TIME == self._clock_type:\n+                event.wait_until_system(self.__clock, until._time_handle)\n+            elif ClockType.STEADY_TIME == self._clock_type:\n+                event.wait_until_steady(self.__clock, until._time_handle)\n+            elif ClockType.ROS_TIME == self._clock_type:\n+                event.wait_until_ros(self.__clock, until._time_handle)\n+\n+        if not context.ok() or time_source_changed:\n+            return False\n+\n+        return self.now() >= until\n+"},{"role":"user","content":"+#include \"clock_event.hpp\""},{"role":"user","content":"+  rclpy::define_clock_event(m);"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <pybind11/pybind11.h>\n+\n+#include <rcl/error_handling.h>\n+#include <rcl/rcl.h>\n+#include <rcl/time.h>\n+#include <rcl/types.h>\n+\n+#include <condition_variable>\n+#include <cstring>\n+#include <memory>\n+#include <stdexcept>\n+\n+#include \"clock_event.hpp\"\n+\n+namespace py = pybind11;\n+\n+namespace rclpy\n+{\n+template<typename ClockType>\n+void ClockEvent::wait_until(std::shared_ptr<Clock> clock, rcl_time_point_t until)\n+{\n+  // Synchronize because clock epochs might differ\n+  const rcl_time_point_t rcl_entry = clock->get_now();\n+  const typename ClockType::time_point chrono_entry = ClockType::now();\n+\n+  rcl_duration_t delta_t;\n+  rcl_ret_t ret = rcl_difference_times(&rcl_entry, &until, &delta_t);\n+\n+  if (RCL_RET_OK != ret) {\n+    throw RCLError(\"failed to subtract times\");\n+  }\n+\n+  // Cast because system clock resolution is too big for nanoseconds on Windows & OSX\n+  const typename ClockType::time_point chrono_until = chrono_entry +\n+    std::chrono::duration_cast<typename ClockType::duration>(\n+    std::chrono::nanoseconds(delta_t.nanoseconds));\n+\n+  // Could be a long wait, release the gil\n+  py::gil_scoped_release release;\n+  std::unique_lock<std::mutex> lock(mutex_);\n+  cv_.wait_until(lock, chrono_until, [this]() {return state_;});\n+}\n+\n+void ClockEvent::wait_until_ros(std::shared_ptr<Clock> clock, rcl_time_point_t until)\n+{\n+  // Check if ROS time is enabled in C++ to avoid TOCTTOU with TimeSource by holding GIL\n+  if (clock->get_ros_time_override_is_enabled()) {\n+    // Could be a long wait, release the gil\n+    py::gil_scoped_release release;\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    // Caller must have setup a time jump callback to wake this event\n+    cv_.wait(lock, [this]() {return state_;});\n+  } else {\n+    // ROS time not enabled is system time\n+    wait_until<std::chrono::system_clock>(clock, until);\n+  }\n+}\n+\n+bool ClockEvent::is_set()\n+{\n+  std::unique_lock<std::mutex> lock(mutex_);\n+  return state_;\n+}\n+\n+void ClockEvent::set()\n+{\n+  {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    state_ = true;\n+  }\n+  cv_.notify_all();\n+}\n+\n+void ClockEvent::clear()\n+{\n+  {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    state_ = false;\n+  }\n+  cv_.notify_all();\n+}\n+\n+void define_clock_event(py::object module)\n+{\n+  py::class_<ClockEvent>(module, \"ClockEvent\")\n+  .def(py::init())\n+  .def(\n+    \"wait_until_steady\", &ClockEvent::wait_until<std::chrono::steady_clock>,\n+    \"Wait for the event to be set (monotonic wait)\")\n+  .def(\n+    \"wait_until_system\", &ClockEvent::wait_until<std::chrono::system_clock>,\n+    \"Wait for the event to be set (system timed wait)\")\n+  .def(\n+    \"wait_until_ros\", &ClockEvent::wait_until_ros,\n+    \"Wait for the event to be set (ROS timed wait)\")\n+  .def(\n+    \"is_set\", &ClockEvent::is_set,\n+    \"Return True if the event is set, False otherwise.\")\n+  .def(\n+    \"set\", &ClockEvent::set,\n+    \"Set the event, waking all those who wait on it.\")\n+  .def(\n+    \"clear\", &ClockEvent::clear,\n+    \"Unset the event.\");\n+}\n+}  // namespace rclpy"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLPY__CLOCK_EVENT_HPP_\n+#define RCLPY__CLOCK_EVENT_HPP_\n+\n+#include <pybind11/pybind11.h>\n+\n+#include <rcl/error_handling.h>\n+#include <rcl/rcl.h>\n+#include <rcl/time.h>\n+#include <rcl/types.h>\n+\n+#include <chrono>\n+#include <condition_variable>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <stdexcept>\n+\n+#include \"clock.hpp\"\n+\n+namespace py = pybind11;\n+\n+namespace rclpy\n+{\n+class ClockEvent\n+{\n+public:\n+  /// Wait until a time specified by a system or steady clock.\n+  /// \\param clock the clock to use for time synchronization with until\n+  /// \\param until this method will block until this time is reached.\n+  template<typename ClockType>\n+  void wait_until(std::shared_ptr<Clock> clock, rcl_time_point_t until);\n+\n+  /// Wait until a time specified by a ROS clock.\n+  /// \\warning the caller is responsible for creating a time jump callback to set this event when\n+  /// the target ROS time is reached.\n+  /// when a given ROS time is reached.\n+  /// \\param clock the clock to use for time synchronization.\n+  /// \\param until this method will block until this time is reached.\n+  void wait_until_ros(std::shared_ptr<Clock> clock, rcl_time_point_t until);\n+\n+  /// Indicate if the ClockEvent is set.\n+  /// \\return True if the ClockEvent is set.\n+  bool is_set();\n+\n+  /// Set the event.\n+  void set();\n+\n+  /// Clear the event.\n+  void clear();\n+\n+private:\n+  bool state_ = false;\n+  std::mutex mutex_;\n+  std::condition_variable cv_;\n+};\n+\n+/// Define a pybind11 wrapper for an rclpy::ClockEvent\n+void define_clock_event(py::object module);\n+}  // namespace rclpy\n+\n+#endif  // RCLPY__CLOCK_EVENT_HPP_"},{"role":"user","content":"+import threading"},{"role":"user","content":"+import rclpy"},{"role":"user","content":"+from rclpy.context import Context"},{"role":"user","content":"+from rclpy.exceptions import NotInitializedException"},{"role":"user","content":"+from rclpy.utilities import get_default_context"},{"role":"user","content":"+A_SMALL_AMOUNT_OF_TIME = Duration(seconds=0.5)\n+\n+"},{"role":"user","content":"+@pytest.fixture()\n+def default_context():\n+    rclpy.init()\n+    yield get_default_context()\n+    rclpy.shutdown()\n+\n+\n+@pytest.fixture()\n+def non_default_context():\n+    context = Context()\n+    context.init()\n+    yield context\n+    context.try_shutdown()\n+\n+\n+def test_sleep_until_mismatched_clock_type(default_context):\n+    clock = Clock(clock_type=ClockType.SYSTEM_TIME)\n+    with pytest.raises(ValueError, match='.*clock type does not match.*'):\n+        clock.sleep_until(Time(clock_type=ClockType.STEADY_TIME))\n+\n+\n+def test_sleep_until_non_default_context(non_default_context):\n+    clock = Clock()\n+    assert clock.sleep_until(clock.now() + Duration(seconds=0.1), context=non_default_context)\n+\n+\n+def test_sleep_until_invalid_context():\n+    clock = Clock()\n+    with pytest.raises(NotInitializedException):\n+        clock.sleep_until(clock.now() + Duration(seconds=0.1), context=Context())\n+\n+\n+@pytest.mark.parametrize(\n+    'clock_type', (ClockType.SYSTEM_TIME, ClockType.STEADY_TIME, ClockType.ROS_TIME))\n+def test_sleep_until_basic(default_context, clock_type):\n+    clock = Clock(clock_type=clock_type)\n+    sleep_duration = Duration(seconds=0.1)\n+    start = clock.now()\n+    assert clock.sleep_until(clock.now() + sleep_duration)\n+    stop = clock.now()\n+    assert stop - start >= sleep_duration\n+\n+\n+@pytest.mark.parametrize(\n+    'clock_type', (ClockType.SYSTEM_TIME, ClockType.STEADY_TIME, ClockType.ROS_TIME))\n+def test_sleep_until_time_in_past(default_context, clock_type):\n+    clock = Clock(clock_type=clock_type)\n+    sleep_duration = Duration(seconds=-1)\n+    start = clock.now()\n+    assert clock.sleep_until(clock.now() + sleep_duration)\n+    stop = clock.now()\n+    assert stop - start < A_SMALL_AMOUNT_OF_TIME\n+\n+\n+@pytest.mark.parametrize('ros_time_enabled', (True, False))\n+def test_sleep_until_ros_time_toggled(default_context, ros_time_enabled):\n+    clock = ROSClock()\n+    clock._set_ros_time_is_active(not ros_time_enabled)\n+\n+    retval = None\n+\n+    def run():\n+        nonlocal retval\n+        retval = clock.sleep_until(clock.now() + Duration(seconds=10))\n+\n+    t = threading.Thread(target=run)\n+    t.start()\n+\n+    # wait for thread to get inside sleep_until call\n+    time.sleep(0.2)\n+\n+    clock._set_ros_time_is_active(ros_time_enabled)\n+\n+    # wait for thread to exit\n+    start = clock.now()\n+    t.join()\n+    stop = clock.now()\n+    assert stop - start < A_SMALL_AMOUNT_OF_TIME\n+\n+    assert retval is False\n+\n+\n+def test_sleep_until_context_shut_down(non_default_context):\n+    clock = Clock()\n+    retval = None\n+\n+    def run():\n+        nonlocal retval\n+        retval = clock.sleep_until(\n+            clock.now() + Duration(seconds=10), context=non_default_context)\n+\n+    t = threading.Thread(target=run)\n+    t.start()\n+\n+    # wait for thread to get inside sleep_until call\n+    time.sleep(0.2)\n+\n+    non_default_context.shutdown()\n+\n+    # wait for thread to exit\n+    start = clock.now()\n+    t.join()\n+    stop = clock.now()\n+    assert stop - start < A_SMALL_AMOUNT_OF_TIME\n+\n+    assert retval is False\n+\n+\n+def test_sleep_until_ros_time_enabled(default_context):\n+    clock = ROSClock()\n+    clock._set_ros_time_is_active(True)\n+\n+    start_time = Time(seconds=1, clock_type=ClockType.ROS_TIME)\n+    stop_time = start_time + Duration(seconds=10)\n+    clock.set_ros_time_override(start_time)\n+\n+    retval = None\n+\n+    def run():\n+        nonlocal retval\n+        retval = clock.sleep_until(stop_time)\n+\n+    t = threading.Thread(target=run)\n+    t.start()\n+\n+    # wait for thread to get inside sleep_until call\n+    time.sleep(0.2)\n+\n+    clock.set_ros_time_override(stop_time)\n+\n+    # wait for thread to exit\n+    start = clock.now()\n+    t.join()\n+    stop = clock.now()\n+    assert stop - start < A_SMALL_AMOUNT_OF_TIME\n+\n+    assert retval\n+\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-The chart below compares the requirements in the REP-2004 with the current state of the `rmw_dds_common` package.\n+The chart below compares the requirements in the REP-2004 with the current state of the `rmw_fastrtps_cpp` package."},{"role":"user","content":"-The package `rmw_fastrtps_shared_cpp` claims to be in the **Quality Level 4** category.\n+The package `rmw_fastrtps_shared_cpp` claims to be in the **Quality Level 3** category."},{"role":"user","content":"-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html)."},{"role":"user","content":"-Most recent test results can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/1525/testReport/rmw_fastrtps_shared_cpp/copyright/)\n+Most recent test results can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_fastrtps_shared_cpp/copyright/)"},{"role":"user","content":"-The results of the test can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/1525/testReport/rmw_fastrtps_shared_cpp/copyright/).\n+The results of the test can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_fastrtps_shared_cpp/copyright/)."},{"role":"user","content":"-`rmw_fastrtps_shared_cpp` does not currently track test coverage.\n+`rmw_fastrtps_shared_cpp` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n+\n+This includes:\n+\n+- tracking and reporting line coverage statistics\n+- achieving and maintaining a reasonable branch line coverage (90-100%)\n+- no lines are manually skipped in coverage calculations\n+\n+Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n+\n+Current coverage statistics can be viewed \n+[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/install_rmw_fastrtps_shared_cpp_include_rmw_fastrtps_shared_cpp/), \n+[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_include_rmw_fastrtps_shared_cpp/), \n+[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_src/), and \n+[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_src_types/).\n+This package does not yet meet the 95% coverage guideline.\n+\n+A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs)."},{"role":"user","content":"-## Vulnerability Disclosure Policy [7.i]\n+## Security [7]\n+\n+### Vulnerability Disclosure Policy [7.i]"},{"role":"user","content":"+\n+# Current status Summary\n+\n+The chart below compares the requirements in the REP-2004 with the current state of the `rmw_fastrtps_shared_cpp` package.\n+\n+|Number| Requirement| Current state |\n+|--|--|--|\n+|1| **Version policy** |---|\n+|1.i|Version Policy available | Γ£ô |\n+|1.ii|Stable version |Γ£ô |\n+|1.iii|Declared public API|Γ£ô|\n+|1.iv|API stability policy|Γ£ô|\n+|1.v|ABI stability policy|Γ£ô|\n+|1.vi_|API/ABI stable within ros distribution|Γ£ô|\n+|2| **Change control process** |---|\n+|2.i| All changes occur on change request | Γ£ô|\n+|2.ii| Contributor origin (DCO, CLA, etc) | Γ£ô|\n+|2.iii| Peer review policy | Γ£ô |\n+|2.iv| CI policy for change requests | Γ£ô |\n+|2.v| Documentation policy for change requests | Γ£ô |\n+|3| **Documentation** | --- |\n+|3.i| Per feature documentation | Γ£ô |\n+|3.ii| Per public API item documentation | * |\n+|3.iii| Declared License(s) | Γ£ô |\n+|3.iv| Copyright in source files| Γ£ô |\n+|3.v.a| Quality declaration linked to README | Γ£ô |\n+|3.v.b| Centralized declaration available for peer review |Γ£ô|\n+|4| **Testing** | --- |\n+|4.i| Feature items tests | Γ£ô |\n+|4.ii| Public API tests | Γ£ô |\n+|4.iii.a| Using coverage | Γ£ô |\n+|4.iii.a| Coverage policy | Γ£ô |\n+|4.iv.a| Performance tests (if applicable) | Γÿô |\n+|4.iv.b| Performance tests policy| Γ£ô |\n+|4.v.a| Code style enforcement (linters)| Γ£ô |\n+|4.v.b| Use of static analysis tools | Γ£ô |\n+|5| **Dependencies** | --- |\n+|5.i| Must not have ROS lower level dependencies | Γ£ô |\n+|5.ii| Optional ROS lower level dependencies| Γ£ô |\n+|5.iii| Justifies quality use of non-ROS dependencies |Γ£ô|\n+|6| **Platform support** | --- |\n+|6.i| Support targets Tier1 ROS platforms| Γ£ô |\n+|7| **Security** | --- |\n+|7.i| Vulnerability Disclosure Policy | Γ£ô |"},{"role":"user","content":"-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclcpp/executors/executor_entities_collection.cpp\n+  src/rclcpp/executors/executor_entities_collector.cpp\n+  src/rclcpp/executors/executor_notify_waitable.cpp"},{"role":"user","content":"+  [[deprecated(\"Use CallbackGroup constructor with context function argument\")]]"},{"role":"user","content":"+  /// Constructor for CallbackGroup.\n+  /**\n+   * Callback Groups have a type, either 'Mutually Exclusive' or 'Reentrant'\n+   * and when creating one the type must be specified.\n+   *\n+   * Callbacks in Reentrant Callback Groups must be able to:\n+   *   - run at the same time as themselves (reentrant)\n+   *   - run at the same time as other callbacks in their group\n+   *   - run at the same time as other callbacks in other groups\n+   *\n+   * Callbacks in Mutually Exclusive Callback Groups:\n+   *   - will not be run multiple times simultaneously (non-reentrant)\n+   *   - will not be run at the same time as other callbacks in their group\n+   *   - but must run at the same time as callbacks in other groups\n+   *\n+   * Additionally, callback groups have a property which determines whether or\n+   * not they are added to an executor with their associated node automatically.\n+   * When creating a callback group the automatically_add_to_executor_with_node\n+   * argument determines this behavior, and if true it will cause the newly\n+   * created callback group to be added to an executor with the node when the\n+   * Executor::add_node method is used.\n+   * If false, this callback group will not be added automatically and would\n+   * have to be added to an executor manually using the\n+   * Executor::add_callback_group method.\n+   *\n+   * Whether the node was added to the executor before creating the callback\n+   * group, or after, is irrelevant; the callback group will be automatically\n+   * added to the executor in either case.\n+   *\n+   * \\param[in] group_type The type of the callback group.\n+   * \\param[in] get_node_context Lambda to retrieve the node context when\n+   *   checking that the creating node is valid and using the guard condition.\n+   * \\param[in] automatically_add_to_executor_with_node A boolean that\n+   *   determines whether a callback group is automatically added to an executor\n+   *   with the node with which it is associated.\n+   */\n+  RCLCPP_PUBLIC\n+  explicit CallbackGroup(\n+    CallbackGroupType group_type,\n+    std::function<rclcpp::Context::SharedPtr(void)> get_node_context,\n+    bool automatically_add_to_executor_with_node = true);\n+"},{"role":"user","content":"-  /// Defer creating the notify guard condition and return it.\n+  /// Retrieve the guard condition used to signal changes to this callback group.\n+  /**\n+   * \\param[in] context_ptr context to use when creating the guard condition\n+   * \\return guard condition if it is valid, otherwise nullptr.\n+   */\n+  [[deprecated(\"Use get_notify_guard_condition() without arguments\")]]"},{"role":"user","content":"+  /// Retrieve the guard condition used to signal changes to this callback group.\n+  /**\n+   * \\return guard condition if it is valid, otherwise nullptr.\n+   */\n+  RCLCPP_PUBLIC\n+  rclcpp::GuardCondition::SharedPtr\n+  get_notify_guard_condition();\n+"},{"role":"user","content":"+  std::function<rclcpp::Context::SharedPtr(void)> get_context_;\n+"},{"role":"user","content":"-  rclcpp::GuardCondition interrupt_guard_condition_;\n+  std::shared_ptr<rclcpp::GuardCondition> interrupt_guard_condition_;"},{"role":"user","content":"+  /// Guard condition for signaling the rmw layer to wake up for system shutdown."},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_\n+#define RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_\n+\n+#include <deque>\n+#include <functional>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <rclcpp/any_executable.hpp>\n+#include <rclcpp/node_interfaces/node_base.hpp>\n+#include <rclcpp/callback_group.hpp>\n+#include <rclcpp/executors/executor_notify_waitable.hpp>\n+#include <rclcpp/visibility_control.hpp>\n+#include <rclcpp/wait_result.hpp>\n+#include <rclcpp/wait_set.hpp>\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+\n+/// Structure to represent a single entity's entry in a collection\n+template<typename EntityValueType>\n+struct CollectionEntry\n+{\n+  /// Weak pointer to entity type\n+  using EntityWeakPtr = typename EntityValueType::WeakPtr;\n+  /// Shared pointer to entity type\n+  using EntitySharedPtr = typename EntityValueType::SharedPtr;\n+\n+  /// The entity\n+  EntityWeakPtr entity;\n+\n+  /// If relevant, the entity's corresponding callback_group\n+  rclcpp::CallbackGroup::WeakPtr callback_group;\n+};\n+\n+/// Update a collection based on another collection\n+/*\n+ * Iterates update_from and update_to to see which entities have been added/removed between\n+ * the two collections.\n+ *\n+ * For each new entry (in update_from, but not in update_to),\n+ *   add the entity and fire the on_added callback\n+ * For each removed entry (in update_to, but not in update_from),\n+ *   remove the entity and fire the on_removed callback.\n+ *\n+ *  \\param[in] update_from The collection representing the next iteration's state\n+ *  \\param[inout] update_to The collection representing the current iteration's state\n+ *  \\param[in] on_added Callback fired when a new entity is detected\n+ *  \\param[in] on_removed Callback fired when an entity is removed\n+ */\n+template<typename CollectionType>\n+void update_entities(\n+  const CollectionType & update_from,\n+  CollectionType & update_to,\n+  std::function<void(const typename CollectionType::EntitySharedPtr &)> on_added,\n+  std::function<void(const typename CollectionType::EntitySharedPtr &)> on_removed\n+)\n+{\n+  for (auto it = update_to.begin(); it != update_to.end(); ) {\n+    if (update_from.count(it->first) == 0) {\n+      auto entity = it->second.entity.lock();\n+      if (entity) {\n+        on_removed(entity);\n+      }\n+      it = update_to.erase(it);\n+    } else {\n+      ++it;\n+    }\n+  }\n+  for (auto it = update_from.begin(); it != update_from.end(); ++it) {\n+    if (update_to.count(it->first) == 0) {\n+      auto entity = it->second.entity.lock();\n+      if (entity) {\n+        on_added(entity);\n+      }\n+      update_to.insert(*it);\n+    }\n+  }\n+}\n+\n+/// A collection of entities, indexed by their corresponding handles\n+template<typename EntityKeyType, typename EntityValueType>\n+class EntityCollection\n+  : public std::unordered_map<const EntityKeyType *, CollectionEntry<EntityValueType>>\n+{\n+public:\n+  /// Key type of the map\n+  using Key = const EntityKeyType *;\n+\n+  /// Weak pointer to entity type\n+  using EntityWeakPtr = typename EntityValueType::WeakPtr;\n+\n+  /// Shared pointer to entity type\n+  using EntitySharedPtr = typename EntityValueType::SharedPtr;\n+\n+  /// Update this collection based on the contents of another collection\n+  /**\n+   * Update the internal state of this collection, firing callbacks when entities have been\n+   * added or removed.\n+   *\n+   * \\param[in] other Collection to compare to\n+   * \\param[in] on_added Callback for when entities have been added\n+   * \\param[in] on_removed Callback for when entities have been removed\n+   */\n+  void update(\n+    const EntityCollection<EntityKeyType, EntityValueType> & other,\n+    std::function<void(const EntitySharedPtr &)> on_added,\n+    std::function<void(const EntitySharedPtr &)> on_removed)\n+  {\n+    update_entities(other, *this, on_added, on_removed);\n+  }\n+};\n+\n+/// Represent the total set of entities for a single executor\n+/**\n+ * This allows the entities to be stored from ExecutorEntitiesCollector.\n+ * The structure also makes in convenient to re-evaluate when entities have been added or removed.\n+ */\n+struct ExecutorEntitiesCollection\n+{\n+  /// Collection type for timer entities\n+  using TimerCollection = EntityCollection<rcl_timer_t, rclcpp::TimerBase>;\n+\n+  /// Collection type for subscription entities\n+  using SubscriptionCollection = EntityCollection<rcl_subscription_t, rclcpp::SubscriptionBase>;\n+\n+  /// Collection type for client entities\n+  using ClientCollection = EntityCollection<rcl_client_t, rclcpp::ClientBase>;\n+\n+  /// Collection type for service entities\n+  using ServiceCollection = EntityCollection<rcl_service_t, rclcpp::ServiceBase>;\n+\n+  /// Collection type for waitable entities\n+  using WaitableCollection = EntityCollection<rclcpp::Waitable, rclcpp::Waitable>;\n+\n+  /// Collection type for guard condition entities\n+  using GuardConditionCollection = EntityCollection<rcl_guard_condition_t, rclcpp::GuardCondition>;\n+\n+  /// Collection of timers currently in use by the executor.\n+  TimerCollection timers;\n+\n+  /// Collection of subscriptions currently in use by the executor.\n+  SubscriptionCollection subscriptions;\n+\n+  /// Collection of clients currently in use by the executor.\n+  ClientCollection clients;\n+\n+  /// Collection of services currently in use by the executor.\n+  ServiceCollection services;\n+\n+  /// Collection of guard conditions currently in use by the executor.\n+  GuardConditionCollection guard_conditions;\n+\n+  /// Collection of waitables currently in use by the executor.\n+  WaitableCollection waitables;\n+\n+  /// Check if the entities collection is empty\n+  /**\n+   * \\return true if all member collections are empty, false otherwise\n+  */\n+  bool empty() const;\n+\n+  /// Clear the entities collection\n+  void clear();\n+};\n+\n+/// Build an entities collection from callback groups\n+/**\n+ * Iterates a list of callback groups and adds entities from each valid group\n+ *\n+ * \\param[in] callback_groups List of callback groups to check for entities\n+ * \\param[inout] colletion Entities collection to populate with found entities\n+ */\n+void\n+build_entities_collection(\n+  const std::vector<rclcpp::CallbackGroup::WeakPtr> & callback_groups,\n+  ExecutorEntitiesCollection & collection);\n+\n+/// Build a queue of executables ready to be executed\n+/**\n+ * Iterates a list of entities and adds them to a queue if they are ready.\n+ *\n+ * \\param[in] collection Collection of entities corresponding to the current wait set.\n+ * \\param[in] wait_result Result of rclcpp::WaitSet::wait corresponding to the collection.\n+ * \\return A queue of executables that have been marked ready by the waitset.\n+ */\n+std::deque<rclcpp::AnyExecutable>\n+ready_executables(\n+  const ExecutorEntitiesCollection & collection,\n+  rclcpp::WaitResult<rclcpp::WaitSet> & wait_result\n+);\n+\n+}  // namespace executors\n+}  // namespace rclcpp\n+\n+#endif  // RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_\n+#define RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_\n+\n+#include <map>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <vector>\n+\n+#include \"rcpputils/thread_safety_annotations.hpp\"\n+\n+#include <rclcpp/any_executable.hpp>\n+#include <rclcpp/node_interfaces/node_base.hpp>\n+#include <rclcpp/callback_group.hpp>\n+#include <rclcpp/executors/executor_notify_waitable.hpp>\n+#include <rclcpp/visibility_control.hpp>\n+#include <rclcpp/wait_set.hpp>\n+#include <rclcpp/wait_result.hpp>\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+\n+/// Class to monitor a set of nodes and callback groups for changes in entity membership\n+/**\n+ * This is to be used with an executor to track the membership of various nodes, groups,\n+ * and entities (timers, subscriptions, clients, services, etc) and report status to the\n+ * executor.\n+ *\n+ * In general, users will add either nodes or callback groups to an executor.\n+ * Each node may have callback groups that are automatically associated with executors,\n+ * or callback groups that must be manually associated with an executor.\n+ *\n+ * This object tracks both types of callback groups as well as nodes that have been\n+ * previously added to the executor.\n+ * When a new callback group is added/removed or new entities are added/removed, the\n+ * corresponding node or callback group will signal this to the executor so that the\n+ * entity collection may be rebuilt according to that executor's implementation.\n+ *\n+ */\n+class ExecutorEntitiesCollector\n+{\n+public:\n+  /// Constructor\n+  /**\n+   * \\param[in] notify_waitable Waitable that is used to signal to the executor\n+   *   when nodes or callback groups have been added or removed.\n+   */\n+  RCLCPP_PUBLIC\n+  explicit ExecutorEntitiesCollector(\n+    std::shared_ptr<ExecutorNotifyWaitable> notify_waitable);\n+\n+  /// Destructor\n+  RCLCPP_PUBLIC\n+  ~ExecutorEntitiesCollector();\n+\n+  /// Indicate if the entities collector has pending additions or removals.\n+  /**\n+   * \\return true if there are pending additions or removals\n+   */\n+  bool has_pending() const;\n+\n+  /// Add a node to the entity collector\n+  /**\n+   * \\param[in] node_ptr a shared pointer that points to a node base interface\n+   * \\throw std::runtime_error if the node is associated with an executor\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  add_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr);\n+\n+  /// Remove a node from the entity collector\n+  /**\n+   * \\param[in] node_ptr a shared pointer that points to a node base interface\n+   * \\throw std::runtime_error if the node is associated with an executor\n+   * \\throw std::runtime_error if the node is associated with this executor\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  remove_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr);\n+\n+  /// Add a callback group to the entity collector\n+  /**\n+   * \\param[in] group_ptr a shared pointer that points to a callback group\n+   * \\throw std::runtime_error if the callback_group is associated with an executor\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  add_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr);\n+\n+  /// Remove a callback group from the entity collector\n+  /**\n+   * \\param[in] group_ptr a shared pointer that points to a callback group\n+   * \\throw std::runtime_error if the callback_group is not associated with an executor\n+   * \\throw std::runtime_error if the callback_group is not associated with this executor\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  remove_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr);\n+\n+  /// Get all callback groups known to this entity collector\n+  /**\n+   * This will include manually added and automatically added (node associated) groups\n+   * \\return vector of all callback groups\n+   */\n+  RCLCPP_PUBLIC\n+  std::vector<rclcpp::CallbackGroup::WeakPtr>\n+  get_all_callback_groups() const;\n+\n+  /// Get manually-added callback groups known to this entity collector\n+  /**\n+   * This will include callback groups that have been added via add_callback_group\n+   * \\return vector of manually-added callback groups\n+   */\n+  RCLCPP_PUBLIC\n+  std::vector<rclcpp::CallbackGroup::WeakPtr>\n+  get_manually_added_callback_groups() const;\n+\n+  /// Get automatically-added callback groups known to this entity collector\n+  /**\n+   * This will include callback groups that are associated with nodes added via add_node\n+   * \\return vector of automatically-added callback groups\n+   */\n+  RCLCPP_PUBLIC\n+  std::vector<rclcpp::CallbackGroup::WeakPtr>\n+  get_automatically_added_callback_groups() const;\n+\n+  /// Update the underlying collections\n+  /**\n+   * This will prune nodes and callback groups that are no longer valid as well\n+   * as add new callback groups from any associated nodes.\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  update_collections();\n+\n+protected:\n+  using NodeCollection = std::set<\n+    rclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n+    std::owner_less<rclcpp::node_interfaces::NodeBaseInterface::WeakPtr>>;\n+\n+  using CallbackGroupCollection = std::set<\n+    rclcpp::CallbackGroup::WeakPtr,\n+    std::owner_less<rclcpp::CallbackGroup::WeakPtr>>;\n+\n+  using WeakNodesToGuardConditionsMap = std::map<\n+    rclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n+    rclcpp::GuardCondition::WeakPtr,\n+    std::owner_less<rclcpp::node_interfaces::NodeBaseInterface::WeakPtr>>;\n+\n+  using WeakGroupsToGuardConditionsMap = std::map<\n+    rclcpp::CallbackGroup::WeakPtr,\n+    rclcpp::GuardCondition::WeakPtr,\n+    std::owner_less<rclcpp::CallbackGroup::WeakPtr>>;\n+\n+  /// Implementation of removing a node from the collector.\n+  /**\n+   * This will disassociate the node from the collector and remove any\n+   * automatically-added callback groups\n+   *\n+   * This takes and returns an iterator so it may be used as:\n+   *\n+   * it = remove_weak_node(it);\n+   *\n+   * \\param[in] weak_node iterator to the weak node to be removed\n+   * \\return Valid updated iterator in the same collection\n+   */\n+  RCLCPP_PUBLIC\n+  NodeCollection::iterator\n+  remove_weak_node(NodeCollection::iterator weak_node) RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// Implementation of removing a callback group from the collector.\n+  /**\n+   * This will disassociate the callback group from the collector\n+   *\n+   * This takes and returns an iterator so it may be used as:\n+   *\n+   * it = remove_weak_callback_group(it);\n+   *\n+   * \\param[in] weak_group_it iterator to the weak group to be removed\n+   * \\param[in] collection the collection to remove the group from\n+   *   (manually or automatically added)\n+   * \\return Valid updated iterator in the same collection\n+   */\n+  RCLCPP_PUBLIC\n+  CallbackGroupCollection::iterator\n+  remove_weak_callback_group(\n+    CallbackGroupCollection::iterator weak_group_it,\n+    CallbackGroupCollection & collection) RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// Implementation of adding a callback group\n+  /**\n+   * \\param[in] group_ptr the group to add\n+   * \\param[in] collection the collection to add the group to\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  add_callback_group_to_collection(\n+    rclcpp::CallbackGroup::SharedPtr group_ptr,\n+    CallbackGroupCollection & collection)  RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// Iterate over queued added/remove nodes and callback_groups\n+  RCLCPP_PUBLIC\n+  void\n+  process_queues() RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// Check a collection of nodes and add any new callback_groups that\n+  /// are set to be automatically associated via the node.\n+  RCLCPP_PUBLIC\n+  void\n+  add_automatically_associated_callback_groups(\n+    const NodeCollection & nodes_to_check) RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// Check all nodes and group for expired weak pointers and remove them.\n+  RCLCPP_PUBLIC\n+  void\n+  prune_invalid_nodes_and_groups() RCPPUTILS_TSA_REQUIRES(mutex_);\n+\n+  /// mutex to protect collections and pending queues\n+  mutable std::mutex mutex_;\n+\n+  /// Callback groups that were added via `add_callback_group`\n+  CallbackGroupCollection manually_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// Callback groups that were added by their association with added nodes\n+  CallbackGroupCollection automatically_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// nodes that are associated with the executor\n+  NodeCollection weak_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// Track guard conditions associated with added nodes\n+  WeakNodesToGuardConditionsMap weak_nodes_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// Track guard conditions associated with added callback groups\n+  WeakGroupsToGuardConditionsMap weak_groups_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// nodes that have been added since the last update.\n+  NodeCollection pending_added_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// nodes that have been removed since the last update.\n+  NodeCollection pending_removed_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// callback groups that have been added since the last update.\n+  CallbackGroupCollection pending_manually_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// callback groups that have been removed since the last update.\n+  CallbackGroupCollection pending_manually_removed_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n+\n+  /// Waitable to add guard conditions to\n+  std::shared_ptr<ExecutorNotifyWaitable> notify_waitable_;\n+};\n+}  // namespace executors\n+}  // namespace rclcpp\n+//\n+#endif  // RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_\n+#define RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_\n+\n+#include <functional>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+\n+#include \"rclcpp/guard_condition.hpp\"\n+#include \"rclcpp/waitable.hpp\"\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+\n+/// Maintain a collection of guard conditions from associated nodes and callback groups\n+/// to signal to the executor when associated entities have changed.\n+class ExecutorNotifyWaitable : public rclcpp::Waitable\n+{\n+public:\n+  RCLCPP_SMART_PTR_DEFINITIONS(ExecutorNotifyWaitable)\n+\n+  // Constructor\n+  /**\n+   * \\param[in] on_execute_callback Callback to execute when one of the conditions\n+   *   of this waitable has signaled the wait_set.\n+   */\n+  RCLCPP_PUBLIC\n+  explicit ExecutorNotifyWaitable(std::function<void(void)> on_execute_callback = {});\n+\n+  // Destructor\n+  RCLCPP_PUBLIC\n+  ~ExecutorNotifyWaitable() override = default;\n+\n+  RCLCPP_PUBLIC\n+  ExecutorNotifyWaitable(const ExecutorNotifyWaitable & other);\n+\n+\n+  RCLCPP_PUBLIC\n+  ExecutorNotifyWaitable & operator=(const ExecutorNotifyWaitable & other);\n+\n+  /// Add conditions to the wait set\n+  /**\n+   * \\param[inout] wait_set structure that conditions will be added to\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  add_to_wait_set(rcl_wait_set_t * wait_set) override;\n+\n+  /// Check conditions against the wait set\n+  /**\n+   * \\param[inout] wait_set structure that internal elements will be checked against.\n+   * \\return true if this waitable is ready to be executed, false otherwise.\n+   */\n+  RCLCPP_PUBLIC\n+  bool\n+  is_ready(rcl_wait_set_t * wait_set) override;\n+\n+  /// Perform work associated with the waitable.\n+  /**\n+   * This will call the callback provided in the constructor.\n+   * \\param[in] data Data to be use for the execute, if available, else nullptr.\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  execute(std::shared_ptr<void> & data) override;\n+\n+  /// Retrieve data to be used in the next execute call.\n+  /**\n+   * \\return If available, data to be used, otherwise nullptr\n+   */\n+  RCLCPP_PUBLIC\n+  std::shared_ptr<void>\n+  take_data() override;\n+\n+  /// Add a guard condition to be waited on.\n+  /**\n+   * \\param[in] guard_condition The guard condition to add.\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  add_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition);\n+\n+  /// Remove a guard condition from being waited on.\n+  /**\n+   * \\param[in] guard_condition The guard condition to remove.\n+   */\n+  RCLCPP_PUBLIC\n+  void\n+  remove_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition);\n+\n+  /// Get the number of ready guard_conditions\n+  /**\n+   * \\return The number of guard_conditions associated with the Waitable.\n+   */\n+  RCLCPP_PUBLIC\n+  size_t\n+  get_number_of_ready_guard_conditions() override;\n+\n+private:\n+  /// Callback to run when waitable executes\n+  std::function<void(void)> execute_callback_;\n+\n+  std::mutex guard_condition_mutex_;\n+\n+  /// The collection of guard conditions to be waited on.\n+  std::set<rclcpp::GuardCondition::WeakPtr,\n+    std::owner_less<rclcpp::GuardCondition::WeakPtr>> notify_guard_conditions_;\n+};\n+\n+}  // namespace executors\n+}  // namespace rclcpp\n+\n+#endif  // RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_"},{"role":"user","content":"+  [[deprecated(\"Use get_shared_notify_guard_condition or trigger_notify_guard_condition instead\")]]"},{"role":"user","content":"+  RCLCPP_PUBLIC\n+  rclcpp::GuardCondition::SharedPtr\n+  get_shared_notify_guard_condition() override;\n+\n+  RCLCPP_PUBLIC\n+  void\n+  trigger_notify_guard_condition() override;\n+"},{"role":"user","content":"-  rclcpp::GuardCondition notify_guard_condition_;\n+  std::shared_ptr<rclcpp::GuardCondition> notify_guard_condition_;"},{"role":"user","content":"-   * \\return the GuardCondition if it is valid, else thow runtime error\n+   * \\return the GuardCondition if it is valid, else throw runtime error"},{"role":"user","content":"+  /// Return a guard condition that should be notified when the internal node state changes.\n+  /**\n+   * For example, this should be notified when a publisher is added or removed.\n+   *\n+   * \\return the GuardCondition if it is valid, else nullptr\n+   */\n+  RCLCPP_PUBLIC\n+  virtual\n+  rclcpp::GuardCondition::SharedPtr\n+  get_shared_notify_guard_condition() = 0;\n+\n+  /// Trigger the guard condition that notifies of internal node state changes.\n+  /**\n+   * For example, this should be notified when a publisher is added or removed.\n+   */\n+  RCLCPP_PUBLIC\n+  virtual\n+  void\n+  trigger_notify_guard_condition() = 0;\n+"},{"role":"user","content":"+  std::function<rclcpp::Context::SharedPtr(void)> get_context,"},{"role":"user","content":"-  automatically_add_to_executor_with_node_(automatically_add_to_executor_with_node)\n+  automatically_add_to_executor_with_node_(automatically_add_to_executor_with_node),\n+  get_context_(get_context)"},{"role":"user","content":"+// \\TODO(mjcarroll) Deprecated, remove on tock"},{"role":"user","content":"+rclcpp::GuardCondition::SharedPtr\n+CallbackGroup::get_notify_guard_condition()\n+{\n+  std::lock_guard<std::recursive_mutex> lock(notify_guard_condition_mutex_);\n+  if (!this->get_context_) {\n+    throw std::runtime_error(\"Callback group was created without context and not passed context\");\n+  }\n+  auto context_ptr = this->get_context_();\n+  if (context_ptr && context_ptr->is_valid()) {\n+    if (notify_guard_condition_ && context_ptr != notify_guard_condition_->get_context()) {\n+      if (associated_with_executor_) {\n+        trigger_notify_guard_condition();\n+      }\n+      notify_guard_condition_ = nullptr;\n+    }\n+    if (!notify_guard_condition_) {\n+      notify_guard_condition_ = std::make_shared<rclcpp::GuardCondition>(context_ptr);\n+    }\n+    return notify_guard_condition_;\n+  }\n+  return nullptr;\n+}\n+"},{"role":"user","content":"-using rclcpp::AnyExecutable;"},{"role":"user","content":"-using rclcpp::ExecutorOptions;\n-using rclcpp::FutureReturnCode;"},{"role":"user","content":"-  interrupt_guard_condition_(options.context),\n+  interrupt_guard_condition_(std::make_shared<rclcpp::GuardCondition>(options.context)),"},{"role":"user","content":"-  memory_strategy_->add_guard_condition(interrupt_guard_condition_);\n+  memory_strategy_->add_guard_condition(*interrupt_guard_condition_.get());"},{"role":"user","content":"-  memory_strategy_->remove_guard_condition(&interrupt_guard_condition_);\n+  memory_strategy_->remove_guard_condition(interrupt_guard_condition_.get());"},{"role":"user","content":"-    auto callback_group_guard_condition =\n-      group_ptr->get_notify_guard_condition(node_ptr->get_context());\n+    auto callback_group_guard_condition = group_ptr->get_notify_guard_condition();"},{"role":"user","content":"-      interrupt_guard_condition_.trigger();\n+      interrupt_guard_condition_->trigger();"},{"role":"user","content":"-  const auto & gc = node_ptr->get_notify_guard_condition();\n-  weak_nodes_to_guard_conditions_[node_ptr] = &gc;\n+  const auto gc = node_ptr->get_shared_notify_guard_condition();\n+  weak_nodes_to_guard_conditions_[node_ptr] = gc.get();"},{"role":"user","content":"-  memory_strategy_->add_guard_condition(gc);\n+  memory_strategy_->add_guard_condition(*gc);"},{"role":"user","content":"-        interrupt_guard_condition_.trigger();\n+        interrupt_guard_condition_->trigger();"},{"role":"user","content":"-  memory_strategy_->remove_guard_condition(&node_ptr->get_notify_guard_condition());\n+  memory_strategy_->remove_guard_condition(node_ptr->get_shared_notify_guard_condition().get());"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"rclcpp/executors/executor_entities_collection.hpp\"\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+bool ExecutorEntitiesCollection::empty() const\n+{\n+  return subscriptions.empty() &&\n+         timers.empty() &&\n+         guard_conditions.empty() &&\n+         clients.empty() &&\n+         services.empty() &&\n+         waitables.empty();\n+}\n+\n+void ExecutorEntitiesCollection::clear()\n+{\n+  subscriptions.clear();\n+  timers.clear();\n+  guard_conditions.clear();\n+  clients.clear();\n+  services.clear();\n+  waitables.clear();\n+}\n+\n+\n+void\n+build_entities_collection(\n+  const std::vector<rclcpp::CallbackGroup::WeakPtr> & callback_groups,\n+  ExecutorEntitiesCollection & collection)\n+{\n+  collection.clear();\n+\n+  for (auto weak_group_ptr : callback_groups) {\n+    auto group_ptr = weak_group_ptr.lock();\n+    if (!group_ptr) {\n+      continue;\n+    }\n+\n+    if (group_ptr->can_be_taken_from().load()) {\n+      group_ptr->collect_all_ptrs(\n+        [&collection, weak_group_ptr](const rclcpp::SubscriptionBase::SharedPtr & subscription) {\n+          collection.subscriptions.insert(\n+            {\n+              subscription->get_subscription_handle().get(),\n+              {subscription, weak_group_ptr}\n+            });\n+        },\n+        [&collection, weak_group_ptr](const rclcpp::ServiceBase::SharedPtr & service) {\n+          collection.services.insert(\n+            {\n+              service->get_service_handle().get(),\n+              {service, weak_group_ptr}\n+            });\n+        },\n+        [&collection, weak_group_ptr](const rclcpp::ClientBase::SharedPtr & client) {\n+          collection.clients.insert(\n+            {\n+              client->get_client_handle().get(),\n+              {client, weak_group_ptr}\n+            });\n+        },\n+        [&collection, weak_group_ptr](const rclcpp::TimerBase::SharedPtr & timer) {\n+          collection.timers.insert(\n+            {\n+              timer->get_timer_handle().get(),\n+              {timer, weak_group_ptr}\n+            });\n+        },\n+        [&collection, weak_group_ptr](const rclcpp::Waitable::SharedPtr & waitable) {\n+          collection.waitables.insert(\n+            {\n+              waitable.get(),\n+              {waitable, weak_group_ptr}\n+            });\n+        }\n+      );\n+    }\n+  }\n+}\n+\n+template<typename EntityCollectionType>\n+void check_ready(\n+  EntityCollectionType & collection,\n+  std::deque<rclcpp::AnyExecutable> & executables,\n+  size_t size_of_waited_entities,\n+  typename EntityCollectionType::Key * waited_entities,\n+  std::function<bool(rclcpp::AnyExecutable &,\n+  typename EntityCollectionType::EntitySharedPtr &)> fill_executable)\n+{\n+  for (size_t ii = 0; ii < size_of_waited_entities; ++ii) {\n+    if (!waited_entities[ii]) {continue;}\n+    auto entity_iter = collection.find(waited_entities[ii]);\n+    if (entity_iter != collection.end()) {\n+      auto entity = entity_iter->second.entity.lock();\n+      if (!entity) {\n+        continue;\n+      }\n+\n+      auto callback_group = entity_iter->second.callback_group.lock();\n+      if (callback_group && !callback_group->can_be_taken_from().load()) {\n+        continue;\n+      }\n+      rclcpp::AnyExecutable exec;\n+\n+      exec.callback_group = callback_group;\n+      if (fill_executable(exec, entity)) {\n+        executables.push_back(exec);\n+      }\n+    }\n+  }\n+}\n+\n+std::deque<rclcpp::AnyExecutable>\n+ready_executables(\n+  const ExecutorEntitiesCollection & collection,\n+  rclcpp::WaitResult<rclcpp::WaitSet> & wait_result\n+)\n+{\n+  std::deque<rclcpp::AnyExecutable> ret;\n+\n+  if (wait_result.kind() != rclcpp::WaitResultKind::Ready) {\n+    return ret;\n+  }\n+  auto rcl_wait_set = wait_result.get_wait_set().get_rcl_wait_set();\n+  check_ready(\n+    collection.timers,\n+    ret,\n+    rcl_wait_set.size_of_timers,\n+    rcl_wait_set.timers,\n+    [](rclcpp::AnyExecutable & exec, auto timer) {\n+      if (!timer->call()) {\n+        return false;\n+      }\n+      exec.timer = timer;\n+      return true;\n+    });\n+\n+  check_ready(\n+    collection.subscriptions,\n+    ret,\n+    rcl_wait_set.size_of_subscriptions,\n+    rcl_wait_set.subscriptions,\n+    [](rclcpp::AnyExecutable & exec, auto subscription) {\n+      exec.subscription = subscription;\n+      return true;\n+    });\n+\n+\n+  check_ready(\n+    collection.services,\n+    ret,\n+    rcl_wait_set.size_of_services,\n+    rcl_wait_set.services,\n+    [](rclcpp::AnyExecutable & exec, auto service) {\n+      exec.service = service;\n+      return true;\n+    });\n+\n+  check_ready(\n+    collection.clients,\n+    ret,\n+    rcl_wait_set.size_of_clients,\n+    rcl_wait_set.clients,\n+    [](rclcpp::AnyExecutable & exec, auto client) {\n+      exec.client = client;\n+      return true;\n+    });\n+\n+  for (auto & [handle, entry] : collection.waitables) {\n+    auto waitable = entry.entity.lock();\n+    if (waitable && waitable->is_ready(&rcl_wait_set)) {\n+      auto group = entry.callback_group.lock();\n+      if (group && !group->can_be_taken_from().load()) {\n+        continue;\n+      }\n+\n+      rclcpp::AnyExecutable exec;\n+      exec.waitable = waitable;\n+      exec.callback_group = group;\n+      ret.push_back(exec);\n+    }\n+  }\n+  return ret;\n+}\n+\n+}  // namespace executors\n+}  // namespace rclcpp"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <set>\n+\n+#include \"rclcpp/executors/executor_entities_collector.hpp\"\n+#include \"rclcpp/executors/executor_notify_waitable.hpp\"\n+#include \"rclcpp/node_interfaces/node_base_interface.hpp\"\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+\n+ExecutorEntitiesCollector::ExecutorEntitiesCollector(\n+  std::shared_ptr<ExecutorNotifyWaitable> notify_waitable)\n+: notify_waitable_(notify_waitable)\n+{\n+}\n+\n+ExecutorEntitiesCollector::~ExecutorEntitiesCollector()\n+{\n+  for (auto weak_node_it = weak_nodes_.begin(); weak_node_it != weak_nodes_.end(); ) {\n+    weak_node_it = remove_weak_node(weak_node_it);\n+  }\n+\n+  for (auto weak_group_it = automatically_added_groups_.begin();\n+    weak_group_it != automatically_added_groups_.end(); )\n+  {\n+    weak_group_it = remove_weak_callback_group(weak_group_it, automatically_added_groups_);\n+  }\n+\n+  for (auto weak_group_it = manually_added_groups_.begin();\n+    weak_group_it != manually_added_groups_.end(); )\n+  {\n+    weak_group_it = remove_weak_callback_group(weak_group_it, manually_added_groups_);\n+  }\n+\n+  for (auto weak_node_ptr : pending_added_nodes_) {\n+    auto node_ptr = weak_node_ptr.lock();\n+    if (node_ptr) {\n+      node_ptr->get_associated_with_executor_atomic().store(false);\n+    }\n+  }\n+  pending_added_nodes_.clear();\n+  pending_removed_nodes_.clear();\n+\n+  for (auto weak_group_ptr : pending_manually_added_groups_) {\n+    auto group_ptr = weak_group_ptr.lock();\n+    if (group_ptr) {\n+      group_ptr->get_associated_with_executor_atomic().store(false);\n+    }\n+  }\n+  pending_manually_added_groups_.clear();\n+  pending_manually_removed_groups_.clear();\n+}\n+\n+bool\n+ExecutorEntitiesCollector::has_pending() const\n+{\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  return pending_manually_added_groups_.size() != 0 ||\n+         pending_manually_removed_groups_.size() != 0 ||\n+         pending_added_nodes_.size() != 0 ||\n+         pending_removed_nodes_.size() != 0;\n+}\n+\n+void\n+ExecutorEntitiesCollector::add_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)\n+{\n+  // If the node already has an executor\n+  std::atomic_bool & has_executor = node_ptr->get_associated_with_executor_atomic();\n+  if (has_executor.exchange(true)) {\n+    throw std::runtime_error(\n+            std::string(\"Node '\") + node_ptr->get_fully_qualified_name() +\n+            \"' has already been added to an executor.\");\n+  }\n+\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  bool associated = weak_nodes_.count(node_ptr) != 0;\n+  bool add_queued = pending_added_nodes_.count(node_ptr) != 0;\n+  bool remove_queued = pending_removed_nodes_.count(node_ptr) != 0;\n+\n+  if ((associated || add_queued) && !remove_queued) {\n+    throw std::runtime_error(\n+            std::string(\"Node '\") + node_ptr->get_fully_qualified_name() +\n+            \"' has already been added to this executor.\");\n+  }\n+\n+  this->pending_added_nodes_.insert(node_ptr);\n+}\n+\n+void\n+ExecutorEntitiesCollector::remove_node(\n+  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)\n+{\n+  if (!node_ptr->get_associated_with_executor_atomic().load()) {\n+    throw std::runtime_error(\n+            std::string(\"Node '\") + node_ptr->get_fully_qualified_name() +\n+            \"' needs to be associated with an executor.\");\n+  }\n+\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  bool associated = weak_nodes_.count(node_ptr) != 0;\n+  bool add_queued = pending_added_nodes_.count(node_ptr) != 0;\n+  bool remove_queued = pending_removed_nodes_.count(node_ptr) != 0;\n+\n+  if (!(associated || add_queued) || remove_queued) {\n+    throw std::runtime_error(\n+            std::string(\"Node '\") + node_ptr->get_fully_qualified_name() +\n+            \"' needs to be associated with this executor.\");\n+  }\n+\n+  this->pending_removed_nodes_.insert(node_ptr);\n+}\n+\n+void\n+ExecutorEntitiesCollector::add_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr)\n+{\n+  std::atomic_bool & has_executor = group_ptr->get_associated_with_executor_atomic();\n+  if (has_executor.exchange(true)) {\n+    throw std::runtime_error(\"Callback group has already been added to an executor.\");\n+  }\n+\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  bool associated = manually_added_groups_.count(group_ptr) != 0;\n+  bool add_queued = pending_manually_added_groups_.count(group_ptr) != 0;\n+  bool remove_queued = pending_manually_removed_groups_.count(group_ptr) != 0;\n+\n+  if ((associated || add_queued) && !remove_queued) {\n+    throw std::runtime_error(\"Callback group has already been added to this executor.\");\n+  }\n+\n+  this->pending_manually_added_groups_.insert(group_ptr);\n+}\n+\n+void\n+ExecutorEntitiesCollector::remove_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr)\n+{\n+  if (!group_ptr->get_associated_with_executor_atomic().load()) {\n+    throw std::runtime_error(\"Callback group needs to be associated with an executor.\");\n+  }\n+  /**\n+   * TODO(mjcarroll): The callback groups, being created by a node, should never outlive\n+   * the node. Since we haven't historically enforced this, turning this on may cause\n+   * previously-functional code to fail.\n+   * Consider re-enablng this check (along with corresponding CallbackGroup::has_valid_node),\n+   * when we can guarantee node/group lifetimes.\n+  if (!group_ptr->has_valid_node()) {\n+    throw std::runtime_error(\"Node must not be deleted before its callback group(s).\");\n+  }\n+  */\n+\n+  auto weak_group_ptr = rclcpp::CallbackGroup::WeakPtr(group_ptr);\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  bool associated = manually_added_groups_.count(group_ptr) != 0;\n+  bool add_queued = pending_manually_added_groups_.count(group_ptr) != 0;\n+  bool remove_queued = pending_manually_removed_groups_.count(group_ptr) != 0;\n+\n+  if (!(associated || add_queued) || remove_queued) {\n+    throw std::runtime_error(\"Callback group needs to be associated with this executor.\");\n+  }\n+\n+  this->pending_manually_removed_groups_.insert(group_ptr);\n+}\n+\n+std::vector<rclcpp::CallbackGroup::WeakPtr>\n+ExecutorEntitiesCollector::get_all_callback_groups() const\n+{\n+  std::vector<rclcpp::CallbackGroup::WeakPtr> groups;\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  for (const auto & group_ptr : manually_added_groups_) {\n+    groups.push_back(group_ptr);\n+  }\n+  for (auto const & group_ptr : automatically_added_groups_) {\n+    groups.push_back(group_ptr);\n+  }\n+  return groups;\n+}\n+\n+std::vector<rclcpp::CallbackGroup::WeakPtr>\n+ExecutorEntitiesCollector::get_manually_added_callback_groups() const\n+{\n+  std::vector<rclcpp::CallbackGroup::WeakPtr> groups;\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  for (const auto & group_ptr : manually_added_groups_) {\n+    groups.push_back(group_ptr);\n+  }\n+  return groups;\n+}\n+\n+std::vector<rclcpp::CallbackGroup::WeakPtr>\n+ExecutorEntitiesCollector::get_automatically_added_callback_groups() const\n+{\n+  std::vector<rclcpp::CallbackGroup::WeakPtr> groups;\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  for (auto const & group_ptr : automatically_added_groups_) {\n+    groups.push_back(group_ptr);\n+  }\n+  return groups;\n+}\n+\n+void\n+ExecutorEntitiesCollector::update_collections()\n+{\n+  std::lock_guard<std::mutex> lock(mutex_);\n+  this->process_queues();\n+  this->add_automatically_associated_callback_groups(this->weak_nodes_);\n+  this->prune_invalid_nodes_and_groups();\n+}\n+\n+ExecutorEntitiesCollector::NodeCollection::iterator\n+ExecutorEntitiesCollector::remove_weak_node(NodeCollection::iterator weak_node)\n+{\n+  // Disassociate the guard condition from the executor notify waitable\n+  auto guard_condition_it = weak_nodes_to_guard_conditions_.find(*weak_node);\n+  if (guard_condition_it != weak_nodes_to_guard_conditions_.end()) {\n+    this->notify_waitable_->remove_guard_condition(guard_condition_it->second);\n+    weak_nodes_to_guard_conditions_.erase(guard_condition_it);\n+  }\n+\n+  // Mark the node as disassociated (if the node is still valid)\n+  auto node_ptr = weak_node->lock();\n+  if (node_ptr) {\n+    std::atomic_bool & has_executor = node_ptr->get_associated_with_executor_atomic();\n+    has_executor.store(false);\n+  }\n+\n+  // Remove the node from tracked nodes\n+  return weak_nodes_.erase(weak_node);\n+}\n+\n+ExecutorEntitiesCollector::CallbackGroupCollection::iterator\n+ExecutorEntitiesCollector::remove_weak_callback_group(\n+  CallbackGroupCollection::iterator weak_group_it,\n+  CallbackGroupCollection & collection\n+)\n+{\n+  // Disassociate the guard condition from the executor notify waitable\n+  auto guard_condition_it = weak_groups_to_guard_conditions_.find(*weak_group_it);\n+  if (guard_condition_it != weak_groups_to_guard_conditions_.end()) {\n+    this->notify_waitable_->remove_guard_condition(guard_condition_it->second);\n+    weak_groups_to_guard_conditions_.erase(guard_condition_it);\n+  }\n+\n+  // Mark the node as disassociated (if the group is still valid)\n+  auto group_ptr = weak_group_it->lock();\n+  if (group_ptr) {\n+    /**\n+     * TODO(mjcarroll): The callback groups, being created by a node, should never outlive\n+     * the node. Since we haven't historically enforced this, turning this on may cause\n+     * previously-functional code to fail.\n+     * Consider re-enablng this check (along with corresponding CallbackGroup::has_valid_node),\n+     * when we can guarantee node/group lifetimes.\n+    if (!group_ptr->has_valid_node()) {\n+      throw std::runtime_error(\"Node must not be deleted before its callback group(s).\");\n+    }\n+    */\n+    std::atomic_bool & has_executor = group_ptr->get_associated_with_executor_atomic();\n+    has_executor.store(false);\n+  }\n+\n+  // Remove the node from tracked nodes\n+  return collection.erase(weak_group_it);\n+}\n+\n+void\n+ExecutorEntitiesCollector::add_callback_group_to_collection(\n+  rclcpp::CallbackGroup::SharedPtr group_ptr,\n+  CallbackGroupCollection & collection)\n+{\n+  auto iter = collection.insert(group_ptr);\n+  if (iter.second == false) {\n+    throw std::runtime_error(\"Callback group has already been added to this executor.\");\n+  }\n+\n+  // Store node guard condition in map and add it to the notify waitable\n+  auto group_guard_condition = group_ptr->get_notify_guard_condition();\n+  weak_groups_to_guard_conditions_.insert({group_ptr, group_guard_condition});\n+  this->notify_waitable_->add_guard_condition(group_guard_condition);\n+}\n+\n+void\n+ExecutorEntitiesCollector::process_queues()\n+{\n+  for (auto weak_node_ptr : pending_added_nodes_) {\n+    auto node_ptr = weak_node_ptr.lock();\n+    if (!node_ptr) {\n+      continue;\n+    }\n+    weak_nodes_.insert(weak_node_ptr);\n+    this->add_automatically_associated_callback_groups({weak_node_ptr});\n+\n+    // Store node guard condition in map and add it to the notify waitable\n+    auto node_guard_condition = node_ptr->get_shared_notify_guard_condition();\n+    weak_nodes_to_guard_conditions_.insert({weak_node_ptr, node_guard_condition});\n+    this->notify_waitable_->add_guard_condition(node_guard_condition);\n+  }\n+  pending_added_nodes_.clear();\n+\n+  for (auto weak_node_ptr : pending_removed_nodes_) {\n+    auto node_it = weak_nodes_.find(weak_node_ptr);\n+    if (node_it != weak_nodes_.end()) {\n+      remove_weak_node(node_it);\n+    } else {\n+      throw std::runtime_error(\"Node needs to be associated with this executor.\");\n+    }\n+\n+    auto node_ptr = weak_node_ptr.lock();\n+    if (node_ptr) {\n+      for (auto group_it = automatically_added_groups_.begin();\n+        group_it != automatically_added_groups_.end(); )\n+      {\n+        auto group_ptr = group_it->lock();\n+        if (node_ptr->callback_group_in_node(group_ptr)) {\n+          group_it = remove_weak_callback_group(group_it, automatically_added_groups_);\n+        } else {\n+          ++group_it;\n+        }\n+      }\n+    }\n+  }\n+  pending_removed_nodes_.clear();\n+\n+  for (auto weak_group_ptr : pending_manually_added_groups_) {\n+    auto group_ptr = weak_group_ptr.lock();\n+    if (group_ptr) {\n+      this->add_callback_group_to_collection(group_ptr, manually_added_groups_);\n+    }\n+  }\n+  pending_manually_added_groups_.clear();\n+\n+  for (auto weak_group_ptr : pending_manually_removed_groups_) {\n+    auto group_ptr = weak_group_ptr.lock();\n+    if (group_ptr) {\n+      auto group_it = manually_added_groups_.find(group_ptr);\n+      if (group_it != manually_added_groups_.end()) {\n+        remove_weak_callback_group(group_it, manually_added_groups_);\n+      } else {\n+        throw std::runtime_error(\n+                \"Attempting to remove a callback group not added to this executor.\");\n+      }\n+    }\n+  }\n+  pending_manually_removed_groups_.clear();\n+}\n+\n+void\n+ExecutorEntitiesCollector::add_automatically_associated_callback_groups(\n+  const NodeCollection & nodes_to_check)\n+{\n+  for (auto & weak_node : nodes_to_check) {\n+    auto node = weak_node.lock();\n+    if (node) {\n+      node->for_each_callback_group(\n+        [this, node](rclcpp::CallbackGroup::SharedPtr group_ptr)\n+        {\n+          if (!group_ptr->get_associated_with_executor_atomic().load() &&\n+          group_ptr->automatically_add_to_executor_with_node())\n+          {\n+            std::atomic_bool & has_executor = group_ptr->get_associated_with_executor_atomic();\n+            if (has_executor.exchange(true)) {\n+              throw std::runtime_error(\"Callback group has already been added to an executor.\");\n+            }\n+            this->add_callback_group_to_collection(group_ptr, this->automatically_added_groups_);\n+          }\n+        });\n+    }\n+  }\n+}\n+\n+void\n+ExecutorEntitiesCollector::prune_invalid_nodes_and_groups()\n+{\n+  for (auto node_it = weak_nodes_.begin();\n+    node_it != weak_nodes_.end(); )\n+  {\n+    if (node_it->expired()) {\n+      node_it = remove_weak_node(node_it);\n+    } else {\n+      node_it++;\n+    }\n+  }\n+  for (auto group_it = automatically_added_groups_.begin();\n+    group_it != automatically_added_groups_.end(); )\n+  {\n+    if (group_it->expired()) {\n+      group_it = remove_weak_callback_group(group_it, automatically_added_groups_);\n+    } else {\n+      group_it++;\n+    }\n+  }\n+  for (auto group_it = manually_added_groups_.begin();\n+    group_it != manually_added_groups_.end(); )\n+  {\n+    if (group_it->expired()) {\n+      group_it = remove_weak_callback_group(group_it, manually_added_groups_);\n+    } else {\n+      group_it++;\n+    }\n+  }\n+}\n+\n+}  // namespace executors\n+}  // namespace rclcpp"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <iostream>\n+\n+#include \"rclcpp/exceptions.hpp\"\n+#include \"rclcpp/executors/executor_notify_waitable.hpp\"\n+\n+namespace rclcpp\n+{\n+namespace executors\n+{\n+\n+ExecutorNotifyWaitable::ExecutorNotifyWaitable(std::function<void(void)> on_execute_callback)\n+: execute_callback_(on_execute_callback)\n+{\n+}\n+\n+ExecutorNotifyWaitable::ExecutorNotifyWaitable(const ExecutorNotifyWaitable & other)\n+: ExecutorNotifyWaitable(other.execute_callback_)\n+{\n+  this->notify_guard_conditions_ = other.notify_guard_conditions_;\n+}\n+\n+ExecutorNotifyWaitable & ExecutorNotifyWaitable::operator=(const ExecutorNotifyWaitable & other)\n+{\n+  if (this != &other) {\n+    this->execute_callback_ = other.execute_callback_;\n+    this->notify_guard_conditions_ = other.notify_guard_conditions_;\n+  }\n+  return *this;\n+}\n+\n+void\n+ExecutorNotifyWaitable::add_to_wait_set(rcl_wait_set_t * wait_set)\n+{\n+  std::lock_guard<std::mutex> lock(guard_condition_mutex_);\n+\n+  for (auto weak_guard_condition : this->notify_guard_conditions_) {\n+    auto guard_condition = weak_guard_condition.lock();\n+    if (guard_condition) {\n+      auto rcl_guard_condition = &guard_condition->get_rcl_guard_condition();\n+\n+      rcl_ret_t ret = rcl_wait_set_add_guard_condition(\n+        wait_set,\n+        rcl_guard_condition, NULL);\n+\n+      if (RCL_RET_OK != ret) {\n+        rclcpp::exceptions::throw_from_rcl_error(\n+          ret, \"failed to add guard condition to wait set\");\n+      }\n+    }\n+  }\n+}\n+\n+bool\n+ExecutorNotifyWaitable::is_ready(rcl_wait_set_t * wait_set)\n+{\n+  std::lock_guard<std::mutex> lock(guard_condition_mutex_);\n+\n+  bool any_ready = false;\n+  for (size_t ii = 0; ii < wait_set->size_of_guard_conditions; ++ii) {\n+    auto rcl_guard_condition = wait_set->guard_conditions[ii];\n+\n+    if (nullptr == rcl_guard_condition) {\n+      continue;\n+    }\n+    for (auto weak_guard_condition : this->notify_guard_conditions_) {\n+      auto guard_condition = weak_guard_condition.lock();\n+      if (guard_condition && &guard_condition->get_rcl_guard_condition() == rcl_guard_condition) {\n+        any_ready = true;\n+      }\n+    }\n+  }\n+  return any_ready;\n+}\n+\n+void\n+ExecutorNotifyWaitable::execute(std::shared_ptr<void> & data)\n+{\n+  (void) data;\n+  this->execute_callback_();\n+}\n+\n+std::shared_ptr<void>\n+ExecutorNotifyWaitable::take_data()\n+{\n+  return nullptr;\n+}\n+\n+void\n+ExecutorNotifyWaitable::add_guard_condition(rclcpp::GuardCondition::WeakPtr weak_guard_condition)\n+{\n+  std::lock_guard<std::mutex> lock(guard_condition_mutex_);\n+  auto guard_condition = weak_guard_condition.lock();\n+  if (guard_condition && notify_guard_conditions_.count(weak_guard_condition) == 0) {\n+    notify_guard_conditions_.insert(weak_guard_condition);\n+  }\n+}\n+\n+void\n+ExecutorNotifyWaitable::remove_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition)\n+{\n+  std::lock_guard<std::mutex> lock(guard_condition_mutex_);\n+  if (notify_guard_conditions_.count(guard_condition) != 0) {\n+    notify_guard_conditions_.erase(guard_condition);\n+  }\n+}\n+\n+size_t\n+ExecutorNotifyWaitable::get_number_of_ready_guard_conditions()\n+{\n+  std::lock_guard<std::mutex> lock(guard_condition_mutex_);\n+  return notify_guard_conditions_.size();\n+}\n+\n+}  // namespace executors\n+}  // namespace rclcpp"},{"role":"user","content":"-      const auto & gc = node_ptr->get_notify_guard_condition();\n-      weak_nodes_to_guard_conditions_[node_ptr] = &gc;\n+      weak_nodes_to_guard_conditions_[node_ptr] =\n+        node_ptr->get_shared_notify_guard_condition().get();"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"-    interrupt_guard_condition_.trigger();\n+    interrupt_guard_condition_->trigger();"},{"role":"user","content":"-  notify_guard_condition_(context),\n+  notify_guard_condition_(std::make_shared<rclcpp::GuardCondition>(context)),"},{"role":"user","content":"+    // Default callback group is mutually exclusive and automatically associated with\n+    // any executors that this node is added to."},{"role":"user","content":"-      NodeBase::create_callback_group(CallbackGroupType::MutuallyExclusive);\n+      NodeBase::create_callback_group(CallbackGroupType::MutuallyExclusive, true);"},{"role":"user","content":"+  auto weak_context = this->get_context()->weak_from_this();\n+  auto get_node_context = [weak_context]() -> rclcpp::Context::SharedPtr {\n+      return weak_context.lock();\n+    };\n+"},{"role":"user","content":"+    get_node_context,"},{"role":"user","content":"+\n+  // This guard condition is generally used to signal to this node's executor that a callback\n+  // group has been added that should be considered for new entities.\n+  // If this is creating the default callback group, then the notify guard condition won't be\n+  // ready or needed yet, as the node is not done being constructed and therefore cannot be added.\n+  // If the callback group is not automatically associated with this node's executors, then\n+  // triggering the guard condition is also unnecessary, it will be manually added to an exector.\n+  if (notify_guard_condition_is_valid_ && automatically_add_to_executor_with_node) {\n+    this->trigger_notify_guard_condition();\n+  }"},{"role":"user","content":"+  return *notify_guard_condition_;\n+}\n+\n+rclcpp::GuardCondition::SharedPtr\n+NodeBase::get_shared_notify_guard_condition()\n+{\n+  std::lock_guard<std::recursive_mutex> notify_condition_lock(notify_guard_condition_mutex_);\n+  if (!notify_guard_condition_is_valid_) {\n+    return nullptr;\n+  }"},{"role":"user","content":"+void\n+NodeBase::trigger_notify_guard_condition()\n+{\n+  std::lock_guard<std::recursive_mutex> notify_condition_lock(notify_guard_condition_mutex_);\n+  if (!notify_guard_condition_is_valid_) {\n+    throw std::runtime_error(\"failed to trigger notify guard condition because it is invalid\");\n+  }\n+  notify_guard_condition_->trigger();\n+}\n+"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"-  auto & node_gc = node_base_->get_notify_guard_condition();"},{"role":"user","content":"-    node_gc.trigger();\n+    node_base_->trigger_notify_guard_condition();"},{"role":"user","content":"+ament_add_gtest(test_entities_collector executors/test_entities_collector.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\" TIMEOUT 120)\n+if(TARGET test_entities_collector)\n+  ament_target_dependencies(test_entities_collector\n+    \"rcl\"\n+    \"test_msgs\")\n+  target_link_libraries(test_entities_collector ${PROJECT_NAME} mimick)\n+endif()\n+\n+ament_add_gtest(test_executor_notify_waitable executors/test_executor_notify_waitable.cpp\n+  APPEND_LIBRARY_DIRS \"${append_library_dirs}\" TIMEOUT 120)\n+if(TARGET test_executor_notify_waitable)\n+  ament_target_dependencies(test_executor_notify_waitable\n+    \"rcl\"\n+    \"test_msgs\")\n+  target_link_libraries(test_executor_notify_waitable ${PROJECT_NAME} mimick)\n+endif()\n+"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"rclcpp/executors/executor_notify_waitable.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+#include \"rclcpp/executors/executor_entities_collector.hpp\"\n+\n+#include \"../../utils/rclcpp_gtest_macros.hpp\"\n+\n+class TestExecutorEntitiesCollector : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+\n+    notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+    entities_collector = std::make_shared<rclcpp::executors::ExecutorEntitiesCollector>(\n+      notify_waitable);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  std::shared_ptr<rclcpp::executors::ExecutorNotifyWaitable> notify_waitable;\n+  std::shared_ptr<rclcpp::executors::ExecutorEntitiesCollector> entities_collector;\n+};\n+\n+TEST_F(TestExecutorEntitiesCollector, add_remove_node) {\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+\n+  // Add a node\n+  EXPECT_NO_THROW(entities_collector->add_node(node1->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector->update_collections());\n+\n+  // Remove a node\n+  EXPECT_NO_THROW(entities_collector->remove_node(node1->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector->update_collections());\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_node_twice) {\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+\n+  EXPECT_NO_THROW(entities_collector->add_node(node1->get_node_base_interface()));\n+\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector->add_node(node1->get_node_base_interface()),\n+    std::runtime_error(\"Node '/ns/node1' has already been added to an executor.\"));\n+\n+  EXPECT_NO_THROW(entities_collector->update_collections());\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_associated_node) {\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+\n+  // Simulate node being associated somewhere else\n+  auto & has_executor = node1->get_node_base_interface()->get_associated_with_executor_atomic();\n+  has_executor.store(true);\n+\n+  // Add an already-associated node\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector->remove_node(node1->get_node_base_interface()),\n+    std::runtime_error(\"Node '/ns/node1' needs to be associated with this executor.\"));\n+\n+  has_executor.store(false);\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, remove_unassociated_node) {\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+\n+  // Add an already-associated node\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector->remove_node(node1->get_node_base_interface()),\n+    std::runtime_error(\"Node '/ns/node1' needs to be associated with an executor.\"));\n+\n+  // Simulate node being associated somewhere else\n+  auto & has_executor = node1->get_node_base_interface()->get_associated_with_executor_atomic();\n+  has_executor.store(true);\n+\n+  // Add an already-associated node\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector->remove_node(node1->get_node_base_interface()),\n+    std::runtime_error(\"Node '/ns/node1' needs to be associated with this executor.\"));\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_remove_node_before_update) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  auto node2 = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  // Add and remove nodes without running updatenode\n+  EXPECT_NO_THROW(entities_collector.add_node(node1->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector.add_node(node2->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector.remove_node(node1->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector.remove_node(node2->get_node_base_interface()));\n+  EXPECT_NO_THROW(entities_collector.update_collections());\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_callback_group) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  // Add a callback group and update\n+  entities_collector.add_callback_group(cb_group);\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  // Remove callback group and update\n+  entities_collector.remove_callback_group(cb_group);\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_node_default_callback_group) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  entities_collector.add_node(node->get_node_base_interface());\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 1u);\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_callback_group_after_add_node) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  entities_collector.add_node(node->get_node_base_interface());\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 2u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 2u);\n+\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector.add_callback_group(cb_group),\n+    std::runtime_error(\"Callback group has already been added to an executor.\"));\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, add_callback_group_twice) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  entities_collector.add_callback_group(cb_group);\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  cb_group->get_associated_with_executor_atomic().exchange(false);\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector.add_callback_group(cb_group),\n+    std::runtime_error(\"Callback group has already been added to this executor.\"));\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, remove_callback_group_after_node) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  entities_collector.add_callback_group(cb_group);\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  node.reset();\n+\n+  /**\n+   * TODO(mjcarroll): Assert this when we are enforcing that nodes must be destroyed\n+   * after their created callback groups.\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector.remove_callback_group(cb_group),\n+    std::runtime_error(\"Node must not be deleted before its callback group(s).\"));\n+  */\n+  EXPECT_NO_THROW(entities_collector.update_collections());\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, remove_callback_group_after_node2) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  entities_collector.add_callback_group(cb_group);\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  EXPECT_NO_THROW(entities_collector.remove_callback_group(cb_group));\n+\n+  node.reset();\n+\n+  /**\n+   * TODO(mjcarroll): Assert this when we are enforcing that nodes must be destroyed\n+   * after their created callback groups.\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector.remove_callback_group(cb_group),\n+    std::runtime_error(\"Node must not be deleted before its callback group(s).\"));\n+  */\n+  EXPECT_NO_THROW(entities_collector.update_collections());\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, remove_callback_group_twice) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  entities_collector.add_callback_group(cb_group);\n+  entities_collector.update_collections();\n+\n+  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n+  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n+\n+  entities_collector.remove_callback_group(cb_group);\n+  entities_collector.update_collections();\n+\n+  RCLCPP_EXPECT_THROW_EQ(\n+    entities_collector.remove_callback_group(cb_group),\n+    std::runtime_error(\"Callback group needs to be associated with an executor.\"));\n+}\n+\n+TEST_F(TestExecutorEntitiesCollector, remove_node_opposite_order) {\n+  auto notify_waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n+\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  EXPECT_NO_THROW(entities_collector.add_node(node1->get_node_base_interface()));\n+\n+  auto node2 = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+  EXPECT_NO_THROW(entities_collector.add_node(node2->get_node_base_interface()));\n+\n+  EXPECT_NO_THROW(entities_collector.remove_node(node2->get_node_base_interface()));\n+}"},{"role":"user","content":"+// Copyright 2023 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <chrono>\n+#include <memory>\n+#include <stdexcept>\n+\n+#include \"rclcpp/executors/single_threaded_executor.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+#include \"rcpputils/scope_exit.hpp\"\n+\n+#include \"rclcpp/executors/executor_notify_waitable.hpp\"\n+\n+#include \"../../utils/rclcpp_gtest_macros.hpp\"\n+\n+\n+class TestExecutorNotifyWaitable : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestExecutorNotifyWaitable, construct_destruct) {\n+  {\n+    auto waitable = std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>();\n+    waitable.reset();\n+  }\n+  {\n+    auto on_execute_callback = []() {};\n+    auto waitable =\n+      std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>(on_execute_callback);\n+    waitable.reset();\n+  }\n+}\n+\n+TEST_F(TestExecutorNotifyWaitable, add_remove_guard_conditions) {\n+  auto on_execute_callback = []() {};\n+  auto waitable =\n+    std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>(on_execute_callback);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\");\n+  auto notify_guard_condition =\n+\n+    node->get_node_base_interface()->get_shared_notify_guard_condition();\n+  EXPECT_NO_THROW(waitable->add_guard_condition(notify_guard_condition));\n+  EXPECT_NO_THROW(waitable->remove_guard_condition(notify_guard_condition));\n+}\n+\n+TEST_F(TestExecutorNotifyWaitable, wait) {\n+  int on_execute_calls = 0;\n+  auto on_execute_callback = [&on_execute_calls]() {on_execute_calls++;};\n+\n+  auto waitable =\n+    std::make_shared<rclcpp::executors::ExecutorNotifyWaitable>(on_execute_callback);\n+\n+  auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\");\n+  auto notify_guard_condition =\n+    node->get_node_base_interface()->get_shared_notify_guard_condition();\n+  EXPECT_NO_THROW(waitable->add_guard_condition(notify_guard_condition));\n+\n+  auto default_cbg = node->get_node_base_interface()->get_default_callback_group();\n+  ASSERT_NE(nullptr, default_cbg->get_notify_guard_condition());\n+\n+  auto waitables = node->get_node_waitables_interface();\n+  waitables->add_waitable(std::static_pointer_cast<rclcpp::Waitable>(waitable), default_cbg);\n+\n+  rclcpp::executors::SingleThreadedExecutor executor;\n+  executor.add_node(node);\n+  executor.spin_all(std::chrono::seconds(1));\n+  EXPECT_EQ(1u, on_execute_calls);\n+\n+  // on_execute_callback doesn't change if the topology doesn't change\n+  executor.spin_all(std::chrono::seconds(1));\n+  EXPECT_EQ(1u, on_execute_calls);\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  // Wait for the subscription to be matched\n+  size_t tries = 10000;\n+  while (this->publisher->get_subscription_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(this->publisher->get_subscription_count(), 2);\n+"},{"role":"user","content":"+  // Wait for the subscription to be matched\n+  tries = 10000;\n+  while (this->publisher->get_subscription_count() < 3 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(this->publisher->get_subscription_count(), 3);\n+"},{"role":"user","content":"-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n+  rclcpp::Duration duration(std::chrono::milliseconds(1));"},{"role":"user","content":"-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n+  rclcpp::Duration duration(std::chrono::milliseconds(1));"},{"role":"user","content":"-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n+  rclcpp::Duration duration(std::chrono::milliseconds(1));"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+\n+  // Wait for the introspection to attach to our subscription\n+  size_t tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+\n+  ASSERT_EQ(sub->get_publisher_count(), 0);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+\n+  // Wait for the introspection to attach to our subscription\n+  size_t tries = 1000;\n+  while (this->sub->get_publisher_count() < 1 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 1u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+\n+  // Wait for the introspection to attach to our subscription\n+  tries = 1000;\n+  while (this->sub->get_publisher_count() < 1 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 1u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+\n+  // Wait for the introspection to attach to our subscription\n+  tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+\n+  // Wait for the introspection to attach to our subscription\n+  size_t tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+\n+  // Wait for the introspection to attach to our subscription\n+  tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+\n+  // Wait for the introspection to attach to our subscription\n+  tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);"},{"role":"user","content":"-    node->get_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+    node->get_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n+\n+  // Wait for the introspection to attach to our subscription\n+  tries = 1000;\n+  while (this->sub->get_publisher_count() < 2 && tries-- > 0) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+  ASSERT_EQ(sub->get_publisher_count(), 2u);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-`rmw_dds_common` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n+`rmw_dds_common` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use branch coverage instead of line coverage."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclcpp/executor_options.cpp"},{"role":"user","content":"+#include <memory>\n+"},{"role":"user","content":"+class ExecutorOptionsImplementation;\n+"},{"role":"user","content":"-  ExecutorOptions()\n-  : memory_strategy(rclcpp::memory_strategies::create_default_strategy()),\n-    context(rclcpp::contexts::get_global_default_context()),\n-    max_conditions(0)\n-  {}\n+  RCLCPP_PUBLIC\n+  ExecutorOptions();\n+\n+  RCLCPP_PUBLIC\n+  virtual ~ExecutorOptions();\n+\n+  RCLCPP_PUBLIC\n+  ExecutorOptions(const ExecutorOptions &);\n+\n+  RCLCPP_PUBLIC\n+  ExecutorOptions & operator=(const ExecutorOptions &);"},{"role":"user","content":"+\n+private:\n+  /// Pointer to implementation\n+  std::unique_ptr<ExecutorOptionsImplementation> impl_;"},{"role":"user","content":"+// Copyright 2024 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"rclcpp/executor_options.hpp\"\n+\n+using rclcpp::ExecutorOptions;\n+\n+namespace rclcpp\n+{\n+\n+class ExecutorOptionsImplementation {};\n+\n+}  // namespace rclcpp\n+\n+ExecutorOptions::ExecutorOptions()\n+: memory_strategy(rclcpp::memory_strategies::create_default_strategy()),\n+  context(rclcpp::contexts::get_global_default_context()),\n+  max_conditions(0),\n+  impl_(nullptr)\n+{}\n+\n+ExecutorOptions::~ExecutorOptions()\n+{}\n+\n+ExecutorOptions::ExecutorOptions(const ExecutorOptions & other)\n+{\n+  *this = other;\n+}\n+\n+ExecutorOptions & ExecutorOptions::operator=(const ExecutorOptions & other)\n+{\n+  if (this == &other) {\n+    return *this;\n+  }\n+\n+  this->memory_strategy = other.memory_strategy;\n+  this->context = other.context;\n+  this->max_conditions = other.max_conditions;\n+  if (nullptr != other.impl_) {\n+    this->impl_ = std::make_unique<ExecutorOptionsImplementation>(*other.impl_);\n+  }\n+\n+  return *this;\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-This package lets [*ROS 2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n+This package lets [*ROS 2*](https://docs.ros.org/en/rolling/) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation."},{"role":"user","content":"-    \n+"},{"role":"user","content":"-    \n+"},{"role":"user","content":"-  \n+"},{"role":"user","content":"-* `master`, which targets the upcoming ROS version, [*Foxy*](https://index.ros.org/doc/ros2/Releases/Release-Foxy-Fitzroy/).\n-* `dashing-eloquent`, which maintains compatibility with ROS releases [*Dashing*](https://index.ros.org/doc/ros2/Releases/Release-Dashing-Diademata/) and [*Eloquent*](https://index.ros.org/doc/ros2/Releases/Release-Eloquent-Elusor/)\n+* `master`, which targets the upcoming ROS version, [*Foxy*](https://docs.ros.org/en/rolling/Releases/Release-Foxy-Fitzroy.html)\n+* `dashing-eloquent`, which maintains compatibility with ROS releases [*Dashing*](https://docs.ros.org/en/rolling/Releases/Release-Dashing-Diademata.html) and [*Eloquent*](https://docs.ros.org/en/rolling/Releases/Release-Eloquent-Elusor.html)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+  EXPECT_EQ(RCL_RET_OK, rcl_arguments_fini(&prev_ini_options.arguments));"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+TEST_F(TestNode, declare_parameter_with_allow_undeclared_parameters) {\n+  // test cases without initial values\n+  auto node = std::make_shared<rclcpp::Node>(\n+    \"test_declare_parameter_node\"_unq, \"/\",\n+    rclcpp::NodeOptions{}.allow_undeclared_parameters(true));\n+  {\n+    // declared parameters static typing is still enforced\n+    auto param_name = \"parameter\"_unq;\n+    auto value = node->declare_parameter(param_name, 5);\n+    EXPECT_EQ(value, 5);\n+    EXPECT_FALSE(node->set_parameter({param_name, \"asd\"}).successful);\n+    auto param = node->get_parameter(param_name);\n+    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(param.get_value<int64_t>(), 5);\n+  }\n+  {\n+    // not for automatically declared parameters\n+    auto param_name = \"parameter\"_unq;\n+    EXPECT_TRUE(node->set_parameter({param_name, 5}).successful);\n+    auto param = node->get_parameter(param_name);\n+    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(param.get_value<int64_t>(), 5);\n+    EXPECT_TRUE(node->set_parameter({param_name, \"asd\"}).successful);\n+    param = node->get_parameter(param_name);\n+    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_STRING);\n+    EXPECT_EQ(param.get_value<std::string>(), \"asd\");\n+  }\n+  {\n+    // declare after set is invalid\n+    auto param_name = \"parameter\"_unq;\n+    EXPECT_TRUE(node->set_parameter({param_name, 5}).successful);\n+    auto param = node->get_parameter(param_name);\n+    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(param.get_value<int64_t>(), 5);\n+    EXPECT_THROW(\n+      node->declare_parameter(param_name, 5),\n+      rclcpp::exceptions::ParameterAlreadyDeclaredException);\n+  }\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclpy/action_server.cpp"},{"role":"user","content":"-            _rclpy.rclpy_action_publish_status(self._action_server._handle)\n+            self._action_server._handle.publish_status()"},{"role":"user","content":"-            _rclpy.rclpy_action_publish_feedback(\n-                self._action_server._handle, feedback_message)\n+            self._action_server._handle.publish_feedback(feedback_message)"},{"role":"user","content":"-            self._handle = _rclpy.rclpy_action_create_server(\n+            self._handle = _rclpy.ActionServer("},{"role":"user","content":"-            goal_id_exists = _rclpy.rclpy_action_server_goal_exists(self._handle, goal_info)\n+            goal_id_exists = self._handle.goal_exists(goal_info)"},{"role":"user","content":"-        _rclpy.rclpy_action_send_goal_response(\n-            self._handle,\n-            request_header,\n-            response_msg,\n-        )\n+        self._handle.send_goal_response(request_header, response_msg)"},{"role":"user","content":"-            cancel_response = _rclpy.rclpy_action_process_cancel_request(\n-                self._handle, cancel_request, self._action_type.Impl.CancelGoalService.Response)\n+            cancel_response = self._handle.process_cancel_request(\n+                cancel_request, self._action_type.Impl.CancelGoalService.Response)"},{"role":"user","content":"-        _rclpy.rclpy_action_send_cancel_response(\n-            self._handle,\n-            request_header,\n-            cancel_response,\n-        )\n+        self._handle.send_cancel_response(request_header, cancel_response)"},{"role":"user","content":"-            _rclpy.rclpy_action_send_result_response(\n-                self._handle,\n-                request_header,\n-                result_response,\n-            )\n+            self._handle.send_result_response(request_header, result_response)"},{"role":"user","content":"-        _rclpy.rclpy_action_send_result_response(\n-            self._handle,\n-            request_header,\n-            future.result(),\n-        )\n+        self._handle.send_result_response(request_header, future.result())"},{"role":"user","content":"-            ready_entities = _rclpy.rclpy_action_wait_set_is_ready(self._handle, wait_set)\n+            ready_entities = self._handle.is_ready(wait_set)"},{"role":"user","content":"-                taken_data = _rclpy.rclpy_action_take_goal_request(\n-                    self._handle,\n+                taken_data = self._handle.take_goal_request("},{"role":"user","content":"-                taken_data = _rclpy.rclpy_action_take_cancel_request(\n-                    self._handle,\n+                taken_data = self._handle.take_cancel_request("},{"role":"user","content":"-                taken_data = _rclpy.rclpy_action_take_result_request(\n-                    self._handle,\n+                taken_data = self._handle.take_result_request("},{"role":"user","content":"-                data['expired'] = _rclpy.rclpy_action_expire_goals(\n-                    self._handle,\n-                    len(self._goal_handles),\n-                )\n+                data['expired'] = self._handle.expire_goals(len(self._goal_handles))"},{"role":"user","content":"-        num_entities = _rclpy.rclpy_action_wait_set_get_num_entities(self._handle)\n+        num_entities = self._handle.get_num_entities()"},{"role":"user","content":"-            _rclpy.rclpy_action_wait_set_add(self._handle, wait_set)\n+            self._handle.add_to_waitset(wait_set)"},{"role":"user","content":"-            _rclpy.rclpy_action_notify_goal_done(self._handle)\n+            self._handle.notify_goal_done()"},{"role":"user","content":"-        with self._node.handle as node_capsule:\n-            _rclpy.rclpy_action_destroy_entity(self._handle, node_capsule)\n+        self._handle.destroy_when_not_in_use()"},{"role":"user","content":"+#include \"action_server.hpp\""},{"role":"user","content":"-\n-/// Destroy an rcl_action entity.\n-/**\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyentity Capsule pointing to the entity to destroy.\n- * \\param[in] pynode Capsule pointing to the node the action client was added to.\n- */\n-void\n-rclpy_action_destroy_entity(py::capsule pyentity, py::capsule pynode)\n-{\n-  rcl_node_t * node = static_cast<rcl_node_t *>(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \"rcl_node_t\"));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_ret_t ret;\n-  if (0 == std::strcmp(\"rcl_action_server_t\", pyentity.name())) {\n-    auto action_server = get_pointer<rcl_action_server_t *>(pyentity, \"rcl_action_server_t\");\n-    ret = rcl_action_server_fini(action_server, node);\n-    PyMem_Free(action_server);\n-  } else {\n-    std::string entity_name = pyentity.name();\n-    throw std::runtime_error(entity_name + \" is not a known entity\");\n-  }\n-\n-  if (ret != RCL_RET_OK) {\n-    std::string error_text = \"Failed to fini '\";\n-    error_text += pyentity.name();\n-    error_text += \"'\";\n-    throw rclpy::RCLError(error_text);\n-  }\n-\n-  if (PyCapsule_SetName(pyentity.ptr(), \"_destroyed_by_rclpy_action_destroy_entity_\")) {\n-    throw py::error_already_set();\n-  }\n-}\n-"},{"role":"user","content":"-/// Add an action entitiy to a wait set.\n-/**\n- * Raises RuntimeError on failure.\n- * \\param[in] pyentity Capsule pointer to an action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n- */\n-void\n-rclpy_action_wait_set_add(py::capsule pyentity, py::capsule pywait_set)\n-{\n-  auto wait_set = get_pointer<rcl_wait_set_t *>(pywait_set, \"rcl_wait_set_t\");\n-\n-  rcl_ret_t ret;\n-  if (0 == strcmp(pyentity.name(), \"rcl_action_server_t\")) {\n-    auto action_server = get_pointer<rcl_action_server_t *>(pyentity, \"rcl_action_server_t\");\n-    ret = rcl_action_wait_set_add_action_server(wait_set, action_server, NULL);\n-  } else {\n-    std::string error_text{\"Unknown entity: \"};\n-    error_text += pyentity.name();\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\"Failed to add '\"};\n-    error_text += pyentity.name();\n-    error_text += \"' to wait set\";\n-    throw rclpy::RCLError(error_text);\n-  }\n-}\n-\n-/// Get the number of wait set entities that make up an action entity.\n-/**\n- * \\param[in] pyentity Capsule pointer to an action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\return Tuple containing the number of wait set entities:\n- *   (num_subscriptions,\n- *    num_guard_conditions,\n- *    num_timers,\n- *    num_clients,\n- *    num_services)\n- */\n-py::tuple\n-rclpy_action_wait_set_get_num_entities(py::capsule pyentity)\n-{\n-  size_t num_subscriptions = 0u;\n-  size_t num_guard_conditions = 0u;\n-  size_t num_timers = 0u;\n-  size_t num_clients = 0u;\n-  size_t num_services = 0u;\n-\n-  rcl_ret_t ret;\n-  if (0 == strcmp(pyentity.name(), \"rcl_action_server_t\")) {\n-    auto action_server = get_pointer<rcl_action_server_t *>(pyentity, \"rcl_action_server_t\");\n-\n-    ret = rcl_action_server_wait_set_get_num_entities(\n-      action_server,\n-      &num_subscriptions,\n-      &num_guard_conditions,\n-      &num_timers,\n-      &num_clients,\n-      &num_services);\n-  } else {\n-    std::string error_text{\"Unknown entity: \"};\n-    error_text += pyentity.name();\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\"Failed to get number of entities for '\"};\n-    error_text += pyentity.name();\n-    error_text += \"'\";\n-    throw rclpy::RCLError(error_text);\n-  }\n-\n-  py::tuple result_tuple(5);\n-  result_tuple[0] = py::int_(num_subscriptions);\n-  result_tuple[1] = py::int_(num_guard_conditions);\n-  result_tuple[2] = py::int_(num_timers);\n-  result_tuple[3] = py::int_(num_clients);\n-  result_tuple[4] = py::int_(num_services);\n-  return result_tuple;\n-}\n-\n-/// Check if an action entity has any ready wait set entities.\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] entity Capsule pointing to the action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\param[in] pywait_set Capsule pointing to the wait set structure.\n- * \\return A tuple of Bool representing the ready sub-entities.\n- *     For a rcl_action_client_t:\n- *       (is_feedback_ready,\n- *        is_status_ready,\n- *        is_goal_response_ready,\n- *        is_cancel_response_ready,\n- *        is_result_response_ready)\n- *\n- *     For a rcl_action_server_t:\n- *       (is_goal_request_ready,\n- *        is_cancel_request_ready,\n- *        is_result_request_ready,\n- *        is_goal_expired)\n- */\n-py::tuple\n-rclpy_action_wait_set_is_ready(py::capsule pyentity, py::capsule pywait_set)\n-{\n-  auto wait_set = get_pointer<rcl_wait_set_t *>(pywait_set, \"rcl_wait_set_t\");\n-\n-  if (0 == strcmp(pyentity.name(), \"rcl_action_client_t\")) {\n-    auto action_client = get_pointer<rcl_action_client_t *>(pyentity, \"rcl_action_client_t\");\n-    bool is_feedback_ready = false;\n-    bool is_status_ready = false;\n-    bool is_goal_response_ready = false;\n-    bool is_cancel_response_ready = false;\n-    bool is_result_response_ready = false;\n-    rcl_ret_t ret = rcl_action_client_wait_set_get_entities_ready(\n-      wait_set,\n-      action_client,\n-      &is_feedback_ready,\n-      &is_status_ready,\n-      &is_goal_response_ready,\n-      &is_cancel_response_ready,\n-      &is_result_response_ready);\n-    if (RCL_RET_OK != ret) {\n-      throw rclpy::RCLError(\"Failed to get number of ready entities for action client\");\n-    }\n-\n-    py::tuple result_tuple(5);\n-    result_tuple[0] = py::bool_(is_feedback_ready);\n-    result_tuple[1] = py::bool_(is_status_ready);\n-    result_tuple[2] = py::bool_(is_goal_response_ready);\n-    result_tuple[3] = py::bool_(is_cancel_response_ready);\n-    result_tuple[4] = py::bool_(is_result_response_ready);\n-    return result_tuple;\n-  } else if (0 == strcmp(pyentity.name(), \"rcl_action_server_t\")) {\n-    auto action_server = get_pointer<rcl_action_server_t *>(pyentity, \"rcl_action_server_t\");\n-    bool is_goal_request_ready = false;\n-    bool is_cancel_request_ready = false;\n-    bool is_result_request_ready = false;\n-    bool is_goal_expired = false;\n-    rcl_ret_t ret = rcl_action_server_wait_set_get_entities_ready(\n-      wait_set,\n-      action_server,\n-      &is_goal_request_ready,\n-      &is_cancel_request_ready,\n-      &is_result_request_ready,\n-      &is_goal_expired);\n-    if (RCL_RET_OK != ret) {\n-      throw rclpy::RCLError(\"Failed to get number of ready entities for action server\");\n-    }\n-\n-    py::tuple result_tuple(4);\n-    result_tuple[0] = py::bool_(is_goal_request_ready);\n-    result_tuple[1] = py::bool_(is_cancel_request_ready);\n-    result_tuple[2] = py::bool_(is_result_request_ready);\n-    result_tuple[3] = py::bool_(is_goal_expired);\n-    return result_tuple;\n-  }\n-\n-  std::string error_text{\"Unknown entity: \"};\n-  error_text += pyentity.name();\n-  throw std::runtime_error(error_text);\n-}\n-\n-/// Create an action client.\n-/**\n- * This function will create an action client for the given action name.\n- * This client will use the typesupport defined in the action module\n- * provided as pyaction_type to send messages over the wire.\n- *\n- * On a successful call a capsule referencing the created rcl_action_client_t structure\n- * is returned.\n- *\n- * Raises ValueError if action name is invalid\n- * Raises RuntimeError if the action client could not be created.\n- *\n- * \\remark Call rclpy_action_destroy_entity() to destroy an action client.\n- * \\param[in] pynode Capsule pointing to the node to add the action client to.\n- * \\param[in] pyaction_type Action module associated with the action client.\n- * \\param[in] pyaction_name Python object containing the action name.\n- * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n- * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n- * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n- * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n- * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n- * \\return Capsule named 'rcl_action_client_t', or\n- * \\return NULL on failure.\n- */\n-py::capsule\n-rclpy_action_create_client(\n-  py::capsule pynode,\n-  py::object pyaction_type,\n-  const char * action_name,\n-  const rmw_qos_profile_t & goal_service_qos,\n-  const rmw_qos_profile_t & result_service_qos,\n-  const rmw_qos_profile_t & cancel_service_qos,\n-  const rmw_qos_profile_t & feedback_topic_qos,\n-  const rmw_qos_profile_t & status_topic_qos)\n-{\n-  rcl_node_t * node = static_cast<rcl_node_t *>(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \"rcl_node_t\"));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rosidl_action_type_support_t * ts =\n-    static_cast<rosidl_action_type_support_t *>(rclpy_common_get_type_support(\n-      pyaction_type.ptr()));\n-  if (!ts) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_action_client_options_t action_client_ops = rcl_action_client_get_default_options();\n-\n-  action_client_ops.goal_service_qos = goal_service_qos;\n-  action_client_ops.result_service_qos = result_service_qos;\n-  action_client_ops.cancel_service_qos = cancel_service_qos;\n-  action_client_ops.feedback_topic_qos = feedback_topic_qos;\n-  action_client_ops.status_topic_qos = status_topic_qos;\n-\n-  auto deleter = [](rcl_action_client_t * ptr) {PyMem_Free(ptr);};\n-  auto action_client = std::unique_ptr<rcl_action_client_t, decltype(deleter)>(\n-    static_cast<rcl_action_client_t *>(PyMem_Malloc(sizeof(rcl_action_client_t))),\n-    deleter);\n-  if (!action_client) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *action_client = rcl_action_get_zero_initialized_client();\n-  rcl_ret_t ret = rcl_action_client_init(\n-    action_client.get(),\n-    node,\n-    ts,\n-    action_name,\n-    &action_client_ops);\n-  if (ret == RCL_RET_ACTION_NAME_INVALID) {\n-    std::string error_text{\"Failed to create action client due to invalid topic name '\"};\n-    error_text += action_name;\n-    error_text += \"' : \";\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  } else if (ret != RCL_RET_OK) {\n-    std::string error_text{\"Failed to create action client: \"};\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  }\n-\n-  return py::capsule(action_client.release(), \"rcl_action_client_t\");\n-}\n-\n-/// Create an action server.\n-/**\n- * This function will create an action server for the given action name.\n- * This server will use the typesupport defined in the action module\n- * provided as pyaction_type to send messages over the wire.\n- *\n- * On a successful call a capsule referencing the created rcl_action_server_t structure\n- * is returned.\n- *\n- * Raises AttributeError if action type is invalid\n- * Raises ValueError if action name is invalid\n- * Raises RuntimeError if the action server could not be created.\n- *\n- * \\remark Call rclpy_action_destroy_entity() to destroy an action server.\n- * \\param[in] pynode Capsule pointing to the node to add the action server to.\n- * \\param[in] pyaction_type Action module associated with the action server.\n- * \\param[in] pyaction_name Python object containing the action name.\n- * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n- * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n- * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n- * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n- * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n- * \\return Capsule named 'rcl_action_server_t', or\n- * \\return NULL on failure.\n- */\n-py::capsule\n-rclpy_action_create_server(\n-  py::capsule pynode,\n-  const rclpy::Clock & rclpy_clock,\n-  py::object pyaction_type,\n-  const char * action_name,\n-  const rmw_qos_profile_t & goal_service_qos,\n-  const rmw_qos_profile_t & result_service_qos,\n-  const rmw_qos_profile_t & cancel_service_qos,\n-  const rmw_qos_profile_t & feedback_topic_qos,\n-  const rmw_qos_profile_t & status_topic_qos,\n-  double result_timeout)\n-{\n-  rcl_node_t * node = static_cast<rcl_node_t *>(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \"rcl_node_t\"));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_clock_t * clock = rclpy_clock.rcl_ptr();\n-\n-  rosidl_action_type_support_t * ts = static_cast<rosidl_action_type_support_t *>(\n-    rclpy_common_get_type_support(pyaction_type.ptr()));\n-  if (!ts) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();\n-\n-  action_server_ops.goal_service_qos = goal_service_qos;\n-  action_server_ops.result_service_qos = result_service_qos;\n-  action_server_ops.cancel_service_qos = cancel_service_qos;\n-  action_server_ops.feedback_topic_qos = feedback_topic_qos;\n-  action_server_ops.status_topic_qos = status_topic_qos;\n-  action_server_ops.result_timeout.nanoseconds = (rcl_duration_value_t)RCL_S_TO_NS(result_timeout);\n-\n-  auto deleter = [](rcl_action_server_t * ptr) {PyMem_Free(ptr);};\n-  auto action_server = std::unique_ptr<rcl_action_server_t, decltype(deleter)>(\n-    static_cast<rcl_action_server_t *>(PyMem_Malloc(sizeof(rcl_action_server_t))),\n-    deleter);\n-  if (!action_server) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *action_server = rcl_action_get_zero_initialized_server();\n-  rcl_ret_t ret = rcl_action_server_init(\n-    action_server.get(),\n-    node,\n-    clock,\n-    ts,\n-    action_name,\n-    &action_server_ops);\n-  if (ret == RCL_RET_ACTION_NAME_INVALID) {\n-    std::string error_text{\"Failed to create action server due to invalid topic name '\"};\n-    error_text += action_name;\n-    error_text += \"' : \";\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  } else if (ret != RCL_RET_OK) {\n-    std::string error_text{\"Failed to create action server: \"};\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  }\n-\n-  return py::capsule(action_server.release(), \"rcl_action_server_t\");\n-}\n-\n-\n-/// Check if an action server is available for the given action client.\n-/**\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pynode Capsule pointing to the node to associated with the action client.\n- * \\param[in] pyaction_client The action client to use when checking for an available server.\n- * \\return True if an action server is available, False otherwise.\n- */\n-bool\n-rclpy_action_server_is_available(py::capsule pynode, py::capsule pyaction_client)\n-{\n-  rcl_node_t * node = static_cast<rcl_node_t *>(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \"rcl_node_t\"));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  auto action_client = get_pointer<rcl_action_client_t *>(pyaction_client, \"rcl_action_client_t\");\n-\n-  bool is_available = false;\n-  rcl_ret_t ret = rcl_action_server_is_available(node, action_client, &is_available);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed to check if action server is available\");\n-  }\n-  return is_available;\n-}\n-\n-#define SEND_SERVICE_RESPONSE(Type) \\\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\"); \\\n-  destroy_ros_message_signature * destroy_ros_message = NULL; \\\n-  void * raw_ros_response = rclpy_convert_from_py(pyresponse.ptr(), &destroy_ros_message); \\\n-  if (!raw_ros_response) { \\\n-    throw py::error_already_set(); \\\n-  } \\\n-  rcl_ret_t ret = rcl_action_send_ ## Type ## _response(action_server, header, raw_ros_response); \\\n-  destroy_ros_message(raw_ros_response); \\\n-  if (ret != RCL_RET_OK) { \\\n-    throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n-  }\n-\n-#define TAKE_SERVICE_REQUEST(Type) \\\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\"); \\\n-  destroy_ros_message_signature * destroy_ros_message = NULL; \\\n-  /* taken_msg is always destroyed in this function */ \\\n-  void * taken_msg = rclpy_create_from_py(pymsg_type.ptr(), &destroy_ros_message); \\\n-  if (!taken_msg) { \\\n-    throw py::error_already_set(); \\\n-  } \\\n-  auto taken_msg_ptr = \\\n-    std::unique_ptr<void, destroy_ros_message_signature *>(taken_msg, destroy_ros_message); \\\n-  rmw_request_id_t header; \\\n-  rcl_ret_t ret = \\\n-    rcl_action_take_ ## Type ## _request(action_server, &header, taken_msg_ptr.get()); \\\n-  /* Create the tuple to return */ \\\n-  py::tuple pytuple(2); \\\n-  if (ret == RCL_RET_ACTION_CLIENT_TAKE_FAILED || ret == RCL_RET_ACTION_SERVER_TAKE_FAILED) { \\\n-    pytuple[0] = py::none(); \\\n-    pytuple[1] = py::none(); \\\n-    return pytuple; \\\n-  } else if (ret != RCL_RET_OK) { \\\n-    throw rclpy::RCLError(\"Failed to take \" #Type); \\\n-  } \\\n-  pytuple[0] = header; \\\n-  pytuple[1] = py::reinterpret_steal<py::object>( \\\n-    rclpy_convert_to_py(taken_msg_ptr.get(), pymsg_type.ptr())); \\\n-  return pytuple;\n-\n-/// Take an action goal request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pygoal_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pygoal_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \"rclpy.rmw_request_id_t\" type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_goal_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(goal)\n-}\n-\n-/// Send an action goal response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pygoal_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] header Pointer to the message header.\n- * \\param[in] pygoal_response The response message to send.\n- * \\return None\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_goal_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(goal)\n-}\n-\n-/// Take an action result request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyresult_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pyresult_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \"rclpy.rmw_request_id_t\" type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_result_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(result)\n-}\n-\n-/// Send an action result response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyresult_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] pyheader Pointer to the message header.\n- * \\param[in] pyresult_response The response message to send.\n- * \\return None\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_result_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(result)\n-}\n-\n-/// Take an action cancel request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pycancel_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pycancel_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \"rmw_request_id_t\" type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_cancel_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(cancel)\n-}\n-\n-/// Send an action cancel response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pycancel_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] pyheader Pointer to the message header.\n- * \\param[in] pycancel_response The response message to send.\n- * \\return sequence_number PyLong object representing the index of the sent response, or\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_cancel_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(cancel)\n-}\n-\n-\n-/// Publish a feedback message from a given action server.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyfeedback_msg.\n- * Raises RuntimeError on failure while publishing a feedback message.\n- *\n- * \\param[in] pyaction_server Capsule pointing to the action server to publish the message.\n- * \\param[in] pyfeedback_msg The feedback message to publish.\n- * \\return None\n- */\n-void\n-rclpy_action_publish_feedback(py::capsule pyaction_server, py::object pymsg)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  void * raw_ros_message = rclpy_convert_from_py(pymsg.ptr(), &destroy_ros_message);\n-  if (!raw_ros_message) {\n-    throw py::error_already_set();\n-  }\n-  auto raw_ros_message_ptr = std::unique_ptr<void, decltype(destroy_ros_message)>(\n-    raw_ros_message, destroy_ros_message);\n-  rcl_ret_t ret = rcl_action_publish_feedback(action_server, raw_ros_message);\n-  if (ret != RCL_RET_OK) {\n-    throw rclpy::RCLError(\"Failed to publish feedback with an action server\");\n-  }\n-}\n-\n-/// Publish a status message from a given action server.\n-/**\n- * Raises RuntimeError on failure while publishing a status message.\n- *\n- * \\param[in] pyaction_server Capsule pointing to the action server to publish the message.\n- * \\return None\n- */\n-void\n-rclpy_action_publish_status(py::capsule pyaction_server)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-  rcl_action_goal_status_array_t status_message =\n-    rcl_action_get_zero_initialized_goal_status_array();\n-  rcl_ret_t ret = rcl_action_get_goal_status_array(action_server, &status_message);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed get goal status array\");\n-  }\n-\n-  ret = rcl_action_publish_status(action_server, &status_message);\n-\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed publish goal status array\");\n-  }\n-}\n-\n-rclpy::ActionGoalHandle\n-rclpy_action_accept_new_goal(py::capsule pyaction_server, py::object pygoal_info_msg)\n-{\n-  return rclpy::ActionGoalHandle(pyaction_server, pygoal_info_msg);\n-}\n-\n-void\n-rclpy_action_notify_goal_done(py::capsule pyaction_server)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-  rcl_ret_t ret = rcl_action_notify_goal_done(action_server);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed to notfiy action server of goal done\");\n-  }\n-}\n-\n-bool\n-rclpy_action_server_goal_exists(py::capsule pyaction_server, py::object pygoal_info)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  rcl_action_goal_info_t * goal_info = static_cast<rcl_action_goal_info_t *>(\n-    rclpy_convert_from_py(pygoal_info.ptr(), &destroy_ros_message));\n-  if (!goal_info) {\n-    throw py::error_already_set();\n-  }\n-\n-  auto goal_info_ptr = std::unique_ptr<rcl_action_goal_info_t, decltype(destroy_ros_message)>(\n-    goal_info, destroy_ros_message);\n-\n-  return rcl_action_server_goal_exists(action_server, goal_info);\n-}\n-\n-py::object\n-rclpy_action_process_cancel_request(\n-  py::capsule pyaction_server, py::object pycancel_request, py::object pycancel_response_type)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-\n-  destroy_ros_message_signature * destroy_cancel_request = NULL;\n-  rcl_action_cancel_request_t * cancel_request = static_cast<rcl_action_cancel_request_t *>(\n-    rclpy_convert_from_py(pycancel_request.ptr(), &destroy_cancel_request));\n-  if (!cancel_request) {\n-    throw py::error_already_set();\n-  }\n-  auto cancel_request_ptr =\n-    std::unique_ptr<rcl_action_cancel_request_t, decltype(destroy_cancel_request)>(\n-    cancel_request, destroy_cancel_request);\n-\n-  rcl_action_cancel_response_t cancel_response = rcl_action_get_zero_initialized_cancel_response();\n-  rcl_ret_t ret = rcl_action_process_cancel_request(\n-    action_server, cancel_request, &cancel_response);\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\"Failed to process cancel request: \"};\n-    error_text += rcl_get_error_string().str;\n-    rcl_reset_error();\n-\n-    ret = rcl_action_cancel_response_fini(&cancel_response);\n-    if (RCL_RET_OK != ret) {\n-      error_text += \".  Also failed to cleanup response: \";\n-      error_text += rcl_get_error_string().str;\n-      rcl_reset_error();\n-    }\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  PyObject * pycancel_response =\n-    rclpy_convert_to_py(&cancel_response.msg, pycancel_response_type.ptr());\n-  if (!pycancel_response) {\n-    rcl_ret_t ignore = rcl_action_cancel_response_fini(&cancel_response);\n-    (void) ignore;\n-    throw py::error_already_set();\n-  }\n-  py::object return_value = py::reinterpret_steal<py::object>(pycancel_response);\n-\n-  ret = rcl_action_cancel_response_fini(&cancel_response);\n-\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed to finalize cancel response\");\n-  }\n-  return return_value;\n-}\n-\n-py::tuple\n-rclpy_action_expire_goals(py::capsule pyaction_server, int64_t max_num_goals)\n-{\n-  auto action_server = get_pointer<rcl_action_server_t *>(pyaction_server, \"rcl_action_server_t\");\n-\n-  auto expired_goals =\n-    std::unique_ptr<rcl_action_goal_info_t[]>(new rcl_action_goal_info_t[max_num_goals]);\n-  size_t num_expired;\n-  rcl_ret_t ret = rcl_action_expire_goals(\n-    action_server, expired_goals.get(), max_num_goals, &num_expired);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\"Failed to expire goals\");\n-  }\n-\n-  // Get Python GoalInfo type\n-  py::module pyaction_msgs_module = py::module::import(\"action_msgs.msg\");\n-  py::object pygoal_info_class = pyaction_msgs_module.attr(\"GoalInfo\");\n-  py::object pygoal_info_type = pygoal_info_class();\n-\n-  // Create a tuple of GoalInfo instances to return\n-  py::tuple result_tuple(num_expired);\n-\n-  for (size_t i = 0; i < num_expired; ++i) {\n-    result_tuple[i] = py::reinterpret_steal<py::object>(\n-      rclpy_convert_to_py(&(expired_goals.get()[i]), pygoal_info_type.ptr()));\n-  }\n-\n-  return result_tuple;\n-}\n-\n-"},{"role":"user","content":"-  m.def(\n-    \"rclpy_action_destroy_entity\", &rclpy_action_destroy_entity,\n-    \"Destroy a rclpy_action entity.\");"},{"role":"user","content":"-  m.def(\n-    \"rclpy_action_wait_set_add\", &rclpy_action_wait_set_add,\n-    \"Add an action entitiy to a wait set.\");\n-  m.def(\n-    \"rclpy_action_wait_set_get_num_entities\", &rclpy_action_wait_set_get_num_entities,\n-    \"Get the number of wait set entities for an action entitity.\");\n-  m.def(\n-    \"rclpy_action_wait_set_is_ready\", &rclpy_action_wait_set_is_ready,\n-    \"Check if an action entity has any sub-entities ready in a wait set.\");\n-  m.def(\n-    \"rclpy_action_create_server\", &rclpy_action_create_server,\n-    \"Create an action server.\");\n-  m.def(\n-    \"rclpy_action_server_is_available\", &rclpy_action_server_is_available,\n-    \"Check if an action server is available for a given client.\");\n-  m.def(\n-    \"rclpy_action_take_goal_request\", &rclpy_action_take_goal_request,\n-    \"Take a goal request.\");\n-  m.def(\n-    \"rclpy_action_send_goal_response\", &rclpy_action_send_goal_response,\n-    \"Send a goal response.\");\n-  m.def(\n-    \"rclpy_action_take_result_request\", &rclpy_action_take_result_request,\n-    \"Take a result request.\");\n-  m.def(\n-    \"rclpy_action_send_result_response\", &rclpy_action_send_result_response,\n-    \"Send a result response.\");\n-  m.def(\n-    \"rclpy_action_take_cancel_request\", &rclpy_action_take_cancel_request,\n-    \"Take a cancel request.\");\n-  m.def(\n-    \"rclpy_action_send_cancel_response\", &rclpy_action_send_cancel_response,\n-    \"Send a cancel response.\");\n-  m.def(\n-    \"rclpy_action_publish_feedback\", &rclpy_action_publish_feedback,\n-    \"Publish a feedback message.\");\n-  m.def(\n-    \"rclpy_action_publish_status\", &rclpy_action_publish_status,\n-    \"Publish a status message.\");\n-  m.def(\n-    \"rclpy_action_accept_new_goal\", &rclpy_action_accept_new_goal,\n-    \"Accept a new goal using an action server.\");\n-  m.def(\n-    \"rclpy_action_notify_goal_done\", &rclpy_action_notify_goal_done,\n-    \"Notify and action server that a goal has reached a terminal state.\");\n-"},{"role":"user","content":"+  define_action_server(m);"},{"role":"user","content":"-  m.def(\n-    \"rclpy_action_server_goal_exists\", &rclpy_action_server_goal_exists,\n-    \"Check if a goal being tracked by an action server.\");\n-  m.def(\n-    \"rclpy_action_process_cancel_request\", &rclpy_action_process_cancel_request,\n-    \"Process a cancel request to determine what goals should be canceled.\");\n-  m.def(\n-    \"rclpy_action_expire_goals\", &rclpy_action_expire_goals,\n-    \"Expire goals associated with an action server.\");"},{"role":"user","content":"-template<typename T>\n-T\n-get_pointer(py::capsule & capsule, const char * name)\n-{\n-  if (strcmp(name, capsule.name())) {\n-    std::string error_text{\"Expected capusle with name '\"};\n-    error_text += name;\n-    error_text += \"' but got '\";\n-    error_text += capsule.name();\n-    error_text += \"'\";\n-    throw py::value_error(error_text);\n-  }\n-  // TODO(sloretz) use get_pointer() in pybind11 2.6+\n-  return static_cast<T>(capsule);\n-}\n-"},{"role":"user","content":"-  py::capsule pyaction_server, py::object pygoal_info_msg)\n+  rclpy::ActionServer & action_server, py::object pygoal_info_msg)"},{"role":"user","content":"-  auto action_server = get_pointer<rcl_action_server_t *>(\n-    pyaction_server, \"rcl_action_server_t\");\n-"},{"role":"user","content":"-  auto rcl_handle = rcl_action_accept_new_goal(action_server, goal_info_msg);\n+  auto rcl_handle = rcl_action_accept_new_goal(\n+    action_server.rcl_ptr(), goal_info_msg);"},{"role":"user","content":"-    module,\n-    \"ActionGoalHandle\")\n-  .def(py::init<py::capsule, py::object>())\n+    module, \"ActionGoalHandle\")\n+  .def(py::init<rclpy::ActionServer &, py::object>())"},{"role":"user","content":"+#include \"action_server.hpp\""},{"role":"user","content":"-class ActionGoalHandle : public Destroyable\n+\n+class ActionServer;\n+\n+class ActionGoalHandle : public Destroyable, public std::enable_shared_from_this<ActionGoalHandle>"},{"role":"user","content":"-  ActionGoalHandle(py::capsule pyaction_server, py::object pygoal_info_msg);\n+  ActionGoalHandle(rclpy::ActionServer & action_server, py::object pygoal_info_msg);"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Include pybind11 before rclpy_common/handle.h includes Python.h\n+#include <pybind11/pybind11.h>\n+\n+#include <rcl/error_handling.h>\n+#include <rcpputils/scope_exit.hpp>\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rclpy_common/common.h\"\n+#include \"rclpy_common/exceptions.hpp\"\n+#include \"rclpy_common/handle.h\"\n+\n+#include \"action_server.hpp\"\n+\n+namespace rclpy\n+{\n+\n+void\n+ActionServer::destroy()\n+{\n+  rcl_action_server_.reset();\n+  node_handle_.reset();\n+}\n+\n+ActionServer::ActionServer(\n+  py::capsule pynode,\n+  const rclpy::Clock & rclpy_clock,\n+  py::object pyaction_type,\n+  const char * action_name,\n+  const rmw_qos_profile_t & goal_service_qos,\n+  const rmw_qos_profile_t & result_service_qos,\n+  const rmw_qos_profile_t & cancel_service_qos,\n+  const rmw_qos_profile_t & feedback_topic_qos,\n+  const rmw_qos_profile_t & status_topic_qos,\n+  double result_timeout)\n+: node_handle_(std::make_shared<Handle>(pynode))\n+{\n+  auto node = node_handle_->cast<rcl_node_t *>(\"rcl_node_t\");\n+\n+  rcl_clock_t * clock = rclpy_clock.rcl_ptr();\n+\n+  rosidl_action_type_support_t * ts = static_cast<rosidl_action_type_support_t *>(\n+    rclpy_common_get_type_support(pyaction_type.ptr()));\n+  if (!ts) {\n+    throw py::error_already_set();\n+  }\n+\n+  rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();\n+\n+  action_server_ops.goal_service_qos = goal_service_qos;\n+  action_server_ops.result_service_qos = result_service_qos;\n+  action_server_ops.cancel_service_qos = cancel_service_qos;\n+  action_server_ops.feedback_topic_qos = feedback_topic_qos;\n+  action_server_ops.status_topic_qos = status_topic_qos;\n+  action_server_ops.result_timeout.nanoseconds = (rcl_duration_value_t)RCL_S_TO_NS(result_timeout);\n+\n+  rcl_action_server_ = std::shared_ptr<rcl_action_server_t>(\n+    new rcl_action_server_t,\n+    [this](rcl_action_server_t * action_server)\n+    {\n+      auto node = node_handle_->cast_or_warn<rcl_node_t *>(\"rcl_node_t\");\n+\n+      rcl_ret_t ret = rcl_action_server_fini(action_server, node);\n+      if (RCL_RET_OK != ret) {\n+        // Warning should use line number of the current stack frame\n+        int stack_level = 1;\n+        PyErr_WarnFormat(\n+          PyExc_RuntimeWarning, stack_level, \"Failed to fini publisher: %s\",\n+          rcl_get_error_string().str);\n+        rcl_reset_error();\n+      }\n+      delete action_server;\n+    });\n+\n+  *rcl_action_server_ = rcl_action_get_zero_initialized_server();\n+\n+  rcl_ret_t ret = rcl_action_server_init(\n+    rcl_action_server_.get(),\n+    node,\n+    clock,\n+    ts,\n+    action_name,\n+    &action_server_ops);\n+  if (RCL_RET_ACTION_NAME_INVALID == ret) {\n+    std::string error_text{\"Failed to create action server due to invalid topic name '\"};\n+    error_text += action_name;\n+    error_text += \"' : \";\n+    error_text += rcl_get_error_string().str;\n+    rcl_reset_error();\n+    throw py::value_error(error_text);\n+  } else if (RCL_RET_OK != ret) {\n+    std::string error_text{\"Failed to create action server: \"};\n+    error_text += rcl_get_error_string().str;\n+    rcl_reset_error();\n+    throw py::value_error(error_text);\n+  }\n+}\n+\n+#define TAKE_SERVICE_REQUEST(Type) \\\n+  /* taken_msg is always destroyed in this function */ \\\n+  auto taken_msg = create_from_py(pymsg_type); \\\n+  rmw_request_id_t header; \\\n+  rcl_ret_t ret = \\\n+    rcl_action_take_ ## Type ## _request(rcl_action_server_.get(), &header, taken_msg.get()); \\\n+  /* Create the tuple to return */ \\\n+  if (ret == RCL_RET_ACTION_CLIENT_TAKE_FAILED || ret == RCL_RET_ACTION_SERVER_TAKE_FAILED) { \\\n+    return py::make_tuple(py::none(), py::none()); \\\n+  } else if (RCL_RET_OK != ret) { \\\n+    throw rclpy::RCLError(\"Failed to take \" #Type); \\\n+  } \\\n+  return py::make_tuple(header, convert_to_py(taken_msg.get(), pymsg_type)); \\\n+\n+py::tuple\n+ActionServer::take_goal_request(py::object pymsg_type)\n+{\n+  TAKE_SERVICE_REQUEST(goal)\n+}\n+\n+py::tuple\n+ActionServer::take_result_request(py::object pymsg_type)\n+{\n+  TAKE_SERVICE_REQUEST(result)\n+}\n+\n+#define SEND_SERVICE_RESPONSE(Type) \\\n+  auto ros_response = convert_from_py(pyresponse); \\\n+  rcl_ret_t ret = rcl_action_send_ ## Type ## _response( \\\n+    rcl_action_server_.get(), header, ros_response.get()); \\\n+  if (RCL_RET_OK != ret) { \\\n+    throw rclpy::RCLError(\"Failed to send \" #Type \" response\"); \\\n+  }\n+\n+void\n+ActionServer::send_goal_response(\n+  rmw_request_id_t * header, py::object pyresponse)\n+{\n+  SEND_SERVICE_RESPONSE(goal)\n+}\n+\n+void\n+ActionServer::send_result_response(\n+  rmw_request_id_t * header, py::object pyresponse)\n+{\n+  SEND_SERVICE_RESPONSE(result)\n+}\n+\n+py::tuple\n+ActionServer::take_cancel_request(py::object pymsg_type)\n+{\n+  TAKE_SERVICE_REQUEST(cancel)\n+}\n+\n+void\n+ActionServer::send_cancel_response(\n+  rmw_request_id_t * header, py::object pyresponse)\n+{\n+  SEND_SERVICE_RESPONSE(cancel)\n+}\n+\n+void\n+ActionServer::publish_feedback(py::object pymsg)\n+{\n+  auto ros_message = convert_from_py(pymsg);\n+  rcl_ret_t ret = rcl_action_publish_feedback(rcl_action_server_.get(), ros_message.get());\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed to publish feedback with an action server\");\n+  }\n+}\n+\n+void\n+ActionServer::publish_status()\n+{\n+  rcl_action_goal_status_array_t status_message =\n+    rcl_action_get_zero_initialized_goal_status_array();\n+  rcl_ret_t ret = rcl_action_get_goal_status_array(rcl_action_server_.get(), &status_message);\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed get goal status array\");\n+  }\n+\n+  ret = rcl_action_publish_status(rcl_action_server_.get(), &status_message);\n+\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed publish goal status array\");\n+  }\n+}\n+\n+void\n+ActionServer::notify_goal_done()\n+{\n+  rcl_ret_t ret = rcl_action_notify_goal_done(rcl_action_server_.get());\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed to notfiy action server of goal done\");\n+  }\n+}\n+\n+bool\n+ActionServer::goal_exists(py::object pygoal_info)\n+{\n+  auto goal_info = convert_from_py(pygoal_info);\n+  rcl_action_goal_info_t * goal_info_type = static_cast<rcl_action_goal_info_t *>(goal_info.get());\n+  return rcl_action_server_goal_exists(rcl_action_server_.get(), goal_info_type);\n+}\n+\n+py::tuple\n+ActionServer::get_num_entities()\n+{\n+  size_t num_subscriptions = 0u;\n+  size_t num_guard_conditions = 0u;\n+  size_t num_timers = 0u;\n+  size_t num_clients = 0u;\n+  size_t num_services = 0u;\n+\n+  rcl_ret_t ret = rcl_action_server_wait_set_get_num_entities(\n+    rcl_action_server_.get(),\n+    &num_subscriptions,\n+    &num_guard_conditions,\n+    &num_timers,\n+    &num_clients,\n+    &num_services);\n+\n+  if (RCL_RET_OK != ret) {\n+    std::string error_text{\"Failed to get number of entities for 'rcl_action_server_t'\"};\n+    throw rclpy::RCLError(error_text);\n+  }\n+\n+  py::tuple result_tuple(5);\n+  result_tuple[0] = py::int_(num_subscriptions);\n+  result_tuple[1] = py::int_(num_guard_conditions);\n+  result_tuple[2] = py::int_(num_timers);\n+  result_tuple[3] = py::int_(num_clients);\n+  result_tuple[4] = py::int_(num_services);\n+  return result_tuple;\n+}\n+\n+py::tuple\n+ActionServer::is_ready(py::capsule pywait_set)\n+{\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+  bool is_goal_request_ready = false;\n+  bool is_cancel_request_ready = false;\n+  bool is_result_request_ready = false;\n+  bool is_goal_expired = false;\n+  rcl_ret_t ret = rcl_action_server_wait_set_get_entities_ready(\n+    wait_set,\n+    rcl_action_server_.get(),\n+    &is_goal_request_ready,\n+    &is_cancel_request_ready,\n+    &is_result_request_ready,\n+    &is_goal_expired);\n+\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed to get number of ready entities for action server\");\n+  }\n+\n+  py::tuple result_tuple(4);\n+  result_tuple[0] = py::bool_(is_goal_request_ready);\n+  result_tuple[1] = py::bool_(is_cancel_request_ready);\n+  result_tuple[2] = py::bool_(is_result_request_ready);\n+  result_tuple[3] = py::bool_(is_goal_expired);\n+  return result_tuple;\n+}\n+\n+void\n+ActionServer::add_to_waitset(py::capsule pywait_set)\n+{\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+  rcl_ret_t ret = rcl_action_wait_set_add_action_server(wait_set, rcl_action_server_.get(), NULL);\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed to add 'rcl_action_server_t' to wait set\");\n+  }\n+}\n+\n+py::object\n+ActionServer::process_cancel_request(\n+  py::object pycancel_request, py::object pycancel_response_type)\n+{\n+  auto cancel_request = convert_from_py(pycancel_request);\n+  rcl_action_cancel_request_t * cancel_request_tmp = static_cast<rcl_action_cancel_request_t *>(\n+    cancel_request.get());\n+\n+  rcl_action_cancel_response_t cancel_response = rcl_action_get_zero_initialized_cancel_response();\n+  rcl_ret_t ret = rcl_action_process_cancel_request(\n+    rcl_action_server_.get(), cancel_request_tmp, &cancel_response);\n+\n+  if (RCL_RET_OK != ret) {\n+    std::string error_text{\"Failed to process cancel request: \"};\n+    error_text += rcl_get_error_string().str;\n+    rcl_reset_error();\n+\n+    ret = rcl_action_cancel_response_fini(&cancel_response);\n+    if (RCL_RET_OK != ret) {\n+      error_text += \".  Also failed to cleanup response: \";\n+      error_text += rcl_get_error_string().str;\n+      rcl_reset_error();\n+    }\n+    throw std::runtime_error(error_text);\n+  }\n+\n+  py::object return_value = convert_to_py(&cancel_response.msg, pycancel_response_type);\n+  RCPPUTILS_SCOPE_EXIT(\n+    {\n+      ret = rcl_action_cancel_response_fini(&cancel_response);\n+\n+      if (RCL_RET_OK != ret) {\n+        throw rclpy::RCLError(\"Failed to finalize cancel response\");\n+      }\n+    });\n+  return return_value;\n+}\n+\n+py::tuple\n+ActionServer::expire_goals(int64_t max_num_goals)\n+{\n+  auto expired_goals =\n+    std::unique_ptr<rcl_action_goal_info_t[]>(new rcl_action_goal_info_t[max_num_goals]);\n+  size_t num_expired;\n+  rcl_ret_t ret = rcl_action_expire_goals(\n+    rcl_action_server_.get(), expired_goals.get(), max_num_goals, &num_expired);\n+  if (RCL_RET_OK != ret) {\n+    throw rclpy::RCLError(\"Failed to expire goals\");\n+  }\n+\n+  // Get Python GoalInfo type\n+  py::module pyaction_msgs_module = py::module::import(\"action_msgs.msg\");\n+  py::object pygoal_info_class = pyaction_msgs_module.attr(\"GoalInfo\");\n+  py::object pygoal_info_type = pygoal_info_class();\n+\n+  // Create a tuple of GoalInfo instances to return\n+  py::tuple result_tuple(num_expired);\n+\n+  for (size_t i = 0; i < num_expired; ++i) {\n+    result_tuple[i] =\n+      convert_to_py(&(expired_goals.get()[i]), pygoal_info_type);\n+  }\n+\n+  return result_tuple;\n+}\n+\n+void\n+define_action_server(py::object module)\n+{\n+  py::class_<ActionServer, Destroyable, std::shared_ptr<ActionServer>>(module, \"ActionServer\")\n+  .def(\n+    py::init<py::capsule, const rclpy::Clock &, py::object, const char *,\n+    const rmw_qos_profile_t &, const rmw_qos_profile_t &, const rmw_qos_profile_t &,\n+    const rmw_qos_profile_t &, const rmw_qos_profile_t &, double>())\n+  .def_property_readonly(\n+    \"pointer\", [](const ActionServer & action_server) {\n+      return reinterpret_cast<size_t>(action_server.rcl_ptr());\n+    },\n+    \"Get the address of the entity as an integer\")\n+  .def(\n+    \"take_goal_request\", &ActionServer::take_goal_request,\n+    \"Take an action goal request.\")\n+  .def(\n+    \"send_goal_response\", &ActionServer::send_goal_response,\n+    \"Send an action goal response.\")\n+  .def(\n+    \"send_result_response\", &ActionServer::send_result_response,\n+    \"Send an action result response.\")\n+  .def(\n+    \"take_cancel_request\", &ActionServer::take_cancel_request,\n+    \"Take an action cancel request.\")\n+  .def(\n+    \"take_result_request\", &ActionServer::take_result_request,\n+    \"Take an action result request.\")\n+  .def(\n+    \"send_cancel_response\", &ActionServer::send_cancel_response,\n+    \"Send an action cancel response.\")\n+  .def(\n+    \"publish_feedback\", &ActionServer::publish_feedback,\n+    \" Publish a feedback message from a given action server.\")\n+  .def(\n+    \"publish_status\", &ActionServer::publish_status,\n+    \"Publish a status message from a given action server.\")\n+  .def(\n+    \"notify_goal_done\", &ActionServer::notify_goal_done,\n+    \"Notify goal is done.\")\n+  .def(\n+    \"goal_exists\", &ActionServer::goal_exists,\n+    \"Check is a goal exists in the server.\")\n+  .def(\n+    \"process_cancel_request\", &ActionServer::process_cancel_request,\n+    \"Process a cancel request\")\n+  .def(\n+    \"expire_goals\", &ActionServer::expire_goals,\n+    \"Expired goals.\")\n+  .def(\n+    \"get_num_entities\", &ActionServer::get_num_entities,\n+    \"Get the number of wait set entities that make up an action entity.\")\n+  .def(\n+    \"is_ready\", &ActionServer::is_ready,\n+    \"Check if an action entity has any ready wait set entities.\")\n+  .def(\n+    \"add_to_waitset\", &ActionServer::add_to_waitset,\n+    \"Add an action entitiy to a wait set.\");\n+}\n+\n+}  // namespace rclpy"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLPY__ACTION_SERVER_HPP_\n+#define RCLPY__ACTION_SERVER_HPP_\n+\n+#include <pybind11/pybind11.h>\n+\n+#include <rcl_action/rcl_action.h>\n+\n+#include <memory>\n+\n+#include \"clock.hpp\"\n+#include \"destroyable.hpp\"\n+#include \"handle.hpp\"\n+\n+namespace py = pybind11;\n+\n+namespace rclpy\n+{\n+/*\n+  * This class will create an action server for the given action name.\n+  * This client will use the typesupport defined in the action module\n+  * provided as pyaction_type to send messages.\n+  */\n+class ActionServer : public Destroyable, public std::enable_shared_from_this<ActionServer>\n+{\n+public:\n+  /// Create an action server.\n+  /**\n+   * Raises AttributeError if action type is invalid\n+   * Raises ValueError if action name is invalid\n+   * Raises RuntimeError if the action server could not be created.\n+   *\n+   * \\param[in] pynode Capsule pointing to the node to add the action server to.\n+   * \\param[in] rclpy_clock Clock use to create the action server.\n+   * \\param[in] pyaction_type Action module associated with the action server.\n+   * \\param[in] pyaction_name Python object containing the action name.\n+   * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n+   * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n+   * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n+   * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n+   * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n+   */\n+  ActionServer(\n+    py::capsule pynode,\n+    const rclpy::Clock & rclpy_clock,\n+    py::object pyaction_type,\n+    const char * action_name,\n+    const rmw_qos_profile_t & goal_service_qos,\n+    const rmw_qos_profile_t & result_service_qos,\n+    const rmw_qos_profile_t & cancel_service_qos,\n+    const rmw_qos_profile_t & feedback_topic_qos,\n+    const rmw_qos_profile_t & status_topic_qos,\n+    double result_timeout);\n+\n+  /// Take an action goal request.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] pymsg_type An instance of the type of request message to take.\n+   * \\return 2-tuple (header, received request message) where the header is an\n+   *   \"rclpy.rmw_request_id_t\" type, or\n+   * \\return 2-tuple (None, None) if there as no message to take\n+   */\n+  py::tuple\n+  take_goal_request(py::object pymsg_type);\n+\n+  /// Send an action goal response.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] header Pointer to the message header.\n+   * \\param[in] pyresponse The response message to send.\n+   */\n+  void\n+  send_goal_response(\n+    rmw_request_id_t * header, py::object pyresponse);\n+\n+  /// Send an action result response.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] pyheader Pointer to the message header.\n+   * \\param[in] pyresponse The response message to send.\n+   */\n+  void\n+  send_result_response(\n+    rmw_request_id_t * header, py::object pyresponse);\n+\n+  /// Take an action cancel request.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] pymsg_type An instance of the type of request message to take.\n+   * \\return 2-tuple (header, received request message) where the header is an\n+   *   \"rmw_request_id_t\" type, or\n+   * \\return 2-tuple (None, None) if there as no message to take\n+   */\n+  py::tuple\n+  take_cancel_request(py::object pymsg_type);\n+\n+  /// Take an action result request.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] pymsg_type An instance of the type of request message to take.\n+   * \\return 2-tuple (header, received request message) where the header is an\n+   *   \"rclpy.rmw_request_id_t\" type, or\n+   * \\return 2-tuple (None, None) if there as no message to take\n+   */\n+  py::tuple\n+  take_result_request(py::object pymsg_type);\n+\n+  /// Send an action cancel response.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure.\n+   *\n+   * \\param[in] pyheader Pointer to the message header.\n+   * \\param[in] pyresponse The response message to send.\n+   */\n+  void\n+  send_cancel_response(\n+    rmw_request_id_t * header, py::object pyresponse);\n+\n+  /// Publish a feedback message from a given action server.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure while publishing a feedback message.\n+   *\n+   * \\param[in] pymsg The feedback message to publish.\n+   */\n+  void\n+  publish_feedback(py::object pymsg);\n+\n+  /// Publish a status message from a given action server.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   * Raises RuntimeError on failure while publishing a status message.\n+   */\n+  void\n+  publish_status();\n+\n+  /// Notifies action server that a goal handle reached a terminal state.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   */\n+  void\n+  notify_goal_done();\n+\n+  /// Check if a goal is already being tracked by an action server.\n+  /*\n+   * Raises AttributeError if there is an issue parsing the pygoal_info.\n+   *\n+   * \\param[in] pygoal_info the identifiers of goals that expired, or set to `NULL` if unused\n+   * \\return True if the goal exists, false otherwise.\n+   */\n+  bool\n+  goal_exists(py::object pygoal_info);\n+\n+  /// Process a cancel request using an action server.\n+  /**\n+   * This is a non-blocking call.\n+   *\n+   * Raises RuntimeError on failure while publishing a status message.\n+   * Raises RCLError if an error occurs in rcl\n+   *\n+   * \\return the cancel response message\n+   */\n+  py::object\n+  process_cancel_request(\n+    py::object pycancel_request, py::object pycancel_response_type);\n+\n+  /// Expires goals associated with an action server.\n+  py::tuple\n+  expire_goals(int64_t max_num_goals);\n+\n+  /// Get the number of wait set entities that make up an action entity.\n+  /**\n+   * Raises RCLError if an error occurs in rcl\n+   *\n+   * \\return Tuple containing the number of wait set entities:\n+   *   (num_subscriptions,\n+   *    num_guard_conditions,\n+   *    num_timers,\n+   *    num_clients,\n+   *    num_services)\n+   */\n+  py::tuple\n+  get_num_entities();\n+\n+  /// Check if an action entity has any ready wait set entities.\n+  /**\n+   * This must be called after waiting on the wait set.\n+   * Raises RuntimeError on failure.\n+   * Raises RCLError if an error occurs in rcl\n+   *\n+   * \\param[in] pywait_set Capsule pointing to the wait set structure.\n+   * \\return A tuple of booleans representing ready sub-entities.\n+   *       (is_goal_request_ready,\n+   *        is_cancel_request_ready,\n+   *        is_result_request_ready,\n+   *        is_goal_expired)\n+   */\n+  py::tuple\n+  is_ready(py::capsule pywait_set);\n+\n+  /// Add an action entitiy to a wait set.\n+  /**\n+   * Raises RuntimeError on failure.\n+   * Raises RCLError if an error occurs in rcl\n+   *\n+   * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n+   */\n+  void\n+  add_to_waitset(py::capsule pywait_set);\n+\n+  /// Get rcl_client_t pointer\n+  rcl_action_server_t *\n+  rcl_ptr() const\n+  {\n+    return rcl_action_server_.get();\n+  }\n+\n+  /// Get rcl_client_t pointer\n+  std::shared_ptr<rcl_action_server_t>\n+  get_rcl_shared_ptr()\n+  {\n+    return rcl_action_server_;\n+  }\n+\n+  /// Force an early destruction of this object\n+  void\n+  destroy() override;\n+\n+private:\n+  std::shared_ptr<Handle> node_handle_;\n+  std::shared_ptr<rcl_action_server_t> rcl_action_server_;\n+};\n+/// Define a pybind11 wrapper for an rcl_time_point_t\n+/**\n+ * \\param[in] module a pybind11 module to add the definition to\n+ */\n+void define_action_server(py::object module);\n+}  // namespace rclpy\n+\n+#endif  // RCLPY__ACTION_SERVER_HPP_"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  static rcutils_allocator_t zero_allocator = {\n-    .allocate = NULL,\n-    .deallocate = NULL,\n-    .reallocate = NULL,\n-    .zero_allocate = NULL,\n-    .state = NULL,\n-  };\n+  static rcutils_allocator_t zero_allocator = {0};"},{"role":"user","content":"-  static rcutils_array_list_t zero_initialized_array_list = {NULL};\n+  static rcutils_array_list_t zero_initialized_array_list = {0};"},{"role":"user","content":"-  static rcutils_char_array_t char_array = {\n-    .buffer = NULL,\n-    .owns_buffer = true,\n-    .buffer_length = 0u,\n-    .buffer_capacity = 0u\n-  };\n-  char_array.allocator = rcutils_get_zero_initialized_allocator();\n+  static rcutils_char_array_t char_array = {0};"},{"role":"user","content":"-  static rcutils_hash_map_t zero_initialized_hash_map = {NULL};\n+  static rcutils_hash_map_t zero_initialized_hash_map = {0};"},{"role":"user","content":"-  rcutils_shared_library_t zero_initialized_shared_library;\n-  zero_initialized_shared_library.library_path = NULL;\n-  zero_initialized_shared_library.lib_pointer = NULL;\n-  zero_initialized_shared_library.allocator = rcutils_get_zero_initialized_allocator();\n+  static rcutils_shared_library_t zero_initialized_shared_library = {0};"},{"role":"user","content":"-  static rcutils_string_array_t array = {\n-    .size = 0,\n-    .data = NULL,\n-  };\n-  array.allocator = rcutils_get_zero_initialized_allocator();\n+  static rcutils_string_array_t array = {0};"},{"role":"user","content":"-  static rcutils_string_map_t zero_initialized_string_map;\n-  zero_initialized_string_map.impl = NULL;\n+  static rcutils_string_map_t zero_initialized_string_map = {0};"},{"role":"user","content":"-  static rcutils_uint8_array_t uint8_array = {\n-    .buffer = NULL,\n-    .buffer_length = 0lu,\n-    .buffer_capacity = 0lu\n-  };\n-  uint8_array.allocator = rcutils_get_zero_initialized_allocator();\n+  static rcutils_uint8_array_t uint8_array = {0};"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    int index = topic.lastIndexOf(\"/\");\n-    if (index == -1) {\n-      return;\n-    }\n-    QString transport = topic.mid(index + 1);\n-    QString base_topic = topic.mid(0, index);\n-\n-    depth_transport_property_->setString(transport);\n-    depth_topic_property_->setString(base_topic);\n+    setStatus(\n+      rviz_common::properties::StatusProperty::Warn,\n+      \"Message\",\n+      \"Expected topic type of 'sensor_msgs/msg/Image', saw topic type '\" + datatype + \"'\");"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+   * Work that is ready to be done is collected only once, and when collecting that work\n+   * entities which may have multiple pieces of work ready will only be executed at most\n+   * one time.\n+   * The reason for this is that it is not possible to tell if, for example, a ready\n+   * subscription has only one message ready or multiple without checking again.\n+   * Because, in order to find out if there are multiple messages, one message must\n+   * be taken and executed before checking again if that subscription is still ready.\n+   * However, this function only checks for ready entities to work on once,\n+   * and so it will never execute a single entity more than once per call to this function.\n+   * See spin_all() variants for a function that will repeatedly work on a single entity\n+   * in a single call.\n+   *"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-/// Take an incoming message from a subscription.\n+/// Take an incoming ROS message."},{"role":"user","content":"- * Take an incoming ROS message from a given subscription.\n+ * Take a ROS message already received by the given subscription, removing it from internal queues.\n+ * This function will succeed even if no ROS message was received, but `taken` will be false."},{"role":"user","content":"- * \\param[in] subscription The subscription object to take from.\n- * \\param[out] ros_message The ROS message data on success.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * \\remarks The same ROS message cannot be taken twice.\n+ *   Callers do not have to deal with duplicates.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a ROS message is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n+ *   but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations that deserialize ROS messages received over\n+ *   the wire may need to perform additional memory allocations when dealing with\n+ *   unbounded (dynamically-sized) fields.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation\n+ *   guarantees when taking ROS messages with and without subscription allocations.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking regular ROS messages:\n+ *   - Access to the given ROS message is not synchronized.\n+ *     It is not safe to read or write `ros_message` while rmw_take() uses it.\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` while rmw_take() uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre Given `ros_message` must be a valid message, whose type matches the message type support\n+ *   registered with the `subscription` on creation.\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with the `subscription` on creation.\n+ * \\post Given `ros_message` will remain a valid message.\n+ *   It will be left unchanged if this function fails early due to a logical error, such as an\n+ *   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n+ *   It will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take message from.\n+ * \\param[out] ros_message Type erased ROS message to write to.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[in] allocation Pre-allocated memory to be used. May be NULL."},{"role":"user","content":"+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`\n+ *   implementation identifier does not match this implementation, or"},{"role":"user","content":"-/// Take an incoming message from a subscription with additional metadata.\n+/// Take an incoming ROS message with its metadata."},{"role":"user","content":"- * Take an incoming ROS message from a given subscription.\n+ * Same as rmw_take(), except it also takes ROS message metadata.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]"},{"role":"user","content":"- * \\param[in] subscription The subscription object to take from.\n- * \\param[out] ros_message The ROS message data on success.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info Additional message metadata.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a ROS message with its metadata is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n+ *   but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations that deserialize ROS messages received over\n+ *   the wire may need to perform additional memory allocations when dealing with\n+ *   unbounded (dynamically-sized) fields.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation\n+ *   guarantees when taking ROS messages with and without subscription allocations.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking regular ROS messages with metadata:\n+ *   - Access to the given ROS message is not synchronized.\n+ *     It is not safe to read or write `ros_message` while rmw_take_with_info() uses it.\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` while rmw_take_with_info() uses it.\n+ *   - Access to the given ROS message metadata is not synchronized.\n+ *     It is not safe to read or write `message_info` while rmw_take_with_info() uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()\n+ *     uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre Given `ros_message` must be a valid message, whose type matches\n+ *   the message type support registered with the `subscription` on creation.\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation\n+ *   initialized with rmw_subscription_allocation_init() with a message type support\n+ *   that matches the one registered with the `subscription` on creation.\n+ * \\post Given `ros_message` will remain a valid message, and\n+ *   `message_info`, valid message metadata.\n+ *   Both will be left unchanged if this function fails early due to a logical error, such as\n+ *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n+ *   Both will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from.\n+ * \\param[out] ros_message Type erased ROS message to write to.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[out] message_info Taken ROS message metadata.\n+ * \\param[in] allocation Pre-allocated memory to be used. May be NULL."},{"role":"user","content":"+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`\n+ *   implementation identifier does not match this implementation, or"},{"role":"user","content":"-/// Take multiple incoming messages from a subscription with additional metadata.\n+/// Take multiple incoming ROS messages with their metadata."},{"role":"user","content":"- * Take a sequence of ROS messgages from a given subscription.\n+ * Take a sequence of consecutive ROS messages already received by the given\n+ * subscription, removing them from internal queues.\n+ * While `count` ROS messages may be requested, fewer messages may have been\n+ * received by the subscription.\n+ * This function will only take what has been already received, and it will\n+ * succeed even if fewer (or zero) messages were received.\n+ * In this case, only currently available messages will be returned.\n+ * The `taken` flag indicates the number of ROS messages actually taken.\n+ *\n+ * \\remarks Once taken, ROS messages in the sequence cannot be taken again.\n+ *   Callers do not have to deal with duplicates.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]"},{"role":"user","content":"- * While `count` messages may be requested, fewer messages may be available on the subscription.\n- * In this case, only the currently available messages will be returned.\n- * The `taken` flag indicates the number of messages actually taken.\n- * The method will return `RMW_RET_OK` even in the case that fewer (or zero) messages were retrieved.\n- * from the subscription, and will `RMW_RET_ERROR` in the case of unexpected errors.\n- * In the case that `count` is zero, the function will return `RMW_RET_INVALID_ARGUMENT`.\n+ * <i>[1] implementation defined, check implementation documentation.</i>"},{"role":"user","content":"- * `message_sequence` and `message_info_sequence` should be initialized and have sufficient capacity.\n- * It is not critical that the sequence sizes match, and they may be reused from previous calls.\n- * Both must be valid (not NULL) for the method to run successfully.\n+ * \\par Runtime behavior\n+ *   To take a sequence of ROS messages is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n+ *   but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling)."},{"role":"user","content":"- * \\param[in] subscription The subscription object to take from.\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations that deserialize ROS messages received over\n+ *   the wire may need to perform additional memory allocations when dealing with\n+ *   unbounded (dynamically-sized) fields.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation\n+ *   guarantees when taking ROS messages with and without subscription allocations.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to\n+ *   preserve the order in the subscription queues, despite any concurrent takes.\n+ *   However, when taking a sequence of ROS messages with metadata:\n+ *   - Access to the given ROS message sequence is not synchronized.\n+ *     It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it.\n+ *   - Access to the given ROS message metadata sequence is not synchronized.\n+ *     It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it.\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` while rmw_take_sequence() uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()\n+ *     uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre Given `message_sequence` must be a valid message sequence, initialized\n+ *   by rmw_message_sequence_init() and populated with ROS messages whose\n+ *   type matches the message type support registered with the `subscription`\n+ *   on creation.\n+ * \\pre Given `message_info_sequence` must be a valid message metadata sequence,\n+ *   initialized by rmw_message_info_sequence_init().\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with `subscription` on creation.\n+ * \\post Given `message_sequence` will remain a valid message sequence, and\n+ *   `message_info_sequence`, a valid message metadata sequence.\n+ *   Both will be left unchanged if this function fails early due to a logical error, such as\n+ *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n+ *   Both will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from."},{"role":"user","content":"- * \\param[out] message_sequence The sequence of ROS message data on success.\n- * \\param[out] message_info_sequence The sequence of additional message metadata on success.\n+ * \\param[out] message_sequence Sequence of type erase ROS messages to write to.\n+ *   Message sequence capacity has to be enough to hold all requested messages\n+ *   i.e. capacity has to be equal or greater than `count`.\n+ *   It does not have to match that of `message_info_sequence`.\n+ * \\param[out] message_info_sequence Sequence of additional message metadata.\n+ *   Message info sequence capacity has to be enough to hold all requested messages\n+ *   metadata i.e. capacity has to be equal or greater than `count`.\n+ *   It does not have to match that of `message_sequence`."},{"role":"user","content":"- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * \\param[in] allocation Pre-allocated memory to use. May be NULL."},{"role":"user","content":"- * \\return `RMW_RET_INVALID_ARGUMENT` if an argument is invalid, or\n- * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n- * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the rmw implementation does not match, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `count` is 0, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or"},{"role":"user","content":"-/// Take a message without deserializing it.\n+/// Take an incoming ROS message as a byte stream."},{"role":"user","content":"- * The message is taken in its serialized form. In contrast to rmw_take, the message\n- * is not deserialized in its ROS type but rather returned as a byte stream.\n- * The subscriber has to be registered for a specific type. But instead of receiving\n- * the message as its corresponding message type, it is taken as a byte stream.\n- * If needed, this byte stream can then be deserialized in a ROS message with a call to\n- * rmw_deserialize.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[out] serialized_message The destination in which to store the serialized message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * Take a ROS message already received by the given subscription, removing it from internal queues.\n+ * This function will succeed even if no ROS message was received, but `taken` will be false.\n+ * Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.\n+ * If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().\n+ *\n+ * \\remarks The same ROS message, serialized or not, cannot be taken twice.\n+ *   Callers do not have to deal with duplicates.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a ROS message a byte stream is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n+ *   but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations may have to perform additional memory allocations\n+ *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n+ *   i.e. these implementations may have to resize the given byte stream.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation guarantees\n+ *   when taking serialized ROS messages with and without subscription allocations.\n+ * \\par\n+ *   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n+ *   their size using rmw_get_serialized_message_size() and resize `serialized_message`\n+ *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n+ *   on take.\n+ *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking serialized ROS messages:\n+ *   - Access to the given byte stream for serialized ROS messages is not synchronized.\n+ *     It is not safe to read or write `serialized_message` while\n+ *     rmw_take_serialized_message() uses it.\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` while rmw_take_serialized_message() uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while\n+ *     rmw_take_serialized_message() uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned by\n+ *   rmw_create_subscription().\n+ * \\pre Given `serialized_message` must be a valid serialized message, initialized by\n+ *   rmw_serialized_message_init().\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with `subscription` on creation.\n+ * \\post Given `serialized_message` will remain a valid serialized message.\n+ *   It will be left unchanged if this function fails early due to a logical error,\n+ *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n+ *   runtime error.\n+ *   It will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from.\n+ * \\param[out] serialized_message Byte stream to write to.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[in] allocation Pre-allocated memory to use. May be NULL."},{"role":"user","content":"- * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or"},{"role":"user","content":"-/// Take a message without deserializing it and with its additional message information.\n+/// Take an incoming ROS message as a byte stream with its metadata."},{"role":"user","content":"- * The same as rmw_take_serialized_message(), except it also includes the\n- * rmw_message_info_t.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[out] serialized_message The destination in which to store the serialized message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info A structure containing meta information about the taken message.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * Same as rmw_take_serialized_message(), except it also takes ROS message metadata.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a ROS message a byte stream with its metadata is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n+ *   but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations may have to perform additional memory allocations\n+ *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n+ *   i.e. these implementations may have to resize the given byte stream.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation guarantees\n+ *   when taking serialized ROS messages with and without subscription allocations.\n+ * \\par\n+ *   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n+ *   their size using rmw_get_serialized_message_size() and resize `serialized_message`\n+ *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n+ *   on take.\n+ *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking serialized ROS messages with metadata:\n+ *   - Access to the given byte stream for serialized ROS messages is not synchronized.\n+ *     It is not safe to read or write `serialized_message` while\n+ *     rmw_take_serialized_message_with_info() uses it.\n+ *   - Access to the given ROS message metadata is not synchronized.\n+ *     It is not safe to read or write `message_info` while\n+ *     rmw_take_serialized_message_with_info() uses it.\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()\n+ *     uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while\n+ *     rmw_take_serialized_message_with_info() uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `serialized_message` must be a valid serialized message, initialized by\n+ *   rmw_serialized_message_init().\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with `subscription` on creation.\n+ * \\post Given `serialized_message` will remain a valid serialized message, and `message_info`,\n+ *   valid message metadata.\n+ *   Both will be left unchanged if this function fails early due to a logical error,\n+ *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n+ *   runtime error.\n+ *   It will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from.\n+ * \\param[out] serialized_message Byte stream to write to.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[out] message_info Taken ROS message metadata.\n+ * \\param[in] allocation Pre-allocated memory to use. May be NULL."},{"role":"user","content":"- * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or"},{"role":"user","content":"-/// Take a loaned message.\n+/// Take an incoming ROS message, loaned by the middleware."},{"role":"user","content":"- * If capable, the middleware can loan messages containing incoming messages.\n- * The message is owned by the middleware and thus has to be returned\n- * with a call to \\sa rmw_return_loaned_message_from_subscription.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[inout] loaned_message The destination in which to store the loaned message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * Take a ROS message already received by the given subscription, removing it from internal queues.\n+ * This function will succeed even if no ROS message was received, but `taken` will be false.\n+ * The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid\n+ * memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().\n+ *\n+ * \\remarks The same ROS message, loaned or not, cannot be taken twice.\n+ *   Callers do not have to deal with duplicates.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a loaned ROS message is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n+ *   nor for internal memory loaning pools, if any, to be replenished, but it is not\n+ *   guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations that deserialize ROS messages received over\n+ *   the wire may need to perform additional memory allocations when dealing with\n+ *   unbounded (dynamically-sized) fields.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation\n+ *   guarantees when taking loaned ROS messages with and without subscription allocations.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking loaned ROS messages:\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` nor `loaned_message`\n+ *     while rmw_take_loaned_message() uses them.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while\n+ *     rmw_take_loaned_message() uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with `subscription` on creation.\n+ * \\post Given `loaned_message` will remain unchanged, or point to a valid message if\n+ *   this function was successful and `taken` is true.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from.\n+ * \\param[inout] loaned_message Pointer to type erased ROS message taken\n+ *   and loaned by the middleware.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[in] allocation Pre-allocated memory to use. May be NULL."},{"role":"user","content":"- * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n- * \\return `RMW_RET_UNSUPPORTED` if the rmw_implementation does not support loaned_message, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or\n+ * \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or"},{"role":"user","content":"- * If capable, the middleware can loan messages containing incoming messages.\n- * The message is owned by the middleware and thus has to be returned\n- * with a call to \\sa rmw_release_loaned_message.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[inout] loaned_message The destination in which to store the loaned message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info A structure containing meta information about the taken message.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n+ * Same as rmw_take_loaned_message(), except it also takes ROS message metadata.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To take a loaned ROS message with its metadata is a synchronous operation.\n+ *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n+ *   nor for internal memory loaning pools, if any, to be replenished, but it is not\n+ *   guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Memory allocation\n+ *   It is implementation defined whether memory will be allocated on take or not.\n+ *   For instance, implementations that deserialize ROS messages received over\n+ *   the wire may need to perform additional memory allocations when dealing with\n+ *   unbounded (dynamically-sized) fields.\n+ *   A subscription allocation, if provided, may or may not be used.\n+ *   Check the implementation documentation to learn about memory allocation\n+ *   guarantees when taking loaned ROS messages with and without subscription allocations.\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to take from the same subscription concurrently.\n+ *   However, when taking loaned ROS messages with metadata:\n+ *   - Access to given primitive data-type arguments is not synchronized.\n+ *     It is not safe to read or write `taken` nor `loaned_message`\n+ *     while rmw_take_loaned_message_with_info() uses them.\n+ *   - Access to the given ROS message metadata is not synchronized.\n+ *     It is not safe to read or write `message_info` while\n+ *     rmw_take_loaned_message_with_info() uses it.\n+ *   - Access to the given subscription allocation is not synchronized,\n+ *     unless specifically stated otherwise by the implementation.\n+ *     Thus, it is generally not safe to read or write `allocation` while\n+ *     rmw_take_loaned_message_with_info() uses it.\n+ *     Check the implementation documentation to learn about subscription allocations'\n+ *     thread-safety.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre If not NULL, given `allocation` must be a valid subscription allocation initialized\n+ *   with rmw_subscription_allocation_init() with a message type support that matches the\n+ *   one registered with `subscription` on creation.\n+ * \\post Given `loaned_message` will remain unchanged, or point to a valid message if\n+ *   this function was successful and `taken` is true.\n+ * \\post Given `message_info` will remain valid message metadata.\n+ *   It will be left unchanged if this function fails early due to a logical error,\n+ *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n+ *   runtime error.\n+ *   It will also be left unchanged if this function succeeds but `taken` is false.\n+ *\n+ * \\param[in] subscription Subscription to take ROS message from.\n+ * \\param[inout] loaned_message Pointer to type erased ROS message taken\n+ *   and loaned by the middleware.\n+ * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n+ * \\param[out] message_info Taken ROS message metadata.\n+ * \\param[in] allocation Pre-allocated memory to use. May be NULL."},{"role":"user","content":"- * \\return `RMW_RET_BAD_ALLOC` if memory allocation failed, or\n- * \\return `RMW_RET_UNSUPPORTED` if the rmw_implementation does not support loaned_message, or\n+ * \\return `RMW_RET_BAD_ALLOC` if memory allocation fails, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or\n+ * \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or"},{"role":"user","content":"-/// Return a loaned message previously taken from a subscription.\n+/// Return a loaned ROS message previously taken from a subscription."},{"role":"user","content":"- * After the taking a loaned message from the middleware, the middleware has to keep the memory\n- * for the loaned message alive and valid as long as the user is working with that loan.\n- * In order to indicate that the loaned message is no longer needed, the call to\n- * \\sa rmw_return_loaned_message_from_subscription tells the middleware that memory can be\n- * deallocated/destroyed.\n- *\n- * \\param[in] subscription The subscription instance which loaned the message.\n- * \\param[in] loaned_message The message to be released.\n+ * Tells the middleware that previously loaned ROS message is no longer needed by the caller.\n+ * If this function fails early due to a logical error, such as an invalid argument,\n+ * the loaned ROS message will be left unchanged.\n+ * Otherwise, ownership of the ROS message will be given back to the middleware.\n+ * It is up to the middleware what will be made of the returned ROS message.\n+ * It is undefined behavior to use a loaned ROS message after returning it.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | Yes\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ *\n+ * <i>[1] implementation defined, check implementation documentation.</i>\n+ *\n+ * \\par Runtime behavior\n+ *   To return a loaned ROS message is a synchronous operation.\n+ *   It is also non-blocking, but it is not guaranteed to be lock-free.\n+ *   Generally speaking, implementations may synchronize access to internal resources using\n+ *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n+ *   the effects of starvation due to OS scheduling).\n+ *\n+ * \\par Thread-safety\n+ *   Subscriptions are thread-safe objects, and so are all operations on them except for\n+ *   finalization.\n+ *   Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.\n+ *   However, since ownership of the loaned ROS message is given back to middleware and this\n+ *   transfer is not synchronized, it is not safe to return the same loaned ROS message\n+ *   concurrently.\n+ *\n+ * \\pre Given `subscription` must be a valid subscription, as returned\n+ *   by rmw_create_subscription().\n+ * \\pre Given `loaned_message` must be a loaned ROS message, previously taken from\n+ *   `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().\n+ *\n+ * \\param[in] subscription Subscription the ROS message was taken and loaned from.\n+ * \\param[in] loaned_message Loaned type erased ROS message to be returned to the middleware.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation\n+ *   identifier does not match this implementation, or\n+ * \\return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs."},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        timestamp_fields = []"},{"role":"user","content":"-            set_message_fields(goal, goal_dict)\n+            timestamp_fields = set_message_fields(\n+                goal, goal_dict, expand_header_auto=True, expand_time_now=True)"},{"role":"user","content":"+        stamp_now = node.get_clock().now().to_msg()\n+        for field_setter in timestamp_fields:\n+            field_setter(stamp_now)\n+"},{"role":"user","content":"+"},{"role":"user","content":"+        timestamp_fields = []"},{"role":"user","content":"-            set_message_fields(request, values_dictionary)\n+            timestamp_fields = set_message_fields(\n+                request, values_dictionary, expand_header_auto=True, expand_time_now=True)"},{"role":"user","content":"+            stamp_now = node.get_clock().now().to_msg()\n+            for field_setter in timestamp_fields:\n+                field_setter(stamp_now)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+// Copyright 2017 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef ALLOCATOR_TESTING_UTILS_H_\n+#define ALLOCATOR_TESTING_UTILS_H_\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#include <stddef.h>\n+\n+#include \"rcutils/allocator.h\"\n+\n+typedef struct __failing_allocator_state\n+{\n+  bool is_failing;\n+} __failing_allocator_state;\n+\n+void *\n+failing_malloc(size_t size, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().allocate(size, rcutils_get_default_allocator().state);\n+}\n+\n+void *\n+failing_realloc(void * pointer, size_t size, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().reallocate(\n+    pointer, size, rcutils_get_default_allocator().state);\n+}\n+\n+void\n+failing_free(void * pointer, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return;\n+  }\n+  rcutils_get_default_allocator().deallocate(pointer, rcutils_get_default_allocator().state);\n+}\n+\n+void *\n+failing_calloc(size_t number_of_elements, size_t size_of_element, void * state)\n+{\n+  if (((__failing_allocator_state *)state)->is_failing) {\n+    return nullptr;\n+  }\n+  return rcutils_get_default_allocator().zero_allocate(\n+    number_of_elements, size_of_element, rcutils_get_default_allocator().state);\n+}\n+\n+static inline rcutils_allocator_t\n+get_failing_allocator(void)\n+{\n+  static __failing_allocator_state state;\n+  state.is_failing = true;\n+  auto failing_allocator = rcutils_get_default_allocator();\n+  failing_allocator.allocate = failing_malloc;\n+  failing_allocator.deallocate = failing_free;\n+  failing_allocator.reallocate = failing_realloc;\n+  failing_allocator.zero_allocate = failing_calloc;\n+  failing_allocator.state = &state;\n+  return failing_allocator;\n+}\n+\n+static inline void\n+set_failing_allocator_is_failing(rcutils_allocator_t & failing_allocator, bool state)\n+{\n+  ((__failing_allocator_state *)failing_allocator.state)->is_failing = state;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif  // ALLOCATOR_TESTING_UTILS_H_"},{"role":"user","content":"+#include \"./allocator_testing_utils.h\"\n+#include \"rmw/error_handling.h\""},{"role":"user","content":"+TEST(test_message_info_sequence, bad_arguments) {\n+  auto info_sequence = rmw_get_zero_initialized_message_info_sequence();\n+  auto allocator = rcutils_get_default_allocator();\n+\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_info_sequence_init(nullptr, 5u, &allocator));\n+  EXPECT_EQ(0u, info_sequence.size);\n+  EXPECT_EQ(0u, info_sequence.capacity);\n+  EXPECT_EQ(nullptr, info_sequence.data);\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_info_sequence_init(&info_sequence, 5u, nullptr));\n+  EXPECT_EQ(0u, info_sequence.size);\n+  EXPECT_EQ(0u, info_sequence.capacity);\n+  EXPECT_EQ(nullptr, info_sequence.data);\n+  rmw_reset_error();\n+\n+  rcutils_allocator_t failing_allocator = get_failing_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_BAD_ALLOC, rmw_message_info_sequence_init(&info_sequence, 5u, &failing_allocator));\n+  EXPECT_EQ(0u, info_sequence.size);\n+  EXPECT_EQ(0u, info_sequence.capacity);\n+  EXPECT_EQ(nullptr, info_sequence.data);\n+  rmw_reset_error();\n+}\n+"},{"role":"user","content":"+\n+TEST(test_message_sequence, bad_arguments) {\n+  auto message_sequence = rmw_get_zero_initialized_message_sequence();\n+  auto allocator = rcutils_get_default_allocator();\n+\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_sequence_init(nullptr, 5u, &allocator));\n+  EXPECT_EQ(0u, message_sequence.size);\n+  EXPECT_EQ(0u, message_sequence.capacity);\n+  EXPECT_EQ(nullptr, message_sequence.data);\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_sequence_init(&message_sequence, 5u, nullptr));\n+  EXPECT_EQ(0u, message_sequence.size);\n+  EXPECT_EQ(0u, message_sequence.capacity);\n+  EXPECT_EQ(nullptr, message_sequence.data);\n+  rmw_reset_error();\n+\n+  rcutils_allocator_t failing_allocator = get_failing_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_BAD_ALLOC, rmw_message_sequence_init(&message_sequence, 5u, &failing_allocator));\n+  EXPECT_EQ(0u, message_sequence.size);\n+  EXPECT_EQ(0u, message_sequence.capacity);\n+  EXPECT_EQ(nullptr, message_sequence.data);\n+  rmw_reset_error();\n+}"},{"role":"user","content":"+#include \"./allocator_testing_utils.h\""},{"role":"user","content":"+TEST(rmw_security_options, options_copy) {\n+  rmw_security_options_t source = rmw_get_default_security_options();\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_set_root_path(\"root_path\", &allocator, &source));\n+\n+  rmw_security_options_t destination = rmw_get_zero_initialized_security_options();\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_copy(nullptr, &allocator, &destination));\n+\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_copy(&source, nullptr, &destination));\n+\n+  EXPECT_EQ(\n+    RMW_RET_INVALID_ARGUMENT,\n+    rmw_security_options_copy(&source, &allocator, nullptr));\n+\n+\n+  rcutils_allocator_t failing_allocator = get_failing_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_BAD_ALLOC,\n+    rmw_security_options_copy(&source, &failing_allocator, &destination));\n+\n+  EXPECT_EQ(\n+    RMW_RET_OK,\n+    rmw_security_options_copy(&source, &allocator, &destination));\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(&source, &allocator));\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(&destination, &allocator));\n+}\n+"},{"role":"user","content":"+\n+TEST(rmw_security_options, security_options_fini) {\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_security_options_fini(nullptr, &allocator));\n+\n+  rmw_security_options_t options = rmw_get_zero_initialized_security_options();\n+  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_security_options_fini(&options, nullptr));\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(&options, &allocator));\n+\n+  options = rmw_get_default_security_options();\n+  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(&options, &allocator));\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  size_t src_length = strnlen(src, dst_size);\n+  size_t src_length = strlen(src);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-* *Costmap:* Paint valid points between 0 and 98 from blue to red. \n-  Paint points with value 99 in cyan (obstacle value) and points with value 100 in purple (lethal obstacle). \n+* *Costmap:* Paint valid points between 1 and 98 from blue to red. \n+  Paint points with value 0 in black, points with value 99 in cyan (obstacle value) and points with value 100 in purple (lethal obstacle). "},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+# Python temporary files\n+*.pyc\n+__pycache__/"},{"role":"user","content":"+  <exec_depend>python3-numpy</exec_depend>"},{"role":"user","content":"+import array"},{"role":"user","content":"-import ctypes\n-import math\n-import struct"},{"role":"user","content":"+from typing import Iterable, List, NamedTuple, Optional"},{"role":"user","content":"+import numpy as np\n+from numpy.lib.recfunctions import (structured_to_unstructured,\n+                                    unstructured_to_structured)"},{"role":"user","content":"+from std_msgs.msg import Header"},{"role":"user","content":"-_DATATYPES[PointField.INT8] = ('b', 1)\n-_DATATYPES[PointField.UINT8] = ('B', 1)\n-_DATATYPES[PointField.INT16] = ('h', 2)\n-_DATATYPES[PointField.UINT16] = ('H', 2)\n-_DATATYPES[PointField.INT32] = ('i', 4)\n-_DATATYPES[PointField.UINT32] = ('I', 4)\n-_DATATYPES[PointField.FLOAT32] = ('f', 4)\n-_DATATYPES[PointField.FLOAT64] = ('d', 8)\n-\n-\n-def read_points(cloud, field_names=None, skip_nans=False, uvs=[]):\n+_DATATYPES[PointField.INT8] = np.dtype(np.int8)\n+_DATATYPES[PointField.UINT8] = np.dtype(np.uint8)\n+_DATATYPES[PointField.INT16] = np.dtype(np.int16)\n+_DATATYPES[PointField.UINT16] = np.dtype(np.uint16)\n+_DATATYPES[PointField.INT32] = np.dtype(np.int32)\n+_DATATYPES[PointField.UINT32] = np.dtype(np.uint32)\n+_DATATYPES[PointField.FLOAT32] = np.dtype(np.float32)\n+_DATATYPES[PointField.FLOAT64] = np.dtype(np.float64)\n+\n+DUMMY_FIELD_PREFIX = 'unnamed_field'\n+\n+\n+def read_points(\n+        cloud: PointCloud2,\n+        field_names: Optional[List[str]] = None,\n+        skip_nans: bool = False,\n+        uvs: Optional[Iterable] = None,\n+        reshape_organized_cloud: bool = False) -> np.ndarray:"},{"role":"user","content":"-        coordinates. (Type: Iterable, Default: empty list)\n-    :return: Generator which yields a list of values for each point.\n+        coordinates. (Type: Iterable, Default: None)\n+    :param reshape_organized_cloud: Returns the array as an 2D organized point cloud if set.\n+    :return: Structured NumPy array containing all points."},{"role":"user","content":"-        'cloud is not a sensor_msgs.msg.PointCloud2'\n-    fmt = _get_struct_fmt(cloud.is_bigendian, cloud.fields, field_names)\n-    width, height, point_step, row_step, data, isnan = \\\n-        cloud.width, cloud.height, \\\n-        cloud.point_step, cloud.row_step, \\\n-        cloud.data, math.isnan\n-\n-    unpack_from = struct.Struct(fmt).unpack_from\n-\n-    if skip_nans:\n-        if uvs:\n-            for u, v in uvs:\n-                p = unpack_from(data, (row_step * v) + (point_step * u))\n-                has_nan = False\n-                for pv in p:\n-                    if isnan(pv):\n-                        has_nan = True\n-                        break\n-                if not has_nan:\n-                    yield p\n-        else:\n-            for v in range(height):\n-                offset = row_step * v\n-                for u in range(width):\n-                    p = unpack_from(data, offset)\n-                    has_nan = False\n-                    for pv in p:\n-                        if isnan(pv):\n-                            has_nan = True\n-                            break\n-                    if not has_nan:\n-                        yield p\n-                    offset += point_step\n-    else:\n-        if uvs:\n-            for u, v in uvs:\n-                yield unpack_from(data, (row_step * v) + (point_step * u))\n-        else:\n-            for v in range(height):\n-                offset = row_step * v\n-                for u in range(width):\n-                    yield unpack_from(data, offset)\n-                    offset += point_step\n+        'Cloud is not a sensor_msgs.msg.PointCloud2'\n+\n+    # Cast bytes to numpy array\n+    points = np.ndarray(\n+        shape=(cloud.width * cloud.height, ),\n+        dtype=dtype_from_fields(cloud.fields),\n+        buffer=cloud.data)\n+\n+    # Keep only the requested fields\n+    if field_names is not None:\n+        assert all(field_name in points.dtype.names for field_name in field_names), \\\n+            'Requests field is not in the fields of the PointCloud!'\n+        # Mask fields\n+        points = points[list(field_names)]\n+\n+    # Swap array if byte order does not match\n+    if bool(sys.byteorder != 'little') != bool(cloud.is_bigendian):\n+        points = points.byteswap(inplace=True)\n+\n+    # Check if we want to drop points with nan values\n+    if skip_nans and not cloud.is_dense:\n+        # Init mask which selects all points\n+        not_nan_mask = np.ones(len(points), dtype=bool)\n+        for field_name in points.dtype.names:\n+            # Only keep points without any non values in the mask\n+            not_nan_mask = np.logical_and(\n+                not_nan_mask, ~np.isnan(points[field_name]))\n+        # Select these points\n+        points = points[not_nan_mask]\n+\n+    # Select points indexed by the uvs field\n+    if uvs is not None:\n+        # Don't convert to numpy array if it is already one\n+        if not isinstance(uvs, np.ndarray):\n+            uvs = np.fromiter(uvs, int)\n+        # Index requested points\n+        points = points[uvs]\n+\n+    # Cast into 2d array if cloud is 'organized'\n+    if reshape_organized_cloud and cloud.height > 1:\n+        points = points.reshape(cloud.width, cloud.height)\n+\n+    return points\n+\n+\n+def read_points_numpy(\n+        cloud: PointCloud2,\n+        field_names: Optional[List[str]] = None,\n+        skip_nans: bool = False,\n+        uvs: Optional[Iterable] = None,\n+        reshape_organized_cloud: bool = False) -> np.ndarray:\n+    \"\"\"\n+    Read equally typed fields from sensor_msgs.PointCloud2 message as a unstructured numpy array."},{"role":"user","content":"+    This method is better suited if one wants to perform math operations\n+    on e.g. all x,y,z fields.\n+    But it is limited to fields with the same dtype as unstructured numpy arrays\n+    only contain one dtype."},{"role":"user","content":"-def read_points_list(cloud, field_names=None, skip_nans=False, uvs=[]):\n+    :param cloud: The point cloud to read from sensor_msgs.PointCloud2.\n+    :param field_names: The names of fields to read. If None, read all fields.\n+                        (Type: Iterable, Default: None)\n+    :param skip_nans: If True, then don't return any point with a NaN value.\n+                      (Type: Bool, Default: False)\n+    :param uvs: If specified, then only return the points at the given\n+        coordinates. (Type: Iterable, Default: None)\n+    :param reshape_organized_cloud: Returns the array as an 2D organized point cloud if set.\n+    :return: Numpy array containing all points.\n+    \"\"\"\n+    assert all(cloud.fields[0].datatype == field.datatype for field in cloud.fields[1:]), \\\n+        'All fields need to have the same datatype. Use `read_points()` otherwise.'\n+    structured_numpy_array = read_points(\n+        cloud, field_names, skip_nans, uvs, reshape_organized_cloud)\n+    return structured_to_unstructured(structured_numpy_array)\n+\n+\n+def read_points_list(\n+        cloud: PointCloud2,\n+        field_names: Optional[List[str]] = None,\n+        skip_nans: bool = False,\n+        uvs: Optional[Iterable] = None) -> List[NamedTuple]:"},{"role":"user","content":"-                coordinates. (Type: Iterable, Default: empty list]\n+                coordinates. (Type: Iterable, Default: None]"},{"role":"user","content":"-def create_cloud(header, fields, points):\n+def dtype_from_fields(fields: Iterable[PointField]) -> np.dtype:\n+    \"\"\"\n+    Convert a Iterable of sensor_msgs.msg.PointField messages to a np.dtype.\n+\n+    :param fields: The point cloud fields.\n+                   (Type: iterable of sensor_msgs.msg.PointField)\n+    :returns: NumPy datatype\n+    \"\"\"\n+    # Create a lists containing the names, offsets and datatypes of all fields\n+    field_names = []\n+    field_offsets = []\n+    field_datatypes = []\n+    for i, field in enumerate(fields):\n+        # Datatype as numpy datatype\n+        datatype = _DATATYPES[field.datatype]\n+        # Name field\n+        if field.name == '':\n+            name = f'{DUMMY_FIELD_PREFIX}_{i}'\n+        else:\n+            name = field.name\n+        # Handle fields with count > 1 by creating subfields with a suffix consiting\n+        # of \"_\" followed by the subfield counter [0 -> (count - 1)]\n+        assert field.count > 0, \"Can't process fields with count = 0.\"\n+        for a in range(field.count):\n+            # Add suffix if we have multiple subfields\n+            if field.count > 1:\n+                subfield_name = f'{name}_{a}'\n+            else:\n+                subfield_name = name\n+            assert subfield_name not in field_names, 'Duplicate field names are not allowed!'\n+            field_names.append(subfield_name)\n+            # Create new offset that includes subfields\n+            field_offsets.append(field.offset + a * datatype.itemsize)\n+            field_datatypes.append(datatype.str)\n+\n+    # Create a tuple for each field containing name and data type\n+    return np.dtype({\n+        'names': field_names,\n+        'formats': field_datatypes,\n+        'offsets': field_offsets,\n+    })\n+\n+\n+def create_cloud(\n+        header: Header,\n+        fields: Iterable[PointField],\n+        points: Iterable) -> PointCloud2:"},{"role":"user","content":"-    cloud_struct = struct.Struct(_get_struct_fmt(False, fields))\n-\n-    buff = ctypes.create_string_buffer(cloud_struct.size * len(points))\n-\n-    point_step, pack_into = cloud_struct.size, cloud_struct.pack_into\n-    offset = 0\n-    for p in points:\n-        pack_into(buff, offset, *p)\n-        offset += point_step\n-\n-    return PointCloud2(header=header,\n-                       height=1,\n-                       width=len(points),\n-                       is_dense=False,\n-                       is_bigendian=False,\n-                       fields=fields,\n-                       point_step=cloud_struct.size,\n-                       row_step=cloud_struct.size * len(points),\n-                       data=buff.raw)\n-\n-\n-def create_cloud_xyz32(header, points):\n+    # Check if input is numpy array\n+    if isinstance(points, np.ndarray):\n+        # Check if this is an unstructured array\n+        if points.dtype.names is None:\n+            assert all(fields[0].datatype == field.datatype for field in fields[1:]), \\\n+                'All fields need to have the same datatype. Pass a structured NumPy array \\\n+                    with multiple dtypes otherwise.'\n+            # Convert unstructured to structured array\n+            points = unstructured_to_structured(\n+                points,\n+                dtype=dtype_from_fields(fields))\n+        else:\n+            assert points.dtype == dtype_from_fields(fields), \\\n+                'PointFields and structured NumPy array dtype do not match for all fields! \\\n+                    Check their field order, names and types.'\n+    else:\n+        # Cast python objects to structured NumPy array (slow)\n+        points = np.array(\n+            # Points need to be tuples in the structured array\n+            list(map(tuple, points)),\n+            dtype=dtype_from_fields(fields))\n+\n+    # Handle organized clouds\n+    assert len(points.shape) <= 2, \\\n+        'Too many dimensions for organized cloud! \\\n+            Points can only be organized in max. two dimensional space'\n+    height = 1\n+    width = points.shape[0]\n+    # Check if input points are an organized cloud (2D array of points)\n+    if len(points.shape) == 2:\n+        height = points.shape[1]\n+\n+    # Convert numpy points to array.array\n+    memory_view = memoryview(points)\n+    casted = memory_view.cast('B')\n+    array_array = array.array('B')\n+    array_array.frombytes(casted)\n+\n+    # Put everything together\n+    cloud = PointCloud2(\n+        header=header,\n+        height=height,\n+        width=width,\n+        is_dense=False,\n+        is_bigendian=sys.byteorder != 'little',\n+        fields=fields,\n+        point_step=points.dtype.itemsize,\n+        row_step=(points.dtype.itemsize * width))\n+    # Set cloud via property instead of the constructor because of the bug described in\n+    # https://github.com/ros2/common_interfaces/issues/176\n+    cloud.data = array_array\n+    return cloud\n+\n+\n+def create_cloud_xyz32(header: Header, points: Iterable) -> PointCloud2:"},{"role":"user","content":"-\n-\n-def _get_struct_fmt(is_bigendian, fields, field_names=None):\n-    fmt = '>' if is_bigendian else '<'\n-\n-    offset = 0\n-    for field in (f for f in sorted(fields, key=lambda f: f.offset)\n-                  if field_names is None or f.name in field_names):\n-        if offset < field.offset:\n-            fmt += 'x' * (field.offset - offset)\n-            offset = field.offset\n-        if field.datatype not in _DATATYPES:\n-            print('Skipping unknown PointField datatype [%d]' %\n-                  field.datatype, file=sys.stderr)\n-        else:\n-            datatype_fmt, datatype_length = _DATATYPES[field.datatype]\n-            fmt += field.count * datatype_fmt\n-            offset += field.count * datatype_length\n-\n-    return fmt"},{"role":"user","content":"+import sys"},{"role":"user","content":"-\n-from sensor_msgs.msg import PointCloud2\n-from sensor_msgs.msg import PointField\n+from numpy.lib.recfunctions import structured_to_unstructured\n+from sensor_msgs.msg import PointCloud2, PointField"},{"role":"user","content":"-"},{"role":"user","content":"-          [4.0, np.nan, 4.2]]\n+          [4.0, np.nan, 4.2],\n+          [5.0, 5.1, 5.2]]"},{"role":"user","content":"-    is_bigendian=False,  # Not sure how to properly determine this.\n+    is_bigendian=sys.byteorder != 'little',"},{"role":"user","content":"-    is_bigendian=False,  # Not sure how to properly determine this.\n+    is_bigendian=sys.byteorder != 'little',"},{"role":"user","content":"-    point_step=(itemsize * 2),  # Every point consists of three float32s.\n+    point_step=(itemsize * 2),  # Every point consists of two float32s."},{"role":"user","content":"+# Organized point cloud (Points are aligned in 2D matrix)\n+points3 = points.reshape(2, 3, -1)\n+pcd3 = PointCloud2(\n+    header=Header(frame_id='frame'),\n+    height=points3.shape[1],\n+    width=points3.shape[0],\n+    is_dense=False,\n+    is_bigendian=sys.byteorder != 'little',\n+    fields=fields,\n+    # Every point consists of three float32s.\n+    point_step=(itemsize * points3.shape[-1]),\n+    row_step=(itemsize * points3.shape[-1] * points3.shape[0]),\n+    data=points3.tobytes()\n+)\n+\n+# Check multiple datatype pointclouds\n+struct_points = np.array(\n+    # Make each point a tuple\n+    list(map(tuple, points)),\n+    dtype=[\n+        ('a', np.float32),\n+        ('b', np.float64),\n+        ('c', np.uint8),\n+    ])\n+\n+struct_points_itemsize = struct_points.itemsize\n+\n+struct_points_fields = [\n+    PointField(name='a', offset=0, datatype=PointField.FLOAT32, count=1),\n+    PointField(name='b', offset=4, datatype=PointField.FLOAT64, count=1),\n+    PointField(name='c', offset=12, datatype=PointField.UINT8, count=1)]\n+\n+pcd4 = PointCloud2(\n+    header=Header(frame_id='frame'),\n+    height=1,\n+    width=struct_points.shape[0],\n+    is_dense=False,\n+    is_bigendian=sys.byteorder != 'little',\n+    fields=struct_points_fields,\n+    # This time a struct array is used.\n+    # The itemsize therfore represents the size of a complete point\n+    point_step=struct_points_itemsize,\n+    row_step=(struct_points_itemsize * points.shape[0]),\n+    data=struct_points.tobytes()\n+)\n+\n+# Point cloud with a field with count > 1\n+count = 3\n+fields5 = [PointField(name='x', offset=0, datatype=PointField.FLOAT32, count=3)]\n+\n+itemsize = points.itemsize * count\n+data = points.tobytes()\n+\n+pcd5 = PointCloud2(\n+    header=Header(frame_id='frame'),\n+    height=1,\n+    width=points.shape[0],\n+    is_dense=False,\n+    is_bigendian=sys.byteorder != 'little',\n+    fields=fields5,\n+    point_step=(itemsize),\n+    row_step=(itemsize * points.shape[0]),\n+    data=data\n+)\n+"},{"role":"user","content":"-        pcd_list = list(point_cloud2.read_points(pcd))\n+        pcd_list = list(map(list, point_cloud2.read_points(pcd)))"},{"role":"user","content":"-        pcd_list = list(point_cloud2.read_points(pcd, field_names=['x', 'z']))\n+        pcd_list = list(map(\n+            list,\n+            point_cloud2.read_points(pcd, field_names=['x', 'z'])))"},{"role":"user","content":"-        pcd_list = list(point_cloud2.read_points(pcd, skip_nans=True))\n+        pcd_list = list(map(\n+            list,\n+            point_cloud2.read_points(pcd, skip_nans=True)))"},{"role":"user","content":"-        self.assertTrue(np.allclose(np.array(points_named), points, equal_nan=True))\n+        self.assertTrue(np.allclose(\n+            np.array(points_named), points, equal_nan=True))\n+\n+    def test_read_points_organized(self):\n+        # Checks if organized clouds are handled correctly\n+        # Test if it is converted into a unorganized one by default\n+        pcd_list = list(map(list, point_cloud2.read_points(pcd3)))\n+        self.assertTrue(np.allclose(pcd_list, pylist, equal_nan=True))\n+        # Test if organization is correctly if requested\n+        pcd_points = point_cloud2.read_points(\n+            pcd3, reshape_organized_cloud=True)\n+        # Because we have a 2d array of points now it is easier to cat it into a\n+        # unstructured NumPy array instead of converting it into a list of lists\n+        pcd_points = structured_to_unstructured(pcd_points)\n+        self.assertTrue(np.allclose(pcd_points, points3, equal_nan=True))\n+\n+    def test_read_points_numpy(self):\n+        # Checks if the deserialization to an unstructured numpy array works\n+        pcd_points = point_cloud2.read_points_numpy(pcd)\n+        self.assertTrue(np.allclose(pcd_points, points, equal_nan=True))\n+\n+    def test_read_points_different_types(self):\n+        # Checks if the deserialization to an unstructured numpy array works\n+        pcd_points = point_cloud2.read_points(pcd4)\n+        self.assertTrue(\n+            all(np.allclose(pcd_points[name], struct_points[name], equal_nan=True)\n+                for name in struct_points.dtype.names))\n+        self.assertEqual(struct_points.dtype, pcd_points.dtype)\n+\n+    def test_read_points_non_one_count(self):\n+        pcd_points = point_cloud2.read_points_numpy(pcd5)\n+        self.assertTrue(\n+            np.allclose(pcd_points, points, equal_nan=True))\n+\n+    def test_read_points_non_one_count_structured(self):\n+        pcd_points = point_cloud2.read_points(pcd5)\n+        pcd_points_unstructured = structured_to_unstructured(pcd_points)\n+        self.assertTrue(\n+            np.allclose(pcd_points_unstructured, points, equal_nan=True))\n+        self.assertEqual(pcd_points.dtype.names, ('x_0', 'x_1', 'x_2'))"},{"role":"user","content":"-        self.assertTrue(thispcd == pcd)\n+        self.assertEqual(thispcd, pcd)"},{"role":"user","content":"+    def test_create_cloud_different_types(self):\n+        # Check if we are able to create a point cloud with different data\n+        thispcd = point_cloud2.create_cloud(\n+            Header(frame_id='frame'),\n+            struct_points_fields,\n+            struct_points)\n+        self.assertEqual(thispcd, pcd4)\n+"},{"role":"user","content":"-        thispcd = point_cloud2.create_cloud_xyz32(Header(frame_id='frame'),\n-                                                  pylist)\n-        self.assertTrue(thispcd == pcd)\n+        thispcd = point_cloud2.create_cloud_xyz32(\n+            Header(frame_id='frame'),\n+            pylist)\n+        self.assertEqual(thispcd, pcd)\n+\n+    def test_create_cloud_xyz32_organized(self):\n+        # Checks if organized clouds are handled correctly\n+        thispcd = point_cloud2.create_cloud_xyz32(\n+            Header(frame_id='frame'),\n+            points3)\n+        print(thispcd)\n+        print(pcd3)\n+        self.assertEqual(thispcd, pcd3)\n+\n+    def test_create_cloud__non_one_count(self):\n+        thispcd = point_cloud2.create_cloud(\n+            Header(frame_id='frame'),\n+            fields5,\n+            points)\n+        self.assertEqual(thispcd, pcd5)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master"},{"role":"user","content":"-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"tracetools/tracetools.h\"\n+"},{"role":"user","content":"+  if (TRACETOOLS_TRACEPOINT_ENABLED(rmw_client_init)) {\n+    TRACETOOLS_DO_TRACEPOINT(\n+      rmw_client_init, static_cast<const void *>(rmw_client),\n+      client_info->subscriber_gid.data);\n+  }\n+"},{"role":"user","content":"+      TRACETOOLS_TRACEPOINT(\n+        rmw_send_request,\n+        static_cast<const void *>(client),\n+        static_cast<const void *>(ros_request),\n+        *sequence_id);\n+"},{"role":"user","content":"+  TRACETOOLS_TRACEPOINT(\n+    rmw_take_response,\n+    static_cast<const void *>(client),\n+    static_cast<const void *>(ros_response),\n+    request_header->request_id.sequence_number,\n+    request_header->source_timestamp,\n+    *taken);\n+"},{"role":"user","content":"+#include \"tracetools/tracetools.h\"\n+"},{"role":"user","content":"+\n+  TRACETOOLS_TRACEPOINT(\n+    rmw_take_request,\n+    static_cast<const void *>(service),\n+    static_cast<const void *>(ros_request),\n+    request_header->request_id.writer_guid,\n+    request_header->request_id.sequence_number,\n+    *taken);\n+"},{"role":"user","content":"+    dds_Time_get_current_time(&sampleinfo_ex.info.source_timestamp);\n+    TRACETOOLS_TRACEPOINT(\n+      rmw_send_response,\n+      static_cast<const void *>(service),\n+      static_cast<const void *>(ros_response),\n+      request_header->writer_guid,\n+      request_header->sequence_number,\n+      rmw_gurumdds_cpp::dds_time_to_i64(sampleinfo_ex.info.source_timestamp));\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ament_add_gtest(test_message_pool_memory_strategy rclcpp/strategies/test_message_pool_memory_strategy.cpp)\n+if(TARGET test_message_pool_memory_strategy)\n+  ament_target_dependencies(test_message_pool_memory_strategy\n+    \"rcl\"\n+    \"test_msgs\"\n+  )\n+  target_link_libraries(test_message_pool_memory_strategy ${PROJECT_NAME})\n+endif()"},{"role":"user","content":"+ament_add_gtest(test_memory_strategy rclcpp/test_memory_strategy.cpp)\n+ament_target_dependencies(test_memory_strategy\n+  \"test_msgs\"\n+)\n+target_link_libraries(test_memory_strategy ${PROJECT_NAME})\n+\n+ament_add_gtest(test_message_memory_strategy rclcpp/test_message_memory_strategy.cpp)\n+ament_target_dependencies(test_message_memory_strategy\n+  \"test_msgs\"\n+)\n+target_link_libraries(test_message_memory_strategy ${PROJECT_NAME})\n+"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <memory>\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"rclcpp/strategies/message_pool_memory_strategy.hpp\"\n+#include \"test_msgs/msg/empty.hpp\"\n+#include \"../../utils/rclcpp_gtest_macros.hpp\"\n+\n+using rclcpp::strategies::message_pool_memory_strategy::MessagePoolMemoryStrategy;\n+\n+class TestMessagePoolMemoryStrategy : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    message_memory_strategy_ =\n+      std::make_shared<MessagePoolMemoryStrategy<test_msgs::msg::Empty, 1>>();\n+  }\n+\n+protected:\n+  std::shared_ptr<MessagePoolMemoryStrategy<test_msgs::msg::Empty, 1>> message_memory_strategy_;\n+};\n+\n+TEST_F(TestMessagePoolMemoryStrategy, construct_destruct) {\n+  ASSERT_NE(nullptr, message_memory_strategy_);\n+  EXPECT_NE(nullptr, message_memory_strategy_->message_allocator_);\n+  EXPECT_NE(nullptr, message_memory_strategy_->serialized_message_allocator_);\n+  EXPECT_NE(nullptr, message_memory_strategy_->buffer_allocator_);\n+}\n+\n+TEST_F(TestMessagePoolMemoryStrategy, borrow_return) {\n+  auto message = message_memory_strategy_->borrow_message();\n+  ASSERT_NE(nullptr, message);\n+\n+  EXPECT_NO_THROW(message_memory_strategy_->return_message(message));\n+}\n+\n+TEST_F(TestMessagePoolMemoryStrategy, borrow_too_many) {\n+  auto message = message_memory_strategy_->borrow_message();\n+  ASSERT_NE(nullptr, message);\n+\n+  // Size is 1, borrowing second time should fail\n+  RCLCPP_EXPECT_THROW_EQ(\n+    message_memory_strategy_->borrow_message(),\n+    std::runtime_error(\"Tried to access message that was still in use! Abort.\"));\n+  EXPECT_NO_THROW(message_memory_strategy_->return_message(message));\n+}\n+\n+TEST_F(TestMessagePoolMemoryStrategy, return_unrecognized) {\n+  auto message = message_memory_strategy_->borrow_message();\n+  ASSERT_NE(nullptr, message);\n+\n+  auto unrecognized = std::make_shared<test_msgs::msg::Empty>();\n+  // Unrecognized does not belong to pool\n+  RCLCPP_EXPECT_THROW_EQ(\n+    message_memory_strategy_->return_message(unrecognized),\n+    std::runtime_error(\"Unrecognized message ptr in return_message.\"));\n+  EXPECT_NO_THROW(message_memory_strategy_->return_message(message));\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <list>\n+#include <memory>\n+#include <utility>\n+\n+#include \"rclcpp/strategies/allocator_memory_strategy.hpp\"\n+#include \"rclcpp/memory_strategy.hpp\"\n+#include \"test_msgs/msg/empty.hpp\"\n+#include \"test_msgs/srv/empty.hpp\"\n+\n+using rclcpp::memory_strategy::MemoryStrategy;\n+using WeakNodeList = std::list<rclcpp::node_interfaces::NodeBaseInterface::WeakPtr>;\n+\n+/**\n+ * Mock Waitable class\n+ */\n+class TestWaitable : public rclcpp::Waitable\n+{\n+public:\n+  bool add_to_wait_set(rcl_wait_set_t *) override {return true;}\n+  bool is_ready(rcl_wait_set_t *) override {return true;}\n+  void execute() override {}\n+};\n+\n+class TestMemoryStrategy : public ::testing::Test\n+{\n+public:\n+  TestMemoryStrategy()\n+  : memory_strategy_(nullptr) {}\n+\n+  void SetUp() override\n+  {\n+    rclcpp::init(0, nullptr);\n+\n+    // This doesn't test AllocatorMemoryStrategy directly, so we cast to the base class.\n+    // AllocatorMemoryStrategy is more commonly used than MessagePoolMemoryStrategy\n+    // so we use this derived class for these tests.\n+    memory_strategy_ =\n+      std::make_shared<\n+      rclcpp::memory_strategies::allocator_memory_strategy::AllocatorMemoryStrategy<>>();\n+  }\n+\n+  void TearDown() override\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+protected:\n+  std::shared_ptr<MemoryStrategy> memory_strategy()\n+  {\n+    return memory_strategy_;\n+  }\n+\n+private:\n+  std::shared_ptr<MemoryStrategy> memory_strategy_;\n+};\n+\n+TEST_F(TestMemoryStrategy, construct_destruct) {\n+  EXPECT_NE(nullptr, memory_strategy());\n+}\n+\n+TEST_F(TestMemoryStrategy, get_subscription_by_handle) {\n+  WeakNodeList nodes;\n+  std::shared_ptr<const rcl_subscription_t> subscription_handle;\n+  rclcpp::SubscriptionBase::SharedPtr found_subscription = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+      const rclcpp::QoS qos(10);\n+\n+      {\n+        auto subscription = node->create_subscription<\n+          test_msgs::msg::Empty, decltype(subscription_callback)>(\n+          \"topic\", qos, std::move(subscription_callback));\n+\n+        subscription_handle = subscription->get_subscription_handle();\n+\n+        EXPECT_EQ(\n+          subscription,\n+          memory_strategy()->get_subscription_by_handle(subscription_handle, nodes));\n+      }  // subscription goes out of scope\n+      EXPECT_EQ(\n+        nullptr,\n+        memory_strategy()->get_subscription_by_handle(subscription_handle, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_subscription_by_handle(subscription_handle, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_subscription_by_handle(subscription_handle, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_service_by_handle) {\n+  WeakNodeList nodes;\n+  std::shared_ptr<const rcl_service_t> service_handle;\n+  rclcpp::ServiceBase::SharedPtr found_service = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      auto service_callback =\n+        [](const test_msgs::srv::Empty::Request::SharedPtr,\n+          test_msgs::srv::Empty::Response::SharedPtr) {};\n+      const rclcpp::QoS qos(10);\n+\n+      {\n+        auto service = node->create_service<test_msgs::srv::Empty>(\n+          \"service\", std::move(service_callback),\n+          rmw_qos_profile_services_default, callback_group);\n+\n+        service_handle = service->get_service_handle();\n+\n+        EXPECT_EQ(\n+          service,\n+          memory_strategy()->get_service_by_handle(service_handle, nodes));\n+      }  // service goes out of scope\n+      EXPECT_EQ(\n+        nullptr,\n+        memory_strategy()->get_service_by_handle(service_handle, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_service_by_handle(service_handle, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_service_by_handle(service_handle, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_client_by_handle) {\n+  WeakNodeList nodes;\n+  std::shared_ptr<const rcl_client_t> client_handle;\n+  rclcpp::ClientBase::SharedPtr found_client = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      {\n+        auto client = node->create_client<test_msgs::srv::Empty>(\n+          \"service\", rmw_qos_profile_services_default, callback_group);\n+\n+        client_handle = client->get_client_handle();\n+\n+        EXPECT_EQ(\n+          client,\n+          memory_strategy()->get_client_by_handle(client_handle, nodes));\n+      }  // client goes out of scope\n+      EXPECT_EQ(\n+        nullptr,\n+        memory_strategy()->get_client_by_handle(client_handle, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_client_by_handle(client_handle, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_client_by_handle(client_handle, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_timer_by_handle) {\n+  WeakNodeList nodes;\n+  std::shared_ptr<const rcl_timer_t> timer_handle;\n+  rclcpp::TimerBase::SharedPtr found_timer = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      {\n+        auto timer_callback = []() {};\n+        auto timer = node->create_wall_timer(\n+          std::chrono::milliseconds(1), timer_callback, callback_group);\n+\n+        timer_handle = timer->get_timer_handle();\n+\n+        EXPECT_EQ(\n+          timer,\n+          memory_strategy()->get_timer_by_handle(timer_handle, nodes));\n+      }  // timer goes out of scope\n+      EXPECT_EQ(\n+        nullptr,\n+        memory_strategy()->get_timer_by_handle(timer_handle, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_timer_by_handle(timer_handle, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_timer_by_handle(timer_handle, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_node_by_group) {\n+  WeakNodeList nodes;\n+  rclcpp::CallbackGroup::SharedPtr callback_group = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    auto node_handle = node->get_node_base_interface();\n+    nodes.push_back(node_handle);\n+    memory_strategy()->collect_entities(nodes);\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_node_by_group(nullptr, nodes));\n+\n+    callback_group =\n+      node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+    EXPECT_EQ(\n+      node_handle,\n+      memory_strategy()->get_node_by_group(callback_group, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_node_by_group(callback_group, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_group_by_subscription) {\n+  WeakNodeList nodes;\n+  rclcpp::SubscriptionBase::SharedPtr subscription = nullptr;\n+  rclcpp::CallbackGroup::SharedPtr callback_group = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      // This group is just used to test that a callback group that is held as a weak pointer\n+      // by node, doesn't confuse get_group_by_subscription() when it goes out of scope\n+      auto non_persistant_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+      callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+      const rclcpp::QoS qos(10);\n+\n+      rclcpp::SubscriptionOptions subscription_options;\n+\n+      // This callback group is held as a shared_ptr in subscription_options, which means it\n+      // stays alive as long as subscription does.\n+      subscription_options.callback_group = callback_group;\n+\n+      subscription = node->create_subscription<\n+        test_msgs::msg::Empty, decltype(subscription_callback)>(\n+        \"topic\", qos, std::move(subscription_callback), subscription_options);\n+\n+      EXPECT_EQ(\n+        callback_group,\n+        memory_strategy()->get_group_by_subscription(subscription, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      callback_group,\n+      memory_strategy()->get_group_by_subscription(subscription, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_group_by_subscription(subscription, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_group_by_service) {\n+  WeakNodeList nodes;\n+  rclcpp::ServiceBase::SharedPtr service = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      auto service_callback =\n+        [](const test_msgs::srv::Empty::Request::SharedPtr,\n+          test_msgs::srv::Empty::Response::SharedPtr) {};\n+      const rclcpp::QoS qos(10);\n+\n+      service = node->create_service<test_msgs::srv::Empty>(\n+        \"service\", std::move(service_callback),\n+        rmw_qos_profile_services_default, callback_group);\n+\n+      EXPECT_EQ(\n+        callback_group,\n+        memory_strategy()->get_group_by_service(service, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_group_by_service(service, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_group_by_service(service, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_group_by_client) {\n+  WeakNodeList nodes;\n+  rclcpp::ClientBase::SharedPtr client = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+      client = node->create_client<test_msgs::srv::Empty>(\n+        \"service\", rmw_qos_profile_services_default, callback_group);\n+\n+      EXPECT_EQ(\n+        callback_group,\n+        memory_strategy()->get_group_by_client(client, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_group_by_client(client, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_group_by_client(client, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_group_by_timer) {\n+  WeakNodeList nodes;\n+  rclcpp::TimerBase::SharedPtr timer = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      auto timer_callback = []() {};\n+      timer = node->create_wall_timer(\n+        std::chrono::milliseconds(1), timer_callback, callback_group);\n+\n+      EXPECT_EQ(\n+        callback_group,\n+        memory_strategy()->get_group_by_timer(timer, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_group_by_timer(timer, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_group_by_timer(timer, nodes));\n+}\n+\n+TEST_F(TestMemoryStrategy, get_group_by_waitable) {\n+  WeakNodeList nodes;\n+  rclcpp::Waitable::SharedPtr waitable = nullptr;\n+  {\n+    auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+    nodes.push_back(node->get_node_base_interface());\n+    memory_strategy()->collect_entities(nodes);\n+    {\n+      waitable = std::make_shared<TestWaitable>();\n+      auto callback_group =\n+        node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+      node->get_node_waitables_interface()->add_waitable(waitable, callback_group);\n+\n+      EXPECT_EQ(\n+        callback_group,\n+        memory_strategy()->get_group_by_waitable(waitable, nodes));\n+    }  // callback_group goes out of scope\n+    EXPECT_EQ(\n+      nullptr,\n+      memory_strategy()->get_group_by_waitable(waitable, nodes));\n+  }  // Node goes out of scope\n+  EXPECT_EQ(\n+    nullptr,\n+    memory_strategy()->get_group_by_waitable(waitable, nodes));\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+\n+#include \"rclcpp/message_memory_strategy.hpp\"\n+#include \"test_msgs/msg/empty.hpp\"\n+\n+TEST(TestMemoryStrategies, construct_destruct) {\n+  rclcpp::message_memory_strategy::MessageMemoryStrategy<test_msgs::msg::Empty> memory_strategy1;\n+\n+  EXPECT_NE(nullptr, memory_strategy1.message_allocator_);\n+  EXPECT_NE(nullptr, memory_strategy1.serialized_message_allocator_);\n+  EXPECT_NE(nullptr, memory_strategy1.buffer_allocator_);\n+\n+  auto allocator = std::make_shared<std::allocator<void>>();\n+  rclcpp::message_memory_strategy::MessageMemoryStrategy<test_msgs::msg::Empty> memory_strategy2(\n+    allocator);\n+\n+  EXPECT_NE(nullptr, memory_strategy2.message_allocator_);\n+  EXPECT_NE(nullptr, memory_strategy2.serialized_message_allocator_);\n+  EXPECT_NE(nullptr, memory_strategy2.buffer_allocator_);\n+}\n+\n+TEST(TestMemoryStrategies, standard_allocation) {\n+  auto memory_strategy =\n+    rclcpp::message_memory_strategy::MessageMemoryStrategy<\n+    test_msgs::msg::Empty>::create_default();\n+  ASSERT_NE(nullptr, memory_strategy);\n+\n+  auto borrowed_message = memory_strategy->borrow_message();\n+  ASSERT_NE(nullptr, borrowed_message);\n+  EXPECT_NO_THROW(memory_strategy->return_message(borrowed_message));\n+\n+  auto serialized_message = memory_strategy->borrow_serialized_message();\n+  ASSERT_NE(nullptr, serialized_message);\n+  EXPECT_EQ(0u, serialized_message->capacity());\n+  EXPECT_NO_THROW(memory_strategy->return_serialized_message(serialized_message));\n+\n+  memory_strategy->set_default_buffer_capacity(42);\n+  serialized_message = memory_strategy->borrow_serialized_message();\n+  ASSERT_NE(nullptr, serialized_message);\n+  EXPECT_EQ(42u, serialized_message->capacity());\n+  EXPECT_NO_THROW(memory_strategy->return_serialized_message(serialized_message));\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-   * \\return true by default\n+   * \\return SUCCESS by default"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-* `fastcdr`\n-* `fastrtps`\n+* `fastcdr`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n+* `fastrtps`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)"},{"role":"user","content":"-* `fastcdr`\n-* `fastrtps`\n+* `fastcdr`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n+* `fastrtps`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)"},{"role":"user","content":"-* `fastcdr`\n-* `fastrtps`\n+* `fastcdr`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n+* `fastrtps`: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+namespace rmw_gurumdds_cpp\n+{\n+void on_participant_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_ParticipantBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle);\n+\n+void on_publication_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_PublicationBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle);\n+\n+void on_subscription_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_SubscriptionBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle);\n+} // namespace rmw_gurumdds_cpp\n+"},{"role":"user","content":"-void on_participant_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_ParticipantBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-void on_publication_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_PublicationBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-void on_subscription_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_SubscriptionBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-struct WaitSetInfo\n-{\n-  dds_WaitSet * wait_set;\n-  dds_ConditionSeq * active_conditions;\n-  dds_ConditionSeq * attached_conditions;\n-};\n-"},{"role":"user","content":"+struct WaitSetInfo\n+{\n+  dds_WaitSet * wait_set;\n+  dds_ConditionSeq * active_conditions;\n+  dds_ConditionSeq * attached_conditions;\n+};\n+"},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/wait.hpp\""},{"role":"user","content":"+#include <cstdint>"},{"role":"user","content":"+#include <map>\n+#include <string>\n+#include <vector>"},{"role":"user","content":"+#include \"rmw/impl/cpp/key_value.hpp\"\n+\n+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+namespace rmw_gurumdds_cpp\n+{\n+static inline std::map<std::string, std::vector<uint8_t>>\n+parse_map(uint8_t * const data, const uint32_t data_len)\n+{\n+  std::vector<uint8_t> data_vec(data, data + data_len);\n+  std::map<std::string, std::vector<uint8_t>> map\n+    = rmw::impl::cpp::parse_key_value(data_vec);\n+  return map;\n+}\n+\n+static inline rmw_ret_t\n+get_user_data_key(\n+  dds_ParticipantBuiltinTopicData * data,\n+  const std::string& key,\n+  std::string & value,\n+  bool & found)\n+{\n+  found = false;\n+  uint8_t * user_data =\n+    static_cast<uint8_t *>(data->user_data.value);\n+  const uint32_t user_data_len = data->user_data.size;\n+  if (user_data_len == 0) {\n+    return RMW_RET_OK;\n+  }\n+\n+  auto map = parse_map(user_data, user_data_len);\n+  auto name_found = map.find(key);\n+  if (name_found != map.end()) {\n+    value = std::string(name_found->second.begin(), name_found->second.end());\n+    found = true;\n+  }\n+\n+  return RMW_RET_OK;\n+}\n+\n+void on_participant_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_ParticipantBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle)\n+{\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  rmw_gurumdds_cpp::Guid_t dp_guid{*data};\n+  if (handle == dds_HANDLE_NIL) {\n+    rmw_gurumdds_cpp::graph_cache::remove_participant(ctx, &dp_guid);\n+  } else {\n+    std::string enclave_str;\n+    bool enclave_found;\n+    dds_ReturnCode_t rc =\n+      get_user_data_key(\n+      const_cast<dds_ParticipantBuiltinTopicData *>(data),\n+      \"securitycontext\", enclave_str, enclave_found);\n+    if (RMW_RET_OK != rc) {\n+      RMW_SET_ERROR_MSG(\"failed to parse user data for enclave\");\n+    }\n+\n+    const char * enclave = nullptr;\n+    if (enclave_found) {\n+      enclave = enclave_str.c_str();\n+    }\n+\n+    if (RMW_RET_OK != rmw_gurumdds_cpp::graph_cache::add_participant(ctx, &dp_guid, enclave)) {\n+      RMW_SET_ERROR_MSG(\"failed to assert remote participant in graph\");\n+    }\n+  }\n+}\n+\n+void on_publication_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_PublicationBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle)\n+{\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n+  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n+  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n+  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);\n+  if (handle == dds_HANDLE_NIL) {\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      \"pub on data available\",\n+      \"[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \",\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],\n+      endp_guid.entityId);\n+    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, &endp_guid, false);\n+  } else {\n+    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n+      ctx,\n+      &endp_guid,\n+      &dp_guid,\n+      data->topic_name,\n+      data->type_name,\n+      data->user_data,\n+      &data->reliability,\n+      &data->durability,\n+      &data->deadline,\n+      &data->liveliness,\n+      &data->lifespan,\n+      false);\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      \"pub on data available\",\n+      \"dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \"\n+      \"gid=0x%08X.0x%08X.0x%08X.0x%08X, \",\n+      dp_guid_prefix[0],\n+      dp_guid_prefix[1],\n+      dp_guid_prefix[2],\n+      dp_guid.entityId,\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],\n+      endp_guid.entityId);\n+  }\n+}\n+\n+void on_subscription_changed(\n+  const dds_DomainParticipant * a_participant,\n+  const dds_SubscriptionBuiltinTopicData * data,\n+  dds_InstanceHandle_t handle)\n+{\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );\n+  if (ctx == nullptr) {\n+    return;\n+  }\n+\n+  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n+  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n+  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n+  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);\n+  if (handle == dds_HANDLE_NIL) {\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      \"sub on data available\",\n+      \"[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \",\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],\n+      endp_guid.entityId);\n+    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, &endp_guid, false);\n+  } else {\n+    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n+      ctx,\n+      &endp_guid,\n+      &dp_guid,\n+      data->topic_name,\n+      data->type_name,\n+      data->user_data,\n+      &data->reliability,\n+      &data->durability,\n+      &data->deadline,\n+      &data->liveliness,\n+      nullptr,\n+      true);\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      \"sub on data available\",\n+      \"dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \"\n+      \"gid=0x%08X.0x%08X.0x%08X.0x%08X, \",\n+      dp_guid_prefix[0],\n+      dp_guid_prefix[1],\n+      dp_guid_prefix[2],\n+      dp_guid.entityId,\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],\n+      endp_guid.entityId);\n+  }\n+}\n+} // namespace rmw_gurumdds_cpp\n+"},{"role":"user","content":"-#include \"rmw/impl/cpp/key_value.hpp\"\n-"},{"role":"user","content":"-static inline std::map<std::string, std::vector<uint8_t>>\n-parse_map(uint8_t * const data, const uint32_t data_len)\n-{\n-  std::vector<uint8_t> data_vec(data, data + data_len);\n-  std::map<std::string, std::vector<uint8_t>> map\n-    = rmw::impl::cpp::parse_key_value(data_vec);\n-  return map;\n-}\n-\n-static inline rmw_ret_t\n-get_user_data_key(\n-  dds_ParticipantBuiltinTopicData * data,\n-  const std::string& key,\n-  std::string & value,\n-  bool & found)\n-{\n-  found = false;\n-  uint8_t * user_data =\n-    static_cast<uint8_t *>(data->user_data.value);\n-  const uint32_t user_data_len = data->user_data.size;\n-  if (user_data_len == 0) {\n-    return RMW_RET_OK;\n-  }\n-\n-  auto map = parse_map(user_data, user_data_len);\n-  auto name_found = map.find(key);\n-  if (name_found != map.end()) {\n-    value = std::string(name_found->second.begin(), name_found->second.end());\n-    found = true;\n-  }\n-\n-  return RMW_RET_OK;\n-}\n-\n-void on_participant_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_ParticipantBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid{*data};\n-  if (handle == dds_HANDLE_NIL) {\n-    rmw_gurumdds_cpp::graph_cache::remove_participant(ctx, &dp_guid);\n-  } else {\n-    std::string enclave_str;\n-    bool enclave_found;\n-    dds_ReturnCode_t rc =\n-      get_user_data_key(\n-      const_cast<dds_ParticipantBuiltinTopicData *>(data),\n-      \"securitycontext\", enclave_str, enclave_found);\n-    if (RMW_RET_OK != rc) {\n-      RMW_SET_ERROR_MSG(\"failed to parse user data for enclave\");\n-    }\n-\n-    const char * enclave = nullptr;\n-    if (enclave_found) {\n-      enclave = enclave_str.c_str();\n-    }\n-\n-    if (RMW_RET_OK != rmw_gurumdds_cpp::graph_cache::add_participant(ctx, &dp_guid, enclave)) {\n-      RMW_SET_ERROR_MSG(\"failed to assert remote participant in graph\");\n-    }\n-  }\n-}\n-\n-void on_publication_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_PublicationBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n-  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n-  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n-  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);\n-  if (handle == dds_HANDLE_NIL) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"pub on data available\",\n-      \"[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \",\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, &endp_guid, false);\n-  } else {\n-    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n-      ctx,\n-      &endp_guid,\n-      &dp_guid,\n-      data->topic_name,\n-      data->type_name,\n-      data->user_data,\n-      &data->reliability,\n-      &data->durability,\n-      &data->deadline,\n-      &data->liveliness,\n-      &data->lifespan,\n-      false);\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"pub on data available\",\n-      \"dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \"\n-      \"gid=0x%08X.0x%08X.0x%08X.0x%08X, \",\n-      dp_guid_prefix[0],\n-      dp_guid_prefix[1],\n-      dp_guid_prefix[2],\n-      dp_guid.entityId,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-  }\n-}\n-\n-void on_subscription_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_SubscriptionBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n-  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n-  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n-  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);\n-  if (handle == dds_HANDLE_NIL) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"sub on data available\",\n-      \"[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \",\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, &endp_guid, false);\n-  } else {\n-    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n-      ctx,\n-      &endp_guid,\n-      &dp_guid,\n-      data->topic_name,\n-      data->type_name,\n-      data->user_data,\n-      &data->reliability,\n-      &data->durability,\n-      &data->deadline,\n-      &data->liveliness,\n-      nullptr,\n-      true);\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \"sub on data available\",\n-      \"dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \"\n-      \"gid=0x%08X.0x%08X.0x%08X.0x%08X, \",\n-      dp_guid_prefix[0],\n-      dp_guid_prefix[1],\n-      dp_guid_prefix[2],\n-      dp_guid.entityId,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-  }\n-}\n-"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+    ament_add_gtest(test_serialize_deserialize${target_suffix}\n+      test/test_serialize_deserialize.cpp\n+      ENV ${rmw_implementation_env_var}\n+    )\n+    target_compile_definitions(test_serialize_deserialize${target_suffix}\n+      PUBLIC \"RMW_IMPLEMENTATION=${rmw_implementation}\")\n+    ament_target_dependencies(test_serialize_deserialize${target_suffix}\n+      rcutils rmw rmw_implementation test_msgs\n+    )"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include \"rcutils/allocator.h\"\n+\n+#include \"rosidl_typesupport_cpp/message_type_support.hpp\"\n+\n+#include \"rmw/rmw.h\"\n+#include \"rmw/error_handling.h\"\n+\n+#include \"test_msgs/msg/basic_types.h\"\n+#include \"test_msgs/msg/basic_types.hpp\"\n+\n+#include \"./allocator_testing_utils.h\"\n+\n+#ifdef RMW_IMPLEMENTATION\n+# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n+# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n+#else\n+# define CLASSNAME(NAME, SUFFIX) NAME\n+#endif\n+\n+class CLASSNAME (TestSerializeDeserialize, RMW_IMPLEMENTATION) : public ::testing::Test\n+{\n+};\n+\n+TEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), serialize_with_bad_arguments) {\n+  const rosidl_message_type_support_t * ts{\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n+  test_msgs__msg__BasicTypes input_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&input_message));\n+  rcutils_allocator_t failing_allocator = get_failing_allocator();\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &failing_allocator)) << rmw_get_error_string().str;\n+\n+  EXPECT_NE(RMW_RET_OK, rmw_serialize(&input_message, ts, &serialized_message));\n+  rmw_reset_error();\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) <<\n+    rmw_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), clean_round_trip_for_c_message) {\n+  const rosidl_message_type_support_t * ts{\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n+  test_msgs__msg__BasicTypes input_message{};\n+  test_msgs__msg__BasicTypes output_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&input_message));\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n+\n+  // Make input_message not equal to output_message.\n+  input_message.bool_value = !output_message.bool_value;\n+  input_message.int16_value = output_message.int16_value - 1;\n+  input_message.uint32_value = output_message.uint32_value + 1000000;\n+\n+  rmw_ret_t ret = rmw_serialize(&input_message, ts, &serialized_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_NE(nullptr, serialized_message.buffer);\n+  EXPECT_GT(serialized_message.buffer_length, 0lu);\n+\n+  ret = rmw_deserialize(&serialized_message, ts, &output_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(input_message.bool_value, output_message.bool_value);\n+  EXPECT_EQ(input_message.int16_value, output_message.int16_value);\n+  EXPECT_EQ(input_message.uint32_value, output_message.uint32_value);\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) <<\n+    rmw_get_error_string().str;\n+}\n+\n+TEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), clean_round_trip_for_cpp_message) {\n+  const rosidl_message_type_support_t * ts =\n+    rosidl_typesupport_cpp::get_message_type_support_handle<test_msgs::msg::BasicTypes>();\n+  test_msgs::msg::BasicTypes input_message{};\n+  test_msgs::msg::BasicTypes output_message{};\n+  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n+  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n+  ASSERT_EQ(\n+    RMW_RET_OK, rmw_serialized_message_init(\n+      &serialized_message, 0lu, &default_allocator)) << rmw_get_error_string().str;\n+\n+  // Make input_message not equal to output_message.\n+  input_message.bool_value = !output_message.bool_value;\n+  input_message.int16_value = output_message.int16_value - 1;\n+  input_message.uint32_value = output_message.uint32_value + 1000000;\n+\n+  rmw_ret_t ret = rmw_serialize(&input_message, ts, &serialized_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_NE(nullptr, serialized_message.buffer);\n+  EXPECT_GT(serialized_message.buffer_length, 0lu);\n+\n+  ret = rmw_deserialize(&serialized_message, ts, &output_message);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+  EXPECT_EQ(input_message, output_message);\n+\n+  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(&serialized_message)) <<\n+    rmw_get_error_string().str;\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  template<typename type>\n+  constexpr\n+  typename std::enable_if<\n+    std::is_convertible<\n+      type, const std::vector<int> &>::value, const std::vector<int64_t> &>::type\n+  get() const\n+  {\n+    return get<ParameterType::PARAMETER_INTEGER_ARRAY>();\n+  }\n+"},{"role":"user","content":"+  template<typename type>\n+  constexpr\n+  typename std::enable_if<\n+    std::is_convertible<\n+      type, const std::vector<float> &>::value, const std::vector<double> &>::type\n+  get() const\n+  {\n+    return get<ParameterType::PARAMETER_DOUBLE_ARRAY>();\n+  }\n+"},{"role":"user","content":"+#include <limits>"},{"role":"user","content":"+// test declare parameter with int, int64_t, float and double vector\n+TEST_F(TestNode, declare_parameter_with_vector) {\n+  auto node = std::make_shared<rclcpp::Node>(\n+    \"test_declare_parameter_with_vector\"_unq,\n+    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n+  {\n+    // declare parameter and then get types to check\n+    auto name1 = \"parameter\"_unq;\n+    auto name2 = \"parameter\"_unq;\n+    auto name3 = \"parameter\"_unq;\n+    auto name4 = \"parameter\"_unq;\n+\n+    node->declare_parameter(name1, std::vector<int>{});\n+    node->declare_parameter(name2, std::vector<int64_t>{});\n+    node->declare_parameter(name3, std::vector<float>{});\n+    node->declare_parameter(name4, std::vector<double>{});\n+\n+    EXPECT_TRUE(node->has_parameter(name1));\n+    EXPECT_TRUE(node->has_parameter(name2));\n+    EXPECT_TRUE(node->has_parameter(name3));\n+    EXPECT_TRUE(node->has_parameter(name4));\n+\n+    auto results = node->get_parameter_types({name1, name2, name3, name4});\n+    EXPECT_EQ(results.size(), 4u);\n+    EXPECT_EQ(results[0], rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY);\n+    EXPECT_EQ(results[1], rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY);\n+    EXPECT_EQ(results[2], rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY);\n+    EXPECT_EQ(results[3], rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY);\n+  }\n+  {\n+    // declare parameter and then get values to check\n+    auto name1 = \"parameter\"_unq;\n+    auto name2 = \"parameter\"_unq;\n+    auto name3 = \"parameter\"_unq;\n+    auto name4 = \"parameter\"_unq;\n+\n+    int64_t bigger_than_int = INT64_MAX - 42;\n+    double bigger_than_float = std::numeric_limits<double>::max() - 42;\n+    node->declare_parameter(name1, std::vector<int>{1, 2});\n+    node->declare_parameter(name2, std::vector<int64_t>{3, bigger_than_int});\n+    node->declare_parameter(name3, std::vector<float>{1.5f, 2.8f});\n+    node->declare_parameter(name4, std::vector<double>{3.0, bigger_than_float});\n+\n+    std::vector<rclcpp::Parameter> expected = {\n+      {name1, std::vector<int>{1, 2}},\n+      {name2, std::vector<int64_t>{3, bigger_than_int}},\n+      {name3, std::vector<float>{1.5f, 2.8f}},\n+      {name4, std::vector<double>{3.0, bigger_than_float}},\n+    };\n+    EXPECT_EQ(node->get_parameters({name1, name2, name3, name4}), expected);\n+  }\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <chrono>\n-#include <thread>"},{"role":"user","content":"-  std::this_thread::sleep_for(std::chrono::microseconds(100));"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from rclpy.parameter import Parameter"},{"role":"user","content":"+        use_sim_time = getattr(args, 'use_sim_time', False)"},{"role":"user","content":"-            start_parameter_services=start_parameter_services)\n+            start_parameter_services=start_parameter_services,\n+            parameter_overrides=[\n+                Parameter('use_sim_time', value=use_sim_time)\n+            ])\n+"},{"role":"user","content":"+    parser.add_argument(\n+        '-s', '--use-sim-time', action='store_true',\n+        help='Enable ROS simulation time')"},{"role":"user","content":"+# Copyright 2020 Sony Corporation.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import argparse\n+\n+import pytest\n+\n+from ros2cli.node.direct import add_arguments as add_direct_node_arguments\n+from ros2cli.node.direct import DEFAULT_TIMEOUT\n+from ros2cli.node.direct import DirectNode\n+\n+TEST_NODE_NAME = 'test_node'\n+\n+\n+@pytest.fixture(scope='function')\n+def test_arguments_parser():\n+    parser = argparse.ArgumentParser()\n+    add_direct_node_arguments(parser)\n+    return parser\n+\n+\n+def test_default_arguments(test_arguments_parser):\n+    args = test_arguments_parser.parse_args()\n+    assert not args.use_sim_time\n+    assert DEFAULT_TIMEOUT == args.spin_time\n+\n+\n+def test_use_sim_time_arguments(test_arguments_parser):\n+    args = test_arguments_parser.parse_args(['--use-sim-time'])\n+    assert args.use_sim_time\n+    assert DEFAULT_TIMEOUT == args.spin_time\n+\n+\n+def test_spin_time_arguments(test_arguments_parser):\n+    args = test_arguments_parser.parse_args(['--spin-time', '10.0'])\n+    assert not args.use_sim_time\n+    assert 10.0 == args.spin_time\n+\n+\n+def test_use_sim_time_parameter():\n+    with DirectNode(args=[], node_name=TEST_NODE_NAME) as direct_node:\n+        assert not direct_node.node.get_parameter('use_sim_time').value\n+\n+    args = argparse.Namespace(use_sim_time=False)\n+    with DirectNode(args, node_name=TEST_NODE_NAME) as direct_node:\n+        assert not direct_node.node.get_parameter('use_sim_time').value\n+\n+    # TODO(fujitatomoya): enable this test once /clock callback thread is insulated.\n+    #                     see https://github.com/ros2/rclcpp/issues/1542\n+    # args = argparse.Namespace(use_sim_time=True)\n+    # with DirectNode(args, node_name=TEST_NODE_NAME) as direct_node:\n+    #     assert direct_node.node.get_parameter('use_sim_time').value"},{"role":"user","content":"+from ros2cli.node.direct import add_arguments as add_direct_node_arguments"},{"role":"user","content":"+        add_direct_node_arguments(parser)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  include/rviz_default_plugins/displays/camera_info/camera_info_display.hpp"},{"role":"user","content":"+  src/rviz_default_plugins/displays/camera_info/camera_info_display.cpp"},{"role":"user","content":"+  ament_add_gtest(camera_info_display_visual_test\n+    test/rviz_default_plugins/displays/camera_info/camera_info_display_visual_test.cpp\n+    test/rviz_default_plugins/page_objects/camera_info_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET camera_info_display_visual_test)\n+    target_include_directories(camera_info_display_visual_test PRIVATE test)\n+    target_link_libraries(camera_info_display_visual_test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      ogre_testing_environment\n+    )\n+  endif()\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_\n+#define RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_\n+\n+#ifndef Q_MOC_RUN\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"rviz_default_plugins/visibility_control.hpp\"\n+\n+#include <rviz_common/message_filter_display.hpp>\n+#include <rviz_common/properties/property.hpp>\n+#include <rviz_common/properties/bool_property.hpp>\n+#include <rviz_common/properties/color_property.hpp>\n+#include <rviz_common/properties/float_property.hpp>\n+#include <rviz_common/properties/ros_topic_property.hpp>\n+#include <rviz_rendering/objects/billboard_line.hpp>\n+#include <rviz_rendering/objects/triangle_polygon.hpp>\n+\n+#include <sensor_msgs/msg/camera_info.hpp>\n+#endif\n+\n+namespace rviz_default_plugins\n+{\n+namespace displays\n+{\n+/**\n+ * \\class CameraInfoDisplay\n+ *\n+ */\n+class RVIZ_DEFAULT_PLUGINS_PUBLIC CameraInfoDisplay\n+  : public rviz_common::MessageFilterDisplay<sensor_msgs::msg::CameraInfo>\n+{\n+  Q_OBJECT\n+\n+public:\n+  CameraInfoDisplay();\n+  ~CameraInfoDisplay() override;\n+\n+  // Overrides of public virtual functions from the Display class.\n+  void onInitialize() override;\n+  void reset() override;\n+\n+protected:\n+  void processMessage(const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg);\n+\n+  void update(float wall_dt, float ros_dt) override;\n+  bool isSameCameraInfo(\n+    const sensor_msgs::msg::CameraInfo::ConstSharedPtr & camera_info);\n+  void createCameraInfoShapes(\n+    const sensor_msgs::msg::CameraInfo::ConstSharedPtr & camera_info);\n+  void addPointToEdge(\n+    const Ogre::Vector3 & point);\n+  void addPolygon(\n+    const Ogre::Vector3 & O, const Ogre::Vector3 & A, const Ogre::Vector3 & B, std::string name,\n+    bool use_color, bool upper_triangle);\n+  void prepareMaterial();\n+\n+  std::vector<std::shared_ptr<rviz_rendering::TrianglePolygon>> polygons_;\n+  std::shared_ptr<rviz_rendering::BillboardLine> edges_;\n+  sensor_msgs::msg::CameraInfo::ConstSharedPtr camera_info_;\n+  Ogre::MaterialPtr material_;\n+  Ogre::TexturePtr texture_;\n+\n+  double alpha_;\n+  double far_clip_distance_;\n+  QColor color_;\n+  QColor edge_color_;\n+  bool show_polygons_;\n+  bool show_edges_;\n+  bool not_show_side_polygons_;\n+\n+  rviz_common::properties::FloatProperty * far_clip_distance_property_;\n+  rviz_common::properties::FloatProperty * alpha_property_;\n+  rviz_common::properties::ColorProperty * color_property_;\n+  rviz_common::properties::ColorProperty * edge_color_property_;\n+  rviz_common::properties::BoolProperty * show_polygons_property_;\n+  rviz_common::properties::BoolProperty * not_show_side_polygons_property_;\n+  rviz_common::properties::BoolProperty * show_edges_property_;\n+\n+protected Q_SLOTS:\n+  void updateFarClipDistance();\n+  void updateAlpha();\n+  void updateColor();\n+  void updateShowEdges();\n+  void updateShowPolygons();\n+  void updateNotShowSidePolygons();\n+  void updateEdgeColor();\n+};\n+}  // namespace displays\n+}  // namespace rviz_default_plugins\n+#endif  // RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_"},{"role":"user","content":"+  <class\n+    name=\"rviz_default_plugins/CameraInfo\"\n+    type=\"rviz_default_plugins::displays::CameraInfoDisplay\"\n+    base_class_type=\"rviz_common::Display\"\n+  >\n+    <description>\n+      Displays CameraInfo.\n+    </description>\n+    <message_type>sensor_msgs/msg/CameraInfo</message_type>\n+  </class>\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include \"rviz_default_plugins/displays/camera_info/camera_info_display.hpp\"\n+\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include <OgreMaterialManager.h>\n+#include <OgreTextureManager.h>\n+#include <OgreTechnique.h>\n+#include <OgreHardwarePixelBuffer.h>\n+\n+#include <rviz_common/uniform_string_stream.hpp>\n+#include <rviz_common/properties/parse_color.hpp>\n+\n+#include <rviz_rendering/objects/triangle_polygon.hpp>\n+\n+namespace rviz_default_plugins\n+{\n+namespace displays\n+{\n+static const char * const CAM_INFO_STATUS = \"Camera Info\";\n+\n+CameraInfoDisplay::CameraInfoDisplay()\n+: rviz_common::MessageFilterDisplay<sensor_msgs::msg::CameraInfo>()\n+{\n+  far_clip_distance_property_ = new rviz_common::properties::FloatProperty(\n+    \"Far clip\",\n+    1.0,\n+    \"Far clip distance from the origin of camera info\",\n+    this, SLOT(updateFarClipDistance()));\n+  show_edges_property_ = new rviz_common::properties::BoolProperty(\n+    \"Show edges\",\n+    true,\n+    \"Show edges of the region of the camera info\",\n+    this, SLOT(updateShowEdges()));\n+  show_polygons_property_ = new rviz_common::properties::BoolProperty(\n+    \"Show polygons\",\n+    true,\n+    \"Show polygons of the region of the camera info\",\n+    this, SLOT(updateShowPolygons()));\n+  not_show_side_polygons_property_ = new rviz_common::properties::BoolProperty(\n+    \"Not show side polygons\",\n+    true,\n+    \"Do not show polygons of the region of the camera info\",\n+    this, SLOT(updateNotShowSidePolygons()));\n+\n+  color_property_ = new rviz_common::properties::ColorProperty(\n+    \"Color\",\n+    QColor(85, 255, 255),\n+    \"Color of CameraInfo\",\n+    this, SLOT(updateColor()));\n+  edge_color_property_ = new rviz_common::properties::ColorProperty(\n+    \"Edge color\",\n+    QColor(125, 125, 125),\n+    \"Edge color of CameraInfo\",\n+    this, SLOT(updateEdgeColor()));\n+  alpha_property_ = new rviz_common::properties::FloatProperty(\n+    \"Alpha\",\n+    0.5,\n+    \"Alpha blending value\",\n+    this, SLOT(updateAlpha()));\n+}\n+\n+CameraInfoDisplay::~CameraInfoDisplay()\n+{\n+  if (edges_) {\n+    edges_->clear();\n+  }\n+  polygons_.clear();\n+  delete far_clip_distance_property_;\n+  delete color_property_;\n+  delete alpha_property_;\n+  delete show_polygons_property_;\n+  delete edge_color_property_;\n+}\n+\n+void CameraInfoDisplay::reset()\n+{\n+  MFDClass::reset();\n+  if (edges_) {\n+    edges_->clear();\n+  }\n+  polygons_.clear();\n+  camera_info_ = sensor_msgs::msg::CameraInfo::ConstSharedPtr();\n+}\n+\n+void CameraInfoDisplay::onInitialize()\n+{\n+  MFDClass::onInitialize();\n+  scene_node_ = scene_manager_->getRootSceneNode()->createChildSceneNode();\n+  updateColor();\n+  updateAlpha();\n+  updateFarClipDistance();\n+  updateShowPolygons();\n+  updateNotShowSidePolygons();\n+  updateShowEdges();\n+  updateEdgeColor();\n+}\n+\n+void CameraInfoDisplay::processMessage(\n+  const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg)\n+{\n+  if (!isSameCameraInfo(msg)) {\n+    createCameraInfoShapes(msg);\n+  }\n+  // move scene_node according to tf\n+  Ogre::Vector3 position;\n+  Ogre::Quaternion quaternion;\n+  std::string frame_id = msg->header.frame_id;\n+  if (frame_id[0] == '/') {\n+    frame_id = frame_id.substr(1, frame_id.size());\n+  }\n+  if (!context_->getFrameManager()->getTransform(\n+      frame_id,\n+      msg->header.stamp,\n+      position,\n+      quaternion))\n+  {\n+    std::ostringstream sstm;\n+    sstm << \"Error transforming pose '\" << qPrintable(getName()) << \"' from frame '\"\n+         << msg->header.frame_id.c_str() << \"' to frame '\" << qPrintable(fixed_frame_) << \"'\";\n+    setStatus(\n+      rviz_common::properties::StatusLevel::Warn, CAM_INFO_STATUS,\n+      QString(sstm.str().c_str()));\n+  }\n+  scene_node_->setPosition(position);\n+  scene_node_->setOrientation(quaternion);\n+  camera_info_ = msg;\n+}\n+\n+void CameraInfoDisplay::update(float /*wall_dt*/, float /*ros_dt*/)\n+{\n+}\n+\n+bool CameraInfoDisplay::isSameCameraInfo(\n+  const sensor_msgs::msg::CameraInfo::ConstSharedPtr & msg)\n+{\n+  if (camera_info_) {\n+    bool meta_same_p =\n+      msg->header.frame_id == camera_info_->header.frame_id &&\n+      msg->height == camera_info_->height &&\n+      msg->width == camera_info_->width &&\n+      msg->distortion_model == camera_info_->distortion_model &&\n+      msg->roi.x_offset == camera_info_->roi.x_offset &&\n+      msg->roi.y_offset == camera_info_->roi.y_offset &&\n+      msg->roi.height == camera_info_->roi.height &&\n+      msg->roi.width == camera_info_->roi.width;\n+    if (meta_same_p) {\n+      for (size_t i = 0; i < msg->p.size(); i++) {\n+        if (msg->p[i] != camera_info_->p[i]) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void CameraInfoDisplay::addPointToEdge(\n+  const Ogre::Vector3 & point)\n+{\n+  edges_->addPoint(point);\n+}\n+\n+void CameraInfoDisplay::addPolygon(\n+  const Ogre::Vector3 & O, const Ogre::Vector3 & A, const Ogre::Vector3 & B,\n+  std::string name, bool use_color, bool upper_triangle)\n+{\n+  Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n+  color.a = alpha_;\n+  std::shared_ptr<rviz_rendering::TrianglePolygon> triangle =\n+    std::make_shared<rviz_rendering::TrianglePolygon>(\n+    scene_manager_,\n+    scene_node_,\n+    O, A, B, name,\n+    color,\n+    use_color,\n+    upper_triangle);\n+  polygons_.push_back(triangle);\n+}\n+\n+void CameraInfoDisplay::prepareMaterial()\n+{\n+  if (texture_ == nullptr) {\n+    // material\n+    static uint32_t count = 0;\n+    rviz_common::UniformStringStream ss;\n+    ss << \"CameraInfoDisplayPolygon\" << count++;\n+    material_ =\n+      Ogre::MaterialManager::getSingletonPtr()->create(\n+      ss.str(),\n+      Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);\n+    texture_ = Ogre::TextureManager::getSingletonPtr()->createManual(\n+      material_->getName() + \"Texture\",          // name\n+      Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,\n+      Ogre::TEX_TYPE_2D, 1, 1, 0, Ogre::PF_A8R8G8B8, Ogre::TU_DEFAULT);\n+    material_->getTechnique(0)->getPass(0)->setColourWriteEnabled(true);\n+    Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n+    color.a = alpha_;\n+    material_->getTechnique(0)->getPass(0)->setAmbient(color);\n+    material_->setReceiveShadows(false);\n+    material_->getTechnique(0)->setLightingEnabled(true);\n+    material_->getTechnique(0)->getPass(0)->setCullingMode(Ogre::CULL_NONE);\n+    material_->getTechnique(0)->getPass(0)->setLightingEnabled(false);\n+    material_->getTechnique(0)->getPass(0)->setDepthWriteEnabled(false);\n+    material_->getTechnique(0)->getPass(0)->setDepthCheckEnabled(true);\n+\n+    material_->getTechnique(0)->getPass(0)->setVertexColourTracking(Ogre::TVC_DIFFUSE);\n+    material_->getTechnique(0)->getPass(0)->createTextureUnitState(texture_->getName());\n+    material_->getTechnique(0)->getPass(0)->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);\n+  }\n+}\n+\n+Ogre::Vector3 projectPixelTo3dRay(\n+  double x, double y, double fx, double fy, double cx, double cy,\n+  double Tx, double Ty)\n+{\n+  Ogre::Vector3 ray;\n+  ray.x = (x - cx - Tx) / fx;\n+  ray.y = (y - cy - Ty) / fy;\n+  ray.z = 1.0;\n+  return ray;\n+}\n+\n+void CameraInfoDisplay::createCameraInfoShapes(\n+  const sensor_msgs::msg::CameraInfo::ConstSharedPtr & msg)\n+{\n+  polygons_.clear();\n+  if (edges_) {\n+    edges_->clear();\n+  }\n+  // fx and fy should not be equal 0.\n+  if (msg->p[0] == 0.0 || msg->p[5] == 0.0) {\n+    setStatus(\n+      rviz_common::properties::StatusProperty::Error, \"Camera Info\",\n+      \"Invalid intrinsic matrix\");\n+    return;\n+  }\n+  setStatus(rviz_common::properties::StatusProperty::Ok, \"Camera Info\", \"OK\");\n+\n+  // initialize BillboardLine\n+  if (!edges_) {\n+    edges_.reset(\n+      new rviz_rendering::BillboardLine(\n+        context_->getSceneManager(),\n+        scene_node_));\n+    edges_->setLineWidth(0.01f);\n+  }\n+\n+  int height = msg->roi.height ? msg->roi.height : msg->height;\n+  int width = msg->roi.width ? msg->roi.width : msg->width;\n+  if (msg->binning_y > 0) {\n+    height /= msg->binning_y;\n+  }\n+  if (msg->binning_x > 0) {\n+    width /= msg->binning_x;\n+  }\n+\n+  Ogre::Vector2 a(0, 0), b(width, 0),\n+  c(width, height), d(0, height);\n+  // all the z = 1.0\n+  Ogre::Vector3 A = projectPixelTo3dRay(\n+    a.x, a.y, msg->p[0], msg->p[5], msg->p[2], msg->p[6],\n+    msg->p[3], msg->p[7]);\n+  Ogre::Vector3 B = projectPixelTo3dRay(\n+    b.x, b.y, msg->p[0], msg->p[5], msg->p[2], msg->p[6],\n+    msg->p[3], msg->p[7]);\n+  Ogre::Vector3 C = projectPixelTo3dRay(\n+    c.x, c.y, msg->p[0], msg->p[5], msg->p[2], msg->p[6],\n+    msg->p[3], msg->p[7]);\n+  Ogre::Vector3 D = projectPixelTo3dRay(\n+    d.x, d.y, msg->p[0], msg->p[5], msg->p[2], msg->p[6],\n+    msg->p[3], msg->p[7]);\n+\n+  Ogre::Vector3 scaled_A = A * far_clip_distance_;\n+  Ogre::Vector3 scaled_B = B * far_clip_distance_;\n+  Ogre::Vector3 scaled_C = C * far_clip_distance_;\n+  Ogre::Vector3 scaled_D = D * far_clip_distance_;\n+\n+  Ogre::Vector3 O(0, 0, 0);\n+\n+  // build polygons\n+  if (show_polygons_) {\n+    Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n+    color.a = alpha_;\n+    prepareMaterial();\n+    if (!not_show_side_polygons_) {\n+      material_->getTechnique(0)->getPass(0)->setAmbient(color);\n+      {\n+        texture_->getBuffer()->lock(Ogre::HardwareBuffer::HBL_NORMAL);\n+        const Ogre::PixelBox & pixelBox =\n+          texture_->getBuffer()->getCurrentLock();\n+        Ogre::uint8 * pDest = static_cast<Ogre::uint8 *>(pixelBox.data);\n+        memset(pDest, 0, 1);\n+        QImage Hud(pDest, 1, 1, QImage::Format_ARGB32);\n+        Hud.setPixel(0, 0, color_.rgba());\n+        texture_->getBuffer()->unlock();\n+      }\n+      addPolygon(O, scaled_B, scaled_A, material_->getName(), true, true);\n+      addPolygon(O, scaled_C, scaled_B, material_->getName(), true, true);\n+      addPolygon(O, scaled_D, scaled_C, material_->getName(), true, true);\n+      addPolygon(O, scaled_A, scaled_D, material_->getName(), true, true);\n+    }\n+  }\n+  if (show_edges_) {\n+    edges_->clear();\n+    edges_->setMaxPointsPerLine(2);\n+    edges_->setNumLines(8);\n+    edges_->setColor(\n+      edge_color_.red() / 255.0,\n+      edge_color_.green() / 255.0,\n+      edge_color_.blue() / 255.0,\n+      alpha_);\n+    addPointToEdge(O); addPointToEdge(scaled_A); edges_->finishLine();\n+    addPointToEdge(O); addPointToEdge(scaled_B); edges_->finishLine();\n+    addPointToEdge(O); addPointToEdge(scaled_C); edges_->finishLine();\n+    addPointToEdge(O); addPointToEdge(scaled_D); edges_->finishLine();\n+    addPointToEdge(scaled_A); addPointToEdge(scaled_B); edges_->finishLine();\n+    addPointToEdge(scaled_B); addPointToEdge(scaled_C); edges_->finishLine();\n+    addPointToEdge(scaled_C); addPointToEdge(scaled_D); edges_->finishLine();\n+    addPointToEdge(scaled_D); addPointToEdge(scaled_A);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateColor()\n+{\n+  color_ = color_property_->getColor();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateEdgeColor()\n+{\n+  edge_color_ = edge_color_property_->getColor();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateAlpha()\n+{\n+  alpha_ = alpha_property_->getFloat();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateFarClipDistance()\n+{\n+  far_clip_distance_ = far_clip_distance_property_->getFloat();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateShowPolygons()\n+{\n+  show_polygons_ = show_polygons_property_->getBool();\n+  if (show_polygons_) {\n+    not_show_side_polygons_property_->show();\n+  } else {\n+    not_show_side_polygons_property_->hide();\n+  }\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateShowEdges()\n+{\n+  show_edges_ = show_edges_property_->getBool();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+void CameraInfoDisplay::updateNotShowSidePolygons()\n+{\n+  not_show_side_polygons_ = not_show_side_polygons_property_->getBool();\n+  if (camera_info_) {\n+    createCameraInfoShapes(camera_info_);\n+  }\n+}\n+\n+}  // namespace displays\n+}  // namespace rviz_default_plugins\n+\n+#include <pluginlib/class_list_macros.hpp>  // NOLINT\n+PLUGINLIB_EXPORT_CLASS(rviz_default_plugins::displays::CameraInfoDisplay, rviz_common::Display)"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"rviz_visual_testing_framework/visual_test_fixture.hpp\"\n+#include \"rviz_visual_testing_framework/visual_test_publisher.hpp\"\n+\n+#include \"../../publishers/camera_info_publisher.hpp\"\n+#include \"../../page_objects/camera_info_display_page_object.hpp\"\n+\n+TEST_F(VisualTestFixture, camera_info_displayed) {\n+  std::vector<PublisherWithFrame> publishers = {\n+    PublisherWithFrame(std::make_shared<nodes::CameraInfoPublisher>(\"map\"), \"image\"),\n+  };\n+  auto cam_publisher = std::make_unique<VisualTestPublisher>(publishers);\n+\n+  auto camera_info_display = addDisplay<CameraInfoDisplayPageObject>();\n+  camera_info_display->setTopic(\"/image/camera_info\");\n+  camera_info_display->collapse();\n+\n+  captureMainWindow();\n+\n+  camera_info_display->setAlpha(0.0f);\n+  captureMainWindow(\"empty_scene\");\n+\n+  assertScreenShotsIdentity();\n+}"},{"role":"user","content":"- * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc."},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include \"camera_info_display_page_object.hpp\"\n+\n+CameraInfoDisplayPageObject::CameraInfoDisplayPageObject()\n+: BasePageObject(0, \"CameraInfo\")\n+{\n+}\n+\n+void CameraInfoDisplayPageObject::setTopic(QString topic)\n+{\n+  setComboBox(\"Topic\", topic);\n+  waitForFirstMessage();\n+}\n+\n+void CameraInfoDisplayPageObject::setFarClip(float far_clip)\n+{\n+  setFloat(\"Far clip\", far_clip);\n+}\n+\n+void CameraInfoDisplayPageObject::setShowEdged(bool show_edges)\n+{\n+  setBool(\"Show edges\", show_edges);\n+}\n+\n+void CameraInfoDisplayPageObject::setShowPolygon(bool show_polygon)\n+{\n+  setBool(\"Show polygons\", show_polygon);\n+}\n+\n+void CameraInfoDisplayPageObject::setNotShowSidePolygon(bool now_show_side_polygon)\n+{\n+  setBool(\"Not show side polygons\", now_show_side_polygon);\n+}\n+\n+void CameraInfoDisplayPageObject::setColor(int r, int g, int b)\n+{\n+  setColorCode(\"Color\", r, g, b);\n+}\n+\n+void CameraInfoDisplayPageObject::setEdgeColor(int r, int g, int b)\n+{\n+  setColorCode(\"Edge color\", r, g, b);\n+}\n+\n+void CameraInfoDisplayPageObject::setAlpha(float alpha)\n+{\n+  setFloat(\"Alpha\", alpha);\n+}"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+#ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_\n+#define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_\n+\n+#include \"rviz_visual_testing_framework/page_objects/base_page_object.hpp\"\n+\n+#include <QString>  // NOLINT\n+\n+class CameraInfoDisplayPageObject : public BasePageObject\n+{\n+public:\n+  CameraInfoDisplayPageObject();\n+\n+  void setTopic(QString topic);\n+  void setFarClip(float far_clip);\n+  void setShowEdged(bool show_edges);\n+  void setShowPolygon(bool show_polygon);\n+  void setNotShowSidePolygon(bool now_show_side_polygon);\n+  void setColor(int r, int g, int b);\n+  void setEdgeColor(int r, int g, int b);\n+\n+  void setAlpha(float alpha);\n+  void setAngularColor(int r, int g, int b);\n+  void setLinearColor(int r, int g, int b);\n+  void setAngularScale(float scale);\n+  void setLinearScale(float scale);\n+  void setWidth(float width);\n+  void setHistoryLength(int history);\n+};\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_"},{"role":"user","content":"+#include <string>\n+"},{"role":"user","content":"-  CameraInfoPublisher()\n+  explicit CameraInfoPublisher(std::string frame_id = \"camera_info_frame\")"},{"role":"user","content":"+    this->frame_id = frame_id;"},{"role":"user","content":"-    message.header.frame_id = \"camera_info_frame\";\n+    message.header.frame_id = this->frame_id;"},{"role":"user","content":"+  std::string frame_id;"},{"role":"user","content":"+  src/rviz_rendering/objects/triangle_polygon.cpp"},{"role":"user","content":"+  ament_add_gmock(triangle_polygon_visual_test_target\n+    test/rviz_rendering/objects/triangle_polygon_test.cpp\n+    ${SKIP_DISPLAY_TESTS})\n+  if(TARGET triangle_polygon_visual_test_target)\n+    target_link_libraries(triangle_polygon_visual_test_target\n+      rviz_ogre_vendor::OgreMain\n+      rviz_rendering\n+      rviz_rendering_test_utils\n+      Qt5::Widgets  # explicitly do this for include directories (not necessary for external use)\n+    )\n+  endif()\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_\n+#define RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_\n+\n+#include <string>\n+\n+#include <OgreColourValue.h>\n+#include <OgreManualObject.h>\n+#include <OgreSceneNode.h>\n+#include <OgreSceneManager.h>\n+#include <OgreVector.h>\n+\n+#include \"rviz_rendering/visibility_control.hpp\"\n+\n+namespace rviz_rendering\n+{\n+class TrianglePolygon\n+{\n+public:\n+  RVIZ_RENDERING_PUBLIC\n+  TrianglePolygon(\n+    Ogre::SceneManager * manager,\n+    Ogre::SceneNode * node,\n+    const Ogre::Vector3 & O,\n+    const Ogre::Vector3 & A,\n+    const Ogre::Vector3 & B,\n+    const std::string & name,\n+    const Ogre::ColourValue & color,\n+    bool use_color,\n+    bool upper_triangle);\n+  virtual ~TrianglePolygon();\n+\n+  RVIZ_RENDERING_PUBLIC\n+  Ogre::ManualObject * getManualObject();\n+\n+protected:\n+  Ogre::ManualObject * manual_;\n+  Ogre::SceneManager * manager_;\n+};\n+\n+}  // namespace rviz_rendering\n+#endif  // RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include \"rviz_rendering/objects/triangle_polygon.hpp\"\n+\n+#include <string>\n+\n+#include <OgreColourValue.h>\n+#include <OgreManualObject.h>\n+#include <OgreRenderOperation.h>\n+#include <OgreSceneNode.h>\n+#include <OgreSceneManager.h>\n+#include <OgreVector.h>\n+\n+namespace rviz_rendering\n+{\n+TrianglePolygon::TrianglePolygon(\n+  Ogre::SceneManager * manager,\n+  Ogre::SceneNode * node,\n+  const Ogre::Vector3 & O,\n+  const Ogre::Vector3 & A,\n+  const Ogre::Vector3 & B,\n+  const std::string & name,\n+  const Ogre::ColourValue & color,\n+  bool use_color,\n+  bool upper_triangle)\n+{\n+  // uniq string is requred for name\n+  manual_ = manager->createManualObject();\n+  manual_->clear();\n+  manual_->begin(\n+    name,\n+    Ogre::RenderOperation::OT_TRIANGLE_STRIP);\n+  manual_->position(O.x, O.y, O.z);\n+  if (upper_triangle) {\n+    manual_->textureCoord(0, 0);\n+  } else {\n+    manual_->textureCoord(1, 0);\n+  }\n+  if (use_color) {\n+    manual_->colour(color);\n+  }\n+  manual_->position(A.x, A.y, A.z);\n+  if (upper_triangle) {\n+    manual_->textureCoord(1, 0);\n+  } else {\n+    manual_->textureCoord(1, 1);\n+  }\n+  if (use_color) {\n+    manual_->colour(color);\n+  }\n+  manual_->position(B.x, B.y, B.z);\n+  if (upper_triangle) {\n+    manual_->textureCoord(0, 1);\n+  } else {\n+    manual_->textureCoord(0, 1);\n+  }\n+  if (use_color) {\n+    manual_->colour(color);\n+  }\n+  manual_->end();\n+  node->attachObject(manual_);\n+}\n+\n+TrianglePolygon::~TrianglePolygon()\n+{\n+  manual_->detachFromParent();\n+}\n+\n+Ogre::ManualObject * TrianglePolygon::getManualObject()\n+{\n+  return manual_;\n+}\n+}  // namespace rviz_rendering"},{"role":"user","content":"+/*\n+ * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted (subject to the limitations in the disclaimer\n+ * below) provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include <gtest/gtest.h>  // NOLINT\n+#include <gmock/gmock.h>  // NOLINT\n+\n+#include <memory>\n+#include <vector>\n+\n+#include <Ogre.h>\n+\n+#include \"rviz_rendering/objects/triangle_polygon.hpp\"\n+#include \"../ogre_testing_environment.hpp\"\n+\n+#include \"../matcher.hpp\"\n+\n+class TrianglePolygonTestFixture : public ::testing::Test\n+{\n+protected:\n+  void SetUp()\n+  {\n+    testing_environment_ = std::make_shared<rviz_rendering::OgreTestingEnvironment>();\n+    testing_environment_->setUpOgreTestEnvironment();\n+  }\n+\n+  std::shared_ptr<rviz_rendering::OgreTestingEnvironment> testing_environment_;\n+};\n+\n+TEST_F(TrianglePolygonTestFixture, setPoints_sets_the_line_position_and_size) {\n+  auto scene_manager = Ogre::Root::getSingletonPtr()->createSceneManager();\n+  auto root_node = scene_manager->getRootSceneNode();\n+\n+  auto O = Ogre::Vector3(0, 0, 0);\n+  auto A = Ogre::Vector3(0, 1, 0);\n+  auto B = Ogre::Vector3(1, 0.5, 0);\n+  auto color = Ogre::ColourValue(255, 0, 0, 1.0);\n+  auto triangle_polygon = new rviz_rendering::TrianglePolygon(\n+    scene_manager, root_node, O, A, B, \"test_triangle\",\n+    color, false, false);\n+\n+  auto manual_object = triangle_polygon->getManualObject();\n+\n+\n+  // auto triangle_node = dynamic_cast<Ogre::SceneNode *>(root_node->getChild(0));\n+  auto aabb = manual_object->getBoundingBox();\n+\n+  ASSERT_THAT(aabb.getMinimum(), Vector3Eq(Ogre::Vector3(0, 0, 0)));\n+  ASSERT_THAT(aabb.getMaximum(), Vector3Eq(Ogre::Vector3(1, 1, 0)));\n+  delete triangle_polygon;\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+      \"rcutils\""},{"role":"user","content":"-    target_link_libraries(test_lifecycle_node ${PROJECT_NAME})\n+    target_link_libraries(test_lifecycle_node ${PROJECT_NAME} mimick)\n+  endif()\n+  ament_add_gtest(test_lifecycle_publisher test/test_lifecycle_publisher.cpp)\n+  if(TARGET test_lifecycle_publisher)\n+    ament_target_dependencies(test_lifecycle_publisher\n+      \"rcl_lifecycle\"\n+      \"rclcpp\"\n+      \"test_msgs\"\n+    )\n+    target_link_libraries(test_lifecycle_publisher ${PROJECT_NAME})"},{"role":"user","content":"+      \"rcutils\""},{"role":"user","content":"-    target_link_libraries(test_lifecycle_service_client ${PROJECT_NAME})\n+    target_link_libraries(test_lifecycle_service_client ${PROJECT_NAME} mimick)"},{"role":"user","content":"+      \"rcutils\"\n+    )\n+    target_link_libraries(test_transition_wrapper ${PROJECT_NAME} mimick)\n+    target_compile_definitions(test_transition_wrapper\n+      PUBLIC RCUTILS_ENABLE_FAULT_INJECTION"},{"role":"user","content":"-    target_link_libraries(test_transition_wrapper ${PROJECT_NAME})"},{"role":"user","content":"+  <test_depend>mimick_vendor</test_depend>\n+  <test_depend>rcutils</test_depend>\n+  <test_depend>test_msgs</test_depend>"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Original file taken from:\n+// https://github.com/ros2/rcutils/blob/master/test/mocking_utils/patch.hpp\n+\n+#ifndef MOCKING_UTILS__PATCH_HPP_\n+#define MOCKING_UTILS__PATCH_HPP_\n+\n+#define MOCKING_UTILS_SUPPORT_VA_LIST\n+#if (defined(__aarch64__) || defined(__arm__) || defined(_M_ARM) || defined(__thumb__))\n+// In ARM machines, va_list does not define comparison operators\n+// nor the compiler allows defining them via operator overloads.\n+// Thus, Mimick argument matching code will not compile.\n+#undef MOCKING_UTILS_SUPPORT_VA_LIST\n+#endif\n+\n+#ifdef MOCKING_UTILS_SUPPORT_VA_LIST\n+#include <cstdarg>\n+#endif\n+\n+#include <functional>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"mimick/mimick.h\"\n+\n+#include \"rcutils/error_handling.h\"\n+#include \"rcutils/macros.h\"\n+\n+namespace mocking_utils\n+{\n+\n+/// Mimick specific traits for each mocking_utils::Patch instance.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam SignatureT Type of the symbol to be patched.\n+*/\n+template<size_t ID, typename SignatureT>\n+struct PatchTraits;\n+\n+/// Traits specialization for ReturnT(void) free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ */\n+template<size_t ID, typename ReturnT>\n+struct PatchTraits<ID, ReturnT(void)>\n+{\n+  mmk_mock_define(mock_type, ReturnT);\n+};\n+\n+/// Traits specialization for void(void) free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ */\n+template<size_t ID>\n+struct PatchTraits<ID, void(void)>\n+{\n+  mmk_mock_define(mock_type, void);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0) free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgT0 Argument type.\n+ */\n+template<size_t ID, typename ReturnT, typename ArgT0>\n+struct PatchTraits<ID, ReturnT(ArgT0)>\n+{\n+  mmk_mock_define(mock_type, ReturnT, ArgT0);\n+};\n+\n+/// Traits specialization for void(ArgT0) free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgT0 Argument type.\n+ */\n+template<size_t ID, typename ArgT0>\n+struct PatchTraits<ID, void(ArgT0)>\n+{\n+  mmk_mock_define(mock_type, void, ArgT0);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0, ArgT1) free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1>\n+struct PatchTraits<ID, ReturnT(ArgT0, ArgT1)>\n+{\n+  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1) free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ArgT0, typename ArgT1>\n+struct PatchTraits<ID, void(ArgT0, ArgT1)>\n+{\n+  mmk_mock_define(mock_type, void, ArgT0, ArgT1);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2) free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1, typename ArgT2>\n+struct PatchTraits<ID, ReturnT(ArgT0, ArgT1, ArgT2)>\n+{\n+  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1, ArgT2) free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ArgT0, typename ArgT1, typename ArgT2>\n+struct PatchTraits<ID, void(ArgT0, ArgT1, ArgT2)>\n+{\n+  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3) free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3>\n+struct PatchTraits<ID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3)>\n+{\n+  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3) free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3>\n+struct PatchTraits<ID, void(ArgT0, ArgT1, ArgT2, ArgT3)>\n+{\n+  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\n+/// free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3, typename ArgT4>\n+struct PatchTraits<ID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)>\n+{\n+  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\n+/// free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3, typename ArgT4>\n+struct PatchTraits<ID, void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)>\n+{\n+  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4);\n+};\n+\n+/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\n+/// free functions.\n+/**\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3,\n+  typename ArgT4, typename ArgT5>\n+struct PatchTraits<ID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)>\n+{\n+  mmk_mock_define(\n+    mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7)\n+/// free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID, typename ReturnT,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3,\n+  typename ArgT4, typename ArgT5,\n+  typename ArgT6, typename ArgT7,\n+  typename ArgT8, typename ArgT9>\n+struct PatchTraits<ID, ReturnT(\n+    ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7, ArgT8, ArgT9)>\n+{\n+  mmk_mock_define(\n+    mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7, ArgT8, ArgT9);\n+};\n+\n+/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\n+/// free functions.\n+/**\n+ * Necessary for Mimick macros to adjust accordingly when the return\n+ * type is `void`.\n+ *\n+ * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n+ * \\tparam ArgTx Argument types.\n+ */\n+template<size_t ID,\n+  typename ArgT0, typename ArgT1,\n+  typename ArgT2, typename ArgT3,\n+  typename ArgT4, typename ArgT5>\n+struct PatchTraits<ID, void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)>\n+{\n+  mmk_mock_define(\n+    mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5);\n+};\n+\n+/// Generic trampoline to wrap generalized callables in plain functions.\n+/**\n+ * \\tparam ID Numerical identifier of this trampoline. Ought to be unique.\n+ * \\tparam SignatureT Type of the symbol this trampoline replaces.\n+ */\n+template<size_t ID, typename SignatureT>\n+struct Trampoline;\n+\n+/// Trampoline specialization for free functions.\n+template<size_t ID, typename ReturnT, typename ... ArgTs>\n+struct Trampoline<ID, ReturnT(ArgTs...)>\n+{\n+  static ReturnT base(ArgTs... args)\n+  {\n+    return target(std::forward<ArgTs>(args)...);\n+  }\n+\n+  static std::function<ReturnT(ArgTs...)> target;\n+};\n+\n+template<size_t ID, typename ReturnT, typename ... ArgTs>\n+std::function<ReturnT(ArgTs...)>\n+Trampoline<ID, ReturnT(ArgTs...)>::target;\n+\n+/// Setup trampoline with the given @p target.\n+/**\n+ * \\param[in] target Callable that this trampoline will target.\n+ * \\return the plain base function of this trampoline.\n+ *\n+ * \\tparam ID Numerical identifier of this trampoline. Ought to be unique.\n+ * \\tparam SignatureT Type of the symbol this trampoline replaces.\n+ */\n+template<size_t ID, typename SignatureT>\n+auto prepare_trampoline(std::function<SignatureT> target)\n+{\n+  Trampoline<ID, SignatureT>::target = target;\n+  return Trampoline<ID, SignatureT>::base;\n+}\n+\n+/// Patch class for binary API mocking\n+/**\n+ * Built on top of Mimick, to enable symbol mocking on a per dynamically\n+ * linked binary object basis.\n+ *\n+ * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n+ * \\tparam SignatureT Type of the symbol to be patched.\n+ */\n+template<size_t ID, typename SignatureT>\n+class Patch;\n+\n+/// Patch specialization for ReturnT(ArgTs...) free functions.\n+/**\n+ * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n+ * \\tparam ReturnT Return value type.\n+ * \\tparam ArgTs Argument types.\n+ */\n+template<size_t ID, typename ReturnT, typename ... ArgTs>\n+class Patch<ID, ReturnT(ArgTs...)>\n+{\n+public:\n+  using mock_type = typename PatchTraits<ID, ReturnT(ArgTs...)>::mock_type;\n+\n+  /// Construct a patch.\n+  /**\n+   * \\param[in] target Symbol target string, using Mimick syntax\n+   *   i.e. \"symbol(@scope)?\", where scope may be \"self\" to target the current\n+   *   binary, \"lib:library_name\" to target a given library, \"file:path/to/library\"\n+   *   to target a given file, or \"sym:other_symbol\" to target the first library\n+   *   that defines said symbol.\n+   * \\param[in] proxy An indirection to call the target function.\n+   *   This indirection must ensure this call goes through the function's\n+   *   trampoline, as setup by the dynamic linker.\n+   * \\return a mocking_utils::Patch instance.\n+   */\n+  explicit Patch(const std::string & target, std::function<ReturnT(ArgTs...)> proxy)\n+  : target_(target), proxy_(proxy)\n+  {\n+  }\n+\n+  // Copy construction and assignment are disabled.\n+  Patch(const Patch &) = delete;\n+  Patch & operator=(const Patch &) = delete;\n+\n+  Patch(Patch && other)\n+  {\n+    mock_ = other.mock_;\n+    other.mock_ = nullptr;\n+  }\n+\n+  Patch & operator=(Patch && other)\n+  {\n+    if (mock_) {\n+      mmk_reset(mock_);\n+    }\n+    mock_ = other.mock_;\n+    other.mock_ = nullptr;\n+  }\n+\n+  ~Patch()\n+  {\n+    if (mock_) {\n+      mmk_reset(mock_);\n+    }\n+  }\n+\n+  /// Inject a @p replacement for the patched function.\n+  Patch & then_call(std::function<ReturnT(ArgTs...)> replacement) &\n+  {\n+    replace_with(replacement);\n+    return *this;\n+  }\n+\n+  /// Inject a @p replacement for the patched function.\n+  Patch && then_call(std::function<ReturnT(ArgTs...)> replacement) &&\n+  {\n+    replace_with(replacement);\n+    return std::move(*this);\n+  }\n+\n+private:\n+  // Helper for template parameter pack expansion using `mmk_any`\n+  // macro as pattern.\n+  template<typename T>\n+  T any() {return mmk_any(T);}\n+\n+  void replace_with(std::function<ReturnT(ArgTs...)> replacement)\n+  {\n+    if (mock_) {\n+      throw std::logic_error(\"Cannot configure patch more than once\");\n+    }\n+    auto type_erased_trampoline =\n+      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n+    auto MMK_MANGLE(mock_type, create) =\n+      PatchTraits<ID, ReturnT(ArgTs...)>::MMK_MANGLE(mock_type, create);\n+    mock_ = mmk_mock(target_.c_str(), mock_type);\n+    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+  }\n+\n+  mock_type mock_{nullptr};\n+  std::string target_;\n+  std::function<ReturnT(ArgTs...)> proxy_;\n+};\n+\n+/// Make a patch for a `target` function.\n+/**\n+ * Useful for type deduction during \\ref mocking_utils::Patch construction.\n+ *\n+ * \\param[in] target Symbol target string, using Mimick syntax.\n+ * \\param[in] proxy An indirection to call the target function.\n+ * \\return a mocking_utils::Patch instance.\n+ *\n+ * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n+ * \\tparam SignatureT Type of the function to be patched.\n+ *\n+ * \\sa mocking_utils::Patch for further reference.\n+ */\n+template<size_t ID, typename SignatureT>\n+auto make_patch(const std::string & target, std::function<SignatureT> proxy)\n+{\n+  return Patch<ID, SignatureT>(target, proxy);\n+}\n+\n+/// Define a dummy operator `op` for a given `type`.\n+/**\n+ * Useful to enable patching functions that take arguments whose types\n+ * do not define basic comparison operators, as required by Mimick.\n+*/\n+#define MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(type_, op) \\\n+  template<typename T> \\\n+  typename std::enable_if<std::is_same<T, type_>::value, bool>::type \\\n+  operator op(const T &, const T &) { \\\n+    return false; \\\n+  }\n+\n+/// Get the exact \\ref mocking_utils::Patch type for a given `id` and `function`.\n+/**\n+ * Useful to avoid ignored attribute warnings when using the \\b decltype operator.\n+ */\n+#define MOCKING_UTILS_PATCH_TYPE(id, function) \\\n+  decltype(mocking_utils::make_patch<id, decltype(function)>(\"\", nullptr))\n+\n+/// A transparent forwarding proxy to a given `function`.\n+/**\n+ * Useful to ensure a call to `function` goes through its trampoline.\n+ */\n+#define MOCKING_UTILS_PATCH_PROXY(function) \\\n+  [] (auto && ... args)->decltype(auto) { \\\n+    return function(std::forward<decltype(args)>(args)...); \\\n+  }\n+\n+/// Compute a Mimick symbol target string based on which `function` is to be patched\n+/// in which `scope`.\n+#define MOCKING_UTILS_PATCH_TARGET(scope, function) \\\n+  (std::string(RCUTILS_STRINGIFY(function)) + \"@\" + (scope))\n+\n+/// Prepare a mocking_utils::Patch for patching a `function` in a given `scope`\n+/// but defer applying any changes.\n+#define prepare_patch(scope, function) \\\n+  make_patch<__COUNTER__, decltype(function)>( \\\n+    MOCKING_UTILS_PATCH_TARGET(scope, function), MOCKING_UTILS_PATCH_PROXY(function) \\\n+  )\n+\n+/// Patch a `function` with a used-provided `replacement` in a given `scope`.\n+#define patch(scope, function, replacement) \\\n+  prepare_patch(scope, function).then_call(replacement)\n+\n+/// Patch a `function` to always yield a given `return_code` in a given `scope`.\n+#define patch_and_return(scope, function, return_code) \\\n+  patch(scope, function, [&](auto && ...) {return return_code;})\n+\n+/// Patch a `function` to always yield a given `return_code` in a given `scope`.\n+#define patch_to_fail(scope, function, error_message, return_code) \\\n+  patch( \\\n+    scope, function, [&](auto && ...) { \\\n+      RCUTILS_SET_ERROR_MSG(error_message); \\\n+      return return_code; \\\n+    })\n+\n+/// Patch a `function` to execute normally but always yield a given `return_code`\n+/// in a given `scope`.\n+/**\n+ * \\warning On some Linux distributions (e.g. CentOS), pointers to function\n+ *   reference their PLT trampolines. In such cases, it is not possible to\n+ *   call `function` from within the mock.\n+ */\n+#define inject_on_return(scope, function, return_code) \\\n+  patch( \\\n+    scope, function, ([&, base = function](auto && ... __args) { \\\n+      if (base != function) { \\\n+        static_cast<void>(base(std::forward<decltype(__args)>(__args)...)); \\\n+      } else { \\\n+        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n+          \"[WARNING] mocking_utils::inject_on_return() cannot forward call to \" \\\n+          \"original '\" RCUTILS_STRINGIFY(function) \"' function before injection\\n\" \\\n+          \"    at \" __FILE__ \":\" RCUTILS_STRINGIFY(__LINE__) \"\\n\"); \\\n+      } \\\n+      return return_code; \\\n+    }))\n+\n+}  // namespace mocking_utils\n+\n+#ifdef MOCKING_UTILS_SUPPORT_VA_LIST\n+// Define dummy comparison operators for C standard va_list type\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, ==)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, !=)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, <)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, >)\n+#endif\n+\n+#endif  // MOCKING_UTILS__PATCH_HPP_"},{"role":"user","content":"+#include \"rcl_lifecycle/rcl_lifecycle.h\"\n+"},{"role":"user","content":"+#include \"./mocking_utils/patch.hpp\"\n+"},{"role":"user","content":"+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }"},{"role":"user","content":"-  explicit EmptyLifecycleNode(std::string node_name)\n-  : rclcpp_lifecycle::LifecycleNode(std::move(node_name))\n+  explicit EmptyLifecycleNode(const std::string & node_name)\n+  : rclcpp_lifecycle::LifecycleNode(node_name)"},{"role":"user","content":"+TEST_F(TestDefaultStateMachine, empty_initializer_rcl_errors) {\n+  {\n+    auto patch = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_state_machine_init, RCL_RET_ERROR);\n+    EXPECT_THROW(\n+      std::make_shared<EmptyLifecycleNode>(\"testnode\").reset(),\n+      std::runtime_error);\n+  }\n+  {\n+    auto test_node = std::make_shared<EmptyLifecycleNode>(\"testnode\");\n+    auto patch = mocking_utils::inject_on_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_state_machine_fini, RCL_RET_ERROR);\n+    EXPECT_NO_THROW(test_node.reset());\n+  }\n+}\n+"},{"role":"user","content":"+TEST_F(TestDefaultStateMachine, trigger_transition_rcl_errors) {\n+  auto test_node = std::make_shared<EmptyLifecycleNode>(\"testnode\");\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_state_machine_is_initialized, RCL_RET_ERROR);\n+    EXPECT_EQ(\n+      State::PRIMARY_STATE_UNCONFIGURED,\n+      test_node->trigger_transition(\n+        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n+  }\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_trigger_transition_by_id, RCL_RET_ERROR);\n+    EXPECT_EQ(\n+      State::PRIMARY_STATE_UNCONFIGURED,\n+      test_node->trigger_transition(\n+        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n+  }\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_trigger_transition_by_label, RCL_RET_ERROR);\n+    EXPECT_EQ(\n+      State::TRANSITION_STATE_CONFIGURING,\n+      test_node->trigger_transition(\n+        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n+  }\n+}\n+"},{"role":"user","content":"+  // This actually throws inside NodeParameters::describe_parameters(), so it's not currently\n+  // possible to cover this method 100%."},{"role":"user","content":"+  test_node->remove_on_set_parameters_callback(callback_handle.get());\n+  rclcpp::Parameter bool_parameter2(bool_name, rclcpp::ParameterValue(true));\n+  EXPECT_TRUE(test_node->set_parameter(bool_parameter2).successful);\n+  EXPECT_EQ(parameters_set, 2u);\n+\n+"},{"role":"user","content":"-TEST_F(TestDefaultStateMachine, test_graph) {\n+TEST_F(TestDefaultStateMachine, test_graph_topics) {"},{"role":"user","content":"+  EXPECT_EQ(1u, test_node->count_publishers(\"/testnode/transition_event\"));\n+  EXPECT_EQ(0u, test_node->count_subscribers(\"/testnode/transition_event\"));\n+\n+  auto publishers_info = test_node->get_publishers_info_by_topic(\"/testnode/transition_event\");\n+  EXPECT_EQ(1u, publishers_info.size());\n+  auto subscriptions_info =\n+    test_node->get_subscriptions_info_by_topic(\"/testnode/transition_event\");\n+  EXPECT_EQ(0u, subscriptions_info.size());\n+}\n+\n+TEST_F(TestDefaultStateMachine, test_graph_services) {\n+  auto test_node = std::make_shared<EmptyLifecycleNode>(\"testnode\");\n+"},{"role":"user","content":"+}"},{"role":"user","content":"-  EXPECT_EQ(1u, test_node->count_publishers(\"/testnode/transition_event\"));\n-  EXPECT_EQ(0u, test_node->count_subscribers(\"/testnode/transition_event\"));\n+TEST_F(TestDefaultStateMachine, test_graph_services_by_node) {\n+  auto test_node = std::make_shared<EmptyLifecycleNode>(\"testnode\");"},{"role":"user","content":"-  auto publishers_info = test_node->get_publishers_info_by_topic(\"/testnode/transition_event\");\n-  EXPECT_EQ(publishers_info.size(), 1u);\n-  auto subscriptions_info =\n-    test_node->get_subscriptions_info_by_topic(\"/testnode/transition_event\");\n-  EXPECT_EQ(subscriptions_info.size(), 0u);\n+  auto service_names_and_types_by_node =\n+    test_node->get_service_names_and_types_by_node(\"testnode\", \"\");\n+  // These are specific to lifecycle nodes, other services are provided by rclcpp::Node\n+  ASSERT_NE(\n+    service_names_and_types_by_node.end(),\n+    service_names_and_types_by_node.find(std::string(\"/testnode/change_state\")));\n+  EXPECT_STREQ(\n+    service_names_and_types_by_node[\"/testnode/change_state\"][0].c_str(),\n+    \"lifecycle_msgs/srv/ChangeState\");\n+\n+  ASSERT_NE(\n+    service_names_and_types_by_node.end(),\n+    service_names_and_types_by_node.find(std::string(\"/testnode/get_available_states\")));\n+  EXPECT_STREQ(\n+    service_names_and_types_by_node[\"/testnode/get_available_states\"][0].c_str(),\n+    \"lifecycle_msgs/srv/GetAvailableStates\");\n+\n+  ASSERT_NE(\n+    service_names_and_types_by_node.end(),\n+    service_names_and_types_by_node.find(std::string(\"/testnode/get_available_transitions\")));\n+  EXPECT_STREQ(\n+    service_names_and_types_by_node[\"/testnode/get_available_transitions\"][0].c_str(),\n+    \"lifecycle_msgs/srv/GetAvailableTransitions\");\n+\n+  ASSERT_NE(\n+    service_names_and_types_by_node.end(),\n+    service_names_and_types_by_node.find(std::string(\"/testnode/get_state\")));\n+  EXPECT_STREQ(\n+    service_names_and_types_by_node[\"/testnode/get_state\"][0].c_str(),\n+    \"lifecycle_msgs/srv/GetState\");\n+\n+  ASSERT_NE(\n+    service_names_and_types_by_node.end(),\n+    service_names_and_types_by_node.find(std::string(\"/testnode/get_transition_graph\")));\n+  EXPECT_STREQ(\n+    service_names_and_types_by_node[\"/testnode/get_transition_graph\"][0].c_str(),\n+    \"lifecycle_msgs/srv/GetAvailableTransitions\");"},{"role":"user","content":"+\n+TEST_F(TestDefaultStateMachine, wait_for_graph_change)\n+{\n+  auto test_node = std::make_shared<EmptyLifecycleNode>(\"testnode\");\n+  EXPECT_THROW(\n+    test_node->wait_for_graph_change(nullptr, std::chrono::milliseconds(1)),\n+    rclcpp::exceptions::InvalidEventError);\n+\n+  auto event = std::make_shared<rclcpp::Event>();\n+  EXPECT_THROW(\n+    test_node->wait_for_graph_change(event, std::chrono::milliseconds(0)),\n+    rclcpp::exceptions::EventNotRegisteredError);\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+\n+#include <gtest/gtest.h>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"test_msgs/msg/empty.hpp\"\n+\n+#include \"rclcpp_lifecycle/lifecycle_node.hpp\"\n+#include \"rclcpp_lifecycle/lifecycle_publisher.hpp\"\n+\n+class TestDefaultStateMachine : public ::testing::Test\n+{\n+protected:\n+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+class EmptyLifecycleNode : public rclcpp_lifecycle::LifecycleNode\n+{\n+public:\n+  explicit EmptyLifecycleNode(const std::string & node_name)\n+  : rclcpp_lifecycle::LifecycleNode(node_name)\n+  {\n+    rclcpp::PublisherOptionsWithAllocator<std::allocator<void>> options;\n+    publisher_ =\n+      std::make_shared<rclcpp_lifecycle::LifecyclePublisher<test_msgs::msg::Empty>>(\n+      get_node_base_interface().get(), std::string(\"topic\"), rclcpp::QoS(10), options);\n+    add_publisher_handle(publisher_);\n+\n+    // For coverage this is being added here\n+    auto timer = create_wall_timer(std::chrono::seconds(1), []() {});\n+    add_timer_handle(timer);\n+  }\n+\n+  std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<test_msgs::msg::Empty>> publisher()\n+  {\n+    return publisher_;\n+  }\n+\n+private:\n+  std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<test_msgs::msg::Empty>> publisher_;\n+};\n+\n+class TestLifecyclePublisher : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+    node_ = std::make_shared<EmptyLifecycleNode>(\"node\");\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+protected:\n+  std::shared_ptr<EmptyLifecycleNode> node_;\n+};\n+\n+TEST_F(TestLifecyclePublisher, publish) {\n+  node_->publisher()->on_deactivate();\n+  EXPECT_FALSE(node_->publisher()->is_activated());\n+  {\n+    auto msg_ptr = std::make_unique<test_msgs::msg::Empty>();\n+    EXPECT_NO_THROW(node_->publisher()->publish(*msg_ptr));\n+  }\n+  {\n+    auto msg_ptr = std::make_unique<test_msgs::msg::Empty>();\n+    EXPECT_NO_THROW(node_->publisher()->publish(std::move(msg_ptr)));\n+  }\n+  node_->publisher()->on_activate();\n+  EXPECT_TRUE(node_->publisher()->is_activated());\n+  {\n+    auto msg_ptr = std::make_unique<test_msgs::msg::Empty>();\n+    EXPECT_NO_THROW(node_->publisher()->publish(*msg_ptr));\n+  }\n+  {\n+    auto msg_ptr = std::make_unique<test_msgs::msg::Empty>();\n+    EXPECT_NO_THROW(node_->publisher()->publish(std::move(msg_ptr)));\n+  }\n+}"},{"role":"user","content":"+#include \"./mocking_utils/patch.hpp\"\n+"},{"role":"user","content":"+\n+class TestLifecycleServiceClientRCLErrors : public ::testing::Test\n+{\n+protected:\n+  void SetUp() override\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown() override\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestLifecycleServiceClientRCLErrors, call_services_rcl_errors) {\n+  auto lifecycle_node = std::make_shared<EmptyLifecycleNode>();\n+  auto lifecycle_client = std::make_shared<LifecycleServiceClient>(\"client_with_errors\");\n+\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rclcpp_lifecycle\", rcl_lifecycle_state_machine_is_initialized, RCL_RET_ERROR);\n+\n+  // on_change_state\n+  lifecycle_client->change_state(\n+    lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);\n+  rclcpp::spin_some(lifecycle_client);\n+  EXPECT_THROW(\n+    rclcpp::spin_some(lifecycle_node->get_node_base_interface()), std::runtime_error);\n+\n+  // on_get_state\n+  lifecycle_client->get_state();\n+  rclcpp::spin_some(lifecycle_client);\n+  EXPECT_THROW(\n+    rclcpp::spin_some(lifecycle_node->get_node_base_interface()), std::runtime_error);\n+\n+  // on_get_avilable_states\n+  lifecycle_client->get_available_states();\n+  rclcpp::spin_some(lifecycle_client);\n+  EXPECT_THROW(\n+    rclcpp::spin_some(lifecycle_node->get_node_base_interface()), std::runtime_error);\n+\n+  // on_get_available_transitions\n+  lifecycle_client->get_available_transitions();\n+  rclcpp::spin_some(lifecycle_client);\n+  EXPECT_THROW(\n+    rclcpp::spin_some(lifecycle_node->get_node_base_interface()), std::runtime_error);\n+\n+  // on_get_transition_graph\n+  lifecycle_client->get_transition_graph();\n+  rclcpp::spin_some(lifecycle_client);\n+  EXPECT_THROW(\n+    rclcpp::spin_some(lifecycle_node->get_node_base_interface()), std::runtime_error);\n+}"},{"role":"user","content":"+#include \"rcutils/testing/fault_injection.h\"\n+"},{"role":"user","content":"+#include \"./mocking_utils/patch.hpp\"\n+"},{"role":"user","content":"+  TransitionDerived(const uint8_t id, const std::string & label)\n+  : Transition(id, label) {}\n+"},{"role":"user","content":"-    uint8_t id, const std::string & label,\n+    const uint8_t id, const std::string & label,"},{"role":"user","content":"+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_transition_init, RCL_RET_ERROR);\n+\n+    EXPECT_THROW(\n+      std::make_shared<TransitionDerived>(1, \"one\").reset(),\n+      std::runtime_error);\n+\n+    rclcpp_lifecycle::State state1(1, \"start_state\");\n+    rclcpp_lifecycle::State state2(2, \"goal_state\");\n+    EXPECT_THROW(\n+      std::make_shared<TransitionDerived>(\n+        2, \"two\", std::move(start_state), std::move(goal_state)).reset(),\n+      std::runtime_error);\n+  }\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp_lifecycle\", rcl_lifecycle_transition_fini, RCL_RET_ERROR);\n+    auto transition1 = std::make_shared<TransitionDerived>(1, \"one\");\n+    EXPECT_NO_THROW(transition1->expose_reset());\n+\n+    rclcpp_lifecycle::State state1(1, \"start_state\");\n+    rclcpp_lifecycle::State state2(2, \"goal_state\");\n+    auto transition2 =\n+      std::make_shared<TransitionDerived>(2, \"two\", std::move(start_state), std::move(goal_state));\n+    EXPECT_NO_THROW(transition2->expose_reset());\n+  }\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    std::shared_ptr<TransitionDerived> transition = nullptr;\n+    try {\n+      transition = std::make_shared<TransitionDerived>(1, \"one\");\n+    } catch (...) {\n+    }\n+    if (nullptr != transition) {\n+      EXPECT_NO_THROW(transition->expose_reset());\n+    }\n+  });\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    std::shared_ptr<TransitionDerived> transition = nullptr;\n+    try {\n+      {\n+        // These will fail due to failed allocations\n+        rclcpp_lifecycle::State state1(1, \"start_state\");\n+        rclcpp_lifecycle::State state2(2, \"goal_state\");\n+\n+        // Failed allocations and failed rcl init functions\n+        transition = std::make_shared<TransitionDerived>(\n+          2, \"two\", std::move(state1), std::move(state2));\n+      }\n+    } catch (...) {\n+    }\n+\n+    if (nullptr != transition) {\n+      EXPECT_NO_THROW(transition->expose_reset());\n+    }\n+  });\n+\n+  RCUTILS_FAULT_INJECTION_TEST(\n+  {\n+    try {\n+      // These will fail due to failed allocations\n+      rclcpp_lifecycle::State state1(1, \"start_state\");\n+      rclcpp_lifecycle::State state2(2, \"goal_state\");\n+\n+      // Failed allocations and failed rcl init functions\n+      auto a = std::make_shared<TransitionDerived>(2, \"two\", std::move(state1), std::move(state2));\n+      auto b = std::make_shared<TransitionDerived>(3, \"three\");\n+      *b = *a;\n+    } catch (...) {\n+    }\n+  });"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#ifndef DDS_GUID_INITIALIZER\n+#define DDS_GUID_INITIALIZER        DDS_GUID_DEFAULT\n+#endif /* DDS_GUID_INITIALIZER */\n+"},{"role":"user","content":"+rmw_ret_t\n+rmw_connextdds_guid_to_instance_handle(\n+  const struct DDS_GUID_t * const guid,\n+  DDS_InstanceHandle_t * const instanceHandle);\n+"},{"role":"user","content":"+#ifndef RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT\n+#define RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT     100000 /* 100ms */\n+#endif /* RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT */\n+\n+#ifndef RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE\n+#define RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE    (31536000ull * 1000000ull) /* 1 year */\n+#endif /* RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE */\n+\n+"},{"role":"user","content":"+#include <chrono>"},{"role":"user","content":"+class RMW_Connext_OrderedGid\n+{\n+public:\n+  explicit RMW_Connext_OrderedGid(const rmw_gid_t & value)\n+  : value(value)\n+  {\n+  }\n+\n+  bool operator<(const RMW_Connext_OrderedGid & other) const\n+  {\n+    return memcmp(value.data, other.value.data, RMW_GID_STORAGE_SIZE) < 0;\n+  }\n+\n+  bool operator==(const RMW_Connext_OrderedGid & other) const\n+  {\n+    return memcmp(value.data, other.value.data, RMW_GID_STORAGE_SIZE) == 0;\n+  }\n+\n+private:\n+  rmw_gid_t value;\n+};\n+"},{"role":"user","content":"-  enable() const\n+  enable()"},{"role":"user","content":"+    max_blocking_time = load_max_blocking_time();\n+"},{"role":"user","content":"+  rmw_ret_t\n+  wait_for_subscription(\n+    rmw_gid_t & reader_gid,\n+    bool & unmatched,\n+    rmw_gid_t & related_writer_gid);\n+"},{"role":"user","content":"+  void\n+  push_related_endpoints(const rmw_gid_t & endpoint, const rmw_gid_t & related)\n+  {\n+    std::lock_guard<std::mutex> lock(matched_mutex);\n+    known_endpoints.emplace(RMW_Connext_OrderedGid(endpoint), related);\n+    known_endpoints.emplace(RMW_Connext_OrderedGid(related), endpoint);\n+  }\n+\n+  void\n+  on_publication_matched(\n+    const DDS_PublicationMatchedStatus * const status)\n+  {\n+    std::lock_guard<std::mutex> lock(matched_mutex);\n+    DDS_ReturnCode_t dds_rc =\n+      DDS_DataWriter_get_matched_subscriptions(writer(), &matched_subscriptions);\n+    if (DDS_RETCODE_OK != dds_rc) {\n+      RMW_CONNEXT_LOG_ERROR_A_SET(\"failed to list matched subscriptions: dds_rc=%d\", dds_rc)\n+    }\n+    if (status->current_count_change < 0) {\n+      rmw_gid_t unmatched_gid;\n+      rmw_connextdds_ih_to_gid(status->last_subscription_handle, unmatched_gid);\n+      pop_related_endpoints(unmatched_gid);\n+    }\n+    matched_cv.notify_all();\n+  }\n+\n+  void\n+  on_related_subscription_matched(\n+    RMW_Connext_Subscriber * const sub,\n+    const DDS_SubscriptionMatchedStatus * const status)\n+  {\n+    UNUSED_ARG(sub);\n+    std::lock_guard<std::mutex> lock(matched_mutex);\n+    if (status->current_count_change < 0) {\n+      rmw_gid_t unmatched_gid;\n+      rmw_connextdds_ih_to_gid(status->last_publication_handle, unmatched_gid);\n+      pop_related_endpoints(unmatched_gid);\n+    }\n+    matched_cv.notify_all();\n+  }\n+\n+  rmw_context_impl_t * const ctx;\n+\n+  ~RMW_Connext_Publisher();\n+"},{"role":"user","content":"-  rmw_context_impl_t * ctx;"},{"role":"user","content":"+  std::mutex matched_mutex;\n+  std::condition_variable matched_cv;\n+  std::chrono::microseconds max_blocking_time;\n+  std::map<RMW_Connext_OrderedGid, rmw_gid_t> known_endpoints;\n+  DDS_InstanceHandleSeq matched_subscriptions;"},{"role":"user","content":"+\n+  void\n+  pop_related_endpoints(const rmw_gid_t & endpoint)\n+  {\n+    auto endpoint_entry = known_endpoints.find(RMW_Connext_OrderedGid(endpoint));\n+    if (endpoint_entry == known_endpoints.end()) {\n+      return;\n+    }\n+    known_endpoints.erase(RMW_Connext_OrderedGid(endpoint));\n+    known_endpoints.erase(RMW_Connext_OrderedGid(endpoint_entry->second));\n+  }\n+\n+  std::chrono::microseconds\n+  load_max_blocking_time() const;"},{"role":"user","content":"-    const char * const cft_filter = nullptr);\n+    const char * const cft_filter = nullptr,\n+    RMW_Connext_Publisher * const related_pub = nullptr);"},{"role":"user","content":"-  rmw_context_impl_t * ctx;\n+  rmw_context_impl_t * const ctx;"},{"role":"user","content":"+  RMW_Connext_Publisher * const related_pub;"},{"role":"user","content":"-    const bool internal);\n+    const bool internal,\n+    RMW_Connext_Publisher * const related_pub);"},{"role":"user","content":"-  install(RMW_Connext_Subscriber * const sub);\n+  install(\n+    RMW_Connext_Subscriber * const sub,\n+    RMW_Connext_Publisher * const related_pub = nullptr);"},{"role":"user","content":"-  RMW_Connext_Subscriber * sub;\n+  RMW_Connext_Subscriber * sub{nullptr};\n+  RMW_Connext_Publisher * related_pub{nullptr};"},{"role":"user","content":"+  rmw_gid_t writer_gid;"},{"role":"user","content":"-  status_condition(dds_writer)\n+  status_condition(dds_writer),\n+  matched_subscriptions(DDS_SEQUENCE_INITIALIZER)"},{"role":"user","content":"+RMW_Connext_Publisher::~RMW_Connext_Publisher()\n+{\n+  DDS_InstanceHandleSeq_finalize(&matched_subscriptions);\n+}\n+"},{"role":"user","content":"-#ifndef DDS_GUID_INITIALIZER\n-#define DDS_GUID_INITIALIZER        DDS_GUID_DEFAULT\n-#endif /* DDS_GUID_INITIALIZER */\n-"},{"role":"user","content":"+std::chrono::microseconds\n+RMW_Connext_Publisher::load_max_blocking_time() const\n+{\n+#if !RMW_CONNEXT_DDS_API_PRO_LEGACY\n+  DDS_DataWriterQos dw_qos = DDS_DataWriterQos_INITIALIZER;\n+#else\n+  DDS_DataWriterQos dw_qos;\n+  if (DDS_RETCODE_OK != DDS_DataWriterQos_initialize(&dw_qos)) {\n+    RMW_CONNEXT_LOG_ERROR_SET(\"failed to initialize datawriter qos\")\n+    return std::chrono::microseconds(0);\n+  }\n+#endif /* !RMW_CONNEXT_DDS_API_PRO_LEGACY */\n+\n+  auto scope_exit_dw_qos_delete =\n+    rcpputils::make_scope_exit(\n+    [&dw_qos]()\n+    {\n+      if (DDS_RETCODE_OK != DDS_DataWriterQos_finalize(&dw_qos)) {\n+        RMW_CONNEXT_LOG_ERROR_SET(\"failed to finalize DataWriterQoS\")\n+      }\n+    });\n+\n+  if (DDS_DataWriter_get_qos(writer(), &dw_qos)) {\n+    RMW_CONNEXT_LOG_ERROR_SET(\"failed to get datawriter qos\")\n+    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT);\n+  }\n+  if (DDS_Duration_is_auto(&dw_qos.reliability.max_blocking_time)) {\n+    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT);\n+  }\n+  if (DDS_Duration_is_infinite(&dw_qos.reliability.max_blocking_time) ||\n+    DDS_Duration_is_auto(&dw_qos.reliability.max_blocking_time))\n+  {\n+    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE);\n+  }\n+  if (DDS_Duration_is_zero(&dw_qos.reliability.max_blocking_time)) {\n+    return std::chrono::microseconds(0);\n+  }\n+  std::chrono::microseconds max_blocking_time =\n+    std::chrono::duration_cast<std::chrono::milliseconds>(\n+    std::chrono::seconds(dw_qos.reliability.max_blocking_time.sec) +\n+    std::chrono::nanoseconds(dw_qos.reliability.max_blocking_time.nanosec));\n+\n+  return max_blocking_time;\n+}\n+\n+rmw_ret_t\n+RMW_Connext_Publisher::wait_for_subscription(\n+  rmw_gid_t & reader_gid,\n+  bool & unmatched,\n+  rmw_gid_t & related_writer_gid)\n+{\n+  unmatched = false;\n+\n+  struct DDS_GUID_t reader_guid = DDS_GUID_INITIALIZER;\n+  rmw_ret_t rc = RMW_RET_ERROR;\n+  rc = rmw_connextdds_gid_to_guid(reader_gid, reader_guid);\n+  if (RMW_RET_OK != rc) {\n+    return rc;\n+  }\n+\n+  std::unique_lock<std::mutex> lock(matched_mutex);\n+  auto endpoint_entry = known_endpoints.find(RMW_Connext_OrderedGid(reader_gid));\n+  if (endpoint_entry == known_endpoints.end()) {\n+    unmatched = true;\n+    return RMW_RET_OK;\n+  }\n+  related_writer_gid = endpoint_entry->second;\n+\n+  DDS_InstanceHandle_t reader_ih = DDS_HANDLE_NIL;\n+  rc = rmw_connextdds_guid_to_instance_handle(&reader_guid, &reader_ih);\n+  if (RMW_RET_OK != rc) {\n+    return rc;\n+  }\n+  auto done_waiting = [this, &reader_ih]() {\n+      bool matched = false;\n+      const DDS_Long subs_len = DDS_InstanceHandleSeq_get_length(&matched_subscriptions);\n+      for (DDS_Long i = 0; i < subs_len && !matched; i++) {\n+        DDS_InstanceHandle_t * const matched_ih =\n+          DDS_InstanceHandleSeq_get_reference(&matched_subscriptions, i);\n+        matched = DDS_InstanceHandle_compare(matched_ih, &reader_ih) == 0;\n+      }\n+      return matched;\n+    };\n+\n+  if (!matched_cv.wait_for(lock, this->max_blocking_time, done_waiting)) {\n+    return RMW_RET_TIMEOUT;\n+  }\n+\n+  return RMW_RET_OK;\n+}\n+"},{"role":"user","content":"-  const bool internal)\n+  const bool internal,\n+  RMW_Connext_Publisher * const related_pub)"},{"role":"user","content":"-  status_condition(dds_reader, ignore_local, internal)\n+  status_condition(dds_reader, ignore_local, internal),\n+  related_pub(related_pub)"},{"role":"user","content":"-  if (RMW_RET_OK != this->status_condition.install(this)) {\n+  if (RMW_RET_OK != this->status_condition.install(this, this->related_pub)) {"},{"role":"user","content":"-  const char * const cft_filter)\n+  const char * const cft_filter,\n+  RMW_Connext_Publisher * const related_pub)"},{"role":"user","content":"-    internal);\n+    internal,\n+    related_pub);"},{"role":"user","content":"+  const struct DDS_GUID_t * writer_guid = nullptr;"},{"role":"user","content":"-    src_guid = &sample_identity->writer_guid;\n+    src_guid = &related_sample_identity->writer_guid;"},{"role":"user","content":"+    writer_guid = &sample_identity->writer_guid;"},{"role":"user","content":"+    writer_guid = &sample_identity->writer_guid;"},{"role":"user","content":"+  rmw_connextdds_guid_to_gid(*writer_guid, rr_msg->writer_gid);"},{"role":"user","content":"-    [cft_name, cft_filter]()\n+    [&cft_name, &cft_filter]()"},{"role":"user","content":"+    /* (asorbini) although messages are correlated using the reply DataReader's GUID,\n+       we report the writer's GUID to upper layers. */"},{"role":"user","content":"-      rr_msg.gid.data,\n+      this->request_pub->gid()->data,"},{"role":"user","content":"+    rr_msg.gid = *this->request_pub->gid();"},{"role":"user","content":"+    /* (asorbini) use the reply DataReader's GUID to correlate request and reply, instead of the\n+      request DataWriter's GUID, so that the service may try to wait for the DataReader to be\n+      matched before writing the reply. */\n+    rr_msg.gid = *this->reply_sub->gid();"},{"role":"user","content":"-  rr_msg.gid = *this->request_pub->gid();\n+"},{"role":"user","content":"-    &request_type);\n+    &request_type,\n+    nullptr /* cft_name */,\n+    nullptr /* cft_filter */,\n+    /* If we are using the extended RPC mapping, then we cache the reply writer\n+       so that we can notify it of \"subscription_match\" events. */\n+    (ctx->request_reply_mapping == RMW_Connext_RequestReplyMapping::Extended ?\n+    svc_impl->reply_pub : nullptr));"},{"role":"user","content":"-  rmw_ret_t rc = this->reply_pub->enable();\n+  rmw_ret_t rc = this->request_sub->enable();"},{"role":"user","content":"-    RMW_CONNEXT_LOG_ERROR(\"failed to enable service's publisher\")\n+    RMW_CONNEXT_LOG_ERROR(\"failed to enable service's subscription\")"},{"role":"user","content":"-  rc = this->request_sub->enable();\n+  rc = this->reply_pub->enable();"},{"role":"user","content":"-    RMW_CONNEXT_LOG_ERROR(\"failed to enable service's subscription\")\n+    RMW_CONNEXT_LOG_ERROR(\"failed to enable service's publisher\")"},{"role":"user","content":"+    if (ctx->request_reply_mapping == RMW_Connext_RequestReplyMapping::Extended) {\n+      /* Cache the writer/reader GUIDs */\n+      reply_pub->push_related_endpoints(rr_msg.gid, rr_msg.writer_gid);\n+    }\n+"},{"role":"user","content":"+  /* (asorbini) The following logic tries to partially work around some race conditions that exists\n+     in the way request/reply interactions between clients and services are mapped to DDS topics\n+     and endpoints.\n+\n+     It is possible for the service's request DataReader to receive a request from the client,\n+     handle it, and try to write the response before the service's reply DataWriter has actually\n+     matched the client's reply DataReader. If this is the case, the response will be lost\n+     (unless the endpoints have been configured with \"transient local\" or higher Durability QoS,\n+     but this is not the default configuration, and it is unlikely to be used in practice...).\n+     The data race and loss of reply message may also occur in the case of an\n+     \"asymmetric discovery\" between the client's reply DataReader and the service's reply\n+     DataWriter, where the latter has discovered and matched the former, but not viceversa.\n+\n+     The only way to fully resolve these data races is to have the underlying implementation force\n+     a \"match ordering\" when dealing with pairs of endpoints used for RPC exchanges. The solution\n+     is described by the OMG DDS-RPC 1.0 specification, section 7.6.2 (Enhanced Service Mapping).\n+     It requires the DDS implementation to prevent the DataWriter from matching its remote\n+     counterpart before the associated DataReader has matched. This behavior must be enforced\n+     by both service and client for all data races to be resolved.\n+\n+     This partial workaround relies on (ab)using the \"related sample identity\" field to communicate\n+     the client's reply DataReader's GUID to the service. Normally, this field should would be\n+     used to communicate the client's request DataWriter's GUID.\n+\n+     When the service detects the presence of an unusual DataReader GUID, it will enter a\n+     (time-bounded) loop to query the reply DataWriter's list of matched subscriptions, and wait\n+     for the GUID to appear.\n+\n+     If the reader is not matched within the timeout (HistoryQosPolicy::max_blocking_time), the\n+     service will return RMW_RET_TIMEOUT to the upper layers. Otherwise, the response is written\n+     out as normal.\n+\n+     It is still possible for the response to be lost by the client, in case of an asymmetric\n+     discovery, but this issue partially mitigated by the implementation of\n+     Client::is_service_available.\n+  */\n+  if (ctx->request_reply_mapping == RMW_Connext_RequestReplyMapping::Extended) {\n+    struct DDS_GUID_t src_guid = DDS_GUID_INITIALIZER;\n+    rmw_ret_t rc = RMW_RET_ERROR;\n+    rc = rmw_connextdds_gid_to_guid(rr_msg.gid, src_guid);\n+    if (RMW_RET_OK != rc) {\n+      return rc;\n+    }\n+    DDS_RTPS_GUID_t * const rtps_guid = DDS_GUID_as_rtps_guid(&src_guid);\n+    if (rtps_guid->entityId.entityKind & 0x04) {\n+      bool unmatched = false;\n+      rc = reply_pub->wait_for_subscription(rr_msg.gid, unmatched, rr_msg.writer_gid);\n+      if (RMW_RET_OK != rc || unmatched) {\n+        return rc;\n+      }\n+    }\n+  }\n+"},{"role":"user","content":"-  RMW_Connext_Subscriber * const sub)\n+  RMW_Connext_Subscriber * const sub,\n+  RMW_Connext_Publisher * const related_pub)"},{"role":"user","content":"+  this->sub = sub;\n+  this->related_pub = related_pub;\n+"},{"role":"user","content":"-  this->sub = sub;\n-"},{"role":"user","content":"+  if (nullptr != this->sub && nullptr != this->related_pub) {\n+    this->related_pub->on_related_subscription_matched(this->sub, status);\n+  }\n+"},{"role":"user","content":"+  this->pub = pub;\n+"},{"role":"user","content":"-  this->pub = pub;\n-"},{"role":"user","content":"+  if (nullptr != this->pub) {\n+    this->pub->on_publication_matched(status);\n+  }\n+"},{"role":"user","content":"+#include \"dds_c/dds_c_infrastructure_impl.h\"\n+"},{"role":"user","content":"-    if (!rr_msg->request) {\n-      /* If this is a reply, propagate the request's sample identity\n-         via the related_sample_identity field */\n-      rmw_ret_t rc = RMW_RET_ERROR;\n-\n-      rmw_connextdds_sn_ros_to_dds(\n-        rr_msg->sn,\n-        write_params.related_sample_identity.sequence_number);\n+    // Propagate the request's sample identity via the related_sample_identity field\n+    int64_t sn_ros = rr_msg->sn >= 0 ? rr_msg->sn : 0;\n+    rmw_connextdds_sn_ros_to_dds(\n+      sn_ros,\n+      write_params.related_sample_identity.sequence_number);\n+\n+    rmw_ret_t rc = rmw_connextdds_gid_to_guid(\n+      rr_msg->request ? rr_msg->gid : rr_msg->writer_gid,\n+      write_params.related_sample_identity.writer_guid);\n+    if (RMW_RET_OK != rc) {\n+      return rc;\n+    }"},{"role":"user","content":"-      rc = rmw_connextdds_gid_to_guid(\n-        rr_msg->gid,\n-        write_params.related_sample_identity.writer_guid);\n-      if (RMW_RET_OK != rc) {\n-        return rc;\n-      }\n-    } else {\n+    if (rr_msg->request) {"},{"role":"user","content":"+\n+rmw_ret_t\n+rmw_connextdds_guid_to_instance_handle(\n+  const struct DDS_GUID_t * const guid,\n+  DDS_InstanceHandle_t * const instance_handle)\n+{\n+  DDS_GUID_to_instance_handle(guid, instance_handle);\n+  return RMW_RET_OK;\n+}"},{"role":"user","content":"+\n+rmw_ret_t\n+rmw_connextdds_guid_to_instance_handle(\n+  const struct DDS_GUID_t * const guid,\n+  DDS_InstanceHandle_t * const instance_handle)\n+{\n+  UNUSED_ARG(guid);\n+  UNUSED_ARG(instance_handle);\n+  return RMW_RET_UNSUPPORTED;\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  uint64_t guid_temp = 0;\n+  uint8_t client_guid[16] = {0};"},{"role":"user","content":"-  // Random values are required for GUID\n-  std::random_device rd;\n-  std::default_random_engine dre(rd());\n-  std::uniform_int_distribution<uint64_t> uniform_dist(\n-    (std::numeric_limits<uint64_t>::min)(),\n-    (std::numeric_limits<uint64_t>::max)());\n-"},{"role":"user","content":"-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid, &guid_temp, sizeof(guid_temp));\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info->writer_guid + sizeof(guid_temp), &guid_temp, sizeof(guid_temp));\n+  dds_DataWriter_get_guid(request_writer, client_guid);\n+  memcpy(client_info->writer_guid, client_guid, sizeof(client_guid));"},{"role":"user","content":"+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+"},{"role":"user","content":"-  void * dds_request = allocate_request(\n-    type_support->data,\n-    type_support->typesupport_identifier,\n-    ros_request,\n-    &size\n-  );\n+  if (service_mapping_basic) {\n+    void * dds_request = allocate_request_basic(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_request,\n+      &size\n+    );"},{"role":"user","content":"-  if (dds_request == nullptr) {\n-    // Error message already set\n-    return RMW_RET_ERROR;\n-  }\n+    if (dds_request == nullptr) {\n+      return RMW_RET_ERROR;\n+    }\n+\n+    bool res = serialize_request_basic(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_request,\n+      dds_request,\n+      size,\n+      ++client_info->sequence_number,\n+      client_info->writer_guid\n+    );\n+\n+    if (!res) {\n+      RMW_SET_ERROR_MSG(\"failed to serialize message\");\n+      free(dds_request);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-  bool res = serialize_request(\n-    type_support->data,\n-    type_support->typesupport_identifier,\n-    ros_request,\n-    dds_request,\n-    size,\n-    ++client_info->sequence_number,\n-    client_info->writer_guid\n-  );\n-\n-  if (!res) {\n-    RMW_SET_ERROR_MSG(\"failed to serialize message\");\n+    if (dds_DataWriter_raw_write(request_writer, dds_request, size) != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to send request\");\n+      free(dds_request);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-    return RMW_RET_ERROR;\n-  }\n+  } else {\n+    void * dds_request = allocate_request_enhanced(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_request,\n+      &size\n+    );\n+\n+    if (dds_request == nullptr) {\n+      return RMW_RET_ERROR;\n+    }\n+\n+    bool res = serialize_request_enhanced(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_request,\n+      dds_request,\n+      size\n+    );\n+\n+    if (!res) {\n+      RMW_SET_ERROR_MSG(\"failed to serialize message\");\n+      free(dds_request);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-  if (dds_DataWriter_raw_write(request_writer, dds_request, size) != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to publish data\");\n+    dds_SampleInfoEx sampleinfo_ex;\n+    memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n+    ros_sn_to_dds_sn(++client_info->sequence_number, &sampleinfo_ex.seq);\n+    ros_guid_to_dds_guid(\n+      reinterpret_cast<int8_t *>(client_info->writer_guid),\n+      reinterpret_cast<int8_t *>(&sampleinfo_ex.src_guid));\n+\n+    if (dds_DataWriter_raw_write_w_sampleinfoex(\n+        request_writer, dds_request, size, &sampleinfo_ex) != dds_RETCODE_OK)\n+    {\n+      RMW_SET_ERROR_MSG(\"failed to send request\");\n+      free(dds_request);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-    return RMW_RET_ERROR;"},{"role":"user","content":"-  free(dds_request);"},{"role":"user","content":"+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+"},{"role":"user","content":"-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n+  if (service_mapping_basic) {\n+    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n+      request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n+      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);"},{"role":"user","content":"-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n+    if (ret == dds_RETCODE_NO_DATA) {\n+      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+      dds_DataSeq_delete(data_values);\n+      dds_SampleInfoSeq_delete(sample_infos);\n+      dds_UnsignedLongSeq_delete(sample_sizes);\n+      return RMW_RET_OK;\n+    }\n+\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to take data\");\n+      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+      dds_DataSeq_delete(data_values);\n+      dds_SampleInfoSeq_delete(sample_infos);\n+      dds_UnsignedLongSeq_delete(sample_sizes);\n+      return RMW_RET_ERROR;\n+    }\n+\n+    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+    if (sample_info->valid_data) {\n+      void * sample = dds_DataSeq_get(data_values, 0);\n+      if (sample == nullptr) {\n+        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+      int32_t sn_high = 0;\n+      uint32_t sn_low = 0;\n+      int8_t client_guid[16] = {0};\n+\n+      bool res = deserialize_request_basic(\n+        type_support->data,\n+        type_support->typesupport_identifier,\n+        ros_request,\n+        sample,\n+        static_cast<size_t>(size),\n+        &sn_high,\n+        &sn_low,\n+        client_guid\n+      );\n+\n+      if (!res) {\n+        // Error message already set\n+        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+\n+      request_header->source_timestamp =\n+        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sample_info->source_timestamp.nanosec;\n+      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+      request_header->received_timestamp = 0;\n+      request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n+      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+    }"},{"role":"user","content":"-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");"},{"role":"user","content":"-    return RMW_RET_ERROR;\n-  }\n+  } else {\n+    dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n+      request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n+      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);"},{"role":"user","content":"-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info->valid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n+    if (ret == dds_RETCODE_NO_DATA) {"},{"role":"user","content":"-      return RMW_RET_ERROR;\n+      return RMW_RET_OK;"},{"role":"user","content":"-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    int32_t sn_high = 0;\n-    uint32_t sn_low = 0;\n-    int8_t client_guid[16] = {0};\n-    bool res = deserialize_request(\n-      type_support->data,\n-      type_support->typesupport_identifier,\n-      ros_request,\n-      sample,\n-      static_cast<size_t>(size),\n-      &sn_high,\n-      &sn_low,\n-      client_guid\n-    );"},{"role":"user","content":"-    if (!res) {\n-      // Error message already set\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to take data\");"},{"role":"user","content":"-    request_header->source_timestamp =\n-      sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-      sample_info->source_timestamp.nanosec;\n-    // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-    request_header->received_timestamp = 0;\n-    request_header->request_id.sequence_number = ((int64_t)sn_high) << 32 | sn_low;\n-    memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+    if (sample_info->valid_data) {\n+      void * sample = dds_DataSeq_get(data_values, 0);\n+      if (sample == nullptr) {\n+        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+      int64_t sequence_number = 0;\n+      int8_t client_guid[16] = {0};\n+      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);\n+      dds_guid_to_ros_guid(reinterpret_cast<int8_t *>(&sampleinfo_ex->src_guid), client_guid);\n+      dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);\n+\n+      bool res = deserialize_request_enhanced(\n+        type_support->data,\n+        type_support->typesupport_identifier,\n+        ros_request,\n+        sample,\n+        static_cast<size_t>(size)\n+      );\n+\n+      if (!res) {\n+        // Error message already set\n+        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+\n+      request_header->source_timestamp =\n+        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sample_info->source_timestamp.nanosec;\n+      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+      request_header->received_timestamp = 0;\n+      request_header->request_id.sequence_number = sequence_number;\n+      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+    }"},{"role":"user","content":"-    *taken = true;\n+    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n+    dds_DataSeq_delete(data_values);\n+    dds_SampleInfoSeq_delete(sample_infos);\n+    dds_UnsignedLongSeq_delete(sample_sizes);"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n-\n+  *taken = true;"},{"role":"user","content":"+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+"},{"role":"user","content":"-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n+  if (service_mapping_basic) {\n+    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n+      response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n+      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);"},{"role":"user","content":"-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info->valid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n+    if (ret == dds_RETCODE_NO_DATA) {"},{"role":"user","content":"-      return RMW_RET_ERROR;\n+      return RMW_RET_OK;"},{"role":"user","content":"-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    int32_t sn_high = 0;\n-    uint32_t sn_low = 0;\n-    int8_t client_guid[16] = {0};\n-    bool res = deserialize_response(\n-      type_support->data,\n-      type_support->typesupport_identifier,\n-      ros_response,\n-      sample,\n-      static_cast<size_t>(size),\n-      &sn_high,\n-      &sn_low,\n-      client_guid\n-    );"},{"role":"user","content":"-    if (!res) {\n-      // Error message already set\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to take data\");"},{"role":"user","content":"-    if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+    if (sample_info->valid_data) {\n+      void * sample = dds_DataSeq_get(data_values, 0);\n+      if (sample == nullptr) {\n+        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+      int32_t sn_high = 0;\n+      uint32_t sn_low = 0;\n+      int8_t client_guid[16] = {0};\n+      bool res = deserialize_response_basic(\n+        type_support->data,\n+        type_support->typesupport_identifier,\n+        ros_response,\n+        sample,\n+        static_cast<size_t>(size),\n+        &sn_high,\n+        &sn_low,\n+        client_guid\n+      );\n+\n+      if (!res) {\n+        // Error message already set\n+        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+"},{"role":"user","content":"+    }\n+\n+    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+    dds_DataSeq_delete(data_values);\n+    dds_SampleInfoSeq_delete(sample_infos);\n+    dds_UnsignedLongSeq_delete(sample_sizes);\n+  } else {\n+    dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n+      response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n+      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);"},{"role":"user","content":"-      *taken = true;\n+    if (ret == dds_RETCODE_NO_DATA) {\n+      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+      dds_DataSeq_delete(data_values);\n+      dds_SampleInfoSeq_delete(sample_infos);\n+      dds_UnsignedLongSeq_delete(sample_sizes);\n+      return RMW_RET_OK;\n+    }\n+\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to take data\");\n+      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+      dds_DataSeq_delete(data_values);\n+      dds_SampleInfoSeq_delete(sample_infos);\n+      dds_UnsignedLongSeq_delete(sample_sizes);\n+      return RMW_RET_ERROR;"},{"role":"user","content":"-  }"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n+    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n+    if (sample_info->valid_data) {\n+      void * sample = dds_DataSeq_get(data_values, 0);\n+      if (sample == nullptr) {\n+        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n+      int64_t sequence_number = 0;\n+      int8_t client_guid[16] = {0};\n+      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);\n+      dds_guid_to_ros_guid(reinterpret_cast<int8_t *>(&sampleinfo_ex->src_guid), client_guid);\n+      dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);\n+\n+      bool res = deserialize_response_enhanced(\n+        type_support->data,\n+        type_support->typesupport_identifier,\n+        ros_response,\n+        sample,\n+        static_cast<size_t>(size)\n+      );\n+\n+      if (!res) {\n+        // Error message already set\n+        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+        dds_DataSeq_delete(data_values);\n+        dds_SampleInfoSeq_delete(sample_infos);\n+        dds_UnsignedLongSeq_delete(sample_sizes);\n+        return RMW_RET_ERROR;\n+      }\n+\n+      if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+        request_header->source_timestamp =\n+          sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+          sample_info->source_timestamp.nanosec;\n+        // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+        request_header->received_timestamp = 0;\n+        request_header->request_id.sequence_number = sequence_number;\n+        memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      }\n+    }"},{"role":"user","content":"+    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n+    dds_DataSeq_delete(data_values);\n+    dds_SampleInfoSeq_delete(sample_infos);\n+    dds_UnsignedLongSeq_delete(sample_sizes);\n+  }\n+\n+  *taken = true;"},{"role":"user","content":"+  const char * env_name = \"RMW_GURUMDDS_REQUEST_REPLY_MAPPING\";\n+  char * env_value = nullptr;\n+  bool service_mapping_basic = false;\n+\n+  env_value = getenv(env_name);\n+  if (env_value != nullptr) {\n+    service_mapping_basic = (strcmp(env_value, \"basic\") == 0);\n+  }\n+"},{"role":"user","content":"-  void * dds_response = allocate_response(\n-    type_support->data,\n-    type_support->typesupport_identifier,\n-    ros_response,\n-    &size\n-  );\n+  if (service_mapping_basic) {\n+    void * dds_response = allocate_response_basic(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_response,\n+      &size\n+    );"},{"role":"user","content":"-  if (dds_response == nullptr) {\n-    // Error message already set\n-    return RMW_RET_ERROR;\n-  }\n+    if (dds_response == nullptr) {\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-  bool res = serialize_response(\n-    type_support->data,\n-    type_support->typesupport_identifier,\n-    ros_response,\n-    dds_response,\n-    size,\n-    request_header->sequence_number,\n-    request_header->writer_guid\n-  );\n-\n-  if (!res) {\n-    // Error message already set\n+    bool res = serialize_response_basic(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_response,\n+      dds_response,\n+      size,\n+      request_header->sequence_number,\n+      request_header->writer_guid\n+    );\n+\n+    if (!res) {\n+      RMW_SET_ERROR_MSG(\"failed to serialize message\");\n+      free(dds_response);\n+      return RMW_RET_ERROR;\n+    }\n+\n+    if (dds_DataWriter_raw_write(response_writer, dds_response, size) != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to publish data\");\n+      free(dds_response);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-    return RMW_RET_ERROR;\n-  }\n+  } else {\n+    void * dds_response = allocate_response_enhanced(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_response,\n+      &size\n+    );\n+\n+    if (dds_response == nullptr) {\n+      // Error message already set\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-  if (dds_DataWriter_raw_write(response_writer, dds_response, size) != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to publish data\");\n+    bool res = serialize_response_enhanced(\n+      type_support->data,\n+      type_support->typesupport_identifier,\n+      ros_response,\n+      dds_response,\n+      size\n+    );\n+\n+    if (!res) {\n+      // Error message already set\n+      free(dds_response);\n+      return RMW_RET_ERROR;\n+    }\n+\n+    dds_SampleInfoEx sampleinfo_ex;\n+    memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n+    ros_sn_to_dds_sn(request_header->sequence_number, &sampleinfo_ex.seq);\n+    ros_guid_to_dds_guid(\n+      request_header->writer_guid,\n+      reinterpret_cast<int8_t *>(&sampleinfo_ex.src_guid));\n+\n+    if (dds_DataWriter_raw_write_w_sampleinfoex(\n+        response_writer, dds_response, size, &sampleinfo_ex) != dds_RETCODE_OK)\n+    {\n+      RMW_SET_ERROR_MSG(\"failed to send response\");\n+      free(dds_response);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-    return RMW_RET_ERROR;"},{"role":"user","content":"-  free(dds_response);\n-"},{"role":"user","content":"-_allocate_request(\n+_allocate_request_basic("},{"role":"user","content":"-allocate_request(\n+allocate_request_basic("},{"role":"user","content":"-    return _allocate_request<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _allocate_request_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _allocate_request<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _allocate_request_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"-_allocate_response(\n+_allocate_response_basic("},{"role":"user","content":"-allocate_response(\n+allocate_response_basic("},{"role":"user","content":"-    return _allocate_response<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _allocate_response_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _allocate_response<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _allocate_response_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_response),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return nullptr;\n+}\n+\n+template<typename ServiceMembersT>\n+void *\n+_allocate_request_enhanced(\n+  const void * untyped_members,\n+  const void * ros_request,\n+  size_t * size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return nullptr;\n+  }\n+\n+  return _allocate_message<GET_TYPENAME(members->request_members_)>(\n+    static_cast<const void *>(members->request_members_),\n+    static_cast<const uint8_t *>(ros_request),\n+    size,\n+    false\n+  );\n+}\n+\n+inline void *\n+allocate_request_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  const void * ros_request,\n+  size_t * size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _allocate_request_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_request),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _allocate_request_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_request),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return nullptr;\n+}\n+\n+template<typename ServiceMembersT>\n+void *\n+_allocate_response_enhanced(\n+  const void * untyped_members,\n+  const void * ros_response,\n+  size_t * size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return nullptr;\n+  }\n+\n+  return _allocate_message<GET_TYPENAME(members->response_members_)>(\n+    static_cast<const void *>(members->response_members_),\n+    static_cast<const uint8_t *>(ros_response),\n+    size,\n+    false\n+  );\n+}\n+\n+inline void *\n+allocate_response_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  const void * ros_response,\n+  size_t * size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _allocate_response_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_response),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _allocate_response_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"-_serialize_service(\n+_serialize_service_basic("},{"role":"user","content":"-serialize_service(\n+serialize_service_basic("},{"role":"user","content":"-    return _serialize_service<rosidl_typesupport_introspection_c__MessageMembers>(\n+    return _serialize_service_basic<rosidl_typesupport_introspection_c__MessageMembers>("},{"role":"user","content":"-    return _serialize_service<rosidl_typesupport_introspection_cpp::MessageMembers>(\n+    return _serialize_service_basic<rosidl_typesupport_introspection_cpp::MessageMembers>("},{"role":"user","content":"-_serialize_request(\n+_serialize_request_basic("},{"role":"user","content":"-  return _serialize_service<GET_TYPENAME(members->request_members_)>(\n+  return _serialize_service_basic<GET_TYPENAME(members->request_members_)>("},{"role":"user","content":"-serialize_request(\n+serialize_request_basic("},{"role":"user","content":"-    return _serialize_request<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _serialize_request_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _serialize_request<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _serialize_request_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"-_serialize_response(\n+_serialize_response_basic("},{"role":"user","content":"-  return _serialize_service<GET_TYPENAME(members->response_members_)>(\n+  return _serialize_service_basic<GET_TYPENAME(members->response_members_)>("},{"role":"user","content":"-serialize_response(\n+serialize_response_basic("},{"role":"user","content":"-    return _serialize_response<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _serialize_response_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _serialize_response<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _serialize_response_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"-_deserialize_service(\n+_serialize_service_enhanced(\n+  const void * untyped_members,\n+  const uint8_t * ros_service,\n+  uint8_t * dds_service,\n+  size_t size)\n+{\n+  auto members =\n+    static_cast<const MessageMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  try {\n+    auto buffer = CDRSerializationBuffer(dds_service, size);\n+    auto serializer = MessageSerializer(buffer);\n+    serializer.serialize(members, ros_service, true);\n+  } catch (std::runtime_error & e) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"Failed to serialize ros message: %s\", e.what());\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool\n+serialize_service_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  const void * ros_service,\n+  void * dds_service,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _serialize_service_enhanced<rosidl_typesupport_introspection_c__MessageMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_service),\n+      reinterpret_cast<uint8_t *>(dds_service),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _serialize_service_enhanced<rosidl_typesupport_introspection_cpp::MessageMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_service),\n+      reinterpret_cast<uint8_t *>(dds_service),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+template<typename ServiceMembersT>\n+bool\n+_serialize_request_enhanced(\n+  const void * untyped_members,\n+  const uint8_t * ros_request,\n+  uint8_t * dds_request,\n+  size_t size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  return _serialize_service_enhanced<GET_TYPENAME(members->request_members_)>(\n+    static_cast<const void *>(members->request_members_),\n+    ros_request,\n+    dds_request,\n+    size\n+  );\n+}\n+\n+inline bool\n+serialize_request_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  const void * ros_request,\n+  void * dds_request,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _serialize_request_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_request),\n+      reinterpret_cast<uint8_t *>(dds_request),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _serialize_request_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_request),\n+      reinterpret_cast<uint8_t *>(dds_request),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+template<typename ServiceMembersT>\n+bool\n+_serialize_response_enhanced(\n+  const void * untyped_members,\n+  const uint8_t * ros_response,\n+  uint8_t * dds_response,\n+  size_t size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  return _serialize_service_enhanced<GET_TYPENAME(members->response_members_)>(\n+    static_cast<const void *>(members->response_members_),\n+    ros_response,\n+    dds_response,\n+    size\n+  );\n+}\n+\n+inline bool\n+serialize_response_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  const void * ros_response,\n+  void * dds_response,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _serialize_response_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_response),\n+      reinterpret_cast<uint8_t *>(dds_response),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _serialize_response_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<const uint8_t *>(ros_response),\n+      reinterpret_cast<uint8_t *>(dds_response),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+template<typename MessageMembersT>\n+bool\n+_deserialize_service_basic("},{"role":"user","content":"-deserialize_service(\n+deserialize_service_basic("},{"role":"user","content":"-    return _deserialize_service<rosidl_typesupport_introspection_c__MessageMembers>(\n+    return _deserialize_service_basic<rosidl_typesupport_introspection_c__MessageMembers>("},{"role":"user","content":"-    return _deserialize_service<rosidl_typesupport_introspection_cpp::MessageMembers>(\n+    return _deserialize_service_basic<rosidl_typesupport_introspection_cpp::MessageMembers>("},{"role":"user","content":"-_deserialize_request(\n+_deserialize_request_basic("},{"role":"user","content":"-  return _deserialize_service<GET_TYPENAME(members->request_members_)>(\n+  return _deserialize_service_basic<GET_TYPENAME(members->request_members_)>("},{"role":"user","content":"-deserialize_request(\n+deserialize_request_basic("},{"role":"user","content":"-    return _deserialize_request<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _deserialize_request_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _deserialize_request<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _deserialize_request_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"-_deserialize_response(\n+_deserialize_response_basic("},{"role":"user","content":"-  return _deserialize_service<GET_TYPENAME(members->response_members_)>(\n+  return _deserialize_service_basic<GET_TYPENAME(members->response_members_)>("},{"role":"user","content":"-deserialize_response(\n+deserialize_response_basic("},{"role":"user","content":"-    return _deserialize_response<rosidl_typesupport_introspection_c__ServiceMembers>(\n+    return _deserialize_response_basic<rosidl_typesupport_introspection_c__ServiceMembers>("},{"role":"user","content":"-    return _deserialize_response<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+    return _deserialize_response_basic<rosidl_typesupport_introspection_cpp::ServiceMembers>("},{"role":"user","content":"+template<typename MessageMembersT>\n+bool\n+_deserialize_service_enhanced(\n+  const void * untyped_members,\n+  uint8_t * ros_service,\n+  uint8_t * dds_service,\n+  size_t size)\n+{\n+  auto members =\n+    static_cast<const MessageMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  try {\n+    auto buffer = CDRDeserializationBuffer(dds_service, size);\n+    auto deserializer = MessageDeserializer(buffer);\n+    deserializer.deserialize(members, ros_service, true);\n+  } catch (std::runtime_error & e) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"Failed to deserialize dds message: %s\", e.what());\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool\n+deserialize_service_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  void * ros_service,\n+  void * dds_service,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _deserialize_service_enhanced<rosidl_typesupport_introspection_c__MessageMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_service),\n+      reinterpret_cast<uint8_t *>(dds_service),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _deserialize_service_enhanced<rosidl_typesupport_introspection_cpp::MessageMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_service),\n+      reinterpret_cast<uint8_t *>(dds_service),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+template<typename ServiceMembersT>\n+bool\n+_deserialize_request_enhanced(\n+  const void * untyped_members,\n+  uint8_t * ros_request,\n+  uint8_t * dds_request,\n+  size_t size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  return _deserialize_service_enhanced<GET_TYPENAME(members->request_members_)>(\n+    static_cast<const void *>(members->request_members_),\n+    ros_request,\n+    dds_request,\n+    size\n+  );\n+}\n+\n+inline bool\n+deserialize_request_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  void * ros_request,\n+  void * dds_request,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _deserialize_request_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_request),\n+      reinterpret_cast<uint8_t *>(dds_request),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _deserialize_request_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_request),\n+      reinterpret_cast<uint8_t *>(dds_request),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+template<typename ServiceMembersT>\n+bool\n+_deserialize_response_enhanced(\n+  const void * untyped_members,\n+  uint8_t * ros_response,\n+  uint8_t * dds_response,\n+  size_t size)\n+{\n+  auto members = static_cast<const ServiceMembersT *>(untyped_members);\n+  if (members == nullptr) {\n+    RMW_SET_ERROR_MSG(\"Members handle is null\");\n+    return false;\n+  }\n+\n+  return _deserialize_service_enhanced<GET_TYPENAME(members->response_members_)>(\n+    static_cast<const void *>(members->response_members_),\n+    ros_response,\n+    dds_response,\n+    size\n+  );\n+}\n+\n+inline bool\n+deserialize_response_enhanced(\n+  const void * untyped_members,\n+  const char * identifier,\n+  void * ros_reponse,\n+  void * dds_reponse,\n+  size_t size)\n+{\n+  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n+    return _deserialize_response_enhanced<rosidl_typesupport_introspection_c__ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_reponse),\n+      reinterpret_cast<uint8_t *>(dds_reponse),\n+      size\n+    );\n+  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n+    return _deserialize_response_enhanced<rosidl_typesupport_introspection_cpp::ServiceMembers>(\n+      untyped_members,\n+      reinterpret_cast<uint8_t *>(ros_reponse),\n+      reinterpret_cast<uint8_t *>(dds_reponse),\n+      size\n+    );\n+  }\n+\n+  RMW_SET_ERROR_MSG(\"Unknown typesupport identifier\");\n+  return false;\n+}\n+\n+inline void\n+ros_guid_to_dds_guid(int8_t * guid_ros, int8_t * guid_dds)\n+{\n+  memcpy(guid_dds, guid_ros, 12);\n+  memcpy(&guid_dds[12], &guid_ros[12], 4);\n+}\n+\n+inline void\n+dds_guid_to_ros_guid(int8_t * guid_dds, int8_t * guid_ros)\n+{\n+  memcpy(guid_ros, guid_dds, 12);\n+  memcpy(&guid_ros[12], &guid_dds[12], 4);\n+}\n+\n+inline void\n+ros_sn_to_dds_sn(int64_t sn_ros, uint64_t * sn_dds)\n+{\n+  *sn_dds = ((sn_ros) & 0xFFFFFFFF00000000LL) >> 32;\n+  *sn_dds = *sn_dds | ((sn_ros & 0x00000000FFFFFFFFLL) << 32);\n+}\n+\n+inline void\n+dds_sn_to_ros_sn(uint64_t sn_dds, int64_t * sn_ros)\n+{\n+  *sn_ros = ((sn_dds & 0x00000000FFFFFFFF) << 32) | ((sn_dds & 0xFFFFFFFF00000000) >> 32);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+  ament_add_pytest_test(test_cli_extension test/test_cli_extension.py)"},{"role":"user","content":"+# Copyright 2021 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import pathlib\n+\n+from rosidl_cli.command.generate.api import generate\n+\n+PACKAGE_DIR = str(pathlib.Path(__file__).parent.parent)\n+\n+\n+def test_cli_extension_for_smoke(tmp_path):\n+    generate(\n+        package_name='rosidl_generator_py',\n+        interface_files=[PACKAGE_DIR + ':msg/StringArrays.msg'],\n+        types=['py'],\n+        output_path=tmp_path\n+    )"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"rclcpp/node_options.hpp\""},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  \"c:rosidl_typesupport_c:rosidl_typesupport_fastrtps_c\"\n-  \"cpp:rosidl_typesupport_cpp:rosidl_typesupport_fastrtps_cpp\")\n+  \"c:rosidl_typesupport_c:rosidl_typesupport_fastrtps_c:rosidl_typesupport_introspection_c\"\n+  \"cpp:rosidl_typesupport_cpp:rosidl_typesupport_fastrtps_cpp:rosidl_typesupport_introspection_cpp\")"},{"role":"user","content":"+  if (!rmw_fastrtps_shared_cpp::register_type_object(type_supports, type_name)) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"failed to register type object with incompatible type %s\",\n+      type_name.c_str());\n+    return nullptr;\n+  }\n+"},{"role":"user","content":"-  auto info = static_cast<const CustomSubscriberInfo *>(subscription->data);\n+  auto info = static_cast<CustomSubscriberInfo *>(subscription->data);\n+"},{"role":"user","content":"+  info->node_ = node;\n+  info->common_context_ = common_context;\n+"},{"role":"user","content":"+rmw_ret_t\n+rmw_subscription_set_content_filter(\n+  rmw_subscription_t * subscription,\n+  const rmw_subscription_content_filter_options_t * options)\n+{\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(options, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_subscription_set_content_filter(\n+    subscription, options);\n+  auto info = static_cast<const CustomSubscriberInfo *>(subscription->data);\n+  subscription->is_cft_enabled = (info && info->filtered_topic_);\n+  return ret;\n+}\n+\n+rmw_ret_t\n+rmw_subscription_get_content_filter(\n+  const rmw_subscription_t * subscription,\n+  rcutils_allocator_t * allocator,\n+  rmw_subscription_content_filter_options_t * options)\n+{\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(allocator, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(options, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  return rmw_fastrtps_shared_cpp::__rmw_subscription_get_content_filter(\n+    subscription, allocator, options);\n+}\n+"},{"role":"user","content":"+  if (!rmw_fastrtps_shared_cpp::register_type_object(type_supports, type_name)) {\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"failed to register type object with incompatible type %s\",\n+      type_name.c_str());\n+    return nullptr;\n+  }\n+"},{"role":"user","content":"+  info->dds_participant_ = dds_participant;\n+  info->subscriber_ = subscriber;\n+  info->topic_name_mangled_ = topic_name_mangled;\n+  info->topic_ = topic.desc;"},{"role":"user","content":"+  // Create ContentFilteredTopic\n+  if (subscription_options->content_filter_options) {\n+    rmw_subscription_content_filter_options_t * options =\n+      subscription_options->content_filter_options;\n+    if (nullptr != options->filter_expression) {\n+      eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = nullptr;\n+      if (!rmw_fastrtps_shared_cpp::create_content_filtered_topic(\n+          dds_participant, des_topic,\n+          topic_name_mangled, options, &filtered_topic))\n+      {\n+        RMW_SET_ERROR_MSG(\"create_contentfilteredtopic() failed to create contentfilteredtopic\");\n+        return nullptr;\n+      }\n+      info->filtered_topic_ = filtered_topic;\n+      des_topic = filtered_topic;\n+    }\n+  }\n+"},{"role":"user","content":"-  eprosima::fastdds::dds::DataReaderQos original_qos = reader_qos;\n-  switch (subscription_options->require_unique_network_flow_endpoints) {\n-    default:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED:\n-      // Unique network flow endpoints not required. We leave the decission to the XML profile.\n-      break;\n-\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED:\n-      // Ensure we request unique network flow endpoints\n-      if (nullptr ==\n-        PropertyPolicyHelper::find_property(\n-          reader_qos.properties(),\n-          \"fastdds.unique_network_flows\"))\n-      {\n-        reader_qos.properties().properties().emplace_back(\"fastdds.unique_network_flows\", \"\");\n-      }\n-      break;\n-  }\n+  info->datareader_qos_ = reader_qos;"},{"role":"user","content":"-  // Creates DataReader (with subscriber name to not change name policy)\n-  info->data_reader_ = subscriber->create_datareader(\n-    des_topic,\n-    reader_qos,\n-    info->listener_);\n-  if (!info->data_reader_ &&\n-    (RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED ==\n-    subscription_options->require_unique_network_flow_endpoints))\n-  {\n-    info->data_reader_ = subscriber->create_datareader(\n+  // create_datareader\n+  if (!rmw_fastrtps_shared_cpp::create_datareader(\n+      info->datareader_qos_,\n+      subscription_options,\n+      subscriber,"},{"role":"user","content":"-      original_qos,\n-      info->listener_);\n-  }\n-\n-  if (!info->data_reader_) {\n-    RMW_SET_ERROR_MSG(\"create_subscription() could not create data reader\");\n+      info->listener_,\n+      &info->data_reader_))\n+  {\n+    RMW_SET_ERROR_MSG(\"create_datareader() could not create data reader\");"},{"role":"user","content":"+  rmw_subscription->is_cft_enabled = info->filtered_topic_ != nullptr;"},{"role":"user","content":"-  auto info = static_cast<const CustomSubscriberInfo *>(subscription->data);\n+  auto info = static_cast<CustomSubscriberInfo *>(subscription->data);"},{"role":"user","content":"+  info->node_ = node;\n+  info->common_context_ = common_context;\n+"},{"role":"user","content":"+rmw_ret_t\n+rmw_subscription_set_content_filter(\n+  rmw_subscription_t * subscription,\n+  const rmw_subscription_content_filter_options_t * options)\n+{\n+  // Unused in current implementation.\n+  (void) subscription;\n+  (void) options;\n+  RMW_SET_ERROR_MSG(\"unimplemented\");\n+  return RMW_RET_UNSUPPORTED;\n+}\n+\n+rmw_ret_t\n+rmw_subscription_get_content_filter(\n+  const rmw_subscription_t * subscription,\n+  rcutils_allocator_t * allocator,\n+  rmw_subscription_content_filter_options_t * options)\n+{\n+  // Unused in current implementation.\n+  (void) subscription;\n+  (void) allocator;\n+  (void) options;\n+  RMW_SET_ERROR_MSG(\"unimplemented\");\n+  return RMW_RET_UNSUPPORTED;\n+}\n+"},{"role":"user","content":"+  // TODO(iuhilnehc-ynos): update after rmw_fastrtps_cpp is confirmed\n+  rmw_subscription->is_cft_enabled = false;"},{"role":"user","content":"+find_package(rosidl_typesupport_introspection_c REQUIRED)\n+find_package(rosidl_typesupport_introspection_cpp REQUIRED)"},{"role":"user","content":"+  \"rosidl_typesupport_introspection_c\"\n+  \"rosidl_typesupport_introspection_cpp\""},{"role":"user","content":"+ament_export_dependencies(rosidl_typesupport_introspection_c)\n+ament_export_dependencies(rosidl_typesupport_introspection_cpp)"},{"role":"user","content":"+#include \"rosidl_runtime_c/message_type_support_struct.h\"\n+"},{"role":"user","content":"+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+bool register_type_object(\n+  const rosidl_message_type_support_t * type_supports,\n+  const std::string & type_name);\n+"},{"role":"user","content":"+#include <string>"},{"role":"user","content":"+#include \"fastdds/dds/subscriber/qos/DataReaderQos.hpp\"\n+#include \"fastdds/dds/topic/ContentFilteredTopic.hpp\""},{"role":"user","content":"+#include \"rmw_dds_common/context.hpp\"\n+"},{"role":"user","content":"+  // for re-create or delete content filtered topic\n+  const rmw_node_t * node_ {nullptr};\n+  rmw_dds_common::Context * common_context_ {nullptr};\n+  eprosima::fastdds::dds::DomainParticipant * dds_participant_ {nullptr};\n+  eprosima::fastdds::dds::Subscriber * subscriber_ {nullptr};\n+  std::string topic_name_mangled_;\n+  eprosima::fastdds::dds::TopicDescription * topic_ {nullptr};\n+  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic_ {nullptr};\n+  eprosima::fastdds::dds::DataReaderQos datareader_qos_;\n+"},{"role":"user","content":"-  rmw_subscription_t * subscription);\n+  rmw_subscription_t * subscription,\n+  bool reset_cft = false);"},{"role":"user","content":"+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+rmw_ret_t\n+__rmw_subscription_set_content_filter(\n+  rmw_subscription_t * subscription,\n+  const rmw_subscription_content_filter_options_t * options);\n+\n+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+rmw_ret_t\n+__rmw_subscription_get_content_filter(\n+  const rmw_subscription_t * subscription,\n+  rcutils_allocator_t * allocator,\n+  rmw_subscription_content_filter_options_t * options);\n+"},{"role":"user","content":"-  rmw_subscription_t * subscription);\n+  rmw_subscription_t * subscription,\n+  bool reset_cft = false);"},{"role":"user","content":"+#include \"rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp\""},{"role":"user","content":"+/**\n+* Create content filtered topic.\n+*\n+* \\param[in]  participant             DomainParticipant where the topic will be created.\n+* \\param[in]  topic_desc              TopicDescription returned by find_and_check_topic_and_type.\n+* \\param[in]  topic_name_mangled      Mangled Name of the topic.\n+* \\param[in]  options                 Options of the content filtered topic.\n+* \\param[out] content_filtered_topic  Will hold the pointer to the content filtered topic along\n+                                      with the necessary information for its deletion.\n+*\n+* \\return true when the content filtered topic was created\n+* \\return false when the content filtered topic could not be created\n+*/\n+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+bool\n+create_content_filtered_topic(\n+  eprosima::fastdds::dds::DomainParticipant * participant,\n+  eprosima::fastdds::dds::TopicDescription * topic_desc,\n+  const std::string & topic_name_mangled,\n+  const rmw_subscription_content_filter_options_t * options,\n+  eprosima::fastdds::dds::ContentFilteredTopic ** content_filtered_topic);\n+\n+\n+/**\n+* Create data reader.\n+*\n+* \\param[in]  datareader_qos         QoS of data reader.\n+* \\param[in]  subscription_options   Options of the subscription.\n+* \\param[in]  subscriber             A subsciber to create the data reader.\n+* \\param[in]  des_topic              TopicDescription returned by find_and_check_topic_and_type.\n+* \\param[in]  listener               The listener of the data reader.\n+* \\param[out] data_reader            Will hold the pointer to the data reader.\n+*\n+* \\return true when the data reader was created\n+* \\return false when the data reader could not be created\n+*/\n+RMW_FASTRTPS_SHARED_CPP_PUBLIC\n+bool\n+create_datareader(\n+  const eprosima::fastdds::dds::DataReaderQos & datareader_qos,\n+  const rmw_subscription_options_t * subscription_options,\n+  eprosima::fastdds::dds::Subscriber * subscriber,\n+  eprosima::fastdds::dds::TopicDescription * des_topic,\n+  SubListener * listener,\n+  eprosima::fastdds::dds::DataReader ** data_reader);\n+"},{"role":"user","content":"+  <build_depend>rosidl_typesupport_introspection_c</build_depend>\n+  <build_depend>rosidl_typesupport_introspection_cpp</build_depend>"},{"role":"user","content":"+  <build_export_depend>rosidl_typesupport_introspection_c</build_export_depend>\n+  <build_export_depend>rosidl_typesupport_introspection_cpp</build_export_depend>"},{"role":"user","content":"+#include <sstream>"},{"role":"user","content":"+#include <utility>"},{"role":"user","content":"+#include \"fastrtps/rtps/common/SerializedPayload.h\"\n+#include \"fastrtps/utils/md5.h\"\n+#include \"fastrtps/types/TypesBase.h\"\n+#include \"fastrtps/types/TypeObjectFactory.h\"\n+#include \"fastrtps/types/TypeNamesGenerator.h\"\n+#include \"fastrtps/types/AnnotationParameterValue.h\"\n+"},{"role":"user","content":"+#include \"rmw/error_handling.h\"\n+\n+#include \"rosidl_typesupport_introspection_c/identifier.h\"\n+#include \"rosidl_typesupport_introspection_cpp/identifier.hpp\"\n+#include \"rosidl_typesupport_introspection_c/message_introspection.h\"\n+#include \"rosidl_typesupport_introspection_cpp/message_introspection.hpp\"\n+#include \"rosidl_typesupport_introspection_cpp/field_types.hpp\""},{"role":"user","content":"+  auto_fill_type_object(false);\n+  auto_fill_type_information(false);"},{"role":"user","content":"+// TODO(iuhilnehc-ynos): add the following content into new files named TypeObject?\n+using CompleteStructType = eprosima::fastrtps::types::CompleteStructType;\n+using CompleteStructMember = eprosima::fastrtps::types::CompleteStructMember;\n+using MinimalStructType = eprosima::fastrtps::types::MinimalStructType;\n+using MinimalStructMember = eprosima::fastrtps::types::MinimalStructMember;\n+using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;\n+using TypeNamesGenerator = eprosima::fastrtps::types::TypeNamesGenerator;\n+using TypeIdentifier = eprosima::fastrtps::types::TypeIdentifier;\n+using TypeObject = eprosima::fastrtps::types::TypeObject;\n+using TypeObjectFactory = eprosima::fastrtps::types::TypeObjectFactory;\n+\n+const rosidl_message_type_support_t *\n+get_type_support_introspection(\n+  const rosidl_message_type_support_t * type_supports)\n+{\n+  const rosidl_message_type_support_t * type_support =\n+    get_message_typesupport_handle(\n+    type_supports, rosidl_typesupport_introspection_c__identifier);\n+  if (nullptr == type_support) {\n+    rcutils_error_string_t prev_error_string = rcutils_get_error_string();\n+    rcutils_reset_error();\n+\n+    type_support =\n+      get_message_typesupport_handle(\n+      type_supports,\n+      rosidl_typesupport_introspection_cpp::typesupport_identifier);\n+    if (nullptr == type_support) {\n+      rcutils_error_string_t error_string = rcutils_get_error_string();\n+      rcutils_reset_error();\n+      RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+        \"Type support not from this implementation. Got:\\n\"\n+        \"    %s\\n\"\n+        \"    %s\\n\"\n+        \"while fetching it\",\n+        prev_error_string.str, error_string.str);\n+      return nullptr;\n+    }\n+  }\n+\n+  return type_support;\n+}\n+\n+template<typename MembersType>\n+inline std::string\n+_create_type_name(\n+  const MembersType * members)\n+{\n+  if (!members) {\n+    return std::string();\n+  }\n+\n+  std::ostringstream ss;\n+  std::string message_namespace(members->message_namespace_);\n+  std::string message_name(members->message_name_);\n+  if (!message_namespace.empty()) {\n+    ss << message_namespace << \"::\";\n+  }\n+  ss << \"dds_::\" << message_name << \"_\";\n+  return ss.str();\n+}\n+\n+typedef std::pair<const TypeIdentifier *, std::string> MemberIdentifierName;\n+\n+template<typename MembersType>\n+MemberIdentifierName GetTypeIdentifier(const MembersType * member, uint32_t index, bool complete);\n+\n+template<typename MembersType>\n+const TypeObject * GetCompleteObject(\n+  const std::string & type_name,\n+  const MembersType * members)\n+{\n+  const TypeObject * c_type_object =\n+    TypeObjectFactory::get_instance()->get_type_object(type_name, true);\n+  if (c_type_object != nullptr && c_type_object->_d() == eprosima::fastrtps::types::EK_COMPLETE) {\n+    return c_type_object;\n+  }\n+\n+  TypeObject * type_object = new TypeObject();\n+\n+  type_object->_d(eprosima::fastrtps::types::EK_COMPLETE);\n+  type_object->complete()._d(eprosima::fastrtps::types::TK_STRUCTURE);\n+  type_object->complete().struct_type().struct_flags().IS_FINAL(false);\n+  type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);\n+  type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);\n+  // Not sure whether current type is nested or not, make all Type Nested\n+  type_object->complete().struct_type().struct_flags().IS_NESTED(true);\n+  type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false);  // Unsupported\n+\n+  for (uint32_t i = 0; i < members->member_count_; ++i) {\n+    CompleteStructMember cst_field;\n+    cst_field.common().member_id(i);\n+    cst_field.common().member_flags().TRY_CONSTRUCT1(false);  // Unsupported\n+    cst_field.common().member_flags().TRY_CONSTRUCT2(false);  // Unsupported\n+    cst_field.common().member_flags().IS_EXTERNAL(false);  // Unsupported\n+    cst_field.common().member_flags().IS_OPTIONAL(false);\n+    cst_field.common().member_flags().IS_MUST_UNDERSTAND(false);\n+    cst_field.common().member_flags().IS_KEY(false);\n+    cst_field.common().member_flags().IS_DEFAULT(false);  // Doesn't apply\n+\n+    MemberIdentifierName pair = GetTypeIdentifier(members, i, true);\n+    if (!pair.first) {\n+      continue;\n+    }\n+    cst_field.common().member_type_id(*pair.first);\n+    cst_field.detail().name(pair.second);\n+    type_object->complete().struct_type().member_seq().emplace_back(cst_field);\n+  }\n+\n+  // Header\n+  type_object->complete().struct_type().header().detail().type_name(type_name);\n+\n+  TypeIdentifier identifier;\n+  identifier._d(eprosima::fastrtps::types::EK_COMPLETE);\n+\n+  SerializedPayload_t payload(static_cast<uint32_t>(\n+      CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));\n+\n+  eprosima::fastcdr::FastBuffer fastbuffer(\n+    reinterpret_cast<char *>(payload.data), payload.max_size);\n+\n+  // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for\n+  // DDS document)\n+  eprosima::fastcdr::Cdr ser(\n+    fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n+    eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.\n+  payload.encapsulation = CDR_LE;\n+\n+  type_object->serialize(ser);\n+  payload.length =\n+    static_cast<uint32_t>(ser.getSerializedDataLength());  // Get the serialized length\n+  MD5 objectHash;\n+  objectHash.update(reinterpret_cast<char *>(payload.data), payload.length);\n+  objectHash.finalize();\n+  for (int i = 0; i < 14; ++i) {\n+    identifier.equivalence_hash()[i] = objectHash.digest[i];\n+  }\n+\n+  TypeObjectFactory::get_instance()->add_type_object(type_name, &identifier, type_object);\n+  delete type_object;\n+\n+  return TypeObjectFactory::get_instance()->get_type_object(type_name, true);\n+}\n+\n+template<typename MembersType>\n+const TypeObject * GetMinimalObject(\n+  const std::string & type_name,\n+  const MembersType * members)\n+{\n+  const TypeObject * c_type_object =\n+    TypeObjectFactory::get_instance()->get_type_object(type_name, false);\n+  if (c_type_object != nullptr) {\n+    return c_type_object;\n+  }\n+\n+  TypeObject * type_object = new TypeObject();\n+  type_object->_d(eprosima::fastrtps::types::EK_MINIMAL);\n+  type_object->minimal()._d(eprosima::fastrtps::types::TK_STRUCTURE);\n+  type_object->minimal().struct_type().struct_flags().IS_FINAL(false);\n+  type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);\n+  type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);\n+  type_object->minimal().struct_type().struct_flags().IS_NESTED(true);\n+  type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false);  // Unsupported\n+\n+  for (uint32_t i = 0; i < members->member_count_; ++i) {\n+    MinimalStructMember mst_field;\n+    mst_field.common().member_id(i);\n+    mst_field.common().member_flags().TRY_CONSTRUCT1(false);  // Unsupported\n+    mst_field.common().member_flags().TRY_CONSTRUCT2(false);  // Unsupported\n+    mst_field.common().member_flags().IS_EXTERNAL(false);  // Unsupported\n+    mst_field.common().member_flags().IS_OPTIONAL(false);\n+    mst_field.common().member_flags().IS_MUST_UNDERSTAND(false);\n+    mst_field.common().member_flags().IS_KEY(false);\n+    mst_field.common().member_flags().IS_DEFAULT(false);  // Doesn't apply\n+\n+    MemberIdentifierName pair = GetTypeIdentifier(members, i, false);\n+    if (!pair.first) {\n+      continue;\n+    }\n+    mst_field.common().member_type_id(*pair.first);\n+    MD5 field_hash(pair.second);\n+    for (int i = 0; i < 4; ++i) {\n+      mst_field.detail().name_hash()[i] = field_hash.digest[i];\n+    }\n+    type_object->minimal().struct_type().member_seq().emplace_back(mst_field);\n+  }\n+\n+  TypeIdentifier identifier;\n+  identifier._d(eprosima::fastrtps::types::EK_MINIMAL);\n+\n+  SerializedPayload_t payload(\n+    static_cast<uint32_t>(\n+      MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));\n+\n+  eprosima::fastcdr::FastBuffer fastbuffer(\n+    reinterpret_cast<char *>(payload.data), payload.max_size);\n+\n+  // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for\n+  // DDS document)\n+  eprosima::fastcdr::Cdr ser(\n+    fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n+    eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.\n+  payload.encapsulation = CDR_LE;\n+\n+  type_object->serialize(ser);\n+  payload.length =\n+    static_cast<uint32_t>(ser.getSerializedDataLength());  // Get the serialized length\n+  MD5 objectHash;\n+  objectHash.update(reinterpret_cast<char *>(payload.data), payload.length);\n+  objectHash.finalize();\n+  for (int i = 0; i < 14; ++i) {\n+    identifier.equivalence_hash()[i] = objectHash.digest[i];\n+  }\n+\n+  TypeObjectFactory::get_instance()->add_type_object(type_name, &identifier, type_object);\n+  delete type_object;\n+  return TypeObjectFactory::get_instance()->get_type_object(type_name, false);\n+}\n+\n+template<typename MembersType>\n+MemberIdentifierName GetTypeIdentifier(const MembersType * members, uint32_t index, bool complete)\n+{\n+  const auto member = members->members_ + index;\n+  const TypeIdentifier * type_identifier = nullptr;\n+  std::string name = member->name_;\n+\n+  std::string type_name;\n+  bool complete_type = false;\n+  switch (member->type_id_) {\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT:\n+      {\n+        type_name = \"float\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_DOUBLE:\n+      {\n+        type_name = \"double\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_LONG_DOUBLE:\n+      {\n+        type_name = \"longdouble\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n+      {\n+        type_name = \"char\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WCHAR:\n+      {\n+        type_name = \"wchar\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BOOLEAN:\n+      {\n+        type_name = \"bool\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_OCTET:\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT8:\n+      {\n+        type_name = \"uint8_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT8:\n+      {\n+        type_name = \"int8_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT16:\n+      {\n+        type_name = \"uint16_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT16:\n+      {\n+        type_name = \"int16_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT32:\n+      {\n+        type_name = \"uint32_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT32:\n+      {\n+        type_name = \"int32_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT64:\n+      {\n+        type_name = \"uint64_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT64:\n+      {\n+        type_name = \"int64_t\";\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n+      {\n+        uint32_t bound = member->string_upper_bound_ ? member->string_upper_bound_ : 255;\n+        bool wide =\n+          (member->type_id_ == ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING) ?\n+          false : true;\n+        TypeObjectFactory::get_instance()->get_string_identifier(bound, wide);\n+        type_name = TypeNamesGenerator::get_string_type_name(\n+          bound, wide);\n+        break;\n+      }\n+    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE:\n+      {\n+        const rosidl_message_type_support_t * type_support_intro =\n+          get_type_support_introspection(member->members_);\n+        const MembersType * sub_members =\n+          static_cast<const MembersType *>(type_support_intro->data);\n+        std::string sub_type_name = _create_type_name(sub_members);\n+        if (complete) {\n+          GetCompleteObject(sub_type_name, sub_members);\n+        } else {\n+          GetMinimalObject(sub_type_name, sub_members);\n+        }\n+        type_name = sub_type_name;\n+        complete_type = complete;\n+      }\n+      break;\n+    default:\n+      break;\n+  }\n+\n+  if (!type_name.empty()) {\n+    if (!member->is_array_) {\n+      type_identifier = TypeObjectFactory::get_instance()->get_type_identifier(\n+        type_name, complete_type);\n+    } else if (member->array_size_ && !member->is_upper_bound_) {\n+      type_identifier = TypeObjectFactory::get_instance()->get_array_identifier(\n+        type_name, {static_cast<uint32_t>(member->array_size_)}, complete_type);\n+    } else {\n+      type_identifier = TypeObjectFactory::get_instance()->get_sequence_identifier(\n+        type_name, 0, complete_type);\n+    }\n+  }\n+\n+  return {type_identifier, name};\n+}\n+\n+template<typename MembersType>\n+const TypeObject * GetTypeObject(\n+  const std::string & type_name, bool complete,\n+  const MembersType * members)\n+{\n+  const TypeObject * c_type_object =\n+    TypeObjectFactory::get_instance()->get_type_object(type_name, complete);\n+  if (c_type_object != nullptr) {\n+    return c_type_object;\n+  } else if (complete) {\n+    return GetCompleteObject(type_name, members);\n+  }\n+  // else\n+  return GetMinimalObject(type_name, members);\n+}\n+\n+template<typename MembersType>\n+const TypeIdentifier * GetTypeIdentifier(\n+  const std::string & type_name, bool complete,\n+  const MembersType * members)\n+{\n+  const TypeIdentifier * c_identifier =\n+    TypeObjectFactory::get_instance()->get_type_identifier(type_name, complete);\n+  if (c_identifier != nullptr &&\n+    (!complete || c_identifier->_d() == eprosima::fastrtps::types::EK_COMPLETE))\n+  {\n+    return c_identifier;\n+  }\n+\n+  GetTypeObject(type_name, complete, members);  // Generated inside\n+  return TypeObjectFactory::get_instance()->get_type_identifier(type_name, complete);\n+}\n+\n+template<typename MembersType>\n+inline bool\n+add_type_object(\n+  const void * untype_members,\n+  const std::string & type_name)\n+{\n+  const MembersType * members = static_cast<const MembersType *>(untype_members);\n+  if (!members) {\n+    return false;\n+  }\n+\n+  TypeObjectFactory * factory = TypeObjectFactory::get_instance();\n+  if (!factory) {\n+    return false;\n+  }\n+\n+  const TypeIdentifier * identifier = nullptr;\n+  const TypeObject * type_object = nullptr;\n+  identifier = GetTypeIdentifier(type_name, true, members);\n+  if (!identifier) {\n+    return false;\n+  }\n+  type_object = GetTypeObject(type_name, true, members);\n+  if (!type_object) {\n+    return false;\n+  }\n+\n+  factory->add_type_object(type_name, identifier, type_object);\n+\n+  identifier = GetTypeIdentifier(type_name, false, members);\n+  if (!identifier) {\n+    return false;\n+  }\n+  type_object = GetTypeObject(type_name, false, members);\n+  if (!type_object) {\n+    return false;\n+  }\n+  factory->add_type_object(type_name, identifier, type_object);\n+\n+  return true;\n+}\n+\n+bool register_type_object(\n+  const rosidl_message_type_support_t * type_supports,\n+  const std::string & type_name)\n+{\n+  const rosidl_message_type_support_t * type_support_intro =\n+    get_type_support_introspection(type_supports);\n+  if (!type_support_intro) {\n+    return false;\n+  }\n+\n+  bool ret = false;\n+  if (type_support_intro->typesupport_identifier ==\n+    rosidl_typesupport_introspection_c__identifier)\n+  {\n+    ret = add_type_object<rosidl_typesupport_introspection_c__MessageMembers>(\n+      type_support_intro->data, type_name);\n+  } else {\n+    ret = add_type_object<rosidl_typesupport_introspection_cpp::MessageMembers>(\n+      type_support_intro->data, type_name);\n+  }\n+\n+  return ret;\n+}\n+"},{"role":"user","content":"+#include \"rcpputils/scope_exit.hpp\"\n+"},{"role":"user","content":"+#include \"rmw_fastrtps_shared_cpp/utils.hpp\""},{"role":"user","content":"-  rmw_subscription_t * subscription)\n+  rmw_subscription_t * subscription,\n+  bool reset_cft)"},{"role":"user","content":"-  rmw_ret_t local_ret = destroy_subscription(identifier, participant_info, subscription);\n+  rmw_ret_t local_ret = destroy_subscription(identifier, participant_info, subscription, reset_cft);"},{"role":"user","content":"+rmw_ret_t\n+__rmw_subscription_set_content_filter(\n+  rmw_subscription_t * subscription,\n+  const rmw_subscription_content_filter_options_t * options\n+)\n+{\n+  auto info = static_cast<CustomSubscriberInfo *>(subscription->data);\n+  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = info->filtered_topic_;\n+  const bool filter_expression_empty = (*options->filter_expression == '\\0');\n+\n+  if (!filtered_topic && filter_expression_empty) {\n+    // can't reset current subscriber\n+    RMW_SET_ERROR_MSG(\n+      \"current subscriber has no content filter topic\");\n+    return RMW_RET_ERROR;\n+  } else if (filtered_topic && !filter_expression_empty) {\n+    std::vector<std::string> expression_parameters;\n+    for (size_t i = 0; i < options->expression_parameters.size; ++i) {\n+      expression_parameters.push_back(options->expression_parameters.data[i]);\n+    }\n+\n+    ReturnCode_t ret =\n+      filtered_topic->set_filter_expression(options->filter_expression, expression_parameters);\n+    if (ret != ReturnCode_t::RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\n+        \"failed to set_filter_expression\");\n+      return RMW_RET_ERROR;\n+    }\n+    return RMW_RET_OK;\n+  }\n+\n+  eprosima::fastdds::dds::DomainParticipant * dds_participant =\n+    info->dds_participant_;\n+  eprosima::fastdds::dds::TopicDescription * des_topic = nullptr;\n+  const char * eprosima_fastrtps_identifier = subscription->implementation_identifier;\n+\n+  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_destroy_subscription(\n+    eprosima_fastrtps_identifier,\n+    info->node_,\n+    subscription,\n+    true /* reset_cft */);\n+  if (ret != RMW_RET_OK) {\n+    RMW_SET_ERROR_MSG(\"delete subscription with reset cft\");\n+    return RMW_RET_ERROR;\n+  }\n+\n+  if (!filtered_topic) {\n+    // create content filtered topic\n+    eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = nullptr;\n+    if (!rmw_fastrtps_shared_cpp::create_content_filtered_topic(\n+        dds_participant, info->topic_,\n+        info->topic_name_mangled_, options, &filtered_topic))\n+    {\n+      RMW_SET_ERROR_MSG(\"create_contentfilteredtopic() failed to create contentfilteredtopic\");\n+      return RMW_RET_ERROR;\n+    }\n+    info->filtered_topic_ = filtered_topic;\n+    des_topic = filtered_topic;\n+  } else {\n+    // use the existing parent topic\n+    des_topic = info->topic_;\n+  }\n+\n+  // create data reader\n+  eprosima::fastdds::dds::Subscriber * subscriber = info->subscriber_;\n+  const rmw_subscription_options_t * subscription_options =\n+    &subscription->options;\n+  if (!rmw_fastrtps_shared_cpp::create_datareader(\n+      info->datareader_qos_,\n+      subscription_options,\n+      subscriber,\n+      des_topic,\n+      info->listener_,\n+      &info->data_reader_))\n+  {\n+    RMW_SET_ERROR_MSG(\"create_datareader() could not create data reader\");\n+    return RMW_RET_ERROR;\n+  }\n+  // lambda to delete datareader\n+  auto cleanup_datareader = rcpputils::make_scope_exit(\n+    [subscriber, info]() {\n+      subscriber->delete_datareader(info->data_reader_);\n+    });\n+\n+  /////\n+  // Update RMW GID\n+  info->subscription_gid_ = rmw_fastrtps_shared_cpp::create_rmw_gid(\n+    eprosima_fastrtps_identifier, info->data_reader_->guid());\n+\n+  {\n+    rmw_dds_common::Context * common_context = info->common_context_;\n+    const rmw_node_t * node = info->node_;\n+\n+    // Update graph\n+    std::lock_guard<std::mutex> guard(common_context->node_update_mutex);\n+    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n+      common_context->graph_cache.associate_reader(\n+      info->subscription_gid_, common_context->gid, node->name, node->namespace_);\n+    rmw_ret_t rmw_ret = rmw_fastrtps_shared_cpp::__rmw_publish(\n+      eprosima_fastrtps_identifier,\n+      common_context->pub,\n+      static_cast<void *>(&msg),\n+      nullptr);\n+    if (RMW_RET_OK != rmw_ret) {\n+      static_cast<void>(common_context->graph_cache.dissociate_writer(\n+        info->subscription_gid_, common_context->gid, node->name, node->namespace_));\n+      return RMW_RET_ERROR;\n+    }\n+  }\n+  cleanup_datareader.cancel();\n+  return RMW_RET_OK;\n+}\n+\n+rmw_ret_t\n+__rmw_subscription_get_content_filter(\n+  const rmw_subscription_t * subscription,\n+  rcutils_allocator_t * allocator,\n+  rmw_subscription_content_filter_options_t * options\n+)\n+{\n+  auto info = static_cast<CustomSubscriberInfo *>(subscription->data);\n+  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = info->filtered_topic_;\n+\n+  if (nullptr == filtered_topic) {\n+    RMW_SET_ERROR_MSG(\"this subscriber has not created a ContentFilteredTopic\");\n+    return RMW_RET_ERROR;\n+  }\n+  std::vector<std::string> expression_parameters;\n+  ReturnCode_t ret = filtered_topic->get_expression_parameters(expression_parameters);\n+  if (ret != ReturnCode_t::RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\n+      \"failed to get_expression_parameters\");\n+    return RMW_RET_ERROR;\n+  }\n+\n+  std::vector<const char *> string_array;\n+  for (size_t i = 0; i < expression_parameters.size(); ++i) {\n+    string_array.push_back(expression_parameters[i].c_str());\n+  }\n+\n+  return rmw_subscription_content_filter_options_init(\n+    filtered_topic->get_filter_expression().c_str(),\n+    string_array.size(),\n+    string_array.data(),\n+    allocator,\n+    options\n+  );\n+}\n+"},{"role":"user","content":"-  rmw_subscription_t * subscription)\n+  rmw_subscription_t * subscription,\n+  bool reset_cft)"},{"role":"user","content":"-    // Keep pointer to topic, so we can remove it later\n-    auto topic = info->data_reader_->get_topicdescription();\n-"},{"role":"user","content":"+    // Delete ContentFilteredTopic\n+    if (nullptr != info->filtered_topic_) {\n+      participant_info->participant_->delete_contentfilteredtopic(info->filtered_topic_);\n+      info->filtered_topic_ = nullptr;\n+    }\n+\n+    if (reset_cft) {\n+      return RMW_RET_OK;\n+    }\n+"},{"role":"user","content":"-    remove_topic_and_type(participant_info, topic, info->type_support_);\n+    remove_topic_and_type(participant_info, info->topic_, info->type_support_);"},{"role":"user","content":"+const char * const CONTENT_FILTERED_TOPIC_POSTFIX = \"_filtered_name\";\n+"},{"role":"user","content":"+"},{"role":"user","content":"+bool\n+create_content_filtered_topic(\n+  eprosima::fastdds::dds::DomainParticipant * participant,\n+  eprosima::fastdds::dds::TopicDescription * topic_desc,\n+  const std::string & topic_name_mangled,\n+  const rmw_subscription_content_filter_options_t * options,\n+  eprosima::fastdds::dds::ContentFilteredTopic ** content_filtered_topic)\n+{\n+  std::vector<std::string> expression_parameters;\n+  for (size_t i = 0; i < options->expression_parameters.size; ++i) {\n+    expression_parameters.push_back(options->expression_parameters.data[i]);\n+  }\n+\n+  auto topic = dynamic_cast<eprosima::fastdds::dds::Topic *>(topic_desc);\n+  std::string cft_topic_name = topic_name_mangled + CONTENT_FILTERED_TOPIC_POSTFIX;\n+  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic =\n+    participant->create_contentfilteredtopic(\n+    cft_topic_name,\n+    topic,\n+    options->filter_expression,\n+    expression_parameters);\n+  if (filtered_topic == nullptr) {\n+    return false;\n+  }\n+\n+  *content_filtered_topic = filtered_topic;\n+  return true;\n+}\n+\n+bool\n+create_datareader(\n+  const eprosima::fastdds::dds::DataReaderQos & datareader_qos,\n+  const rmw_subscription_options_t * subscription_options,\n+  eprosima::fastdds::dds::Subscriber * subscriber,\n+  eprosima::fastdds::dds::TopicDescription * des_topic,\n+  SubListener * listener,\n+  eprosima::fastdds::dds::DataReader ** data_reader\n+)\n+{\n+  eprosima::fastdds::dds::DataReaderQos updated_qos = datareader_qos;\n+  switch (subscription_options->require_unique_network_flow_endpoints) {\n+    default:\n+    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT:\n+    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED:\n+      // Unique network flow endpoints not required. We leave the decission to the XML profile.\n+      break;\n+\n+    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED:\n+    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED:\n+      // Ensure we request unique network flow endpoints\n+      using PropertyPolicyHelper = eprosima::fastrtps::rtps::PropertyPolicyHelper;\n+      if (nullptr ==\n+        PropertyPolicyHelper::find_property(\n+          updated_qos.properties(),\n+          \"fastdds.unique_network_flows\"))\n+      {\n+        updated_qos.properties().properties().emplace_back(\"fastdds.unique_network_flows\", \"\");\n+      }\n+      break;\n+  }\n+\n+  // Creates DataReader (with subscriber name to not change name policy)\n+  *data_reader = subscriber->create_datareader(\n+    des_topic,\n+    updated_qos,\n+    listener);\n+  if (!data_reader &&\n+    (RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED ==\n+    subscription_options->require_unique_network_flow_endpoints))\n+  {\n+    *data_reader = subscriber->create_datareader(\n+      des_topic,\n+      datareader_qos,\n+      listener);\n+  }\n+  return true;\n+}\n+\n+"},{"role":"assistant","content":"No"}]}
