[
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "c42656aaa6377397d8e34edabf51e22f4c6e41d6",
    "RawMessage": "Handle RMW_DEFAULT_DOMAIN_ID. (#194)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 2ad92c3..508512a 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -925,7 \u002B925,10 @@ rmw_context_impl_t::init(rmw_init_options_t * options)\n     failed: otherwise there is a race with rmw_destroy_node deleting the last participant\n     and tearing down the domain for versions of Cyclone that implement the original\n     version of dds_create_domain that doesn\u0027t return a handle.  */\n-  this-\u003Edomain_id = static_cast\u003Cdds_domainid_t\u003E(options-\u003Edomain_id);\n\u002B  this-\u003Edomain_id = static_cast\u003Cdds_domainid_t\u003E(\n\u002B    // No custom handling of RMW_DEFAULT_DOMAIN_ID. Simply use a reasonable domain id.\n\u002B    options-\u003Edomain_id != RMW_DEFAULT_DOMAIN_ID ? options-\u003Edomain_id : 0u);\n\u002B\n   if (!check_create_domain(this-\u003Edomain_id, options-\u003Elocalhost_only)) {\n     return RMW_RET_ERROR;\n   }\n@@ -1114,8 \u002B1117,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_init(const rmw_init_options_t * options, rmw_context_t\n     eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n-  /* domain_id = UINT32_MAX = Cyclone DDS\u0027 \u0022default domain id\u0022.*/\n-  if (options-\u003Edomain_id \u003E= UINT32_MAX) {\n\u002B  if (options-\u003Edomain_id \u003E= UINT32_MAX \u0026\u0026 options-\u003Edomain_id != RMW_DEFAULT_DOMAIN_ID) {\n     RCUTILS_LOG_ERROR_NAMED(\n       \u0022rmw_cyclonedds_cpp\u0022, \u0022rmw_create_node: domain id out of range\u0022);\n     return RMW_RET_INVALID_ARGUMENT;\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "10252e9f66ac87f3903f301b64320d32457f0658",
    "RawMessage": "Set hints to find the python version we actually want. (#2426)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex cad17103..1f78d03d 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -1,4 \u002B1,4 @@\n-cmake_minimum_required(VERSION 3.12)\n\u002Bcmake_minimum_required(VERSION 3.20)\n \n project(rclcpp)\n \n@@ -127,6 \u002B127,21 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/waitable.cpp\n )\n \n\u002B# By default, without the settings below, find_package(Python3) will attempt\n\u002B# to find the newest python version it can, and additionally will find the\n\u002B# most specific version.  For instance, on a system that has\n\u002B# /usr/bin/python3.10, /usr/bin/python3.11, and /usr/bin/python3, it will find\n\u002B# /usr/bin/python3.11, even if /usr/bin/python3 points to /usr/bin/python3.10.\n\u002B# The behavior we want is to prefer the \u0022system\u0022 installed version unless the\n\u002B# user specifically tells us othewise through the Python3_EXECUTABLE hint.\n\u002B# Setting CMP0094 to NEW means that the search will stop after the first\n\u002B# python version is found.  Setting Python3_FIND_UNVERSIONED_NAMES means that\n\u002B# the search will prefer /usr/bin/python3 over /usr/bin/python3.11.  And that\n\u002B# latter functionality is only available in CMake 3.20 or later, so we need\n\u002B# at least that version.\n\u002Bcmake_policy(SET CMP0094 NEW)\n\u002Bset(Python3_FIND_UNVERSIONED_NAMES FIRST)\n\u002B\n find_package(Python3 REQUIRED COMPONENTS Interpreter)\n \n # \u0022watch\u0022 template for changes\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "de353f9e45ca2ef191708e557f217eda843ab46a",
    "RawMessage": "Reserve vector capacities and use emplace_back for constructing vectors (#1464)",
    "Changes": "diff --git rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\nindex 1696e267..107166da 100644\n--- rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node_interface_impl.hpp\n@@ -265,11 \u002B265,13 @@ public:\n       throw std::runtime_error(\n               \u0022Can\u0027t get available states. State machine is not initialized.\u0022);\n     }\n\u002B\n\u002B    resp-\u003Eavailable_states.resize(state_machine_.transition_map.states_size);\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.states_size; \u002B\u002Bi) {\n-      lifecycle_msgs::msg::State state;\n-      state.id = static_cast\u003Cuint8_t\u003E(state_machine_.transition_map.states[i].id);\n-      state.label = static_cast\u003Cstd::string\u003E(state_machine_.transition_map.states[i].label);\n-      resp-\u003Eavailable_states.push_back(state);\n\u002B      resp-\u003Eavailable_states[i].id =\n\u002B        static_cast\u003Cuint8_t\u003E(state_machine_.transition_map.states[i].id);\n\u002B      resp-\u003Eavailable_states[i].label =\n\u002B        static_cast\u003Cstd::string\u003E(state_machine_.transition_map.states[i].label);\n     }\n   }\n \n@@ -286,16 \u002B288,17 @@ public:\n               \u0022Can\u0027t get available transitions. State machine is not initialized.\u0022);\n     }\n \n\u002B    resp-\u003Eavailable_transitions.resize(state_machine_.current_state-\u003Evalid_transition_size);\n     for (unsigned int i = 0; i \u003C state_machine_.current_state-\u003Evalid_transition_size; \u002B\u002Bi) {\n\u002B      lifecycle_msgs::msg::TransitionDescription \u0026 trans_desc = resp-\u003Eavailable_transitions[i];\n\u002B\n       auto rcl_transition = state_machine_.current_state-\u003Evalid_transitions[i];\n-      lifecycle_msgs::msg::TransitionDescription trans_desc;\n       trans_desc.transition.id = static_cast\u003Cuint8_t\u003E(rcl_transition.id);\n       trans_desc.transition.label = rcl_transition.label;\n       trans_desc.start_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.start-\u003Eid);\n       trans_desc.start_state.label = rcl_transition.start-\u003Elabel;\n       trans_desc.goal_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.goal-\u003Eid);\n       trans_desc.goal_state.label = rcl_transition.goal-\u003Elabel;\n-      resp-\u003Eavailable_transitions.push_back(trans_desc);\n     }\n   }\n \n@@ -312,16 \u002B315,17 @@ public:\n               \u0022Can\u0027t get available transitions. State machine is not initialized.\u0022);\n     }\n \n\u002B    resp-\u003Eavailable_transitions.resize(state_machine_.transition_map.transitions_size);\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.transitions_size; \u002B\u002Bi) {\n\u002B      lifecycle_msgs::msg::TransitionDescription \u0026 trans_desc = resp-\u003Eavailable_transitions[i];\n\u002B\n       auto rcl_transition = state_machine_.transition_map.transitions[i];\n-      lifecycle_msgs::msg::TransitionDescription trans_desc;\n       trans_desc.transition.id = static_cast\u003Cuint8_t\u003E(rcl_transition.id);\n       trans_desc.transition.label = rcl_transition.label;\n       trans_desc.start_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.start-\u003Eid);\n       trans_desc.start_state.label = rcl_transition.start-\u003Elabel;\n       trans_desc.goal_state.id = static_cast\u003Cuint8_t\u003E(rcl_transition.goal-\u003Eid);\n       trans_desc.goal_state.label = rcl_transition.goal-\u003Elabel;\n-      resp-\u003Eavailable_transitions.push_back(trans_desc);\n     }\n   }\n \n@@ -336,9 \u002B340,10 @@ public:\n   get_available_states()\n   {\n     std::vector\u003CState\u003E states;\n\u002B    states.reserve(state_machine_.transition_map.states_size);\n\u002B\n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.states_size; \u002B\u002Bi) {\n-      State state(\u0026state_machine_.transition_map.states[i]);\n-      states.push_back(state);\n\u002B      states.emplace_back(\u0026state_machine_.transition_map.states[i]);\n     }\n     return states;\n   }\n@@ -347,11 \u002B352,10 @@ public:\n   get_available_transitions()\n   {\n     std::vector\u003CTransition\u003E transitions;\n\u002B    transitions.reserve(state_machine_.transition_map.transitions_size);\n \n     for (unsigned int i = 0; i \u003C state_machine_.transition_map.transitions_size; \u002B\u002Bi) {\n-      Transition transition(\n-        \u0026state_machine_.transition_map.transitions[i]);\n-      transitions.push_back(transition);\n\u002B      transitions.emplace_back(\u0026state_machine_.transition_map.transitions[i]);\n     }\n     return transitions;\n   }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcutils",
    "SHA": "ebb174d25600e5c103d656f7598bd2c9f935b7cb",
    "RawMessage": "Add \u0027mimick\u0027 label to tests which use Mimick (#466)",
    "Changes": "diff --git CMakeLists.txt CMakeLists.txt\nindex 4f6ae5f..ee45396 100644\n--- CMakeLists.txt\n\u002B\u002B\u002B CMakeLists.txt\n@@ -311,6 \u002B311,7 @@ if(BUILD_TESTING)\n   ament_add_gtest(test_strerror\n     test/test_strerror.cpp\n   )\n\u002B  ament_add_test_label(test_strerror mimick)\n   if(TARGET test_strerror)\n     target_link_libraries(test_strerror ${PROJECT_NAME} mimick)\n   endif()\n@@ -336,6 \u002B337,7 @@ if(BUILD_TESTING)\n     test/test_filesystem.cpp\n     WORKING_DIRECTORY \u0022${CMAKE_CURRENT_SOURCE_DIR}\u0022\n   )\n\u002B  ament_add_test_label(test_filesystem mimick)\n   if(TARGET test_filesystem)\n     target_link_libraries(test_filesystem ${PROJECT_NAME} mimick osrf_testing_tools_cpp::memory_tools)\n     target_compile_definitions(test_filesystem PRIVATE BUILD_DIR=\u0022${CMAKE_CURRENT_BINARY_DIR}\u0022)\n@@ -460,6 \u002B462,7 @@ if(BUILD_TESTING)\n   ament_add_gtest(test_time\n     test/test_time.cpp\n     ENV ${memory_tools_test_env_vars})\n\u002B  ament_add_test_label(test_time mimick)\n   if(TARGET test_time)\n     target_link_libraries(test_time ${PROJECT_NAME} mimick osrf_testing_tools_cpp::memory_tools)\n   endif()\n@@ -522,6 \u002B525,7 @@ if(BUILD_TESTING)\n       RCUTILS_LOGGING_USE_STDOUT=1\n       RCUTILS_COLORIZED_OUTPUT=1\n   )\n\u002B  ament_add_test_label(test_logging_custom_env mimick)\n   if(TARGET test_logging_custom_env)\n     target_link_libraries(test_logging_custom_env ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools mimick)\n   endif()\n@@ -539,6 \u002B543,7 @@ if(BUILD_TESTING)\n       RCUTILS_LOGGING_USE_STDOUT=0\n       RCUTILS_COLORIZED_OUTPUT=0\n   )\n\u002B  ament_add_test_label(test_logging_custom_env2 mimick)\n   if(TARGET test_logging_custom_env2)\n     target_link_libraries(test_logging_custom_env2 ${PROJECT_NAME} osrf_testing_tools_cpp::memory_tools mimick)\n   endif()\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "5ee7ad4e7811902af7e07f515904e02e811f230a",
    "RawMessage": "Handle take failure in wait_for_message (#1172)",
    "Changes": "diff --git rclpy/rclpy/wait_for_message.py rclpy/rclpy/wait_for_message.py\nindex 9c0bd63..5b2a8de 100644\n--- rclpy/rclpy/wait_for_message.py\n\u002B\u002B\u002B rclpy/rclpy/wait_for_message.py\n@@ -56,6 \u002B56,7 @@ def wait_for_message(\n     if subs_ready:\n         if sub.handle.pointer in subs_ready:\n             msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n-            return (True, msg_info[0])\n\u002B            if msg_info is not None:\n\u002B                return (True, msg_info[0])\n \n     return (False, None)\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "launch_ros",
    "SHA": "b424bbb1076142ded03aebf36f7b3df7b9542769",
    "RawMessage": "Increase test_composable_node_container timeout (#195)",
    "Changes": "diff --git test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\nindex 3caec8f..75d3749 100644\n--- test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\n\u002B\u002B\u002B test_launch_ros/test/test_launch_ros/actions/test_composable_node_container.py\n@@ -33,7 \u002B33,7 @@ TEST_NODE_NAME = \u0027test_composable_node_name\u0027\n TEST_NODE_NAMESPACE = \u0027test_composable_node_namespace\u0027\n \n \n-def _assert_launch_no_errors(actions, *, timeout_sec=1):\n\u002Bdef _assert_launch_no_errors(actions, *, timeout_sec=5):\n     ld = LaunchDescription(actions)\n     ls = LaunchService(debug=True)\n     ls.include_launch_description(ld)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "5cecbf99bbb0f1d558592761d9b41d3de39e169f",
    "RawMessage": "Add check for invalid topic statistics publish period (#1151)",
    "Changes": "diff --git rclcpp/include/rclcpp/create_subscription.hpp rclcpp/include/rclcpp/create_subscription.hpp\nindex 207bee4a..2eb24b48 100644\n--- rclcpp/include/rclcpp/create_subscription.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/create_subscription.hpp\n@@ -18,6 \u002B18,7 @@\n #include \u003Cchrono\u003E\n #include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n@@ -44,6 \u002B45,23 @@ namespace rclcpp\n  * The NodeT type only needs to have a method called get_node_topics_interface()\n  * which returns a shared_ptr to a NodeTopicsInterface, or be a\n  * NodeTopicsInterface pointer itself.\n\u002B *\n\u002B * \\tparam MessageT\n\u002B * \\tparam CallbackT\n\u002B * \\tparam AllocatorT\n\u002B * \\tparam CallbackMessageT\n\u002B * \\tparam SubscriptionT\n\u002B * \\tparam MessageMemoryStrategyT\n\u002B * \\tparam NodeT\n\u002B * \\param node\n\u002B * \\param topic_name\n\u002B * \\param qos\n\u002B * \\param callback\n\u002B * \\param options\n\u002B * \\param msg_mem_strat\n\u002B * \\return the created subscription\n\u002B * \\throws std::invalid_argument if topic statistics is enabled and the publish period is\n\u002B * less than or equal to zero.\n  */\n template\u003C\n   typename MessageT,\n@@ -81,6 \u002B99,13 @@ create_subscription(\n       options,\n       *node_topics-\u003Eget_node_base_interface()))\n   {\n\u002B    if (options.topic_stats_options.publish_period \u003C= std::chrono::milliseconds(0)) {\n\u002B      throw std::invalid_argument(\n\u002B              \u0022topic_stats_options.publish_period must be greater than 0, specified value of \u0022 \u002B\n\u002B              std::to_string(options.topic_stats_options.publish_period.count()) \u002B\n\u002B              \u0022 ms\u0022);\n\u002B    }\n\u002B\n     std::shared_ptr\u003CPublisher\u003Cstatistics_msgs::msg::MetricsMessage\u003E\u003E publisher =\n       create_publisher\u003Cstatistics_msgs::msg::MetricsMessage\u003E(\n       node,\ndiff --git rclcpp/include/rclcpp/subscription_options.hpp rclcpp/include/rclcpp/subscription_options.hpp\nindex 5088f35f..ebf4331c 100644\n--- rclcpp/include/rclcpp/subscription_options.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription_options.hpp\n@@ -66,7 \u002B66,8 @@ struct SubscriptionOptionsBase\n     // Topic to which topic statistics get published when enabled. Defaults to /statistics.\n     std::string publish_topic = \u0022/statistics\u0022;\n \n-    // Topic statistics publication period in ms. Defaults to one minute.\n\u002B    // Topic statistics publication period in ms. Defaults to one second.\n\u002B    // Only values greater than zero are allowed.\n     std::chrono::milliseconds publish_period{std::chrono::seconds(1)};\n   };\n \ndiff --git rclcpp/test/topic_statistics/test_subscription_topic_statistics.cpp rclcpp/test/topic_statistics/test_subscription_topic_statistics.cpp\nindex 74a79e6f..dc4e1fa8 100644\n--- rclcpp/test/topic_statistics/test_subscription_topic_statistics.cpp\n\u002B\u002B\u002B rclcpp/test/topic_statistics/test_subscription_topic_statistics.cpp\n@@ -19,6 \u002B19,7 @@\n #include \u003Ciostream\u003E\n #include \u003Cmemory\u003E\n #include \u003Cset\u003E\n\u002B#include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n@@ -219,6 \u002B220,30 @@ protected:\n   }\n };\n \n\u002BTEST(TestSubscriptionTopicStatistics, test_invalid_publish_period)\n\u002B{\n\u002B  rclcpp::init(0 /* argc */, nullptr /* argv */);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_period_node\u0022);\n\u002B\n\u002B  auto options = rclcpp::SubscriptionOptions();\n\u002B  options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n\u002B  options.topic_stats_options.publish_period = std::chrono::milliseconds(0);\n\u002B\n\u002B  auto callback = [](Empty::UniquePtr msg) {\n\u002B      (void) msg;\n\u002B    };\n\u002B\n\u002B  ASSERT_THROW(\n\u002B    (node-\u003Ecreate_subscription\u003CEmpty, std::function\u003Cvoid(Empty::UniquePtr)\u003E\u003E(\n\u002B      \u0022should_throw_invalid_arg\u0022,\n\u002B      rclcpp::QoS(rclcpp::KeepAll()),\n\u002B      callback,\n\u002B      options)), std::invalid_argument);\n\u002B\n\u002B  rclcpp::shutdown();\n\u002B}\n\u002B\n TEST_F(TestSubscriptionTopicStatisticsFixture, test_manual_construction)\n {\n   auto empty_subscriber = std::make_shared\u003CEmptySubscriber\u003E(\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "a127514d2e480f59056c9568cf9ae9b94ae2f1cc",
    "RawMessage": "Fixed naming convention of service response topics in documentation (#144)",
    "Changes": "diff --git README.md README.md\nindex cd414f9..0986674 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -244,7 \u002B244,7 @@ ROS mangles topic names in the following way:\n \n - Topics are prefixed with \u0060rt\u0060. e.g.: \u0060/my/fully/qualified/ros/topic\u0060 is converted to \u0060rt/my/fully/qualified/ros/topic\u0060.\n - The service request topics are prefixed with \u0060rq\u0060 and suffixed with \u0060Request\u0060. e.g.: \u0060/my/fully/qualified/ros/service\u0060 request topic is \u0060rq/my/fully/qualified/ros/serviceRequest\u0060.\n-- The service response topics are prefixed with \u0060rr\u0060 and suffixed with \u0060Response\u0060. e.g.: \u0060/my/fully/qualified/ros/service\u0060 response topic is \u0060rr/my/fully/qualified/ros/serviceResponse\u0060.\n\u002B- The service response topics are prefixed with \u0060rr\u0060 and suffixed with \u0060Reply\u0060. e.g.: \u0060/my/fully/qualified/ros/service\u0060 response topic is \u0060rr/my/fully/qualified/ros/serviceReply\u0060.\n \n ### RMW_CONNEXT_INITIAL_PEERS\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "714f69ee64ee8ea5dbc5f3067211b7886a4e7226",
    "RawMessage": "reject cancel request if failed to transit to CANCEL_GOAL state. (#791)",
    "Changes": "diff --git rclpy/rclpy/action/server.py rclpy/rclpy/action/server.py\nindex 64e7aab..1e018bd 100644\n--- rclpy/rclpy/action/server.py\n\u002B\u002B\u002B rclpy/rclpy/action/server.py\n@@ -28,6 \u002B28,9 @@ from rclpy.task import Future\n from rclpy.type_support import check_for_type_support\n from rclpy.waitable import NumberOfEntities, Waitable\n \n\u002B# Re-export exception defined in _rclpy C extension.\n\u002BRCLError = _rclpy.RCLError\n\u002B\n \n class GoalResponse(Enum):\n     \u0022\u0022\u0022Possible goal responses.\u0022\u0022\u0022\n@@ -362,7 \u002B365,15 @@ class ActionServer(Waitable):\n \n             if CancelResponse.ACCEPT == response:\n                 # Notify goal handle\n-                goal_handle._update_state(_rclpy.GoalEvent.CANCEL_GOAL)\n\u002B                try:\n\u002B                    # If the goal\u0027s just succeeded after user cancel callback\n\u002B                    # that will generate an exception from invalid transition.\n\u002B                    goal_handle._update_state(GoalEvent.CANCEL_GOAL)\n\u002B                except RCLError as ex:\n\u002B                    self._node.get_logger().debug(\n\u002B                        \u0027Failed to cancel goal in cancel callback: {0}\u0027.format(ex))\n\u002B                    # Remove from response since goal has been succeeded\n\u002B                    cancel_response.goals_canceling.remove(goal_info)\n             else:\n                 # Remove from response\n                 cancel_response.goals_canceling.remove(goal_info)\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "1037822a63330495dcf0de5e8f20544375a5f116",
    "RawMessage": "refactor AnySubscriptionCallback and add/deprecate callback signatures (#1598)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex d28ce2be..ea1e516f 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -21,9 \u002B21,10 @@ find_package(rosidl_typesupport_cpp REQUIRED)\n find_package(statistics_msgs REQUIRED)\n find_package(tracetools REQUIRED)\n \n-# Default to C\u002B\u002B14\n\u002B# TODO(wjwwood): remove this when gtest can build on its own, when using target_compile_features()\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   # About -Wno-sign-conversion: With Clang, -Wconversion implies -Wsign-conversion. There are a number of\n@@ -174,8 \u002B175,12 @@ foreach(interface_file ${interface_files})\n     include/rclcpp/node_interfaces/get_${interface_name}.hpp)\n endforeach()\n \n-add_library(${PROJECT_NAME}\n-  ${${PROJECT_NAME}_SRCS})\n\u002Badd_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})\n\u002Btarget_compile_features(${PROJECT_NAME} PUBLIC cxx_std_17)\n\u002B# TODO(wjwwood): address all deprecation warnings and then remove this\n\u002Bif(WIN32)\n\u002B  target_compile_definitions(${PROJECT_NAME} PUBLIC \u0022_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\u0022)\n\u002Bendif()\n target_include_directories(${PROJECT_NAME} PUBLIC\n   \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n   \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include\u003E\u0022\ndiff --git rclcpp/include/rclcpp/any_subscription_callback.hpp rclcpp/include/rclcpp/any_subscription_callback.hpp\nindex 9a31ecff..61b5e2e8 100644\n--- rclcpp/include/rclcpp/any_subscription_callback.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/any_subscription_callback.hpp\n@@ -15,256 \u002B15,394 @@\n #ifndef RCLCPP__ANY_SUBSCRIPTION_CALLBACK_HPP_\n #define RCLCPP__ANY_SUBSCRIPTION_CALLBACK_HPP_\n \n-#include \u003Crmw/types.h\u003E\n-\n #include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstdexcept\u003E\n #include \u003Ctype_traits\u003E\n #include \u003Cutility\u003E\n\u002B#include \u003Cvariant\u003E  // NOLINT[build/include_order]\n\u002B\n\u002B#include \u0022tracetools/tracetools.h\u0022\n\u002B#include \u0022tracetools/utils.hpp\u0022\n \n #include \u0022rclcpp/allocator/allocator_common.hpp\u0022\n\u002B#include \u0022rclcpp/detail/subscription_callback_type_helper.hpp\u0022\n #include \u0022rclcpp/function_traits.hpp\u0022\n #include \u0022rclcpp/message_info.hpp\u0022\n-#include \u0022rclcpp/visibility_control.hpp\u0022\n-#include \u0022tracetools/tracetools.h\u0022\n-#include \u0022tracetools/utils.hpp\u0022\n\u002B\n\u002Btemplate\u003Cclass\u003E\n\u002Binline constexpr bool always_false_v = false;\n \n namespace rclcpp\n {\n \n-template\u003Ctypename MessageT, typename Alloc\u003E\n-class AnySubscriptionCallback\n\u002Bnamespace detail\n {\n-  using MessageAllocTraits = allocator::AllocRebind\u003CMessageT, Alloc\u003E;\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename AllocatorT\u003E\n\u002Bstruct MessageDeleterHelper\n\u002B{\n\u002B  using MessageAllocTraits = allocator::AllocRebind\u003CMessageT, AllocatorT\u003E;\n   using MessageAlloc = typename MessageAllocTraits::allocator_type;\n   using MessageDeleter = allocator::Deleter\u003CMessageAlloc, MessageT\u003E;\n-  using ConstMessageSharedPtr = std::shared_ptr\u003Cconst MessageT\u003E;\n-  using MessageUniquePtr = std::unique_ptr\u003CMessageT, MessageDeleter\u003E;\n\u002B};\n \n-  using SharedPtrCallback = std::function\u003Cvoid (const std::shared_ptr\u003CMessageT\u003E)\u003E;\n-  using SharedPtrWithInfoCallback =\n-    std::function\u003Cvoid (const std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n-  using ConstSharedPtrCallback = std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E)\u003E;\n-  using ConstSharedPtrWithInfoCallback =\n-    std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n-  using UniquePtrCallback = std::function\u003Cvoid (MessageUniquePtr)\u003E;\n\u002Btemplate\u003Ctypename MessageT, typename AllocatorT\u003E\n\u002Bstruct AnySubscriptionCallbackHelper\n\u002B{\n\u002B  using MessageDeleter = typename MessageDeleterHelper\u003CMessageT, AllocatorT\u003E::MessageDeleter;\n\u002B\n\u002B  using ConstRefCallback =\n\u002B    std::function\u003Cvoid (const MessageT \u0026)\u003E;\n\u002B  using ConstRefWithInfoCallback =\n\u002B    std::function\u003Cvoid (const MessageT \u0026, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B\n\u002B  using UniquePtrCallback =\n\u002B    std::function\u003Cvoid (std::unique_ptr\u003CMessageT, MessageDeleter\u003E)\u003E;\n   using UniquePtrWithInfoCallback =\n-    std::function\u003Cvoid (MessageUniquePtr, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B    std::function\u003Cvoid (std::unique_ptr\u003CMessageT, MessageDeleter\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B\n\u002B  using SharedConstPtrCallback =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003Cconst MessageT\u003E)\u003E;\n\u002B  using SharedConstPtrWithInfoCallback =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003Cconst MessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B\n\u002B  using ConstRefSharedConstPtrCallback =\n\u002B    std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E \u0026)\u003E;\n\u002B  using ConstRefSharedConstPtrWithInfoCallback =\n\u002B    std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E \u0026, const rclcpp::MessageInfo \u0026)\u003E;\n \n-  SharedPtrCallback shared_ptr_callback_;\n-  SharedPtrWithInfoCallback shared_ptr_with_info_callback_;\n-  ConstSharedPtrCallback const_shared_ptr_callback_;\n-  ConstSharedPtrWithInfoCallback const_shared_ptr_with_info_callback_;\n-  UniquePtrCallback unique_ptr_callback_;\n-  UniquePtrWithInfoCallback unique_ptr_with_info_callback_;\n\u002B  // Deprecated signatures:\n\u002B  using SharedPtrCallback =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003CMessageT\u003E)\u003E;\n\u002B  using SharedPtrWithInfoCallback =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B\n\u002B  using variant_type = std::variant\u003C\n\u002B    ConstRefCallback,\n\u002B    ConstRefWithInfoCallback,\n\u002B    UniquePtrCallback,\n\u002B    UniquePtrWithInfoCallback,\n\u002B    SharedConstPtrCallback,\n\u002B    SharedConstPtrWithInfoCallback,\n\u002B    ConstRefSharedConstPtrCallback,\n\u002B    ConstRefSharedConstPtrWithInfoCallback,\n\u002B    SharedPtrCallback,\n\u002B    SharedPtrWithInfoCallback\n\u002B  \u003E;\n\u002B};\n\u002B\n\u002B}  // namespace detail\n\u002B\n\u002Btemplate\u003C\n\u002B  typename MessageT,\n\u002B  typename AllocatorT = std::allocator\u003Cvoid\u003E\n\u002B\u003E\n\u002Bclass AnySubscriptionCallback\n\u002B{\n\u002Bprivate:\n\u002B  using HelperT = typename rclcpp::detail::AnySubscriptionCallbackHelper\u003CMessageT, AllocatorT\u003E;\n\u002B  using MessageDeleterHelper = rclcpp::detail::MessageDeleterHelper\u003CMessageT, AllocatorT\u003E;\n\u002B\n\u002B  using MessageAllocTraits = typename MessageDeleterHelper::MessageAllocTraits;\n\u002B  using MessageAlloc = typename MessageDeleterHelper::MessageAlloc;\n\u002B  using MessageDeleter = typename MessageDeleterHelper::MessageDeleter;\n\u002B\n\u002B  // See AnySubscriptionCallbackHelper for the types of these.\n\u002B  using ConstRefCallback = typename HelperT::ConstRefCallback;\n\u002B  using ConstRefWithInfoCallback = typename HelperT::ConstRefWithInfoCallback;\n\u002B\n\u002B  using UniquePtrCallback = typename HelperT::UniquePtrCallback;\n\u002B  using UniquePtrWithInfoCallback = typename HelperT::UniquePtrWithInfoCallback;\n\u002B\n\u002B  using SharedConstPtrCallback = typename HelperT::SharedConstPtrCallback;\n\u002B  using SharedConstPtrWithInfoCallback = typename HelperT::SharedConstPtrWithInfoCallback;\n\u002B\n\u002B  using ConstRefSharedConstPtrCallback =\n\u002B    typename HelperT::ConstRefSharedConstPtrCallback;\n\u002B  using ConstRefSharedConstPtrWithInfoCallback =\n\u002B    typename HelperT::ConstRefSharedConstPtrWithInfoCallback;\n\u002B\n\u002B  using SharedPtrCallback = typename HelperT::SharedPtrCallback;\n\u002B  using SharedPtrWithInfoCallback = typename HelperT::SharedPtrWithInfoCallback;\n \n public:\n-  explicit AnySubscriptionCallback(std::shared_ptr\u003CAlloc\u003E allocator)\n-  : shared_ptr_callback_(nullptr), shared_ptr_with_info_callback_(nullptr),\n-    const_shared_ptr_callback_(nullptr), const_shared_ptr_with_info_callback_(nullptr),\n-    unique_ptr_callback_(nullptr), unique_ptr_with_info_callback_(nullptr)\n\u002B  explicit\n\u002B  AnySubscriptionCallback(const AllocatorT \u0026 allocator = AllocatorT())  // NOLINT[runtime/explicit]\n\u002B  {\n\u002B    message_allocator_ = allocator;\n\u002B    allocator::set_allocator_for_deleter(\u0026message_deleter_, \u0026message_allocator_);\n\u002B  }\n\u002B\n\u002B  [[deprecated(\u0022use AnySubscriptionCallback(const AllocatorT \u0026 allocator) instead\u0022)]]\n\u002B  explicit\n\u002B  AnySubscriptionCallback(std::shared_ptr\u003CAllocatorT\u003E allocator)  // NOLINT[runtime/explicit]\n   {\n     if (allocator == nullptr) {\n       throw std::runtime_error(\u0022invalid allocator\u0022);\n     }\n-    message_allocator_ = std::make_shared\u003CMessageAlloc\u003E(*allocator.get());\n-    allocator::set_allocator_for_deleter(\u0026message_deleter_, message_allocator_.get());\n\u002B    message_allocator_ = *allocator;\n\u002B    allocator::set_allocator_for_deleter(\u0026message_deleter_, \u0026message_allocator_);\n   }\n \n   AnySubscriptionCallback(const AnySubscriptionCallback \u0026) = default;\n \n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n-      rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        SharedPtrCallback\n-      \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n\u002B  /// Generic function for setting the callback.\n\u002B  /**\n\u002B   * There are specializations that overload this in order to deprecate some\n\u002B   * callback signatures, and also to fix ambiguity between shared_ptr and\n\u002B   * unique_ptr callback signatures when using them with lambda functions.\n\u002B   */\n\u002B  template\u003Ctypename CallbackT\u003E\n\u002B  AnySubscriptionCallback\u003CMessageT, AllocatorT\u003E\n\u002B  set(CallbackT callback)\n   {\n-    shared_ptr_callback_ = callback;\n-  }\n\u002B    // Use the SubscriptionCallbackTypeHelper to determine the actual type of\n\u002B    // the CallbackT, in terms of std::function\u003C...\u003E, which does not happen\n\u002B    // automatically with lambda functions in cases where the arguments can be\n\u002B    // converted to one another, e.g. shared_ptr and unique_ptr.\n\u002B    using scbth = detail::SubscriptionCallbackTypeHelper\u003CMessageT, CallbackT\u003E;\n \n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n\u002B    // Determine if the given CallbackT is a deprecated signature or not.\n\u002B    constexpr auto is_deprecated =\n       rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        SharedPtrWithInfoCallback\n\u002B      typename scbth::callback_type,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E)\u003E\n       \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n-  {\n-    shared_ptr_with_info_callback_ = callback;\n-  }\n-\n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n\u002B      ||\n       rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        ConstSharedPtrCallback\n-      \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n-  {\n-    const_shared_ptr_callback_ = callback;\n\u002B      typename scbth::callback_type,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E\n\u002B      \u003E::value;\n\u002B\n\u002B    // Use the discovered type to force the type of callback when assigning\n\u002B    // into the variant.\n\u002B    if constexpr (is_deprecated) {\n\u002B      // If deprecated, call sub-routine that is deprecated.\n\u002B      set_deprecated(static_cast\u003Ctypename scbth::callback_type\u003E(callback));\n\u002B    } else {\n\u002B      // Otherwise just assign it.\n\u002B      callback_variant_ = static_cast\u003Ctypename scbth::callback_type\u003E(callback);\n\u002B    }\n\u002B\n\u002B    // Return copy of self for easier testing, normally will be compiled out.\n\u002B    return *this;\n   }\n \n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n-      rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        ConstSharedPtrWithInfoCallback\n-      \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n\u002B  /// Function for shared_ptr to non-const MessageT, which is deprecated.\n\u002B  // TODO(wjwwood): enable this deprecation after Galactic\n\u002B  // [[deprecated(\n\u002B  //   \u0022use \u0027void (std::shared_ptr\u003Cconst MessageT\u003E)\u0027 instead\u0022\n\u002B  // )]]\n\u002B  void\n\u002B  set_deprecated(std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E)\u003E callback)\n\u002B  // set(CallbackT callback)\n   {\n-    const_shared_ptr_with_info_callback_ = callback;\n\u002B    callback_variant_ = callback;\n   }\n \n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n-      rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        UniquePtrCallback\n-      \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n\u002B  /// Function for shared_ptr to non-const MessageT with MessageInfo, which is deprecated.\n\u002B  // TODO(wjwwood): enable this deprecation after Galactic\n\u002B  // [[deprecated(\n\u002B  //   \u0022use \u0027void (std::shared_ptr\u003Cconst MessageT\u003E, const rclcpp::MessageInfo \u0026)\u0027 instead\u0022\n\u002B  // )]]\n\u002B  void\n\u002B  set_deprecated(\n\u002B    std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E callback)\n   {\n-    unique_ptr_callback_ = callback;\n\u002B    callback_variant_ = callback;\n   }\n \n-  template\u003C\n-    typename CallbackT,\n-    typename std::enable_if\u003C\n-      rclcpp::function_traits::same_arguments\u003C\n-        CallbackT,\n-        UniquePtrWithInfoCallback\n-      \u003E::value\n-    \u003E::type * = nullptr\n-  \u003E\n-  void set(CallbackT callback)\n\u002B  std::unique_ptr\u003CMessageT, MessageDeleter\u003E\n\u002B  create_unique_ptr_from_shared_ptr_message(const std::shared_ptr\u003Cconst MessageT\u003E \u0026 message)\n   {\n-    unique_ptr_with_info_callback_ = callback;\n\u002B    auto ptr = MessageAllocTraits::allocate(message_allocator_, 1);\n\u002B    MessageAllocTraits::construct(message_allocator_, ptr, *message);\n\u002B    return std::unique_ptr\u003CMessageT, MessageDeleter\u003E(ptr, message_deleter_);\n   }\n \n-  void dispatch(\n-    std::shared_ptr\u003CMessageT\u003E message, const rclcpp::MessageInfo \u0026 message_info)\n\u002B  void\n\u002B  dispatch(\n\u002B    std::shared_ptr\u003CMessageT\u003E message,\n\u002B    const rclcpp::MessageInfo \u0026 message_info)\n   {\n     TRACEPOINT(callback_start, static_cast\u003Cconst void *\u003E(this), false);\n-    if (shared_ptr_callback_) {\n-      shared_ptr_callback_(message);\n-    } else if (shared_ptr_with_info_callback_) {\n-      shared_ptr_with_info_callback_(message, message_info);\n-    } else if (const_shared_ptr_callback_) {\n-      const_shared_ptr_callback_(message);\n-    } else if (const_shared_ptr_with_info_callback_) {\n-      const_shared_ptr_with_info_callback_(message, message_info);\n-    } else if (unique_ptr_callback_) {\n-      auto ptr = MessageAllocTraits::allocate(*message_allocator_.get(), 1);\n-      MessageAllocTraits::construct(*message_allocator_.get(), ptr, *message);\n-      unique_ptr_callback_(MessageUniquePtr(ptr, message_deleter_));\n-    } else if (unique_ptr_with_info_callback_) {\n-      auto ptr = MessageAllocTraits::allocate(*message_allocator_.get(), 1);\n-      MessageAllocTraits::construct(*message_allocator_.get(), ptr, *message);\n-      unique_ptr_with_info_callback_(MessageUniquePtr(ptr, message_deleter_), message_info);\n-    } else {\n-      throw std::runtime_error(\u0022unexpected message without any callback set\u0022);\n\u002B    // Check if the variant is \u0022unset\u0022, throw if it is.\n\u002B    if (callback_variant_.index() == 0) {\n\u002B      if (std::get\u003C0\u003E(callback_variant_) == nullptr) {\n\u002B        // This can happen if it is default initialized, or if it is assigned nullptr.\n\u002B        throw std::runtime_error(\u0022dispatch called on an unset AnySubscriptionCallback\u0022);\n\u002B      }\n     }\n\u002B    // Dispatch.\n\u002B    std::visit(\n\u002B      [\u0026message, \u0026message_info, this](auto \u0026\u0026 callback) {\n\u002B        using T = std::decay_t\u003Cdecltype(callback)\u003E;\n\u002B\n\u002B        if constexpr (std::is_same_v\u003CT, ConstRefCallback\u003E) {\n\u002B          callback(*message);\n\u002B        } else if constexpr (std::is_same_v\u003CT, ConstRefWithInfoCallback\u003E) {\n\u002B          callback(*message, message_info);\n\u002B        } else if constexpr (std::is_same_v\u003CT, UniquePtrCallback\u003E) {\n\u002B          callback(create_unique_ptr_from_shared_ptr_message(message));\n\u002B        } else if constexpr (std::is_same_v\u003CT, UniquePtrWithInfoCallback\u003E) {\n\u002B          callback(create_unique_ptr_from_shared_ptr_message(message), message_info);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, SharedConstPtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrCallback\u003E)\n\u002B        {\n\u002B          callback(message);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, SharedConstPtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrWithInfoCallback\u003E)\n\u002B        {\n\u002B          callback(message, message_info);\n\u002B        } else {\n\u002B          static_assert(always_false_v\u003CT\u003E, \u0022unhandled callback type\u0022);\n\u002B        }\n\u002B      }, callback_variant_);\n     TRACEPOINT(callback_end, static_cast\u003Cconst void *\u003E(this));\n   }\n \n-  void dispatch_intra_process(\n-    ConstMessageSharedPtr message, const rclcpp::MessageInfo \u0026 message_info)\n\u002B  void\n\u002B  dispatch_intra_process(\n\u002B    std::shared_ptr\u003Cconst MessageT\u003E message,\n\u002B    const rclcpp::MessageInfo \u0026 message_info)\n   {\n     TRACEPOINT(callback_start, static_cast\u003Cconst void *\u003E(this), true);\n-    if (const_shared_ptr_callback_) {\n-      const_shared_ptr_callback_(message);\n-    } else if (const_shared_ptr_with_info_callback_) {\n-      const_shared_ptr_with_info_callback_(message, message_info);\n-    } else {\n-      if (\n-        unique_ptr_callback_ || unique_ptr_with_info_callback_ ||\n-        shared_ptr_callback_ || shared_ptr_with_info_callback_)\n-      {\n-        throw std::runtime_error(\n-                \u0022unexpected dispatch_intra_process const shared \u0022\n-                \u0022message call with no const shared_ptr callback\u0022);\n-      } else {\n-        throw std::runtime_error(\u0022unexpected message without any callback set\u0022);\n\u002B    // Check if the variant is \u0022unset\u0022, throw if it is.\n\u002B    if (callback_variant_.index() == 0) {\n\u002B      if (std::get\u003C0\u003E(callback_variant_) == nullptr) {\n\u002B        // This can happen if it is default initialized, or if it is assigned nullptr.\n\u002B        throw std::runtime_error(\u0022dispatch called on an unset AnySubscriptionCallback\u0022);\n       }\n     }\n\u002B    // Dispatch.\n\u002B    std::visit(\n\u002B      [\u0026message, \u0026message_info, this](auto \u0026\u0026 callback) {\n\u002B        using T = std::decay_t\u003Cdecltype(callback)\u003E;\n\u002B\n\u002B        if constexpr (std::is_same_v\u003CT, ConstRefCallback\u003E) {\n\u002B          callback(*message);\n\u002B        } else if constexpr (std::is_same_v\u003CT, ConstRefWithInfoCallback\u003E) {\n\u002B          callback(*message, message_info);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, UniquePtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrCallback\u003E)\n\u002B        {\n\u002B          callback(create_unique_ptr_from_shared_ptr_message(message));\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, UniquePtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrWithInfoCallback\u003E)\n\u002B        {\n\u002B          callback(create_unique_ptr_from_shared_ptr_message(message), message_info);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, SharedConstPtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrCallback\u003E)\n\u002B        {\n\u002B          callback(message);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, SharedConstPtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrWithInfoCallback\u003E)\n\u002B        {\n\u002B          callback(message, message_info);\n\u002B        } else {\n\u002B          static_assert(always_false_v\u003CT\u003E, \u0022unhandled callback type\u0022);\n\u002B        }\n\u002B      }, callback_variant_);\n     TRACEPOINT(callback_end, static_cast\u003Cconst void *\u003E(this));\n   }\n \n-  void dispatch_intra_process(\n-    MessageUniquePtr message, const rclcpp::MessageInfo \u0026 message_info)\n\u002B  void\n\u002B  dispatch_intra_process(\n\u002B    std::unique_ptr\u003CMessageT, MessageDeleter\u003E message,\n\u002B    const rclcpp::MessageInfo \u0026 message_info)\n   {\n     TRACEPOINT(callback_start, static_cast\u003Cconst void *\u003E(this), true);\n-    if (shared_ptr_callback_) {\n-      typename std::shared_ptr\u003CMessageT\u003E shared_message = std::move(message);\n-      shared_ptr_callback_(shared_message);\n-    } else if (shared_ptr_with_info_callback_) {\n-      typename std::shared_ptr\u003CMessageT\u003E shared_message = std::move(message);\n-      shared_ptr_with_info_callback_(shared_message, message_info);\n-    } else if (unique_ptr_callback_) {\n-      unique_ptr_callback_(std::move(message));\n-    } else if (unique_ptr_with_info_callback_) {\n-      unique_ptr_with_info_callback_(std::move(message), message_info);\n-    } else if (const_shared_ptr_callback_ || const_shared_ptr_with_info_callback_) {\n-      throw std::runtime_error(\n-              \u0022unexpected dispatch_intra_process unique message call\u0022\n-              \u0022 with const shared_ptr callback\u0022);\n-    } else {\n-      throw std::runtime_error(\u0022unexpected message without any callback set\u0022);\n\u002B    // Check if the variant is \u0022unset\u0022, throw if it is.\n\u002B    if (callback_variant_.index() == 0) {\n\u002B      if (std::get\u003C0\u003E(callback_variant_) == nullptr) {\n\u002B        // This can happen if it is default initialized, or if it is assigned nullptr.\n\u002B        throw std::runtime_error(\u0022dispatch called on an unset AnySubscriptionCallback\u0022);\n\u002B      }\n     }\n\u002B    // Dispatch.\n\u002B    std::visit(\n\u002B      [\u0026message, \u0026message_info](auto \u0026\u0026 callback) {\n\u002B        using T = std::decay_t\u003Cdecltype(callback)\u003E;\n\u002B\n\u002B        if constexpr (std::is_same_v\u003CT, ConstRefCallback\u003E) {\n\u002B          callback(*message);\n\u002B        } else if constexpr (std::is_same_v\u003CT, ConstRefWithInfoCallback\u003E) {\n\u002B          callback(*message, message_info);\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, UniquePtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedConstPtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrCallback\u003E)\n\u002B        {\n\u002B          callback(std::move(message));\n\u002B        } else if constexpr (  // NOLINT[readability/braces]\n\u002B          std::is_same_v\u003CT, UniquePtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedConstPtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, ConstRefSharedConstPtrWithInfoCallback\u003E||\n\u002B          std::is_same_v\u003CT, SharedPtrWithInfoCallback\u003E)\n\u002B        {\n\u002B          callback(std::move(message), message_info);\n\u002B        } else {\n\u002B          static_assert(always_false_v\u003CT\u003E, \u0022unhandled callback type\u0022);\n\u002B        }\n\u002B      }, callback_variant_);\n     TRACEPOINT(callback_end, static_cast\u003Cconst void *\u003E(this));\n   }\n \n-  bool use_take_shared_method() const\n\u002B  constexpr\n\u002B  bool\n\u002B  use_take_shared_method() const\n   {\n-    return const_shared_ptr_callback_ || const_shared_ptr_with_info_callback_;\n\u002B    return\n\u002B      std::holds_alternative\u003CSharedConstPtrCallback\u003E(callback_variant_) ||\n\u002B      std::holds_alternative\u003CSharedConstPtrWithInfoCallback\u003E(callback_variant_) ||\n\u002B      std::holds_alternative\u003CConstRefSharedConstPtrCallback\u003E(callback_variant_) ||\n\u002B      std::holds_alternative\u003CConstRefSharedConstPtrWithInfoCallback\u003E(callback_variant_);\n   }\n \n-  void register_callback_for_tracing()\n\u002B  void\n\u002B  register_callback_for_tracing()\n   {\n #ifndef TRACETOOLS_DISABLED\n-    if (shared_ptr_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast\u003Cconst void *\u003E(this),\n-        tracetools::get_symbol(shared_ptr_callback_));\n-    } else if (shared_ptr_with_info_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast\u003Cconst void *\u003E(this),\n-        tracetools::get_symbol(shared_ptr_with_info_callback_));\n-    } else if (unique_ptr_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast\u003Cconst void *\u003E(this),\n-        tracetools::get_symbol(unique_ptr_callback_));\n-    } else if (unique_ptr_with_info_callback_) {\n-      TRACEPOINT(\n-        rclcpp_callback_register,\n-        static_cast\u003Cconst void *\u003E(this),\n-        tracetools::get_symbol(unique_ptr_with_info_callback_));\n-    }\n\u002B    std::visit(\n\u002B      [this](auto \u0026\u0026 callback) {\n\u002B        TRACEPOINT(\n\u002B          rclcpp_callback_register,\n\u002B          static_cast\u003Cconst void *\u003E(this),\n\u002B          tracetools::get_symbol(callback));\n\u002B      }, callback_variant_);\n #endif  // TRACETOOLS_DISABLED\n   }\n \n\u002B  typename HelperT::variant_type \u0026\n\u002B  get_variant()\n\u002B  {\n\u002B    return callback_variant_;\n\u002B  }\n\u002B\n\u002B  const typename HelperT::variant_type \u0026\n\u002B  get_variant() const\n\u002B  {\n\u002B    return callback_variant_;\n\u002B  }\n\u002B\n private:\n-  std::shared_ptr\u003CMessageAlloc\u003E message_allocator_;\n\u002B  // TODO(wjwwood): switch to inheriting from std::variant (i.e. HelperT::variant_type) once\n\u002B  // inheriting from std::variant is realistic (maybe C\u002B\u002B23?), see:\n\u002B  //   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2162r0.html\n\u002B  // For now, compose the variant into this class as a private attribute.\n\u002B  typename HelperT::variant_type callback_variant_;\n\u002B\n\u002B  MessageAlloc message_allocator_;\n   MessageDeleter message_deleter_;\n };\n \ndiff --git rclcpp/include/rclcpp/detail/subscription_callback_type_helper.hpp rclcpp/include/rclcpp/detail/subscription_callback_type_helper.hpp\nnew file mode 100644\nindex 00000000..ec24038d\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/detail/subscription_callback_type_helper.hpp\n@@ -0,0 \u002B1,164 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_\n\u002B#define RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Ctype_traits\u003E\n\u002B\n\u002B#include \u0022rclcpp/function_traits.hpp\u0022\n\u002B#include \u0022rclcpp/message_info.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace detail\n\u002B{\n\u002B\n\u002B/// Template metaprogramming helper used to resolve the callback argument into a std::function.\n\u002B/**\n\u002B * Sometimes the CallbackT is a std::function already, but it could also be a\n\u002B * function pointer, lambda, bind, or some variant of those.\n\u002B * In some cases, like a lambda where the arguments can be converted between one\n\u002B * another, e.g. std::function\u003Cvoid (shared_ptr\u003C...\u003E)\u003E and\n\u002B * std::function\u003Cvoid (unique_ptr\u003C...\u003E)\u003E, you need to make that not ambiguous\n\u002B * by checking the arguments independently using function traits rather than\n\u002B * rely on overloading the two std::function types.\n\u002B *\n\u002B * This issue, with the lambda\u0027s, can be demonstrated with this minimal program:\n\u002B *\n\u002B *   #include \u003Cfunctional\u003E\n\u002B *   #include \u003Cmemory\u003E\n\u002B *\n\u002B *   void f(std::function\u003Cvoid (std::shared_ptr\u003Cint\u003E)\u003E) {}\n\u002B *   void f(std::function\u003Cvoid (std::unique_ptr\u003Cint\u003E)\u003E) {}\n\u002B *\n\u002B *   int main() {\n\u002B *     // Fails to compile with an \u0022ambiguous call\u0022 error.\n\u002B *     f([](std::shared_ptr\u003Cint\u003E){});\n\u002B *\n\u002B *     // Works.\n\u002B *     std::function\u003Cvoid (std::shared_ptr\u003Cint\u003E)\u003E cb = [](std::shared_ptr\u003Cint\u003E){};\n\u002B *     f(cb);\n\u002B *   }\n\u002B *\n\u002B * If this program ever starts working in a future version of C\u002B\u002B, this class\n\u002B * may become redundant.\n\u002B *\n\u002B * This helper works by using SFINAE with rclcpp::function_traits::same_arguments\u003C\u003E\n\u002B * to narrow down the exact std::function\u003C\u003E type for the given CallbackT.\n\u002B */\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT, typename Enable = void\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\n\u002B{\n\u002B  using callback_type = typename rclcpp::function_traits::as_std_function\u003CCallbackT\u003E::type;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003Cconst MessageT\u003E)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type = std::function\u003Cvoid (std::shared_ptr\u003Cconst MessageT\u003E)\u003E;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003Cconst MessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003Cconst MessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(const std::shared_ptr\u003Cconst MessageT\u003E \u0026)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type = std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E \u0026)\u003E;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(const std::shared_ptr\u003Cconst MessageT\u003E \u0026, const rclcpp::MessageInfo \u0026)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type =\n\u002B    std::function\u003Cvoid (const std::shared_ptr\u003Cconst MessageT\u003E \u0026, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type = std::function\u003Cvoid (std::shared_ptr\u003CMessageT\u003E)\u003E;\n\u002B};\n\u002B\n\u002Btemplate\u003Ctypename MessageT, typename CallbackT\u003E\n\u002Bstruct SubscriptionCallbackTypeHelper\u003C\n\u002B  MessageT,\n\u002B  CallbackT,\n\u002B  typename std::enable_if_t\u003C\n\u002B    rclcpp::function_traits::same_arguments\u003C\n\u002B      CallbackT,\n\u002B      std::function\u003Cvoid(std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E\n\u002B    \u003E::value\n\u002B  \u003E\n\u002B\u003E\n\u002B{\n\u002B  using callback_type =\n\u002B    std::function\u003Cvoid (std::shared_ptr\u003CMessageT\u003E, const rclcpp::MessageInfo \u0026)\u003E;\n\u002B};\n\u002B\n\u002B}  // namespace detail\n\u002B}  // namespace rclcpp\n\u002B\n\u002B#endif  // RCLCPP__DETAIL__SUBSCRIPTION_CALLBACK_TYPE_HELPER_HPP_\ndiff --git rclcpp/include/rclcpp/function_traits.hpp rclcpp/include/rclcpp/function_traits.hpp\nindex f5c56b04..40044768 100644\n--- rclcpp/include/rclcpp/function_traits.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/function_traits.hpp\n@@ -162,6 \u002B162,32 @@ struct same_arguments : std::is_same\u003C\n \u003E\n {};\n \n\u002Bnamespace detail\n\u002B{\n\u002B\n\u002Btemplate\u003Ctypename ReturnTypeT, typename ... Args\u003E\n\u002Bstruct as_std_function_helper;\n\u002B\n\u002Btemplate\u003Ctypename ReturnTypeT, typename ... Args\u003E\n\u002Bstruct as_std_function_helper\u003CReturnTypeT, std::tuple\u003CArgs ...\u003E\u003E\n\u002B{\n\u002B  using type = std::function\u003CReturnTypeT(Args ...)\u003E;\n\u002B};\n\u002B\n\u002B}  // namespace detail\n\u002B\n\u002Btemplate\u003C\n\u002B  typename FunctorT,\n\u002B  typename FunctionTraits = function_traits\u003CFunctorT\u003E\n\u002B\u003E\n\u002Bstruct as_std_function\n\u002B{\n\u002B  using type = typename detail::as_std_function_helper\u003C\n\u002B    typename FunctionTraits::return_type,\n\u002B    typename FunctionTraits::arguments\n\u002B    \u003E::type;\n\u002B};\n\u002B\n }  // namespace function_traits\n \n }  // namespace rclcpp\ndiff --git rclcpp/include/rclcpp/parameter_event_handler.hpp rclcpp/include/rclcpp/parameter_event_handler.hpp\nindex 9a2e65b1..c7b781f0 100644\n--- rclcpp/include/rclcpp/parameter_event_handler.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_event_handler.hpp\n@@ -52,7 \u002B52,7 @@ struct ParameterEventCallbackHandle\n   RCLCPP_SMART_PTR_DEFINITIONS(ParameterEventCallbackHandle)\n \n   using ParameterEventCallbackType =\n-    std::function\u003Cvoid (const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026)\u003E;\n\u002B    std::function\u003Cvoid (const rcl_interfaces::msg::ParameterEvent \u0026)\u003E;\n \n   ParameterEventCallbackType callback;\n };\n@@ -115,16 \u002B115,16 @@ struct ParameterEventCallbackHandle\n  * For example:\n  *\n  *   auto cb3 =\n- *     [fqn, remote_param_name, \u0026node](const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026 event) {\n\u002B *     [fqn, remote_param_name, \u0026node](const rcl_interfaces::msg::ParameterEvent \u0026 event) {\n  *       // Look for any updates to parameters in \u0022/a_namespace\u0022 as well as any parameter changes\n  *       // to our own node (\u0022this_node\u0022)\n  *       std::regex re(\u0022(/a_namespace/.*)|(/this_node)\u0022);\n- *       if (regex_match(event-\u003Enode, re)) {\n\u002B *       if (regex_match(event.node, re)) {\n  *         // Now that we know the event matches the regular expression we scanned for, we can\n  *         // use \u0027get_parameter_from_event\u0027 to get a specific parameter name that we\u0027re looking for\n  *         rclcpp::Parameter p;\n  *         if (rclcpp::ParameterEventsSubscriber::get_parameter_from_event(\n- *             *event, p, remote_param_name, fqn))\n\u002B *             event, p, remote_param_name, fqn))\n  *         {\n  *           RCLCPP_INFO(\n  *             node-\u003Eget_logger(),\n@@ -136,7 \u002B136,7 @@ struct ParameterEventCallbackHandle\n  *\n  *         // You can also use \u0027get_parameter*s*_from_event\u0027 to enumerate all changes that came\n  *         // in on this event\n- *         auto params = rclcpp::ParameterEventsSubscriber::get_parameters_from_event(*event);\n\u002B *         auto params = rclcpp::ParameterEventsSubscriber::get_parameters_from_event(event);\n  *         for (auto \u0026 p : params) {\n  *           RCLCPP_INFO(\n  *             node-\u003Eget_logger(),\n@@ -288,7 \u002B288,7 @@ protected:\n   /// Callback for parameter events subscriptions.\n   RCLCPP_PUBLIC\n   void\n-  event_callback(const rcl_interfaces::msg::ParameterEvent::SharedPtr event);\n\u002B  event_callback(const rcl_interfaces::msg::ParameterEvent \u0026 event);\n \n   // Utility function for resolving node path.\n   std::string resolve_path(const std::string \u0026 path);\ndiff --git rclcpp/include/rclcpp/parameter_events_filter.hpp rclcpp/include/rclcpp/parameter_events_filter.hpp\nindex d09d2877..3aa70d8a 100644\n--- rclcpp/include/rclcpp/parameter_events_filter.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_events_filter.hpp\n@@ -37,7 \u002B37,7 @@ public:\n   RCLCPP_SMART_PTR_DEFINITIONS(ParameterEventsFilter)\n   enum class EventType {NEW, DELETED, CHANGED};  ///\u003C An enum for the type of event.\n   /// Used for the listed results\n-  using EventPair = std::pair\u003CEventType, rcl_interfaces::msg::Parameter *\u003E;\n\u002B  using EventPair = std::pair\u003CEventType, const rcl_interfaces::msg::Parameter *\u003E;\n \n   /// Construct a filtered view of a parameter event.\n   /**\n@@ -60,7 \u002B60,7 @@ public:\n    */\n   RCLCPP_PUBLIC\n   ParameterEventsFilter(\n-    rcl_interfaces::msg::ParameterEvent::SharedPtr event,\n\u002B    std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event,\n     const std::vector\u003Cstd::string\u003E \u0026 names,\n     const std::vector\u003CEventType\u003E \u0026 types);\n \n@@ -74,7 \u002B74,7 @@ public:\n private:\n   // access only allowed via const accessor.\n   std::vector\u003CEventPair\u003E result_;  ///\u003C Storage of the resultant vector\n-  rcl_interfaces::msg::ParameterEvent::SharedPtr event_;  ///\u003C Keep event in scope\n\u002B  std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event_;  ///\u003C Keep event in scope\n };\n \n }  // namespace rclcpp\ndiff --git rclcpp/include/rclcpp/subscription_factory.hpp rclcpp/include/rclcpp/subscription_factory.hpp\nindex 694be60a..7708f27d 100644\n--- rclcpp/include/rclcpp/subscription_factory.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription_factory.hpp\n@@ -93,7 \u002B93,7 @@ create_subscription_factory(\n   auto allocator = options.get_allocator();\n \n   using rclcpp::AnySubscriptionCallback;\n-  AnySubscriptionCallback\u003CCallbackMessageT, AllocatorT\u003E any_subscription_callback(allocator);\n\u002B  AnySubscriptionCallback\u003CCallbackMessageT, AllocatorT\u003E any_subscription_callback(*allocator);\n   any_subscription_callback.set(std::forward\u003CCallbackT\u003E(callback));\n \n   SubscriptionFactory factory {\ndiff --git rclcpp/include/rclcpp/subscription_traits.hpp rclcpp/include/rclcpp/subscription_traits.hpp\nindex 8eacd3a1..34f2cc92 100644\n--- rclcpp/include/rclcpp/subscription_traits.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription_traits.hpp\n@@ -64,7 \u002B64,7 @@ struct is_serialized_callback\n template\u003Ctypename MessageT\u003E\n struct extract_message_type\n {\n-  using type = typename std::remove_cv\u003CMessageT\u003E::type;\n\u002B  using type = typename std::remove_cv_t\u003Cstd::remove_reference_t\u003CMessageT\u003E\u003E;\n };\n \n template\u003Ctypename MessageT\u003E\ndiff --git rclcpp/include/rclcpp/time_source.hpp rclcpp/include/rclcpp/time_source.hpp\nindex 6f528057..b4eb2aff 100644\n--- rclcpp/include/rclcpp/time_source.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/time_source.hpp\n@@ -156,7 \u002B156,7 @@ private:\n   std::promise\u003Cvoid\u003E cancel_clock_executor_promise_;\n \n   // The clock callback itself\n-  void clock_cb(const rosgraph_msgs::msg::Clock::SharedPtr msg);\n\u002B  void clock_cb(std::shared_ptr\u003Cconst rosgraph_msgs::msg::Clock\u003E msg);\n \n   // Create the subscription for the clock topic\n   void create_clock_sub();\n@@ -170,7 \u002B170,7 @@ private:\n   std::shared_ptr\u003CParamSubscriptionT\u003E parameter_subscription_;\n \n   // Callback for parameter updates\n-  void on_parameter_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event);\n\u002B  void on_parameter_event(std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event);\n \n   // An enum to hold the parameter state\n   enum UseSimTimeParameterState {UNSET, SET_TRUE, SET_FALSE};\n@@ -191,7 \u002B191,7 @@ private:\n   // This is needed when new clocks are added.\n   bool ros_time_active_{false};\n   // Last set message to be passed to newly registered clocks\n-  rosgraph_msgs::msg::Clock::SharedPtr last_msg_set_;\n\u002B  std::shared_ptr\u003Cconst rosgraph_msgs::msg::Clock\u003E last_msg_set_;\n \n   // A lock to protect iterating the associated_clocks_ field.\n   std::mutex clock_list_lock_;\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\nindex c6aa2af6..16aa9c49 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n@@ -954,22 \u002B954,6 @@ NodeParameters::list_parameters(const std::vector\u003Cstd::string\u003E \u0026 prefixes, uint6\n   return result;\n }\n \n-struct HandleCompare\n-  : public std::unary_function\u003COnSetParametersCallbackHandle::WeakPtr, bool\u003E\n-{\n-  explicit HandleCompare(const OnSetParametersCallbackHandle * const base)\n-  : base_(base) {}\n-  bool operator()(const OnSetParametersCallbackHandle::WeakPtr \u0026 handle)\n-  {\n-    auto shared_handle = handle.lock();\n-    if (base_ == shared_handle.get()) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  const OnSetParametersCallbackHandle * const base_;\n-};\n-\n void\n NodeParameters::remove_on_set_parameters_callback(\n   const OnSetParametersCallbackHandle * const handle)\n@@ -980,7 \u002B964,9 @@ NodeParameters::remove_on_set_parameters_callback(\n   auto it = std::find_if(\n     on_parameters_set_callback_container_.begin(),\n     on_parameters_set_callback_container_.end(),\n-    HandleCompare(handle));\n\u002B    [handle](const auto \u0026 weak_handle) {\n\u002B      return handle == weak_handle.lock().get();\n\u002B    });\n   if (it != on_parameters_set_callback_container_.end()) {\n     on_parameters_set_callback_container_.erase(it);\n   } else {\ndiff --git rclcpp/src/rclcpp/parameter_event_handler.cpp rclcpp/src/rclcpp/parameter_event_handler.cpp\nindex 9fd59948..232a32f8 100644\n--- rclcpp/src/rclcpp/parameter_event_handler.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_event_handler.cpp\n@@ -37,23 \u002B37,6 @@ ParameterEventHandler::add_parameter_event_callback(\n   return handle;\n }\n \n-template\u003Ctypename CallbackHandleT\u003E\n-struct HandleCompare\n-  : public std::unary_function\u003Ctypename CallbackHandleT::WeakPtr, bool\u003E\n-{\n-  explicit HandleCompare(const CallbackHandleT * const base)\n-  : base_(base) {}\n-  bool operator()(const typename CallbackHandleT::WeakPtr \u0026 handle)\n-  {\n-    auto shared_handle = handle.lock();\n-    if (base_ == shared_handle.get()) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  const CallbackHandleT * const base_;\n-};\n-\n void\n ParameterEventHandler::remove_parameter_event_callback(\n   ParameterEventCallbackHandle::SharedPtr callback_handle)\n@@ -62,7 \u002B45,9 @@ ParameterEventHandler::remove_parameter_event_callback(\n   auto it = std::find_if(\n     event_callbacks_.begin(),\n     event_callbacks_.end(),\n-    HandleCompare\u003CParameterEventCallbackHandle\u003E(callback_handle.get()));\n\u002B    [callback_handle](const auto \u0026 weak_handle) {\n\u002B      return callback_handle.get() == weak_handle.lock().get();\n\u002B    });\n   if (it != event_callbacks_.end()) {\n     event_callbacks_.erase(it);\n   } else {\n@@ -99,7 \u002B84,9 @@ ParameterEventHandler::remove_parameter_callback(\n   auto it = std::find_if(\n     container.begin(),\n     container.end(),\n-    HandleCompare\u003CParameterCallbackHandle\u003E(handle));\n\u002B    [handle](const auto \u0026 weak_handle) {\n\u002B      return handle == weak_handle.lock().get();\n\u002B    });\n   if (it != container.end()) {\n     container.erase(it);\n     if (container.empty()) {\n@@ -171,14 \u002B158,13 @@ ParameterEventHandler::get_parameters_from_event(\n }\n \n void\n-ParameterEventHandler::event_callback(\n-  const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n\u002BParameterEventHandler::event_callback(const rcl_interfaces::msg::ParameterEvent \u0026 event)\n {\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(mutex_);\n \n   for (auto it = parameter_callbacks_.begin(); it != parameter_callbacks_.end(); \u002B\u002Bit) {\n     rclcpp::Parameter p;\n-    if (get_parameter_from_event(*event, p, it-\u003Efirst.first, it-\u003Efirst.second)) {\n\u002B    if (get_parameter_from_event(event, p, it-\u003Efirst.first, it-\u003Efirst.second)) {\n       for (auto cb = it-\u003Esecond.begin(); cb != it-\u003Esecond.end(); \u002B\u002Bcb) {\n         auto shared_handle = cb-\u003Elock();\n         if (nullptr != shared_handle) {\ndiff --git rclcpp/src/rclcpp/parameter_events_filter.cpp rclcpp/src/rclcpp/parameter_events_filter.cpp\nindex 36ef708c..be9882c8 100644\n--- rclcpp/src/rclcpp/parameter_events_filter.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_events_filter.cpp\n@@ -14,6 \u002B14,7 @@\n \n #include \u0022rclcpp/parameter_events_filter.hpp\u0022\n \n\u002B#include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n@@ -22,7 \u002B23,7 @@ using EventType = rclcpp::ParameterEventsFilter::EventType;\n using EventPair = rclcpp::ParameterEventsFilter::EventPair;\n \n ParameterEventsFilter::ParameterEventsFilter(\n-  rcl_interfaces::msg::ParameterEvent::SharedPtr event,\n\u002B  std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event,\n   const std::vector\u003Cstd::string\u003E \u0026 names,\n   const std::vector\u003CEventType\u003E \u0026 types)\n : event_(event)\ndiff --git rclcpp/src/rclcpp/time_source.cpp rclcpp/src/rclcpp/time_source.cpp\nindex 24f48b7c..595520da 100644\n--- rclcpp/src/rclcpp/time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time_source.cpp\n@@ -216,7 \u002B216,7 @@ void TimeSource::set_clock(\n   }\n }\n \n-void TimeSource::clock_cb(const rosgraph_msgs::msg::Clock::SharedPtr msg)\n\u002Bvoid TimeSource::clock_cb(std::shared_ptr\u003Cconst rosgraph_msgs::msg::Clock\u003E msg)\n {\n   if (!this-\u003Eros_time_active_ \u0026\u0026 SET_TRUE == this-\u003Eparameter_state_) {\n     enable_ros_time();\n@@ -294,7 \u002B294,8 @@ void TimeSource::destroy_clock_sub()\n   clock_subscription_.reset();\n }\n \n-void TimeSource::on_parameter_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n\u002Bvoid TimeSource::on_parameter_event(\n\u002B  std::shared_ptr\u003Cconst rcl_interfaces::msg::ParameterEvent\u003E event)\n {\n   // Filter out events on \u0027use_sim_time\u0027 parameter instances in other nodes.\n   if (event-\u003Enode != node_base_-\u003Eget_fully_qualified_name()) {\ndiff --git rclcpp/test/benchmark/benchmark_executor.cpp rclcpp/test/benchmark/benchmark_executor.cpp\nindex 27e6d2ff..c1fb3cf5 100644\n--- rclcpp/test/benchmark/benchmark_executor.cpp\n\u002B\u002B\u002B rclcpp/test/benchmark/benchmark_executor.cpp\n@@ -42,7 \u002B42,7 @@ public:\n         nodes[i]-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\n           \u0022/empty_msgs_\u0022 \u002B std::to_string(i), rclcpp::QoS(10)));\n \n-      auto callback = [this](test_msgs::msg::Empty::SharedPtr) {this-\u003Ecallback_count\u002B\u002B;};\n\u002B      auto callback = [this](test_msgs::msg::Empty::ConstSharedPtr) {this-\u003Ecallback_count\u002B\u002B;};\n       subscriptions.push_back(\n         nodes[i]-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n           \u0022/empty_msgs_\u0022 \u002B std::to_string(i), rclcpp::QoS(10), std::move(callback)));\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex ad34273f..970cd3bd 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -62,7 \u002B62,7 @@ public:\n \n     const std::string topic_name = std::string(\u0022topic_\u0022) \u002B test_name.str();\n     publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(topic_name, rclcpp::QoS(10));\n-    auto callback = [this](test_msgs::msg::Empty::SharedPtr) {this-\u003Ecallback_count\u002B\u002B;};\n\u002B    auto callback = [this](test_msgs::msg::Empty::ConstSharedPtr) {this-\u003Ecallback_count\u002B\u002B;};\n     subscription =\n       node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n       topic_name, rclcpp::QoS(10), std::move(callback));\ndiff --git rclcpp/test/rclcpp/executors/test_static_executor_entities_collector.cpp rclcpp/test/rclcpp/executors/test_static_executor_entities_collector.cpp\nindex 5b20c6b2..fba322f9 100644\n--- rclcpp/test/rclcpp/executors/test_static_executor_entities_collector.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_static_executor_entities_collector.cpp\n@@ -255,7 \u002B255,7 @@ TEST_F(TestStaticExecutorEntitiesCollector, add_remove_node_with_entities) {\n   // Create 1 of each entity type\n   auto subscription =\n     node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, rclcpp::QoS(10), [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, rclcpp::QoS(10), [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   auto timer =\n     node-\u003Ecreate_wall_timer(std::chrono::seconds(60), []() {});\n   auto service =\n@@ -455,7 \u002B455,7 @@ TEST_F(TestStaticExecutorEntitiesCollector, refresh_wait_set_add_handles_to_wait\n   // Create 1 of each entity type\n   auto subscription =\n     node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, rclcpp::QoS(10), [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, rclcpp::QoS(10), [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   auto timer =\n     node-\u003Ecreate_wall_timer(std::chrono::seconds(60), []() {});\n   auto service =\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp\nindex 08717164..6690b88b 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp\n@@ -335,7 \u002B335,7 @@ TEST_F(TestNodeGraph, get_info_by_topic)\n {\n   const rclcpp::QoS publisher_qos(1);\n   auto publisher = node()-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, publisher_qos);\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n \n   const rclcpp::QoS subscriber_qos(10);\n   auto subscription =\ndiff --git rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\nindex b0951c92..0b4286dc 100644\n--- rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/strategies/test_allocator_memory_strategy.cpp\n@@ -125,7 \u002B125,7 @@ protected:\n \n   std::shared_ptr\u003Crclcpp::Node\u003E create_node_with_subscription(const std::string \u0026 name)\n   {\n-    auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B    auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n     const rclcpp::QoS qos(10);\n     auto node_with_subscription = create_node_with_disabled_callback_groups(name);\n \n@@ -778,7 \u002B778,7 @@ TEST_F(TestAllocatorMemoryStrategy, get_next_subscription_out_of_scope) {\n \n     subscription_options.callback_group = callback_group;\n \n-    auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B    auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n     const rclcpp::QoS qos(10);\n \n     auto subscription = node-\u003Ecreate_subscription\u003C\ndiff --git rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\nindex 25bd2aba..fa636b71 100644\n--- rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\n@@ -96,7 \u002B96,7 @@ TYPED_TEST(TestAddCallbackGroupsToExecutor, add_callback_groups) {\n \n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   rclcpp::CallbackGroup::SharedPtr cb_grp2 = node-\u003Ecreate_callback_group(\n     rclcpp::CallbackGroupType::MutuallyExclusive);\n   options.callback_group = cb_grp2;\n@@ -139,7 \u002B139,7 @@ TYPED_TEST(TestAddCallbackGroupsToExecutor, remove_callback_groups) {\n   executor.add_callback_group(cb_grp, node-\u003Eget_node_base_interface());\n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   rclcpp::CallbackGroup::SharedPtr cb_grp2 = node-\u003Ecreate_callback_group(\n     rclcpp::CallbackGroupType::MutuallyExclusive);\n   options.callback_group = cb_grp2;\n@@ -222,7 \u002B222,7 @@ TYPED_TEST(TestAddCallbackGroupsToExecutor, add_unallowable_callback_groups)\n \n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   rclcpp::CallbackGroup::SharedPtr cb_grp2 = node-\u003Ecreate_callback_group(\n     rclcpp::CallbackGroupType::MutuallyExclusive, false);\n   options.callback_group = cb_grp2;\n@@ -256,7 \u002B256,7 @@ TYPED_TEST(TestAddCallbackGroupsToExecutor, one_node_many_callback_groups_many_e\n   timer_executor.add_callback_group(cb_grp, node-\u003Eget_node_base_interface());\n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   rclcpp::CallbackGroup::SharedPtr cb_grp2 = node-\u003Ecreate_callback_group(\n     rclcpp::CallbackGroupType::MutuallyExclusive, false);\n   options.callback_group = cb_grp2;\ndiff --git rclcpp/test/rclcpp/test_any_subscription_callback.cpp rclcpp/test/rclcpp/test_any_subscription_callback.cpp\nindex 5ed90846..b8d7fd9b 100644\n--- rclcpp/test/rclcpp/test_any_subscription_callback.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_any_subscription_callback.cpp\n@@ -16,6 \u002B16,7 @@\n \n #include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n #include \u0022rclcpp/any_subscription_callback.hpp\u0022\n@@ -25,42 \u002B26,57 @@\n class TestAnySubscriptionCallback : public ::testing::Test\n {\n public:\n-  TestAnySubscriptionCallback()\n-  : allocator_(std::make_shared\u003Cstd::allocator\u003Cvoid\u003E\u003E()),\n-    any_subscription_callback_(allocator_) {}\n-  void SetUp()\n\u002B  TestAnySubscriptionCallback() {}\n\u002B\n\u002B  static\n\u002B  std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E\n\u002B  get_unique_ptr_msg()\n   {\n-    msg_shared_ptr_ = std::make_shared\u003Ctest_msgs::msg::Empty\u003E();\n-    msg_const_shared_ptr_ = std::make_shared\u003Cconst test_msgs::msg::Empty\u003E();\n-    msg_unique_ptr_ = std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n\u002B    return std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n   }\n \n protected:\n-  std::shared_ptr\u003Cstd::allocator\u003Cvoid\u003E\u003E allocator_;\n-  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty, std::allocator\u003Cvoid\u003E\u003E\n-  any_subscription_callback_;\n-\n-  std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E msg_shared_ptr_;\n-  std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E msg_const_shared_ptr_;\n-  std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E msg_unique_ptr_;\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E any_subscription_callback_;\n\u002B  std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E msg_shared_ptr_{std::make_shared\u003Ctest_msgs::msg::Empty\u003E()};\n   rclcpp::MessageInfo message_info_;\n };\n \n void construct_with_null_allocator()\n {\n\u002B// suppress deprecated function warning\n\u002B#if !defined(_WIN32)\n\u002B# pragma GCC diagnostic push\n\u002B# pragma GCC diagnostic ignored \u0022-Wdeprecated-declarations\u0022\n\u002B#else  // !defined(_WIN32)\n\u002B# pragma warning(push)\n\u002B# pragma warning(disable: 4996)\n\u002B#endif\n\u002B\n   // We need to wrap this in a function because \u0060EXPECT_THROW\u0060 is a macro, and thinks\n   // that the comma in here splits macro arguments, not the template arguments.\n-  rclcpp::AnySubscriptionCallback\u003C\n-    test_msgs::msg::Empty, std::allocator\u003Cvoid\u003E\u003E any_subscription_callback_(nullptr);\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E any_subscription_callback(nullptr);\n\u002B\n\u002B// remove warning suppression\n\u002B#if !defined(_WIN32)\n\u002B# pragma GCC diagnostic pop\n\u002B#else  // !defined(_WIN32)\n\u002B# pragma warning(pop)\n\u002B#endif\n }\n \n-TEST(AnySubscription, null_allocator) {\n\u002BTEST(AnySubscriptionCallback, null_allocator) {\n   EXPECT_THROW(\n     construct_with_null_allocator(),\n     std::runtime_error);\n }\n \n TEST_F(TestAnySubscriptionCallback, construct_destruct) {\n\u002B  // Default constructor.\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E asc1;\n\u002B\n\u002B  // Constructor with allocator.\n\u002B  std::allocator\u003Cvoid\u003E allocator;\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E asc2(allocator);\n }\n \n TEST_F(TestAnySubscriptionCallback, unset_dispatch_throw) {\n@@ -68,153 \u002B84,285 @@ TEST_F(TestAnySubscriptionCallback, unset_dispatch_throw) {\n     any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_),\n     std::runtime_error);\n   EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n\u002B    any_subscription_callback_.dispatch_intra_process(msg_shared_ptr_, message_info_),\n     std::runtime_error);\n   EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n\u002B    any_subscription_callback_.dispatch_intra_process(get_unique_ptr_msg(), message_info_),\n     std::runtime_error);\n }\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_shared_ptr) {\n-  int callback_count = 0;\n-  auto shared_ptr_callback = [\u0026callback_count](\n-    const std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E) {\n-      callback_count\u002B\u002B;\n-    };\n-\n-  any_subscription_callback_.set(shared_ptr_callback);\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002B//\n\u002B// Parameterized test to test across all callback types and dispatch types.\n\u002B//\n \n-  // Can\u0027t convert ConstSharedPtr to SharedPtr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n\u002Bclass InstanceContextImpl\n\u002B{\n\u002Bpublic:\n\u002B  InstanceContextImpl() = default;\n\u002B  virtual ~InstanceContextImpl() = default;\n \n-  // Promotes Unique into SharedPtr\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n\u002B  explicit InstanceContextImpl(rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E asc)\n\u002B  : any_subscription_callback_(asc)\n\u002B  {}\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_shared_ptr_w_info) {\n-  int callback_count = 0;\n-  auto shared_ptr_w_info_callback = [\u0026callback_count](\n-    const std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {\n-      callback_count\u002B\u002B;\n-    };\n\u002B  virtual\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E\n\u002B  get_any_subscription_callback_to_test() const\n\u002B  {\n\u002B    return any_subscription_callback_;\n\u002B  }\n \n-  any_subscription_callback_.set(shared_ptr_w_info_callback);\n\u002Bprotected:\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E any_subscription_callback_;\n\u002B};\n \n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002Bclass InstanceContext\n\u002B{\n\u002Bpublic:\n\u002B  InstanceContext(const std::string \u0026 name, std::shared_ptr\u003CInstanceContextImpl\u003E impl)\n\u002B  : name(name), impl_(impl)\n\u002B  {}\n \n-  // Can\u0027t convert ConstSharedPtr to SharedPtr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n\u002B  InstanceContext(\n\u002B    const std::string \u0026 name,\n\u002B    rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E asc)\n\u002B  : name(name), impl_(std::make_shared\u003CInstanceContextImpl\u003E(asc))\n\u002B  {}\n \n-  // Promotes Unique into SharedPtr\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n\u002B  InstanceContext(const InstanceContext \u0026 other)\n\u002B  : InstanceContext(other.name, other.impl_) {}\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_const_shared_ptr) {\n-  int callback_count = 0;\n-  auto const_shared_ptr_callback = [\u0026callback_count](\n-    std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E) {\n-      callback_count\u002B\u002B;\n-    };\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E\n\u002B  get_any_subscription_callback_to_test() const\n\u002B  {\n\u002B    return impl_-\u003Eget_any_subscription_callback_to_test();\n\u002B  }\n \n-  any_subscription_callback_.set(const_shared_ptr_callback);\n\u002B  std::string name;\n \n-  // Ok to promote shared_ptr to ConstSharedPtr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002Bprotected:\n\u002B  std::shared_ptr\u003CInstanceContextImpl\u003E impl_;\n\u002B};\n \n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 2);\n\u002Bclass DispatchTests\n\u002B  : public TestAnySubscriptionCallback,\n\u002B  public ::testing::WithParamInterface\u003CInstanceContext\u003E\n\u002B{};\n \n-  // Not allowed to convert unique_ptr to const shared_ptr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 2);\n\u002Bauto\n\u002Bformat_parameter(const ::testing::TestParamInfo\u003CDispatchTests::ParamType\u003E \u0026 info)\n\u002B{\n\u002B  return info.param.name;\n }\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_const_shared_ptr_w_info) {\n-  int callback_count = 0;\n-  auto const_shared_ptr_callback = [\u0026callback_count](\n-    std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {\n-      callback_count\u002B\u002B;\n-    };\n-\n-  any_subscription_callback_.set(\n-    std::move(const_shared_ptr_callback));\n-\n-  // Ok to promote shared_ptr to ConstSharedPtr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002B// Testing dispatch with shared_ptr\u003CMessageT\u003E as input\n\u002BTEST_P(DispatchTests, test_inter_shared_dispatch) {\n\u002B  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n\u002B  any_subscription_callback_to_test.dispatch(msg_shared_ptr_, message_info_);\n\u002B}\n \n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 2);\n\u002B// Testing dispatch with shared_ptr\u003Cconst MessageT\u003E as input\n\u002BTEST_P(DispatchTests, test_intra_shared_dispatch) {\n\u002B  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n\u002B  any_subscription_callback_to_test.dispatch_intra_process(msg_shared_ptr_, message_info_);\n\u002B}\n \n-  // Not allowed to convert unique_ptr to const shared_ptr\n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 2);\n\u002B// Testing dispatch with unique_ptr\u003CMessageT\u003E as input\n\u002BTEST_P(DispatchTests, test_intra_unique_dispatch) {\n\u002B  auto any_subscription_callback_to_test = GetParam().get_any_subscription_callback_to_test();\n\u002B  any_subscription_callback_to_test.dispatch_intra_process(get_unique_ptr_msg(), message_info_);\n }\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_unique_ptr) {\n-  int callback_count = 0;\n-  auto unique_ptr_callback = [\u0026callback_count](\n-    std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E) {\n-      callback_count\u002B\u002B;\n-    };\n\u002B// Generic classes for testing callbacks using std::bind to class methods.\n\u002Btemplate\u003Ctypename ... CallbackArgs\u003E\n\u002Bclass BindContextImpl : public InstanceContextImpl\n\u002B{\n\u002B  static constexpr size_t number_of_callback_args{sizeof...(CallbackArgs)};\n \n-  any_subscription_callback_.set(unique_ptr_callback);\n\u002Bpublic:\n\u002B  using InstanceContextImpl::InstanceContextImpl;\n\u002B  virtual ~BindContextImpl() = default;\n \n-  // Message is copied into unique_ptr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002B  void on_message(CallbackArgs ...) const {}\n \n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n\u002B  rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E\n\u002B  get_any_subscription_callback_to_test() const override\n\u002B  {\n\u002B    if constexpr (number_of_callback_args == 1) {\n\u002B      return rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        std::bind(\u0026BindContextImpl::on_message, this, std::placeholders::_1)\n\u002B      );\n\u002B    } else {\n\u002B      return rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        std::bind(\u0026BindContextImpl::on_message, this, std::placeholders::_1, std::placeholders::_2)\n\u002B      );\n\u002B    }\n\u002B  }\n\u002B};\n \n-  // Unique_ptr is_moved\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n\u002Btemplate\u003Ctypename ... CallbackArgs\u003E\n\u002Bclass BindContext : public InstanceContext\n\u002B{\n\u002Bpublic:\n\u002B  explicit BindContext(const std::string \u0026 name)\n\u002B  : InstanceContext(name, std::make_shared\u003CBindContextImpl\u003CCallbackArgs ...\u003E\u003E())\n\u002B  {}\n\u002B};\n \n-TEST_F(TestAnySubscriptionCallback, set_dispatch_unique_ptr_w_info) {\n-  int callback_count = 0;\n-  auto unique_ptr_callback = [\u0026callback_count](\n-    std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {\n-      callback_count\u002B\u002B;\n-    };\n\u002B//\n\u002B// Versions of \u0060const MessageT \u0026\u0060\n\u002B//\n\u002Bvoid const_ref_free_func(const test_msgs::msg::Empty \u0026) {}\n\u002Bvoid const_ref_w_info_free_func(const test_msgs::msg::Empty \u0026, const rclcpp::MessageInfo \u0026) {}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  ConstRefCallbackTests,\n\u002B  DispatchTests,\n\u002B  ::testing::Values(\n\u002B    // lambda\n\u002B    InstanceContext{\u0022lambda\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](const test_msgs::msg::Empty \u0026) {})},\n\u002B    InstanceContext{\u0022lambda_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](const test_msgs::msg::Empty \u0026, const rclcpp::MessageInfo \u0026) {})},\n\u002B    // free function\n\u002B    InstanceContext{\u0022free_function\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        const_ref_free_func)},\n\u002B    InstanceContext{\u0022free_function_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        const_ref_w_info_free_func)},\n\u002B    // bind function\n\u002B    BindContext\u003Cconst test_msgs::msg::Empty \u0026\u003E(\u0022bind_method\u0022),\n\u002B    BindContext\u003Cconst test_msgs::msg::Empty \u0026, const rclcpp::MessageInfo \u0026\u003E(\n\u002B      \u0022bind_method_with_info\u0022)\n\u002B  ),\n\u002B  format_parameter\n\u002B);\n \n-  any_subscription_callback_.set(unique_ptr_callback);\n\u002B//\n\u002B// Versions of \u0060std::unique_ptr\u003CMessageT, MessageDeleter\u003E\u0060\n\u002B//\n\u002Bvoid unique_ptr_free_func(std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E) {}\n\u002Bvoid unique_ptr_w_info_free_func(\n\u002B  std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026)\n\u002B{}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  UniquePtrCallbackTests,\n\u002B  DispatchTests,\n\u002B  ::testing::Values(\n\u002B    // lambda\n\u002B    InstanceContext{\u0022lambda\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E) {})},\n\u002B    InstanceContext{\u0022lambda_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::unique_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {})},\n\u002B    // free function\n\u002B    InstanceContext{\u0022free_function\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        unique_ptr_free_func)},\n\u002B    InstanceContext{\u0022free_function_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        unique_ptr_w_info_free_func)},\n\u002B    // bind function\n\u002B    BindContext\u003Cstd::unique_ptr\u003Ctest_msgs::msg::Empty\u003E\u003E(\u0022bind_method\u0022),\n\u002B    BindContext\u003Cstd::unique_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026\u003E(\n\u002B      \u0022bind_method_with_info\u0022)\n\u002B  ),\n\u002B  format_parameter\n\u002B);\n \n-  // Message is copied into unique_ptr\n-  EXPECT_NO_THROW(any_subscription_callback_.dispatch(msg_shared_ptr_, message_info_));\n-  EXPECT_EQ(callback_count, 1);\n\u002B//\n\u002B// Versions of \u0060std::shared_ptr\u003Cconst MessageT\u003E\u0060\n\u002B//\n\u002Bvoid shared_const_ptr_free_func(std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E) {}\n\u002Bvoid shared_const_ptr_w_info_free_func(\n\u002B  std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026)\n\u002B{}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  SharedConstPtrCallbackTests,\n\u002B  DispatchTests,\n\u002B  ::testing::Values(\n\u002B    // lambda\n\u002B    InstanceContext{\u0022lambda\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E) {})},\n\u002B    InstanceContext{\u0022lambda_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {})},\n\u002B    // free function\n\u002B    InstanceContext{\u0022free_function\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        shared_const_ptr_free_func)},\n\u002B    InstanceContext{\u0022free_function_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        shared_const_ptr_w_info_free_func)},\n\u002B    // bind function\n\u002B    BindContext\u003Cstd::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E\u003E(\u0022bind_method\u0022),\n\u002B    BindContext\u003Cstd::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026\u003E(\n\u002B      \u0022bind_method_with_info\u0022)\n\u002B  ),\n\u002B  format_parameter\n\u002B);\n \n-  EXPECT_THROW(\n-    any_subscription_callback_.dispatch_intra_process(msg_const_shared_ptr_, message_info_),\n-    std::runtime_error);\n-  EXPECT_EQ(callback_count, 1);\n\u002B//\n\u002B// Versions of \u0060const std::shared_ptr\u003Cconst MessageT\u003E \u0026\u0060\n\u002B//\n\u002Bvoid const_ref_shared_const_ptr_free_func(const std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026) {}\n\u002Bvoid const_ref_shared_const_ptr_w_info_free_func(\n\u002B  const std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026, const rclcpp::MessageInfo \u0026)\n\u002B{}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  ConstRefSharedConstPtrCallbackTests,\n\u002B  DispatchTests,\n\u002B  ::testing::Values(\n\u002B    // lambda\n\u002B    InstanceContext{\u0022lambda\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](const std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026) {})},\n\u002B    InstanceContext{\u0022lambda_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](const std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026, const rclcpp::MessageInfo \u0026) {})},\n\u002B    // free function\n\u002B    InstanceContext{\u0022free_function\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        const_ref_shared_const_ptr_free_func)},\n\u002B    InstanceContext{\u0022free_function_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        const_ref_shared_const_ptr_w_info_free_func)},\n\u002B    // bind function\n\u002B    BindContext\u003Cconst std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026\u003E(\u0022bind_method\u0022),\n\u002B    BindContext\u003Cconst std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E \u0026, const rclcpp::MessageInfo \u0026\u003E(\n\u002B      \u0022bind_method_with_info\u0022)\n\u002B  ),\n\u002B  format_parameter\n\u002B);\n \n-  // Unique_ptr is_moved\n-  EXPECT_NO_THROW(\n-    any_subscription_callback_.dispatch_intra_process(std::move(msg_unique_ptr_), message_info_));\n-  EXPECT_EQ(callback_count, 2);\n-}\n\u002B//\n\u002B// Versions of \u0060std::shared_ptr\u003CMessageT\u003E\u0060\n\u002B//\n\u002Bvoid shared_ptr_free_func(std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E) {}\n\u002Bvoid shared_ptr_w_info_free_func(\n\u002B  std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026)\n\u002B{}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  SharedPtrCallbackTests,\n\u002B  DispatchTests,\n\u002B  ::testing::Values(\n\u002B    // lambda\n\u002B    InstanceContext{\u0022lambda\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E) {})},\n\u002B    InstanceContext{\u0022lambda_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        [](std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026) {})},\n\u002B    // free function\n\u002B    InstanceContext{\u0022free_function\u0022, rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        shared_ptr_free_func)},\n\u002B    InstanceContext{\u0022free_function_with_info\u0022,\n\u002B      rclcpp::AnySubscriptionCallback\u003Ctest_msgs::msg::Empty\u003E().set(\n\u002B        shared_ptr_w_info_free_func)},\n\u002B    // bind function\n\u002B    BindContext\u003Cstd::shared_ptr\u003Ctest_msgs::msg::Empty\u003E\u003E(\u0022bind_method\u0022),\n\u002B    BindContext\u003Cstd::shared_ptr\u003Ctest_msgs::msg::Empty\u003E, const rclcpp::MessageInfo \u0026\u003E(\n\u002B      \u0022bind_method_with_info\u0022)\n\u002B  ),\n\u002B  format_parameter\n\u002B);\ndiff --git rclcpp/test/rclcpp/test_create_subscription.cpp rclcpp/test/rclcpp/test_create_subscription.cpp\nindex 401e6c33..fd947485 100644\n--- rclcpp/test/rclcpp/test_create_subscription.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_create_subscription.cpp\n@@ -42,7 \u002B42,7 @@ TEST_F(TestCreateSubscription, create) {\n   auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   auto subscription =\n     rclcpp::create_subscription\u003Ctest_msgs::msg::Empty\u003E(node, \u0022topic_name\u0022, qos, callback, options);\n \n@@ -55,7 \u002B55,7 @@ TEST_F(TestCreateSubscription, create_with_overriding_options) {\n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n   options.qos_overriding_options = rclcpp::QosOverridingOptions::with_default_policies();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   auto subscription =\n     rclcpp::create_subscription\u003Ctest_msgs::msg::Empty\u003E(node, \u0022topic_name\u0022, qos, callback, options);\n \n@@ -67,7 \u002B67,7 @@ TEST_F(TestCreateSubscription, create_separated_node_topics_and_parameters) {\n   auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n   const rclcpp::QoS qos(10);\n   auto options = rclcpp::SubscriptionOptions();\n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n \n   auto node_parameters = node-\u003Eget_node_parameters_interface();\n   auto node_topics = node-\u003Eget_node_topics_interface();\n@@ -86,7 \u002B86,7 @@ TEST_F(TestCreateSubscription, create_with_statistics) {\n   options.topic_stats_options.publish_topic = \u0022topic_statistics\u0022;\n   options.topic_stats_options.publish_period = 5min;\n \n-  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   auto subscription =\n     rclcpp::create_subscription\u003Ctest_msgs::msg::Empty\u003E(node, \u0022topic_name\u0022, qos, callback, options);\n \ndiff --git rclcpp/test/rclcpp/test_memory_strategy.cpp rclcpp/test/rclcpp/test_memory_strategy.cpp\nindex 93fa0c8d..574bc1ae 100644\n--- rclcpp/test/rclcpp/test_memory_strategy.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_memory_strategy.cpp\n@@ -98,7 \u002B98,7 @@ TEST_F(TestMemoryStrategy, get_subscription_by_handle) {\n     {\n       auto callback_group =\n         node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n-      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B      auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n       const rclcpp::QoS qos(10);\n \n       {\n@@ -344,7 \u002B344,7 @@ TEST_F(TestMemoryStrategy, get_group_by_subscription) {\n \n       callback_group =\n         node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n-      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B      auto subscription_callback = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n       const rclcpp::QoS qos(10);\n \n       rclcpp::SubscriptionOptions subscription_options;\ndiff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex 6297c4eb..e1fb4b8c 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -2591,7 \u002B2591,7 @@ TEST_F(TestNode, get_publishers_subscriptions_info_by_topic) {\n     false\n   };\n   rclcpp::QoS qos2 = rclcpp::QoS(qos_initialization2, rmw_qos_profile_default2);\n-  auto callback = [](const test_msgs::msg::BasicTypes::SharedPtr msg) {\n\u002B  auto callback = [](test_msgs::msg::BasicTypes::ConstSharedPtr msg) {\n       (void)msg;\n     };\n   auto subscriber =\ndiff --git rclcpp/test/rclcpp/test_parameter_client.cpp rclcpp/test/rclcpp/test_parameter_client.cpp\nindex c7f8ad65..04240b7a 100644\n--- rclcpp/test/rclcpp/test_parameter_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_client.cpp\n@@ -33,7 \u002B33,7 @@ using namespace std::chrono_literals;\n class TestParameterClient : public ::testing::Test\n {\n public:\n-  void OnMessage(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n\u002B  void OnMessage(rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)\n   {\n     (void)event;\n   }\ndiff --git rclcpp/test/rclcpp/test_parameter_event_handler.cpp rclcpp/test/rclcpp/test_parameter_event_handler.cpp\nindex 86841924..097b0ee3 100644\n--- rclcpp/test/rclcpp/test_parameter_event_handler.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_event_handler.cpp\n@@ -27,9 \u002B27,9 @@ public:\n   : ParameterEventHandler(node)\n   {}\n \n-  void test_event(const rcl_interfaces::msg::ParameterEvent::SharedPtr event)\n\u002B  void test_event(rcl_interfaces::msg::ParameterEvent::ConstSharedPtr event)\n   {\n-    event_callback(event);\n\u002B    event_callback(*event);\n   }\n \n   size_t num_event_callbacks()\n@@ -264,20 \u002B264,20 @@ TEST_F(TestNode, EventCallback)\n   double product;\n   auto cb =\n     [\u0026int_param, \u0026double_param, \u0026product, \u0026received,\n-      this](const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026 event)\n\u002B      this](const rcl_interfaces::msg::ParameterEvent \u0026 event)\n     {\n       auto node_name = node-\u003Eget_fully_qualified_name();\n \n-      if (event-\u003Enode == node_name) {\n\u002B      if (event.node == node_name) {\n         received = true;\n       }\n \n       rclcpp::Parameter p;\n-      if (ParameterEventHandler::get_parameter_from_event(*event, p, \u0022my_int\u0022, node_name)) {\n\u002B      if (ParameterEventHandler::get_parameter_from_event(event, p, \u0022my_int\u0022, node_name)) {\n         int_param = p.get_value\u003Cint64_t\u003E();\n       }\n       try {\n-        p = ParameterEventHandler::get_parameter_from_event(*event, \u0022my_double\u0022, node_name);\n\u002B        p = ParameterEventHandler::get_parameter_from_event(event, \u0022my_double\u0022, node_name);\n         double_param = p.get_value\u003Cdouble\u003E();\n       } catch (...) {\n       }\n@@ -286,12 \u002B286,12 @@ TEST_F(TestNode, EventCallback)\n     };\n \n   auto cb2 =\n-    [\u0026bool_param, this](const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026 event)\n\u002B    [\u0026bool_param, this](const rcl_interfaces::msg::ParameterEvent \u0026 event)\n     {\n       rclcpp::Parameter p;\n-      if (event-\u003Enode == diff_ns_name) {\n\u002B      if (event.node == diff_ns_name) {\n         if (ParameterEventHandler::get_parameter_from_event(\n-            *event, p, \u0022my_bool\u0022, diff_ns_name))\n\u002B            event, p, \u0022my_bool\u0022, diff_ns_name))\n         {\n           bool_param = p.get_value\u003Cbool\u003E();\n         }\n@@ -405,13 \u002B405,13 @@ TEST_F(TestNode, LastInFirstCallForParameterEventCallbacks)\n   // The callbacks will log the current time for comparison purposes. Add a bit of a stall\n   // to ensure that the time noted in the back-to-back calls isn\u0027t the same\n   auto cb1 =\n-    [this, \u0026time_1](const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026)\n\u002B    [this, \u0026time_1](const rcl_interfaces::msg::ParameterEvent \u0026)\n     {\n       time_1 = node-\u003Enow();\n       std::this_thread::sleep_for(std::chrono::milliseconds(10));\n     };\n   auto cb2 =\n-    [this, \u0026time_2](const rcl_interfaces::msg::ParameterEvent::SharedPtr \u0026)\n\u002B    [this, \u0026time_2](const rcl_interfaces::msg::ParameterEvent \u0026)\n     {\n       time_2 = node-\u003Enow();\n       std::this_thread::sleep_for(std::chrono::milliseconds(10));\ndiff --git rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\nindex 9e009acb..eac46c1d 100644\n--- rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_publisher_subscription_count_api.cpp\n@@ -122,7 \u002B122,7 @@ public:\n   }\n \n protected:\n-  static void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\ndiff --git rclcpp/test/rclcpp/test_qos_event.cpp rclcpp/test/rclcpp/test_qos_event.cpp\nindex 6c94aaff..960ffdcb 100644\n--- rclcpp/test/rclcpp/test_qos_event.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_qos_event.cpp\n@@ -42,7 \u002B42,7 @@ protected:\n \n     node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_qos_event\u0022, \u0022/ns\u0022);\n \n-    message_callback = [node = node.get()](const test_msgs::msg::Empty::SharedPtr /*msg*/) {\n\u002B    message_callback = [node = node.get()](test_msgs::msg::Empty::ConstSharedPtr /*msg*/) {\n         RCLCPP_INFO(node-\u003Eget_logger(), \u0022Message received\u0022);\n       };\n   }\n@@ -55,7 \u002B55,7 @@ protected:\n   static constexpr char topic_name[] = \u0022test_topic\u0022;\n   rclcpp::Node::SharedPtr node;\n   bool is_fastrtps;\n-  std::function\u003Cvoid(const test_msgs::msg::Empty::SharedPtr)\u003E message_callback;\n\u002B  std::function\u003Cvoid(test_msgs::msg::Empty::ConstSharedPtr)\u003E message_callback;\n };\n \n constexpr char TestQosEvent::topic_name[];\ndiff --git rclcpp/test/rclcpp/test_serialized_message_allocator.cpp rclcpp/test/rclcpp/test_serialized_message_allocator.cpp\nindex 968ad0ac..78ab77a2 100644\n--- rclcpp/test/rclcpp/test_serialized_message_allocator.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_serialized_message_allocator.cpp\n@@ -58,7 \u002B58,7 @@ TEST(TestSerializedMessageAllocator, borrow_from_subscription) {\n   std::shared_ptr\u003Crclcpp::SubscriptionBase\u003E sub =\n     node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n     \u0022~/dummy_topic\u0022, 10,\n-    [](std::shared_ptr\u003Ctest_msgs::msg::Empty\u003E test_msg) {(void) test_msg;});\n\u002B    [](std::shared_ptr\u003Cconst test_msgs::msg::Empty\u003E test_msg) {(void) test_msg;});\n \n   auto msg0 = sub-\u003Ecreate_serialized_message();\n   EXPECT_EQ(0u, msg0-\u003Ecapacity());\ndiff --git rclcpp/test/rclcpp/test_subscription.cpp rclcpp/test/rclcpp/test_subscription.cpp\nindex 9b190fea..0e798cab 100644\n--- rclcpp/test/rclcpp/test_subscription.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription.cpp\n@@ -34,7 \u002B34,7 @@ using namespace std::chrono_literals;\n class TestSubscription : public ::testing::Test\n {\n public:\n-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\n@@ -80,7 \u002B80,7 @@ class TestSubscriptionInvalidIntraprocessQos\n class TestSubscriptionSub : public ::testing::Test\n {\n public:\n-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\n@@ -113,7 \u002B113,7 @@ public:\n   {\n   }\n \n-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\n@@ -130,7 \u002B130,7 @@ public:\n class SubscriptionClass\n {\n public:\n-  void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\n@@ -150,7 \u002B150,7 @@ public:\n TEST_F(TestSubscription, construction_and_destruction) {\n   initialize();\n   using test_msgs::msg::Empty;\n-  auto callback = [](const Empty::SharedPtr msg) {\n\u002B  auto callback = [](Empty::ConstSharedPtr msg) {\n       (void)msg;\n     };\n   {\n@@ -162,7 \u002B162,7 @@ TEST_F(TestSubscription, construction_and_destruction) {\n     // get_subscription_handle()\n     const rclcpp::SubscriptionBase * const_sub = sub.get();\n     EXPECT_NE(nullptr, const_sub-\u003Eget_subscription_handle());\n-    EXPECT_FALSE(sub-\u003Euse_take_shared_method());\n\u002B    EXPECT_TRUE(sub-\u003Euse_take_shared_method());\n \n     EXPECT_NE(nullptr, sub-\u003Eget_message_type_support_handle().typesupport_identifier);\n     EXPECT_NE(nullptr, sub-\u003Eget_message_type_support_handle().data);\n@@ -182,7 \u002B182,7 @@ TEST_F(TestSubscription, construction_and_destruction) {\n  */\n TEST_F(TestSubscriptionSub, construction_and_destruction) {\n   using test_msgs::msg::Empty;\n-  auto callback = [](const Empty::SharedPtr msg) {\n\u002B  auto callback = [](Empty::ConstSharedPtr msg) {\n       (void)msg;\n     };\n   {\n@@ -216,7 \u002B216,7 @@ TEST_F(TestSubscriptionSub, construction_and_destruction) {\n TEST_F(TestSubscription, various_creation_signatures) {\n   initialize();\n   using test_msgs::msg::Empty;\n-  auto cb = [](test_msgs::msg::Empty::SharedPtr) {};\n\u002B  auto cb = [](test_msgs::msg::Empty::ConstSharedPtr) {};\n   {\n     auto sub = node-\u003Ecreate_subscription\u003CEmpty\u003E(\u0022topic\u0022, 1, cb);\n     (void)sub;\ndiff --git rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\nindex 1e71e28c..92297e0e 100644\n--- rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_publisher_count_api.cpp\n@@ -108,7 \u002B108,7 @@ public:\n   }\n \n protected:\n-  static void OnMessage(const test_msgs::msg::Empty::SharedPtr msg)\n\u002B  static void OnMessage(test_msgs::msg::Empty::ConstSharedPtr msg)\n   {\n     (void)msg;\n   }\ndiff --git rclcpp/test/rclcpp/test_wait_set.cpp rclcpp/test/rclcpp/test_wait_set.cpp\nindex bbfc9383..f9d97a57 100644\n--- rclcpp/test/rclcpp/test_wait_set.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_wait_set.cpp\n@@ -221,7 \u002B221,7 @@ TEST_F(TestWaitSet, add_guard_condition_to_two_different_wait_set) {\n       wait_set2.add_guard_condition(guard_condition);\n     }, std::runtime_error);\n \n-    auto do_nothing = [](const std::shared_ptr\u003Ctest_msgs::msg::BasicTypes\u003E) {};\n\u002B    auto do_nothing = [](std::shared_ptr\u003Cconst test_msgs::msg::BasicTypes\u003E) {};\n     auto sub = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::BasicTypes\u003E(\u0022~/test\u0022, 1, do_nothing);\n     wait_set1.add_subscription(sub);\n     ASSERT_THROW(\n@@ -281,7 \u002B281,7 @@ TEST_F(TestWaitSet, add_remove_wait) {\n   rclcpp::SubscriptionOptions subscription_options;\n   subscription_options.event_callbacks.deadline_callback = [](auto) {};\n   subscription_options.event_callbacks.liveliness_callback = [](auto) {};\n-  auto do_nothing = [](const std::shared_ptr\u003Ctest_msgs::msg::BasicTypes\u003E) {};\n\u002B  auto do_nothing = [](std::shared_ptr\u003Cconst test_msgs::msg::BasicTypes\u003E) {};\n   auto sub =\n     node-\u003Ecreate_subscription\u003Ctest_msgs::msg::BasicTypes\u003E(\n     \u0022~/test\u0022, 1, do_nothing, subscription_options);\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\nindex 2282a92b..7a15e2cf 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_dynamic_storage.cpp\n@@ -74,7 \u002B74,7 @@ TEST_F(TestDynamicStorage, default_construct_destruct) {\n \n TEST_F(TestDynamicStorage, iterables_construct_destruct) {\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   auto timer = node-\u003Ecreate_wall_timer(std::chrono::seconds(100), []() {});\n   auto guard_condition = std::make_shared\u003Crclcpp::GuardCondition\u003E();\n   auto service =\n@@ -110,7 \u002B110,7 @@ TEST_F(TestDynamicStorage, add_remove_dynamically) {\n   options.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n \n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {}, options);\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {}, options);\n \n   rclcpp::SubscriptionWaitSetMask mask{true, true, true};\n   wait_set.add_subscription(subscription, mask);\n@@ -203,7 \u002B203,7 @@ TEST_F(TestDynamicStorage, add_remove_out_of_scope) {\n \n   {\n     auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-      \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B      \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n     wait_set.add_subscription(subscription);\n \n     // This is short, so if it\u0027s not cleaned up, it will trigger wait and it won\u0027t timeout\n@@ -238,7 \u002B238,7 @@ TEST_F(TestDynamicStorage, wait_subscription) {\n   auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, 10);\n \n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   wait_set.add_subscription(subscription);\n \n   {\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\nindex 8e406276..1e4d5f80 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_static_storage.cpp\n@@ -67,7 \u002B67,7 @@ private:\n \n TEST_F(TestStaticStorage, iterables_construct_destruct) {\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   // This is long, so it can stick around and be removed\n   auto timer = node-\u003Ecreate_wall_timer(std::chrono::seconds(100), []() {});\n   auto guard_condition = std::make_shared\u003Crclcpp::GuardCondition\u003E();\n@@ -132,7 \u002B132,7 @@ TEST_F(TestStaticStorage, fixed_storage_needs_pruning) {\n TEST_F(TestStaticStorage, wait_subscription) {\n   auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, 10);\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   rclcpp::SubscriptionWaitSetMask mask{true, true, true};\n   rclcpp::StaticWaitSet\u003C1, 0, 0, 0, 0, 0\u003E wait_set({{{subscription, mask}}});\n \ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\nindex 130d281e..ba0f4d16 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_storage_policy_common.cpp\n@@ -79,7 \u002B79,7 @@ TEST_F(TestStoragePolicyCommon, rcl_wait_set_resize_error) {\n   rclcpp::WaitSet wait_set;\n \n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   rclcpp::SubscriptionWaitSetMask mask{true, true, true};\n \n   auto mock = mocking_utils::patch_and_return(\n@@ -103,7 \u002B103,7 @@ TEST_F(TestStoragePolicyCommon, rcl_wait_set_clear_error) {\n TEST_F(TestStoragePolicyCommon, rcl_wait_set_add_subscription_error) {\n   rclcpp::WaitSet wait_set;\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   rclcpp::SubscriptionWaitSetMask mask{true, true, true};\n \n   auto mock = mocking_utils::patch_and_return(\ndiff --git rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\nindex 8f4870f1..99d07f1a 100644\n--- rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/wait_set_policies/test_thread_safe_synchronization.cpp\n@@ -75,7 \u002B75,7 @@ TEST_F(TestThreadSafeStorage, default_construct_destruct) {\n \n TEST_F(TestThreadSafeStorage, iterables_construct_destruct) {\n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   // This is long, so it can stick around\n   auto timer = node-\u003Ecreate_wall_timer(std::chrono::seconds(100), []() {});\n   auto guard_condition = std::make_shared\u003Crclcpp::GuardCondition\u003E();\n@@ -113,7 \u002B113,7 @@ TEST_F(TestThreadSafeStorage, add_remove_dynamically) {\n   options.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n \n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {}, options);\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {}, options);\n \n   rclcpp::SubscriptionWaitSetMask mask{true, true, true};\n   wait_set.add_subscription(subscription, mask);\n@@ -207,7 \u002B207,7 @@ TEST_F(TestThreadSafeStorage, add_remove_out_of_scope) {\n \n   {\n     auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-      \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B      \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n     wait_set.add_subscription(subscription);\n \n     // This is short, so if it\u0027s not cleaned up, it will trigger wait\n@@ -242,7 \u002B242,7 @@ TEST_F(TestThreadSafeStorage, wait_subscription) {\n   auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, 10);\n \n   auto subscription = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n-    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::SharedPtr) {});\n\u002B    \u0022topic\u0022, 10, [](test_msgs::msg::Empty::ConstSharedPtr) {});\n   wait_set.add_subscription(subscription);\n \n   {\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "b9a187db38a55045777ce60f48a89c64af587fd7",
    "RawMessage": "Update code about build error on windows",
    "Changes": "diff --git rmw_gurumdds_cpp/src/type_support_common.hpp rmw_gurumdds_cpp/src/type_support_common.hpp\nindex 04a19c9..e0f0d46 100644\n--- rmw_gurumdds_cpp/src/type_support_common.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/type_support_common.hpp\n@@ -15,6 \u002B15,11 @@\n #ifndef TYPE_SUPPORT_COMMON_HPP_\n #define TYPE_SUPPORT_COMMON_HPP_\n \n\u002B#if defined(_MSC_VER)\n\u002B#include \u003CBaseTsd.h\u003E\n\u002Btypedef SSIZE_T ssize_t;\n\u002B#endif\n\u002B\n #include \u003Cstring\u003E\n #include \u003Csstream\u003E\n \ndiff --git rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/qos.hpp rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/qos.hpp\nindex a80f248..d707966 100644\n--- rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/qos.hpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/qos.hpp\n@@ -64,6 \u002B64,7 @@ struct rmw_time_t\n convert_liveliness_lease_duration(\n   dds_LivelinessQosPolicy policy);\n \n\u002BRMW_GURUMDDS_SHARED_CPP_PUBLIC\n rmw_qos_policy_kind_t\n convert_qos_policy(\n   dds_QosPolicyId_t policy_id);\ndiff --git rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_common.hpp rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_common.hpp\nindex d063908..c81fa6a 100644\n--- rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_common.hpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_common.hpp\n@@ -198,6 \u002B198,7 @@ RMW_GURUMDDS_SHARED_CPP_PUBLIC\n rmw_ret_t\n shared__rmw_set_log_severity(rmw_log_severity_t severity);\n \n\u002BRMW_GURUMDDS_SHARED_CPP_PUBLIC\n rmw_ret_t\n shared__rmw_init_event(\n   const char * identifier,\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "common_interfaces",
    "SHA": "d407bd0d0cfc172f960fd4e199a7e8018994e250",
    "RawMessage": "[J-Turtle] Fix uninitialized values in NavSatFix and add missing NavSatStatus UNKNOWN (#220)",
    "Changes": "diff --git sensor_msgs/msg/NavSatStatus.msg sensor_msgs/msg/NavSatStatus.msg\nindex 7d2edc1..ae03056 100644\n--- sensor_msgs/msg/NavSatStatus.msg\n\u002B\u002B\u002B sensor_msgs/msg/NavSatStatus.msg\n@@ -4,16 \u002B4,18 @@\n # type and the last time differential corrections were received.  A\n # fix is valid when status \u003E= STATUS_FIX.\n \n\u002Bint8 STATUS_UNKNOWN = -2        # status is not yet set\n int8 STATUS_NO_FIX =  -1        # unable to fix position\n int8 STATUS_FIX =      0        # unaugmented fix\n int8 STATUS_SBAS_FIX = 1        # with satellite-based augmentation\n int8 STATUS_GBAS_FIX = 2        # with ground-based augmentation\n \n-int8 status\n\u002Bint8 status -2 # STATUS_UNKNOWN\n \n # Bits defining which Global Navigation Satellite System signals were\n # used by the receiver.\n \n\u002Buint16 SERVICE_UNKNOWN = 0  # Remember service is a bitfield, so checking (service \u0026 SERVICE_UNKNOWN) will not work. Use == instead.\n uint16 SERVICE_GPS =     1\n uint16 SERVICE_GLONASS = 2\n uint16 SERVICE_COMPASS = 4      # includes BeiDou.\n",
    "IsBackported": false
  },
  {
    "Repository": "ros2cli",
    "SHA": "50411582ff6f72d1940a52070c26988dff65fee7",
    "RawMessage": "Skip QoS compatibility test on Zenoh (#985)",
    "Changes": "diff --git ros2doctor/test/test_qos_compatibility.py ros2doctor/test/test_qos_compatibility.py\nindex cb21bed..29be364 100644\n--- ros2doctor/test/test_qos_compatibility.py\n\u002B\u002B\u002B ros2doctor/test/test_qos_compatibility.py\n@@ -122,6 \u002B122,10 @@ class TestROS2DoctorQoSCompatibility(unittest.TestCase):\n             filtered_rmw_implementation=rmw_implementation\n         )\n \n\u002B        # skip zenoh because of the QoS compatibility\n\u002B        if rmw_implementation == \u0027rmw_zenoh_cpp\u0027:\n\u002B            raise unittest.SkipTest()\n\u002B\n         @contextlib.contextmanager\n         def launch_doctor_command(self, arguments):\n             doctor_command_action = ExecuteProcess(\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "2d84e191873befa86c1b4060ddf7e25b39d095c1",
    "RawMessage": "Remove the word \u0022Alpha\u0022 from the splash screen. (#696)",
    "Changes": "diff --git rviz_common/CMakeLists.txt rviz_common/CMakeLists.txt\nindex 2dca676d..84f46647 100644\n--- rviz_common/CMakeLists.txt\n\u002B\u002B\u002B rviz_common/CMakeLists.txt\n@@ -57,8 \u002B57,9 @@ configure_file(src/rviz_common/env_config.hpp ${ENV_CONFIG_HPP} @ONLY)\n \n # TODO(jsquare): Adopt parameters given here\n set(ENV_CONFIG_CPP ${CMAKE_CURRENT_BINARY_DIR}/src/rviz_common/env_config.cpp)\n-set(RVIZ_VERSION \u0022Alpha\u0022)\n-set(ROS_DISTRO \u0022ROS 2.0\u0022)\n\u002Bament_package_xml()\n\u002Bset(RVIZ_VERSION \u0022${rviz_common_VERSION}\u0022)\n\u002Bset(ROS_DISTRO \u0022ROS 2\u0022)\n set(OGRE_PLUGIN_PATH \u0022rviz_ogre_vendor\u0022)\n configure_file(src/rviz_common/env_config.cpp.in ${ENV_CONFIG_CPP} @ONLY)\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "d37bbc53f4fb6c9d207af0bc5f194b31bb8a3183",
    "RawMessage": "Disable a Windows platform warning. (#311)",
    "Changes": "diff --git include/rcutils/stdatomic_helper/win32/stdatomic.h include/rcutils/stdatomic_helper/win32/stdatomic.h\nindex 596c2a7..7000fb2 100644\n--- include/rcutils/stdatomic_helper/win32/stdatomic.h\n\u002B\u002B\u002B include/rcutils/stdatomic_helper/win32/stdatomic.h\n@@ -63,7 \u002B63,19 @@\n #ifndef RCUTILS__STDATOMIC_HELPER__WIN32__STDATOMIC_H_\n #define RCUTILS__STDATOMIC_HELPER__WIN32__STDATOMIC_H_\n \n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B\n\u002B#pragma warning(push)\n\u002B#pragma warning(disable : 5105)\n #include \u003CWindows.h\u003E\n\u002B#pragma warning(pop)\n \n #include \u003Cstddef.h\u003E\n #include \u003Cstdint.h\u003E\ndiff --git src/filesystem.c src/filesystem.c\nindex 8a70957..772c602 100644\n--- src/filesystem.c\n\u002B\u002B\u002B src/filesystem.c\n@@ -27,7 \u002B27,18 @@ extern \u0022C\u0022\n #include \u003Cdirent.h\u003E\n #include \u003Cunistd.h\u003E\n #else\n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B#pragma warning(push)\n\u002B#pragma warning(disable : 5105)\n #include \u003Cwindows.h\u003E\n\u002B#pragma warning(pop)\n #include \u003Cdirect.h\u003E\n #endif  // _WIN32\n \ndiff --git src/logging.c src/logging.c\nindex 59df0af..2472850 100644\n--- src/logging.c\n\u002B\u002B\u002B src/logging.c\n@@ -26,7 \u002B26,18 @@ extern \u0022C\u0022\n \n #ifdef _WIN32\n # include \u003Cio.h\u003E\n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B# pragma warning(push)\n\u002B# pragma warning(disable : 5105)\n # include \u003Cwindows.h\u003E\n\u002B# pragma warning(pop)\n #else\n # include \u003Cunistd.h\u003E\n #endif\ndiff --git src/process.c src/process.c\nindex 89bd4bc..78eb97d 100644\n--- src/process.c\n\u002B\u002B\u002B src/process.c\n@@ -22,7 \u002B22,18 @@ extern \u0022C\u0022\n #include \u003Cstring.h\u003E\n \n #if defined _WIN32 || defined __CYGWIN__\n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B#pragma warning(push)\n\u002B#pragma warning(disable : 5105)\n #include \u003CWindows.h\u003E\n\u002B#pragma warning(pop)\n #else\n #include \u003Clibgen.h\u003E\n #include \u003Cunistd.h\u003E\ndiff --git src/shared_library.c src/shared_library.c\nindex 59d4ed2..f8ee5cb 100644\n--- src/shared_library.c\n\u002B\u002B\u002B src/shared_library.c\n@@ -22,7 \u002B22,18 @@ extern \u0022C\u0022\n #ifndef _WIN32\n #include \u003Cdlfcn.h\u003E\n #else\n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B#pragma warning(push)\n\u002B#pragma warning(disable : 5105)\n #include \u003Cwindows.h\u003E\n\u002B#pragma warning(pop)\n C_ASSERT(sizeof(void *) == sizeof(HINSTANCE));\n #endif  // _WIN32\n \ndiff --git src/time_win32.c src/time_win32.c\nindex 1ab0ac7..0a3dc34 100644\n--- src/time_win32.c\n\u002B\u002B\u002B src/time_win32.c\n@@ -23,7 \u002B23,18 @@ extern \u0022C\u0022\n \n #include \u0022rcutils/time.h\u0022\n \n\u002B// When building with MSVC 19.28.29333.0 on Windows 10 (as of 2020-11-11),\n\u002B// there appears to be a problem with winbase.h (which is included by\n\u002B// Windows.h).  In particular, warnings of the form:\n\u002B//\n\u002B// warning C5105: macro expansion producing \u0027defined\u0027 has undefined behavior\n\u002B//\n\u002B// See https://developercommunity.visualstudio.com/content/problem/695656/wdk-and-sdk-are-not-compatible-with-experimentalpr.html\n\u002B// for more information.  For now disable that warning when including windows.h\n\u002B#pragma warning(push)\n\u002B#pragma warning(disable : 5105)\n #include \u003Cwindows.h\u003E\n\u002B#pragma warning(pop)\n \n #include \u0022./common.h\u0022\n #include \u0022rcutils/allocator.h\u0022\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "aa18ef51cc289c3ecdb1e6373f347edc2c808530",
    "RawMessage": "Cleanup the TypeAdapt tests (#1858)",
    "Changes": "diff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex 34bdc0da..331c39fb 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -368,17 \u002B368,8 @@ ament_add_gtest(test_publisher_with_type_adapter test_publisher_with_type_adapte\n   APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022\n )\n if(TARGET test_publisher_with_type_adapter)\n-  ament_target_dependencies(test_publisher_with_type_adapter\n-    \u0022rcutils\u0022\n-    \u0022rcl_interfaces\u0022\n-    \u0022rmw\u0022\n-    \u0022rosidl_runtime_cpp\u0022\n-    \u0022rosidl_typesupport_cpp\u0022\n-    \u0022test_msgs\u0022\n-  )\n   target_link_libraries(test_publisher_with_type_adapter\n     ${PROJECT_NAME}\n-    mimick\n     ${cpp_typesupport_target})\n endif()\n \n@@ -386,17 \u002B377,8 @@ ament_add_gtest(test_subscription_with_type_adapter test_subscription_with_type_\n   APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022\n )\n if(TARGET test_subscription_with_type_adapter)\n-  ament_target_dependencies(test_subscription_with_type_adapter\n-    \u0022rcutils\u0022\n-    \u0022rcl_interfaces\u0022\n-    \u0022rmw\u0022\n-    \u0022rosidl_runtime_cpp\u0022\n-    \u0022rosidl_typesupport_cpp\u0022\n-    \u0022test_msgs\u0022\n-  )\n   target_link_libraries(test_subscription_with_type_adapter\n     ${PROJECT_NAME}\n-    mimick\n     ${cpp_typesupport_target})\n endif()\n \ndiff --git rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\nindex 8c6ebaee..c041d86a 100644\n--- rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_publisher_with_type_adapter.cpp\n@@ -16,32 \u002B16,18 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Cchrono\u003E\n-#include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n #include \u003Cthread\u003E\n #include \u003Cutility\u003E\n-#include \u003Cvector\u003E\n \n #include \u0022rclcpp/exceptions.hpp\u0022\n #include \u0022rclcpp/loaned_message.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n \n-#include \u0022../mocking_utils/patch.hpp\u0022\n-#include \u0022../utils/rclcpp_gtest_macros.hpp\u0022\n-\n-#include \u0022test_msgs/msg/empty.hpp\u0022\n #include \u0022rclcpp/msg/string.hpp\u0022\n \n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-\n using namespace std::chrono_literals;\n \n static const int g_max_loops = 200;\n@@ -58,28 \u002B44,6 @@ public:\n     }\n   }\n \n-protected:\n-  void initialize(const rclcpp::NodeOptions \u0026 node_options = rclcpp::NodeOptions())\n-  {\n-    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, node_options);\n-  }\n-\n-  void TearDown()\n-  {\n-    node.reset();\n-  }\n-\n-  rclcpp::Node::SharedPtr node;\n-};\n-\n-class CLASSNAME (test_intra_process_within_one_node, RMW_IMPLEMENTATION) : public ::testing::Test\n-{\n-public:\n-  static void SetUpTestCase()\n-  {\n-    rclcpp::init(0, nullptr);\n-  }\n-\n   static void TearDownTestCase()\n   {\n     rclcpp::shutdown();\n@@ -128,7 \u002B92,7 @@ struct TypeAdapter\u003Cint, rclcpp::msg::String\u003E\n   {\n     (void) source;\n     (void) destination;\n-    throw std::runtime_error(\u0022This should happen\u0022);\n\u002B    throw std::runtime_error(\u0022This should not happen\u0022);\n   }\n \n   static void\n@@ -150,7 \u002B114,7 @@ TEST_F(TestPublisher, various_creation_signatures) {\n   for (auto is_intra_process : {true, false}) {\n     rclcpp::NodeOptions options;\n     options.use_intra_process_comms(is_intra_process);\n-    initialize(options);\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, options);\n     {\n       using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n       auto publisher = node-\u003Ecreate_publisher\u003CStringTypeAdapter\u003E(\u0022topic\u0022, 42);\n@@ -179,7 \u002B143,7 @@ TEST_F(TestPublisher, conversion_exception_is_passed_up) {\n         (void)msg;\n       };\n \n-    initialize(options);\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, options);\n     auto pub = node-\u003Ecreate_publisher\u003CBadStringTypeAdapter\u003E(\u0022topic_name\u0022, 1);\n     // A subscription is created to ensure the existence of a buffer in the intra proccess\n     // manager which will trigger the faulty conversion.\n@@ -192,7 \u002B156,7 @@ TEST_F(TestPublisher, conversion_exception_is_passed_up) {\n  * Testing that publisher sends type adapted types and ROS message types with intra proccess communications.\n  */\n TEST_F(\n-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n\u002B  TestPublisher,\n   check_type_adapted_message_is_sent_and_received_intra_process) {\n   using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n   const std::string message_data = \u0022Message Data\u0022;\n@@ -281,7 \u002B245,7 @@ TEST_F(\n TEST_F(TestPublisher, check_type_adapted_message_is_sent_and_received) {\n   using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n \n-  initialize();\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, rclcpp::NodeOptions());\n \n   const std::string message_data = \u0022Message Data\u0022;\n   const std::string topic_name = \u0022topic_name\u0022;\ndiff --git rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\nindex 7668fead..8e74592f 100644\n--- rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\n@@ -16,32 \u002B16,16 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Cchrono\u003E\n-#include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n #include \u003Cthread\u003E\n-#include \u003Cutility\u003E\n-#include \u003Cvector\u003E\n \n #include \u0022rclcpp/exceptions.hpp\u0022\n-#include \u0022rclcpp/loaned_message.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n \n-#include \u0022../mocking_utils/patch.hpp\u0022\n-#include \u0022../utils/rclcpp_gtest_macros.hpp\u0022\n-\n-#include \u0022test_msgs/msg/empty.hpp\u0022\n #include \u0022rclcpp/msg/string.hpp\u0022\n \n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-\n using namespace std::chrono_literals;\n \n static const int g_max_loops = 200;\n@@ -50,30 \u002B34,6 @@ static const std::chrono::milliseconds g_sleep_per_loop(10);\n \n class TestSubscription : public ::testing::Test\n {\n-public:\n-  static void SetUpTestCase()\n-  {\n-    if (!rclcpp::ok()) {\n-      rclcpp::init(0, nullptr);\n-    }\n-  }\n-\n-protected:\n-  void initialize(const rclcpp::NodeOptions \u0026 node_options = rclcpp::NodeOptions())\n-  {\n-    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, node_options);\n-  }\n-\n-  void TearDown()\n-  {\n-    node.reset();\n-  }\n-\n-  rclcpp::Node::SharedPtr node;\n-};\n-\n-class CLASSNAME (test_intra_process_within_one_node, RMW_IMPLEMENTATION) : public ::testing::Test\n-{\n public:\n   static void SetUpTestCase()\n   {\n@@ -148,7 \u002B108,7 @@ bool wait_for_match(\n  * Testing publisher creation signatures with a type adapter.\n  */\n TEST_F(TestSubscription, various_creation_signatures) {\n-  initialize();\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022, rclcpp::NodeOptions());\n   {\n     using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n     auto sub =\n@@ -167,7 \u002B127,7 @@ TEST_F(TestSubscription, various_creation_signatures) {\n  * Testing that subscriber receives type adapted types and ROS message types with intra proccess communications.\n  */\n TEST_F(\n-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n\u002B  TestSubscription,\n   check_type_adapted_messages_are_received_by_intra_process_subscription) {\n   using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n   const std::string message_data = \u0022Message Data\u0022;\n@@ -386,7 \u002B346,7 @@ TEST_F(\n  * Testing that subscriber receives type adapted types and ROS message types with inter proccess communications.\n  */\n TEST_F(\n-  CLASSNAME(test_intra_process_within_one_node, RMW_IMPLEMENTATION),\n\u002B  TestSubscription,\n   check_type_adapted_messages_are_received_by_inter_process_subscription) {\n   using StringTypeAdapter = rclcpp::TypeAdapter\u003Cstd::string, rclcpp::msg::String\u003E;\n   const std::string message_data = \u0022Message Data\u0022;\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "f7056c0d86cd3b66c31ca02eb17d2dc6e789a3c4",
    "RawMessage": "fix events-executor warm-up bug and add unit-tests (#2591)",
    "Changes": "diff --git rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\nindex 5c1a8e8c..e8a6e188 100644\n--- rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n@@ -79,7 \u002B79,6 @@ EventsExecutor::setup_notify_waitable()\n       //    ---\u003E we need to wake up the executor so that it can terminate\n       // - a node or callback group guard condition is triggered:\n       //    ---\u003E the entities collection is changed, we need to update callbacks\n-      entities_need_rebuild_ = false;\n       this-\u003Ehandle_updated_entities(false);\n     });\n \n@@ -168,6 \u002B167,14 @@ EventsExecutor::spin_some_impl(std::chrono::nanoseconds max_duration, bool exhau\n       return false;\n     };\n \n\u002B  // If this spin is not exhaustive (e.g. spin_some), we need to explicitly check\n\u002B  // if entities need to be rebuilt here rather than letting the notify waitable event do it.\n\u002B  // A non-exhaustive spin would not check for work a second time, thus delaying the execution\n\u002B  // of some entities to the next invocation of spin.\n\u002B  if (!exhaustive) {\n\u002B    this-\u003Ehandle_updated_entities(false);\n\u002B  }\n\u002B\n   // Get the number of events and timers ready at start\n   const size_t ready_events_at_start = events_queue_-\u003Esize();\n   size_t executed_events = 0;\n@@ -314,6 \u002B321,17 @@ void\n EventsExecutor::handle_updated_entities(bool notify)\n {\n   (void)notify;\n\u002B\n\u002B  // Do not rebuild if we don\u0027t need to.\n\u002B  // A rebuild event could be generated, but then\n\u002B  // this function could end up being called from somewhere else\n\u002B  // before that event gets processed, for example if\n\u002B  // a node or callback group is manually added to the executor.\n\u002B  const bool notify_waitable_triggered = entities_need_rebuild_.exchange(false);\n\u002B  if (!notify_waitable_triggered \u0026\u0026 !this-\u003Ecollector_.has_pending()) {\n\u002B    return;\n\u002B  }\n\u002B\n   // Build the new collection\n   this-\u003Ecollector_.update_collections();\n   auto callback_groups = this-\u003Ecollector_.get_all_callback_groups();\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex dd4fcc1f..1c6fafe9 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -507,6 \u002B507,16 @@ if(TARGET test_executors_busy_waiting)\n   target_link_libraries(test_executors_busy_waiting ${PROJECT_NAME})\n endif()\n \n\u002Bament_add_gtest(\n\u002B  test_executors_warmup\n\u002B  executors/test_executors_warmup.cpp\n\u002B  executors/test_waitable.cpp\n\u002B  APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022\n\u002B  TIMEOUT 180)\n\u002Bif(TARGET test_executors_warmup)\n\u002B  target_link_libraries(test_executors_warmup ${PROJECT_NAME} ${test_msgs_TARGETS})\n\u002Bendif()\n\u002B\n ament_add_gtest(test_static_single_threaded_executor executors/test_static_single_threaded_executor.cpp\n   APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022)\n ament_add_test_label(test_static_single_threaded_executor mimick)\ndiff --git rclcpp/test/rclcpp/executors/test_executors_warmup.cpp rclcpp/test/rclcpp/executors/test_executors_warmup.cpp\nnew file mode 100644\nindex 00000000..7ab26a9d\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors_warmup.cpp\n@@ -0,0 \u002B1,244 @@\n\u002B// Copyright 2024 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B/**\n\u002B * This test checks all implementations of rclcpp::executor to check they pass they basic API\n\u002B * tests. Anything specific to any executor in particular should go in a separate test file.\n\u002B */\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Ccstddef\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Ctype_traits\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B\n\u002B#include \u0022./executor_types.hpp\u0022\n\u002B\n\u002Busing namespace std::chrono_literals;\n\u002B\n\u002Btemplate\u003Ctypename T\u003E\n\u002Bclass TestExecutorsWarmup : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTYPED_TEST_SUITE(TestExecutorsWarmup, ExecutorTypes, ExecutorTypeNames);\n\u002B\n\u002B// This test verifies that spin_all is correctly collecting work multiple times\n\u002B// even when one of the items of work is a notifier waitable event and thus results in\n\u002B// rebuilding the entities collection.\n\u002B// When spin_all goes back to collect more work, it should see the ready items from\n\u002B// the new added entities\n\u002BTYPED_TEST(TestExecutorsWarmup, spin_all_doesnt_require_warmup)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B  ExecutorType executor;\n\u002B\n\u002B  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n\u002B  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, node_options);\n\u002B\n\u002B  // Add node to the executor before creating the entities\n\u002B  executor.add_node(node);\n\u002B\n\u002B  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n\u002B  // the entities collection\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022test_topic\u0022, rclcpp::QoS(10));\n\u002B  size_t callback_count = 0;\n\u002B  auto callback = [\u0026callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count\u002B\u002B;};\n\u002B  auto subscription =\n\u002B    node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    \u0022test_topic\u0022, rclcpp::QoS(10), std::move(callback));\n\u002B\n\u002B  ASSERT_EQ(callback_count, 0u);\n\u002B\n\u002B  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n\u002B  publisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B\n\u002B  // We need to select a duration that is greater than\n\u002B  // the time taken to refresh the entities collection and rebuild the waitset.\n\u002B  // spin-all is expected to process the notifier waitable event, rebuild the collection,\n\u002B  // and then collect more work, finding the subscription message event.\n\u002B  // This duration has been selected empirically.\n\u002B  executor.spin_all(std::chrono::milliseconds(500));\n\u002B\n\u002B  // Verify that the callback is called as part of the spin above\n\u002B  EXPECT_EQ(callback_count, 1u);\n\u002B}\n\u002B\n\u002B// Same test as \u0060spin_all_doesnt_require_warmup\u0060, but uses a callback group\n\u002B// This test reproduces the bug reported by https://github.com/ros2/rclcpp/issues/2589\n\u002BTYPED_TEST(TestExecutorsWarmup, spin_all_doesnt_require_warmup_with_cbgroup)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B\n\u002B  // TODO(alsora): Enable when https://github.com/ros2/rclcpp/pull/2595 gets merged\n\u002B  if (\n\u002B    std::is_same\u003CExecutorType, rclcpp::executors::SingleThreadedExecutor\u003E() ||\n\u002B    std::is_same\u003CExecutorType, rclcpp::executors::MultiThreadedExecutor\u003E())\n\u002B  {\n\u002B    GTEST_SKIP();\n\u002B  }\n\u002B\n\u002B  ExecutorType executor;\n\u002B\n\u002B  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n\u002B  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, node_options);\n\u002B\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive,\n\u002B    false);\n\u002B\n\u002B  // Add callback group to the executor before creating the entities\n\u002B  executor.add_callback_group(callback_group, node-\u003Eget_node_base_interface());\n\u002B\n\u002B  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n\u002B  // the entities collection\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022test_topic\u0022, rclcpp::QoS(10));\n\u002B  size_t callback_count = 0;\n\u002B  auto callback = [\u0026callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count\u002B\u002B;};\n\u002B  rclcpp::SubscriptionOptions sub_options;\n\u002B  sub_options.callback_group = callback_group;\n\u002B  auto subscription =\n\u002B    node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    \u0022test_topic\u0022, rclcpp::QoS(10), std::move(callback), sub_options);\n\u002B\n\u002B  ASSERT_EQ(callback_count, 0u);\n\u002B\n\u002B  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n\u002B  publisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B\n\u002B  // We need to select a duration that is greater than\n\u002B  // the time taken to refresh the entities collection and rebuild the waitset.\n\u002B  // spin-all is expected to process the notifier waitable event, rebuild the collection,\n\u002B  // and then collect more work, finding the subscription message event.\n\u002B  // This duration has been selected empirically.\n\u002B  executor.spin_all(std::chrono::milliseconds(500));\n\u002B\n\u002B  // Verify that the callback is called as part of the spin above\n\u002B  EXPECT_EQ(callback_count, 1u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestExecutorsWarmup, spin_some_doesnt_require_warmup)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B\n\u002B  // TODO(alsora): currently only the events-executor passes this test.\n\u002B  // Enable single-threaded and multi-threaded executors\n\u002B  // when https://github.com/ros2/rclcpp/pull/2595 gets merged\n\u002B  if (\n\u002B    !std::is_same\u003CExecutorType, rclcpp::experimental::executors::EventsExecutor\u003E())\n\u002B  {\n\u002B    GTEST_SKIP();\n\u002B  }\n\u002B\n\u002B  ExecutorType executor;\n\u002B\n\u002B  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n\u002B  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, node_options);\n\u002B\n\u002B  // Add node to the executor before creating the entities\n\u002B  executor.add_node(node);\n\u002B\n\u002B  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n\u002B  // the entities collection\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022test_topic\u0022, rclcpp::QoS(10));\n\u002B  size_t callback_count = 0;\n\u002B  auto callback = [\u0026callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count\u002B\u002B;};\n\u002B  auto subscription =\n\u002B    node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    \u0022test_topic\u0022, rclcpp::QoS(10), std::move(callback));\n\u002B\n\u002B  ASSERT_EQ(callback_count, 0u);\n\u002B\n\u002B  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n\u002B  publisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B\n\u002B  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n\u002B  // the new message, no risk of race conditions where spin_some gets called before the\n\u002B  // message has been delivered.\n\u002B  executor.spin_some();\n\u002B\n\u002B  // Verify that the callback is called as part of the spin above\n\u002B  EXPECT_EQ(callback_count, 1u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestExecutorsWarmup, spin_some_doesnt_require_warmup_with_cbgroup)\n\u002B{\n\u002B  using ExecutorType = TypeParam;\n\u002B\n\u002B  // TODO(alsora): currently only the events-executor passes this test.\n\u002B  // Enable single-threaded and multi-threaded executors\n\u002B  // when https://github.com/ros2/rclcpp/pull/2595 gets merged\n\u002B  if (\n\u002B    !std::is_same\u003CExecutorType, rclcpp::experimental::executors::EventsExecutor\u003E())\n\u002B  {\n\u002B    GTEST_SKIP();\n\u002B  }\n\u002B\n\u002B  ExecutorType executor;\n\u002B\n\u002B  // Enable intra-process to guarantee deterministic and synchronous delivery of the message / event\n\u002B  auto node_options = rclcpp::NodeOptions().use_intra_process_comms(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, node_options);\n\u002B\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive,\n\u002B    false);\n\u002B\n\u002B  // Add callback group to the executor before creating the entities\n\u002B  executor.add_callback_group(callback_group, node-\u003Eget_node_base_interface());\n\u002B\n\u002B  // Create entities, this will produce a notifier waitable event, telling the executor to refresh\n\u002B  // the entities collection\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022test_topic\u0022, rclcpp::QoS(10));\n\u002B  size_t callback_count = 0;\n\u002B  auto callback = [\u0026callback_count](test_msgs::msg::Empty::ConstSharedPtr) {callback_count\u002B\u002B;};\n\u002B  rclcpp::SubscriptionOptions sub_options;\n\u002B  sub_options.callback_group = callback_group;\n\u002B  auto subscription =\n\u002B    node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    \u0022test_topic\u0022, rclcpp::QoS(10), std::move(callback), sub_options);\n\u002B\n\u002B  ASSERT_EQ(callback_count, 0u);\n\u002B\n\u002B  // Publish a message so that the new entities (i.e. the subscriber) already have work to do\n\u002B  publisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B\n\u002B  // NOTE: intra-process communication is enabled, so the subscription will immediately see\n\u002B  // the new message, no risk of race conditions where spin_some gets called before the\n\u002B  // message has been delivered.\n\u002B  executor.spin_some();\n\u002B\n\u002B  // Verify that the callback is called as part of the spin above\n\u002B  EXPECT_EQ(callback_count, 1u);\n\u002B}\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "5c2fa707d74c5ac3c10898a4aab9788b3b1e0c85",
    "RawMessage": "Fix the type annotation in pub.py. (#814)",
    "Changes": "diff --git ros2topic/ros2topic/verb/pub.py ros2topic/ros2topic/verb/pub.py\nindex f515380..6b87694 100644\n--- ros2topic/ros2topic/verb/pub.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/pub.py\n@@ -140,7 \u002B140,7 @@ def publisher(\n     print_nth: int,\n     times: int,\n     wait_matching_subscriptions: int,\n-    max_wait_time: float | None,\n\u002B    max_wait_time: Optional[float],\n     qos_profile: QoSProfile,\n     keep_alive: float,\n ) -\u003E Optional[str]:\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "a6f6bb70033336f6d90a916d51c0e9d9bdab6798",
    "RawMessage": "Move the QD into the rmw_implementation subdirectory. (#111)",
    "Changes": "diff --git QUALITY_DECLARATION.md rmw_implementation/QUALITY_DECLARATION.md\nsimilarity index 95%\nrename from QUALITY_DECLARATION.md\nrename to rmw_implementation/QUALITY_DECLARATION.md\nindex 2b7cbc9..3b94f95 100644\n--- QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_implementation/QUALITY_DECLARATION.md\n@@ -15,7 \u002B15,7 @@ Below are the rationales, notes, and caveats for this claim, organized by each r\n ### Version Stability [1.ii]\n \n \u0060rmw_implementation\u0060 is at a stable version, i.e. \u0060\u003E= 1.0.0\u0060.\n-The current version can be found in its [package.xml](rmw_implementation/package.xml), and its change history can be found in its [CHANGELOG](rmw_implementation/CHANGELOG.rst).\n\u002BThe current version can be found in its [package.xml](./package.xml), and its change history can be found in its [CHANGELOG](./CHANGELOG.rst).\n \n ### Public API Declaration [1.iii]\n \n@@ -32,6 \u002B32,7 @@ The current version can be found in its [package.xml](rmw_implementation/package\n ### ABI and ABI Stability Within a Released ROS Distribution [1.vi]\n \n \u0060rmw_implementation\u0060 will not break API nor ABI within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n\u002B\n ## Change Control Process [2]\n \n \u0060rmw_implementation\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n@@ -42,7 \u002B43,7 @@ This package requires that all changes occurr through a pull request.\n \n ### Contributor Origin [2.ii]\n \n-This package has a confirmation of contributor origin policy, which can be found in [CONTRIBUTING](./CONTRIBUTING.md).\n\u002BThis package has a confirmation of contributor origin policy, which can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n \n ### Peer Review Policy [2.iii]\n \n@@ -74,7 \u002B75,7 @@ Currently nightly results can be seen here:\n \n ### License [3.iii]\n \n-The license for \u0060rmw_implementation\u0060 is Apache 2.0, and a summary is in each source file, the type is declared in the [package.xml](rmw_implementation/package.xml) manifest file, and a full copy of the license is in the [LICENSE](./LICENSE) file.\n\u002BThe license for \u0060rmw_implementation\u0060 is Apache 2.0, and a summary is in each source file, the type is declared in the [package.xml](./package.xml) manifest file, and a full copy of the license is in the [LICENSE](../LICENSE) file.\n \n There is an automated test which runs a linter (ament_copyright) that ensures each file has a license statement.\n \n@@ -150,7 \u002B151,7 @@ This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https\n \n # Current status Summary\n \n-The chart below compares the requirements in the REP-2004 with the current state of the rcutils package.\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the rmw_implementation package.\n \n |Number|  Requirement| Current state |\n |--|--|--|\ndiff --git README.md rmw_implementation/README.md\nsimilarity index 100%\nrename from README.md\nrename to rmw_implementation/README.md\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "85c0af4fa06264a6b92a519197774c0e10b9606e",
    "RawMessage": "Set the minimum number of threads of the Multithreaded executor to 2 (#2030)",
    "Changes": "diff --git rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\nindex bb477690..507d47f9 100644\n--- rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/multi_threaded_executor.cpp\n@@ -21,6 \u002B21,7 @@\n \n #include \u0022rcpputils/scope_exit.hpp\u0022\n \n\u002B#include \u0022rclcpp/logging.hpp\u0022\n #include \u0022rclcpp/utilities.hpp\u0022\n \n using rclcpp::executors::MultiThreadedExecutor;\n@@ -34,9 \u002B35,15 @@ MultiThreadedExecutor::MultiThreadedExecutor(\n   yield_before_execute_(yield_before_execute),\n   next_exec_timeout_(next_exec_timeout)\n {\n-  number_of_threads_ = number_of_threads ? number_of_threads : std::thread::hardware_concurrency();\n-  if (number_of_threads_ == 0) {\n-    number_of_threads_ = 1;\n\u002B  number_of_threads_ = number_of_threads \u003E 0 ?\n\u002B    number_of_threads :\n\u002B    std::max(std::thread::hardware_concurrency(), 2U);\n\u002B\n\u002B  if (number_of_threads_ == 1) {\n\u002B    RCLCPP_WARN(\n\u002B      rclcpp::get_logger(\u0022rclcpp\u0022),\n\u002B      \u0022MultiThreadedExecutor is used with a single thread.\\n\u0022\n\u002B      \u0022Use the SingleThreadedExecutor instead.\u0022);\n   }\n }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "eac6a8daab60c9f9bdf6715b241312fb8f170739",
    "RawMessage": "[rolling] updated ros-tooling versions (#289)",
    "Changes": "diff --git .github/workflows/ci.yml .github/workflows/ci.yml\nindex a55966d..5530274 100644\n--- .github/workflows/ci.yml\n\u002B\u002B\u002B .github/workflows/ci.yml\n@@ -25,7 \u002B25,7 @@ jobs:\n       image: ${{ matrix.docker_image }}\n     steps:\n     - uses: actions/checkout@v2\n-    - uses: ros-tooling/setup-ros@0.3.0\n\u002B    - uses: ros-tooling/setup-ros@0.3.3\n       with:\n         use-ros2-testing: true\n         required-ros-distributions: ${{ matrix.ros_distribution }}\n@@ -36,7 \u002B36,7 @@ jobs:\n         apt-get install ros-${{ matrix.ros_distribution }}-rclcpp-action\n         apt-get install ros-${{ matrix.ros_distribution }}-mimick-vendor\n         apt-get -y install ros-${{ matrix.ros_distribution }}-performance-test-fixture\n-    - uses : ros-tooling/action-ros-ci@0.2.4\n\u002B    - uses : ros-tooling/action-ros-ci@0.2.5\n       with:\n         package-name: \u0022rclc rclc_examples rclc_lifecycle rclc_parameter\u0022\n         target-ros2-distro: ${{ matrix.ros_distribution }}\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "8a50fe72a0763aa35c46964c80b6946d9d99712a",
    "RawMessage": "Added common test to rviz_rendering_tests (#1234)",
    "Changes": "diff --git rviz_rendering_tests/package.xml rviz_rendering_tests/package.xml\nindex d8a62273..5eefc432 100644\n--- rviz_rendering_tests/package.xml\n\u002B\u002B\u002B rviz_rendering_tests/package.xml\n@@ -27,14 \u002B27,9 @@\n   \u003Cdepend\u003Erviz_rendering\u003C/depend\u003E\n   \u003Cdepend\u003Eresource_retriever\u003C/depend\u003E\n \n-  \u003C!-- TODO(jacobperron): Replace with ament_lint_common when ament_copyright is working --\u003E\n-  \u003Ctest_depend\u003Eament_cmake_cppcheck\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_cpplint\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_cmake_gmock\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_lint_cmake\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_uncrustify\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Eament_cmake_xmllint\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_index_cpp\u003C/test_depend\u003E\n \ndiff --git rviz_rendering_tests/test/mesh_loader_test.cpp rviz_rendering_tests/test/mesh_loader_test.cpp\nindex 3916a32c..507559de 100644\n--- rviz_rendering_tests/test/mesh_loader_test.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/mesh_loader_test.cpp\n@@ -1,31 \u002B1,31 @@\n-/*\n- * Copyright (c) 2018, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the copyright holder, nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2018, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n \n #include \u003Cgtest/gtest.h\u003E\n #include \u003Cgmock/gmock.h\u003E\ndiff --git rviz_rendering_tests/test/ogre_testing_environment.cpp rviz_rendering_tests/test/ogre_testing_environment.cpp\nindex dc8e884a..bb790c76 100644\n--- rviz_rendering_tests/test/ogre_testing_environment.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/ogre_testing_environment.cpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #include \u0022ogre_testing_environment.hpp\u0022\n \ndiff --git rviz_rendering_tests/test/ogre_testing_environment.hpp rviz_rendering_tests/test/ogre_testing_environment.hpp\nindex 6cc8e541..54f70678 100644\n--- rviz_rendering_tests/test/ogre_testing_environment.hpp\n\u002B\u002B\u002B rviz_rendering_tests/test/ogre_testing_environment.hpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #ifndef OGRE_TESTING_ENVIRONMENT_HPP_\n #define OGRE_TESTING_ENVIRONMENT_HPP_\ndiff --git rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\nindex 6fad5d08..2916113b 100644\n--- rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\n\u002B\u002B\u002B rviz_rendering_tests/test/test_rviz_ogre_media_exports.cpp\n@@ -1,31 \u002B1,32 @@\n-/*\n- * Copyright (c) 2017, Bosch Software Innovations GmbH.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *     * Redistributions of source code must retain the above copyright\n- *       notice, this list of conditions and the following disclaimer.\n- *     * Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *     * Neither the name of the Willow Garage, Inc. nor the names of its\n- *       contributors may be used to endorse or promote products derived from\n- *       this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n\u002B// Copyright (c) 2017, Bosch Software Innovations GmbH.\n\u002B// All rights reserved.\n\u002B//\n\u002B// Redistribution and use in source and binary forms, with or without\n\u002B// modification, are permitted provided that the following conditions are met:\n\u002B//\n\u002B//    * Redistributions of source code must retain the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer.\n\u002B//\n\u002B//    * Redistributions in binary form must reproduce the above copyright\n\u002B//      notice, this list of conditions and the following disclaimer in the\n\u002B//      documentation and/or other materials provided with the distribution.\n\u002B//\n\u002B//    * Neither the name of the copyright holder nor the names of its\n\u002B//      contributors may be used to endorse or promote products derived from\n\u002B//      this software without specific prior written permission.\n\u002B//\n\u002B// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B// POSSIBILITY OF SUCH DAMAGE.\n\u002B\n \n #include \u003Cgtest/gtest.h\u003E\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "c3af8a72fa1f81e5dcd384a9d2912ea244950cfb",
    "RawMessage": "Fix incorrect comparsion on whether parameter type is NOT_SET (#1032)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex f592008..d490a47 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -470,7 \u002B470,7 @@ class Node:\n                 descriptor.dynamic_typing = True\n \n             if isinstance(second_arg, Parameter.Type):\n-                if second_arg.value == Parameter.Type.NOT_SET:\n\u002B                if second_arg == Parameter.Type.NOT_SET:\n                     raise ValueError(\n                         f\u0027Cannot declare parameter {{{name}}} as statically typed of type NOT_SET\u0027)\n                 if descriptor.dynamic_typing is True:\ndiff --git rclpy/test/test_node.py rclpy/test/test_node.py\nindex f4790d6..8945c6b 100644\n--- rclpy/test/test_node.py\n\u002B\u002B\u002B rclpy/test/test_node.py\n@@ -832,6 \u002B832,11 @@ class TestNode(unittest.TestCase):\n                 )]\n             )\n \n\u002B        # Declare a parameter with parameter type \u0027Not Set\u0027\n\u002B        with self.assertRaises(ValueError):\n\u002B            self.node.declare_parameter(\n\u002B                \u0027wrong_parameter_value_type_not_set\u0027, Parameter.Type.NOT_SET)\n\u002B\n     def reject_parameter_callback(self, parameter_list):\n         rejected_parameters = (param for param in parameter_list if \u0027reject\u0027 in param.name)\n         return SetParametersResult(successful=(not any(rejected_parameters)))\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "26817ec0d8dc06880678b407f8690f367c5b92e6",
    "RawMessage": "Turn Context into a ContextManager (#1117)",
    "Changes": "diff --git rclpy/rclpy/context.py rclpy/rclpy/context.py\nindex 4e86d69..429a442 100644\n--- rclpy/rclpy/context.py\n\u002B\u002B\u002B rclpy/rclpy/context.py\n@@ -15,9 \u002B15,12 @@\n from inspect import ismethod\n import sys\n import threading\n\u002Bfrom types import TracebackType\n from typing import Callable\n\u002Bfrom typing import ContextManager\n from typing import List\n from typing import Optional\n\u002Bfrom typing import Type\n import weakref\n \n \n@@ -25,12 \u002B28,19 @@ g_logging_configure_lock = threading.Lock()\n g_logging_ref_count = 0\n \n \n-class Context:\n\u002Bclass Context(ContextManager[\u0027Context\u0027]):\n     \u0022\u0022\u0022\n     Encapsulates the lifecycle of init and shutdown.\n \n     Context objects should not be reused, and are finalized in their destructor.\n     Wraps the \u0060rcl_context_t\u0060 type.\n\u002B\n\u002B    :Example:\n\u002B        \u003E\u003E\u003E from rclpy.context import Context\n\u002B        \u003E\u003E\u003E with Context() as context:\n\u002B        \u003E\u003E\u003E     context.ok()\n\u002B        True\n\u002B\n     \u0022\u0022\u0022\n \n     def __init__(self):\n@@ -149,3 \u002B159,17 @@ class Context:\n             raise RuntimeError(\u0027Context must be initialized before it can have a domain id\u0027)\n         with self.__context, self._lock:\n             return self.__context.get_domain_id()\n\u002B\n\u002B    def __enter__(self) -\u003E \u0027Context\u0027:\n\u002B        # We do not accept parameters here. If one wants to customize the init() call,\n\u002B        # they would have to call it manaully and not use the ContextManager convenience\n\u002B        self.init()\n\u002B        return self\n\u002B\n\u002B    def __exit__(\n\u002B        self,\n\u002B        exc_type: Optional[Type[BaseException]],\n\u002B        exc_val: Optional[BaseException],\n\u002B        exc_tb: Optional[TracebackType],\n\u002B    ) -\u003E None:\n\u002B        self.try_shutdown()\ndiff --git rclpy/test/test_context.py rclpy/test/test_context.py\nindex a3978ff..7905499 100644\n--- rclpy/test/test_context.py\n\u002B\u002B\u002B rclpy/test/test_context.py\n@@ -50,3 \u002B50,20 @@ def test_on_shutdown_function():\n     context.shutdown()\n \n     assert callback_called\n\u002B\n\u002B\n\u002Bdef test_context_manager():\n\u002B    context = Context()\n\u002B\n\u002B    assert not context.ok(), \u0027the context should not be ok() before init() is called\u0027\n\u002B\n\u002B    with context as the_context:\n\u002B        # Make sure the correct instance is returned\n\u002B        assert the_context is context\n\u002B\n\u002B        assert context.ok(), \u0027the context should now be initialized\u0027\n\u002B\n\u002B    assert not context.ok(), \u0027the context should now be shut down\u0027\n\u002B\n\u002B    # Make sure it does not raise (smoke test)\n\u002B    context.try_shutdown()\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "2d7e96b8e2574faa22085c782e223a054de13e3e",
    "RawMessage": "Tweaks to client.c and subscription.c for cleaner init/fini (#728)",
    "Changes": "diff --git rcl/src/rcl/client.c rcl/src/rcl/client.c\nindex 9bf70dc..6a6a510 100644\n--- rcl/src/rcl/client.c\n\u002B\u002B\u002B rcl/src/rcl/client.c\n@@ -189,6 \u002B189,7 @@ rcl_client_init(\n fail:\n   if (client-\u003Eimpl) {\n     allocator-\u003Edeallocate(client-\u003Eimpl, allocator-\u003Estate);\n\u002B    client-\u003Eimpl = NULL;\n   }\n   ret = fail_ret;\n   // Fall through to cleanup\n@@ -223,6 \u002B224,7 @@ rcl_client_fini(rcl_client_t * client, rcl_node_t * node)\n       result = RCL_RET_ERROR;\n     }\n     allocator.deallocate(client-\u003Eimpl, allocator.state);\n\u002B    client-\u003Eimpl = NULL;\n   }\n   RCUTILS_LOG_DEBUG_NAMED(ROS_PACKAGE_NAME, \u0022Client finalized\u0022);\n   return result;\ndiff --git rcl/src/rcl/publisher.c rcl/src/rcl/publisher.c\nindex b82208a..eb2cc90 100644\n--- rcl/src/rcl/publisher.c\n\u002B\u002B\u002B rcl/src/rcl/publisher.c\n@@ -236,6 \u002B236,7 @@ rcl_publisher_fini(rcl_publisher_t * publisher, rcl_node_t * node)\n       result = RCL_RET_ERROR;\n     }\n     allocator.deallocate(publisher-\u003Eimpl, allocator.state);\n\u002B    publisher-\u003Eimpl = NULL;\n   }\n   RCUTILS_LOG_DEBUG_NAMED(ROS_PACKAGE_NAME, \u0022Publisher finalized\u0022);\n   return result;\ndiff --git rcl/src/rcl/service.c rcl/src/rcl/service.c\nindex 6dc1c79..cf7de3c 100644\n--- rcl/src/rcl/service.c\n\u002B\u002B\u002B rcl/src/rcl/service.c\n@@ -193,6 \u002B193,7 @@ rcl_service_init(\n fail:\n   if (service-\u003Eimpl) {\n     allocator-\u003Edeallocate(service-\u003Eimpl, allocator-\u003Estate);\n\u002B    service-\u003Eimpl = NULL;\n   }\n   ret = fail_ret;\n   // Fall through to clean up\n@@ -228,6 \u002B229,7 @@ rcl_service_fini(rcl_service_t * service, rcl_node_t * node)\n       result = RCL_RET_ERROR;\n     }\n     allocator.deallocate(service-\u003Eimpl, allocator.state);\n\u002B    service-\u003Eimpl = NULL;\n   }\n   RCUTILS_LOG_DEBUG_NAMED(ROS_PACKAGE_NAME, \u0022Service finalized\u0022);\n   return result;\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "547245a3fb7526662fbce9b0caffd7980d9d2791",
    "RawMessage": "Make publishers context-manager aware. (#1289)",
    "Changes": "diff --git rclpy/rclpy/publisher.py rclpy/rclpy/publisher.py\nindex d1a14ee..998e555 100644\n--- rclpy/rclpy/publisher.py\n\u002B\u002B\u002B rclpy/rclpy/publisher.py\n@@ -12,7 \u002B12,8 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Generic, List, Type, TypeVar, Union\n\u002Bfrom types import TracebackType\n\u002Bfrom typing import Generic, List, Optional, Type, TypeVar, Union\n \n from rclpy.callback_groups import CallbackGroup\n from rclpy.duration import Duration\n@@ -128,3 \u002B129,14 @@ class Publisher(Generic[MsgT]):\n         \u0022\u0022\u0022\n         with self.handle:\n             return self.__publisher.wait_for_all_acked(timeout._duration_handle)\n\u002B\n\u002B    def __enter__(self) -\u003E \u0027Publisher\u0027:\n\u002B        return self\n\u002B\n\u002B    def __exit__(\n\u002B        self,\n\u002B        exc_type: Optional[Type[BaseException]],\n\u002B        exc_val: Optional[BaseException],\n\u002B        exc_tb: Optional[TracebackType],\n\u002B    ) -\u003E None:\n\u002B        self.destroy()\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "4a1914a3b8c36a0bb59677cdbab9a21fb0da8ddd",
    "RawMessage": "Update init/shutdown API documentation. (#243)",
    "Changes": "diff --git rmw/include/rmw/init.h rmw/include/rmw/init.h\nindex c6788d4..4ff20b2 100644\n--- rmw/include/rmw/init.h\n\u002B\u002B\u002B rmw/include/rmw/init.h\n@@ -55,10 \u002B55,19 @@ rmw_get_zero_initialized_context(void);\n \n /// Initialize the middleware with the given options, and yielding an context.\n /**\n- * The given context must be zero initialized, and is filled with\n- * middleware specific data upon success of this function.\n\u002B * Context is filled with middleware specific data upon success of this function.\n  * The context is used when initializing some entities like nodes and\n- * guard conditions, and is also required to properly call rmw_shutdown().\n\u002B * guard conditions, and is also required to properly call \u0060rmw_shutdown()\u0060.\n\u002B *\n\u002B * \\pre The given options must have been initialized\n\u002B *   i.e. \u0060rmw_init_options_init()\u0060 called on it.\n\u002B * \\pre The given context must be zero initialized.\n\u002B *\n\u002B * \\post If initialization fails, context will remain zero initialized.\n\u002B *\n\u002B * \\remarks If options are zero-initialized, then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n\u002B *   If context has been already initialized (\u0060rmw_init()\u0060 was called on it), then\n\u002B *   \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n  *\n  * \u003Chr\u003E\n  * Attribute          | Adherence\n@@ -73,9 \u002B82,9 @@ rmw_get_zero_initialized_context(void);\n  * \\param[in] options initialization options to be used during initialization\n  * \\param[out] context resulting context struct\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any arguments are invalid, or\n  * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the implementation\n  *   identifier does not match, or\n- * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any arguments are null or invalid, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -85,8 \u002B94,11 @@ rmw_init(const rmw_init_options_t * options, rmw_context_t * context);\n \n /// Shutdown the middleware for a given context.\n /**\n- * The given context must be a valid context which has been initialized\n- * with rmw_init().\n\u002B * \\pre The given context must be a valid context which has been initialized with \u0060rmw_init()\u0060.\n\u002B *\n\u002B * \\remarks If context is zero initialized, then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n\u002B *   If context has been already invalidated (\u0060rmw_shutdown()\u0060 was called on it), then\n\u002B *   this function is a no-op and \u0060RMW_RET_OK\u0060 is returned.\n  *\n  * \u003Chr\u003E\n  * Attribute          | Adherence\n@@ -100,9 \u002B112,9 @@ rmw_init(const rmw_init_options_t * options, rmw_context_t * context);\n  *\n  * \\param[in] context resulting context struct\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any argument are invalid, or\n  * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the implementation\n  *   identifier does not match, or\n- * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if the argument is null or invalid, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -112,12 \u002B124,17 @@ rmw_shutdown(rmw_context_t * context);\n \n /// Finalize a context.\n /**\n- * The context to be finalized must have been previously initialized with\n- * \u0060rmw_init()\u0060, and then later invalidated with \u0060rmw_shutdown()\u0060.\n- * If context is \u0060NULL\u0060, then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n- * If context is zero-initialized, then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n- * If context is initialized and valid (\u0060rmw_shutdown()\u0060 was not called on it),\n- * then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n\u002B * This function will return early if a logical error, such as \u0060RMW_RET_INVALID_ARGUMENT\u0060\n\u002B * or \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060, ensues, leaving the given context unchanged.\n\u002B * Otherwise, it will proceed despite errors, freeing as much resources as it can and zero\n\u002B * initializing the given context.\n\u002B *\n\u002B * \\pre The context to be finalized must have been previously initialized with\n\u002B *   \u0060rmw_init()\u0060, and then later invalidated with \u0060rmw_shutdown()\u0060.\n\u002B *\n\u002B * \\remarks If context is zero initialized, then \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n\u002B *   If context is initialized and valid (\u0060rmw_shutdown()\u0060 was not called on it), then\n\u002B *   \u0060RMW_RET_INVALID_ARGUMENT\u0060 is returned.\n  *\n  * \u003Chr\u003E\n  * Attribute          | Adherence\n@@ -128,8 \u002B145,12 @@ rmw_shutdown(rmw_context_t * context);\n  * Lock-Free          | Yes [1]\n  * \u003Ci\u003E[1] if \u0060atomic_is_lock_free()\u0060 returns true for \u0060atomic_uint_least64_t\u0060\u003C/i\u003E\n  *\n- * \\return \u0060RMW_RET_OK\u0060 if the shutdown was completed successfully, or\n\u002B * This should be defined by the rmw implementation.\n\u002B *\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any arguments are invalid, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the implementation\n\u002B *   identifier does not match, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unspecified error occur.\n  */\n RMW_PUBLIC\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "realtime_support",
    "SHA": "ba01b23b1db4c6928ec24e1b0fb63337c16b16ec",
    "RawMessage": "Addressing issues found in Humble testing (#116)",
    "Changes": "diff --git rttest/CMakeLists.txt rttest/CMakeLists.txt\nindex 51ff3c2..5050e79 100644\n--- rttest/CMakeLists.txt\n\u002B\u002B\u002B rttest/CMakeLists.txt\n@@ -58,7 \u002B58,7 @@ if(${ament_cmake_FOUND})\n \n   install(\n     PROGRAMS scripts/rttest_plot\n-    DESTINATION bin\n\u002B    DESTINATION lib/${PROJECT_NAME}\n   )\n \n   install(\ndiff --git rttest/README.md rttest/README.md\nindex ef1ac0a..4671445 100644\n--- rttest/README.md\n\u002B\u002B\u002B rttest/README.md\n@@ -34,6 \u002B34,12 @@ make\n ./example_loop\n \u0060\u0060\u0060\n \n\u002BNote that if this is run in a Docker container, the \u0060IPC_LOCK\u0060 capability must be added to the container capabilities.\n\u002BThis can be managed via the \u0060--cap-add\u0060 flag:\n\u002B\u0060\u0060\u0060\n\u002Bdocker run --cap-add IPC_LOCK\n\u002B\u0060\u0060\u0060\n\u002B\n ## Command line arguments\n \n Passing \u0060argc\u0060 and \u0060argv\u0060 of an instrumented main function to \u0060rttest_read_args\u0060 will enable command line arguments for the instrumented function.\n@@ -59,4 \u002B65,4 @@ Default value is 1000.\n -tp Set the thread priority of all threads launched by the test program.\n Individual thread priority can be set using the \u0060rttest_set_sched_priority\u0060 command.\n \n--f Specify the name of the file for writing the collected data. Plot this data file using the \u0060rttest_plot.py\u0060 script provided in \u0060scripts\u0060.\n\u002B-f Specify the name of the file for writing the collected data. Plot this data file using the \u0060rttest_plot\u0060 script provided in \u0060scripts\u0060.\ndiff --git rttest/examples/CMakeLists.txt rttest/examples/CMakeLists.txt\nindex fbc765a..de5e686 100644\n--- rttest/examples/CMakeLists.txt\n\u002B\u002B\u002B rttest/examples/CMakeLists.txt\n@@ -4,8 \u002B4,5 @@ project(rttest_examples)\n \n find_package(rttest REQUIRED)\n \n-link_directories(${rttest_LIBRARY_DIR})\n-include_directories(${rttest_INCLUDE_DIRS})\n-\n add_executable(example_loop example_loop.c)\n-target_link_libraries(example_loop ${rttest_LIBRARIES})\n\u002Btarget_link_libraries(example_loop rttest::rttest)\ndiff --git tlsf_cpp/CMakeLists.txt tlsf_cpp/CMakeLists.txt\nindex 3c4a5f4..6c15ced 100644\n--- tlsf_cpp/CMakeLists.txt\n\u002B\u002B\u002B tlsf_cpp/CMakeLists.txt\n@@ -35,8 \u002B35,9 @@ target_link_libraries(tlsf_allocator_example\n   ${std_msgs_TARGETS}\n   tlsf_cpp)\n \n-install(TARGETS tlsf_allocator_example\n-  DESTINATION bin)\n\u002Binstall(TARGETS\n\u002B  tlsf_allocator_example\n\u002B  DESTINATION lib/${PROJECT_NAME})\n \n ament_export_targets(export_tlsf_cpp)\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "efa6b89b16ce6581d9d749da4fa70d1b17566670",
    "RawMessage": "std::copy fix - OccupancyGridUpdate - Data is not being processed correctly (#895)",
    "Changes": "diff --git rviz_default_plugins/src/rviz_default_plugins/displays/map/map_display.cpp rviz_default_plugins/src/rviz_default_plugins/displays/map/map_display.cpp\nindex e1190213..9d0306c8 100644\n--- rviz_default_plugins/src/rviz_default_plugins/displays/map/map_display.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/map/map_display.cpp\n@@ -360,9 \u002B360,10 @@ void MapDisplay::updateMapDataInMemory(\n   const map_msgs::msg::OccupancyGridUpdate::ConstSharedPtr update)\n {\n   for (size_t y = 0; y \u003C update-\u003Eheight; y\u002B\u002B) {\n\u002B    auto offset = update-\u003Edata.begin() \u002B y * update-\u003Ewidth;\n     std::copy(\n-      update-\u003Edata.begin(),\n-      update-\u003Edata.begin() \u002B update-\u003Ewidth,\n\u002B      offset,\n\u002B      offset \u002B update-\u003Ewidth,\n       current_map_.data.begin() \u002B (update-\u003Ey \u002B y) * current_map_.info.width \u002B update-\u003Ex);\n   }\n }\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "ffcdae92d450cc54ef29ea8b7fa7a3467dce4416",
    "RawMessage": "Make subscriptions context-manager aware. (#1291)",
    "Changes": "diff --git rclpy/rclpy/subscription.py rclpy/rclpy/subscription.py\nindex 31eecdd..131da3d 100644\n--- rclpy/rclpy/subscription.py\n\u002B\u002B\u002B rclpy/rclpy/subscription.py\n@@ -15,7 \u002B15,8 @@\n \n from enum import Enum\n import inspect\n-from typing import Callable, Generic, List, Type, TypeVar\n\u002Bfrom types import TracebackType\n\u002Bfrom typing import Callable, Generic, List, Optional, Type, TypeVar\n \n from rclpy.callback_groups import CallbackGroup\n from rclpy.event_handler import EventHandler, SubscriptionEventCallbacks\n@@ -123,3 \u002B124,14 @@ class Subscription(Generic[MsgT]):\n         raise RuntimeError(\n             \u0027Subscription.__init__(): callback should be either be callable with one argument\u0027\n             \u0027(to get only the message) or two (to get message and message info)\u0027)\n\u002B\n\u002B    def __enter__(self) -\u003E \u0027Subscription\u0027:\n\u002B        return self\n\u002B\n\u002B    def __exit__(\n\u002B        self,\n\u002B        exc_type: Optional[Type[BaseException]],\n\u002B        exc_val: Optional[BaseException],\n\u002B        exc_tb: Optional[TracebackType],\n\u002B    ) -\u003E None:\n\u002B        self.destroy()\n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "abea0e92e3eabfaa1079752d9ac6da352bc590d2",
    "RawMessage": "Fix tf2_geometry_msgs_INCLUDE_DIRS. (#729)",
    "Changes": "diff --git tf2_geometry_msgs/CMakeLists.txt tf2_geometry_msgs/CMakeLists.txt\nindex cb02e338..d63e49d6 100644\n--- tf2_geometry_msgs/CMakeLists.txt\n\u002B\u002B\u002B tf2_geometry_msgs/CMakeLists.txt\n@@ -76,6 \u002B76,7 @@ endif()\n install(TARGETS ${PROJECT_NAME} EXPORT export_${PROJECT_NAME})\n install(DIRECTORY include/ DESTINATION include/${PROJECT_NAME})\n \n\u002Bament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\n ament_export_targets(export_${PROJECT_NAME})\n ament_export_dependencies(\n   \u0022geometry_msgs\u0022\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "4f2672924a8352b6edaf71158cc84d385a2c2d1b",
    "RawMessage": "Call get_type_hash_func (#113)",
    "Changes": "diff --git rmw_connextdds_common/include/rmw_connextdds/type_support.hpp rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\nindex 87eb9ac..98c3bad 100644\n--- rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\n@@ -86,7 \u002B86,7 @@ public:\n \n   const rosidl_type_hash_t \u0026 type_hash() const\n   {\n-    return *_type_support_fastrtps-\u003Etype_hash;\n\u002B    return *_type_support_fastrtps-\u003Eget_type_hash_func(_type_support_fastrtps);\n   }\n \n   uint32_t type_serialized_size_max() const\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "7bd168563ca81fccbb8923937a91e70c0f3d9104",
    "RawMessage": "Ensure compliant publisher QoS queries. (#425)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/rmw_publisher.cpp rmw_fastrtps_cpp/src/rmw_publisher.cpp\nindex 976964f..2c3b606 100644\n--- rmw_fastrtps_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_publisher.cpp\n@@ -139,6 \u002B139,14 @@ rmw_publisher_get_actual_qos(\n   const rmw_publisher_t * publisher,\n   rmw_qos_profile_t * qos)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_get_actual_qos(\n     publisher, qos);\n }\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\nindex e9f5fe3..52ce147 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n@@ -143,6 \u002B143,14 @@ rmw_publisher_get_actual_qos(\n   const rmw_publisher_t * publisher,\n   rmw_qos_profile_t * qos)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_get_actual_qos(\n     publisher, qos);\n }\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\nindex 143c7ce..afa4b2e 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n@@ -125,17 \u002B125,8 @@ __rmw_publisher_get_actual_qos(\n   const rmw_publisher_t * publisher,\n   rmw_qos_profile_t * qos)\n {\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n-\n   auto info = static_cast\u003CCustomPublisherInfo *\u003E(publisher-\u003Edata);\n-  if (info == nullptr) {\n-    return RMW_RET_ERROR;\n-  }\n   eprosima::fastrtps::Publisher * fastrtps_pub = info-\u003Epublisher_;\n-  if (fastrtps_pub == nullptr) {\n-    return RMW_RET_ERROR;\n-  }\n   const eprosima::fastrtps::PublisherAttributes \u0026 attributes =\n     fastrtps_pub-\u003EgetAttributes();\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "13312dc6edb82a4f338d63f7140a292650dcf013",
    "RawMessage": "Quiet clang memory leak warning on \u0022DoNotOptimize\u0022. (#1571)",
    "Changes": "diff --git rclcpp/test/benchmark/benchmark_node.cpp rclcpp/test/benchmark/benchmark_node.cpp\nindex f667620d..2a1d8067 100644\n--- rclcpp/test/benchmark/benchmark_node.cpp\n\u002B\u002B\u002B rclcpp/test/benchmark/benchmark_node.cpp\n@@ -46,7 \u002B46,9 @@ BENCHMARK_F(NodePerformanceTest, create_node)(benchmark::State \u0026 state)\n   for (auto _ : state) {\n     // Using pointer to separate construction and destruction in timing\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022);\n\u002B#ifndef __clang_analyzer__\n     benchmark::DoNotOptimize(node);\n\u002B#endif\n     benchmark::ClobberMemory();\n \n     // Ensure destruction of node is not counted toward timing\n@@ -69,7 \u002B71,9 @@ BENCHMARK_F(NodePerformanceTest, destroy_node)(benchmark::State \u0026 state)\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022);\n     state.ResumeTiming();\n \n\u002B#ifndef __clang_analyzer__\n     benchmark::DoNotOptimize(node);\n\u002B#endif\n     benchmark::ClobberMemory();\n \n     node.reset();\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "656f2f067fe5162d772a3c966e70893f4d834dd0",
    "RawMessage": "Avoid memory leaks and undefined behavior in rmw_fastrtps_dynamic_cpp typesupport code (#429)",
    "Changes": "diff --git rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport.hpp rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport.hpp\nindex 54fca91..0c09766 100644\n--- rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport.hpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport.hpp\n@@ -100,7 \u002B100,7 @@ struct StringHelper\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E\n     return std::string(data.data);\n   }\n \n-  static void assign(eprosima::fastcdr::Cdr \u0026 deser, void * field, bool)\n\u002B  static void assign(eprosima::fastcdr::Cdr \u0026 deser, void * field)\n   {\n     std::string str;\n     deser \u003E\u003E str;\n@@ -120,12 \u002B120,9 @@ struct StringHelper\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E\n     return *(static_cast\u003Cstd::string *\u003E(data));\n   }\n \n-  static void assign(eprosima::fastcdr::Cdr \u0026 deser, void * field, bool call_new)\n\u002B  static void assign(eprosima::fastcdr::Cdr \u0026 deser, void * field)\n   {\n     std::string \u0026 str = *(std::string *)field;\n-    if (call_new) {\n-      new(\u0026str) std::string;\n-    }\n     deser \u003E\u003E str;\n   }\n };\n@@ -195,8 \u002B192,7 @@ private:\n   bool deserializeROSmessage(\n     eprosima::fastcdr::Cdr \u0026 deser,\n     const MembersType * members,\n-    void * ros_message,\n-    bool call_new) const;\n\u002B    void * ros_message) const;\n };\n \n }  // namespace rmw_fastrtps_dynamic_cpp\ndiff --git rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\nindex 551f5f8..da919d7 100644\n--- rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\n@@ -23,6 \u002B23,9 @@\n \n #include \u0022rmw_fastrtps_dynamic_cpp/TypeSupport.hpp\u0022\n #include \u0022rmw_fastrtps_dynamic_cpp/macros.hpp\u0022\n\u002B\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B\n #include \u0022rosidl_typesupport_fastrtps_c/wstring_conversion.hpp\u0022\n #include \u0022rosidl_typesupport_fastrtps_cpp/wstring_conversion.hpp\u0022\n #include \u0022rosidl_typesupport_introspection_cpp/field_types.hpp\u0022\n@@ -55,58 \u002B58,6 @@ SPECIALIZE_GENERIC_C_SEQUENCE(uint32, uint32_t)\n SPECIALIZE_GENERIC_C_SEQUENCE(int64, int64_t)\n SPECIALIZE_GENERIC_C_SEQUENCE(uint64, uint64_t)\n \n-typedef struct rosidl_runtime_c__void__Sequence\n-{\n-  void * data;\n-  /// The number of valid items in data\n-  size_t size;\n-  /// The number of allocated items in data\n-  size_t capacity;\n-} rosidl_runtime_c__void__Sequence;\n-\n-inline\n-bool\n-rosidl_runtime_c__void__Sequence__init(\n-  rosidl_runtime_c__void__Sequence * sequence, size_t size, size_t member_size)\n-{\n-  if (!sequence) {\n-    return false;\n-  }\n-  void * data = nullptr;\n-  if (size) {\n-    data = static_cast\u003Cvoid *\u003E(calloc(size, member_size));\n-    if (!data) {\n-      return false;\n-    }\n-  }\n-  sequence-\u003Edata = data;\n-  sequence-\u003Esize = size;\n-  sequence-\u003Ecapacity = size;\n-  return true;\n-}\n-\n-inline\n-void\n-rosidl_runtime_c__void__Sequence__fini(rosidl_runtime_c__void__Sequence * sequence)\n-{\n-  if (!sequence) {\n-    return;\n-  }\n-  if (sequence-\u003Edata) {\n-    // ensure that data and capacity values are consistent\n-    assert(sequence-\u003Ecapacity \u003E 0);\n-    // finalize all sequence elements\n-    free(sequence-\u003Edata);\n-    sequence-\u003Edata = nullptr;\n-    sequence-\u003Esize = 0;\n-    sequence-\u003Ecapacity = 0;\n-  } else {\n-    // ensure that data, size, and capacity values are consistent\n-    assert(0 == sequence-\u003Esize);\n-    assert(0 == sequence-\u003Ecapacity);\n-  }\n-}\n-\n template\u003Ctypename MembersType\u003E\n TypeSupport\u003CMembersType\u003E::TypeSupport(const void * ros_type_support)\n : BaseTypeSupport(ros_type_support)\n@@ -115,99 \u002B66,6 @@ TypeSupport\u003CMembersType\u003E::TypeSupport(const void * ros_type_support)\n   max_size_bound_ = false;\n }\n \n-static inline void *\n-align_(size_t __align, void * \u0026 __ptr) noexcept\n-{\n-  const auto __intptr = reinterpret_cast\u003Cuintptr_t\u003E(__ptr);\n-  const auto __aligned = (__intptr - 1u \u002B __align) \u0026 ~(__align - 1);\n-  return __ptr = reinterpret_cast\u003Cvoid *\u003E(__aligned);\n-}\n-\n-template\u003Ctypename MembersType\u003E\n-static size_t calculateMaxAlign(const MembersType * members)\n-{\n-  size_t max_align = 0;\n-\n-  for (uint32_t i = 0; i \u003C members-\u003Emember_count_; \u002B\u002Bi) {\n-    size_t alignment = 0;\n-    const auto \u0026 member = members-\u003Emembers_[i];\n-\n-    if (member.is_array_ \u0026\u0026 (!member.array_size_ || member.is_upper_bound_)) {\n-      alignment = alignof(std::vector\u003Cunsigned char\u003E);\n-    } else {\n-      switch (member.type_id_) {\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BOOL:\n-          alignment = alignof(bool);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BYTE:\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT8:\n-          alignment = alignof(uint8_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT8:\n-          alignment = alignof(char);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT32:\n-          alignment = alignof(float);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT64:\n-          alignment = alignof(double);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT16:\n-          alignment = alignof(int16_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT16:\n-          alignment = alignof(uint16_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT32:\n-          alignment = alignof(int32_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT32:\n-          alignment = alignof(uint32_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT64:\n-          alignment = alignof(int64_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT64:\n-          alignment = alignof(uint64_t);\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n-          // Note: specialization needed because calculateMaxAlign is called before\n-          // casting submembers as std::string, returned value is the same on i386\n-          if (std::is_same\u003CMembersType,\n-            rosidl_typesupport_introspection_c__MessageMembers\u003E::value)\n-          {\n-            alignment = alignof(rosidl_runtime_c__String);\n-          } else {\n-            alignment = alignof(std::string);\n-          }\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n-          if (std::is_same\u003CMembersType,\n-            rosidl_typesupport_introspection_c__MessageMembers\u003E::value)\n-          {\n-            alignment = alignof(rosidl_runtime_c__U16String);\n-          } else {\n-            alignment = alignof(std::u16string);\n-          }\n-          break;\n-        case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE:\n-          {\n-            auto sub_members = (const MembersType *)member.members_-\u003Edata;\n-            alignment = calculateMaxAlign(sub_members);\n-          }\n-          break;\n-      }\n-    }\n-\n-    if (alignment \u003E max_align) {\n-      max_align = alignment;\n-    }\n-  }\n-\n-  return max_align;\n-}\n-\n // C\u002B\u002B specialization\n template\u003Ctypename T\u003E\n void serialize_field(\n@@ -338,37 \u002B196,31 @@ void serialize_field\u003Cstd::wstring\u003E(\n     }\n   }\n }\n\u002B\n inline\n-size_t get_array_size_and_assign_field(\n\u002Bvoid * get_subros_message(\n   const rosidl_typesupport_introspection_cpp::MessageMember * member,\n   void * field,\n-  void * \u0026 subros_message,\n-  size_t sub_members_size,\n-  size_t max_align)\n\u002B  size_t index,\n\u002B  size_t,\n\u002B  bool)\n {\n-  auto vector = reinterpret_cast\u003Cstd::vector\u003Cunsigned char\u003E *\u003E(field);\n-  void * ptr = reinterpret_cast\u003Cvoid *\u003E(sub_members_size);\n-  size_t vsize = vector-\u003Esize() / reinterpret_cast\u003Csize_t\u003E(align_(max_align, ptr));\n-  if (member-\u003Eis_upper_bound_ \u0026\u0026 vsize \u003E member-\u003Earray_size_) {\n-    throw std::runtime_error(\u0022vector overcomes the maximum length\u0022);\n-  }\n-  subros_message = reinterpret_cast\u003Cvoid *\u003E(vector-\u003Edata());\n-  return vsize;\n\u002B  return member-\u003Eget_function(field, index);\n }\n \n inline\n-size_t get_array_size_and_assign_field(\n\u002Bvoid * get_subros_message(\n   const rosidl_typesupport_introspection_c__MessageMember * member,\n   void * field,\n-  void * \u0026 subros_message,\n-  size_t, size_t)\n\u002B  size_t index,\n\u002B  size_t array_size,\n\u002B  bool is_upper_bound)\n {\n-  auto tmpsequence = static_cast\u003Crosidl_runtime_c__void__Sequence *\u003E(field);\n-  if (member-\u003Eis_upper_bound_ \u0026\u0026 tmpsequence-\u003Esize \u003E member-\u003Earray_size_) {\n-    throw std::runtime_error(\u0022vector overcomes the maximum length\u0022);\n\u002B  if (array_size \u0026\u0026 !is_upper_bound) {\n\u002B    return member-\u003Eget_function(\u0026field, index);\n   }\n-  subros_message = reinterpret_cast\u003Cvoid *\u003E(tmpsequence-\u003Edata);\n-  return tmpsequence-\u003Esize;\n\u002B\n\u002B  return member-\u003Eget_function(field, index);\n }\n \n template\u003Ctypename MembersType\u003E\n@@ -437,26 \u002B289,31 @@ bool TypeSupport\u003CMembersType\u003E::serializeROSmessage(\n           if (!member-\u003Eis_array_) {\n             serializeROSmessage(ser, sub_members, field);\n           } else {\n-            void * subros_message = nullptr;\n             size_t array_size = 0;\n-            size_t sub_members_size = sub_members-\u003Esize_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);\n \n             if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n-              subros_message = field;\n               array_size = member-\u003Earray_size_;\n             } else {\n-              array_size = get_array_size_and_assign_field(\n-                member, field, subros_message, sub_members_size, max_align);\n\u002B              if (!member-\u003Esize_function) {\n\u002B                RMW_SET_ERROR_MSG(\u0022unexpected error: size function is null\u0022);\n\u002B                return false;\n\u002B              }\n\u002B              array_size = member-\u003Esize_function(field);\n \n               // Serialize length\n               ser \u003C\u003C (uint32_t)array_size;\n             }\n \n\u002B            if (array_size != 0 \u0026\u0026 !member-\u003Eget_function) {\n\u002B              RMW_SET_ERROR_MSG(\u0022unexpected error: get_function function is null\u0022);\n\u002B              return false;\n\u002B            }\n             for (size_t index = 0; index \u003C array_size; \u002B\u002Bindex) {\n-              serializeROSmessage(ser, sub_members, subros_message);\n-              subros_message = static_cast\u003Cchar *\u003E(subros_message) \u002B sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n\u002B              serializeROSmessage(\n\u002B                ser, sub_members,\n\u002B                get_subros_message(\n\u002B                  member, field, index, member-\u003Earray_size_,\n\u002B                  member-\u003Eis_upper_bound_));\n             }\n           }\n         }\n@@ -693,27 \u002B550,32 @@ size_t TypeSupport\u003CMembersType\u003E::getEstimatedSerializedSize(\n           if (!member-\u003Eis_array_) {\n             current_alignment \u002B= getEstimatedSerializedSize(sub_members, field, current_alignment);\n           } else {\n-            void * subros_message = nullptr;\n             size_t array_size = 0;\n-            size_t sub_members_size = sub_members-\u003Esize_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);\n \n             if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n-              subros_message = field;\n               array_size = member-\u003Earray_size_;\n             } else {\n-              array_size = get_array_size_and_assign_field(\n-                member, field, subros_message, sub_members_size, max_align);\n\u002B              if (!member-\u003Esize_function) {\n\u002B                RMW_SET_ERROR_MSG(\u0022unexpected error: size function is null\u0022);\n\u002B                return false;\n\u002B              }\n\u002B              array_size = member-\u003Esize_function(field);\n \n               // Length serialization\n               current_alignment \u002B= 4 \u002B eprosima::fastcdr::Cdr::alignment(current_alignment, 4);\n             }\n \n\u002B            if (array_size != 0 \u0026\u0026 !member-\u003Eget_function) {\n\u002B              RMW_SET_ERROR_MSG(\u0022unexpected error: get_function function is null\u0022);\n\u002B              return false;\n\u002B            }\n             for (size_t index = 0; index \u003C array_size; \u002B\u002Bindex) {\n               current_alignment \u002B= getEstimatedSerializedSize(\n-                sub_members, subros_message, current_alignment);\n-              subros_message = static_cast\u003Cchar *\u003E(subros_message) \u002B sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n\u002B                sub_members,\n\u002B                get_subros_message(\n\u002B                  member, field, index, member-\u003Earray_size_,\n\u002B                  member-\u003Eis_upper_bound_),\n\u002B                current_alignment);\n             }\n           }\n         }\n@@ -730,8 \u002B592,7 @@ template\u003Ctypename T\u003E\n void deserialize_field(\n   const rosidl_typesupport_introspection_cpp::MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n   if (!member-\u003Eis_array_) {\n     deser \u003E\u003E *static_cast\u003CT *\u003E(field);\n@@ -739,9 \u002B600,6 @@ void deserialize_field(\n     deser.deserializeArray(static_cast\u003CT *\u003E(field), member-\u003Earray_size_);\n   } else {\n     auto \u0026 vector = *reinterpret_cast\u003Cstd::vector\u003CT\u003E *\u003E(field);\n-    if (call_new) {\n-      new(\u0026vector) std::vector\u003CT\u003E;\n-    }\n     deser \u003E\u003E vector;\n   }\n }\n@@ -750,30 \u002B608,15 @@ template\u003C\u003E\n inline void deserialize_field\u003Cstd::string\u003E(\n   const rosidl_typesupport_introspection_cpp::MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n   if (!member-\u003Eis_array_) {\n-    if (call_new) {\n-      // Because std::string is a complex datatype, we need to make sure that\n-      // the memory is initialized to something reasonable before eventually\n-      // passing it as a reference to Fast-CDR.\n-      new(field) std::string();\n-    }\n     deser \u003E\u003E *static_cast\u003Cstd::string *\u003E(field);\n   } else if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n     std::string * array = static_cast\u003Cstd::string *\u003E(field);\n-    if (call_new) {\n-      for (size_t i = 0; i \u003C member-\u003Earray_size_; \u002B\u002Bi) {\n-        new(\u0026array[i]) std::string();\n-      }\n-    }\n     deser.deserializeArray(array, member-\u003Earray_size_);\n   } else {\n     auto \u0026 vector = *reinterpret_cast\u003Cstd::vector\u003Cstd::string\u003E *\u003E(field);\n-    if (call_new) {\n-      new(\u0026vector) std::vector\u003Cstd::string\u003E;\n-    }\n     deser \u003E\u003E vector;\n   }\n }\n@@ -782,10 \u002B625,8 @@ template\u003C\u003E\n inline void deserialize_field\u003Cstd::wstring\u003E(\n   const rosidl_typesupport_introspection_cpp::MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n-  (void)call_new;\n   std::wstring wstr;\n   if (!member-\u003Eis_array_) {\n     deser \u003E\u003E wstr;\n@@ -812,10 \u002B653,8 @@ template\u003Ctypename T\u003E\n void deserialize_field(\n   const rosidl_typesupport_introspection_c__MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n-  (void)call_new;\n   if (!member-\u003Eis_array_) {\n     deser \u003E\u003E *static_cast\u003CT *\u003E(field);\n   } else if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n@@ -833,13 \u002B672,11 @@ template\u003C\u003E\n inline void deserialize_field\u003Cstd::string\u003E(\n   const rosidl_typesupport_introspection_c__MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n-  (void)call_new;\n   if (!member-\u003Eis_array_) {\n     using CStringHelper = StringHelper\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E;\n-    CStringHelper::assign(deser, field, call_new);\n\u002B    CStringHelper::assign(deser, field);\n   } else {\n     if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n       auto deser_field = static_cast\u003Crosidl_runtime_c__String *\u003E(field);\n@@ -881,10 \u002B718,8 @@ template\u003C\u003E\n inline void deserialize_field\u003Cstd::wstring\u003E(\n   const rosidl_typesupport_introspection_c__MessageMember * member,\n   void * field,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  bool call_new)\n\u002B  eprosima::fastcdr::Cdr \u0026 deser)\n {\n-  (void)call_new;\n   std::wstring wstr;\n   if (!member-\u003Eis_array_) {\n     deser \u003E\u003E wstr;\n@@ -910,54 \u002B745,11 @@ inline void deserialize_field\u003Cstd::wstring\u003E(\n   }\n }\n \n-inline size_t get_submessage_array_deserialize(\n-  const rosidl_typesupport_introspection_cpp::MessageMember * member,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  void * field,\n-  void * \u0026 subros_message,\n-  bool call_new,\n-  size_t sub_members_size,\n-  size_t max_align)\n-{\n-  (void)member;\n-  uint32_t vsize = 0;\n-  // Deserialize length\n-  deser \u003E\u003E vsize;\n-  auto vector = reinterpret_cast\u003Cstd::vector\u003Cunsigned char\u003E *\u003E(field);\n-  if (call_new) {\n-    new(vector) std::vector\u003Cunsigned char\u003E;\n-  }\n-  void * ptr = reinterpret_cast\u003Cvoid *\u003E(sub_members_size);\n-  vector-\u003Eresize(vsize * (size_t)align_(max_align, ptr));\n-  subros_message = reinterpret_cast\u003Cvoid *\u003E(vector-\u003Edata());\n-  return vsize;\n-}\n-\n-inline size_t get_submessage_array_deserialize(\n-  const rosidl_typesupport_introspection_c__MessageMember * member,\n-  eprosima::fastcdr::Cdr \u0026 deser,\n-  void * field,\n-  void * \u0026 subros_message,\n-  bool,\n-  size_t sub_members_size,\n-  size_t)\n-{\n-  (void)member;\n-  // Deserialize length\n-  uint32_t vsize = 0;\n-  deser \u003E\u003E vsize;\n-  auto tmpsequence = static_cast\u003Crosidl_runtime_c__void__Sequence *\u003E(field);\n-  rosidl_runtime_c__void__Sequence__init(tmpsequence, vsize, sub_members_size);\n-  subros_message = reinterpret_cast\u003Cvoid *\u003E(tmpsequence-\u003Edata);\n-  return vsize;\n-}\n-\n template\u003Ctypename MembersType\u003E\n bool TypeSupport\u003CMembersType\u003E::deserializeROSmessage(\n   eprosima::fastcdr::Cdr \u0026 deser,\n   const MembersType * members,\n-  void * ros_message,\n-  bool call_new) const\n\u002B  void * ros_message) const\n {\n   assert(members);\n   assert(ros_message);\n@@ -967,72 \u002B759,78 @@ bool TypeSupport\u003CMembersType\u003E::deserializeROSmessage(\n     void * field = static_cast\u003Cchar *\u003E(ros_message) \u002B member-\u003Eoffset_;\n     switch (member-\u003Etype_id_) {\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BOOL:\n-        deserialize_field\u003Cbool\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cbool\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BYTE:\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT8:\n-        deserialize_field\u003Cuint8_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cuint8_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT8:\n-        deserialize_field\u003Cchar\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cchar\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT32:\n-        deserialize_field\u003Cfloat\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cfloat\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT64:\n-        deserialize_field\u003Cdouble\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cdouble\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT16:\n-        deserialize_field\u003Cint16_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cint16_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT16:\n-        deserialize_field\u003Cuint16_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cuint16_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT32:\n-        deserialize_field\u003Cint32_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cint32_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT32:\n-        deserialize_field\u003Cuint32_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cuint32_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT64:\n-        deserialize_field\u003Cint64_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cint64_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT64:\n-        deserialize_field\u003Cuint64_t\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cuint64_t\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n-        deserialize_field\u003Cstd::string\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cstd::string\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n-        deserialize_field\u003Cstd::wstring\u003E(member, field, deser, call_new);\n\u002B        deserialize_field\u003Cstd::wstring\u003E(member, field, deser);\n         break;\n       case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE:\n         {\n-          auto sub_members = (const MembersType *)member-\u003Emembers_-\u003Edata;\n\u002B          auto sub_members = static_cast\u003Cconst MembersType *\u003E(member-\u003Emembers_-\u003Edata);\n           if (!member-\u003Eis_array_) {\n-            deserializeROSmessage(deser, sub_members, field, call_new);\n\u002B            deserializeROSmessage(deser, sub_members, field);\n           } else {\n-            void * subros_message = nullptr;\n             size_t array_size = 0;\n-            size_t sub_members_size = sub_members-\u003Esize_of_;\n-            size_t max_align = calculateMaxAlign(sub_members);\n-            bool recall_new = call_new;\n \n             if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n-              subros_message = field;\n               array_size = member-\u003Earray_size_;\n             } else {\n-              array_size = get_submessage_array_deserialize(\n-                member, deser, field, subros_message,\n-                call_new, sub_members_size, max_align);\n-              recall_new = true;\n\u002B              uint32_t num_elems = 0;\n\u002B              deser \u003E\u003E num_elems;\n\u002B              array_size = static_cast\u003Csize_t\u003E(num_elems);\n\u002B\n\u002B              if (!member-\u003Eresize_function) {\n\u002B                RMW_SET_ERROR_MSG(\u0022unexpected error: resize function is null\u0022);\n\u002B                return false;\n\u002B              }\n\u002B              member-\u003Eresize_function(field, array_size);\n             }\n \n\u002B            if (array_size != 0 \u0026\u0026 !member-\u003Eget_function) {\n\u002B              RMW_SET_ERROR_MSG(\u0022unexpected error: get_function function is null\u0022);\n\u002B              return false;\n\u002B            }\n             for (size_t index = 0; index \u003C array_size; \u002B\u002Bindex) {\n-              deserializeROSmessage(deser, sub_members, subros_message, recall_new);\n-              subros_message = static_cast\u003Cchar *\u003E(subros_message) \u002B sub_members_size;\n-              subros_message = align_(max_align, subros_message);\n\u002B              deserializeROSmessage(\n\u002B                deser, sub_members,\n\u002B                get_subros_message(\n\u002B                  member, field, index, member-\u003Earray_size_,\n\u002B                  member-\u003Eis_upper_bound_));\n             }\n           }\n         }\n@@ -1179,7 \u002B977,7 @@ bool TypeSupport\u003CMembersType\u003E::deserializeROSmessage(\n \n   (void)impl;\n   if (members_-\u003Emember_count_ != 0) {\n-    TypeSupport::deserializeROSmessage(deser, members_, ros_message, false);\n\u002B    TypeSupport::deserializeROSmessage(deser, members_, ros_message);\n   } else {\n     uint8_t dump = 0;\n     deser \u003E\u003E dump;\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "aefad30495aa31c1c264096574f797e74442ce3b",
    "RawMessage": "Pass the CRL down to Fast-DDS if available. (#546)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/participant.cpp rmw_fastrtps_shared_cpp/src/participant.cpp\nindex 0033cdc..ae23f79 100644\n--- rmw_fastrtps_shared_cpp/src/participant.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/participant.cpp\n@@ -258,6 \u002B258,11 @@ rmw_fastrtps_shared_cpp::create_participant(\n         \u0022dds.sec.access.builtin.Access-Permissions.permissions\u0022,\n         security_files_paths[\u0022PERMISSIONS\u0022]);\n \n\u002B      if (security_files_paths.count(\u0022CRL\u0022) \u003E 0) {\n\u002B        property_policy.properties().emplace_back(\n\u002B          \u0022dds.sec.auth.builtin.PKI-DH.identity_crl\u0022, security_files_paths[\u0022CRL\u0022]);\n\u002B      }\n\u002B\n       // Configure security logging\n       if (!apply_security_logging_configuration(property_policy)) {\n         return nullptr;\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "e56a5cc3bdd637af52fae961990f0b9cf3a32839",
    "RawMessage": "Add QD links for dependencies to rmw_fastrtps_dynamic_cpp QD",
    "Changes": "diff --git rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\nindex acd8051..6501930 100644\n--- rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\n@@ -46,6 \u002B46,7 @@ This package uses DCO as its confirmation of contributor origin policy. More inf\n ### Peer Review Policy [2.iii]\n \n Following the recommended guidelines for ROS Core packages, all pull requests must have at least 1 peer review.\n\u002BCheck [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n \n ### Continuous Integration [2.iv]\n \n@@ -119,15 \u002B120,15 @@ Results of the nightly linter tests can be found [here](https://ci.ros2.org/view\n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n \u0060rmw_fastrtps_dynamic_cpp\u0060 has the following runtime ROS dependencies:\n-* \u0060fastrtps_cmake_module\u0060\n-* \u0060rcpputils\u0060\n-* \u0060rcutils\u0060\n-* \u0060rmw\u0060\n-* \u0060rmw_dds_common\u0060\n-* \u0060rmw_fastrtps_shared_cpp\u0060\n-* \u0060rosidl_runtime_c\u0060\n-* \u0060rosidl_typesupport_fastrtps_c\u0060\n-* \u0060rosidl_typesupport_fastrtps_cpp\u0060\n\u002B* \u0060fastrtps_cmake_module\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/fastrtps_cmake_module/QUALITY_DECLARATION.md)\n\u002B* \u0060rcpputils\u0060: [QUALITY DECLARATION](https://github.com/ros2/rcpputils/blob/master/QUALITY_DECLARATION.md)\n\u002B* \u0060rcutils\u0060: [QUALITY DECLARATION](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md)\n\u002B* \u0060rmw\u0060: [QUALITY DECLARATION](https://github.com/ros2/rmw/blob/master/rmw/QUALITY_DECLARATION.md)\n\u002B* \u0060rmw_dds_common\u0060: [QUALITY DECLARATION](https://github.com/ros2/rmw_dds_common/blob/master/rmw_dds_common/QUALITY_DECLARATION.md)\n\u002B* \u0060rmw_fastrtps_shared_cpp\u0060: [QUALITY DECLARATION](https://github.com/ros2/rmw_fastrtps/blob/master/rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_runtime_c\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl/blob/master/rosidl_runtime_c/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_typesupport_fastrtps_c\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_c/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_typesupport_fastrtps_cpp\u0060: [QUALITY DECLARATION](https://github.com/ros2/rosidl_typesupport_fastrtps/blob/master/rosidl_typesupport_fastrtps_cpp/QUALITY_DECLARATION.md)\n * \u0060rosidl_typesupport_introspection_c\u0060\n * \u0060rosidl_typesupport_introspection_cpp\u0060\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "b4ee7ad4cf9ff7bbdba03c454582b651808c28a1",
    "RawMessage": "Fix ODR violations in interactive_marker displays. (#1068)",
    "Changes": "diff --git rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker.hpp rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker.hpp\nindex fd8971cd..a0fa7ab0 100644\n--- rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker.hpp\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker.hpp\n@@ -41,14 \u002B41,18 @@\n \n #include \u003COgreVector.h\u003E\n #include \u003COgreQuaternion.h\u003E\n\u002B#include \u003COgreSceneNode.h\u003E\n #endif\n \n\u002B#include \u003CQMenu\u003E\n\u002B\n #include \u003Cvisualization_msgs/msg/interactive_marker.hpp\u003E\n #include \u003Cvisualization_msgs/msg/interactive_marker_pose.hpp\u003E\n #include \u003Cvisualization_msgs/msg/interactive_marker_feedback.hpp\u003E\n \n #include \u003Crclcpp/publisher.hpp\u003E\n \n\u002B#include \u0022rviz_common/display_context.hpp\u0022\n #include \u0022rviz_common/properties/status_property.hpp\u0022\n #include \u0022rviz_rendering/objects/axes.hpp\u0022\n \n@@ -56,24 \u002B60,10 @@\n \n #include \u0022rviz_default_plugins/visibility_control.hpp\u0022\n \n-namespace Ogre\n-{\n-class SceneNode;\n-}\n-\n-class QMenu;\n-\n-namespace rviz_common\n-{\n-class DisplayContext;\n-}\n-\n namespace rviz_default_plugins\n {\n namespace displays\n {\n-class InteractiveMarkerDisplay;\n-\n class RVIZ_DEFAULT_PLUGINS_PUBLIC InteractiveMarker : public QObject\n {\n   Q_OBJECT\ndiff --git rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker_display.hpp rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker_display.hpp\nindex 1c09893a..34040577 100644\n--- rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker_display.hpp\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/interactive_markers/interactive_marker_display.hpp\n@@ -44,23 \u002B44,17 @@\n #endif\n \n #include \u0022rviz_common/display.hpp\u0022\n\u002B#include \u0022rviz_common/properties/bool_property.hpp\u0022\n \n #include \u0022rviz_default_plugins/displays/interactive_markers/interactive_marker.hpp\u0022\n-\n-namespace rviz_common\n-{\n-class BoolProperty;\n-class Object;\n-}\n\u002B#include \u0022./interactive_marker_namespace_property.hpp\u0022\n\u002B#include \u0022rviz_default_plugins/displays/marker/markers/marker_base.hpp\u0022\n \n namespace rviz_default_plugins\n {\n-class InteractiveMarkerNamespaceProperty;\n \n namespace displays\n {\n-class MarkerBase;\n-\n /// Displays Interactive Markers\n class InteractiveMarkerDisplay : public rviz_common::Display\n {\n",
    "IsBackported": false
  },
  {
    "Repository": "launch_ros",
    "SHA": "2d125a5105bbfc1d34de17dd70c29905e3ce9732",
    "RawMessage": "\u0060WaitForTopics\u0060: get content of messages for each topic (#353)",
    "Changes": "diff --git launch_testing_ros/launch_testing_ros/wait_for_topics.py launch_testing_ros/launch_testing_ros/wait_for_topics.py\nindex 9736e5d..5cf2c9c 100644\n--- launch_testing_ros/launch_testing_ros/wait_for_topics.py\n\u002B\u002B\u002B launch_testing_ros/launch_testing_ros/wait_for_topics.py\n@@ -12,6 \u002B12,7 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n\u002Bfrom collections import deque\n import random\n import string\n from threading import Event\n@@ -47,12 \u002B48,14 @@ class WaitForTopics:\n             print(\u0027Given topics are receiving messages !\u0027)\n             print(wait_for_topics.topics_not_received()) # Should be an empty set\n             print(wait_for_topics.topics_received()) # Should be {\u0027topic_1\u0027, \u0027topic_2\u0027}\n\u002B            print(wait_for_topics.messages_received(\u0027topic_1\u0027)) # Should be [message_1, ...]\n             wait_for_topics.shutdown()\n     \u0022\u0022\u0022\n \n-    def __init__(self, topic_tuples, timeout=5.0):\n\u002B    def __init__(self, topic_tuples, timeout=5.0, messages_received_buffer_length=10):\n         self.topic_tuples = topic_tuples\n         self.timeout = timeout\n\u002B        self.messages_received_buffer_length = messages_received_buffer_length\n         self.__ros_context = rclpy.Context()\n         rclpy.init(context=self.__ros_context)\n         self.__ros_executor = SingleThreadedExecutor(context=self.__ros_context)\n@@ -64,9 \u002B67,14 @@ class WaitForTopics:\n         self.__ros_spin_thread.start()\n \n     def _prepare_ros_node(self):\n-        node_name = \u0027_test_node_\u0027 \u002B\\\n-            \u0027\u0027.join(random.choices(string.ascii_uppercase \u002B string.digits, k=10))\n-        self.__ros_node = _WaitForTopicsNode(name=node_name, node_context=self.__ros_context)\n\u002B        node_name = \u0027_test_node_\u0027 \u002B \u0027\u0027.join(\n\u002B            random.choices(string.ascii_uppercase \u002B string.digits, k=10)\n\u002B        )\n\u002B        self.__ros_node = _WaitForTopicsNode(\n\u002B            name=node_name,\n\u002B            node_context=self.__ros_context,\n\u002B            messages_received_buffer_length=self.messages_received_buffer_length,\n\u002B        )\n         self.__ros_executor.add_node(self.__ros_node)\n \n     def wait(self):\n@@ -87,6 \u002B95,12 @@ class WaitForTopics:\n         \u0022\u0022\u0022Topics that did not receive any messages.\u0022\u0022\u0022\n         return self.__ros_node.expected_topics - self.__ros_node.received_topics\n \n\u002B    def received_messages(self, topic_name):\n\u002B        \u0022\u0022\u0022List of received messages of a specific topic.\u0022\u0022\u0022\n\u002B        if topic_name not in self.__ros_node.received_messages_buffer:\n\u002B            raise KeyError(\u0027No messages received for topic: \u0027 \u002B topic_name)\n\u002B        return list(self.__ros_node.received_messages_buffer[topic_name])\n\u002B\n     def __enter__(self):\n         if not self.wait():\n             raise RuntimeError(\u0027Did not receive messages on these topics: \u0027,\n@@ -100,31 \u002B114,49 @@ class WaitForTopics:\n class _WaitForTopicsNode(Node):\n     \u0022\u0022\u0022Internal node used for subscribing to a set of topics.\u0022\u0022\u0022\n \n-    def __init__(self, name=\u0027test_node\u0027, node_context=None):\n-        super().__init__(node_name=name, context=node_context)\n\u002B    def __init__(\n\u002B            self, name=\u0027test_node\u0027, node_context=None, messages_received_buffer_length=None\n\u002B    ):\n\u002B        super().__init__(node_name=name, context=node_context)  # type: ignore\n         self.msg_event_object = Event()\n-\n-    def start_subscribers(self, topic_tuples):\n\u002B        self.messages_received_buffer_length = messages_received_buffer_length\n         self.subscriber_list = []\n-        self.expected_topics = {name for name, _ in topic_tuples}\n\u002B        self.topic_tuples = []\n\u002B        self.expected_topics = set()\n\u002B        self.received_topics = set()\n\u002B        self.received_messages_buffer = {}\n\u002B\n\u002B    def _reset(self):\n\u002B        self.msg_event_object.clear()\n         self.received_topics = set()\n\u002B        for buffer in self.received_messages_buffer.values():\n\u002B            buffer.clear()\n \n\u002B    def start_subscribers(self, topic_tuples):\n\u002B        self._reset()\n         for topic_name, topic_type in topic_tuples:\n-            # Create a subscriber\n-            self.subscriber_list.append(\n-                self.create_subscription(\n-                    topic_type,\n-                    topic_name,\n-                    self.callback_template(topic_name),\n-                    10\n\u002B            if (topic_name, topic_type) not in self.topic_tuples:\n\u002B                self.topic_tuples.append((topic_name, topic_type))\n\u002B                self.expected_topics.add(topic_name)\n\u002B                # Initialize ring buffer of received messages\n\u002B                self.received_messages_buffer[topic_name] = deque(\n\u002B                    maxlen=self.messages_received_buffer_length\n\u002B                )\n\u002B                # Create a subscriber\n\u002B                self.subscriber_list.append(\n\u002B                    self.create_subscription(\n\u002B                        topic_type,\n\u002B                        topic_name,\n\u002B                        self.callback_template(topic_name),\n\u002B                        10\n\u002B                    )\n                 )\n-            )\n \n     def callback_template(self, topic_name):\n-\n         def topic_callback(data):\n\u002B            self.get_logger().debug(\u0027Message received for \u0027 \u002B topic_name)\n\u002B            self.received_messages_buffer[topic_name].append(data)\n             if topic_name not in self.received_topics:\n-                self.get_logger().debug(\u0027Message received for \u0027 \u002B topic_name)\n                 self.received_topics.add(topic_name)\n             if self.received_topics == self.expected_topics:\n                 self.msg_event_object.set()\ndiff --git launch_testing_ros/test/examples/wait_for_topic_launch_test.py launch_testing_ros/test/examples/wait_for_topic_launch_test.py\nindex 3485843..ad7288f 100644\n--- launch_testing_ros/test/examples/wait_for_topic_launch_test.py\n\u002B\u002B\u002B launch_testing_ros/test/examples/wait_for_topic_launch_test.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import os\n\u002Bimport re\n import sys\n import unittest\n \n@@ -22,7 \u002B23,9 @@ import launch_ros.actions\n import launch_testing.actions\n import launch_testing.markers\n from launch_testing_ros import WaitForTopics\n\u002B\n import pytest\n\u002B\n from std_msgs.msg import String\n \n \n@@ -57,11 \u002B60,18 @@ if os.name != \u0027nt\u0027:\n             \u0022\u0022\u0022All the supplied topics should be read successfully.\u0022\u0022\u0022\n             topic_list = [(\u0027chatter_\u0027 \u002B str(i), String) for i in range(count)]\n             expected_topics = {\u0027chatter_\u0027 \u002B str(i) for i in range(count)}\n\u002B            message_pattern = re.compile(r\u0027Hello World: \\d\u002B\u0027)\n \n             # Method 1 : Using the magic methods and \u0027with\u0027 keyword\n-            with WaitForTopics(topic_list, timeout=10.0) as wait_for_node_object_1:\n\u002B            with WaitForTopics(\n\u002B                topic_list, timeout=2.0, messages_received_buffer_length=10\n\u002B            ) as wait_for_node_object_1:\n                 assert wait_for_node_object_1.topics_received() == expected_topics\n                 assert wait_for_node_object_1.topics_not_received() == set()\n\u002B                for topic_name, _ in topic_list:\n\u002B                    assert len(wait_for_node_object_1.received_messages(topic_name)) \u003E= 1\n\u002B                    message = wait_for_node_object_1.received_messages(topic_name).pop().data\n\u002B                    assert message_pattern.match(message)\n \n             # Multiple instances of WaitForNode() can be created safely as\n             # their internal nodes spin in separate contexts\n@@ -70,6 \u002B80,10 @@ if os.name != \u0027nt\u0027:\n             assert wait_for_node_object_2.wait()\n             assert wait_for_node_object_2.topics_received() == expected_topics\n             assert wait_for_node_object_2.topics_not_received() == set()\n\u002B            for topic_name, _ in topic_list:\n\u002B                assert len(wait_for_node_object_1.received_messages(topic_name)) \u003E= 1\n\u002B                message = wait_for_node_object_2.received_messages(topic_name).pop().data\n\u002B                assert message_pattern.match(message)\n             wait_for_node_object_2.shutdown()\n \n         def test_topics_unsuccessful(self, count):\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "56d7213abd8b0d23fa5f89e41c29a29fef58a3b7",
    "RawMessage": "Add type hash",
    "Changes": "diff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/graph_cache.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/graph_cache.hpp\nindex d7213cd..12377c5 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/graph_cache.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/graph_cache.hpp\n@@ -112,6 \u002B112,7 @@ graph_add_remote_entity(\n   const dds_GUID_t * const dp_guid,\n   const char * const topic_name,\n   const char * const type_name,\n\u002B  const dds_UserDataQosPolicy\u0026 user_data,\n   const dds_ReliabilityQosPolicy * const reliability,\n   const dds_DurabilityQosPolicy * const durability,\n   const dds_DeadlineQosPolicy * const deadline,\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/qos.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/qos.hpp\nindex 5d7dba8..bb367a4 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/qos.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/qos.hpp\n@@ -27,9 \u002B27,9 @@\n \n RMW_GURUMDDS_CPP_PUBLIC\n bool\n-get_datawriter_qos(\n-  dds_Publisher * publisher,\n\u002Bget_datawriter_qos(dds_Publisher * publisher,\n   const rmw_qos_profile_t * qos_profile,\n\u002B  const rosidl_type_hash_t \u0026 type_hash,\n   dds_DataWriterQos * datawriter_qos);\n \n RMW_GURUMDDS_CPP_PUBLIC\n@@ -37,6 \u002B37,7 @@ bool\n get_datareader_qos(\n   dds_Subscriber * subscriber,\n   const rmw_qos_profile_t * qos_profile,\n\u002B  const rosidl_type_hash_t \u0026 type_hash,\n   dds_DataReaderQos * datareader_qos);\n \n RMW_GURUMDDS_CPP_PUBLIC\ndiff --git rmw_gurumdds_cpp/src/graph_cache.cpp rmw_gurumdds_cpp/src/graph_cache.cpp\nindex 3a355a3..044195b 100644\n--- rmw_gurumdds_cpp/src/graph_cache.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/graph_cache.cpp\n@@ -17,6 \u002B17,7 @@\n #include \u0022rmw/publisher_options.h\u0022\n #include \u0022rmw/subscription_options.h\u0022\n #include \u0022rmw/qos_profiles.h\u0022\n\u002B#include \u0022rmw_dds_common/qos.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/context_listener_thread.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n@@ -28,13 \u002B29,15 @@\n \n #include \u0022rosidl_typesupport_cpp/message_type_support.hpp\u0022\n \n-static rmw_ret_t\n-__add_entity(\n\u002B\n\u002Bnamespace rmw_gurumdds::graph {\n\u002Brmw_ret_t add_entity(\n   rmw_context_impl_t * ctx,\n   const rmw_gid_t * const endp_gid,\n   const rmw_gid_t * const dp_gid,\n   const char * const topic_name,\n   const char * const type_name,\n\u002B  const rosidl_type_hash_s \u0026 type_hash,\n   const dds_HistoryQosPolicy * const history,\n   const dds_ReliabilityQosPolicy * const reliability,\n   const dds_DurabilityQosPolicy * const durability,\n@@ -42,37 \u002B45,29 @@ __add_entity(\n   const dds_LivelinessQosPolicy * const liveliness,\n   const dds_LifespanQosPolicy * const lifespan,\n   const bool is_reader,\n-  const bool local)\n-{\n\u002B  const bool local) {\n   (void)local;\n-  rmw_qos_profile_t qos_profile = {};\n-\n\u002B  size_t history_depth = RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT;\n\u002B  rmw_qos_history_policy_e history_kind = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n   if (history != nullptr) {\n-    qos_profile = {\n-      convert_history(history),\n-      static_cast\u003Csize_t\u003E(history-\u003Edepth),\n-      convert_reliability(reliability),\n-      convert_durability(durability),\n-      convert_deadline(deadline),\n-      convert_lifespan(lifespan),\n-      convert_liveliness(liveliness),\n-      convert_liveliness_lease_duration(liveliness),\n-      false,\n-    };\n-  } else {\n-    qos_profile = {\n-      RMW_QOS_POLICY_HISTORY_UNKNOWN,\n-      RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT,\n-      convert_reliability(reliability),\n-      convert_durability(durability),\n-      convert_deadline(deadline),\n-      convert_lifespan(lifespan),\n-      convert_liveliness(liveliness),\n-      convert_liveliness_lease_duration(liveliness),\n-      false,\n-    };\n-  }\n\u002B    history_depth = static_cast\u003Csize_t\u003E(history-\u003Edepth);\n\u002B    history_kind = convert_history(history);\n\u002B  }\n\u002B\n\u002B  rmw_qos_profile_t qos_profile{\n\u002B    history_kind,\n\u002B    history_depth,\n\u002B    convert_reliability(reliability),\n\u002B    convert_durability(durability),\n\u002B    convert_deadline(deadline),\n\u002B    convert_lifespan(lifespan),\n\u002B    convert_liveliness(liveliness),\n\u002B    convert_liveliness_lease_duration(liveliness),\n\u002B    false,\n\u002B  };\n \n\u002B  const uint32_t * const dp_gid_32_arr = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_gid-\u003Edata);\n\u002B  const uint32_t * const endp_gid_32_arr = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata);\n   RCUTILS_LOG_DEBUG_NAMED(\n     RMW_GURUMDDS_ID,\n     \u0022[context_listener thread] assert endpoint: \u0022\n@@ -86,37 \u002B81,37 @@ __add_entity(\n     \u0022local=%d\u0022,\n     reinterpret_cast\u003Cvoid *\u003E(ctx),\n     reinterpret_cast\u003Cvoid *\u003E(\u0026ctx-\u003Ecommon_ctx.graph_cache),\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(dp_gid-\u003Edata)[0],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(dp_gid-\u003Edata)[1],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(dp_gid-\u003Edata)[2],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(dp_gid-\u003Edata)[3],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[0],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[1],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[2],\n-    reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[3],\n\u002B    dp_gid_32_arr[0],\n\u002B    dp_gid_32_arr[1],\n\u002B    dp_gid_32_arr[2],\n\u002B    dp_gid_32_arr[3],\n\u002B    endp_gid_32_arr[0],\n\u002B    endp_gid_32_arr[1],\n\u002B    endp_gid_32_arr[2],\n\u002B    endp_gid_32_arr[3],\n     topic_name,\n     type_name,\n     is_reader,\n     local);\n \n   if (!ctx-\u003Ecommon_ctx.graph_cache.add_entity(\n-      *endp_gid,\n-      std::string(topic_name),\n-      std::string(type_name),\n-      *dp_gid,\n-      qos_profile,\n-      is_reader))\n-  {\n\u002B    *endp_gid,\n\u002B    std::string(topic_name),\n\u002B    std::string(type_name),\n\u002B    type_hash,\n\u002B    *dp_gid,\n\u002B    qos_profile,\n\u002B    is_reader)) {\n     RCUTILS_LOG_DEBUG_NAMED(\n       RMW_GURUMDDS_ID,\n       \u0022failed to add entity to cache: \u0022\n       \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n       \u0022topic=%s, \u0022\n       \u0022type=%s\u0022,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[2],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_gid-\u003Edata)[3],\n\u002B      endp_gid_32_arr[0],\n\u002B      endp_gid_32_arr[1],\n\u002B      endp_gid_32_arr[2],\n\u002B      endp_gid_32_arr[3],\n       topic_name,\n       type_name);\n     return RMW_RET_ERROR;\n@@ -125,12 \u002B120,10 @@ __add_entity(\n   return RMW_RET_OK;\n }\n \n-static rmw_ret_t\n-__remove_entity(\n\u002Brmw_ret_t remove_entity(\n   rmw_context_impl_t * const ctx,\n   const rmw_gid_t gid,\n-  const bool is_reader)\n-{\n\u002B  const bool is_reader) {\n   if (!ctx-\u003Ecommon_ctx.graph_cache.remove_entity(gid, is_reader)) {\n     RMW_SET_ERROR_MSG(\u0022failed to remove entity from graph_cache\u0022);\n     return RMW_RET_ERROR;\n@@ -152,13 \u002B145,13 @@ __remove_entity(\n   return RMW_RET_OK;\n }\n \n-static rmw_ret_t\n-__add_local_publisher(\n\u002Brmw_ret_t\n\u002Badd_local_publisher(\n   rmw_context_impl_t * const ctx,\n   const rmw_node_t * const node,\n   dds_DataWriter * const datawriter,\n-  const rmw_gid_t gid)\n-{\n\u002B  const rosidl_type_hash_s \u0026 type_hash,\n\u002B  const rmw_gid_t gid) {\n   RCUTILS_LOG_DEBUG_NAMED(\n     RMW_GURUMDDS_ID,\n     \u0022[graph] local publisher created: \u0022\n@@ -189,25 \u002B182,24 @@ __add_local_publisher(\n     return RMW_RET_ERROR;\n   }\n \n-  auto scope_exit_qos_reset = rcpputils::make_scope_exit(\n-    [dw_qos_ptr]()\n-    {\n-      if (dds_RETCODE_OK != dds_DataWriterQos_finalize(dw_qos_ptr)) {\n-        RMW_SET_ERROR_MSG(\u0022failed to finalize DataWriterQos\u0022);\n-      }\n-    });\n\u002B  auto scope_exit_qos_reset = rcpputils::make_scope_exit([dw_qos_ptr]() {\n\u002B    if (dds_RETCODE_OK != dds_DataWriterQos_finalize(dw_qos_ptr)) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize DataWriterQos\u0022);\n\u002B    }\n\u002B  });\n \n   if (dds_RETCODE_OK != dds_DataWriter_get_qos(datawriter, \u0026dw_qos)) {\n     RMW_SET_ERROR_MSG(\u0022failed to get DataWriterQos\u0022);\n     return RMW_RET_ERROR;\n   }\n \n-  return __add_entity(\n\u002B  return add_entity(\n     ctx,\n     \u0026gid,\n     \u0026ctx-\u003Ecommon_ctx.gid,\n     topic_name,\n     type_name,\n\u002B    type_hash,\n     \u0026dw_qos.history,\n     \u0026dw_qos.reliability,\n     \u0026dw_qos.durability,\n@@ -218,21 \u002B210,19 @@ __add_local_publisher(\n     true);\n }\n \n-static rmw_ret_t\n-__add_local_subscriber(\n\u002Brmw_ret_t add_local_subscriber(\n   rmw_context_impl_t * const ctx,\n   const rmw_node_t * const node,\n   dds_DataReader * const datareader,\n-  const rmw_gid_t gid)\n-{\n\u002B  const rosidl_type_hash_s \u0026 type_hash,\n\u002B  const rmw_gid_t gid) {\n   RCUTILS_LOG_DEBUG_NAMED(\n     RMW_GURUMDDS_ID,\n     \u0022[graph] local subscriber created: \u0022\n     \u0022node=%s::%s, \u0022\n     \u0022dp_gid=%08X.%08X.%08X.%08X, \u0022\n     \u0022gid=%08X.%08X.%08X.%08X\u0022,\n-    node-\u003Enamespace_,\n-    node-\u003Ename,\n\u002B    node-\u003Enamespace_, node-\u003Ename,\n     reinterpret_cast\u003Cconst uint32_t *\u003E(ctx-\u003Ecommon_ctx.gid.data)[0],\n     reinterpret_cast\u003Cconst uint32_t *\u003E(ctx-\u003Ecommon_ctx.gid.data)[1],\n     reinterpret_cast\u003Cconst uint32_t *\u003E(ctx-\u003Ecommon_ctx.gid.data)[2],\n@@ -245,8 \u002B235,7 @@ __add_local_subscriber(\n   dds_DataReaderQos dr_qos;\n   dds_DataReaderQos * dr_qos_ptr = \u0026dr_qos;\n \n-  dds_Topic * topic =\n-    reinterpret_cast\u003Cdds_Topic *\u003E(dds_DataReader_get_topicdescription(datareader));\n\u002B  dds_Topic * topic = reinterpret_cast\u003Cdds_Topic *\u003E(dds_DataReader_get_topicdescription(datareader));\n   const char * topic_name = dds_Topic_get_name(topic);\n   const char * type_name = dds_Topic_get_type_name(topic);\n \n@@ -256,25 \u002B245,24 @@ __add_local_subscriber(\n     return RMW_RET_ERROR;\n   }\n \n-  auto scope_exit_qos_reset = rcpputils::make_scope_exit(\n-    [dr_qos_ptr]()\n-    {\n-      if (dds_RETCODE_OK != dds_DataReaderQos_finalize(dr_qos_ptr)) {\n-        RMW_SET_ERROR_MSG(\u0022failed to finalize DataReaderQos\u0022);\n-      }\n-    });\n\u002B  auto scope_exit_qos_reset = rcpputils::make_scope_exit([dr_qos_ptr]() {\n\u002B    if (dds_RETCODE_OK != dds_DataReaderQos_finalize(dr_qos_ptr)) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize DataReaderQos\u0022);\n\u002B    }\n\u002B  });\n \n   if (dds_RETCODE_OK != dds_DataReader_get_qos(datareader, \u0026dr_qos)) {\n     RMW_SET_ERROR_MSG(\u0022failed to get DataReaderQos\u0022);\n     return RMW_RET_ERROR;\n   }\n \n-  return __add_entity(\n\u002B  return rmw_gurumdds::graph::add_entity(\n     ctx,\n     \u0026gid,\n     \u0026ctx-\u003Ecommon_ctx.gid,\n     topic_name,\n     type_name,\n\u002B    type_hash,\n     \u0026dr_qos.history,\n     \u0026dr_qos.reliability,\n     \u0026dr_qos.durability,\n@@ -284,6 \u002B272,7 @@ __add_local_subscriber(\n     true,\n     true);\n }\n\u002B}\n \n rmw_ret_t\n graph_cache_initialize(rmw_context_impl_t * const ctx)\n@@ -493,7 \u002B482,8 @@ graph_on_publisher_created(\n   GurumddsPublisherInfo * const pub)\n {\n \n-  if (__add_local_publisher(ctx, node, pub-\u003Etopic_writer, pub-\u003Epublisher_gid) != RMW_RET_OK) {\n\u002B  const rosidl_type_hash_s\u0026 type_hash = *pub-\u003Erosidl_message_typesupport-\u003Eget_type_hash_func(pub-\u003Erosidl_message_typesupport);\n\u002B  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, pub-\u003Etopic_writer, type_hash, pub-\u003Epublisher_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n@@ -505,7 \u002B495,7 @@ graph_on_publisher_created(\n     node-\u003Enamespace_);\n \n   if (graph_publish_update(ctx, reinterpret_cast\u003Cvoid *\u003E(\u0026msg)) != RMW_RET_OK) {\n-    __remove_entity(ctx, pub-\u003Epublisher_gid, false);\n\u002B    rmw_gurumdds::graph::remove_entity(ctx, pub-\u003Epublisher_gid, false);\n     static_cast\u003Cvoid\u003E(ctx-\u003Ecommon_ctx.graph_cache.dissociate_writer(\n       pub-\u003Epublisher_gid,\n       ctx-\u003Ecommon_ctx.gid,\n@@ -525,7 \u002B515,7 @@ graph_on_publisher_deleted(\n {\n   bool failed = false;\n \n-  if (__remove_entity(ctx, pub-\u003Epublisher_gid, false) != RMW_RET_OK) {\n\u002B  if (rmw_gurumdds::graph::remove_entity(ctx, pub-\u003Epublisher_gid, false) != RMW_RET_OK) {\n     RMW_SET_ERROR_MSG(\u0022failed to remove publisher from graph_cache\u0022);\n     failed = true;\n   }\n@@ -551,7 \u002B541,8 @@ graph_on_subscriber_created(\n   GurumddsSubscriberInfo * const sub)\n {\n \n-  if (__add_local_subscriber(ctx, node, sub-\u003Etopic_reader, sub-\u003Esubscriber_gid) != RMW_RET_OK) {\n\u002B  const rosidl_type_hash_s\u0026 type_hash = *sub-\u003Erosidl_message_typesupport-\u003Eget_type_hash_func(sub-\u003Erosidl_message_typesupport);\n\u002B  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, sub-\u003Etopic_reader, type_hash, sub-\u003Esubscriber_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n@@ -563,7 \u002B554,7 @@ graph_on_subscriber_created(\n     node-\u003Enamespace_);\n \n   if (graph_publish_update(ctx, reinterpret_cast\u003Cvoid *\u003E(\u0026msg)) != RMW_RET_OK) {\n-    __remove_entity(ctx, sub-\u003Esubscriber_gid, true);\n\u002B    rmw_gurumdds::graph::remove_entity(ctx, sub-\u003Esubscriber_gid, true);\n     static_cast\u003Cvoid\u003E(ctx-\u003Ecommon_ctx.graph_cache.dissociate_reader(\n       sub-\u003Esubscriber_gid,\n       ctx-\u003Ecommon_ctx.gid,\n@@ -583,7 \u002B574,7 @@ graph_on_subscriber_deleted(\n {\n   bool failed = false;\n \n-  if (__remove_entity(ctx, sub-\u003Esubscriber_gid, true) != RMW_RET_OK) {\n\u002B  if (rmw_gurumdds::graph::remove_entity(ctx, sub-\u003Esubscriber_gid, true) != RMW_RET_OK) {\n     RMW_SET_ERROR_MSG(\u0022failed to remove subscriber from graph_cache\u0022);\n     failed = true;\n   }\n@@ -618,18 \u002B609,24 @@ graph_on_service_created(\n     [ctx, pub_gid, sub_gid, add_sub, add_pub]()\n     {\n       if (add_sub) {\n-        __remove_entity(ctx, sub_gid, true);\n\u002B        rmw_gurumdds::graph::remove_entity(ctx, sub_gid, true);\n       }\n       if (add_pub) {\n-        __remove_entity(ctx, pub_gid, false);\n\u002B        rmw_gurumdds::graph::remove_entity(ctx, pub_gid, false);\n       }\n     });\n \n-  if (__add_local_subscriber(ctx, node, svc-\u003Erequest_reader, sub_gid) != RMW_RET_OK) {\n\u002B  const rosidl_message_type_support_t* type_support;\n\u002B  const rosidl_type_hash_s* type_hash;\n\u002B  type_support = svc-\u003Eservice_typesupport-\u003Erequest_typesupport;\n\u002B  type_hash = type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, svc-\u003Erequest_reader, *type_hash,  sub_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n-  if (__add_local_publisher(ctx, node, svc-\u003Eresponse_writer, pub_gid) != RMW_RET_OK) {\n\u002B  type_support = svc-\u003Eservice_typesupport-\u003Eresponse_typesupport;\n\u002B  type_hash = type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, svc-\u003Eresponse_writer, *type_hash, pub_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n@@ -675,13 \u002B672,13 @@ graph_on_service_deleted(\n {\n   bool failed = false;\n \n-  rmw_ret_t rc = __remove_entity(\n\u002B  rmw_ret_t rc = rmw_gurumdds::graph::remove_entity(\n     ctx,\n     svc-\u003Esubscriber_gid,\n     true);\n   failed = failed \u0026\u0026 (RMW_RET_OK == rc);\n \n-  rc = __remove_entity(\n\u002B  rc = rmw_gurumdds::graph::remove_entity(\n     ctx,\n     svc-\u003Epublisher_gid,\n     false);\n@@ -721,18 \u002B718,25 @@ graph_on_client_created(\n     [ctx, pub_gid, sub_gid, add_sub, add_pub]()\n     {\n       if (add_sub) {\n-        __remove_entity(ctx, sub_gid, true);\n\u002B        rmw_gurumdds::graph::remove_entity(ctx, sub_gid, true);\n       }\n       if (add_pub) {\n-        __remove_entity(ctx, pub_gid, false);\n\u002B        rmw_gurumdds::graph::remove_entity(ctx, pub_gid, false);\n       }\n     });\n \n-  if (__add_local_subscriber(ctx, node, client-\u003Eresponse_reader, sub_gid) != RMW_RET_OK) {\n\u002B\n\u002B  const rosidl_message_type_support_t* type_support;\n\u002B  const rosidl_type_hash_s* type_hash;\n\u002B  type_support = client-\u003Eservice_typesupport-\u003Eresponse_typesupport;\n\u002B  type_hash = type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (rmw_gurumdds::graph::add_local_subscriber(ctx, node, client-\u003Eresponse_reader, *type_hash, sub_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n-  if (__add_local_publisher(ctx, node, client-\u003Erequest_writer, pub_gid) != RMW_RET_OK) {\n\u002B  type_support = client-\u003Eservice_typesupport-\u003Erequest_typesupport;\n\u002B  type_hash = type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (rmw_gurumdds::graph::add_local_publisher(ctx, node, client-\u003Erequest_writer, *type_hash, pub_gid) != RMW_RET_OK) {\n     return RMW_RET_ERROR;\n   }\n \n@@ -777,13 \u002B781,13 @@ graph_on_client_deleted(\n {\n   bool failed = false;\n \n-  rmw_ret_t rc = __remove_entity(\n\u002B  rmw_ret_t rc = rmw_gurumdds::graph::remove_entity(\n     ctx,\n     client-\u003Esubscriber_gid,\n     true);\n   failed = failed \u0026\u0026 (RMW_RET_OK == rc);\n \n-  rc = __remove_entity(\n\u002B  rc = rmw_gurumdds::graph::remove_entity(\n     ctx,\n     client-\u003Epublisher_gid,\n     false);\n@@ -889,6 \u002B893,7 @@ graph_add_remote_entity(\n   const dds_GUID_t * const dp_guid,\n   const char * const topic_name,\n   const char * const type_name,\n\u002B  const dds_UserDataQosPolicy\u0026 user_data,\n   const dds_ReliabilityQosPolicy * const reliability,\n   const dds_DurabilityQosPolicy * const durability,\n   const dds_DeadlineQosPolicy * const deadline,\n@@ -906,12 \u002B911,21 @@ graph_add_remote_entity(\n     return RMW_RET_OK;\n   }\n \n-  if (RMW_RET_OK != __add_entity(\n\u002B\n\u002B  rosidl_type_hash_s type_hash;\n\u002B  if(RMW_RET_OK != rmw_dds_common::parse_type_hash_from_user_data(\n\u002B    user_data.value, user_data.size, type_hash)) {\n\u002B    type_hash = rosidl_get_zero_initialized_type_hash();\n\u002B    rmw_reset_error();\n\u002B  }\n\u002B\n\u002B  if (RMW_RET_OK != rmw_gurumdds::graph::add_entity(\n       ctx,\n       \u0026endp_gid,\n       \u0026dp_gid,\n       topic_name,\n       type_name,\n\u002B      type_hash,\n       nullptr,\n       reliability,\n       durability,\n@@ -941,5 \u002B955,5 @@ graph_remove_entity(\n     return RMW_RET_OK;\n   }\n \n-  return __remove_entity(ctx, gid, is_reader);\n\u002B  return rmw_gurumdds::graph::remove_entity(ctx, gid, is_reader);\n }\ndiff --git rmw_gurumdds_cpp/src/qos.cpp rmw_gurumdds_cpp/src/qos.cpp\nindex 52f3cd2..1200fc6 100644\n--- rmw_gurumdds_cpp/src/qos.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/qos.cpp\n@@ -14,8 \u002B14,14 @@\n \n #include \u003Climits\u003E\n \n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rosidl_runtime_c/type_hash.h\u0022\n\u002B\n #include \u0022rmw_dds_common/time_utils.hpp\u0022\n \n\u002B#include \u0022rmw_dds_common/qos.hpp\u0022\n\u002B\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n \n static inline bool is_time_unspecified(const rmw_time_t \u0026 time)\n@@ -141,8 \u002B147,8 @@ bool\n get_datawriter_qos(\n   dds_Publisher * publisher,\n   const rmw_qos_profile_t * qos_profile,\n-  dds_DataWriterQos * datawriter_qos)\n-{\n\u002B  const rosidl_type_hash_t \u0026 type_hash,\n\u002B  dds_DataWriterQos * datawriter_qos) {\n   dds_ReturnCode_t ret = dds_Publisher_get_default_datawriter_qos(publisher, datawriter_qos);\n   if (ret != dds_RETCODE_OK) {\n     RMW_SET_ERROR_MSG(\u0022failed to get default datawriter qos\u0022);\n@@ -155,12 \u002B161,23 @@ get_datawriter_qos(\n \n   set_entity_qos_from_profile_generic(qos_profile, datawriter_qos);\n \n\u002B  std::string user_data_str;\n\u002B  if (RMW_RET_OK != rmw_dds_common::encode_type_hash_for_user_data_qos(type_hash, user_data_str)) {\n\u002B    user_data_str.clear();\n\u002B    // Since we are going to go on without a hash, we clear the error so other\n\u002B    // code won\u0027t overwrite it.\n\u002B    rmw_reset_error();\n\u002B  }\n\u002B\n\u002B  memcpy(datawriter_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n\u002B\n   return true;\n }\n \n bool get_datareader_qos(\n   dds_Subscriber * subscriber,\n   const rmw_qos_profile_t * qos_profile,\n\u002B  const rosidl_type_hash_t \u0026 type_hash,\n   dds_DataReaderQos * datareader_qos)\n {\n   dds_ReturnCode_t ret = dds_Subscriber_get_default_datareader_qos(subscriber, datareader_qos);\n@@ -171,6 \u002B188,17 @@ bool get_datareader_qos(\n \n   set_entity_qos_from_profile_generic(qos_profile, datareader_qos);\n \n\u002B\n\u002B  std::string user_data_str;\n\u002B  if (RMW_RET_OK != rmw_dds_common::encode_type_hash_for_user_data_qos(type_hash, user_data_str)) {\n\u002B    user_data_str.clear();\n\u002B    // Since we are going to go on without a hash, we clear the error so other\n\u002B    // code won\u0027t overwrite it.\n\u002B    rmw_reset_error();\n\u002B  }\n\u002B\n\u002B  memcpy(datareader_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n\u002B\n   return true;\n }\n \ndiff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex 249b807..11d1bce 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -123,6 \u002B123,7 @@ rmw_create_client(\n   std::string response_type_name;\n   std::string request_metastring;\n   std::string response_metastring;\n\u002B  const rosidl_type_hash_t* type_hash;\n \n   // Create topic and type name strings\n   service_type_name =\n@@ -262,7 \u002B263,8 @@ rmw_create_client(\n   }\n \n   // Create datawriter for request\n-  if (!get_datawriter_qos(publisher, qos_policies, \u0026datawriter_qos)) {\n\u002B  type_hash = type_support-\u003Erequest_typesupport-\u003Eget_type_hash_func(type_support-\u003Erequest_typesupport);\n\u002B  if (!get_datawriter_qos(publisher, qos_policies, *type_hash, \u0026datawriter_qos)) {\n     // Error message already set\n     goto fail;\n   }\n@@ -282,7 \u002B284,8 @@ rmw_create_client(\n     goto fail;\n   }\n \n-  if (!get_datareader_qos(subscriber, qos_policies, \u0026datareader_qos)) {\n\u002B  type_hash = type_support-\u003Eresponse_typesupport-\u003Eget_type_hash_func(type_support-\u003Eresponse_typesupport);\n\u002B  if (!get_datareader_qos(subscriber, qos_policies, *type_hash, \u0026datareader_qos)) {\n     // error message already set\n     goto fail;\n   }\ndiff --git rmw_gurumdds_cpp/src/rmw_publisher.cpp rmw_gurumdds_cpp/src/rmw_publisher.cpp\nindex ecc5609..13696cc 100644\n--- rmw_gurumdds_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_publisher.cpp\n@@ -138,7 \u002B138,8 @@ __rmw_create_publisher(\n     }\n   }\n \n-  if (!get_datawriter_qos(pub, qos_policies, \u0026datawriter_qos)) {\n\u002B  const rosidl_type_hash_t\u0026 type_hash = *type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (!get_datawriter_qos(pub, qos_policies, type_hash, \u0026datawriter_qos)) {\n     // Error message already set\n     return nullptr;\n   }\ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex 475dfad..1c623ed 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -120,6 \u002B120,8 @@ rmw_create_service(\n   std::string request_metastring;\n   std::string response_metastring;\n \n\u002B  const rosidl_type_hash_t* type_hash;\n\u002B\n   // Create topic and type name strings\n   service_type_name =\n     create_service_type_name(type_support-\u003Edata, type_support-\u003Etypesupport_identifier);\n@@ -257,7 \u002B259,8 @@ rmw_create_service(\n     }\n   }\n \n-  if (!get_datareader_qos(subscriber, qos_policies, \u0026datareader_qos)) {\n\u002B  type_hash = type_support-\u003Erequest_typesupport-\u003Eget_type_hash_func(type_support-\u003Erequest_typesupport);\n\u002B  if (!get_datareader_qos(subscriber, qos_policies, *type_hash, \u0026datareader_qos)) {\n     // Error message already set\n     goto fail;\n   }\n@@ -285,7 \u002B288,8 @@ rmw_create_service(\n   }\n   service_info-\u003Eread_condition = read_condition;\n \n-  if (!get_datawriter_qos(publisher, qos_policies, \u0026datawriter_qos)) {\n\u002B  type_hash = type_support-\u003Eresponse_typesupport-\u003Eget_type_hash_func(type_support-\u003Eresponse_typesupport);\n\u002B  if (!get_datawriter_qos(publisher, qos_policies, *type_hash, \u0026datawriter_qos)) {\n     // Error message already set\n     goto fail;\n   }\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex 8aaa3ee..f24dfb4 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -139,7 \u002B139,8 @@ __rmw_create_subscription(\n     }\n   }\n \n-  if (!get_datareader_qos(sub, qos_policies, \u0026datareader_qos)) {\n\u002B  const rosidl_type_hash_t\u0026 type_hash = *type_support-\u003Eget_type_hash_func(type_support);\n\u002B  if (!get_datareader_qos(sub, qos_policies, type_hash, \u0026datareader_qos)) {\n     // Error message already set\n     return nullptr;\n   }\ndiff --git rmw_gurumdds_cpp/src/types.cpp rmw_gurumdds_cpp/src/types.cpp\nindex 23a2c8c..7164d3b 100644\n--- rmw_gurumdds_cpp/src/types.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/types.cpp\n@@ -274,6 \u002B274,7 @@ void on_publication_changed(\n       \u0026dp_guid,\n       data-\u003Etopic_name,\n       data-\u003Etype_name,\n\u002B      data-\u003Euser_data,\n       \u0026data-\u003Ereliability,\n       \u0026data-\u003Edurability,\n       \u0026data-\u003Edeadline,\n@@ -337,6 \u002B338,7 @@ void on_subscription_changed(\n       \u0026dp_guid,\n       data-\u003Etopic_name,\n       data-\u003Etype_name,\n\u002B      data-\u003Euser_data,\n       \u0026data-\u003Ereliability,\n       \u0026data-\u003Edurability,\n       \u0026data-\u003Edeadline,\n",
    "IsBackported": false
  },
  {
    "Repository": "rcpputils",
    "SHA": "c730cb7bcb50a7583b8502aa0e3edbb0028a476d",
    "RawMessage": "Add clamp header (#85)",
    "Changes": "diff --git CMakeLists.txt CMakeLists.txt\nindex 5c9310f..8bdd256 100644\n--- CMakeLists.txt\n\u002B\u002B\u002B CMakeLists.txt\n@@ -115,6 \u002B115,8 @@ if(BUILD_TESTING)\n   set_tests_properties(test_find_library PROPERTIES\n     ENVIRONMENT\n       \u0022_TEST_LIBRARY_DIR=$\u003CTARGET_FILE_DIR:test_library\u003E;_TEST_LIBRARY=$\u003CTARGET_FILE:test_library\u003E\u0022)\n\u002B\n\u002B  ament_add_gtest(test_clamp test/test_clamp.cpp)\n endif()\n \n ament_package()\ndiff --git include/rcppmath/clamp.hpp include/rcppmath/clamp.hpp\nnew file mode 100644\nindex 0000000..a25067c\n--- /dev/null\n\u002B\u002B\u002B include/rcppmath/clamp.hpp\n@@ -0,0 \u002B1,59 @@\n\u002B// Copyright 2020 PAL Robotics S.L.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B/*! \\file clamp.hpp\n\u002B * \\brief Restrict a value between two bounds\n\u002B */\n\u002B\n\u002B#ifndef RCPPMATH__CLAMP_HPP_\n\u002B#define RCPPMATH__CLAMP_HPP_\n\u002B\n\u002B#include \u003Ccassert\u003E\n\u002B\n\u002Bnamespace rcppmath\n\u002B{\n\u002B/// If v compares less than lo, returns lo; otherwise if hi compares less\n\u002B//  than v, returns hi; otherwise returns v. Uses operator\u003C to compare the values\n\u002B/**\n\u002B * \\param[in] v the value to clamp\n\u002B * \\param[in] lo the lower boundary\n\u002B * \\param[in] hi the higher boundary\n\u002B * \\return Reference to lo if v is less than lo, reference to hi if hi is less than v, otherwise\n\u002B * reference to v.\n\u002B * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp\n\u002B * \\warning Capturing the result of clamp by reference if one of the parameters is rvalue produces\n\u002B *  a dangling reference if that parameter is returned\n\u002B **/\n\u002Btemplate\u003Cclass T\u003E\n\u002Bconstexpr const T \u0026 clamp(const T \u0026 v, const T \u0026 lo, const T \u0026 hi)\n\u002B{\n\u002B  assert(!(hi \u003C lo) );\n\u002B  return (v \u003C lo) ? lo : (hi \u003C v) ? hi : v;\n\u002B}\n\u002B\n\u002B/// Like the function above, but uses comp to compare the values.\n\u002B/**\n\u002B * \\param[in] comp Comparison object that returns true if the first argument is\n\u002B * less than the second\n\u002B **/\n\u002Btemplate\u003Cclass T, class Compare\u003E\n\u002Bconstexpr const T \u0026 clamp(const T \u0026 v, const T \u0026 lo, const T \u0026 hi, Compare comp)\n\u002B{\n\u002B  assert(!comp(hi, lo) );\n\u002B  return comp(v, lo) ? lo : comp(hi, v) ? hi : v;\n\u002B}\n\u002B\n\u002B}  // namespace rcppmath\n\u002B\n\u002B#endif  // RCPPMATH__CLAMP_HPP_\ndiff --git test/test_clamp.cpp test/test_clamp.cpp\nnew file mode 100644\nindex 0000000..c6563be\n--- /dev/null\n\u002B\u002B\u002B test/test_clamp.cpp\n@@ -0,0 \u002B1,52 @@\n\u002B// Copyright 2020 PAL Robotics S.L.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Climits\u003E\n\u002B\n\u002B#include \u0022rcppmath/clamp.hpp\u0022\n\u002B\n\u002BTEST(test_clamp, test_basic) {\n\u002B  EXPECT_EQ(rcppmath::clamp(1, 2, 5), 2);\n\u002B  EXPECT_EQ(rcppmath::clamp(2, 2, 5), 2);\n\u002B  EXPECT_EQ(rcppmath::clamp(5, 2, 5), 5);\n\u002B  EXPECT_EQ(rcppmath::clamp(6, 2, 5), 5);\n\u002B  EXPECT_EQ(rcppmath::clamp(3, 2, 5), 3);\n\u002B  EXPECT_EQ(rcppmath::clamp(4, 2, 5), 4);\n\u002B}\n\u002B\n\u002BTEST(test_clamp, test_cmp) {\n\u002B  auto cmp = [](const int \u0026 a, const int \u0026 b)\n\u002B    {\n\u002B      return a \u003C b;\n\u002B    };\n\u002B  EXPECT_EQ(rcppmath::clamp(1, 2, 5, cmp), 2);\n\u002B  EXPECT_EQ(rcppmath::clamp(2, 2, 5, cmp), 2);\n\u002B  EXPECT_EQ(rcppmath::clamp(5, 2, 5, cmp), 5);\n\u002B  EXPECT_EQ(rcppmath::clamp(6, 2, 5, cmp), 5);\n\u002B  EXPECT_EQ(rcppmath::clamp(3, 2, 5, cmp), 3);\n\u002B  EXPECT_EQ(rcppmath::clamp(4, 2, 5, cmp), 4);\n\u002B}\n\u002BTEST(test_clamp, test_limits) {\n\u002B  EXPECT_EQ(rcppmath::clamp(std::numeric_limits\u003Cdouble\u003E::infinity(), 0.0, 1.0), 1.0);\n\u002B  EXPECT_EQ(rcppmath::clamp(-std::numeric_limits\u003Cdouble\u003E::infinity(), 0.0, 1.0), 0.0);\n\u002B\n\u002B  // Nan\u0027s are not limited by clamp, and return a nan, which is not comparable to itself\n\u002B  EXPECT_NE(rcppmath::clamp(std::numeric_limits\u003Cdouble\u003E::quiet_NaN(), 0.0, 1.0), 0.0);\n\u002B  EXPECT_NE(rcppmath::clamp(std::numeric_limits\u003Cdouble\u003E::quiet_NaN(), 0.0, 1.0), 1.0);\n\u002B  EXPECT_NE(\n\u002B    rcppmath::clamp(\n\u002B      std::numeric_limits\u003Cdouble\u003E::quiet_NaN(), 0.0, 1.0),\n\u002B    std::numeric_limits\u003Cdouble\u003E::quiet_NaN());\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "b06baefa0b0cebd293b1dec90627641257de1db3",
    "RawMessage": "Add types to TypeHash and moved away from __slots__ usage (#1232)",
    "Changes": "diff --git rclpy/rclpy/type_hash.py rclpy/rclpy/type_hash.py\nindex f2f3ea4..30b4e0b 100644\n--- rclpy/rclpy/type_hash.py\n\u002B\u002B\u002B rclpy/rclpy/type_hash.py\n@@ -18,56 \u002B18,44 @@ class TypeHash:\n \n     _TYPE_HASH_SIZE = 32\n \n-    __slots__ = [\n-        \u0027_version\u0027,\n-        \u0027_value\u0027,\n-    ]\n-\n-    def __init__(self, **kwargs):\n-        assert all(\u0027_\u0027 \u002B key in self.__slots__ for key in kwargs.keys()), \\\n-            \u0027Invalid arguments passed to constructor: %r\u0027 % kwargs.keys()\n-\n-        self.version = kwargs.get(\u0027version\u0027, -1)\n-        self.value = kwargs.get(\u0027value\u0027, bytes(self._TYPE_HASH_SIZE))\n\u002B    def __init__(self, version: int = -1, value: bytes = bytes(_TYPE_HASH_SIZE)):\n\u002B        self.version = version\n\u002B        self.value = value\n \n     @property\n-    def version(self):\n\u002B    def version(self) -\u003E int:\n         \u0022\u0022\u0022\n         Get field \u0027version\u0027.\n \n         :returns: version attribute\n-        :rtype: int\n         \u0022\u0022\u0022\n         return self._version\n \n     @version.setter\n-    def version(self, value):\n\u002B    def version(self, value: int) -\u003E None:\n         assert isinstance(value, int)\n         self._version = value\n \n     @property\n-    def value(self):\n\u002B    def value(self) -\u003E bytes:\n         \u0022\u0022\u0022\n         Get field \u0027value\u0027.\n \n         :returns: value attribute\n-        :rtype: bytes\n         \u0022\u0022\u0022\n         return self._value\n \n     @value.setter\n-    def value(self, value):\n\u002B    def value(self, value: bytes) -\u003E None:\n         assert isinstance(value, bytes)\n         self._value = value\n \n-    def __eq__(self, other):\n\u002B    def __eq__(self, other: object) -\u003E bool:\n         if not isinstance(other, TypeHash):\n             return False\n-        return all(\n-            self.__getattribute__(slot) == other.__getattribute__(slot)\n-            for slot in self.__slots__)\n\u002B        return self.__dict__ == other.__dict__\n \n-    def __str__(self):\n\u002B    def __str__(self) -\u003E str:\n         if self._version \u003C= 0 or len(self._value) != self._TYPE_HASH_SIZE:\n             return \u0027INVALID\u0027\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "75c51c945d6029bea61571ced43c1d1b9c3c6703",
    "RawMessage": "Destroy event handlers owned by publishers/subscriptions when calling publisher.destroy()/subscription.destroy() (#603)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex 9f78664..52b129c 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -1392,6 \u002B1392,8 @@ class Node:\n         \u0022\u0022\u0022\n         if publisher in self.__publishers:\n             self.__publishers.remove(publisher)\n\u002B            for event_handler in publisher.event_handlers:\n\u002B                self.__waitables.remove(event_handler)\n             try:\n                 publisher.destroy()\n             except InvalidHandle:\n@@ -1408,6 \u002B1410,8 @@ class Node:\n         \u0022\u0022\u0022\n         if subscription in self.__subscriptions:\n             self.__subscriptions.remove(subscription)\n\u002B            for event_handler in subscription.event_handlers:\n\u002B                self.__waitables.remove(event_handler)\n             try:\n                 subscription.destroy()\n             except InvalidHandle:\ndiff --git rclpy/rclpy/publisher.py rclpy/rclpy/publisher.py\nindex e702b9d..f0e0d48 100644\n--- rclpy/rclpy/publisher.py\n\u002B\u002B\u002B rclpy/rclpy/publisher.py\n@@ -19,6 \u002B19,7 @@ from rclpy.handle import Handle\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n from rclpy.qos_event import PublisherEventCallbacks\n\u002Bfrom rclpy.qos_event import QoSEventHandler\n \n MsgType = TypeVar(\u0027MsgType\u0027)\n \n@@ -53,7 \u002B54,7 @@ class Publisher:\n         self.topic = topic\n         self.qos_profile = qos_profile\n \n-        self.event_handlers = event_callbacks.create_event_handlers(\n\u002B        self.event_handlers: QoSEventHandler = event_callbacks.create_event_handlers(\n             callback_group, publisher_handle)\n \n     def publish(self, msg: Union[MsgType, bytes]) -\u003E None:\n@@ -87,6 \u002B88,8 @@ class Publisher:\n         return self.__handle\n \n     def destroy(self):\n\u002B        for handler in self.event_handlers:\n\u002B            handler.destroy()\n         self.handle.destroy()\n \n     def assert_liveliness(self) -\u003E None:\ndiff --git rclpy/rclpy/qos_event.py rclpy/rclpy/qos_event.py\nindex c802a0c..88bbeb6 100644\n--- rclpy/rclpy/qos_event.py\n\u002B\u002B\u002B rclpy/rclpy/qos_event.py\n@@ -188,7 \u002B188,9 @@ class QoSEventHandler(Waitable):\n         \u0022\u0022\u0022Add entites to wait set.\u0022\u0022\u0022\n         with self._event_handle as event_capsule:\n             self._event_index = _rclpy.rclpy_wait_set_add_entity(\u0027event\u0027, wait_set, event_capsule)\n-    # End Waitable API\n\u002B\n\u002B    def destroy(self):\n\u002B        self._event_handle.destroy()\n \n \n class SubscriptionEventCallbacks:\ndiff --git rclpy/rclpy/subscription.py rclpy/rclpy/subscription.py\nindex 0d8424a..b51c037 100644\n--- rclpy/rclpy/subscription.py\n\u002B\u002B\u002B rclpy/rclpy/subscription.py\n@@ -19,6 \u002B19,7 @@ from rclpy.callback_groups import CallbackGroup\n from rclpy.handle import Handle\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n\u002Bfrom rclpy.qos_event import QoSEventHandler\n from rclpy.qos_event import SubscriptionEventCallbacks\n \n \n@@ -67,7 \u002B68,7 @@ class Subscription:\n         self.qos_profile = qos_profile\n         self.raw = raw\n \n-        self.event_handlers = event_callbacks.create_event_handlers(\n\u002B        self.event_handlers: QoSEventHandler = event_callbacks.create_event_handlers(\n             callback_group, subscription_handle)\n \n     @property\n@@ -75,6 \u002B76,8 @@ class Subscription:\n         return self.__handle\n \n     def destroy(self):\n\u002B        for handler in self.event_handlers:\n\u002B            handler.destroy()\n         self.handle.destroy()\n \n     @property\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "0479d5d17ee0f7ccad2b30835d464d5aaa19bb65",
    "RawMessage": "Use local git config instead of global (#693)",
    "Changes": "diff --git ros2pkg/ros2pkg/verb/create.py ros2pkg/ros2pkg/verb/create.py\nindex b4f4468..35f9d1c 100644\n--- ros2pkg/ros2pkg/verb/create.py\n\u002B\u002B\u002B ros2pkg/ros2pkg/verb/create.py\n@@ -106,7 \u002B106,7 @@ class CreateVerb(VerbExtension):\n             git = shutil.which(\u0027git\u0027)\n             if git is not None:\n                 p = subprocess.Popen(\n-                    [git, \u0027config\u0027, \u0027--global\u0027, \u0027user.email\u0027],\n\u002B                    [git, \u0027config\u0027, \u0027user.email\u0027],\n                     stdout=subprocess.PIPE)\n                 resp = p.communicate()\n                 email = resp[0].decode().rstrip()\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "cf2f2ff164505f8f45f9a39347f7d2ebecffb9c1",
    "RawMessage": "Change g_mask_map_ptr type to array of dds_StatusKind",
    "Changes": "diff --git rmw_gurumdds_shared_cpp/src/event_converter.cpp rmw_gurumdds_shared_cpp/src/event_converter.cpp\nindex 492fd56..a3dabc5 100644\n--- rmw_gurumdds_shared_cpp/src/event_converter.cpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/src/event_converter.cpp\n@@ -12,40 \u002B12,33 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Cunordered_map\u003E\n-#include \u003Cmemory\u003E\n #include \u003Cutility\u003E\n \n #include \u0022rmw_gurumdds_shared_cpp/event_converter.hpp\u0022\n \n /// mapping of RMW_EVENT to the corresponding dds_StatusKind.\n-static std::shared_ptr\u003Cstd::unordered_map\u003Crmw_event_type_t, dds_StatusKind, std::hash\u003Cint\u003E\u003E\u003E\n-g_mask_map_ptr {new std::unordered_map\u003Crmw_event_type_t, dds_StatusKind, std::hash\u003Cint\u003E\u003E {\n-    {RMW_EVENT_LIVELINESS_CHANGED, dds_LIVELINESS_CHANGED_STATUS},\n-    {RMW_EVENT_REQUESTED_DEADLINE_MISSED, dds_REQUESTED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE, dds_REQUESTED_INCOMPATIBLE_QOS_STATUS},\n-    {RMW_EVENT_MESSAGE_LOST, dds_SAMPLE_LOST_STATUS},\n-    {RMW_EVENT_LIVELINESS_LOST, dds_LIVELINESS_LOST_STATUS},\n-    {RMW_EVENT_OFFERED_DEADLINE_MISSED, dds_OFFERED_DEADLINE_MISSED_STATUS},\n-    {RMW_EVENT_OFFERED_QOS_INCOMPATIBLE, dds_OFFERED_INCOMPATIBLE_QOS_STATUS},\n-  }};\n\u002Bstatic const dds_StatusKind g_mask_map[] {\n\u002B  dds_LIVELINESS_CHANGED_STATUS,  // RMW_EVENT_LIVELINESS_CHANGED\n\u002B  dds_REQUESTED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_REQUESTED_DEADLINE_MISSED\n\u002B  dds_REQUESTED_INCOMPATIBLE_QOS_STATUS,  // RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE\n\u002B  dds_SAMPLE_LOST_STATUS,  // RMW_EVENT_MESSAGE_LOST\n\u002B  dds_LIVELINESS_LOST_STATUS,  // RMW_EVENT_LIVELINESS_LOST\n\u002B  dds_OFFERED_DEADLINE_MISSED_STATUS,  // RMW_EVENT_OFFERED_DEADLINE_MISSED\n\u002B  dds_OFFERED_INCOMPATIBLE_QOS_STATUS  // RMW_EVENT_OFFERED_QOS_INCOMPATIBLE\n\u002B};\n \n dds_StatusKind get_status_kind_from_rmw(const rmw_event_type_t event_t)\n {\n-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n\u002B  if (!is_event_supported(event_t)) {\n     return 0;\n   }\n-  return mask_map_ptr-\u003Eat(event_t);\n\u002B\n\u002B  return g_mask_map[static_cast\u003Cint\u003E(event_t)];\n }\n \n bool is_event_supported(const rmw_event_type_t event_t)\n {\n-  auto mask_map_ptr{g_mask_map_ptr};\n-  if (mask_map_ptr == nullptr) {\n-    return false;\n-  }\n-  return mask_map_ptr-\u003Ecount(event_t) \u003E 0;\n\u002B  return 0 \u003C= event_t \u0026\u0026 event_t \u003C RMW_EVENT_INVALID;\n }\n \n rmw_ret_t check_dds_ret_code(const dds_ReturnCode_t dds_return_code)\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "fce021b14967f691340a6e90b15bdaa37a2008bd",
    "RawMessage": "Feature/available capacity of ipm (#2173)",
    "Changes": "diff --git rclcpp/include/rclcpp/experimental/buffers/buffer_implementation_base.hpp rclcpp/include/rclcpp/experimental/buffers/buffer_implementation_base.hpp\nindex 1e534611..83a6c746 100644\n--- rclcpp/include/rclcpp/experimental/buffers/buffer_implementation_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/buffers/buffer_implementation_base.hpp\n@@ -33,6 \u002B33,7 @@ public:\n \n   virtual void clear() = 0;\n   virtual bool has_data() const = 0;\n\u002B  virtual size_t available_capacity() const = 0;\n };\n \n }  // namespace buffers\ndiff --git rclcpp/include/rclcpp/experimental/buffers/intra_process_buffer.hpp rclcpp/include/rclcpp/experimental/buffers/intra_process_buffer.hpp\nindex 05092bb2..af936cb3 100644\n--- rclcpp/include/rclcpp/experimental/buffers/intra_process_buffer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/buffers/intra_process_buffer.hpp\n@@ -44,6 \u002B44,7 @@ public:\n \n   virtual bool has_data() const = 0;\n   virtual bool use_take_shared_method() const = 0;\n\u002B  virtual size_t available_capacity() const = 0;\n };\n \n template\u003C\n@@ -143,6 \u002B144,11 @@ public:\n     return std::is_same\u003CBufferT, MessageSharedPtr\u003E::value;\n   }\n \n\u002B  size_t available_capacity() const override\n\u002B  {\n\u002B    return buffer_-\u003Eavailable_capacity();\n\u002B  }\n\u002B\n private:\n   std::unique_ptr\u003CBufferImplementationBase\u003CBufferT\u003E\u003E buffer_;\n \ndiff --git rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\nindex 2c06ea6c..5c6ba592 100644\n--- rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\n@@ -148,6 \u002B148,18 @@ public:\n     return is_full_();\n   }\n \n\u002B  /// Get the remaining capacity to store messages\n\u002B  /**\n\u002B   * This member function is thread-safe.\n\u002B   *\n\u002B   * \\return the number of free capacity for new messages\n\u002B   */\n\u002B  size_t available_capacity() const\n\u002B  {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B    return available_capacity_();\n\u002B  }\n\u002B\n   void clear()\n   {\n     TRACEPOINT(rclcpp_ring_buffer_clear, static_cast\u003Cconst void *\u003E(this));\n@@ -189,6 \u002B201,17 @@ private:\n     return size_ == capacity_;\n   }\n \n\u002B  /// Get the remaining capacity to store messages\n\u002B  /**\n\u002B   * This member function is not thread-safe.\n\u002B   *\n\u002B   * \\return the number of free capacity for new messages\n\u002B   */\n\u002B  inline size_t available_capacity_() const\n\u002B  {\n\u002B    return capacity_ - size_;\n\u002B  }\n\u002B\n   size_t capacity_;\n \n   std::vector\u003CBufferT\u003E ring_buffer_;\ndiff --git rclcpp/include/rclcpp/experimental/intra_process_manager.hpp rclcpp/include/rclcpp/experimental/intra_process_manager.hpp\nindex 11f2dda6..a152632a 100644\n--- rclcpp/include/rclcpp/experimental/intra_process_manager.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/intra_process_manager.hpp\n@@ -306,6 \u002B306,11 @@ public:\n   rclcpp::experimental::SubscriptionIntraProcessBase::SharedPtr\n   get_subscription_intra_process(uint64_t intra_process_subscription_id);\n \n\u002B  /// Return the lowest available capacity for all subscription buffers for a publisher id.\n\u002B  RCLCPP_PUBLIC\n\u002B  size_t\n\u002B  lowest_available_capacity(const uint64_t intra_process_publisher_id) const;\n\u002B\n private:\n   struct SplittedSubscriptions\n   {\ndiff --git rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\nindex 6583e74a..c590207b 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process_base.hpp\n@@ -62,6 \u002B62,11 @@ public:\n   void\n   add_to_wait_set(rcl_wait_set_t * wait_set) override;\n \n\u002B  RCLCPP_PUBLIC\n\u002B  virtual\n\u002B  size_t\n\u002B  available_capacity() const = 0;\n\u002B\n   bool\n   is_ready(rcl_wait_set_t * wait_set) override = 0;\n \ndiff --git rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\nindex 30debed8..16c4b6a8 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process_buffer.hpp\n@@ -169,6 \u002B169,11 @@ public:\n     return buffer_-\u003Euse_take_shared_method();\n   }\n \n\u002B  size_t available_capacity() const override\n\u002B  {\n\u002B    return buffer_-\u003Eavailable_capacity();\n\u002B  }\n\u002B\n protected:\n   void\n   trigger_guard_condition() override\ndiff --git rclcpp/include/rclcpp/publisher_base.hpp rclcpp/include/rclcpp/publisher_base.hpp\nindex d9181bea..32535953 100644\n--- rclcpp/include/rclcpp/publisher_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/publisher_base.hpp\n@@ -215,6 \u002B215,17 @@ public:\n   std::vector\u003Crclcpp::NetworkFlowEndpoint\u003E\n   get_network_flow_endpoints() const;\n \n\u002B  /// Return the lowest available capacity for all subscription buffers.\n\u002B  /**\n\u002B   * For intraprocess communication return the lowest buffer capacity for all subscriptions.\n\u002B   * If intraprocess is disabled or no intraprocess subscriptions present, return maximum of size_t.\n\u002B   * On failure return 0.\n\u002B   * \\return lowest buffer capacity for all subscriptions\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  size_t\n\u002B  lowest_available_ipm_capacity() const;\n\u002B\n   /// Wait until all published messages are acknowledged or until the specified timeout elapses.\n   /**\n    * This method waits until all published messages are acknowledged by all matching\ndiff --git rclcpp/src/rclcpp/intra_process_manager.cpp rclcpp/src/rclcpp/intra_process_manager.cpp\nindex efce4afe..ea068f03 100644\n--- rclcpp/src/rclcpp/intra_process_manager.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/intra_process_manager.cpp\n@@ -225,5 \u002B225,52 @@ IntraProcessManager::can_communicate(\n   return true;\n }\n \n\u002Bsize_t\n\u002BIntraProcessManager::lowest_available_capacity(const uint64_t intra_process_publisher_id) const\n\u002B{\n\u002B  size_t capacity = std::numeric_limits\u003Csize_t\u003E::max();\n\u002B\n\u002B  auto publisher_it = pub_to_subs_.find(intra_process_publisher_id);\n\u002B  if (publisher_it == pub_to_subs_.end()) {\n\u002B    // Publisher is either invalid or no longer exists.\n\u002B    RCLCPP_WARN(\n\u002B      rclcpp::get_logger(\u0022rclcpp\u0022),\n\u002B      \u0022Calling lowest_available_capacity for invalid or no longer existing publisher id\u0022);\n\u002B    return 0u;\n\u002B  }\n\u002B\n\u002B  if (publisher_it-\u003Esecond.take_shared_subscriptions.empty() \u0026\u0026\n\u002B    publisher_it-\u003Esecond.take_ownership_subscriptions.empty())\n\u002B  {\n\u002B    // no subscriptions available\n\u002B    return 0u;\n\u002B  }\n\u002B\n\u002B  auto available_capacity = [this, \u0026capacity](const uint64_t intra_process_subscription_id)\n\u002B    {\n\u002B      auto subscription_it = subscriptions_.find(intra_process_subscription_id);\n\u002B      if (subscription_it != subscriptions_.end()) {\n\u002B        auto subscription = subscription_it-\u003Esecond.lock();\n\u002B        if (subscription) {\n\u002B          capacity = std::min(capacity, subscription-\u003Eavailable_capacity());\n\u002B        }\n\u002B      } else {\n\u002B        // Subscription is either invalid or no longer exists.\n\u002B        RCLCPP_WARN(\n\u002B          rclcpp::get_logger(\u0022rclcpp\u0022),\n\u002B          \u0022Calling available_capacity for invalid or no longer existing subscription id\u0022);\n\u002B      }\n\u002B    };\n\u002B\n\u002B  for (const auto sub_id : publisher_it-\u003Esecond.take_shared_subscriptions) {\n\u002B    available_capacity(sub_id);\n\u002B  }\n\u002B\n\u002B  for (const auto sub_id : publisher_it-\u003Esecond.take_ownership_subscriptions) {\n\u002B    available_capacity(sub_id);\n\u002B  }\n\u002B\n\u002B  return capacity;\n\u002B}\n }  // namespace experimental\n }  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/publisher_base.cpp rclcpp/src/rclcpp/publisher_base.cpp\nindex 698db2d5..0e37dcf3 100644\n--- rclcpp/src/rclcpp/publisher_base.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/publisher_base.cpp\n@@ -384,3 \u002B384,22 @@ std::vector\u003Crclcpp::NetworkFlowEndpoint\u003E PublisherBase::get_network_flow_endpoin\n \n   return network_flow_endpoint_vector;\n }\n\u002B\n\u002Bsize_t PublisherBase::lowest_available_ipm_capacity() const\n\u002B{\n\u002B  if (!intra_process_is_enabled_) {\n\u002B    return 0u;\n\u002B  }\n\u002B\n\u002B  auto ipm = weak_ipm_.lock();\n\u002B\n\u002B  if (!ipm) {\n\u002B    // TODO(ivanpauno): should this raise an error?\n\u002B    RCLCPP_WARN(\n\u002B      rclcpp::get_logger(\u0022rclcpp\u0022),\n\u002B      \u0022Intra process manager died for a publisher.\u0022);\n\u002B    return 0u;\n\u002B  }\n\u002B\n\u002B  return ipm-\u003Elowest_available_capacity(intra_process_publisher_id_);\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_intra_process_buffer.cpp rclcpp/test/rclcpp/test_intra_process_buffer.cpp\nindex 16c457c9..eace6445 100644\n--- rclcpp/test/rclcpp/test_intra_process_buffer.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_intra_process_buffer.cpp\n@@ -238,3 \u002B238,75 @@ TEST(TestIntraProcessBuffer, unique_buffer_consume) {\n   EXPECT_EQ(original_value, *popped_unique_msg);\n   EXPECT_EQ(original_message_pointer, popped_message_pointer);\n }\n\u002B\n\u002B/*\n\u002B  Check the available buffer capacity while storing and consuming data from an intra-process\n\u002B  buffer.\n\u002B  The initial available buffer capacity should equal the buffer size.\n\u002B  Inserting a message should decrease the available buffer capacity by 1.\n\u002B  Consuming a message should increase the available buffer capacity by 1.\n\u002B */\n\u002BTEST(TestIntraProcessBuffer, available_capacity) {\n\u002B  using MessageT = char;\n\u002B  using Alloc = std::allocator\u003Cvoid\u003E;\n\u002B  using Deleter = std::default_delete\u003CMessageT\u003E;\n\u002B  using SharedMessageT = std::shared_ptr\u003Cconst MessageT\u003E;\n\u002B  using UniqueMessageT = std::unique_ptr\u003CMessageT, Deleter\u003E;\n\u002B  using UniqueIntraProcessBufferT = rclcpp::experimental::buffers::TypedIntraProcessBuffer\u003C\n\u002B    MessageT, Alloc, Deleter, UniqueMessageT\u003E;\n\u002B\n\u002B  constexpr auto history_depth = 5u;\n\u002B\n\u002B  auto buffer_impl =\n\u002B    std::make_unique\u003Crclcpp::experimental::buffers::RingBufferImplementation\u003CUniqueMessageT\u003E\u003E(\n\u002B    history_depth);\n\u002B\n\u002B  UniqueIntraProcessBufferT intra_process_buffer(std::move(buffer_impl));\n\u002B\n\u002B  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n\u002B\n\u002B  auto original_unique_msg = std::make_unique\u003Cchar\u003E(\u0027a\u0027);\n\u002B  auto original_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(original_unique_msg.get());\n\u002B  auto original_value = *original_unique_msg;\n\u002B\n\u002B  intra_process_buffer.add_unique(std::move(original_unique_msg));\n\u002B\n\u002B  EXPECT_EQ(history_depth - 1u, intra_process_buffer.available_capacity());\n\u002B\n\u002B  SharedMessageT popped_shared_msg;\n\u002B  popped_shared_msg = intra_process_buffer.consume_shared();\n\u002B  auto popped_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(popped_shared_msg.get());\n\u002B\n\u002B  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n\u002B  EXPECT_EQ(original_value, *popped_shared_msg);\n\u002B  EXPECT_EQ(original_message_pointer, popped_message_pointer);\n\u002B\n\u002B  original_unique_msg = std::make_unique\u003Cchar\u003E(\u0027b\u0027);\n\u002B  original_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(original_unique_msg.get());\n\u002B  original_value = *original_unique_msg;\n\u002B\n\u002B  intra_process_buffer.add_unique(std::move(original_unique_msg));\n\u002B\n\u002B  auto second_unique_msg = std::make_unique\u003Cchar\u003E(\u0027c\u0027);\n\u002B  auto second_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(second_unique_msg.get());\n\u002B  auto second_value = *second_unique_msg;\n\u002B\n\u002B  intra_process_buffer.add_unique(std::move(second_unique_msg));\n\u002B\n\u002B  EXPECT_EQ(history_depth - 2u, intra_process_buffer.available_capacity());\n\u002B\n\u002B  UniqueMessageT popped_unique_msg;\n\u002B  popped_unique_msg = intra_process_buffer.consume_unique();\n\u002B  popped_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(popped_unique_msg.get());\n\u002B\n\u002B  EXPECT_EQ(history_depth - 1u, intra_process_buffer.available_capacity());\n\u002B  EXPECT_EQ(original_value, *popped_unique_msg);\n\u002B  EXPECT_EQ(original_message_pointer, popped_message_pointer);\n\u002B\n\u002B  popped_unique_msg = intra_process_buffer.consume_unique();\n\u002B  popped_message_pointer = reinterpret_cast\u003Cstd::uintptr_t\u003E(popped_unique_msg.get());\n\u002B\n\u002B  EXPECT_EQ(history_depth, intra_process_buffer.available_capacity());\n\u002B  EXPECT_EQ(second_value, *popped_unique_msg);\n\u002B  EXPECT_EQ(second_message_pointer, popped_message_pointer);\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_intra_process_manager.cpp rclcpp/test/rclcpp/test_intra_process_manager.cpp\nindex 45d916b0..83cf586e 100644\n--- rclcpp/test/rclcpp/test_intra_process_manager.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_intra_process_manager.cpp\n@@ -156,18 \u002B156,26 @@ public:\n   {\n     message_ptr = reinterpret_cast\u003Cstd::uintptr_t\u003E(msg.get());\n     shared_msg = msg;\n\u002B    \u002B\u002Bnum_msgs;\n   }\n \n   void add(MessageUniquePtr msg)\n   {\n     message_ptr = reinterpret_cast\u003Cstd::uintptr_t\u003E(msg.get());\n     unique_msg = std::move(msg);\n\u002B    \u002B\u002Bnum_msgs;\n   }\n \n   void pop(std::uintptr_t \u0026 msg_ptr)\n   {\n     msg_ptr = message_ptr;\n     message_ptr = 0;\n\u002B    --num_msgs;\n\u002B  }\n\u002B\n\u002B  size_t size() const\n\u002B  {\n\u002B    return num_msgs;\n   }\n \n   // need to store the messages somewhere otherwise the memory address will be reused\n@@ -175,6 \u002B183,8 @@ public:\n   MessageUniquePtr unique_msg;\n \n   std::uintptr_t message_ptr;\n\u002B  // count add and pop\n\u002B  size_t num_msgs = 0u;\n };\n \n }  // namespace mock\n@@ -221,6 \u002B231,10 @@ public:\n     return topic_name.c_str();\n   }\n \n\u002B  virtual\n\u002B  size_t\n\u002B  available_capacity() const = 0;\n\u002B\n   rclcpp::QoS qos_profile;\n   std::string topic_name;\n };\n@@ -280,6 \u002B294,12 @@ public:\n     return take_shared_method;\n   }\n \n\u002B  size_t\n\u002B  available_capacity() const override\n\u002B  {\n\u002B    return qos_profile.depth() - buffer-\u003Esize();\n\u002B  }\n\u002B\n   bool take_shared_method;\n \n   typename rclcpp::experimental::buffers::mock::IntraProcessBuffer\u003CMessageT\u003E::UniquePtr buffer;\n@@ -712,3 \u002B732,91 @@ TEST(TestIntraProcessManager, multiple_subscriptions_different_type) {\n   EXPECT_EQ(original_message_pointer, received_message_pointer_10);\n   EXPECT_NE(original_message_pointer, received_message_pointer_11);\n }\n\u002B\n\u002B/*\n\u002B   This tests the method \u0022lowest_available_capacity\u0022:\n\u002B   - Creates 1 publisher.\n\u002B   - The available buffer capacity should be at least history size.\n\u002B   - Add 2 subscribers.\n\u002B   - Add everything to the intra-process manager.\n\u002B   - All the entities are expected to have different ids.\n\u002B   - Check the subscriptions count for the publisher.\n\u002B   - The available buffer capacity should be the history size.\n\u002B   - Publish one message (without receiving it).\n\u002B   - The available buffer capacity should decrease by 1.\n\u002B   - Publish another message (without receiving it).\n\u002B   - The available buffer capacity should decrease by 1.\n\u002B   - One subscriber receives one message.\n\u002B   - The available buffer capacity should stay the same,\n\u002B     as the other subscriber still has not freed its buffer.\n\u002B   - The other subscriber receives one message.\n\u002B   - The available buffer capacity should increase by 1.\n\u002B   - One subscription goes out of scope.\n\u002B   - The available buffer capacity should not change.\n\u002B */\n\u002BTEST(TestIntraProcessManager, lowest_available_capacity) {\n\u002B  using IntraProcessManagerT = rclcpp::experimental::IntraProcessManager;\n\u002B  using MessageT = rcl_interfaces::msg::Log;\n\u002B  using PublisherT = rclcpp::mock::Publisher\u003CMessageT\u003E;\n\u002B  using SubscriptionIntraProcessT = rclcpp::experimental::mock::SubscriptionIntraProcess\u003CMessageT\u003E;\n\u002B\n\u002B  constexpr auto history_depth = 10u;\n\u002B\n\u002B  auto ipm = std::make_shared\u003CIntraProcessManagerT\u003E();\n\u002B\n\u002B  auto p1 = std::make_shared\u003CPublisherT\u003E(rclcpp::QoS(history_depth).best_effort());\n\u002B\n\u002B  auto s1 = std::make_shared\u003CSubscriptionIntraProcessT\u003E(rclcpp::QoS(history_depth).best_effort());\n\u002B  auto s2 = std::make_shared\u003CSubscriptionIntraProcessT\u003E(rclcpp::QoS(history_depth).best_effort());\n\u002B\n\u002B  auto p1_id = ipm-\u003Eadd_publisher(p1);\n\u002B  p1-\u003Eset_intra_process_manager(p1_id, ipm);\n\u002B\n\u002B  auto c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B\n\u002B  ASSERT_LE(0u, c1);\n\u002B\n\u002B  auto s1_id = ipm-\u003Eadd_subscription(s1);\n\u002B  auto s2_id = ipm-\u003Eadd_subscription(s2);\n\u002B\n\u002B  bool unique_ids = s1_id != s2_id \u0026\u0026 p1_id != s1_id;\n\u002B  ASSERT_TRUE(unique_ids);\n\u002B\n\u002B  size_t p1_subs = ipm-\u003Eget_subscription_count(p1_id);\n\u002B  size_t non_existing_pub_subs = ipm-\u003Eget_subscription_count(42);\n\u002B  ASSERT_EQ(2u, p1_subs);\n\u002B  ASSERT_EQ(0u, non_existing_pub_subs);\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  auto non_existing_pub_c = ipm-\u003Elowest_available_capacity(42);\n\u002B\n\u002B  ASSERT_EQ(history_depth, c1);\n\u002B  ASSERT_EQ(0u, non_existing_pub_c);\n\u002B\n\u002B  auto unique_msg = std::make_unique\u003CMessageT\u003E();\n\u002B  p1-\u003Epublish(std::move(unique_msg));\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  ASSERT_EQ(history_depth - 1u, c1);\n\u002B\n\u002B  unique_msg = std::make_unique\u003CMessageT\u003E();\n\u002B  p1-\u003Epublish(std::move(unique_msg));\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  ASSERT_EQ(history_depth - 2u, c1);\n\u002B\n\u002B  s1-\u003Epop();\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  ASSERT_EQ(history_depth - 2u, c1);\n\u002B\n\u002B  s2-\u003Epop();\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  ASSERT_EQ(history_depth - 1u, c1);\n\u002B\n\u002B  ipm-\u003Eget_subscription_intra_process(s1_id).reset();\n\u002B\n\u002B  c1 = ipm-\u003Elowest_available_capacity(p1_id);\n\u002B  ASSERT_EQ(history_depth - 1u, c1);\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_publisher.cpp rclcpp/test/rclcpp/test_publisher.cpp\nindex 20a46194..a0c3ec8b 100644\n--- rclcpp/test/rclcpp/test_publisher.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_publisher.cpp\n@@ -629,6 \u002B629,41 @@ TEST_P(TestPublisherWaitForAllAcked, check_wait_for_all_acked_with_QosPolicy) {\n   EXPECT_TRUE(pub-\u003Ewait_for_all_acked(std::chrono::milliseconds(6000)));\n }\n \n\u002BTEST_F(TestPublisher, lowest_available_ipm_capacity) {\n\u002B  constexpr auto history_depth = 10u;\n\u002B\n\u002B  initialize(rclcpp::NodeOptions().use_intra_process_comms(true));\n\u002B\n\u002B  rclcpp::PublisherOptionsWithAllocator\u003Cstd::allocator\u003Cvoid\u003E\u003E options_ipm_disabled;\n\u002B  options_ipm_disabled.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;\n\u002B\n\u002B  rclcpp::PublisherOptionsWithAllocator\u003Cstd::allocator\u003Cvoid\u003E\u003E options_ipm_enabled;\n\u002B  options_ipm_enabled.use_intra_process_comm = rclcpp::IntraProcessSetting::Enable;\n\u002B\n\u002B  auto do_nothing = [](std::shared_ptr\u003Cconst test_msgs::msg::Strings\u003E) {};\n\u002B  auto pub_ipm_disabled = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Strings\u003E(\n\u002B    \u0022topic\u0022, history_depth,\n\u002B    options_ipm_disabled);\n\u002B  auto pub_ipm_enabled = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Strings\u003E(\n\u002B    \u0022topic\u0022, history_depth,\n\u002B    options_ipm_enabled);\n\u002B  auto sub = node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Strings\u003E(\n\u002B    \u0022topic\u0022,\n\u002B    history_depth,\n\u002B    do_nothing);\n\u002B\n\u002B  ASSERT_EQ(1, pub_ipm_enabled-\u003Eget_intra_process_subscription_count());\n\u002B  ASSERT_EQ(0, pub_ipm_disabled-\u003Elowest_available_ipm_capacity());\n\u002B  ASSERT_EQ(history_depth, pub_ipm_enabled-\u003Elowest_available_ipm_capacity());\n\u002B\n\u002B  auto msg = std::make_shared\u003Ctest_msgs::msg::Strings\u003E();\n\u002B  ASSERT_NO_THROW(pub_ipm_disabled-\u003Epublish(*msg));\n\u002B  ASSERT_NO_THROW(pub_ipm_enabled-\u003Epublish(*msg));\n\u002B\n\u002B  ASSERT_EQ(0, pub_ipm_disabled-\u003Elowest_available_ipm_capacity());\n\u002B  ASSERT_EQ(history_depth - 1u, pub_ipm_enabled-\u003Elowest_available_ipm_capacity());\n\u002B}\n\u002B\n INSTANTIATE_TEST_SUITE_P(\n   TestWaitForAllAckedWithParm,\n   TestPublisherWaitForAllAcked,\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "6f41298e6b03fe794003eac4c55735b6aee2663d",
    "RawMessage": "Update QD",
    "Changes": "diff --git rmw/QUALITY_DECLARATION.md rmw/QUALITY_DECLARATION.md\nindex 9e38663..44f6d87 100644\n--- rmw/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw/QUALITY_DECLARATION.md\n@@ -109,6 \u002B109,7 @@ This includes:\n \n Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n \n\u002BThis package has testing coverage of at least 95%.\n Current coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/).\n A description of how coverage statistics are summarized from this page can be found in the [ROS 2 On-boarding Guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "2b6930e27713e46c70b95997c511a89bf57cc624",
    "RawMessage": "Update deprecated qos policy value names (#571)",
    "Changes": "diff --git ros2topic/test/qos_subscription.py ros2topic/test/qos_subscription.py\nindex d295b2d..aed7df0 100644\n--- ros2topic/test/qos_subscription.py\n\u002B\u002B\u002B ros2topic/test/qos_subscription.py\n@@ -55,7 \u002B55,7 @@ def main(args=None):\n             lambda msg: counter.onMsg(\u0027transient\u0027, msg),\n             QoSProfile(\n                 depth=10,\n-                durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL))\n\u002B                durability=QoSDurabilityPolicy.TRANSIENT_LOCAL))\n \n     sub_volatile = node.create_subscription(\n             String,\n@@ -63,7 \u002B63,7 @@ def main(args=None):\n             lambda msg: counter.onMsg(\u0027volatile\u0027, msg),\n             QoSProfile(\n                 depth=10,\n-                durability=QoSDurabilityPolicy.RMW_QOS_POLICY_DURABILITY_VOLATILE))\n\u002B                durability=QoSDurabilityPolicy.VOLATILE))\n \n     sub_reliable = node.create_subscription(\n             String,\n@@ -71,7 \u002B71,7 @@ def main(args=None):\n             lambda msg: counter.onMsg(\u0027reliable\u0027, msg),\n             QoSProfile(\n                 depth=10,\n-                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_RELIABLE))\n\u002B                reliability=QoSReliabilityPolicy.RELIABLE))\n \n     sub_best_effort = node.create_subscription(\n             String,\n@@ -79,7 \u002B79,7 @@ def main(args=None):\n             lambda msg: counter.onMsg(\u0027best_effort\u0027, msg),\n             QoSProfile(\n                 depth=10,\n-                reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT))\n\u002B                reliability=QoSReliabilityPolicy.BEST_EFFORT))\n \n     # Asserts to suppress unused variable warnings.\n     assert sub_default\ndiff --git ros2topic/test/test_cli.py ros2topic/test/test_cli.py\nindex 0173ff9..54a371a 100644\n--- ros2topic/test/test_cli.py\n\u002B\u002B\u002B ros2topic/test/test_cli.py\n@@ -295,11 \u002B295,11 @@ class TestROS2TopicCLI(unittest.TestCase):\n                 re.compile(r\u0027Endpoint type: (INVALID|PUBLISHER|SUBSCRIPTION)\u0027),\n                 re.compile(r\u0027GID: [\\w\\.]\u002B\u0027),\n                 \u0027QoS profile:\u0027,\n-                re.compile(r\u0027  Reliability: RMW_QOS_POLICY_RELIABILITY_\\w\u002B\u0027),\n-                re.compile(r\u0027  Durability: RMW_QOS_POLICY_DURABILITY_\\w\u002B\u0027),\n\u002B                re.compile(r\u0027  Reliability: (RELIABLE|BEST_EFFORT|SYSTEM_DEFAULT|UNKNOWN)\u0027),\n\u002B                re.compile(r\u0027  Durability: (VOLATILE|TRANSIENT_LOCAL|SYSTEM_DEFAULT|UNKNOWN)\u0027),\n                 re.compile(r\u0027  Lifespan: \\d\u002B nanoseconds\u0027),\n                 re.compile(r\u0027  Deadline: \\d\u002B nanoseconds\u0027),\n-                re.compile(r\u0027  Liveliness: RMW_QOS_POLICY_LIVELINESS_\\w\u002B\u0027),\n\u002B                re.compile(r\u0027  Liveliness: (AUTOMATIC|MANUAL_BY_TOPIC|SYSTEM_DEFAULT|UNKNOWN)\u0027),\n                 re.compile(r\u0027  Liveliness lease duration: \\d\u002B nanoseconds\u0027),\n                 \u0027\u0027,\n                 \u0027Subscription count: 0\u0027,\n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "27b4d4fc30149339da50376acd08893141748aa5",
    "RawMessage": "executor ignore canceled timers (#220)",
    "Changes": "diff --git rclc/src/rclc/executor.c rclc/src/rclc/executor.c\nindex 4b508b9..885fced 100644\n--- rclc/src/rclc/executor.c\n\u002B\u002B\u002B rclc/src/rclc/executor.c\n@@ -1433,6 \u002B1433,13 @@ _rclc_execute(rclc_executor_handle_t * handle)\n       case TIMER:\n         // case TIMER_WITH_CONTEXT:\n         rc = rcl_timer_call(handle-\u003Etimer);\n\u002B\n\u002B        // cancled timer are not handled, return success\n\u002B        if (rc == RCL_RET_TIMER_CANCELED) {\n\u002B          rc = RCL_RET_OK;\n\u002B          break;\n\u002B        }\n\u002B\n         if (rc != RCL_RET_OK) {\n           PRINT_RCLC_ERROR(rclc_execute, rcl_timer_call);\n           return rc;\ndiff --git rclc/test/rclc/test_executor.cpp rclc/test/rclc/test_executor.cpp\nindex ed68faa..7eca5ca 100644\n--- rclc/test/rclc/test_executor.cpp\n\u002B\u002B\u002B rclc/test/rclc/test_executor.cpp\n@@ -1021,6 \u002B1021,95 @@ TEST_F(TestDefaultExecutor, executor_spin_timer) {\n   EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n }\n \n\u002BTEST_F(TestDefaultExecutor, executor_spin_publisher_timer_cancelled) {\n\u002B  rcl_ret_t rc;\n\u002B  rclc_executor_t executor;\n\u002B  unsigned int expected_msg;\n\u002B\n\u002B  rc = rclc_executor_init(\u0026executor, \u0026this-\u003Econtext, 10, this-\u003Eallocator_ptr);\n\u002B  EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B  _executor_results_init();\n\u002B\n\u002B  rc = rclc_executor_add_subscription(\n\u002B    \u0026executor, \u0026this-\u003Esub1, \u0026this-\u003Esub1_msg,\n\u002B    \u0026CALLBACK_1, ON_NEW_DATA);\n\u002B\n\u002B  rc = rclc_executor_add_timer(\u0026executor, \u0026this-\u003Etimer1);\n\u002B\n\u002B  for (unsigned int i = 0; i \u003C TC_SPIN_SOME_PUBLISHED_MSGS; i\u002B\u002B) {\n\u002B    rc = rcl_publish(\u0026this-\u003Epub1, \u0026this-\u003Epub1_msg, nullptr);\n\u002B    EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C \u0022 pub1 not published\u0022;\n\u002B  }\n\u002B\n\u002B  // wait until messages are received\n\u002B  bool success = false;\n\u002B  unsigned int tries;\n\u002B  unsigned int max_tries = 100;\n\u002B  uint64_t timeout_ns = 100000000;  // 100ms\n\u002B\n\u002B  rc = rcl_timer_cancel(\u0026this-\u003Etimer1);\n\u002B  // process subscriptions. Assumption: messages for sub1 available\n\u002B  for (unsigned int i = 0; i \u003C 100; i\u002B\u002B) {\n\u002B    // Assumption: messages for all sub1, sub2 and sub3 are available\n\u002B    _wait_for_msg(\n\u002B      \u0026this-\u003Esub1, \u0026this-\u003Econtext, max_tries, timeout_ns, \u0026tries,\n\u002B      \u0026success);\n\u002B    ASSERT_TRUE(success);\n\u002B\n\u002B\n\u002B    EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C \u0022failed to cancel timer\u0022;\n\u002B\n\u002B    rc = rclc_executor_spin_some(\u0026executor, rclc_test_timeout_ns);\n\u002B    if ((rc == RCL_RET_OK) || (rc == RCL_RET_TIMEOUT)) {\n\u002B      // valid return values\n\u002B    } else {\n\u002B      // any other error\n\u002B      EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C \u0022spin_some error\u0022;\n\u002B    }\n\u002B    if (_cb1_cnt == TC_SPIN_SOME_PUBLISHED_MSGS) {\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  expected_msg = TC_SPIN_SOME_PUBLISHED_MSGS;\n\u002B  EXPECT_EQ(_cb1_cnt, expected_msg) \u003C\u003C \u0022cb1 msg does not match\u0022;\n\u002B\n\u002B  rc = rclc_executor_fini(\u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B  rcutils_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(TestDefaultExecutor, executor_spin_timer_cancelled) {\n\u002B  rcl_ret_t rc;\n\u002B  rclc_executor_t executor;\n\u002B  rc = rclc_executor_init(\u0026executor, \u0026this-\u003Econtext, 10, this-\u003Eallocator_ptr);\n\u002B  EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B  // spin_timeout must be \u003C timer1_timeout\n\u002B  const unsigned int spin_timeout = 50;\n\u002B  const unsigned int spin_repeat = 10;\n\u002B  const unsigned int expected_callbacks = (spin_timeout * spin_repeat) / timer1_timeout;\n\u002B  _cbt_cnt = 0;\n\u002B\n\u002B  rc = rclc_executor_add_timer(\u0026executor, \u0026this-\u003Etimer1);\n\u002B  EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B  for (size_t i = 0; i \u003C spin_repeat; i\u002B\u002B) {\n\u002B    rclc_executor_spin_some(\u0026executor, RCL_MS_TO_NS(spin_timeout));\n\u002B    if (i \u003E spin_repeat / 2) {\n\u002B      rc = rcl_timer_cancel(\u0026this-\u003Etimer1);\n\u002B      EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  EXPECT_LT(_cbt_cnt, expected_callbacks);\n\u002B\n\u002B  // tear down\n\u002B  rc = rclc_executor_fini(\u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, rc) \u003C\u003C rcl_get_error_string().str;\n\u002B}\n\u002B\n TEST_F(TestDefaultExecutor, executor_remove_timer) {\n   rcl_ret_t rc;\n   rclc_executor_t executor;\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "4f20a8b416f248b66bfaca44aa7d3e527ef83a13",
    "RawMessage": "\u2261\u0192\u00E6\u2310\u0393\u00C7\u00EC\u2261\u0192\u00EE\u255B Check that header is not none before accessing it in test (#818)",
    "Changes": "diff --git rclpy/test/test_client.py rclpy/test/test_client.py\nindex 7659d6a..6846a0e 100644\n--- rclpy/test/test_client.py\n\u002B\u002B\u002B rclpy/test/test_client.py\n@@ -108,6 \u002B108,7 @@ class TestClient(unittest.TestCase):\n                     result = srv.handle.service_take_request(srv.srv_type.Request)\n                 if result is not None:\n                     request, header = result\n\u002B                    self.assertTrue(header is not None)\n                     self.assertNotEqual(0, header.source_timestamp)\n                     return\n                 else:\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "91aed377a0a2e39664d0eae401ee49e9c419540a",
    "RawMessage": "Suppress cppcheck unknownMacro (#237)",
    "Changes": "diff --git .github/resources/suppress_other_rmw.repos .github/resources/local.repos\nsimilarity index 75%\nrename from .github/resources/suppress_other_rmw.repos\nrename to .github/resources/local.repos\nindex fe986d9..cb4dfc1 100644\n--- .github/resources/suppress_other_rmw.repos\n\u002B\u002B\u002B .github/resources/local.repos\n@@ -9,3 \u002B9,8 @@ repositories:\n \n   ros2/rosidl_typesupport_fastrtps/COLCON_IGNORE: *empty_repo\n   ros2/rmw_fastrtps/COLCON_IGNORE: *empty_repo\n\u002B\n\u002B  ament/ament_lint:\n\u002B    type: git\n\u002B    url: https://github.com/ament/ament_lint.git\n\u002B    version: pull/268/merge\ndiff --git .github/workflows/CI.yml .github/workflows/CI.yml\nindex bea084e..3c56e96 100644\n--- .github/workflows/CI.yml\n\u002B\u002B\u002B .github/workflows/CI.yml\n@@ -27,6 \u002B27,8 @@ jobs:\n       run: sed -e \u0027s/azure.archive.ubuntu.com/us.archive.ubuntu.com/g\u0027 -e t -e d /etc/apt/sources.list | sudo tee /etc/apt/sources.list.d/nonazure.list\n     - name: Acquire ROS dependencies\n       uses: ros-tooling/setup-ros@master\n\u002B    - name: Set up git to see all pull requests\n\u002B      run: git config --global --add remote.origin.fetch \u0027\u002Brefs/pull/*:refs/remotes/origin/pull/*\u0027\n     - name: Build and test ROS\n       id: ros_ci\n       uses: ros-tooling/action-ros-ci@0.0.19\n@@ -37,4 \u002B39,4 @@ jobs:\n         target-ros2-distro: ${{matrix.rosdistro}}\n         vcs-repo-file-url: \u003E\n           https://raw.githubusercontent.com/ros2/ros2/${{ matrix.repos_branch }}/ros2.repos\n-          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/suppress_other_rmw.repos\n\u002B          https://raw.githubusercontent.com/${{github.repository}}/${{github.sha}}/.github/resources/local.repos\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "teleop_twist_joy",
    "SHA": "40461689336538391104c34c4f75c8985aa7e36f",
    "RawMessage": "Install includes to include/${PROJECT_NAME} (#30)",
    "Changes": "diff --git CMakeLists.txt CMakeLists.txt\nindex c034d66..222ed0f 100644\n--- CMakeLists.txt\n\u002B\u002B\u002B CMakeLists.txt\n@@ -17,13 \u002B17,14 @@ find_package(rclcpp REQUIRED)\n find_package(rclcpp_components REQUIRED)\n find_package(sensor_msgs REQUIRED)\n \n-include_directories(include)\n-\n add_library(${PROJECT_NAME} SHARED src/${PROJECT_NAME})\n \n include(GenerateExportHeader)\n generate_export_header(${PROJECT_NAME} EXPORT_FILE_NAME ${PROJECT_NAME}/${PROJECT_NAME}_export.h)\n-target_include_directories(${PROJECT_NAME} PUBLIC \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}\u003E\u0022)\n\u002Btarget_include_directories(${PROJECT_NAME} PUBLIC\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}\u003E\u0022\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\u0022)\n set_target_properties(${PROJECT_NAME} PROPERTIES EXPORT_HEADER_DIR \u0022${CMAKE_CURRENT_BINARY_DIR}\u0022)\n \n ament_target_dependencies(${PROJECT_NAME}\n@@ -42,6 \u002B43,7 @@ set_target_properties(${PROJECT_NAME}_node\n   PROPERTIES OUTPUT_NAME teleop_node PREFIX \u0022\u0022)\n \n install(TARGETS ${PROJECT_NAME}\n\u002B  EXPORT export_${PROJECT_NAME}\n   ARCHIVE DESTINATION lib\n   LIBRARY DESTINATION lib\n   RUNTIME DESTINATION bin)\n@@ -50,11 \u002B52,11 @@ install(TARGETS ${PROJECT_NAME}_node\n   DESTINATION lib/${PROJECT_NAME})\n \n install(DIRECTORY include/\n-  DESTINATION include)\n\u002B  DESTINATION include/${PROJECT_NAME})\n \n install(FILES\n   ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}/${PROJECT_NAME}_export.h\n-  DESTINATION include/${PROJECT_NAME})\n\u002B  DESTINATION include/${PROJECT_NAME}/${PROJECT_NAME})\n \n install(DIRECTORY launch config\n   DESTINATION share/${PROJECT_NAME})\n@@ -92,6 \u002B94,11 @@ if(BUILD_TESTING)\n   endforeach()\n endif()\n \n-ament_export_include_directories(include)\n\u002B# Export old-style CMake variables\n\u002Bament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\n ament_export_libraries(${PROJECT_NAME})\n\u002B\n\u002B# Export modern CMake targets\n\u002Bament_export_targets(export_${PROJECT_NAME})\n\u002B\n ament_package()\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "5d3cecc8af601c10561f7c17d76eab740bb540ce",
    "RawMessage": "updating quality declaration links (re: ros2/docs.ros2.org#52) (#335)",
    "Changes": "diff --git QUALITY_DECLARATION.md QUALITY_DECLARATION.md\nindex db56662..5db788e 100644\n--- QUALITY_DECLARATION.md\n\u002B\u002B\u002B QUALITY_DECLARATION.md\n@@ -4,12 \u002B4,12 @@ This document is a declaration of software quality for the \u0060rcutils\u0060 package, ba\n \n The package \u0060rcutils\u0060 claims to be in the **Quality Level 1** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-quality-categories) of the ROS2 developer guide.\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html) of the ROS2 developer guide.\n \n ## Version Policy [1]\n \n ### Version Scheme [1.i]\n-\u0060rcutils\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning)\n\u002B\u0060rcutils\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning)\n \n ### Version Stability [1.ii]\n \n@@ -38,16 \u002B38,16 @@ The source templates for these generated headers are in the \u0060resource\u0060 folder.\n \n ## Change Control Process [2]\n \n-\u0060rcutils\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process).\n\u002B\u0060rcutils\u0060 follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process).\n \n ### Change Requests [2.i]\n-All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n\u002BAll changes will occur through a pull request, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n \n ### Contributor Origin [2.ii]\n This package uses DCO as its confirmation of contributor origin policy. More information can be found in [CONTRIBUTING](./CONTRIBUTING.md)\n \n ### Peer Review Policy [2.iii]\n-All pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.\n\u002BAll pull request will be peer-reviewed, check [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process) for additional information.\n \n ### Continuous Integration [2.iv]\n \n@@ -104,7 \u002B104,7 @@ The tests aim to cover both typical usage and corner cases, but are quantified b\n \n ### Coverage [4.iii]\n \n-\u0060rcutils\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#code-coverage), and opts to use line coverage instead of branch coverage.\n\u002B\u0060rcutils\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use line coverage instead of branch coverage.\n \n This includes:\n \n@@ -115,11 \u002B115,11 @@ This includes:\n Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n \n Current coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rcutils_src/).\n-A description of how coverage statistics are summarized from this page, can be found in the [\u0022ROS 2 Onboarding Guide\u0022](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n\u002BA description of how coverage statistics are summarized from this page, can be found in the [\u0022ROS 2 Onboarding Guide\u0022](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n-\u0060rcutils\u0060 follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#performance), and opts to do performance analysis on each release rather than each change.\n\u002B\u0060rcutils\u0060 follows the recommendations for performance testing of C code in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#performance), and opts to do performance analysis on each release rather than each change.\n \n System level performance benchmarks that cover features of \u0060rcutils\u0060 can be found at:\n * [Benchmarks](http://build.ros2.org/view/Rci/job/Rci__benchmark_ubuntu_focal_amd64/BenchmarkTable/)\n@@ -129,7 \u002B129,7 @@ Changes that introduce regressions in performance must be adequately justified i\n \n ### Linters and Static Analysis [4.v]\n \n-\u0060rcutils\u0060 uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n\u002B\u0060rcutils\u0060 uses and passes all the ROS2 standard linters and static analysis tools for a C package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis). Passing implies there are no linter/static errors when testing against CI of supported platforms.\n \n Currently nightly test results can be seen here:\n * [linux-aarch64_release](https://ci.ros2.org/view/nightly/job/nightly_linux-aarch64_release/lastBuild/testReport/rcutils/)\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "geometry2",
    "SHA": "ae9d1ba9b39ba8c4c0469240861a5c75878aa5b5",
    "RawMessage": "Use the usual style of parameters for static_transform_program (#300)",
    "Changes": "diff --git tf2_ros/src/static_transform_broadcaster_node.cpp tf2_ros/src/static_transform_broadcaster_node.cpp\nindex 47359ced..33bbd037 100644\n--- tf2_ros/src/static_transform_broadcaster_node.cpp\n\u002B\u002B\u002B tf2_ros/src/static_transform_broadcaster_node.cpp\n@@ -27,11 \u002B27,10 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n-#include \u003Cutility\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Crandom\u003E\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n-#include \u003Crandom\u003E\n \n #include \u0022tf2_ros/static_transform_broadcaster_node.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n@@ -72,17 \u002B71,17 @@ StaticTransformBroadcasterNode::StaticTransformBroadcasterNode(const rclcpp::Nod\n   descriptor.read_only = true;\n \n   tf_msg.header.stamp = this-\u003Enow();\n-  tf_msg.transform.translation.x = this-\u003Edeclare_parameter(\u0022/translation/x\u0022, 0.0, descriptor);\n-  tf_msg.transform.translation.y = this-\u003Edeclare_parameter(\u0022/translation/y\u0022, 0.0, descriptor);\n-  tf_msg.transform.translation.z = this-\u003Edeclare_parameter(\u0022/translation/z\u0022, 0.0, descriptor);\n-  tf_msg.transform.rotation.x = this-\u003Edeclare_parameter(\u0022/rotation/x\u0022, 0.0, descriptor);\n-  tf_msg.transform.rotation.y = this-\u003Edeclare_parameter(\u0022/rotation/y\u0022, 0.0, descriptor);\n-  tf_msg.transform.rotation.z = this-\u003Edeclare_parameter(\u0022/rotation/z\u0022, 0.0, descriptor);\n-  tf_msg.transform.rotation.w = this-\u003Edeclare_parameter(\u0022/rotation/w\u0022, 1.0, descriptor);\n\u002B  tf_msg.transform.translation.x = this-\u003Edeclare_parameter(\u0022translation.x\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.translation.y = this-\u003Edeclare_parameter(\u0022translation.y\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.translation.z = this-\u003Edeclare_parameter(\u0022translation.z\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.rotation.x = this-\u003Edeclare_parameter(\u0022rotation.x\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.rotation.y = this-\u003Edeclare_parameter(\u0022rotation.y\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.rotation.z = this-\u003Edeclare_parameter(\u0022rotation.z\u0022, 0.0, descriptor);\n\u002B  tf_msg.transform.rotation.w = this-\u003Edeclare_parameter(\u0022rotation.w\u0022, 1.0, descriptor);\n   tf_msg.header.frame_id =\n-    this-\u003Edeclare_parameter(\u0022/frame_id\u0022, std::string(\u0022/frame\u0022), descriptor);\n\u002B    this-\u003Edeclare_parameter(\u0022frame_id\u0022, std::string(\u0022/frame\u0022), descriptor);\n   tf_msg.child_frame_id =\n-    this-\u003Edeclare_parameter(\u0022/child_frame_id\u0022, std::string(\u0022/child\u0022), descriptor);\n\u002B    this-\u003Edeclare_parameter(\u0022child_frame_id\u0022, std::string(\u0022/child\u0022), descriptor);\n \n   // check frame_id != child_frame_id\n   if (tf_msg.header.frame_id == tf_msg.child_frame_id) {\ndiff --git tf2_ros/src/static_transform_broadcaster_program.cpp tf2_ros/src/static_transform_broadcaster_program.cpp\nindex d363abbb..8a1cc46f 100644\n--- tf2_ros/src/static_transform_broadcaster_program.cpp\n\u002B\u002B\u002B tf2_ros/src/static_transform_broadcaster_program.cpp\n@@ -28,39 \u002B28,14 @@\n  */\n \n #include \u003Ccstdio\u003E\n-#include \u003Ccstring\u003E\n\u002B#include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n-#include \u0022rclcpp/clock.hpp\u0022\n-#include \u0022rclcpp/time_source.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u003Ctf2/LinearMath/Quaternion.h\u003E\n #include \u0022tf2_ros/static_transform_broadcaster_node.hpp\u0022\n \n-#include \u0022builtin_interfaces/msg/time.hpp\u0022\n-\n-#include \u0022rcutils/logging_macros.h\u0022\n-\n-//TODO(clalancette re-enable this)\n-// bool validateXmlRpcTf(XmlRpc::XmlRpcValue tf_data) {\n-//   // Validate a TF stored in XML RPC format: ensures the appropriate fields\n-//   // exist. Note this does not check data types.\n-//   return tf_data.hasMember(\u0022child_frame_id\u0022) \u0026\u0026\n-//          tf_data.hasMember(\u0022header\u0022) \u0026\u0026\n-//          tf_data[\u0022header\u0022].hasMember(\u0022frame_id\u0022) \u0026\u0026\n-//          tf_data.hasMember(\u0022transform\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022].hasMember(\u0022translation\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022translation\u0022].hasMember(\u0022x\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022translation\u0022].hasMember(\u0022y\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022translation\u0022].hasMember(\u0022z\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022].hasMember(\u0022rotation\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022rotation\u0022].hasMember(\u0022x\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022rotation\u0022].hasMember(\u0022y\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022rotation\u0022].hasMember(\u0022z\u0022) \u0026\u0026\n-//          tf_data[\u0022transform\u0022][\u0022rotation\u0022].hasMember(\u0022w\u0022);\n-// };\n-\n int main(int argc, char ** argv)\n {\n   //Initialize ROS\n@@ -70,14 \u002B45,9 @@ int main(int argc, char ** argv)\n \n   if (args.size() != 9 \u0026\u0026 args.size() != 10) {\n     printf(\u0022A command line utility for manually sending a transform.\\n\u0022);\n-    //printf(\u0022It will periodicaly republish the given transform. \\n\u0022);\n     printf(\u0022Usage: static_transform_publisher x y z qx qy qz qw frame_id child_frame_id \\n\u0022);\n     printf(\u0022OR \\n\u0022);\n     printf(\u0022Usage: static_transform_publisher x y z yaw pitch roll frame_id child_frame_id \\n\u0022);\n-    //printf(\u0022OR \\n\u0022);\n-    //printf(\u0022Usage: static_transform_publisher /param_name \\n\u0022);\n-    //printf(\u0022\\nThis transform is the transform of the coordinate frame from frame_id into the coordinate frame \\n\u0022);\n-    //printf(\u0022of the child_frame_id.  \\n\u0022);\n     RCUTILS_LOG_ERROR(\n       \u0022static_transform_publisher exited due to not having the right number of arguments\u0022);\n     return 2;\n@@ -111,46 \u002B81,19 @@ int main(int argc, char ** argv)\n   // override default parameters with the desired transform\n   options.parameter_overrides(\n   {\n-    {\u0022/translation/x\u0022, x},\n-    {\u0022/translation/y\u0022, y},\n-    {\u0022/translation/z\u0022, z},\n-    {\u0022/rotation/x\u0022, rx},\n-    {\u0022/rotation/y\u0022, ry},\n-    {\u0022/rotation/z\u0022, rz},\n-    {\u0022/rotation/w\u0022, rw},\n-    {\u0022/frame_id\u0022, frame_id},\n-    {\u0022/child_frame_id\u0022, child_id},\n\u002B    {\u0022translation.x\u0022, x},\n\u002B    {\u0022translation.y\u0022, y},\n\u002B    {\u0022translation.z\u0022, z},\n\u002B    {\u0022rotation.x\u0022, rx},\n\u002B    {\u0022rotation.y\u0022, ry},\n\u002B    {\u0022rotation.z\u0022, rz},\n\u002B    {\u0022rotation.w\u0022, rw},\n\u002B    {\u0022frame_id\u0022, frame_id},\n\u002B    {\u0022child_frame_id\u0022, child_id},\n   });\n \n   node = std::make_shared\u003Ctf2_ros::StaticTransformBroadcasterNode\u003E(options);\n \n-  // else if (args.size() == 2) {\n-  //   const std::string param_name = args[1];\n-  //   ROS_INFO_STREAM(\u0022Looking for TF in parameter: \u0022 \u003C\u003C param_name);\n-  //   XmlRpc::XmlRpcValue tf_data;\n-\n-  //   if (!ros::param::has(param_name) || !ros::param::get(param_name, tf_data)) {\n-  //     ROS_FATAL_STREAM(\u0022Could not read TF from parameter server: \u0022 \u003C\u003C param_name);\n-  //     return -1;\n-  //   }\n-\n-  //   // Check that all required members are present \u0026 of the right type.\n-  //   if (!validateXmlRpcTf(tf_data)) {\n-  //     ROS_FATAL_STREAM(\u0022Could not validate XmlRpcC for TF data: \u0022 \u003C\u003C tf_data);\n-  //     return -1;\n-  //   }\n-\n-  //   msg.transform.translation.x = (double) tf_data[\u0022transform\u0022][\u0022translation\u0022][\u0022x\u0022];\n-  //   msg.transform.translation.y = (double) tf_data[\u0022transform\u0022][\u0022translation\u0022][\u0022y\u0022];\n-  //   msg.transform.translation.z = (double) tf_data[\u0022transform\u0022][\u0022translation\u0022][\u0022z\u0022];\n-  //   msg.transform.rotation.x = (double) tf_data[\u0022transform\u0022][\u0022rotation\u0022][\u0022x\u0022];\n-  //   msg.transform.rotation.y = (double) tf_data[\u0022transform\u0022][\u0022rotation\u0022][\u0022y\u0022];\n-  //   msg.transform.rotation.z = (double) tf_data[\u0022transform\u0022][\u0022rotation\u0022][\u0022z\u0022];\n-  //   msg.transform.rotation.w = (double) tf_data[\u0022transform\u0022][\u0022rotation\u0022][\u0022w\u0022];\n-  //   msg.header.stamp = clock-\u003Enow();\n-  //   msg.header.frame_id = (std::string) tf_data[\u0022header\u0022][\u0022frame_id\u0022];\n-  //   msg.child_frame_id = (std::string) tf_data[\u0022child_frame_id\u0022];\n-  // }\n   RCLCPP_INFO(\n     node-\u003Eget_logger(), \u0022Spinning until killed publishing transform from \u0027%s\u0027 to \u0027%s\u0027\u0022,\n     frame_id.c_str(), child_id.c_str());\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "b2b57d90ad3ecf96e6f5a459a48c61caa0390188",
    "RawMessage": "Complete rcl enclave validation API coverage. (#751)",
    "Changes": "diff --git rcl/test/CMakeLists.txt rcl/test/CMakeLists.txt\nindex e33a712..7e46a75 100644\n--- rcl/test/CMakeLists.txt\n\u002B\u002B\u002B rcl/test/CMakeLists.txt\n@@ -355,7 \u002B355,7 @@ call_for_each_rmw_implementation(test_target)\n rcl_add_custom_gtest(test_validate_enclave_name\n   SRCS rcl/test_validate_enclave_name.cpp\n   APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-  LIBRARIES ${PROJECT_NAME}\n\u002B  LIBRARIES ${PROJECT_NAME} mimick\n )\n \n rcl_add_custom_gtest(test_domain_id\ndiff --git rcl/test/rcl/test_validate_enclave_name.cpp rcl/test/rcl/test_validate_enclave_name.cpp\nindex 408bdcc..0cc4b1c 100644\n--- rcl/test/rcl/test_validate_enclave_name.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_validate_enclave_name.cpp\n@@ -17,11 \u002B17,17 @@\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n\u002B#include \u0022rcutils/snprintf.h\u0022\n\u002B\n #include \u0022rcl/rcl.h\u0022\n #include \u0022rcl/validate_enclave_name.h\u0022\n \n #include \u0022rcl/error_handling.h\u0022\n \n\u002B#include \u0022rmw/validate_namespace.h\u0022\n\u002B\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n TEST(TestValidateEnclaveName, test_validate) {\n   int validation_result;\n   size_t invalid_index;\n@@ -47,6 \u002B53,59 @@ TEST(TestValidateEnclaveName, test_validate) {\n     RCL_RET_OK,\n     rcl_validate_enclave_name(\u0022/foo/bar\u0022, \u0026validation_result, \u0026invalid_index));\n   EXPECT_EQ(RCL_ENCLAVE_NAME_VALID, validation_result);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_namespace_with_size,\n\u002B      [\u0026](auto, auto, int * result, size_t * index) {\n\u002B        if (index) {\n\u002B          *index = 0u;\n\u002B        }\n\u002B        *result = RMW_NAMESPACE_INVALID_TOO_LONG;\n\u002B        return RMW_RET_OK;\n\u002B      });\n\u002B\n\u002B    // When applying RMW namespace validation rules, an enclave name may be too\n\u002B    // long for an RMW namespace but not necessarily for an enclave name.\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_OK,\n\u002B      rcl_validate_enclave_name(\u0022/foo/baz\u0022, \u0026validation_result, \u0026invalid_index));\n\u002B    EXPECT_EQ(RCL_ENCLAVE_NAME_VALID, validation_result);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST(TestValidateEnclaveName, test_validate_on_internal_error) {\n\u002B  int validation_result;\n\u002B  size_t invalid_index;\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_to_fail(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_namespace_with_size, \u0022internal error\u0022, RMW_RET_ERROR);\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_ERROR,\n\u002B      rcl_validate_enclave_name(\u0022/foo\u0022, \u0026validation_result, \u0026invalid_index));\n\u002B    EXPECT_TRUE(rcl_error_is_set());\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_namespace_with_size,\n\u002B      [\u0026](auto, auto, int * result, size_t * index) {\n\u002B        if (index) {\n\u002B          *index = 0u;\n\u002B        }\n\u002B        *result = -1;\n\u002B        return RMW_RET_OK;\n\u002B      });\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_ERROR,\n\u002B      rcl_validate_enclave_name(\u0022/foo\u0022, \u0026validation_result, \u0026invalid_index));\n\u002B    EXPECT_TRUE(rcl_error_is_set());\n\u002B    rcl_reset_error();\n\u002B  }\n }\n \n TEST(TestValidateEnclaveName, test_validation_string) {\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "geometry2",
    "SHA": "0e505aaf09bac77242b483fa8a8ede5047a0ddc4",
    "RawMessage": "Adding NodeInterfaces to Buffer (#656)",
    "Changes": "diff --git tf2_ros/include/tf2_ros/buffer.h tf2_ros/include/tf2_ros/buffer.h\nindex fad6f0f4..13571fa9 100644\n--- tf2_ros/include/tf2_ros/buffer.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/buffer.h\n@@ -36,6 \u002B36,7 @@\n #include \u003Cmemory\u003E\n #include \u003Cmutex\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n #include \u003Cunordered_map\u003E\n \n #include \u0022tf2_ros/async_buffer_interface.h\u0022\n@@ -47,6 \u002B48,10 @@\n \n #include \u0022geometry_msgs/msg/transform_stamped.hpp\u0022\n #include \u0022tf2_msgs/srv/frame_graph.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_base_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_services_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_logging_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_logging_interface.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n \n namespace tf2_ros\n@@ -69,11 \u002B74,43 @@ public:\n    * \\param clock A clock to use for time and sleeping\n    * \\param cache_time How long to keep a history of transforms\n    * \\param node If passed advertise the view_frames service that exposes debugging information from the buffer\n\u002B   * \\param  qos If passed change the quality of service of the frames_server_ service\n    */\n-  TF2_ROS_PUBLIC Buffer(\n\u002B  template\u003Ctypename NodeT = rclcpp::Node::SharedPtr\u003E\n\u002B  Buffer(\n     rclcpp::Clock::SharedPtr clock,\n     tf2::Duration cache_time = tf2::Duration(tf2::BUFFER_CORE_DEFAULT_CACHE_TIME),\n-    rclcpp::Node::SharedPtr node = rclcpp::Node::SharedPtr());\n\u002B    NodeT \u0026\u0026 node = NodeT(),\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS())\n\u002B  : BufferCore(cache_time), clock_(clock), timer_interface_(nullptr)\n\u002B  {\n\u002B    if (nullptr == clock_) {\n\u002B      throw std::invalid_argument(\u0022clock must be a valid instance\u0022);\n\u002B    }\n\u002B\n\u002B    auto post_jump_cb = [this](const rcl_time_jump_t \u0026 jump_info) {onTimeJump(jump_info);};\n\u002B\n\u002B    rcl_jump_threshold_t jump_threshold;\n\u002B    // Disable forward jump callbacks\n\u002B    jump_threshold.min_forward.nanoseconds = 0;\n\u002B    // Anything backwards is a jump\n\u002B    jump_threshold.min_backward.nanoseconds = -1;\n\u002B    // Callback if the clock changes too\n\u002B    jump_threshold.on_clock_change = true;\n\u002B\n\u002B    jump_handler_ = clock_-\u003Ecreate_jump_callback(nullptr, post_jump_cb, jump_threshold);\n\u002B\n\u002B    if (node) {\n\u002B      node_logging_interface_ = rclcpp::node_interfaces::get_node_logging_interface(node);\n\u002B\n\u002B      frames_server_ = rclcpp::create_service\u003Ctf2_msgs::srv::FrameGraph\u003E(\n\u002B        rclcpp::node_interfaces::get_node_base_interface(node),\n\u002B        rclcpp::node_interfaces::get_node_services_interface(node),\n\u002B        \u0022tf2_frames\u0022, std::bind(\n\u002B          \u0026Buffer::getFrames, this, std::placeholders::_1,\n\u002B          std::placeholders::_2), qos, nullptr);\n\u002B    }\n\u002B  }\n \n   /** \\brief Get the transform between two frames by frame ID.\n    * \\param target_frame The frame to which data should be transformed\n@@ -275,10 \u002B312,12 @@ private:\n     TransformStampedFuture future,\n     TransformReadyCallback callback);\n \n\u002B  TF2_ROS_PUBLIC\n   bool getFrames(\n     const tf2_msgs::srv::FrameGraph::Request::SharedPtr req,\n     tf2_msgs::srv::FrameGraph::Response::SharedPtr res);\n \n\u002B  TF2_ROS_PUBLIC\n   void onTimeJump(const rcl_time_jump_t \u0026 jump);\n \n   // conditionally error if dedicated_thread unset.\n@@ -293,8 \u002B332,8 @@ private:\n   /// \\brief A clock to use for time and sleeping\n   rclcpp::Clock::SharedPtr clock_;\n \n-  /// \\brief A node to advertise the view_frames service\n-  rclcpp::Node::SharedPtr node_;\n\u002B  /// \\brief A node logging interface to access the buffer node\u0027s logger\n\u002B  rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_interface_;\n \n   /// \\brief Interface for creating timers\n   CreateTimerInterface::SharedPtr timer_interface_;\ndiff --git tf2_ros/src/buffer.cpp tf2_ros/src/buffer.cpp\nindex c3e89ebd..10ee57cc 100644\n--- tf2_ros/src/buffer.cpp\n\u002B\u002B\u002B tf2_ros/src/buffer.cpp\n@@ -42,36 \u002B42,6 @@\n \n namespace tf2_ros\n {\n-\n-Buffer::Buffer(\n-  rclcpp::Clock::SharedPtr clock, tf2::Duration cache_time,\n-  rclcpp::Node::SharedPtr node)\n-: BufferCore(cache_time), clock_(clock), node_(node), timer_interface_(nullptr)\n-{\n-  if (nullptr == clock_) {\n-    throw std::invalid_argument(\u0022clock must be a valid instance\u0022);\n-  }\n-\n-  auto post_jump_cb = [this](const rcl_time_jump_t \u0026 jump_info) {onTimeJump(jump_info);};\n-\n-  rcl_jump_threshold_t jump_threshold;\n-  // Disable forward jump callbacks\n-  jump_threshold.min_forward.nanoseconds = 0;\n-  // Anything backwards is a jump\n-  jump_threshold.min_backward.nanoseconds = -1;\n-  // Callback if the clock changes too\n-  jump_threshold.on_clock_change = true;\n-\n-  jump_handler_ = clock_-\u003Ecreate_jump_callback(nullptr, post_jump_cb, jump_threshold);\n-\n-  if (node_) {\n-    frames_server_ = node_-\u003Ecreate_service\u003Ctf2_msgs::srv::FrameGraph\u003E(\n-      \u0022tf2_frames\u0022, std::bind(\n-        \u0026Buffer::getFrames, this, std::placeholders::_1,\n-        std::placeholders::_2));\n-  }\n-}\n-\n inline\n tf2::Duration\n from_rclcpp(const rclcpp::Duration \u0026 rclcpp_duration)\n@@ -341,7 \u002B311,8 @@ bool Buffer::checkAndErrorDedicatedThreadPresent(std::string * error_str) const\n \n rclcpp::Logger Buffer::getLogger() const\n {\n-  return node_ ? node_-\u003Eget_logger() : rclcpp::get_logger(\u0022tf2_buffer\u0022);\n\u002B  return node_logging_interface_ ? node_logging_interface_-\u003Eget_logger() : rclcpp::get_logger(\n\u002B    \u0022tf2_buffer\u0022);\n }\n \n }  // namespace tf2_ros\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "1ea07e86d05a21b9bf610a0ef1ac9dc930d0286f",
    "RawMessage": "Fixes policy CMP0135 warning for CMake \u003E= 3.24 (#898)",
    "Changes": "diff --git rviz_assimp_vendor/CMakeLists.txt rviz_assimp_vendor/CMakeLists.txt\nindex 034f3f2a..67b260ee 100644\n--- rviz_assimp_vendor/CMakeLists.txt\n\u002B\u002B\u002B rviz_assimp_vendor/CMakeLists.txt\n@@ -9,6 \u002B9,11 @@ option(FORCE_BUILD_VENDOR_PKG\n \n find_package(ament_cmake REQUIRED)\n \n\u002B# Avoid DOWNLOAD_EXTRACT_TIMESTAMP warning for CMake \u003E= 3.24\n\u002Bif(POLICY CMP0135)\n\u002B  cmake_policy(SET CMP0135 NEW)\n\u002Bendif()\n\u002B\n macro(build_assimp)\n   set(extra_cmake_args)\n   if(DEFINED CMAKE_BUILD_TYPE)\ndiff --git rviz_ogre_vendor/CMakeLists.txt rviz_ogre_vendor/CMakeLists.txt\nindex 7a917af8..7893e509 100644\n--- rviz_ogre_vendor/CMakeLists.txt\n\u002B\u002B\u002B rviz_ogre_vendor/CMakeLists.txt\n@@ -6,6 \u002B6,11 @@ find_package(ament_cmake REQUIRED)\n \n set(PACKAGE_VERSION \u00221.0.0\u0022)\n \n\u002B# Avoid DOWNLOAD_EXTRACT_TIMESTAMP warning for CMake \u003E= 3.24\n\u002Bif(POLICY CMP0135)\n\u002B  cmake_policy(SET CMP0135 NEW)\n\u002Bendif()\n\u002B\n if(WIN32)\n   set(BUILDING_FREETYPE_LOCALLY ON)\n   set(BUILDING_ZLIB_LOCALLY ON)\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "367cf4af4dd8bd29a79601b6891cc2ce9158108c",
    "RawMessage": "Updated deprecated message filter headers (#1239)",
    "Changes": "diff --git rviz_common/include/rviz_common/message_filter_display.hpp rviz_common/include/rviz_common/message_filter_display.hpp\nindex d73eb89c..e1f2f183 100644\n--- rviz_common/include/rviz_common/message_filter_display.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/message_filter_display.hpp\n@@ -30,11 \u002B30,11 @@\n #ifndef RVIZ_COMMON__MESSAGE_FILTER_DISPLAY_HPP_\n #define RVIZ_COMMON__MESSAGE_FILTER_DISPLAY_HPP_\n \n-#include \u003Cmessage_filters/subscriber.h\u003E\n #include \u003Ctf2_ros/message_filter.h\u003E\n-\n #include \u003Cmemory\u003E\n \n\u002B#include \u003Cmessage_filters/subscriber.hpp\u003E\n\u002B\n #include \u0022rviz_common/ros_topic_display.hpp\u0022\n #include \u0022rviz_common/properties/int_property.hpp\u0022\n \ndiff --git rviz_default_plugins/include/rviz_default_plugins/displays/camera/camera_display.hpp rviz_default_plugins/include/rviz_default_plugins/displays/camera/camera_display.hpp\nindex 1564d514..29b5eb4a 100644\n--- rviz_default_plugins/include/rviz_default_plugins/displays/camera/camera_display.hpp\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/camera/camera_display.hpp\n@@ -47,7 \u002B47,7 @@\n # include \u003COgreRenderTargetListener.h\u003E\n # include \u003COgreSharedPtr.h\u003E\n \n-#include \u003Cmessage_filters/cache.h\u003E\n\u002B#include \u003Cmessage_filters/cache.hpp\u003E\n \n # include \u0022sensor_msgs/msg/camera_info.hpp\u0022\n # include \u0022tf2_ros/message_filter.h\u0022\ndiff --git rviz_default_plugins/include/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.hpp rviz_default_plugins/include/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.hpp\nindex 6192c37b..57e8ecd9 100644\n--- rviz_default_plugins/include/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.hpp\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.hpp\n@@ -35,9 \u002B35,6 @@\n #include \u003CQObject\u003E  // NOLINT: cpplint cannot handle the include order here\n #include \u003COgre.h\u003E\n \n-#include \u003Cmessage_filters/subscriber.h\u003E\n-#include \u003Cmessage_filters/synchronizer.h\u003E\n-#include \u003Cmessage_filters/sync_policies/approximate_time.h\u003E\n #include \u003Ctf2_ros/message_filter.h\u003E\n \n #include \u003Cmemory\u003E\n@@ -45,6 \u002B42,10 @@\n #include \u003Cset\u003E\n #include \u003Cstring\u003E\n \n\u002B#include \u003Cmessage_filters/subscriber.hpp\u003E\n\u002B#include \u003Cmessage_filters/synchronizer.hpp\u003E\n\u002B#include \u003Cmessage_filters/sync_policies/approximate_time.hpp\u003E\n\u002B\n #include \u003Cimage_transport/image_transport.hpp\u003E\n #include \u003Cimage_transport/subscriber_filter.hpp\u003E\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "5af8896a30311e4b8171864391d3bc2d8b81b611",
    "RawMessage": "Improve the compilation time of rviz_default_plugins (#1007)",
    "Changes": "diff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex e6aacce9..5e8aecc6 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -231,12 \u002B231,28 @@ target_include_directories(rviz_default_plugins PUBLIC\n )\n \n target_link_libraries(rviz_default_plugins PUBLIC\n\u002B  ${geometry_msgs_TARGETS}\n\u002B  image_transport::image_transport\n\u002B  interactive_markers::interactive_markers\n\u002B  laser_geometry::laser_geometry\n\u002B  ${map_msgs_TARGETS}\n\u002B  ${nav_msgs_TARGETS}\n\u002B  rclcpp::rclcpp\n\u002B  rviz_common::rviz_common\n   rviz_ogre_vendor::OgreMain\n   rviz_ogre_vendor::OgreOverlay\n\u002B  rviz_rendering::rviz_rendering\n\u002B  ${sensor_msgs_TARGETS}\n\u002B  tf2::tf2\n\u002B  ${tf2_geometry_msgs_TARGETS}\n\u002B  tf2_ros::tf2_ros\n\u002B  urdf::urdf\n\u002B  ${visualization_msgs_TARGETS}\n )\n \n target_link_libraries(rviz_default_plugins PRIVATE\n   ignition-math6\n\u002B  resource_retriever::resource_retriever\n )\n \n # Causes the visibility macros to use dllexport rather than dllimport,\n@@ -245,26 \u002B261,6 @@ target_compile_definitions(rviz_default_plugins PRIVATE \u0022RVIZ_DEFAULT_PLUGINS_BU\n \n pluginlib_export_plugin_description_file(rviz_common plugins_description.xml)\n \n-ament_target_dependencies(rviz_default_plugins\n-  PUBLIC\n-  geometry_msgs\n-  image_transport\n-  interactive_markers\n-  laser_geometry\n-  map_msgs\n-  nav_msgs\n-  rclcpp\n-  resource_retriever\n-  rviz_common\n-  rviz_rendering\n-  sensor_msgs\n-  tf2\n-  tf2_geometry_msgs\n-  tf2_ros\n-  urdf\n-  visualization_msgs\n-)\n-\n # Export old-style CMake variables\n ament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\n \n@@ -279,7 \u002B275,6 @@ ament_export_dependencies(\n   map_msgs\n   nav_msgs\n   rclcpp\n-  resource_retriever\n   rviz_common\n   rviz_ogre_vendor\n   sensor_msgs\n@@ -316,8 \u002B311,6 @@ if(BUILD_TESTING)\n   find_package(ament_cmake_gmock REQUIRED)\n   find_package(ament_index_cpp REQUIRED)\n   find_package(rviz_visual_testing_framework REQUIRED)\n-  find_package(sensor_msgs REQUIRED)\n-  find_package(visualization_msgs REQUIRED)\n \n   install(DIRECTORY \u0022${CMAKE_CURRENT_SOURCE_DIR}/test/ogre_media_resources/test_meshes\u0022\n     DESTINATION \u0022share/rviz_default_plugins\u0022\n@@ -325,55 \u002B318,40 @@ if(BUILD_TESTING)\n \n   # This is needed for the fixture sources down below...\n   ament_find_gmock()\n-  set(TEST_INCLUDE_DIRS\n-    test\n-    ${GMOCK_INCLUDE_DIRS}\n-    ${OGRE_INCLUDE_DIRS}\n-    ${Qt5Widgets_INCLUDE_DIRS}\n-  )\n-  ament_include_directories_order(TEST_INCLUDE_DIRS ${TEST_INCLUDE_DIRS})\n-\n-  set(TEST_TARGET_DEPENDENCIES\n-    map_msgs\n-    nav_msgs\n-    rclcpp\n-    rviz_common\n-    rviz_rendering\n-    sensor_msgs\n-    urdf\n-    visualization_msgs\n-  )\n \n-  # We can\u0027t compile the fixtures into a library to be used by every test because that would require\n-  # linking against gtest/gmock libraries, which would cause ODR violations down the line with\n-  # ament_add_gmock.\n\u002B  add_library(ogre_testing_environment STATIC test/rviz_default_plugins/ogre_testing_environment.cpp)\n\u002B  target_link_libraries(ogre_testing_environment PRIVATE rviz_ogre_vendor::OgreMain rviz_rendering::rviz_rendering)\n\u002B\n\u002B  # We can\u0027t compile these fixtures into a library to be used by every test because that would\n\u002B  # require linking against gtest/gmock libraries, which would cause ODR violations down the line\n\u002B  # with ament_add_gmock.\n   #\n   # There are also issues even if we manage to defer the linking, because the fixture class inherits\n   # from gtest classes, which are not exported.\n-  set(TEST_FIXTURE_SOURCES\n-    test/rviz_default_plugins/ogre_testing_environment.cpp\n-  )\n-\n   set(TEST_FIXTURE_SOURCES_WITH_MOCK\n     test/rviz_default_plugins/displays/display_test_fixture.cpp\n     test/rviz_default_plugins/scene_graph_introspection.cpp\n-    ${TEST_FIXTURE_SOURCES}\n   )\n \n-  set(TEST_LINK_LIBRARIES\n-    rviz_default_plugins\n-    Qt5::Widgets\n\u002B  set(TEST_FIXTURE_WITH_MOCK_LIBRARIES\n\u002B    rclcpp::rclcpp\n\u002B    rviz_common::rviz_common\n\u002B    rviz_ogre_vendor::OgreMain\n\u002B    ogre_testing_environment\n   )\n \n   ament_add_gmock(fps_view_controller_test\n     test/rviz_default_plugins/view_controllers/fps/fps_view_controller_test.cpp\n-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET fps_view_controller_test)\n-    target_include_directories(fps_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(fps_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(fps_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(fps_view_controller_test PRIVATE ${TEST_INCLUDE_DIRS})\n\u002B    target_link_libraries(fps_view_controller_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      rviz_default_plugins\n\u002B      Qt5::Widgets\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(frame_info_test\n@@ -381,17 \u002B359,16 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET frame_info_test)\n-    target_include_directories(frame_info_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(frame_info_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(frame_info_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(frame_info_test PRIVATE test)\n\u002B    target_link_libraries(frame_info_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(get_transport_from_topic_test\n     test/rviz_default_plugins/displays/image/get_transport_from_topic_test.cpp\n-  ${TEST_FIXTURE_SOURCES_WITH_MOCK})\n\u002B    ${TEST_FIXTURE_SOURCES_WITH_MOCK})\n   if(TARGET get_transport_from_topic_test)\n-    target_include_directories(get_transport_from_topic_test PUBLIC ${TEST_INCLUDE_DIRS} ${rviz_common_INCLUDE_DIRS})\n-    target_link_libraries(get_transport_from_topic_test ${TEST_LINK_LIBRARIES} ${rviz_common})\n\u002B    target_include_directories(get_transport_from_topic_test PRIVATE test)\n\u002B    target_link_libraries(get_transport_from_topic_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(grid_cells_display_test\n@@ -399,9 \u002B376,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET grid_cells_display_test)\n-    target_include_directories(grid_cells_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(grid_cells_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(grid_cells_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(grid_cells_display_test PRIVATE test)\n\u002B    target_link_libraries(grid_cells_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(image_display_test\n@@ -409,11 \u002B385,19 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET image_display_test)\n-    target_include_directories(image_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(image_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(image_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(image_display_test PRIVATE test)\n\u002B    target_link_libraries(image_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} Qt5::Widgets rviz_default_plugins ogre_testing_environment)\n   endif()\n \n\u002B  add_library(marker_messages STATIC test/rviz_default_plugins/displays/marker/marker_messages.cpp)\n\u002B  target_link_libraries(marker_messages PRIVATE\n\u002B    ${geometry_msgs_TARGETS}\n\u002B    rclcpp::rclcpp\n\u002B    ${std_msgs_TARGETS}\n\u002B    ${visualization_msgs_TARGETS}\n\u002B    rviz_ogre_vendor::OgreMain\n\u002B  )\n\u002B\n   ament_add_gmock(marker_test\n     test/rviz_default_plugins/displays/marker/markers/arrow_marker_test.cpp\n     test/rviz_default_plugins/displays/marker/markers/line_marker_test.cpp\n@@ -423,24 \u002B407,32 @@ if(BUILD_TESTING)\n     test/rviz_default_plugins/displays/marker/markers/text_view_facing_marker_test.cpp\n     test/rviz_default_plugins/displays/marker/markers/triangle_list_marker_test.cpp\n     test/rviz_default_plugins/displays/marker/markers/markers_test_fixture.cpp\n-    test/rviz_default_plugins/displays/marker/marker_messages.cpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET marker_test)\n-    target_include_directories(marker_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(marker_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(marker_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(marker_test PRIVATE test)\n\u002B    target_link_libraries(marker_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      rviz_default_plugins\n\u002B      marker_messages\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(marker_common_test\n     test/rviz_default_plugins/displays/marker/marker_common_test.cpp\n-    test/rviz_default_plugins/displays/marker/marker_messages.cpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET marker_common_test)\n-    target_include_directories(marker_common_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(marker_common_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(marker_common_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(marker_common_test PRIVATE test)\n\u002B    target_link_libraries(marker_common_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      rviz_default_plugins\n\u002B      marker_messages\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(map_display_test\n@@ -448,9 \u002B440,8 @@ if(BUILD_TESTING)\n     test/rviz_default_plugins/displays/map/map_display_test.cpp\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET map_display_test)\n-    target_include_directories(map_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(map_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(map_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(map_display_test PRIVATE test)\n\u002B    target_link_libraries(map_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(measure_tool_test\n@@ -458,9 \u002B449,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET measure_tool_test)\n-    target_include_directories(measure_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(measure_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(measure_tool_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(measure_tool_test PRIVATE test)\n\u002B    target_link_libraries(measure_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(odometry_display_test\n@@ -468,9 \u002B458,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET odometry_display_test)\n-    target_include_directories(odometry_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(odometry_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(odometry_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(odometry_display_test PRIVATE test)\n\u002B    target_link_libraries(odometry_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(odometry_ogre_helper_test\n@@ -478,31 \u002B467,36 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET odometry_ogre_helper_test)\n-    target_include_directories(odometry_ogre_helper_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(odometry_ogre_helper_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(odometry_ogre_helper_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(odometry_ogre_helper_test PRIVATE test)\n\u002B    target_link_libraries(odometry_ogre_helper_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(orbit_view_controller_test\n     test/rviz_default_plugins/view_controllers/orbit/orbit_view_controller_test.cpp\n-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET orbit_view_controller_test)\n-    target_include_directories(orbit_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(orbit_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(orbit_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(orbit_view_controller_test PRIVATE test)\n\u002B    target_link_libraries(orbit_view_controller_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      Qt5::Widgets\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(ortho_view_controller_test\n     test/rviz_default_plugins/view_controllers/ortho/ortho_view_controller_test.cpp\n-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET ortho_view_controller_test)\n-    target_include_directories(ortho_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(ortho_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(ortho_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(ortho_view_controller_test PRIVATE test)\n\u002B    target_link_libraries(ortho_view_controller_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      Qt5::Widgets\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(palette_builder_test\n@@ -510,9 \u002B504,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET palette_builder_test)\n-    target_include_directories(palette_builder_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(palette_builder_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(palette_builder_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(palette_builder_test PRIVATE test)\n\u002B    target_link_libraries(palette_builder_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(path_display_test\n@@ -520,33 \u002B513,50 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET path_display_test)\n-    target_include_directories(path_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(path_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(path_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(path_display_test PRIVATE test)\n\u002B    target_link_libraries(path_display_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n\u002B  add_library(pointcloud_messages STATIC test/rviz_default_plugins/pointcloud_messages.cpp)\n\u002B  target_link_libraries(pointcloud_messages PRIVATE\n\u002B    ${sensor_msgs_TARGETS}\n\u002B    ${geometry_msgs_TARGETS}\n\u002B    rclcpp::rclcpp\n\u002B    ${sensor_msgs_TARGETS}\n\u002B    ${std_msgs_TARGETS}\n\u002B  )\n\u002B\n   ament_add_gmock(point_cloud2_display_test\n     test/rviz_default_plugins/displays/pointcloud/point_cloud2_display_test.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET point_cloud2_display_test)\n-    target_include_directories(point_cloud2_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n\u002B    target_include_directories(point_cloud2_display_test PRIVATE test)\n     target_link_libraries(point_cloud2_display_test\n-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud2_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      rviz_default_plugins\n\u002B      pointcloud_messages\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(point_cloud_common_test\n     test/rviz_default_plugins/displays/pointcloud/point_cloud_common_test.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET point_cloud_common_test)\n-    target_include_directories(point_cloud_common_test PUBLIC ${TEST_INCLUDE_DIRS})\n\u002B    target_include_directories(point_cloud_common_test PRIVATE test)\n     target_link_libraries(point_cloud_common_test\n-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_common_test ${TEST_TARGET_DEPENDENCIES})\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      rviz_default_plugins\n\u002B      pointcloud_messages\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(point_cloud_scalar_display_test\n@@ -554,13 \u002B564,16 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET point_cloud_scalar_display_test)\n-    target_include_directories(point_cloud_scalar_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(point_cloud_scalar_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_scalar_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(point_cloud_scalar_display_test PRIVATE test)\n\u002B    target_link_libraries(point_cloud_scalar_display_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      rviz_default_plugins\n\u002B      ${sensor_msgs_TARGETS}\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(point_cloud_transformers_test\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n     test/rviz_default_plugins/displays/pointcloud/point_cloud_transformers/axis_color_pc_transformer_test.cpp\n     test/rviz_default_plugins/displays/pointcloud/point_cloud_transformers/flat_color_pc_transformer_test.cpp\n     test/rviz_default_plugins/displays/pointcloud/point_cloud_transformers/intensity_pc_transformer_test.cpp\n@@ -570,10 \u002B583,14 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET point_cloud_transformers_test)\n-    target_include_directories(point_cloud_transformers_test PUBLIC ${TEST_INCLUDE_DIRS})\n\u002B    target_include_directories(point_cloud_transformers_test PRIVATE test)\n     target_link_libraries(point_cloud_transformers_test\n-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_cloud_transformers_test ${TEST_TARGET_DEPENDENCIES})\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      Qt5::Widgets\n\u002B      rviz_default_plugins\n\u002B      pointcloud_messages\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(point_display_test\n@@ -581,9 \u002B598,13 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET point_display_test)\n-    target_include_directories(point_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(point_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(point_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(point_display_test PRIVATE test)\n\u002B    target_link_libraries(point_display_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(pose_array_display_test\n@@ -591,9 \u002B612,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET pose_array_display_test)\n-    target_include_directories(pose_array_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(pose_array_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(pose_array_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(pose_array_display_test PRIVATE test)\n\u002B    target_link_libraries(pose_array_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(pose_tool_test\n@@ -601,9 \u002B621,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET pose_tool_test)\n-    target_include_directories(pose_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(pose_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(pose_tool_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(pose_tool_test PRIVATE test)\n\u002B    target_link_libraries(pose_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(range_display_test\n@@ -611,9 \u002B630,8 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET range_display_test)\n-    target_include_directories(range_display_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(range_display_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(range_display_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(range_display_test PRIVATE test)\n\u002B    target_link_libraries(range_display_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(robot_test\n@@ -621,11 \u002B639,14 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET robot_test)\n-    target_include_directories(robot_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    # TODO(clalancette): Figure out why putting resource_retriever in the\n-    # TEST_TARGET_DEPENDENCIES doesn\u0027t work.\n-    target_link_libraries(robot_test resource_retriever::resource_retriever ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(robot_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(robot_test PRIVATE test)\n\u002B    target_link_libraries(robot_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      resource_retriever::resource_retriever\n\u002B      Qt5::Widgets\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(ros_image_texture_test\n@@ -633,9 \u002B654,13 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET ros_image_texture_test)\n-    target_include_directories(ros_image_texture_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(ros_image_texture_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(ros_image_texture_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(ros_image_texture_test PRIVATE test)\n\u002B    target_link_libraries(ros_image_texture_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      ${sensor_msgs_TARGETS}\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(selection_tool_test\n@@ -643,20 \u002B668,22 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET selection_tool_test)\n-    target_include_directories(selection_tool_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(selection_tool_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(selection_tool_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(selection_tool_test PRIVATE test)\n\u002B    target_link_libraries(selection_tool_test ${TEST_FIXTURE_WITH_MOCK_LIBRARIES} rviz_default_plugins ogre_testing_environment)\n   endif()\n \n   ament_add_gmock(xy_orbit_view_controller_test\n     test/rviz_default_plugins/view_controllers/xy_orbit/xy_orbit_view_controller_test.cpp\n-    test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET xy_orbit_view_controller_test)\n-    target_include_directories(xy_orbit_view_controller_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(xy_orbit_view_controller_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(xy_orbit_view_controller_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(xy_orbit_view_controller_test PRIVATE test)\n\u002B    target_link_libraries(xy_orbit_view_controller_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      Qt5::Widgets\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(frame_transformer_tf_test\n@@ -664,9 \u002B691,14 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET frame_transformer_tf_test)\n-    target_include_directories(frame_transformer_tf_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(frame_transformer_tf_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(frame_transformer_tf_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(frame_transformer_tf_test PRIVATE test)\n\u002B    target_link_libraries(frame_transformer_tf_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      tf2_ros::tf2_ros\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gmock(transformer_guard_test\n@@ -674,434 \u002B706,414 @@ if(BUILD_TESTING)\n     ${TEST_FIXTURE_SOURCES_WITH_MOCK}\n     ${SKIP_DISPLAY_TESTS})\n   if(TARGET transformer_guard_test)\n-    target_include_directories(transformer_guard_test PUBLIC ${TEST_INCLUDE_DIRS})\n-    target_link_libraries(transformer_guard_test ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(transformer_guard_test ${TEST_TARGET_DEPENDENCIES})\n\u002B    target_include_directories(transformer_guard_test PRIVATE test)\n\u002B    target_link_libraries(transformer_guard_test\n\u002B      ${TEST_FIXTURE_WITH_MOCK_LIBRARIES}\n\u002B      tf2_ros::tf2_ros\n\u002B      rviz_default_plugins\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gtest(axes_display_visual_test\n     test/rviz_default_plugins/displays/axes/axes_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/axes_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET axes_display_visual_test)\n-    target_include_directories(axes_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(axes_display_visual_test PRIVATE test)\n     target_link_libraries(axes_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n\u002B  add_library(point_cloud_common_page_object STATIC test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp)\n\u002B  target_link_libraries(point_cloud_common_page_object PRIVATE Qt5::Test rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B\n   ament_add_gtest(camera_display_visual_test\n     test/rviz_default_plugins/displays/camera/camera_display_visual_test.cpp\n-    test/rviz_default_plugins/publishers/camera_info_publisher.hpp\n     test/rviz_default_plugins/page_objects/camera_display_page_object.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/publishers/image_publisher.hpp\n-    test/rviz_default_plugins/publishers/point_cloud_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET camera_display_visual_test)\n-    target_include_directories(camera_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(camera_display_visual_test PRIVATE test)\n     target_link_libraries(camera_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      rclcpp::rclcpp\n\u002B      ${sensor_msgs_TARGETS}\n\u002B      ${std_msgs_TARGETS}\n\u002B      Qt5::Test\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      tf2::tf2\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(fluid_pressure_display_visual_test\n     test/rviz_default_plugins/displays/fluid_pressure/fluid_pressure_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/fluid_pressure_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET fluid_pressure_display_visual_test)\n-    target_include_directories(fluid_pressure_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(fluid_pressure_display_visual_test PRIVATE test)\n     target_link_libraries(fluid_pressure_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Test\n\u002B      rclcpp::rclcpp\n\u002B      pointcloud_messages\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(grid_display_visual_test\n     test/rviz_default_plugins/displays/grid/grid_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/grid_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET grid_display_visual_test)\n-    target_include_directories(grid_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(grid_display_visual_test PRIVATE test)\n     target_link_libraries(grid_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B    )\n   endif()\n \n   ament_add_gtest(grid_cells_display_visual_test\n     test/rviz_default_plugins/displays/grid_cells/grid_cells_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/grid_cells_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET grid_cells_display_visual_test)\n-    target_include_directories(grid_cells_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(grid_cells_display_visual_test PRIVATE test)\n     target_link_libraries(grid_cells_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      ${nav_msgs_TARGETS}\n\u002B    )\n   endif()\n \n   ament_add_gtest(illuminance_display_visual_test\n     test/rviz_default_plugins/displays/illuminance/illuminance_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/illuminance_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET illuminance_display_visual_test)\n-    target_include_directories(illuminance_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(illuminance_display_visual_test PRIVATE test)\n     target_link_libraries(illuminance_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      pointcloud_messages\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(image_display_visual_test\n     test/rviz_default_plugins/displays/image/image_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/image_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/image_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET image_display_visual_test)\n-    target_include_directories(image_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(image_display_visual_test PRIVATE test)\n     target_link_libraries(image_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      rclcpp::rclcpp\n\u002B      ${sensor_msgs_TARGETS}\n\u002B      ${std_msgs_TARGETS}\n\u002B    )\n   endif()\n \n   ament_add_gtest(interactive_marker_namespace_property_test\n     test/rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property_test.cpp\n-  ${TEST_FIXTURE_SOURCES})\n\u002B    ${SKIP_VISUAL_TESTS}\n\u002B    TIMEOUT 180)\n   if(TARGET interactive_marker_namespace_property_test)\n-    target_include_directories(interactive_marker_namespace_property_test PUBLIC\n-      ${TEST_INCLUDE_DIRS})\n\u002B    target_include_directories(interactive_marker_namespace_property_test PRIVATE test)\n     target_link_libraries(interactive_marker_namespace_property_test\n-      ${TEST_LINK_LIBRARIES})\n-    ament_target_dependencies(interactive_marker_namespace_property_test\n-      ${TEST_TARGET_DEPENDENCIES})\n\u002B      rviz_default_plugins\n\u002B      Qt5::Widgets\n\u002B      ogre_testing_environment\n\u002B    )\n   endif()\n \n   ament_add_gtest(laser_scan_display_visual_test\n     test/rviz_default_plugins/displays/laser_scan/laser_scan_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET laser_scan_display_visual_test)\n-    target_include_directories(laser_scan_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(laser_scan_display_visual_test PRIVATE test)\n     target_link_libraries(laser_scan_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Test\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n\u002B  add_library(marker_display_page_object STATIC test/rviz_default_plugins/page_objects/marker_display_page_object.cpp)\n\u002B  target_link_libraries(marker_display_page_object PRIVATE Qt5::Widgets rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B\n   ament_add_gtest(map_display_visual_test\n     test/rviz_default_plugins/displays/map/map_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/map_display_page_object.cpp\n-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/map_publisher.hpp\n-    test/rviz_default_plugins/publishers/single_marker_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET map_display_visual_test)\n-    target_include_directories(map_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(map_display_visual_test PRIVATE test)\n     target_link_libraries(map_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      ${nav_msgs_TARGETS}\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      marker_display_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(marker_array_display_visual_test\n     test/rviz_default_plugins/displays/marker_array/marker_array_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/marker_array_display_page_object.cpp\n-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/marker_array_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET marker_array_display_visual_test)\n-    target_include_directories(marker_array_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(marker_array_display_visual_test PRIVATE test)\n     target_link_libraries(marker_array_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      marker_display_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(marker_display_visual_test\n     test/rviz_default_plugins/displays/marker/marker_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/marker_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET marker_display_visual_test)\n-    target_include_directories(marker_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(marker_display_visual_test PRIVATE test)\n     target_link_libraries(marker_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${visualization_msgs_TARGETS}\n\u002B      marker_display_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(odometry_display_visual_test\n     test/rviz_default_plugins/displays/odometry/odometry_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/odometry_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/odometry_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET odometry_display_visual_test)\n-    target_include_directories(odometry_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(odometry_display_visual_test PRIVATE test)\n     target_link_libraries(odometry_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      ${nav_msgs_TARGETS}\n\u002B      tf2_ros::tf2_ros\n\u002B    )\n   endif()\n \n   ament_add_gtest(path_display_visual_test\n     test/rviz_default_plugins/displays/path/path_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/path_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/path_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET path_display_visual_test)\n-    target_include_directories(path_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(path_display_visual_test PRIVATE test)\n     target_link_libraries(path_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      ${nav_msgs_TARGETS}\n\u002B    )\n   endif()\n \n   ament_add_gtest(point_display_visual_test\n     test/rviz_default_plugins/displays/point/point_stamped_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/point_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/point_stamped_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET point_display_visual_test)\n-    target_include_directories(point_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(point_display_visual_test PRIVATE test)\n     target_link_libraries(point_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B    )\n   endif()\n \n   ament_add_gtest(point_cloud_display_visual_test\n     test/rviz_default_plugins/displays/pointcloud/point_cloud_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/publishers/point_cloud_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET point_cloud_display_visual_test)\n-    target_include_directories(point_cloud_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(point_cloud_display_visual_test PRIVATE test)\n     target_link_libraries(point_cloud_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      tf2::tf2\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${sensor_msgs_TARGETS}\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(point_cloud2_display_visual_test\n     test/rviz_default_plugins/displays/pointcloud/point_cloud2_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/point_cloud2_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET point_cloud2_display_visual_test)\n-    target_include_directories(point_cloud2_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(point_cloud2_display_visual_test PRIVATE test)\n     target_link_libraries(point_cloud2_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      pointcloud_messages\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n\u002B  add_library(pose_display_page_object STATIC test/rviz_default_plugins/page_objects/pose_display_page_object.cpp)\n\u002B  target_link_libraries(pose_display_page_object PRIVATE Qt5::Widgets rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B\n   ament_add_gtest(pose_array_display_visual_test\n     test/rviz_default_plugins/displays/pose_array/pose_array_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/pose_array_display_page_object.cpp\n-    test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/pose_array_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET pose_array_display_visual_test)\n-    target_include_directories(pose_array_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(pose_array_display_visual_test PRIVATE test)\n     target_link_libraries(pose_array_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      pose_display_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(pose_display_visual_test\n     test/rviz_default_plugins/displays/pose/pose_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/pose_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET pose_display_visual_test)\n-    target_include_directories(pose_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(pose_display_visual_test PRIVATE test)\n     target_link_libraries(pose_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      pose_display_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(pose_with_covariance_display_visual_test\n     test/rviz_default_plugins/displays/pose_covariance/pose_with_covariance_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/pose_with_covariance_display_page_object.cpp\n-    test/rviz_default_plugins/publishers/pose_with_covariance_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET pose_with_covariance_display_visual_test)\n-    target_include_directories(pose_with_covariance_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(pose_with_covariance_display_visual_test PRIVATE test)\n     target_link_libraries(pose_with_covariance_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B      ${geometry_msgs_TARGETS}\n\u002B      rclcpp::rclcpp\n\u002B      ${std_msgs_TARGETS}\n\u002B      tf2_ros::tf2_ros\n\u002B    )\n   endif()\n \n   ament_add_gtest(range_display_visual_test\n     test/rviz_default_plugins/displays/range/range_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/range_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET range_display_visual_test)\n-    target_include_directories(range_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(range_display_visual_test PRIVATE test)\n     target_link_libraries(range_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B    )\n   endif()\n \n   ament_add_gtest(relative_humidity_display_visual_test\n     test/rviz_default_plugins/displays/relative_humidity/relative_humidity_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/relative_humidity_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET relative_humidity_display_visual_test)\n-    target_include_directories(relative_humidity_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(relative_humidity_display_visual_test PRIVATE test)\n     target_link_libraries(relative_humidity_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(robot_model_display_visual_test\n     test/rviz_default_plugins/displays/robot_model/robot_model_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/robot_model_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET robot_model_display_visual_test)\n-    target_include_directories(robot_model_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(robot_model_display_visual_test PRIVATE test)\n     target_link_libraries(robot_model_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n       ament_index_cpp::ament_index_cpp\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B    )\n   endif()\n \n   ament_add_gtest(temperature_display_visual_test\n     test/rviz_default_plugins/displays/temperature/temperature_display_visual_test.cpp\n-    test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp\n-    test/rviz_default_plugins/pointcloud_messages.cpp\n-    test/rviz_default_plugins/publishers/temperature_publisher.hpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET temperature_display_visual_test)\n-    target_include_directories(temperature_display_visual_test PUBLIC\n-      test/page_objects\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(temperature_display_visual_test PRIVATE test)\n     target_link_libraries(temperature_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      Qt5::Test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      point_cloud_common_page_object\n\u002B    )\n   endif()\n \n   ament_add_gtest(tf_display_visual_test\n     test/rviz_default_plugins/displays/tf/tf_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/tf_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET tf_display_visual_test)\n-    target_include_directories(tf_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(tf_display_visual_test PRIVATE test)\n     target_link_libraries(tf_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B    )\n   endif()\n \n   ament_add_gtest(wrench_display_visual_test\n     test/rviz_default_plugins/displays/wrench/wrench_stamped_display_visual_test.cpp\n     test/rviz_default_plugins/page_objects/wrench_display_page_object.cpp\n-    ${TEST_FIXTURE_SOURCES}\n     ${SKIP_VISUAL_TESTS}\n     TIMEOUT 180)\n   if(TARGET wrench_display_visual_test)\n-    target_include_directories(wrench_display_visual_test PUBLIC\n-      ${TEST_INCLUDE_DIRS}\n-      ${rviz_visual_testing_framework_INCLUDE_DIRS})\n\u002B    target_include_directories(wrench_display_visual_test PRIVATE test)\n     target_link_libraries(wrench_display_visual_test\n-      ${TEST_LINK_LIBRARIES}\n-      rviz_visual_testing_framework::rviz_visual_testing_framework)\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      Qt5::Widgets\n\u002B    )\n   endif()\n endif()\n \ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/display_test_fixture.cpp rviz_default_plugins/test/rviz_default_plugins/displays/display_test_fixture.cpp\nindex eb6364b1..7ba53d21 100644\n--- rviz_default_plugins/test/rviz_default_plugins/displays/display_test_fixture.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/display_test_fixture.cpp\n@@ -35,6 \u002B35,8 @@\n \n #include \u003COgreSceneNode.h\u003E\n \n\u002B#include \u0022rclcpp/clock.hpp\u0022\n\u002B\n void DisplayTestFixture::SetUpTestCase()\n {\n   testing_environment_ = std::make_shared\u003Crviz_default_plugins::OgreTestingEnvironment\u003E();\ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property_test.cpp rviz_default_plugins/test/rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property_test.cpp\nindex ce57cb3b..f097ceff 100644\n--- rviz_default_plugins/test/rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property_test.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property_test.cpp\n@@ -31,6 \u002B31,8 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \\\n   \u0022rviz_default_plugins/displays/interactive_markers/interactive_marker_namespace_property.hpp\u0022\n \ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.cpp rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.cpp\nindex ddbfb914..08cd17b8 100644\n--- rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.cpp\n@@ -36,7 \u002B36,11 @@\n \n #include \u003COgreVector.h\u003E\n \n\u002B#include \u0022geometry_msgs/msg/point.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022std_msgs/msg/color_rgba.hpp\u0022\n\u002B#include \u0022std_msgs/msg/header.hpp\u0022\n\u002B#include \u0022visualization_msgs/msg/marker.hpp\u0022\n \n namespace testing\n {\ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.hpp rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.hpp\nindex bdde8777..c04e29f0 100644\n--- rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/marker/marker_messages.hpp\n@@ -32,6 \u002B32,8 @@\n #ifndef RVIZ_DEFAULT_PLUGINS__DISPLAYS__MARKER__MARKER_MESSAGES_HPP_\n #define RVIZ_DEFAULT_PLUGINS__DISPLAYS__MARKER__MARKER_MESSAGES_HPP_\n \n\u002B#include \u0022geometry_msgs/msg/point.hpp\u0022\n\u002B#include \u0022std_msgs/msg/color_rgba.hpp\u0022\n #include \u0022visualization_msgs/msg/marker.hpp\u0022\n \n namespace testing\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/map_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/map_display_page_object.cpp\nindex 2c6caa99..40617774 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/map_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/map_display_page_object.cpp\n@@ -27,6 \u002B27,8 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022map_display_page_object.hpp\u0022\n \n MapDisplayPageObject::MapDisplayPageObject()\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\nindex 7f8bd6ce..ea0127e5 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.cpp\n@@ -27,6 \u002B27,8 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022marker_display_page_object.hpp\u0022\n \n MarkerDisplayPageObject::MarkerDisplayPageObject()\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.hpp rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.hpp\nindex 092dcc61..613f4470 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/marker_display_page_object.hpp\n@@ -30,6 \u002B30,8 @@\n #ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__MARKER_DISPLAY_PAGE_OBJECT_HPP_\n #define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__MARKER_DISPLAY_PAGE_OBJECT_HPP_\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022rviz_visual_testing_framework/page_objects/base_page_object.hpp\u0022\n \n class MarkerDisplayPageObject : public BasePageObject\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/point_cloud_common_page_object.hpp rviz_default_plugins/test/rviz_default_plugins/page_objects/point_cloud_common_page_object.hpp\nindex f6b27cb3..0f5365a6 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/point_cloud_common_page_object.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/point_cloud_common_page_object.hpp\n@@ -30,6 \u002B30,8 @@\n #ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__POINT_CLOUD_COMMON_PAGE_OBJECT_HPP_\n #define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__POINT_CLOUD_COMMON_PAGE_OBJECT_HPP_\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022rviz_visual_testing_framework/page_objects/base_page_object.hpp\u0022\n \n class PointCloudCommonPageObject : public BasePageObject\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\nindex e8ce3ff1..0178ae55 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.cpp\n@@ -29,6 \u002B29,8 @@\n \n #include \u0022pose_display_page_object.hpp\u0022\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n \ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.hpp rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.hpp\nindex 4fcf1adb..37774a35 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_display_page_object.hpp\n@@ -30,6 \u002B30,8 @@\n #ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__POSE_DISPLAY_PAGE_OBJECT_HPP_\n #define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__POSE_DISPLAY_PAGE_OBJECT_HPP_\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022rviz_visual_testing_framework/page_objects/base_page_object.hpp\u0022\n \n class PoseDisplayPageObject : public BasePageObject\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_with_covariance_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_with_covariance_display_page_object.cpp\nindex ecd2ef0f..c8d1f8e5 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_with_covariance_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/pose_with_covariance_display_page_object.cpp\n@@ -28,6 \u002B28,8 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022pose_with_covariance_display_page_object.hpp\u0022\n \n PoseWithCovarianceDisplayPageObject::PoseWithCovarianceDisplayPageObject()\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/range_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/range_display_page_object.cpp\nindex d05a6f31..d3d2c9dd 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/range_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/range_display_page_object.cpp\n@@ -27,6 \u002B27,8 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022range_display_page_object.hpp\u0022\n \n RangeDisplayPageObject::RangeDisplayPageObject()\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/robot_model_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/robot_model_display_page_object.cpp\nindex 73e24a57..d5a9983e 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/robot_model_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/robot_model_display_page_object.cpp\n@@ -27,6 \u002B27,8 @@\n  * POSSIBILITY OF SUCH DAMAGE.\n  */\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u0022robot_model_display_page_object.hpp\u0022\n \n RobotModelDisplayPageObject::RobotModelDisplayPageObject()\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/tf_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/tf_display_page_object.cpp\nindex 64689c02..de0cfa89 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/tf_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/tf_display_page_object.cpp\n@@ -29,6 \u002B29,8 @@\n \n #include \u0022tf_display_page_object.hpp\u0022\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n \ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/wrench_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/wrench_display_page_object.cpp\nindex 3bc700c9..17674195 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/wrench_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/wrench_display_page_object.cpp\n@@ -29,6 \u002B29,8 @@\n \n #include \u0022wrench_display_page_object.hpp\u0022\n \n\u002B#include \u003CQString\u003E\n\u002B\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n \ndiff --git rviz_default_plugins/test/rviz_default_plugins/pointcloud_messages.cpp rviz_default_plugins/test/rviz_default_plugins/pointcloud_messages.cpp\nindex 5e472a31..9ee95669 100644\n--- rviz_default_plugins/test/rviz_default_plugins/pointcloud_messages.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/pointcloud_messages.cpp\n@@ -33,7 \u002B33,11 @@\n #include \u003Cmemory\u003E\n #include \u003Cvector\u003E\n \n\u002B#include \u0022geometry_msgs/msg/point32.hpp\u0022\n #include \u0022rclcpp/clock.hpp\u0022\n\u002B#include \u0022sensor_msgs/msg/point_cloud2.hpp\u0022\n\u002B#include \u0022sensor_msgs/msg/point_field.hpp\u0022\n\u002B#include \u0022std_msgs/msg/header.hpp\u0022\n \n namespace rviz_default_plugins\n {\ndiff --git rviz_default_plugins/test/rviz_default_plugins/publishers/pose_array_publisher.hpp rviz_default_plugins/test/rviz_default_plugins/publishers/pose_array_publisher.hpp\nindex a8c3e675..265100cf 100644\n--- rviz_default_plugins/test/rviz_default_plugins/publishers/pose_array_publisher.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/publishers/pose_array_publisher.hpp\n@@ -35,6 \u002B35,7 @@\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp/clock.hpp\u0022\n #include \u0022std_msgs/msg/header.hpp\u0022\n\u002B#include \u0022geometry_msgs/msg/pose.hpp\u0022\n #include \u0022geometry_msgs/msg/pose_array.hpp\u0022\n \n using namespace std::chrono_literals;  // NOLINT\ndiff --git rviz_visual_testing_framework/CMakeLists.txt rviz_visual_testing_framework/CMakeLists.txt\nindex eb2c6ad0..f393ec72 100644\n--- rviz_visual_testing_framework/CMakeLists.txt\n\u002B\u002B\u002B rviz_visual_testing_framework/CMakeLists.txt\n@@ -24,47 \u002B24,20 @@ if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n endif()\n \n find_package(ament_cmake REQUIRED)\n-\n\u002Bfind_package(geometry_msgs REQUIRED)\n\u002Bfind_package(Qt5 REQUIRED COMPONENTS Widgets Test)\n\u002Bfind_package(rclcpp REQUIRED)\n find_package(rcutils REQUIRED)\n-\n find_package(rviz_common REQUIRED)\n-\n find_package(rviz_ogre_vendor REQUIRED)\n-\n-find_package(Qt5 REQUIRED COMPONENTS Widgets Test)\n\u002Bfind_package(rviz_rendering REQUIRED)\n\u002Bfind_package(std_msgs REQUIRED)\n\u002Bfind_package(tf2 REQUIRED)\n\u002Bfind_package(tf2_ros REQUIRED)\n \n find_package(ament_cmake_gtest REQUIRED)\n ament_find_gtest()\n \n-set(visual_test_framework_source_files\n-  include/rviz_visual_testing_framework/page_objects/base_page_object.hpp\n-  src/page_objects/base_page_object.cpp\n-  include/rviz_visual_testing_framework/page_objects/page_object_with_window.hpp\n-  src/page_objects/page_object_with_window.cpp\n-  src/internal/rviz_scene_test.cpp\n-  include/rviz_visual_testing_framework/internal/rviz_scene_test.hpp\n-  include/rviz_visual_testing_framework/internal/display_handler.hpp\n-  src/internal/display_handler.cpp\n-  src/internal/image_tester.cpp\n-  include/rviz_visual_testing_framework/internal/image_tester.hpp\n-  include/rviz_visual_testing_framework/test_helpers.hpp\n-  src/test_helpers.cpp\n-  include/rviz_visual_testing_framework/internal/executor.hpp\n-  src/internal/executor.cpp\n-  include/rviz_visual_testing_framework/internal/transform_message_creator.hpp\n-  src/internal/transform_message_creator.cpp\n-  include/rviz_visual_testing_framework/internal/visual_test.hpp\n-  src/internal/visual_test.cpp\n-  include/rviz_visual_testing_framework/visual_test_fixture.hpp\n-  src/visual_test_fixture.cpp\n-  include/rviz_visual_testing_framework/visual_test_publisher.hpp\n-)\n-\n-set(visual_tests_target_libaries\n-  rviz_common::rviz_common\n-  Qt5::Widgets\n-  Qt5::Test)\n-\n # TODO(wjwwood): this block is to setup the windeployqt tool, could be removed later.\n if(Qt5_FOUND AND WIN32 AND TARGET Qt5::qmake AND NOT TARGET Qt5::windeployqt)\n   get_target_property(_qt5_qmake_location Qt5::qmake IMPORTED_LOCATION)\n@@ -77,7 \u002B50,18 @@ if(Qt5_FOUND AND WIN32 AND TARGET Qt5::qmake AND NOT TARGET Qt5::windeployqt)\n   )\n endif()\n \n-add_library(rviz_visual_testing_framework STATIC ${visual_test_framework_source_files})\n\u002Badd_library(rviz_visual_testing_framework STATIC\n\u002B  src/page_objects/base_page_object.cpp\n\u002B  src/page_objects/page_object_with_window.cpp\n\u002B  src/internal/rviz_scene_test.cpp\n\u002B  src/internal/display_handler.cpp\n\u002B  src/internal/image_tester.cpp\n\u002B  src/test_helpers.cpp\n\u002B  src/internal/executor.cpp\n\u002B  src/internal/transform_message_creator.cpp\n\u002B  src/internal/visual_test.cpp\n\u002B  src/visual_test_fixture.cpp\n\u002B)\n \n target_include_directories(rviz_visual_testing_framework\n   PUBLIC\n@@ -85,12 \u002B69,22 @@ target_include_directories(rviz_visual_testing_framework\n     $\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\n     ${GTEST_INCLUDE_DIRS})\n \n-target_link_libraries(rviz_visual_testing_framework\n-  ${visual_tests_target_libaries})\n\u002Btarget_link_libraries(rviz_visual_testing_framework PUBLIC\n\u002B  ${geometry_msgs_TARGETS}\n\u002B  Qt5::Test\n\u002B  Qt5::Widgets\n\u002B  rclcpp::rclcpp\n\u002B  rcutils::rcutils\n\u002B  rviz_common::rviz_common\n\u002B  rviz_ogre_vendor::OgreMain\n\u002B  rviz_rendering::rviz_rendering\n\u002B  ${std_msgs_TARGETS}\n\u002B  tf2::tf2\n\u002B  tf2_ros::tf2_ros\n\u002B)\n \n # export information to downstream packages\n-ament_export_dependencies(Qt5)\n-ament_export_dependencies(rviz_common)\n\u002Bament_export_dependencies(geometry_msgs Qt5 rclcpp rcutils rviz_common rviz_ogre_vendor rviz_rendering std_msgs tf2 tf2_ros)\n \n # Export old-style CMake variables\n ament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\ndiff --git rviz_visual_testing_framework/package.xml rviz_visual_testing_framework/package.xml\nindex e021a949..2400ef1e 100644\n--- rviz_visual_testing_framework/package.xml\n\u002B\u002B\u002B rviz_visual_testing_framework/package.xml\n@@ -26,8 \u002B26,15 @@\n \n   \u003Cbuild_depend\u003Eqtbase5-dev\u003C/build_depend\u003E\n \n\u002B  \u003Cdepend\u003Egeometry_msgs\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Erclcpp\u003C/depend\u003E\n   \u003Cdepend\u003Ercutils\u003C/depend\u003E\n   \u003Cdepend\u003Erviz_common\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Erviz_ogre_vendor\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Erviz_rendering\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Estd_msgs\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Etf2\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Etf2_ros\u003C/depend\u003E\n   \u003Cdepend\u003Eament_cmake_gtest\u003C/depend\u003E\n \n   \u003C!-- TODO(jacobperron): Replace with ament_lint_common when ament_copyright is working --\u003E\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "2de5c8ea447a1614a7c36d0fcf2250cefc21a594",
    "RawMessage": "Revert \u0022Add types to Action Server and Action Client (#1349)\u0022 (#1359)",
    "Changes": "diff --git rclpy/rclpy/action/client.py rclpy/rclpy/action/client.py\nindex 7a25873..f22cca0 100644\n--- rclpy/rclpy/action/client.py\n\u002B\u002B\u002B rclpy/rclpy/action/client.py\n@@ -14,112 \u002B14,72 @@\n \n import threading\n import time\n-from types import TracebackType\n from typing import Any\n-from typing import Callable\n-from typing import Dict\n-from typing import Generic\n-from typing import Optional\n-from typing import Tuple\n-from typing import Type\n-from typing import TYPE_CHECKING\n from typing import TypedDict\n-from typing import TypeVar\n import uuid\n import weakref\n \n from action_msgs.msg import GoalStatus\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n from action_msgs.srv import CancelGoal\n-from builtin_interfaces.msg import Time\n\u002B\n from rclpy.executors import await_or_execute\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import qos_profile_action_status_default\n from rclpy.qos import qos_profile_services_default\n from rclpy.qos import QoSProfile\n from rclpy.task import Future\n-from rclpy.type_support import Action\n from rclpy.type_support import check_for_type_support\n-from rclpy.type_support import FeedbackMessage\n-from rclpy.type_support import FeedbackT\n-from rclpy.type_support import GetResultServiceResponse\n-from rclpy.type_support import GoalT\n-from rclpy.type_support import ResultT\n-from rclpy.type_support import SendGoalServiceResponse\n from rclpy.waitable import NumberOfEntities, Waitable\n-from unique_identifier_msgs.msg import UUID\n-\n-if TYPE_CHECKING:\n-    from rclpy.node import Node\n-    from rclpy.callback_groups import CallbackGroup\n-    from typing_extensions import Unpack, TypeAlias\n-\n-    ClientGoalHandleDictResultT = TypeVar(\u0027ClientGoalHandleDictResultT\u0027)\n-    ClientGoalHandleDictFeedbackT = TypeVar(\u0027ClientGoalHandleDictFeedbackT\u0027)\n-\n-    class ClientGoalHandleDict(TypedDict,\n-                               Generic[ClientGoalHandleDictResultT, ClientGoalHandleDictFeedbackT],\n-                               total=False):\n-        goal: Tuple[int, SendGoalServiceResponse]\n-        cancel: Tuple[int, CancelGoal.Response]\n-        result: Tuple[int, GetResultServiceResponse[ClientGoalHandleDictResultT]]\n-        feedback: FeedbackMessage[ClientGoalHandleDictFeedbackT]\n-        status: GoalStatusArray\n-else:\n-    ClientGoalHandleDict: \u0027TypeAlias\u0027 = Dict[str, object]\n \n-\n-T = TypeVar(\u0027T\u0027)\n\u002Bfrom unique_identifier_msgs.msg import UUID\n \n \n-class SendGoalKWargs(TypedDict):\n-    feedback_callback: Optional[Callable[[FeedbackT], None]]\n-    goal_uuid: Optional[UUID]\n\u002Bclass ClientGoalHandleDict(TypedDict, total=False):\n\u002B    goal: Any\n\u002B    cancel: Any\n\u002B    result: Any\n\u002B    feedback: Any\n\u002B    status: Any\n \n \n-class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n\u002Bclass ClientGoalHandle():\n     \u0022\u0022\u0022Goal handle for working with Action Clients.\u0022\u0022\u0022\n \n-    def __init__(self, action_client: \u0027ActionClient[GoalT, ResultT, FeedbackT]\u0027,\n-                 goal_id: UUID, goal_response: SendGoalServiceResponse):\n\u002B    def __init__(self, action_client, goal_id, goal_response):\n         self._action_client = action_client\n         self._goal_id = goal_id\n         self._goal_response = goal_response\n         self._status = GoalStatus.STATUS_UNKNOWN\n \n-    def __eq__(self, other: object) -\u003E bool:\n-        if not isinstance(other, ClientGoalHandle):\n-            return False\n\u002B    def __eq__(self, other):\n         return self._goal_id == other.goal_id\n \n-    def __ne__(self, other: object) -\u003E bool:\n-        if not isinstance(other, ClientGoalHandle):\n-            return True\n\u002B    def __ne__(self, other):\n         return self._goal_id != other.goal_id\n \n-    def __repr__(self) -\u003E str:\n\u002B    def __repr__(self):\n         return \u0027ClientGoalHandle \u003Cid={0}, accepted={1}, status={2}\u003E\u0027.format(\n                 self.goal_id.uuid,\n                 self.accepted,\n                 self.status)\n \n     @property\n-    def goal_id(self) -\u003E UUID:\n\u002B    def goal_id(self):\n         return self._goal_id\n \n     @property\n-    def stamp(self) -\u003E Time:\n\u002B    def stamp(self):\n         return self._goal_response.stamp\n \n     @property\n-    def accepted(self) -\u003E bool:\n\u002B    def accepted(self):\n         return self._goal_response.accepted\n \n     @property\n-    def status(self) -\u003E int:\n\u002B    def status(self):\n         return self._status\n \n-    def cancel_goal(self) -\u003E Optional[CancelGoal.Response]:\n\u002B    def cancel_goal(self):\n         \u0022\u0022\u0022\n         Send a cancel request for the goal and wait for the response.\n \n@@ -129,7 \u002B89,7 @@ class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n         \u0022\u0022\u0022\n         return self._action_client._cancel_goal(self)\n \n-    def cancel_goal_async(self) -\u003E Future[CancelGoal.Response]:\n\u002B    def cancel_goal_async(self):\n         \u0022\u0022\u0022\n         Asynchronous request for the goal be canceled.\n \n@@ -138,7 \u002B98,7 @@ class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n         \u0022\u0022\u0022\n         return self._action_client._cancel_goal_async(self)\n \n-    def get_result(self) -\u003E Optional[GetResultServiceResponse[ResultT]]:\n\u002B    def get_result(self):\n         \u0022\u0022\u0022\n         Request the result for the goal and wait for the response.\n \n@@ -148,7 \u002B108,7 @@ class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n         \u0022\u0022\u0022\n         return self._action_client._get_result(self)\n \n-    def get_result_async(self) -\u003E Future[GetResultServiceResponse[ResultT]]:\n\u002B    def get_result_async(self):\n         \u0022\u0022\u0022\n         Asynchronously request the goal result.\n \n@@ -158,23 \u002B118,22 @@ class ClientGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n         return self._action_client._get_result_async(self)\n \n \n-class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n-                   Waitable[\u0027ClientGoalHandleDict[ResultT, FeedbackT]\u0027]):\n\u002Bclass ActionClient(Waitable[ClientGoalHandleDict]):\n     \u0022\u0022\u0022ROS Action client.\u0022\u0022\u0022\n \n     def __init__(\n         self,\n-        node: \u0027Node\u0027,\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n\u002B        node,\n\u002B        action_type,\n\u002B        action_name,\n         *,\n-        callback_group: \u0027Optional[CallbackGroup]\u0027 = None,\n-        goal_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        result_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        cancel_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        feedback_sub_qos_profile: QoSProfile = QoSProfile(depth=10),\n-        status_sub_qos_profile: QoSProfile = qos_profile_action_status_default\n-    ) -\u003E None:\n\u002B        callback_group=None,\n\u002B        goal_service_qos_profile=qos_profile_services_default,\n\u002B        result_service_qos_profile=qos_profile_services_default,\n\u002B        cancel_service_qos_profile=qos_profile_services_default,\n\u002B        feedback_sub_qos_profile=QoSProfile(depth=10),\n\u002B        status_sub_qos_profile=qos_profile_action_status_default\n\u002B    ):\n         \u0022\u0022\u0022\n         Create an ActionClient.\n \n@@ -215,34 \u002B174,28 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         self._is_ready = False\n \n         # key: UUID in bytes, value: weak reference to ClientGoalHandle\n-        self._goal_handles: Dict[bytes,\n-                                 weakref.ReferenceType[ClientGoalHandle[GoalT,\n-                                                                        ResultT,\n-                                                                        FeedbackT]]] = {}\n\u002B        self._goal_handles = {}\n         # key: goal request sequence_number, value: Future for goal response\n-        self._pending_goal_requests: Dict[int, Future[ClientGoalHandle[GoalT,\n-                                                                       ResultT,\n-                                                                       FeedbackT]]] = {}\n\u002B        self._pending_goal_requests = {}\n         # key: goal request sequence_number, value: UUID\n-        self._goal_sequence_number_to_goal_id: Dict[int, UUID] = {}\n\u002B        self._goal_sequence_number_to_goal_id = {}\n         # key: cancel request sequence number, value: Future for cancel response\n-        self._pending_cancel_requests: Dict[int, Future[CancelGoal.Response]] = {}\n\u002B        self._pending_cancel_requests = {}\n         # key: result request sequence number, value: Future for result response\n-        self._pending_result_requests: Dict[int, Future[GetResultServiceResponse[ResultT]]] = {}\n\u002B        self._pending_result_requests = {}\n         # key: result request sequence_number, value: UUID\n-        self._result_sequence_number_to_goal_id: Dict[int, UUID] = {}\n\u002B        self._result_sequence_number_to_goal_id = {}\n         # key: UUID in bytes, value: callback function\n-        self._feedback_callbacks: Dict[bytes, Callable[[FeedbackT], None]] = {}\n\u002B        self._feedback_callbacks = {}\n \n         callback_group.add_entity(self)\n         self._node.add_waitable(self)\n         self._logger = self._node.get_logger().get_child(\u0027action_client\u0027)\n \n-    def _generate_random_uuid(self) -\u003E UUID:\n\u002B    def _generate_random_uuid(self):\n         return UUID(uuid=list(uuid.uuid4().bytes))\n \n-    def _remove_pending_request(self, future: Future[T], pending_requests: Dict[int, Future[T]]\n-                                ) -\u003E Optional[int]:\n\u002B    def _remove_pending_request(self, future, pending_requests):\n         \u0022\u0022\u0022\n         Remove a future from the list of pending requests.\n \n@@ -266,18 \u002B219,15 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n                     return seq\n         return None\n \n-    def _remove_pending_goal_request(self,\n-                                     future: Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]]\n-                                     ) -\u003E None:\n\u002B    def _remove_pending_goal_request(self, future):\n         seq = self._remove_pending_request(future, self._pending_goal_requests)\n         if seq in self._goal_sequence_number_to_goal_id:\n             del self._goal_sequence_number_to_goal_id[seq]\n \n-    def _remove_pending_cancel_request(self, future: Future[CancelGoal.Response]) -\u003E None:\n\u002B    def _remove_pending_cancel_request(self, future):\n         self._remove_pending_request(future, self._pending_cancel_requests)\n \n-    def _remove_pending_result_request(self, future: Future[GetResultServiceResponse[ResultT]]\n-                                       ) -\u003E None:\n\u002B    def _remove_pending_result_request(self, future):\n         seq = self._remove_pending_request(future, self._pending_result_requests)\n         if seq in self._result_sequence_number_to_goal_id:\n             goal_uuid = bytes(self._result_sequence_number_to_goal_id[seq].uuid)\n@@ -287,7 \u002B237,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n                 del self._feedback_callbacks[goal_uuid]\n \n     # Start Waitable API\n-    def is_ready(self, wait_set: _rclpy.WaitSet) -\u003E bool:\n\u002B    def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if one or more entities are ready in the wait set.\u0022\u0022\u0022\n         ready_entities = self._client_handle.is_ready(wait_set)\n         self._is_feedback_ready = ready_entities[0]\n@@ -297,9 \u002B247,9 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         self._is_result_response_ready = ready_entities[4]\n         return any(ready_entities)\n \n-    def take_data(self) -\u003E \u0027ClientGoalHandleDict[ResultT, FeedbackT]\u0027:\n\u002B    def take_data(self) -\u003E ClientGoalHandleDict:\n         \u0022\u0022\u0022Take stuff from lower level so the wait set doesn\u0027t immediately wake again.\u0022\u0022\u0022\n-        data: \u0027ClientGoalHandleDict[ResultT, FeedbackT]\u0027 = {}\n\u002B        data: ClientGoalHandleDict = {}\n         if self._is_goal_response_ready:\n             taken_data = self._client_handle.take_goal_response(\n                 self._action_type.Impl.SendGoalService.Response)\n@@ -337,7 \u002B287,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         return data\n \n-    async def execute(self, taken_data: \u0027ClientGoalHandleDict[ResultT, FeedbackT]\u0027) -\u003E None:\n\u002B    async def execute(self, taken_data: ClientGoalHandleDict) -\u003E None:\n         \u0022\u0022\u0022\n         Execute work after data has been taken from a ready wait set.\n \n@@ -400,9 \u002B350,9 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n                 status = status_msg.status\n \n                 if goal_uuid in self._goal_handles:\n-                    status_goal_handle = self._goal_handles[goal_uuid]()\n-                    if status_goal_handle is not None:\n-                        status_goal_handle._status = status\n\u002B                    goal_handle = self._goal_handles[goal_uuid]()\n\u002B                    if goal_handle is not None:\n\u002B                        goal_handle._status = status\n                         # Remove \u0022done\u0022 goals from the list\n                         if (GoalStatus.STATUS_SUCCEEDED == status or\n                                 GoalStatus.STATUS_CANCELED == status or\n@@ -412,26 \u002B362,24 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n                         # Weak reference is None\n                         del self._goal_handles[goal_uuid]\n \n-    def get_num_entities(self) -\u003E NumberOfEntities:\n\u002B    def get_num_entities(self):\n         \u0022\u0022\u0022Return number of each type of entity used in the wait set.\u0022\u0022\u0022\n         num_entities = self._client_handle.get_num_entities()\n         return NumberOfEntities(*num_entities)\n \n-    def add_to_wait_set(self, wait_set: _rclpy.WaitSet) -\u003E None:\n\u002B    def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n         self._client_handle.add_to_waitset(wait_set)\n \n-    def __enter__(self) -\u003E None:\n-        self._client_handle.__enter__()\n\u002B    def __enter__(self):\n\u002B        return self._client_handle.__enter__()\n \n-    def __exit__(self, t: Optional[Type[BaseException]], v: Optional[BaseException],\n-                 tb: Optional[TracebackType]) -\u003E None:\n\u002B    def __exit__(self, t, v, tb):\n         self._client_handle.__exit__(t, v, tb)\n \n     # End Waitable API\n \n-    def send_goal(self, goal: GoalT, **kwargs: \u0027Unpack[SendGoalKWargs]\u0027\n-                  ) -\u003E Optional[GetResultServiceResponse[ResultT]]:\n\u002B    def send_goal(self, goal, **kwargs):\n         \u0022\u0022\u0022\n         Send a goal and wait for the result.\n \n@@ -455,7 \u002B403,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         event = threading.Event()\n \n-        def unblock(future: Future[Any]) -\u003E None:\n\u002B        def unblock(future):\n             nonlocal event\n             event.set()\n \n@@ -463,24 \u002B411,16 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         send_goal_future.add_done_callback(unblock)\n \n         event.wait()\n-        exeception = send_goal_future.exception()\n-        if exeception is not None:\n-            raise exeception\n\u002B        if send_goal_future.exception() is not None:\n\u002B            raise send_goal_future.exception()\n \n         goal_handle = send_goal_future.result()\n \n-        if goal_handle is None:\n-            return None\n         result = self._get_result(goal_handle)\n \n         return result\n \n-    def send_goal_async(\n-        self,\n-        goal: GoalT,\n-        feedback_callback: Optional[Callable[[FeedbackT], None]] = None,\n-        goal_uuid: Optional[UUID] = None\n-    ) -\u003E Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]]:\n\u002B    def send_goal_async(self, goal, feedback_callback=None, goal_uuid=None):\n         \u0022\u0022\u0022\n         Send a goal and asynchronously get the result.\n \n@@ -517,7 \u002B457,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n             goal_uuid = bytes(request.goal_id.uuid)\n             self._feedback_callbacks[goal_uuid] = feedback_callback\n \n-        future: Future[ClientGoalHandle[GoalT, ResultT, FeedbackT]] = Future()\n\u002B        future = Future()\n         self._pending_goal_requests[sequence_number] = future\n         self._goal_sequence_number_to_goal_id[sequence_number] = request.goal_id\n         future.add_done_callback(self._remove_pending_goal_request)\n@@ -526,8 \u002B466,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         return future\n \n-    def _cancel_goal(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                     ) -\u003E Optional[CancelGoal.Response]:\n\u002B    def _cancel_goal(self, goal_handle):\n         \u0022\u0022\u0022\n         Send a cancel request for an active goal and wait for the response.\n \n@@ -539,7 \u002B478,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         \u0022\u0022\u0022\n         event = threading.Event()\n \n-        def unblock(future: Future[Any]) -\u003E None:\n\u002B        def unblock(future):\n             nonlocal event\n             event.set()\n \n@@ -547,15 \u002B486,11 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         future.add_done_callback(unblock)\n \n         event.wait()\n-        exeception = future.exception()\n-        if exeception is not None:\n-            raise exeception\n\u002B        if future.exception() is not None:\n\u002B            raise future.exception()\n         return future.result()\n \n-    def _cancel_goal_async(\n-        self,\n-        goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-    ) -\u003E Future[CancelGoal.Response]:\n\u002B    def _cancel_goal_async(self, goal_handle):\n         \u0022\u0022\u0022\n         Send a cancel request for an active goal and asynchronously get the result.\n \n@@ -575,7 \u002B510,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n             raise RuntimeError(\n                 \u0027Sequence ({}) conflicts with pending cancel request\u0027.format(sequence_number))\n \n-        future: Future[CancelGoal.Response] = Future()\n\u002B        future = Future()\n         self._pending_cancel_requests[sequence_number] = future\n         future.add_done_callback(self._remove_pending_cancel_request)\n         # Add future so executor is aware\n@@ -583,8 \u002B518,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         return future\n \n-    def _get_result(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                    ) -\u003E Optional[GetResultServiceResponse[ResultT]]:\n\u002B    def _get_result(self, goal_handle):\n         \u0022\u0022\u0022\n         Request the result for an active goal and wait for the response.\n \n@@ -596,7 \u002B530,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         \u0022\u0022\u0022\n         event = threading.Event()\n \n-        def unblock(future: Future[Any]) -\u003E None:\n\u002B        def unblock(future):\n             nonlocal event\n             event.set()\n \n@@ -604,13 \u002B538,11 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         future.add_done_callback(unblock)\n \n         event.wait()\n-        exception = future.exception()\n-        if exception is not None:\n-            raise exception\n\u002B        if future.exception() is not None:\n\u002B            raise future.exception()\n         return future.result()\n \n-    def _get_result_async(self, goal_handle: ClientGoalHandle[GoalT, ResultT, FeedbackT]\n-                          ) -\u003E Future[GetResultServiceResponse[ResultT]]:\n\u002B    def _get_result_async(self, goal_handle):\n         \u0022\u0022\u0022\n         Request the result for an active goal asynchronously.\n \n@@ -630,7 \u002B562,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n             raise RuntimeError(\n                 \u0027Sequence ({}) conflicts with pending result request\u0027.format(sequence_number))\n \n-        future: Future[GetResultServiceResponse[ResultT]] = Future()\n\u002B        future = Future()\n         self._pending_result_requests[sequence_number] = future\n         self._result_sequence_number_to_goal_id[sequence_number] = result_request.goal_id\n         future.add_done_callback(self._remove_pending_result_request)\n@@ -639,7 \u002B571,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         return future\n \n-    def server_is_ready(self) -\u003E bool:\n\u002B    def server_is_ready(self):\n         \u0022\u0022\u0022\n         Check if there is an action server ready to process requests from this client.\n \n@@ -648,7 \u002B580,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         with self._node.handle:\n             return self._client_handle.is_action_server_available()\n \n-    def wait_for_server(self, timeout_sec: Optional[float] = None) -\u003E bool:\n\u002B    def wait_for_server(self, timeout_sec=None):\n         \u0022\u0022\u0022\n         Wait for an action sever to be ready.\n \n@@ -669,7 \u002B601,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n \n         return self.server_is_ready()\n \n-    def destroy(self) -\u003E None:\n\u002B    def destroy(self):\n         \u0022\u0022\u0022Destroy the underlying action client handle.\u0022\u0022\u0022\n         self._client_handle.destroy_when_not_in_use()\n         self._node.remove_waitable(self)\ndiff --git rclpy/rclpy/action/server.py rclpy/rclpy/action/server.py\nindex ce60309..8296df7 100644\n--- rclpy/rclpy/action/server.py\n\u002B\u002B\u002B rclpy/rclpy/action/server.py\n@@ -17,44 \u002B17,18 @@ import functools\n import threading\n import traceback\n \n-from types import TracebackType\n-from typing import (Any, Callable, Dict, Generic, Literal, Optional, Tuple, Type,\n-                    TYPE_CHECKING, TypedDict, TypeVar)\n-\n\u002Bfrom typing import Any, TypedDict\n \n from action_msgs.msg import GoalInfo, GoalStatus\n-from action_msgs.srv._cancel_goal import CancelGoal\n\u002B\n from rclpy.executors import await_or_execute\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import qos_profile_action_status_default\n from rclpy.qos import qos_profile_services_default\n from rclpy.qos import QoSProfile\n from rclpy.task import Future\n-from rclpy.type_support import (Action, check_for_type_support, FeedbackMessage, FeedbackT,\n-                                GetResultServiceRequest, GetResultServiceResponse, GoalT, ResultT,\n-                                SendGoalServiceRequest)\n\u002Bfrom rclpy.type_support import check_for_type_support\n from rclpy.waitable import NumberOfEntities, Waitable\n-from unique_identifier_msgs.msg import UUID\n-\n-\n-if TYPE_CHECKING:\n-    from typing_extensions import TypeAlias\n-\n-    from rclpy.callback_groups import CallbackGroup\n-    from rclpy.node import Node\n-\n-    ServerGoalHandleDictGoalT = TypeVar(\u0027ServerGoalHandleDictGoalT\u0027)\n-\n-    class ServerGoalHandleDict(TypedDict,\n-                               Generic[ServerGoalHandleDictGoalT],\n-                               total=False):\n-        goal: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, SendGoalServiceRequest[ServerGoalHandleDictGoalT]]\n-        cancel: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, CancelGoal.Request]\n-        result: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, GetResultServiceRequest]\n-        expired: Tuple[GoalInfo, ...]\n-else:\n-    ServerGoalHandleDict: \u0027TypeAlias\u0027 = Dict[str, object]\n-\n \n # Re-export exception defined in _rclpy C extension.\n RCLError = _rclpy.RCLError\n@@ -77,15 \u002B51,17 @@ class CancelResponse(Enum):\n GoalEvent = _rclpy.GoalEvent\n \n \n-class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n\u002Bclass ServerGoalHandleDict(TypedDict, total=False):\n\u002B    goal: Any\n\u002B    cancel: Any\n\u002B    result: Any\n\u002B    expired: Any\n\u002B\n\u002B\n\u002Bclass ServerGoalHandle:\n     \u0022\u0022\u0022Goal handle for working with Action Servers.\u0022\u0022\u0022\n \n-    def __init__(\n-        self,\n-        action_server: \u0027ActionServer[GoalT, ResultT, FeedbackT]\u0027,\n-        goal_info: GoalInfo,\n-        goal_request: GoalT\n-    ) -\u003E None:\n\u002B    def __init__(self, action_server, goal_info, goal_request):\n         \u0022\u0022\u0022\n         Accept a new goal with the given action server.\n \n@@ -105,43 \u002B81,39 @@ class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n         self._cancel_requested = False\n         self._lock = threading.Lock()\n \n-    def __eq__(self, other: object) -\u003E bool:\n-        if isinstance(other, ServerGoalHandle):\n-            return self.goal_id == other.goal_id\n-        return False\n\u002B    def __eq__(self, other):\n\u002B        return self.goal_id == other.goal_id\n \n-    def __ne__(self, other: object) -\u003E bool:\n-        if isinstance(other, ServerGoalHandle):\n-            return self.goal_id != other.goal_id\n-        return True\n\u002B    def __ne__(self, other):\n\u002B        return self.goal_id != other.goal_id\n \n     @property\n-    def request(self) -\u003E GoalT:\n\u002B    def request(self):\n         return self._goal_request\n \n     @property\n-    def goal_id(self) -\u003E UUID:\n\u002B    def goal_id(self):\n         return self._goal_info.goal_id\n \n     @property\n-    def is_active(self) -\u003E bool:\n\u002B    def is_active(self):\n         with self._lock:\n             if self._goal_handle is None:\n                 return False\n             return self._goal_handle.is_active()\n \n     @property\n-    def is_cancel_requested(self) -\u003E bool:\n\u002B    def is_cancel_requested(self):\n         return GoalStatus.STATUS_CANCELING == self.status\n \n     @property\n-    def status(self) -\u003E int:\n\u002B    def status(self):\n         with self._lock:\n             if self._goal_handle is None:\n                 return GoalStatus.STATUS_UNKNOWN\n             return self._goal_handle.get_status()\n \n-    def _update_state(self, event: _rclpy.GoalEvent) -\u003E None:\n\u002B    def _update_state(self, event):\n         with self._lock:\n             # Ignore updates for already destructed goal handles\n             if self._goal_handle is None:\n@@ -157,11 \u002B129,7 @@ class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n             if not self._goal_handle.is_active():\n                 self._action_server.notify_goal_done()\n \n-    def execute(\n-        self,\n-        execute_callback: Optional[Callable[[\u0027ServerGoalHandle[GoalT, ResultT, FeedbackT]\u0027],\n-                                   ResultT]] = None\n-    ) -\u003E None:\n\u002B    def execute(self, execute_callback=None):\n         # It\u0027s possible that there has been a request to cancel the goal prior to executing.\n         # In this case we want to avoid the illegal state transition to EXECUTING\n         # but still call the users execute callback to let them handle canceling the goal.\n@@ -169,7 \u002B137,7 @@ class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n             self._update_state(_rclpy.GoalEvent.EXECUTE)\n         self._action_server.notify_execute(self, execute_callback)\n \n-    def publish_feedback(self, feedback: FeedbackMessage[FeedbackT]) -\u003E None:\n\u002B    def publish_feedback(self, feedback):\n         if not isinstance(feedback, self._action_server.action_type.Feedback):\n             raise TypeError()\n \n@@ -187,16 \u002B155,16 @@ class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n             # Publish\n             self._action_server._handle.publish_feedback(feedback_message)\n \n-    def succeed(self) -\u003E None:\n\u002B    def succeed(self):\n         self._update_state(_rclpy.GoalEvent.SUCCEED)\n \n-    def abort(self) -\u003E None:\n\u002B    def abort(self):\n         self._update_state(_rclpy.GoalEvent.ABORT)\n \n-    def canceled(self) -\u003E None:\n\u002B    def canceled(self):\n         self._update_state(_rclpy.GoalEvent.CANCELED)\n \n-    def destroy(self) -\u003E None:\n\u002B    def destroy(self):\n         with self._lock:\n             if self._goal_handle is None:\n                 return\n@@ -204,47 \u002B172,42 @@ class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n             self._goal_handle = None\n \n \n-def default_handle_accepted_callback(goal_handle: ServerGoalHandle[Any, Any, Any]) -\u003E None:\n\u002Bdef default_handle_accepted_callback(goal_handle):\n     \u0022\u0022\u0022Execute the goal.\u0022\u0022\u0022\n     goal_handle.execute()\n \n \n-def default_goal_callback(\n-    goal_request: SendGoalServiceRequest[Any]\n-) -\u003E Literal[GoalResponse.ACCEPT]:\n\u002Bdef default_goal_callback(goal_request):\n     \u0022\u0022\u0022Accept all goals.\u0022\u0022\u0022\n     return GoalResponse.ACCEPT\n \n \n-def default_cancel_callback(cancel_request: CancelGoal.Request) -\u003E Literal[CancelResponse.REJECT]:\n\u002Bdef default_cancel_callback(cancel_request):\n     \u0022\u0022\u0022No cancellations.\u0022\u0022\u0022\n     return CancelResponse.REJECT\n \n \n-class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandleDict[GoalT]\u0027]):\n\u002Bclass ActionServer(Waitable[ServerGoalHandleDict]):\n     \u0022\u0022\u0022ROS Action server.\u0022\u0022\u0022\n \n     def __init__(\n         self,\n-        node: \u0027Node\u0027,\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT],\n\u002B        node,\n\u002B        action_type,\n\u002B        action_name,\n\u002B        execute_callback,\n         *,\n-        callback_group: \u0027Optional[CallbackGroup]\u0027 = None,\n-        goal_callback: Callable[[CancelGoal.Request], GoalResponse] = default_goal_callback,\n-        handle_accepted_callback: Callable[[ServerGoalHandle[GoalT,\n-                                                             ResultT,\n-                                                             FeedbackT]],\n-                                           None] = default_handle_accepted_callback,\n-        cancel_callback: Callable[[CancelGoal.Request], CancelResponse] = default_cancel_callback,\n-        goal_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        result_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        cancel_service_qos_profile: QoSProfile = qos_profile_services_default,\n-        feedback_pub_qos_profile: QoSProfile = QoSProfile(depth=10),\n-        status_pub_qos_profile: QoSProfile = qos_profile_action_status_default,\n-        result_timeout: int = 10\n-    ) -\u003E None:\n\u002B        callback_group=None,\n\u002B        goal_callback=default_goal_callback,\n\u002B        handle_accepted_callback=default_handle_accepted_callback,\n\u002B        cancel_callback=default_cancel_callback,\n\u002B        goal_service_qos_profile=qos_profile_services_default,\n\u002B        result_service_qos_profile=qos_profile_services_default,\n\u002B        cancel_service_qos_profile=qos_profile_services_default,\n\u002B        feedback_pub_qos_profile=QoSProfile(depth=10),\n\u002B        status_pub_qos_profile=qos_profile_action_status_default,\n\u002B        result_timeout=10\n\u002B    ):\n         \u0022\u0022\u0022\n         Create an ActionServer.\n \n@@ -300,20 \u002B263,16 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             )\n \n         # key: UUID in bytes, value: GoalHandle\n-        self._goal_handles: Dict[bytes, ServerGoalHandle[GoalT, ResultT, FeedbackT]] = {}\n\u002B        self._goal_handles = {}\n \n         # key: UUID in bytes, value: Future\n-        self._result_futures: Dict[bytes, Future[GetResultServiceResponse[ResultT]]] = {}\n\u002B        self._result_futures = {}\n \n         callback_group.add_entity(self)\n         self._node.add_waitable(self)\n         self._logger = self._node.get_logger().get_child(\u0027action_server\u0027)\n \n-    async def _execute_goal_request(\n-        self,\n-        request_header_and_message: Tuple[\u0027_rclpy.rmw_request_id_t\u0027,\n-                                          SendGoalServiceRequest[GoalT]]\n-    ) -\u003E None:\n\u002B    async def _execute_goal_request(self, request_header_and_message):\n         request_header, goal_request = request_header_and_message\n         goal_uuid = goal_request.goal_id\n         goal_info = GoalInfo()\n@@ -374,11 \u002B333,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         # Provide the user a reference to the goal handle\n         await await_or_execute(self._handle_accepted_callback, goal_handle)\n \n-    async def _execute_goal(\n-        self,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT],\n-        goal_handle: ServerGoalHandle[GoalT, ResultT, FeedbackT]\n-    ) -\u003E None:\n\u002B    async def _execute_goal(self, execute_callback, goal_handle):\n         goal_uuid = goal_handle.goal_id.uuid\n         self._logger.debug(\u0027Executing goal with ID {0}\u0027.format(goal_uuid))\n \n@@ -406,10 \u002B361,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         result_response.result = execute_result\n         self._result_futures[bytes(goal_uuid)].set_result(result_response)\n \n-    async def _execute_cancel_request(\n-        self,\n-        request_header_and_message: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, CancelGoal.Request]\n-    ) -\u003E None:\n\u002B    async def _execute_cancel_request(self, request_header_and_message):\n         request_header, cancel_request = request_header_and_message\n \n         self._logger.debug(\u0027Cancel request received: {0}\u0027.format(cancel_request))\n@@ -451,10 \u002B403,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         except RCLError:\n             self._logger.warn(\u0027Failed to send cancel response (the client may have gone away)\u0027)\n \n-    async def _execute_get_result_request(\n-        self,\n-        request_header_and_message: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, GetResultServiceRequest]\n-    ) -\u003E None:\n\u002B    async def _execute_get_result_request(self, request_header_and_message):\n         request_header, result_request = request_header_and_message\n         goal_uuid = result_request.goal_id.uuid\n \n@@ -475,7 \u002B424,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         self._result_futures[bytes(goal_uuid)].add_done_callback(\n             functools.partial(self._send_result_response, request_header))\n \n-    async def _execute_expire_goals(self, expired_goals: Tuple[GoalInfo, ...]) -\u003E None:\n\u002B    async def _execute_expire_goals(self, expired_goals):\n         for goal in expired_goals:\n             goal_uuid = bytes(goal.goal_id.uuid)\n             self._goal_handles[goal_uuid].destroy()\n@@ -483,11 \u002B432,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             self.remove_future(self._result_futures[goal_uuid])\n             del self._result_futures[goal_uuid]\n \n-    def _send_result_response(\n-        self,\n-        request_header: \u0027_rclpy.rmw_request_id_t\u0027,\n-        future: Future[GetResultServiceResponse[ResultT]]\n-    ) -\u003E None:\n\u002B    def _send_result_response(self, request_header, future):\n         try:\n             # If the client goes away anytime before this, sending the result response may fail.\n             # Catch the exception here and go on so we don\u0027t crash.\n@@ -496,11 \u002B441,11 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             self._logger.warn(\u0027Failed to send result response (the client may have gone away)\u0027)\n \n     @property\n-    def action_type(self) -\u003E Type[Action[GoalT, ResultT, FeedbackT]]:\n\u002B    def action_type(self):\n         return self._action_type\n \n     # Start Waitable API\n-    def is_ready(self, wait_set: _rclpy.WaitSet) -\u003E bool:\n\u002B    def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if one or more entities are ready in the wait set.\u0022\u0022\u0022\n         with self._lock:\n             ready_entities = self._handle.is_ready(wait_set)\n@@ -510,9 \u002B455,9 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         self._is_goal_expired = ready_entities[3]\n         return any(ready_entities)\n \n-    def take_data(self) -\u003E \u0027ServerGoalHandleDict[GoalT]\u0027:\n\u002B    def take_data(self) -\u003E ServerGoalHandleDict:\n         \u0022\u0022\u0022Take stuff from lower level so the wait set doesn\u0027t immediately wake again.\u0022\u0022\u0022\n-        data: \u0027ServerGoalHandleDict[GoalT]\u0027 = {}\n\u002B        data: ServerGoalHandleDict = {}\n         if self._is_goal_request_ready:\n             with self._lock:\n                 taken_data = self._handle.take_goal_request(\n@@ -546,7 \u002B491,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n \n         return data\n \n-    async def execute(self, taken_data: \u0027ServerGoalHandleDict[GoalT]\u0027) -\u003E None:\n\u002B    async def execute(self, taken_data: ServerGoalHandleDict) -\u003E None:\n         \u0022\u0022\u0022\n         Execute work after data has been taken from a ready wait set.\n \n@@ -565,7 \u002B510,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         if \u0027expired\u0027 in taken_data:\n             await self._execute_expire_goals(taken_data[\u0027expired\u0027])\n \n-    def get_num_entities(self) -\u003E NumberOfEntities:\n\u002B    def get_num_entities(self):\n         \u0022\u0022\u0022Return number of each type of entity used in the wait set.\u0022\u0022\u0022\n         num_entities = self._handle.get_num_entities()\n         return NumberOfEntities(\n@@ -575,26 \u002B520,20 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             num_entities[3],\n             num_entities[4])\n \n-    def add_to_wait_set(self, wait_set: _rclpy.WaitSet) -\u003E None:\n\u002B    def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n         with self._lock:\n             self._handle.add_to_waitset(wait_set)\n \n-    def __enter__(self) -\u003E None:\n-        self._handle.__enter__()\n\u002B    def __enter__(self):\n\u002B        return self._handle.__enter__()\n \n-    def __exit__(self, t: Optional[Type[BaseException]],\n-                 v: Optional[BaseException], tb: Optional[TracebackType]) -\u003E None:\n\u002B    def __exit__(self, t, v, tb):\n         self._handle.__exit__(t, v, tb)\n \n     # End Waitable API\n \n-    def notify_execute(\n-        self,\n-        goal_handle: ServerGoalHandle[GoalT, ResultT, FeedbackT],\n-        execute_callback: Optional[Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]],\n-                                            ResultT]]\n-    ) -\u003E None:\n\u002B    def notify_execute(self, goal_handle, execute_callback):\n         # Use provided callback, defaulting to a previously registered callback\n         if execute_callback is None:\n             if self._execute_callback is None:\n@@ -602,18 \u002B541,13 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             execute_callback = self._execute_callback\n \n         # Schedule user callback for execution\n-        if self._node.executor:\n-            self._node.executor.create_task(self._execute_goal, execute_callback, goal_handle)\n\u002B        self._node.executor.create_task(self._execute_goal, execute_callback, goal_handle)\n \n-    def notify_goal_done(self) -\u003E None:\n\u002B    def notify_goal_done(self):\n         with self._lock:\n             self._handle.notify_goal_done()\n \n-    def register_handle_accepted_callback(\n-        self,\n-        handle_accepted_callback: Optional[Callable[[\n-            ServerGoalHandle[GoalT, ResultT, FeedbackT]], None]]\n-    ) -\u003E None:\n\u002B    def register_handle_accepted_callback(self, handle_accepted_callback):\n         \u0022\u0022\u0022\n         Register a callback for handling newly accepted goals.\n \n@@ -634,10 \u002B568,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             handle_accepted_callback = default_handle_accepted_callback\n         self._handle_accepted_callback = handle_accepted_callback\n \n-    def register_goal_callback(\n-        self,\n-        goal_callback: Optional[Callable[[SendGoalServiceRequest[GoalT]], GoalResponse]]\n-    ) -\u003E None:\n\u002B    def register_goal_callback(self, goal_callback):\n         \u0022\u0022\u0022\n         Register a callback for handling new goal requests.\n \n@@ -656,10 \u002B587,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             goal_callback = default_goal_callback\n         self._goal_callback = goal_callback\n \n-    def register_cancel_callback(\n-        self,\n-        cancel_callback: Optional[Callable[[CancelGoal.Request], CancelResponse]]\n-    ) -\u003E None:\n\u002B    def register_cancel_callback(self, cancel_callback):\n         \u0022\u0022\u0022\n         Register a callback for handling cancel requests.\n \n@@ -678,10 \u002B606,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             cancel_callback = default_cancel_callback\n         self._cancel_callback = cancel_callback\n \n-    def register_execute_callback(\n-        self,\n-        execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT]\n-    ) -\u003E None:\n\u002B    def register_execute_callback(self, execute_callback):\n         \u0022\u0022\u0022\n         Register a callback for executing action goals.\n \n@@ -700,7 \u002B625,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             raise TypeError(\u0027Failed to register goal execution callback: not callable\u0027)\n         self._execute_callback = execute_callback\n \n-    def destroy(self) -\u003E None:\n\u002B    def destroy(self):\n         \u0022\u0022\u0022Destroy the underlying action server handle.\u0022\u0022\u0022\n         for goal_handle in self._goal_handles.values():\n             goal_handle.destroy()\ndiff --git rclpy/rclpy/client.py rclpy/rclpy/client.py\nindex 60c38f7..cba396a 100644\n--- rclpy/rclpy/client.py\n\u002B\u002B\u002B rclpy/rclpy/client.py\n@@ -28,7 \u002B28,7 @@ from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n from rclpy.service_introspection import ServiceIntrospectionState\n from rclpy.task import Future\n-from rclpy.type_support import Srv, SrvRequestT, SrvResponseT\n\u002Bfrom rclpy.type_support import Srv, SrvEventT, SrvRequestT, SrvResponseT\n \n # Left To Support Legacy TypeVars\n SrvType = TypeVar(\u0027SrvType\u0027)\n@@ -36,12 \u002B36,12 @@ SrvTypeRequest = TypeVar(\u0027SrvTypeRequest\u0027)\n SrvTypeResponse = TypeVar(\u0027SrvTypeResponse\u0027)\n \n \n-class Client(Generic[SrvRequestT, SrvResponseT]):\n\u002Bclass Client(Generic[SrvRequestT, SrvResponseT, SrvEventT]):\n     def __init__(\n         self,\n         context: Context,\n         client_impl: _rclpy.Client,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],\n         srv_name: str,\n         qos_profile: QoSProfile,\n         callback_group: CallbackGroup\n@@ -231,7 \u002B231,7 @@ class Client(Generic[SrvRequestT, SrvResponseT]):\n         \u0022\u0022\u0022\n         self.__client.destroy_when_not_in_use()\n \n-    def __enter__(self) -\u003E \u0027Client[SrvRequestT, SrvResponseT]\u0027:\n\u002B    def __enter__(self) -\u003E \u0027Client[SrvRequestT, SrvResponseT, SrvEventT]\u0027:\n         return self\n \n     def __exit__(\ndiff --git rclpy/rclpy/impl/_rclpy_pybind11.pyi rclpy/rclpy/impl/_rclpy_pybind11.pyi\nindex 6128316..679f6fa 100644\n--- rclpy/rclpy/impl/_rclpy_pybind11.pyi\n\u002B\u002B\u002B rclpy/rclpy/impl/_rclpy_pybind11.pyi\n@@ -18,17 \u002B18,12 @@ from enum import Enum, IntEnum\n from types import TracebackType\n from typing import Any, Generic, Literal, overload, Sequence, TypedDict\n \n-\n-from action_msgs.msg import GoalInfo\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal\n from rclpy.clock import JumpHandle\n from rclpy.clock_type import ClockType\n from rclpy.duration import Duration\n from rclpy.parameter import Parameter\n from rclpy.subscription import MessageInfo\n-from type_support import (MsgT, Action, GoalT, ResultT, FeedbackT, SendGoalServiceResponse,\n-                          GetResultServiceResponse, FeedbackMessage, SendGoalServiceRequest, GetResultServiceRequest)\n\u002Bfrom rclpy.type_support import MsgT\n \n \n def rclpy_remove_ros_args(pycli_args: Sequence[str]) -\u003E list[str]:\n@@ -448,191 \u002B443,6 @@ class WaitSet(Destroyable):\n         \u0022\u0022\u0022Wait until timeout is reached or event happened.\u0022\u0022\u0022\n \n \n-class ActionClient(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n-\n-    def __init__(\n-            self,\n-            node: Node,\n-            pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n-            goal_service_qos: rmw_qos_profile_t,\n-            result_service_qos: rmw_qos_profile_t,\n-            cancel_service_qos: rmw_qos_profile_t,\n-            feedback_service_qos: rmw_qos_profile_t,\n-            status_topci_qos: rmw_qos_profile_t\n-        ) -\u003E None: ...\n-\n-    @property\n-    def pointer(self) -\u003E int:\n-        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n-\n-    def take_goal_response(self, pymsg_type: type[SendGoalServiceResponse]\n-                           ) -\u003E tuple[int, SendGoalServiceResponse] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action goal response.\u0022\u0022\u0022\n-\n-    def send_result_request(self, pyrequest: GetResultServiceRequest) -\u003E int:\n-        \u0022\u0022\u0022Send an action result requst.\u0022\u0022\u0022\n-\n-    def take_cancel_response(self, pymsg_type: type[CancelGoal.Response]\n-                             ) -\u003E tuple[int, CancelGoal.Response] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action cancel response.\u0022\u0022\u0022\n-    \n-    def take_feedback(self, pymsg_type: type[FeedbackMessage[FeedbackT]]\n-                      ) -\u003E FeedbackMessage[FeedbackT] | None:\n-        \u0022\u0022\u0022Take a feedback message from a given action client.\u0022\u0022\u0022\n-\n-    def send_cancel_request(self: CancelGoal.Request) -\u003E int:\n-        \u0022\u0022\u0022Send an action cancel request.\u0022\u0022\u0022\n-\n-    def send_goal_request(self: SendGoalServiceRequest[GoalT]) -\u003E int:\n-        \u0022\u0022\u0022Send an action goal request.\u0022\u0022\u0022\n-    \n-    def take_result_response(self, pymsg_type: type[GetResultServiceResponse[ResultT]]\n-                             ) -\u003E tuple[int, GetResultServiceResponse[ResultT]] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action result response.\u0022\u0022\u0022\n-\n-    def get_num_entities(self) -\u003E tuple[int, int, int, int, int]:\n-        \u0022\u0022\u0022Get the number of wait set entities that make up an action entity.\u0022\u0022\u0022\n-\n-    def is_action_server_available(self) -\u003E bool:\n-        \u0022\u0022\u0022Check if an action server is available for the given action client.\u0022\u0022\u0022   \n-\n-    def add_to_waitset(self, waitset: WaitSet) -\u003E None:\n-        \u0022\u0022\u0022Add an action entity to a wait set.\u0022\u0022\u0022\n-\n-    def is_ready(self) -\u003E bool:\n-        \u0022\u0022\u0022Check if an action entity has any ready wait set entities.\u0022\u0022\u0022\n-\n-    def take_status(self, pymsg_type: type[GoalStatusArray]) -\u003E GoalStatusArray | None:\n-        \u0022\u0022\u0022Take an action status response.\u0022\u0022\u0022\n-\n-\n-class GoalEvent(Enum):\n-    _value_: int\n-    EXECUTE = ...\n-    CANCEL_GOAL = ...\n-    SUCCEED = ...\n-    ABORT = ...\n-    CANCELED = ...\n-\n-\n-class rmw_request_id_t:\n-    writer_guid: list[int]\n-    sequence_number: int\n-\n-\n-class ActionServer(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n-\n-    def __init__(\n-        self,\n-        node: Node,\n-        rclpy_clock: Clock,\n-        pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n-        action_name: str,\n-        goal_service_qos: rmw_qos_profile_t,\n-        result_service_qos: rmw_qos_profile_t,\n-        cancel_service_qos: rmw_qos_profile_t,\n-        feedback_topic_qos: rmw_qos_profile_t,\n-        status_topic_qos: rmw_qos_profile_t,\n-        result_timeout: float\n-    ) -\u003E None: ...\n-\n-    @property\n-    def pointer(self) -\u003E int:\n-        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n-\n-    def take_goal_request(\n-        self,\n-        pymsg_type: type[SendGoalServiceRequest[GoalT]]\n-    ) -\u003E tuple[rmw_request_id_t, SendGoalServiceRequest[GoalT]] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action goal request.\u0022\u0022\u0022\n-\n-    def send_goal_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: SendGoalServiceResponse\n-    ) -\u003E None:\n-        \u0022\u0022\u0022Send an action goal response.\u0022\u0022\u0022\n-\n-    def send_result_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: GetResultServiceResponse[ResultT]\n-    ) -\u003E None:\n-        \u0022\u0022\u0022Send an action result response.\u0022\u0022\u0022\n-\n-    def take_cancel_request(\n-        self,\n-        pymsg_type: type[CancelGoal.Request]\n-    ) -\u003E tuple[rmw_request_id_t, CancelGoal.Request] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action cancel request.\u0022\u0022\u0022\n-\n-    def take_result_request(\n-        self,\n-        pymsg_type: type[GetResultServiceRequest]\n-    ) -\u003E tuple[rmw_request_id_t, GetResultServiceRequest] | tuple[None, None]:\n-        \u0022\u0022\u0022Take an action result request.\u0022\u0022\u0022\n-\n-    def send_cancel_response(\n-        self,\n-        header: rmw_request_id_t,\n-        pyresponse: int\n-    ) -\u003E None:\n-        \u0022\u0022\u0022Send an action cancel response.\u0022\u0022\u0022\n-\n-    def publish_feedback(\n-        self,\n-        pymsg: FeedbackMessage[FeedbackT]\n-    ) -\u003E None:\n-        \u0022\u0022\u0022Publish a feedback message from a given action server.\u0022\u0022\u0022\n-    \n-    def publish_status(self) -\u003E None:\n-        \u0022\u0022\u0022Publish a status message from a given action server.\u0022\u0022\u0022\n-\n-    def notify_goal_done(self) -\u003E None:\n-        \u0022\u0022\u0022Notify goal is done.\u0022\u0022\u0022\n-\n-    def goal_exists(self, pygoal_info: GoalInfo) -\u003E bool:\n-        \u0022\u0022\u0022Check is a goal exists in the server.\u0022\u0022\u0022\n-\n-    def process_cancel_request(\n-        self,\n-        pycancel_request: CancelGoal.Request,\n-        pycancel_response_tpye: type[CancelGoal.Response]\n-    ) -\u003E CancelGoal.Response:\n-        \u0022\u0022\u0022Process a cancel request\u0022\u0022\u0022\n-\n-    def expire_goals(self, max_num_goals: int) -\u003E tuple[GoalInfo, ...]:\n-        \u0022\u0022\u0022Expired goals.\u0022\u0022\u0022\n-\n-    def get_num_entities(self) -\u003E tuple[int, int, int, int, int]:\n-        \u0022\u0022\u0022Get the number of wait set entities that make up an action entity.\u0022\u0022\u0022\n-\n-    def is_ready(self, wait_set: WaitSet) -\u003E tuple[bool, bool, bool, bool]:\n-        \u0022\u0022\u0022Check if an action entity has any ready wait set entities.\u0022\u0022\u0022\n-\n-    def add_to_waitset(self, wait_set: WaitSet) -\u003E None:\n-        \u0022\u0022\u0022Add an action entity to a wait set.\u0022\u0022\u0022\n-\n-\n-class ActionGoalHandle:\n-\n-    def __init__(self, action_server: ActionServer, pygoal_info_msg: GoalInfo) -\u003E None:\n-        ...\n-\n-    @property\n-    def pointer(self) -\u003E int:\n-        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n-\n-    def get_status(self) -\u003E GoalEvent:\n-        \u0022\u0022\u0022Get the status of a goal.\u0022\u0022\u0022\n-\n-    def update_goal_state(self, event: GoalEvent) -\u003E None:\n-        \u0022\u0022\u0022Update a goal state.\u0022\u0022\u0022\n-\n-    def is_active(self) -\u003E bool:\n-        \u0022\u0022\u0022Check if a goal is active.\u0022\u0022\u0022\n-\n-\n class RCLError(RuntimeError):\n     pass\n \n@@ -644,7 \u002B454,7 @@ class NodeNameNonExistentError(RCLError):\n class InvalidHandle(RuntimeError):\n     pass\n \n-\n\u002B  \n class SignalHandlerOptions(Enum):\n     _value_: int\n     NO = ...\ndiff --git rclpy/rclpy/impl/implementation_singleton.pyi rclpy/rclpy/impl/implementation_singleton.pyi\nindex 521e06e..a1e16bd 100644\n--- rclpy/rclpy/impl/implementation_singleton.pyi\n\u002B\u002B\u002B rclpy/rclpy/impl/implementation_singleton.pyi\n@@ -13,6 \u002B13,6 @@\n # limitations under the License.\n \n \n-from impl import _rclpy_pybind11\n\u002Bfrom rclpy.impl import _rclpy_pybind11\n \n rclpy_implementation = _rclpy_pybind11\ndiff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex 2e7bbd2..8da2faa 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -89,6 \u002B89,7 @@ from rclpy.type_support import check_is_valid_msg_type\n from rclpy.type_support import check_is_valid_srv_type\n from rclpy.type_support import MsgT\n from rclpy.type_support import Srv\n\u002Bfrom rclpy.type_support import SrvEventT\n from rclpy.type_support import SrvRequestT\n from rclpy.type_support import SrvResponseT\n from rclpy.utilities import get_default_context\n@@ -172,8 \u002B173,8 @@ class Node:\n         self._parameters: Dict[str, Parameter[Any]] = {}\n         self._publishers: List[Publisher[Any]] = []\n         self._subscriptions: List[Subscription[Any]] = []\n-        self._clients: List[Client[Any, Any]] = []\n-        self._services: List[Service[Any, Any]] = []\n\u002B        self._clients: List[Client[Any, Any, Any]] = []\n\u002B        self._services: List[Service[Any, Any, Any]] = []\n         self._timers: List[Timer] = []\n         self._guards: List[GuardCondition] = []\n         self.__waitables: List[Waitable[Any]] = []\n@@ -269,12 \u002B270,12 @@ class Node:\n         yield from self._subscriptions\n \n     @property\n-    def clients(self) -\u003E Iterator[Client[Any, Any]]:\n\u002B    def clients(self) -\u003E Iterator[Client[Any, Any, Any]]:\n         \u0022\u0022\u0022Get clients that have been created on this node.\u0022\u0022\u0022\n         yield from self._clients\n \n     @property\n-    def services(self) -\u003E Iterator[Service[Any, Any]]:\n\u002B    def services(self) -\u003E Iterator[Service[Any, Any, Any]]:\n         \u0022\u0022\u0022Get services that have been created on this node.\u0022\u0022\u0022\n         yield from self._services\n \n@@ -1689,12 \u002B1690,12 @@ class Node:\n \n     def create_client(\n         self,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],\n         srv_name: str,\n         *,\n         qos_profile: QoSProfile = qos_profile_services_default,\n         callback_group: Optional[CallbackGroup] = None\n-    ) -\u003E Client[SrvRequestT, SrvResponseT]:\n\u002B    ) -\u003E Client[SrvRequestT, SrvResponseT, SrvEventT]:\n         \u0022\u0022\u0022\n         Create a new service client.\n \n@@ -1731,13 \u002B1732,13 @@ class Node:\n \n     def create_service(\n         self,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],\n         srv_name: str,\n         callback: Callable[[SrvRequestT, SrvResponseT], SrvResponseT],\n         *,\n         qos_profile: QoSProfile = qos_profile_services_default,\n         callback_group: Optional[CallbackGroup] = None\n-    ) -\u003E Service[SrvRequestT, SrvResponseT]:\n\u002B    ) -\u003E Service[SrvRequestT, SrvResponseT, SrvEventT]:\n         \u0022\u0022\u0022\n         Create a new service server.\n \n@@ -1891,7 \u002B1892,7 @@ class Node:\n             return True\n         return False\n \n-    def destroy_client(self, client: Client[Any, Any]) -\u003E bool:\n\u002B    def destroy_client(self, client: Client[Any, Any, Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a service client created by the node.\n \n@@ -1907,7 \u002B1908,7 @@ class Node:\n             return True\n         return False\n \n-    def destroy_service(self, service: Service[Any, Any]) -\u003E bool:\n\u002B    def destroy_service(self, service: Service[Any, Any, Any]) -\u003E bool:\n         \u0022\u0022\u0022\n         Destroy a service server created by the node.\n \ndiff --git rclpy/rclpy/service.py rclpy/rclpy/service.py\nindex de1c7d1..bc13940 100644\n--- rclpy/rclpy/service.py\n\u002B\u002B\u002B rclpy/rclpy/service.py\n@@ -24,7 \u002B24,7 @@ from rclpy.clock import Clock\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n from rclpy.service_introspection import ServiceIntrospectionState\n-from rclpy.type_support import Srv, SrvRequestT, SrvResponseT\n\u002Bfrom rclpy.type_support import Srv, SrvEventT, SrvRequestT, SrvResponseT\n \n # Used for documentation purposes only\n SrvType = TypeVar(\u0027SrvType\u0027)\n@@ -32,11 \u002B32,11 @@ SrvTypeRequest = TypeVar(\u0027SrvTypeRequest\u0027)\n SrvTypeResponse = TypeVar(\u0027SrvTypeResponse\u0027)\n \n \n-class Service(Generic[SrvRequestT, SrvResponseT]):\n\u002Bclass Service(Generic[SrvRequestT, SrvResponseT, SrvEventT]):\n     def __init__(\n         self,\n         service_impl: _rclpy.Service,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv[SrvRequestT, SrvResponseT, SrvEventT]],\n         srv_name: str,\n         callback: Callable[[SrvRequestT, SrvResponseT], SrvResponseT],\n         callback_group: CallbackGroup,\n@@ -121,7 \u002B121,7 @@ class Service(Generic[SrvRequestT, SrvResponseT]):\n         \u0022\u0022\u0022\n         self.__service.destroy_when_not_in_use()\n \n-    def __enter__(self) -\u003E \u0027Service[SrvRequestT, SrvResponseT]\u0027:\n\u002B    def __enter__(self) -\u003E \u0027Service[SrvRequestT, SrvResponseT, SrvEventT]\u0027:\n         return self\n \n     def __exit__(\ndiff --git rclpy/rclpy/type_support.py rclpy/rclpy/type_support.py\nindex cbdde9e..33ef95d 100644\n--- rclpy/rclpy/type_support.py\n\u002B\u002B\u002B rclpy/rclpy/type_support.py\n@@ -12,19 \u002B12,9 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Any, ClassVar, Iterable, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union\n\u002Bfrom typing import NoReturn, Optional, Protocol, Type, TypeVar, Union\n \n-\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal\n-from builtin_interfaces.msg import Time\n from rclpy.exceptions import NoTypeSupportImportedException\n-from service_msgs.msg._service_event_info import ServiceEventInfo\n-from unique_identifier_msgs.msg import UUID\n-\n-\n-if TYPE_CHECKING:\n-    from typing_extensions import TypeAlias\n \n \n class PyCapsule(Protocol):\n@@ -40,7 \u002B30,7 @@ ProtocolType: Type = type(Protocol)\n class CommonMsgSrvMetaClass(ProtocolType):\n     \u0022\u0022\u0022Shared attributes between messages and services.\u0022\u0022\u0022\n \n-    _TYPE_SUPPORT: ClassVar[Optional[PyCapsule]]\n\u002B    _TYPE_SUPPORT: Optional[PyCapsule]\n \n     @classmethod\n     def __import_type_support__(cls) -\u003E None:\n@@ -50,10 \u002B40,10 @@ class CommonMsgSrvMetaClass(ProtocolType):\n class MsgMetaClass(CommonMsgSrvMetaClass):\n     \u0022\u0022\u0022Generic Message Metaclass Alias.\u0022\u0022\u0022\n \n-    _CREATE_ROS_MESSAGE:  ClassVar[Optional[PyCapsule]]\n-    _CONVERT_FROM_PY:  ClassVar[Optional[PyCapsule]]\n-    _CONVERT_TO_PY:  ClassVar[Optional[PyCapsule]]\n-    _DESTROY_ROS_MESSAGE:  ClassVar[Optional[PyCapsule]]\n\u002B    _CREATE_ROS_MESSAGE:  Optional[PyCapsule]\n\u002B    _CONVERT_FROM_PY:  Optional[PyCapsule]\n\u002B    _CONVERT_TO_PY:  Optional[PyCapsule]\n\u002B    _DESTROY_ROS_MESSAGE:  Optional[PyCapsule]\n \n \n class Msg(Protocol, metaclass=MsgMetaClass):\n@@ -66,84 \u002B56,24 @@ MsgT = TypeVar(\u0027MsgT\u0027, bound=Msg, contravariant=True)\n \n SrvRequestT = TypeVar(\u0027SrvRequestT\u0027, bound=Msg)\n SrvResponseT = TypeVar(\u0027SrvResponseT\u0027, bound=Msg)\n\u002BSrvEventT = TypeVar(\u0027SrvEventT\u0027, bound=Msg)\n \n \n-class EventMessage(Msg, Protocol[SrvRequestT, SrvResponseT]):\n-    info: ServiceEventInfo\n-    request: Iterable[SrvRequestT]\n-    response: Iterable[SrvResponseT]\n-\n-\n-class Srv(Protocol[SrvRequestT, SrvResponseT], metaclass=CommonMsgSrvMetaClass):\n\u002Bclass Srv(Protocol[SrvRequestT, SrvResponseT, SrvEventT], metaclass=CommonMsgSrvMetaClass):\n     \u0022\u0022\u0022Generic Service Type Alias.\u0022\u0022\u0022\n \n     Request: Type[SrvRequestT]\n     Response: Type[SrvResponseT]\n-    Event: Type[EventMessage[SrvRequestT, SrvResponseT]]\n-\n-\n-GoalT = TypeVar(\u0027GoalT\u0027, bound=Msg)\n-ResultT = TypeVar(\u0027ResultT\u0027, bound=Msg)\n-FeedbackT = TypeVar(\u0027FeedbackT\u0027, bound=Msg)\n-\n-\n-class SendGoalServiceRequest(Msg, Protocol[GoalT]):\n-    goal_id: UUID\n-    goal: GoalT\n-\n-\n-class SendGoalServiceResponse(Msg, Protocol):\n-    accepted: bool\n-    stamp: Time\n-\n-\n-SendGoalService: \u0027TypeAlias\u0027 = Srv[SendGoalServiceRequest[GoalT], SendGoalServiceResponse]\n-\n-\n-class GetResultServiceRequest(Msg, Protocol):\n-    goal_id: UUID\n-\n-\n-class GetResultServiceResponse(Msg, Protocol[ResultT]):\n-    status: int\n-    result: ResultT\n-\n-\n-GetResultService: \u0027TypeAlias\u0027 = Srv[GetResultServiceRequest, GetResultServiceResponse[ResultT]]\n-\n-\n-class FeedbackMessage(Msg, Protocol[FeedbackT]):\n-    goal_id: UUID\n-    feedback: FeedbackT\n-\n-\n-class Impl(Protocol[GoalT, ResultT, FeedbackT]):\n-\n-    SendGoalService: Type[SendGoalService[GoalT]]\n-    GetResultService: Type[GetResultService[ResultT]]\n-    FeedbackMessage: Type[FeedbackMessage[FeedbackT]]\n-    CancelGoalService: ClassVar[Type[CancelGoal]]\n-    GoalStatusMessage: ClassVar[Type[GoalStatusArray]]\n-\n-\n-class Action(Protocol[GoalT,\n-                      ResultT,\n-                      FeedbackT],\n-             metaclass=CommonMsgSrvMetaClass):\n-    Goal: Type[GoalT]\n-    Result: Type[ResultT]\n-    Feedback: Type[FeedbackT]\n\u002B    Event: Type[SrvEventT]\n \n-    Impl: Type[Impl[GoalT, ResultT, FeedbackT]]\n\u002B    def __init__(self) -\u003E NoReturn: ...\n \n \n # Can be used if https://github.com/python/typing/issues/548 ever gets approved.\n-SrvT = TypeVar(\u0027SrvT\u0027, bound=Srv)\n-ActionT = TypeVar(\u0027ActionT\u0027, bound=Action)\n\u002BSrvT = TypeVar(\u0027SrvT\u0027, bound=Type[Srv])\n \n \n-def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv[Any, Any],\n-                                                       Action[Any, Any, Any]]]) -\u003E None:\n\u002Bdef check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv]]) -\u003E None:\n     try:\n         ts = msg_or_srv_type._TYPE_SUPPORT\n     except AttributeError as e:\n@@ -175,7 \u002B105,7 @@ def check_is_valid_msg_type(msg_type: Type[Msg]) -\u003E None:\n         ) from None\n \n \n-def check_is_valid_srv_type(srv_type: Type[Srv[Any, Any]]) -\u003E None:\n\u002Bdef check_is_valid_srv_type(srv_type: Type[Srv]) -\u003E None:\n     check_for_type_support(srv_type)\n     try:\n         assert None not in (\ndiff --git rclpy/rclpy/waitable.py rclpy/rclpy/waitable.py\nindex ae1e905..56b363d 100644\n--- rclpy/rclpy/waitable.py\n\u002B\u002B\u002B rclpy/rclpy/waitable.py\n@@ -22,6 \u002B22,8 @@ T = TypeVar(\u0027T\u0027)\n \n \n if TYPE_CHECKING:\n\u002B    from typing_extensions import Self\n\u002B\n     from rclpy.callback_groups import CallbackGroup\n     from rclpy.task import Future\n \n@@ -89,7 \u002B91,7 @@ class Waitable(Generic[T]):\n         # List of Futures that have callbacks needing execution\n         self._futures: List[Future[Any]] = []\n \n-    def __enter__(self) -\u003E None:\n\u002B    def __enter__(self) -\u003E \u0027Self\u0027:\n         \u0022\u0022\u0022Implement to mark entities as in-use to prevent destruction while waiting on them.\u0022\u0022\u0022\n         raise NotImplementedError(\u0027Must be implemented by subclass\u0027)\n \ndiff --git rclpy/src/rclpy/action_server.cpp rclpy/src/rclpy/action_server.cpp\nindex 9256bcc..a899211 100644\n--- rclpy/src/rclpy/action_server.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.cpp\n@@ -400,7 \u002B400,7 @@ define_action_server(py::object module)\n     \u0022Send an action cancel response.\u0022)\n   .def(\n     \u0022publish_feedback\u0022, \u0026ActionServer::publish_feedback,\n-    \u0022Publish a feedback message from a given action server.\u0022)\n\u002B    \u0022 Publish a feedback message from a given action server.\u0022)\n   .def(\n     \u0022publish_status\u0022, \u0026ActionServer::publish_status,\n     \u0022Publish a status message from a given action server.\u0022)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "df3cfa7e4f41c854c3a9dc5a0b17198042fcc4f8",
    "RawMessage": "Fix clock thread issue (#1266) (#1267)",
    "Changes": "diff --git rclcpp/include/rclcpp/time_source.hpp rclcpp/include/rclcpp/time_source.hpp\nindex 74bf38e8..0a4fc427 100644\n--- rclcpp/include/rclcpp/time_source.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/time_source.hpp\n@@ -148,8 \u002B148,6 @@ private:\n   void disable_ros_time();\n \n   // Internal helper functions used inside iterators\n-  static void enable_ros_time(rclcpp::Clock::SharedPtr clock);\n-  static void disable_ros_time(rclcpp::Clock::SharedPtr clock);\n   static void set_clock(\n     const builtin_interfaces::msg::Time::SharedPtr msg,\n     bool set_ros_time_enabled,\ndiff --git rclcpp/src/rclcpp/time_source.cpp rclcpp/src/rclcpp/time_source.cpp\nindex fd1da9c9..8cbf6bbf 100644\n--- rclcpp/src/rclcpp/time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time_source.cpp\n@@ -185,11 \u002B185,21 @@ void TimeSource::set_clock(\n   const builtin_interfaces::msg::Time::SharedPtr msg, bool set_ros_time_enabled,\n   std::shared_ptr\u003Crclcpp::Clock\u003E clock)\n {\n\u002B  std::lock_guard\u003Cstd::mutex\u003E clock_guard(clock-\u003Eget_clock_mutex());\n\u002B\n   // Do change\n   if (!set_ros_time_enabled \u0026\u0026 clock-\u003Eros_time_is_active()) {\n-    disable_ros_time(clock);\n\u002B    auto ret = rcl_disable_ros_time_override(clock-\u003Eget_clock_handle());\n\u002B    if (ret != RCL_RET_OK) {\n\u002B      rclcpp::exceptions::throw_from_rcl_error(\n\u002B        ret, \u0022Failed to disable ros_time_override_status\u0022);\n\u002B    }\n   } else if (set_ros_time_enabled \u0026\u0026 !clock-\u003Eros_time_is_active()) {\n-    enable_ros_time(clock);\n\u002B    auto ret = rcl_enable_ros_time_override(clock-\u003Eget_clock_handle());\n\u002B    if (ret != RCL_RET_OK) {\n\u002B      rclcpp::exceptions::throw_from_rcl_error(\n\u002B        ret, \u0022Failed to enable ros_time_override_status\u0022);\n\u002B    }\n   }\n \n   auto ret = rcl_set_ros_time_override(clock-\u003Eget_clock_handle(), rclcpp::Time(*msg).nanoseconds());\n@@ -273,24 \u002B283,6 @@ void TimeSource::on_parameter_event(const rcl_interfaces::msg::ParameterEvent::S\n   }\n }\n \n-void TimeSource::enable_ros_time(std::shared_ptr\u003Crclcpp::Clock\u003E clock)\n-{\n-  auto ret = rcl_enable_ros_time_override(clock-\u003Eget_clock_handle());\n-  if (ret != RCL_RET_OK) {\n-    rclcpp::exceptions::throw_from_rcl_error(\n-      ret, \u0022Failed to enable ros_time_override_status\u0022);\n-  }\n-}\n-\n-void TimeSource::disable_ros_time(std::shared_ptr\u003Crclcpp::Clock\u003E clock)\n-{\n-  auto ret = rcl_disable_ros_time_override(clock-\u003Eget_clock_handle());\n-  if (ret != RCL_RET_OK) {\n-    rclcpp::exceptions::throw_from_rcl_error(\n-      ret, \u0022Failed to enable ros_time_override_status\u0022);\n-  }\n-}\n-\n void TimeSource::enable_ros_time()\n {\n   if (ros_time_active_) {\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "0c9f233067c06f94131c38c73b117a4e1c3cf00c",
    "RawMessage": "Add support for topic QOS for ros2topic bw, delay and hz (#935)",
    "Changes": "diff --git ros2topic/ros2topic/api/__init__.py ros2topic/ros2topic/api/__init__.py\nindex 62ebd92..c7813e9 100644\n--- ros2topic/ros2topic/api/__init__.py\n\u002B\u002B\u002B ros2topic/ros2topic/api/__init__.py\n@@ -21,6 \u002B21,9 @@ import rclpy\n \n from rclpy.duration import Duration\n from rclpy.expand_topic_name import expand_topic_name\n\u002Bfrom rclpy.qos import QoSDurabilityPolicy\n\u002Bfrom rclpy.qos import QoSPresetProfiles\n\u002Bfrom rclpy.qos import QoSReliabilityPolicy\n from rclpy.topic_or_service_is_hidden import topic_or_service_is_hidden\n from rclpy.validate_full_topic_name import validate_full_topic_name\n from ros2cli.node.strategy import NodeStrategy\n@@ -259,3 \u002B262,64 @@ def add_qos_arguments(\n             f\u0027Quality of service liveliness lease duration setting to {entity_type} \u0027\n             \u0027with (overrides liveliness lease duration value of --qos-profile option, default: \u0027\n             f\u0027{default_profile.liveliness_lease_duration})\u0027))\n\u002B\n\u002B\n\u002Bdef choose_qos(node, topic_name: str, qos_args):\n\u002B    if (qos_args.qos_reliability is not None or\n\u002B            qos_args.qos_durability is not None or\n\u002B            qos_args.qos_depth is not None or\n\u002B            qos_args.qos_history is not None or\n\u002B            qos_args.qos_liveliness is not None or\n\u002B            qos_args.qos_liveliness_lease_duration_seconds is not None):\n\u002B\n\u002B        return qos_profile_from_short_keys(\n\u002B            qos_args.qos_profile,\n\u002B            reliability=qos_args.qos_reliability,\n\u002B            durability=qos_args.qos_durability,\n\u002B            depth=qos_args.qos_depth,\n\u002B            history=qos_args.qos_history,\n\u002B            liveliness=qos_args.qos_liveliness,\n\u002B            liveliness_lease_duration_s=qos_args.qos_liveliness_lease_duration_seconds)\n\u002B\n\u002B    qos_profile = QoSPresetProfiles.get_from_short_key(qos_args.qos_profile)\n\u002B    reliability_reliable_endpoints_count = 0\n\u002B    durability_transient_local_endpoints_count = 0\n\u002B\n\u002B    pubs_info = node.get_publishers_info_by_topic(topic_name)\n\u002B    publishers_count = len(pubs_info)\n\u002B    if publishers_count == 0:\n\u002B        return qos_profile\n\u002B\n\u002B    for info in pubs_info:\n\u002B        if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n\u002B            reliability_reliable_endpoints_count \u002B= 1\n\u002B        if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n\u002B            durability_transient_local_endpoints_count \u002B= 1\n\u002B\n\u002B    # If all endpoints are reliable, ask for reliable\n\u002B    if reliability_reliable_endpoints_count == publishers_count:\n\u002B        qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n\u002B    else:\n\u002B        if reliability_reliable_endpoints_count \u003E 0:\n\u002B            print(\n\u002B                \u0027Some, but not all, publishers are offering \u0027\n\u002B                \u0027QoSReliabilityPolicy.RELIABLE. Falling back to \u0027\n\u002B                \u0027QoSReliabilityPolicy.BEST_EFFORT as it will connect \u0027\n\u002B                \u0027to all publishers\u0027\n\u002B            )\n\u002B        qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n\u002B\n\u002B    # If all endpoints are transient_local, ask for transient_local\n\u002B    if durability_transient_local_endpoints_count == publishers_count:\n\u002B        qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n\u002B    else:\n\u002B        if durability_transient_local_endpoints_count \u003E 0:\n\u002B            print(\n\u002B                \u0027Some, but not all, publishers are offering \u0027\n\u002B                \u0027QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to \u0027\n\u002B                \u0027QoSDurabilityPolicy.VOLATILE as it will connect \u0027\n\u002B                \u0027to all publishers\u0027\n\u002B            )\n\u002B        qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n\u002B\n\u002B    return qos_profile\ndiff --git ros2topic/ros2topic/verb/bw.py ros2topic/ros2topic/verb/bw.py\nindex b1ad3f1..cff08a6 100644\n--- ros2topic/ros2topic/verb/bw.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/bw.py\n@@ -34,9 \u002B34,10 @@ import threading\n import traceback\n \n import rclpy\n-from rclpy.qos import qos_profile_sensor_data\n from ros2cli.node.direct import add_arguments as add_direct_node_arguments\n from ros2cli.node.direct import DirectNode\n\u002Bfrom ros2topic.api import add_qos_arguments\n\u002Bfrom ros2topic.api import choose_qos\n from ros2topic.api import get_msg_class\n from ros2topic.api import positive_int\n from ros2topic.api import TopicNameCompleter\n@@ -62,19 \u002B63,21 @@ class BwVerb(VerbExtension):\n \n     def add_arguments(self, parser, cli_name):\n         arg = parser.add_argument(\n-            \u0027topic\u0027,\n\u002B            \u0027topic_name\u0027,\n             help=\u0027Topic name to monitor for bandwidth utilization\u0027)\n         arg.completer = TopicNameCompleter(\n             include_hidden_topics_key=\u0027include_hidden_topics\u0027)\n\u002B        add_qos_arguments(parser, \u0027subscribe\u0027, \u0027sensor_data\u0027)\n         parser.add_argument(\n-            \u0027--window\u0027, \u0027-w\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n\u002B            \u0027--window\u0027, \u0027-w\u0027, dest=\u0027window_size\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n             help=\u0027maximum window size, in # of messages, for calculating rate \u0027\n                  f\u0027(default: {DEFAULT_WINDOW_SIZE})\u0027, metavar=\u0027WINDOW\u0027)\n         add_direct_node_arguments(parser)\n \n     def main(self, *, args):\n         with DirectNode(args) as node:\n-            _rostopic_bw(node.node, args.topic, window_size=args.window)\n\u002B            qos_profile = choose_qos(node.node, topic_name=args.topic_name, qos_args=args)\n\u002B            _rostopic_bw(node.node, args.topic_name, qos_profile, window_size=args.window_size)\n \n \n class ROSTopicBandwidth(object):\n@@ -150,7 \u002B153,7 @@ class ROSTopicBandwidth(object):\n         print(f\u0027{bw} from {n} messages\\n\\tMessage size mean: {mean} min: {min_s} max: {max_s}\u0027)\n \n \n-def _rostopic_bw(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n\u002Bdef _rostopic_bw(node, topic, qos_profile, window_size=DEFAULT_WINDOW_SIZE):\n     \u0022\u0022\u0022Periodically print the received bandwidth of a topic to console until shutdown.\u0022\u0022\u0022\n     # pause bw until topic is published\n     msg_class = get_msg_class(node, topic, blocking=True, include_hidden_topics=True)\n@@ -163,7 \u002B166,7 @@ def _rostopic_bw(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n         msg_class,\n         topic,\n         rt.callback,\n-        qos_profile_sensor_data,\n\u002B        qos_profile,\n         raw=True\n     )\n \ndiff --git ros2topic/ros2topic/verb/delay.py ros2topic/ros2topic/verb/delay.py\nindex da5e63e..882c4f4 100644\n--- ros2topic/ros2topic/verb/delay.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/delay.py\n@@ -33,10 \u002B33,11 @@ import math\n \n import rclpy\n \n-from rclpy.qos import qos_profile_sensor_data\n from rclpy.time import Time\n from ros2cli.node.direct import add_arguments as add_direct_node_arguments\n from ros2cli.node.direct import DirectNode\n\u002Bfrom ros2topic.api import add_qos_arguments\n\u002Bfrom ros2topic.api import choose_qos\n from ros2topic.api import get_msg_class\n from ros2topic.api import positive_int\n from ros2topic.api import TopicNameCompleter\n@@ -50,12 \u002B51,13 @@ class DelayVerb(VerbExtension):\n \n     def add_arguments(self, parser, cli_name):\n         arg = parser.add_argument(\n-            \u0027topic\u0027,\n\u002B            \u0027topic_name\u0027,\n             help=\u0027Topic name to calculate the delay for\u0027)\n         arg.completer = TopicNameCompleter(\n             include_hidden_topics_key=\u0027include_hidden_topics\u0027)\n\u002B        add_qos_arguments(parser, \u0027subscribe\u0027, \u0027sensor_data\u0027)\n         parser.add_argument(\n-            \u0027--window\u0027, \u0027-w\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n\u002B            \u0027--window\u0027, \u0027-w\u0027, dest=\u0027window_size\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n             help=\u0027window size, in # of messages, for calculating rate, \u0027\n                  \u0027string to (default: %d)\u0027 % DEFAULT_WINDOW_SIZE)\n         add_direct_node_arguments(parser)\n@@ -66,8 \u002B68,8 @@ class DelayVerb(VerbExtension):\n \n def main(args):\n     with DirectNode(args) as node:\n-        _rostopic_delay(\n-            node.node, args.topic, window_size=args.window)\n\u002B        qos_profile = choose_qos(node.node, topic_name=args.topic_name, qos_args=args)\n\u002B        _rostopic_delay(node.node, args.topic_name, qos_profile, window_size=args.window_size)\n \n \n class ROSTopicDelay(object):\n@@ -155,11 \u002B157,12 @@ class ROSTopicDelay(object):\n               % (delay * 1e-9, min_delta * 1e-9, max_delta * 1e-9, std_dev * 1e-9, window))\n \n \n-def _rostopic_delay(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n\u002Bdef _rostopic_delay(node, topic, qos_profile, window_size=DEFAULT_WINDOW_SIZE):\n     \u0022\u0022\u0022\n     Periodically print the publishing delay of a topic to console until shutdown.\n \n     :param topic: topic name, \u0060\u0060str\u0060\u0060\n\u002B    :param qos_profile: qos profile of the subscriber\n     :param window_size: number of messages to average over, \u0060\u0060unsigned_int\u0060\u0060\n     :param blocking: pause delay until topic is published, \u0060\u0060bool\u0060\u0060\n     \u0022\u0022\u0022\n@@ -175,7 \u002B178,7 @@ def _rostopic_delay(node, topic, window_size=DEFAULT_WINDOW_SIZE):\n         msg_class,\n         topic,\n         rt.callback_delay,\n-        qos_profile_sensor_data)\n\u002B        qos_profile)\n \n     timer = node.create_timer(1, rt.print_delay)\n     while rclpy.ok():\ndiff --git ros2topic/ros2topic/verb/echo.py ros2topic/ros2topic/verb/echo.py\nindex 56693ec..639e97c 100644\n--- ros2topic/ros2topic/verb/echo.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/echo.py\n@@ -19,18 \u002B19,15 @@ import rclpy\n from rclpy.event_handler import SubscriptionEventCallbacks\n from rclpy.event_handler import UnsupportedEventTypeError\n from rclpy.node import Node\n-from rclpy.qos import QoSDurabilityPolicy\n-from rclpy.qos import QoSPresetProfiles\n from rclpy.qos import QoSProfile\n-from rclpy.qos import QoSReliabilityPolicy\n from rclpy.task import Future\n from ros2cli.helpers import unsigned_int\n from ros2cli.node.strategy import add_arguments as add_strategy_node_arguments\n from ros2cli.node.strategy import NodeStrategy\n from ros2topic.api import add_qos_arguments\n\u002Bfrom ros2topic.api import choose_qos\n from ros2topic.api import get_msg_class\n from ros2topic.api import positive_float\n-from ros2topic.api import qos_profile_from_short_keys\n from ros2topic.api import TopicNameCompleter\n from ros2topic.verb import VerbExtension\n from rosidl_runtime_py import message_to_csv\n@@ -116,67 \u002B113,6 @@ class EchoVerb(VerbExtension):\n             \u0027-n\u0027, \u0027--node-name\u0027, type=str, default=None,\n             help=\u0027The name of the echoing node; by default, will be a hidden node name\u0027)\n \n-    def choose_qos(self, node, args):\n-\n-        if (args.qos_reliability is not None or\n-                args.qos_durability is not None or\n-                args.qos_depth is not None or\n-                args.qos_history is not None or\n-                args.qos_liveliness is not None or\n-                args.qos_liveliness_lease_duration_seconds is not None):\n-\n-            return qos_profile_from_short_keys(\n-                args.qos_profile,\n-                reliability=args.qos_reliability,\n-                durability=args.qos_durability,\n-                depth=args.qos_depth,\n-                history=args.qos_history,\n-                liveliness=args.qos_liveliness,\n-                liveliness_lease_duration_s=args.qos_liveliness_lease_duration_seconds)\n-\n-        qos_profile = QoSPresetProfiles.get_from_short_key(args.qos_profile)\n-        reliability_reliable_endpoints_count = 0\n-        durability_transient_local_endpoints_count = 0\n-\n-        pubs_info = node.get_publishers_info_by_topic(args.topic_name)\n-        publishers_count = len(pubs_info)\n-        if publishers_count == 0:\n-            return qos_profile\n-\n-        for info in pubs_info:\n-            if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n-                reliability_reliable_endpoints_count \u002B= 1\n-            if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n-                durability_transient_local_endpoints_count \u002B= 1\n-\n-        # If all endpoints are reliable, ask for reliable\n-        if reliability_reliable_endpoints_count == publishers_count:\n-            qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n-        else:\n-            if reliability_reliable_endpoints_count \u003E 0:\n-                print(\n-                    \u0027Some, but not all, publishers are offering \u0027\n-                    \u0027QoSReliabilityPolicy.RELIABLE. Falling back to \u0027\n-                    \u0027QoSReliabilityPolicy.BEST_EFFORT as it will connect \u0027\n-                    \u0027to all publishers\u0027\n-                )\n-            qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n-\n-        # If all endpoints are transient_local, ask for transient_local\n-        if durability_transient_local_endpoints_count == publishers_count:\n-            qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n-        else:\n-            if durability_transient_local_endpoints_count \u003E 0:\n-                print(\n-                    \u0027Some, but not all, publishers are offering \u0027\n-                    \u0027QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to \u0027\n-                    \u0027QoSDurabilityPolicy.VOLATILE as it will connect \u0027\n-                    \u0027to all publishers\u0027\n-                )\n-            qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n-\n-        return qos_profile\n-\n     def main(self, *, args):\n \n         self.csv = args.csv\n@@ -210,7 \u002B146,7 @@ class EchoVerb(VerbExtension):\n \n         with NodeStrategy(args, node_name=args.node_name) as node:\n \n-            qos_profile = self.choose_qos(node, args)\n\u002B            qos_profile = choose_qos(node, topic_name=args.topic_name, qos_args=args)\n \n             if args.message_type is None:\n                 message_type = get_msg_class(\ndiff --git ros2topic/ros2topic/verb/hz.py ros2topic/ros2topic/verb/hz.py\nindex b04b2ed..9b5f355 100644\n--- ros2topic/ros2topic/verb/hz.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/hz.py\n@@ -41,9 \u002B41,10 @@ import rclpy\n from rclpy.clock import Clock\n from rclpy.clock import ClockType\n from rclpy.executors import ExternalShutdownException\n-from rclpy.qos import qos_profile_sensor_data\n from ros2cli.node.direct import add_arguments as add_direct_node_arguments\n from ros2cli.node.direct import DirectNode\n\u002Bfrom ros2topic.api import add_qos_arguments\n\u002Bfrom ros2topic.api import choose_qos\n from ros2topic.api import get_msg_class\n from ros2topic.api import positive_int\n from ros2topic.api import TopicNameCompleter\n@@ -62,6 \u002B63,7 @@ class HzVerb(VerbExtension):\n             help=\u0022Names of the ROS topic to listen to (e.g. \u0027/chatter\u0027)\u0022)\n         arg.completer = TopicNameCompleter(\n             include_hidden_topics_key=\u0027include_hidden_topics\u0027)\n\u002B        add_qos_arguments(parser, \u0027subscribe\u0027, \u0027sensor_data\u0027)\n         parser.add_argument(\n             \u0027--window\u0027, \u0027-w\u0027,\n             dest=\u0027window_size\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n@@ -94,8 \u002B96,8 @@ def main(args):\n         filter_expr = None\n \n     with DirectNode(args) as node:\n-        _rostopic_hz(node.node, topics, window_size=args.window_size, filter_expr=filter_expr,\n-                     use_wtime=args.use_wtime)\n\u002B        _rostopic_hz(node.node, topics, qos_args=args, window_size=args.window_size,\n\u002B                     filter_expr=filter_expr, use_wtime=args.use_wtime)\n \n \n class ROSTopicHz(object):\n@@ -278,11 \u002B280,13 @@ def _get_ascii_table(header, cols):\n     return table\n \n \n-def _rostopic_hz(node, topics, window_size=DEFAULT_WINDOW_SIZE, filter_expr=None, use_wtime=False):\n\u002Bdef _rostopic_hz(node, topics, qos_args, window_size=DEFAULT_WINDOW_SIZE, filter_expr=None,\n\u002B                 use_wtime=False):\n     \u0022\u0022\u0022\n     Periodically print the publishing rate of a topic to console until shutdown.\n \n     :param topics: list of topic names, \u0060\u0060list\u0060\u0060 of \u0060\u0060str\u0060\u0060\n\u002B    :param qos_args: qos arguments used to pick the qos profile of the subscriber\n     :param window_size: number of messages to average over, -1 for infinite, \u0060\u0060int\u0060\u0060\n     :param filter_expr: Python filter expression that is called with m, the message instance\n     \u0022\u0022\u0022\n@@ -299,11 \u002B303,13 @@ def _rostopic_hz(node, topics, window_size=DEFAULT_WINDOW_SIZE, filter_expr=None\n             print(\u0027WARNING: failed to find message type for topic [%s]\u0027 % topic)\n             continue\n \n\u002B        qos_profile = choose_qos(node, topic_name=topic, qos_args=qos_args)\n\u002B\n         node.create_subscription(\n             msg_class,\n             topic,\n             functools.partial(rt.callback_hz, topic=topic),\n-            qos_profile_sensor_data)\n\u002B            qos_profile)\n         if topics_len \u003E 1:\n             print(\u0027Subscribed to [%s]\u0027 % topic)\n \ndiff --git ros2topic/test/test_bw_delay_hz.py ros2topic/test/test_bw_delay_hz.py\nnew file mode 100644\nindex 0000000..ed5d480\n--- /dev/null\n\u002B\u002B\u002B ros2topic/test/test_bw_delay_hz.py\n@@ -0,0 \u002B1,200 @@\n\u002B# Copyright 2025 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport re\n\u002Bimport sys\n\u002Bimport unittest\n\u002B\n\u002Bfrom geometry_msgs.msg import PointStamped  # Used because delay requires a message with a header\n\u002B\n\u002Bfrom launch import LaunchDescription\n\u002Bfrom launch.actions import ExecuteProcess\n\u002B\n\u002Bimport launch_testing\n\u002Bimport launch_testing.actions\n\u002Bimport launch_testing.asserts\n\u002Bimport launch_testing.markers\n\u002Bimport launch_testing.tools\n\u002Bimport launch_testing_ros.tools\n\u002B\n\u002Bimport pytest\n\u002B\n\u002Bimport rclpy\n\u002Bfrom rclpy.executors import SingleThreadedExecutor\n\u002Bfrom rclpy.qos import DurabilityPolicy\n\u002Bfrom rclpy.qos import QoSProfile\n\u002Bfrom rclpy.qos import ReliabilityPolicy\n\u002Bfrom rclpy.utilities import get_rmw_implementation_identifier\n\u002B\n\u002B\n\u002B# Skip cli tests on Windows while they exhibit pathological behavior\n\u002B# https://github.com/ros2/build_farmer/issues/248\n\u002Bif sys.platform.startswith(\u0027win\u0027):\n\u002B    pytest.skip(\n\u002B            \u0027CLI tests can block for a pathological amount of time on Windows.\u0027,\n\u002B            allow_module_level=True)\n\u002B\n\u002B\n\u002BTEST_NODE = \u0027cli_bw_delay_hz_test_node\u0027\n\u002BTEST_NAMESPACE = \u0027cli_bw_delay_hz\u0027\n\u002B\n\u002B\n\u002B@pytest.mark.rostest\n\u002B@launch_testing.markers.keep_alive\n\u002Bdef generate_test_description():\n\u002B    return LaunchDescription([\n\u002B        # Always restart daemon to isolate tests.\n\u002B        ExecuteProcess(\n\u002B            cmd=[\u0027ros2\u0027, \u0027daemon\u0027, \u0027stop\u0027],\n\u002B            name=\u0027daemon-stop\u0027,\n\u002B            on_exit=[\n\u002B                ExecuteProcess(\n\u002B                    cmd=[\u0027ros2\u0027, \u0027daemon\u0027, \u0027start\u0027],\n\u002B                    name=\u0027daemon-start\u0027,\n\u002B                    on_exit=[\n\u002B                        launch_testing.actions.ReadyToTest()\n\u002B                    ],\n\u002B                )\n\u002B            ]\n\u002B        )\n\u002B    ])\n\u002B\n\u002B\n\u002Bclass TestROS2TopicBwDelayHz(unittest.TestCase):\n\u002B\n\u002B    def setUp(self):\n\u002B        self.context = rclpy.context.Context()\n\u002B        rclpy.init(context=self.context)\n\u002B        self.node = rclpy.create_node(\n\u002B            TEST_NODE, namespace=TEST_NAMESPACE, context=self.context\n\u002B        )\n\u002B        self.executor = SingleThreadedExecutor(context=self.context)\n\u002B        self.executor.add_node(self.node)\n\u002B\n\u002B    def tearDown(self):\n\u002B        self.node.destroy_node()\n\u002B        rclpy.shutdown(context=self.context)\n\u002B\n\u002B    def helper_verb_basic(self, launch_service, proc_info, proc_output, verb, success_regex):\n\u002B        params = [\n\u002B            (f\u0027/clitest/topic/{verb}_basic\u0027, False, True),\n\u002B            (f\u0027/clitest/topic/{verb}_compatible_qos\u0027, True, True),\n\u002B            (f\u0027/clitest/topic/{verb}_incompatible_qos\u0027, True, False),\n\u002B        ]\n\u002B        for topic, provide_qos, compatible_qos in params:\n\u002B            with self.subTest(topic=topic, provide_qos=provide_qos, compatible_qos=compatible_qos):\n\u002B                # Check for inconsistent arguments\n\u002B                assert provide_qos if not compatible_qos else True\n\u002B                verb_extra_options = []\n\u002B                publisher_qos_profile = 10\n\u002B                if provide_qos:\n\u002B                    if compatible_qos:\n\u002B                        # For compatible test, put publisher at very high quality\n\u002B                        # and subscription at low\n\u002B                        verb_extra_options = [\n\u002B                            \u0027--qos-reliability\u0027, \u0027best_effort\u0027,\n\u002B                            \u0027--qos-durability\u0027, \u0027volatile\u0027]\n\u002B                        publisher_qos_profile = QoSProfile(\n\u002B                            depth=10,\n\u002B                            reliability=ReliabilityPolicy.RELIABLE,\n\u002B                            durability=DurabilityPolicy.TRANSIENT_LOCAL)\n\u002B                    else:\n\u002B                        # For an incompatible example, reverse the quality extremes\n\u002B                        # and expect no messages to arrive\n\u002B                        verb_extra_options = [\n\u002B                            \u0027--qos-reliability\u0027, \u0027reliable\u0027,\n\u002B                            \u0027--qos-durability\u0027, \u0027transient_local\u0027]\n\u002B                        publisher_qos_profile = QoSProfile(\n\u002B                            depth=10,\n\u002B                            reliability=ReliabilityPolicy.BEST_EFFORT,\n\u002B                            durability=DurabilityPolicy.VOLATILE)\n\u002B                publisher = self.node.create_publisher(PointStamped, topic, publisher_qos_profile)\n\u002B                assert publisher\n\u002B\n\u002B                def publish_message():\n\u002B                    msg = PointStamped()\n\u002B                    # msg.header.stamp = self.node.get_clock().now()\n\u002B                    publisher.publish(msg)\n\u002B\n\u002B                publish_timer = self.node.create_timer(0.5, publish_message)\n\u002B\n\u002B                try:\n\u002B                    command_action = ExecuteProcess(\n\u002B                        cmd=([\u0027ros2\u0027, \u0027topic\u0027, verb] \u002B\n\u002B                             verb_extra_options \u002B\n\u002B                             [topic]),\n\u002B                        additional_env={\n\u002B                            \u0027PYTHONUNBUFFERED\u0027: \u00271\u0027\n\u002B                        },\n\u002B                        output=\u0027screen\u0027\n\u002B                    )\n\u002B                    with launch_testing.tools.launch_process(\n\u002B                        launch_service, command_action, proc_info, proc_output,\n\u002B                        output_filter=launch_testing_ros.tools.basic_output_filter(\n\u002B                            filtered_rmw_implementation=get_rmw_implementation_identifier()\n\u002B                        )\n\u002B                    ) as command:\n\u002B                        # The future won\u0027t complete - we will hit the timeout\n\u002B                        self.executor.spin_until_future_complete(\n\u002B                            rclpy.task.Future(), timeout_sec=5\n\u002B                        )\n\u002B                    command.wait_for_shutdown(timeout=10)\n\u002B                    # Check results\n\u002B                    if compatible_qos:\n\u002B                        assert command.output, f\u0027{verb} CLI printed no output\u0027\n\u002B                        assert re.search(success_regex, command.output, flags=re.MULTILINE), (\n\u002B                            f\u0027{verb} CLI did not print expected message\u0027\n\u002B                        )\n\u002B                    else:\n\u002B                        assert command.output, (\n\u002B                            f\u0027{verb} CLI did not print incompatible QoS warning\u0027\n\u002B                        )\n\u002B                        assert (\u0022New publisher discovered on topic \u0027{}\u0027, offering incompatible\u0022\n\u002B                                \u0027 QoS.\u0027.format(topic) in command.output), (\n\u002B                                f\u0027{verb} CLI did not print expected incompatible QoS warning\u0027\n\u002B                            )\n\u002B                finally:\n\u002B                    # Cleanup\n\u002B                    self.node.destroy_timer(publish_timer)\n\u002B                    self.node.destroy_publisher(publisher)\n\u002B\n\u002B    @launch_testing.markers.retry_on_failure(times=5)\n\u002B    def test_bw_basic(self, launch_service, proc_info, proc_output):\n\u002B        self.helper_verb_basic(\n\u002B            launch_service,\n\u002B            proc_info,\n\u002B            proc_output,\n\u002B            \u0027bw\u0027,\n\u002B            r\u0027^[0-9]\u002B B/s from [0-9]\u002B messages$\u0027\n\u002B        )\n\u002B\n\u002B    @launch_testing.markers.retry_on_failure(times=5)\n\u002B    def test_delay_basic(self, launch_service, proc_info, proc_output):\n\u002B        self.helper_verb_basic(\n\u002B            launch_service,\n\u002B            proc_info,\n\u002B            proc_output,\n\u002B            \u0027delay\u0027,\n\u002B            r\u0027^average delay: [0-9\\.]\u002B$\u0027\n\u002B        )\n\u002B\n\u002B    @launch_testing.markers.retry_on_failure(times=5)\n\u002B    def test_hw_basic(self, launch_service, proc_info, proc_output):\n\u002B        self.helper_verb_basic(\n\u002B            launch_service,\n\u002B            proc_info,\n\u002B            proc_output,\n\u002B            \u0027hz\u0027,\n\u002B            r\u0027^average rate: [0-9\\.]\u002B$\u0027\n\u002B        )\ndiff --git ros2topic/test/test_cli.py ros2topic/test/test_cli.py\nindex 84640d0..1147322 100644\n--- ros2topic/test/test_cli.py\n\u002B\u002B\u002B ros2topic/test/test_cli.py\n@@ -946,7 \u002B946,7 @@ class TestROS2TopicCLI(unittest.TestCase):\n             assert topic_command.wait_for_output(functools.partial(\n                 launch_testing.tools.expect_output, expected_lines=[\n                     \u0027Subscribed to [/defaults]\u0027,\n-                    re.compile(r\u0027\\d{2} B/s from \\d\u002B messages\u0027),\n\u002B                    re.compile(r\u0027\\d{2,3} B/s from \\d\u002B messages\u0027),\n                     re.compile(r\u0027\\s*Message size mean: \\d{2} B min: \\d{2} B max: \\d{2} B\u0027)\n                 ], strict=True\n             ), timeout=10)\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "163f0700d0df30b58c95a300d255f834a3805b8c",
    "RawMessage": "Update publisher creation/destruction API documentation. (#252)",
    "Changes": "diff --git rmw/include/rmw/rmw.h rmw/include/rmw/rmw.h\nindex 49a209b..6fa1f6e 100644\n--- rmw/include/rmw/rmw.h\n\u002B\u002B\u002B rmw/include/rmw/rmw.h\n@@ -276,14 \u002B276,38 @@ RMW_WARN_UNUSED\n rmw_publisher_options_t\n rmw_get_default_publisher_options(void);\n \n-/// Create and return an rmw publisher.\n\u002B/// Create a publisher and return a handle to that publisher.\n /**\n- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n\u002B * This function can fail, and therefore return \u0060NULL\u0060, if:\n\u002B *   - node is not a valid non-null handle for this rmw implementation,\n\u002B *     as returned by \u0060rmw_create_node()\u0060\n\u002B *   - type_support is a not valid non-null message type support, as returned by\n\u002B *     \u0060ROSIDL_GET_MSG_TYPE_SUPPORT()\u0060\n\u002B *   - topic_name is not a valid non-null topic name, according to\n\u002B *     \u0060rmw_validate_full_topic_name()\u0060\n\u002B *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n\u002B *   - publisher_options is not a valid non-null option set, as returned by\n\u002B *     \u0060rmw_get_default_publisher_options()\u0060\n\u002B *   - memory allocation fails during publisher creation\n\u002B *   - an unspecified error occurs\n  *\n- * The argument \u0060publisher_options\u0060 must not be nullptr.\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Yes\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n  *\n- * \\param[in] publisher_options options for configuring the publisher\n\u002B * \\param[in] node Handle to node with which to register this publisher\n\u002B * \\param[in] type_support Type support for the messages to be published\n\u002B * \\param[in] topic_name Name of the topic to publish to, often a fully qualified\n\u002B *   topic name unless \u0060qos_profile\u0060 is configured to avoid ROS namespace conventions\n\u002B *   i.e. to create a native topic publisher\n\u002B * \\param[in] qos_profile QoS policies for this publisher\n\u002B * \\param[in] publisher_options Options to configure this publisher\n\u002B * \\return rmw publisher handle, or \u0060NULL\u0060 if there was an error\n  */\n RMW_PUBLIC\n RMW_WARN_UNUSED\n@@ -292,9 \u002B316,35 @@ rmw_create_publisher(\n   const rmw_node_t * node,\n   const rosidl_message_type_support_t * type_support,\n   const char * topic_name,\n-  const rmw_qos_profile_t * qos_policies,\n\u002B  const rmw_qos_profile_t * qos_profile,\n   const rmw_publisher_options_t * publisher_options);\n \n\u002B/// Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.\n\u002B/**\n\u002B * This function will return early if a logical error, such as \u0060RMW_RET_INVALID_ARGUMENT\u0060\n\u002B * or \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060, ensues, leaving the given publisher handle unchanged.\n\u002B * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n\u002B * the publisher handle. Usage of a deallocated publisher handle is undefined behavior.\n\u002B *\n\u002B * \\pre Given node must be the one the publisher was registered with.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | No\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n\u002B *\n\u002B * \\param[in] node Handle to node with which the given publisher is registered\n\u002B * \\param[in] publisher Handle to publisher to be finalized\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if node or publisher is \u0060NULL\u0060, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if node or publisher\n\u002B *   implementation identifier does not match, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n\u002B */\n RMW_PUBLIC\n RMW_WARN_UNUSED\n rmw_ret_t\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "c22b5270e1e1a16a57f309733238a24f8e49bd23",
    "RawMessage": "Make spin_until_future_complete check for shutdown",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex 220cd18..7a0f823 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -286,7 \u002B286,7 @@ class Executor:\n     def spin_until_future_complete(self, future: Future, timeout_sec: float = None) -\u003E None:\n         \u0022\u0022\u0022Execute callbacks until a given future is done or a timeout occurs.\u0022\u0022\u0022\n         if timeout_sec is None or timeout_sec \u003C 0:\n-            while self._context.ok() and not future.done():\n\u002B            while self._context.ok() and not future.done() and not self._is_shutdown:\n                 self.spin_once(timeout_sec=timeout_sec)\n         else:\n             start = time.monotonic()\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "d855c90c4b2a9ce63ed0117000aab12b9b12b373",
    "RawMessage": "Handle RMW_DEFAULT_DOMAIN_ID. (#394)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/participant.cpp rmw_fastrtps_shared_cpp/src/participant.cpp\nindex 5b6ec9d..78871a2 100644\n--- rmw_fastrtps_shared_cpp/src/participant.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/participant.cpp\n@@ -164,10 \u002B164,13 @@ rmw_fastrtps_shared_cpp::create_participant(\n     participantAttrs.rtps.builtin.initialPeersList.push_back(local_network_interface_locator);\n   }\n \n\u002B  // No custom handling of RMW_DEFAULT_DOMAIN_ID. Simply use a reasonable domain id.\n #if FASTRTPS_VERSION_MAJOR \u003C 2\n-  participantAttrs.rtps.builtin.domainId = static_cast\u003Cuint32_t\u003E(domain_id);\n\u002B  participantAttrs.rtps.builtin.domainId =\n\u002B    static_cast\u003Cuint32_t\u003E(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);\n #else\n-  participantAttrs.domainId = static_cast\u003Cuint32_t\u003E(domain_id);\n\u002B  participantAttrs.domainId =\n\u002B    static_cast\u003Cuint32_t\u003E(domain_id != RMW_DEFAULT_DOMAIN_ID ? domain_id : 0u);\n #endif\n \n   size_t length = snprintf(nullptr, 0, \u0022enclave=%s;\u0022, enclave) \u002B 1;\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "f16b8137ce7f389174182e478f75e2427e077301",
    "RawMessage": "add yaml dump flow style. (#698)",
    "Changes": "diff --git ros2topic/ros2topic/verb/echo.py ros2topic/ros2topic/verb/echo.py\nindex bd8de6d..bfae04a 100644\n--- ros2topic/ros2topic/verb/echo.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/echo.py\n@@ -107,6 \u002B107,9 @@ class EchoVerb(VerbExtension):\n             \u0027--no-arr\u0027, action=\u0027store_true\u0027, help=\u0022Don\u0027t print array fields of messages\u0022)\n         parser.add_argument(\n             \u0027--no-str\u0027, action=\u0027store_true\u0027, help=\u0022Don\u0027t print string fields of messages\u0022)\n\u002B        parser.add_argument(\n\u002B            \u0027--flow-style\u0027, action=\u0027store_true\u0027,\n\u002B            help=\u0027Print collections in the block style (not available with csv format)\u0027)\n         parser.add_argument(\n             \u0027--lost-messages\u0027, action=\u0027store_true\u0027, help=\u0027DEPRECATED: Does nothing\u0027)\n         parser.add_argument(\n@@ -188,7 \u002B191,8 @@ class EchoVerb(VerbExtension):\n \n         # Select print function\n         self.print_func = _print_yaml\n-        if args.csv:\n\u002B        self.csv = args.csv\n\u002B        if self.csv:\n             self.print_func = _print_csv\n \n         # Validate field selection\n@@ -201,6 \u002B205,7 @@ class EchoVerb(VerbExtension):\n         self.truncate_length = args.truncate_length if not args.full_length else None\n         self.no_arr = args.no_arr\n         self.no_str = args.no_str\n\u002B        self.flow_style = args.flow_style\n \n         self.filter_fn = None\n         if args.filter_expr:\n@@ -288,7 \u002B293,11 @@ class EchoVerb(VerbExtension):\n         if self.future is not None:\n             self.future.set_result(True)\n \n-        self.print_func(submsg, self.truncate_length, self.no_arr, self.no_str)\n\u002B        if self.csv:\n\u002B            self.print_func(submsg, self.truncate_length, self.no_arr, self.no_str)\n\u002B        else:\n\u002B            self.print_func(\n\u002B                submsg, self.truncate_length, self.no_arr, self.no_str, self.flow_style)\n \n \n def _expr_eval(expr):\n@@ -297,11 \u002B306,12 @@ def _expr_eval(expr):\n     return eval_fn\n \n \n-def _print_yaml(msg, truncate_length, noarr, nostr):\n\u002Bdef _print_yaml(msg, truncate_length, noarr, nostr, flowstyle):\n     if hasattr(msg, \u0027__slots__\u0027):\n         print(\n             message_to_yaml(\n-                msg, truncate_length=truncate_length, no_arr=noarr, no_str=nostr),\n\u002B                msg, truncate_length=truncate_length,\n\u002B                no_arr=noarr, no_str=nostr, flow_style=flowstyle),\n             end=\u0027---\\n\u0027)\n     else:\n         print(msg, end=\u0027\\n---\\n\u0027)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "1ed02409a2a31ebdf9bbbae881ca4e71ce5ca375",
    "RawMessage": "update codecov to ignore rclc_examples and all test folders (#145)",
    "Changes": "diff --git codecov.yml codecov.yml\nindex 338b8bc..eea8505 100644\n--- codecov.yml\n\u002B\u002B\u002B codecov.yml\n@@ -1,4 \u002B1,5 @@\n ignore:\n-  - \u0022rclc_examples\u0022\n-  - \u0022rclc/test\u0022\n-  - \u0022rclc_lifecycle/test\u0022\n\u002B  - \u0022rclc_examples/**/*\u0022\n\u002B  - \u0022rclc/test/**/*\u0022\n\u002B  - \u0022rclc_lifecycle/test/**/*\u0022\n\u002B  - \u0022rclc_parameter/test/**/*\u0022\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "1f5a713d9bb262ffd04e83fd4c59860037701e85",
    "RawMessage": "[rcl_yaml_param_parser] Add warnings (#831)",
    "Changes": "diff --git rcl_yaml_param_parser/CMakeLists.txt rcl_yaml_param_parser/CMakeLists.txt\nindex 218801b..397f662 100644\n--- rcl_yaml_param_parser/CMakeLists.txt\n\u002B\u002B\u002B rcl_yaml_param_parser/CMakeLists.txt\n@@ -13,7 \u002B13,10 @@ if(NOT CMAKE_CXX_STANDARD)\n endif()\n \n if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \u0022Clang\u0022)\n-  add_compile_options(-Wall -Wextra -Wpedantic)\n\u002B  add_compile_options(\n\u002B    -Wall -Wextra -Wpedantic\n\u002B    -Wformat=2 -Wconversion -Wsign-conversion\n\u002B  )\n endif()\n \n set(rcl_yaml_parser_sources\ndiff --git rcl_yaml_param_parser/src/parse.c rcl_yaml_param_parser/src/parse.c\nindex c7cd69c..acce68a 100644\n--- rcl_yaml_param_parser/src/parse.c\n\u002B\u002B\u002B rcl_yaml_param_parser/src/parse.c\n@@ -501,7 \u002B501,7 @@ _validate_name(const char * name, rcutils_allocator_t allocator)\n     }\n   } else {\n     // substring namespace including the last \u0027/\u0027\n-    char * namespace_ = rcutils_strndup(name, separator_pos - name \u002B 1, allocator);\n\u002B    char * namespace_ = rcutils_strndup(name, ((size_t) (separator_pos - name)) \u002B 1, allocator);\n     if (NULL == namespace_) {\n       ret = RCUTILS_RET_BAD_ALLOC;\n       goto clean;\n@@ -534,7 \u002B534,7 @@ _validate_name(const char * name, rcutils_allocator_t allocator)\n       }\n     } else {\n       do {\n-        size_t len = separator_pos - absolute_namespace - i;\n\u002B        size_t len = ((size_t) (separator_pos - absolute_namespace)) - i;\n         char * namespace_ = rcutils_strndup(absolute_namespace \u002B i, len, allocator);\n         if (NULL == namespace_) {\n           ret = RCUTILS_RET_BAD_ALLOC;\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "f95c4960eadb4094c2aa296056d27b6664600b5e",
    "RawMessage": "Lost service responses (#183, #74) (#187)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex fe64263..7d5ba26 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -16,6 \u002B16,8 @@\n #include \u003Cunordered_map\u003E\n #include \u003Cunordered_set\u003E\n #include \u003Calgorithm\u003E\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Ciomanip\u003E\n #include \u003Cmap\u003E\n #include \u003Cset\u003E\n #include \u003Cfunctional\u003E\n@@ -75,6 \u002B77,8 @@\n #include \u0022serdata.hpp\u0022\n #include \u0022demangle.hpp\u0022\n \n\u002Busing namespace std::literals::chrono_literals;\n\u002B\n /* Security must be enabled when compiling and requires cyclone to support QOS property lists */\n #if DDS_HAS_SECURITY \u0026\u0026 DDS_HAS_PROPERTY_LIST_QOS\n #define RMW_SUPPORT_SECURITY 1\n@@ -244,6 \u002B248,7 @@ struct rmw_context_impl_t\n   rmw_dds_common::Context common;\n   dds_domainid_t domain_id;\n   dds_entity_t ppant;\n\u002B  rmw_gid_t ppant_gid;\n \n   /* handles for built-in topic readers */\n   dds_entity_t rd_participant;\n@@ -258,8 \u002B263,12 @@ struct rmw_context_impl_t\n   size_t node_count{0};\n   std::mutex initialization_mutex;\n \n\u002B  /* suffix for GUIDs to construct unique client/service ids\n\u002B     (protected by initialization_mutex) */\n\u002B  uint32_t client_service_id;\n\u002B\n   rmw_context_impl_t()\n-  : common(), domain_id(UINT32_MAX), ppant(0)\n\u002B  : common(), domain_id(UINT32_MAX), ppant(0), client_service_id(0)\n   {\n     /* destructor relies on these being initialized properly */\n     common.thread_is_running.store(false);\n@@ -309,10 \u002B318,18 @@ struct CddsSubscription : CddsEntity\n   dds_entity_t rdcondh;\n };\n \n\u002Bstruct client_service_id_t\n\u002B{\n\u002B  // strangely, the writer_guid in an rmw_request_id_t is smaller than the identifier in\n\u002B  // an rmw_gid_t\n\u002B  uint8_t data[sizeof((reinterpret_cast\u003Crmw_request_id_t *\u003E(0))-\u003Ewriter_guid)]; // NOLINT\n\u002B};\n\u002B\n struct CddsCS\n {\n   CddsPublisher * pub;\n   CddsSubscription * sub;\n\u002B  client_service_id_t id;\n };\n \n struct CddsClient\n@@ -490,6 \u002B507,32 @@ static void get_entity_gid(dds_entity_t h, rmw_gid_t \u0026 gid)\n   convert_guid_to_gid(guid, gid);\n }\n \n\u002Bstatic std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E parse_user_data(const dds_qos_t * qos)\n\u002B{\n\u002B  std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E map;\n\u002B  void * ud;\n\u002B  size_t udsz;\n\u002B  if (dds_qget_userdata(qos, \u0026ud, \u0026udsz)) {\n\u002B    std::vector\u003Cuint8_t\u003E udvec(static_cast\u003Cuint8_t *\u003E(ud), static_cast\u003Cuint8_t *\u003E(ud) \u002B udsz);\n\u002B    dds_free(ud);\n\u002B    map = rmw::impl::cpp::parse_key_value(udvec);\n\u002B  }\n\u002B  return map;\n\u002B}\n\u002B\n\u002Bstatic bool get_user_data_key(const dds_qos_t * qos, const std::string key, std::string \u0026 value)\n\u002B{\n\u002B  if (qos != nullptr) {\n\u002B    auto map = parse_user_data(qos);\n\u002B    auto name_found = map.find(key);\n\u002B    if (name_found != map.end()) {\n\u002B      value = std::string(name_found-\u003Esecond.begin(), name_found-\u003Esecond.end());\n\u002B      return true;\n\u002B    }\n\u002B  }\n\u002B  return false;\n\u002B}\n\u002B\n static void handle_ParticipantEntitiesInfo(dds_entity_t reader, void * arg)\n {\n   static_cast\u003Cvoid\u003E(reader);\n@@ -516,18 \u002B559,9 @@ static void handle_DCPSParticipant(dds_entity_t reader, void * arg)\n     } else if (si.instance_state != DDS_ALIVE_INSTANCE_STATE) {\n       impl-\u003Ecommon.graph_cache.remove_participant(gid);\n     } else if (si.valid_data) {\n-      void * ud;\n-      size_t udsz;\n-      if (dds_qget_userdata(s-\u003Eqos, \u0026ud, \u0026udsz)) {\n-        std::vector\u003Cuint8_t\u003E udvec(static_cast\u003Cuint8_t *\u003E(ud), static_cast\u003Cuint8_t *\u003E(ud) \u002B udsz);\n-        dds_free(ud);\n-        auto map = rmw::impl::cpp::parse_key_value(udvec);\n-        auto name_found = map.find(\u0022enclave\u0022);\n-        if (name_found != map.end()) {\n-          auto enclave =\n-            std::string(name_found-\u003Esecond.begin(), name_found-\u003Esecond.end());\n-          impl-\u003Ecommon.graph_cache.add_participant(gid, enclave);\n-        }\n\u002B      std::string enclave;\n\u002B      if (get_user_data_key(s-\u003Eqos, \u0022enclave\u0022, enclave)) {\n\u002B        impl-\u003Ecommon.graph_cache.add_participant(gid, enclave);\n       }\n     }\n     dds_return_loan(reader, \u0026raw, 1);\n@@ -922,6 \u002B956,7 @@ rmw_context_impl_t::init(rmw_init_options_t * options)\n       \u0022rmw_cyclonedds_cpp\u0022, \u0022rmw_create_node: failed to create DDS participant\u0022);\n     return RMW_RET_ERROR;\n   }\n\u002B  get_entity_gid(this-\u003Eppant, this-\u003Eppant_gid);\n \n   /* Create readers for DDS built-in topics for monitoring discovery */\n   if ((this-\u003Erd_participant =\n@@ -3020,6 \u002B3055,66 @@ extern \u0022C\u0022 rmw_ret_t rmw_wait(\n ///////////                                                                   ///////////\n /////////////////////////////////////////////////////////////////////////////////////////\n \n\u002Busing get_matched_endpoints_fn_t = dds_return_t (*)(\n\u002B  dds_entity_t h,\n\u002B  dds_instance_handle_t * xs, size_t nxs);\n\u002Busing BuiltinTopicEndpoint = std::unique_ptr\u003Cdds_builtintopic_endpoint_t,\n\u002B    std::function\u003Cvoid (dds_builtintopic_endpoint_t *)\u003E\u003E;\n\u002B\n\u002Bstatic rmw_ret_t get_matched_endpoints(\n\u002B  dds_entity_t h, get_matched_endpoints_fn_t fn, std::vector\u003Cdds_instance_handle_t\u003E \u0026 res)\n\u002B{\n\u002B  dds_return_t ret;\n\u002B  if ((ret = fn(h, res.data(), res.size())) \u003C 0) {\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B  while ((size_t) ret \u003E= res.size()) {\n\u002B    // 128 is a completely arbitrary margin to reduce the risk of having to retry\n\u002B    // when matches are create/deleted in parallel\n\u002B    res.resize((size_t) ret \u002B 128);\n\u002B    if ((ret = fn(h, res.data(), res.size())) \u003C 0) {\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B  }\n\u002B  res.resize((size_t) ret);\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n\u002Bstatic void free_builtintopic_endpoint(dds_builtintopic_endpoint_t * e)\n\u002B{\n\u002B  dds_delete_qos(e-\u003Eqos);\n\u002B  dds_free(e-\u003Etopic_name);\n\u002B  dds_free(e-\u003Etype_name);\n\u002B  dds_free(e);\n\u002B}\n\u002B\n\u002Bstatic BuiltinTopicEndpoint get_matched_subscription_data(\n\u002B  dds_entity_t writer, dds_instance_handle_t readerih)\n\u002B{\n\u002B  BuiltinTopicEndpoint ep(dds_get_matched_subscription_data(writer, readerih),\n\u002B    free_builtintopic_endpoint);\n\u002B  return ep;\n\u002B}\n\u002B\n\u002Bstatic BuiltinTopicEndpoint get_matched_publication_data(\n\u002B  dds_entity_t reader, dds_instance_handle_t writerih)\n\u002B{\n\u002B  BuiltinTopicEndpoint ep(dds_get_matched_publication_data(reader, writerih),\n\u002B    free_builtintopic_endpoint);\n\u002B  return ep;\n\u002B}\n\u002B\n\u002Bstatic const std::string csid_to_string(const client_service_id_t \u0026 id)\n\u002B{\n\u002B  std::ostringstream os;\n\u002B  os \u003C\u003C std::hex;\n\u002B  os \u003C\u003C std::setw(2) \u003C\u003C static_cast\u003Cint\u003E(id.data[0]);\n\u002B  for (size_t i = 1; i \u003C sizeof(id.data); i\u002B\u002B) {\n\u002B    os \u003C\u003C \u0022.\u0022 \u003C\u003C static_cast\u003Cint\u003E(id.data[i]);\n\u002B  }\n\u002B  return os.str();\n\u002B}\n\u002B\n static rmw_ret_t rmw_take_response_request(\n   CddsCS * cs, rmw_service_info_t * request_header,\n   void * ros_data, bool * taken, dds_time_t * source_timestamp,\n@@ -3034,9 \u002B3129,16 @@ static rmw_ret_t rmw_take_response_request(\n   void * wrap_ptr = static_cast\u003Cvoid *\u003E(\u0026wrap);\n   while (dds_take(cs-\u003Esub-\u003Eenth, \u0026wrap_ptr, \u0026info, 1, 1) == 1) {\n     if (info.valid_data) {\n-      memset(request_header, 0, sizeof(wrap.header));\n-      assert(sizeof(wrap.header.guid) \u003C= sizeof(request_header-\u003Erequest_id.writer_guid));\n-      memcpy(request_header-\u003Erequest_id.writer_guid, \u0026wrap.header.guid, sizeof(wrap.header.guid));\n\u002B      static_assert(\n\u002B        sizeof(request_header-\u003Erequest_id.writer_guid) ==\n\u002B        sizeof(wrap.header.guid) \u002B sizeof(info.publication_handle),\n\u002B        \u0022request header size assumptions not met\u0022);\n\u002B      memcpy(\n\u002B        static_cast\u003Cvoid *\u003E(request_header-\u003Erequest_id.writer_guid),\n\u002B        static_cast\u003Cconst void *\u003E(\u0026wrap.header.guid), sizeof(wrap.header.guid));\n\u002B      memcpy(\n\u002B        static_cast\u003Cvoid *\u003E(request_header-\u003Erequest_id.writer_guid \u002B sizeof(wrap.header.guid)),\n\u002B        static_cast\u003Cconst void *\u003E(\u0026info.publication_handle), sizeof(info.publication_handle));\n       request_header-\u003Erequest_id.sequence_number = wrap.header.seq;\n       request_header-\u003Esource_timestamp = info.source_timestamp;\n       // TODO(iluetkeb) replace with real received timestamp when available in cyclone\n@@ -3108,7 \u002B3210,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_take_request(\n {\n   RET_WRONG_IMPLID(service);\n   auto info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n-  return rmw_take_response_request(\u0026info-\u003Eservice, request_header, ros_request, taken, nullptr, 0);\n\u002B  return rmw_take_response_request(\n\u002B    \u0026info-\u003Eservice, request_header, ros_request, taken, nullptr,\n\u002B    false);\n }\n \n static rmw_ret_t rmw_send_response_request(\n@@ -3124,6 \u002B3228,56 @@ static rmw_ret_t rmw_send_response_request(\n   }\n }\n \n\u002Benum class client_present_t\n\u002B{\n\u002B  FAILURE,  // an error occurred when checking\n\u002B  MAYBE,    // reader not matched, writer still present\n\u002B  YES,      // reader matched\n\u002B  GONE      // neither reader nor writer\n\u002B};\n\u002B\n\u002Bstatic bool check_client_service_endpoint(\n\u002B  const dds_builtintopic_endpoint_t * ep,\n\u002B  const std::string key, const std::string needle)\n\u002B{\n\u002B  if (ep != nullptr) {\n\u002B    std::string clientid;\n\u002B    get_user_data_key(ep-\u003Eqos, key, clientid);\n\u002B    return clientid == needle;\n\u002B  }\n\u002B  return false;\n\u002B}\n\u002B\n\u002Bstatic client_present_t check_for_response_reader(\n\u002B  const CddsCS \u0026 service,\n\u002B  const dds_instance_handle_t reqwrih)\n\u002B{\n\u002B  auto reqwr = get_matched_publication_data(service.sub-\u003Eenth, reqwrih);\n\u002B  std::string clientid;\n\u002B  if (reqwr == nullptr) {\n\u002B    return client_present_t::GONE;\n\u002B  } else if (!get_user_data_key(reqwr-\u003Eqos, \u0022clientid\u0022, clientid)) {\n\u002B    // backwards-compatibility: a client without a client id, assume all is well\n\u002B    return client_present_t::YES;\n\u002B  } else {\n\u002B    // look for this client\u0027s reader: if we have matched it, all is well;\n\u002B    // if not, continue waiting\n\u002B    std::vector\u003Cdds_instance_handle_t\u003E rds;\n\u002B    if (get_matched_endpoints(service.pub-\u003Eenth, dds_get_matched_subscriptions, rds) \u003C 0) {\n\u002B      RMW_SET_ERROR_MSG(\u0022rmw_send_response: failed to get reader/writer matches\u0022);\n\u002B      return client_present_t::FAILURE;\n\u002B    }\n\u002B    // if we have matched this client\u0027s reader, all is well\n\u002B    for (const auto \u0026 rdih : rds) {\n\u002B      auto rd = get_matched_subscription_data(service.pub-\u003Eenth, rdih);\n\u002B      if (check_client_service_endpoint(rd.get(), \u0022clientid\u0022, clientid)) {\n\u002B        return client_present_t::YES;\n\u002B      }\n\u002B    }\n\u002B    return client_present_t::MAYBE;\n\u002B  }\n\u002B}\n\u002B\n extern \u0022C\u0022 rmw_ret_t rmw_send_response(\n   const rmw_service_t * service,\n   rmw_request_id_t * request_header, void * ros_response)\n@@ -3133,9 \u002B3287,43 @@ extern \u0022C\u0022 rmw_ret_t rmw_send_response(\n   RET_NULL(ros_response);\n   CddsService * info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n   cdds_request_header_t header;\n-  memcpy(\u0026header.guid, request_header-\u003Ewriter_guid, sizeof(header.guid));\n\u002B  dds_instance_handle_t reqwrih;\n\u002B  static_assert(\n\u002B    sizeof(request_header-\u003Ewriter_guid) == sizeof(header.guid) \u002B sizeof(reqwrih),\n\u002B    \u0022request header size assumptions not met\u0022);\n\u002B  memcpy(\n\u002B    static_cast\u003Cvoid *\u003E(\u0026header.guid), static_cast\u003Cconst void *\u003E(request_header-\u003Ewriter_guid),\n\u002B    sizeof(header.guid));\n\u002B  memcpy(\n\u002B    static_cast\u003Cvoid *\u003E(\u0026reqwrih),\n\u002B    static_cast\u003Cconst void *\u003E(request_header-\u003Ewriter_guid \u002B sizeof(header.guid)), sizeof(reqwrih));\n   header.seq = request_header-\u003Esequence_number;\n-  return rmw_send_response_request(\u0026info-\u003Eservice, header, ros_response);\n\u002B  // Block until the response reader has been matched by the response writer (this is a\n\u002B  // workaround: rmw_service_server_is_available should keep returning false until this\n\u002B  // is a given).\n\u002B  // TODO(eboasson): rmw_service_server_is_available should block the request instead (#191)\n\u002B  client_present_t st;\n\u002B  std::chrono::system_clock::time_point tnow = std::chrono::system_clock::now();\n\u002B  std::chrono::system_clock::time_point tend = tnow \u002B 100ms;\n\u002B  while ((st =\n\u002B    check_for_response_reader(\n\u002B      info-\u003Eservice,\n\u002B      reqwrih)) == client_present_t::MAYBE \u0026\u0026 tnow \u003C tend)\n\u002B  {\n\u002B    dds_sleepfor(DDS_MSECS(10));\n\u002B    tnow = std::chrono::system_clock::now();\n\u002B  }\n\u002B  switch (st) {\n\u002B    case client_present_t::FAILURE:\n\u002B      break;\n\u002B    case client_present_t::MAYBE:\n\u002B      return RMW_RET_TIMEOUT;\n\u002B    case client_present_t::YES:\n\u002B      return rmw_send_response_request(\u0026info-\u003Eservice, header, ros_response);\n\u002B    case client_present_t::GONE:\n\u002B      return RMW_RET_OK;\n\u002B  }\n\u002B  return RMW_RET_ERROR;\n }\n \n extern \u0022C\u0022 rmw_ret_t rmw_send_request(\n@@ -3183,6 \u002B3371,31 @@ static const rosidl_service_type_support_t * get_service_typesupport(\n   }\n }\n \n\u002Bstatic void get_unique_csid(const rmw_node_t * node, client_service_id_t \u0026 id)\n\u002B{\n\u002B  auto impl = node-\u003Econtext-\u003Eimpl;\n\u002B  static_assert(\n\u002B    sizeof(dds_guid_t) \u003C= sizeof(id.data),\n\u002B    \u0022client/service id assumed it can hold a DDSI GUID\u0022);\n\u002B  static_assert(\n\u002B    sizeof(dds_guid_t) \u003C= sizeof((reinterpret_cast\u003Crmw_gid_t *\u003E(0))-\u003Edata),\n\u002B    \u0022client/service id assumes rmw_gid_t can hold a DDSI GUID\u0022);\n\u002B  uint32_t x;\n\u002B\n\u002B  {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(impl-\u003Einitialization_mutex);\n\u002B    x = \u002B\u002Bimpl-\u003Eclient_service_id;\n\u002B  }\n\u002B\n\u002B  // construct id by taking the entity prefix (which is just the first 12\n\u002B  // bytes of the GID, which itself is just the GUID padded with 0\u0027s; then\n\u002B  // overwriting the entity id with the big-endian counter value\n\u002B  memcpy(id.data, impl-\u003Eppant_gid.data, 12);\n\u002B  for (size_t i = 0, s = 24; i \u003C 4; i\u002B\u002B, s -= 8) {\n\u002B    id.data[12 \u002B i] = static_cast\u003Cuint8_t\u003E(x \u003E\u003E s);\n\u002B  }\n\u002B}\n\u002B\n static rmw_ret_t rmw_init_cs(\n   CddsCS * cs, const rmw_node_t * node,\n   const rosidl_service_type_support_t * type_supports,\n@@ -3260,6 \u002B3473,16 @@ static rmw_ret_t rmw_init_cs(\n   }\n   dds_qset_reliability(qos, DDS_RELIABILITY_RELIABLE, DDS_SECS(1));\n   dds_qset_history(qos, DDS_HISTORY_KEEP_ALL, DDS_LENGTH_UNLIMITED);\n\u002B\n\u002B  // store a unique identifier for this client/service in the user\n\u002B  // data of the reader and writer so that we can always determine\n\u002B  // which pairs belong together\n\u002B  get_unique_csid(node, cs-\u003Eid);\n\u002B  {\n\u002B    std::string user_data = std::string(is_service ? \u0022serviceid=\u0022 : \u0022clientid=\u0022) \u002B csid_to_string(\n\u002B      cs-\u003Eid) \u002B std::string(\u0022;\u0022);\n\u002B    dds_qset_userdata(qos, user_data.c_str(), user_data.size());\n\u002B  }\n   if ((pub-\u003Eenth = dds_create_writer(node-\u003Econtext-\u003Eimpl-\u003Edds_pub, pubtopic, qos, nullptr)) \u003C 0) {\n     RMW_SET_ERROR_MSG(\u0022failed to create writer\u0022);\n     goto fail_writer;\n@@ -3597,6 \u002B3820,49 @@ static rmw_ret_t get_topic_name(dds_entity_t endpoint_handle, std::string \u0026 name\n   } while (true);\n }\n \n\u002Bstatic rmw_ret_t check_for_service_reader_writer(const CddsCS \u0026 client, bool * is_available)\n\u002B{\n\u002B  std::vector\u003Cdds_instance_handle_t\u003E rds, wrs;\n\u002B  assert(is_available != nullptr \u0026\u0026 !*is_available);\n\u002B  if (get_matched_endpoints(client.pub-\u003Eenth, dds_get_matched_subscriptions, rds) \u003C 0 ||\n\u002B    get_matched_endpoints(client.sub-\u003Eenth, dds_get_matched_publications, wrs) \u003C 0)\n\u002B  {\n\u002B    RMW_SET_ERROR_MSG(\u0022rmw_service_server_is_available: failed to get reader/writer matches\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B  // first extract all service ids from matched readers\n\u002B  std::set\u003Cstd::string\u003E needles;\n\u002B  for (const auto \u0026 rdih : rds) {\n\u002B    auto rd = get_matched_subscription_data(client.pub-\u003Eenth, rdih);\n\u002B    std::string serviceid;\n\u002B    if (rd \u0026\u0026 get_user_data_key(rd-\u003Eqos, \u0022serviceid\u0022, serviceid)) {\n\u002B      needles.insert(serviceid);\n\u002B    }\n\u002B  }\n\u002B  if (needles.empty()) {\n\u002B    // if no services advertising a serviceid have been matched, but there\n\u002B    // are matched request readers and response writers, then we fall back\n\u002B    // to the old method of simply requiring the existence of matches.\n\u002B    *is_available = !rds.empty() \u0026\u0026 !wrs.empty();\n\u002B  } else {\n\u002B    // scan the writers to see if there is at least one response writer\n\u002B    // matching a discovered request reader\n\u002B    for (const auto \u0026 wrih : wrs) {\n\u002B      auto wr = get_matched_publication_data(client.sub-\u003Eenth, wrih);\n\u002B      std::string serviceid;\n\u002B      if (wr \u0026\u0026\n\u002B        get_user_data_key(\n\u002B          wr-\u003Eqos, \u0022serviceid\u0022,\n\u002B          serviceid) \u0026\u0026 needles.find(serviceid) != needles.end())\n\u002B      {\n\u002B        *is_available = true;\n\u002B        break;\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n extern \u0022C\u0022 rmw_ret_t rmw_service_server_is_available(\n   const rmw_node_t * node,\n   const rmw_client_t * client,\n@@ -3630,16 \u002B3896,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_service_server_is_available(\n   if (ret != RMW_RET_OK || 0 == number_of_response_publishers) {\n     return ret;\n   }\n-  dds_publication_matched_status_t ps;\n-  dds_subscription_matched_status_t cs;\n-  if (dds_get_publication_matched_status(info-\u003Eclient.pub-\u003Eenth, \u0026ps) \u003C 0 ||\n-    dds_get_subscription_matched_status(info-\u003Eclient.sub-\u003Eenth, \u0026cs) \u003C 0)\n-  {\n-    RMW_SET_ERROR_MSG(\u0022rmw_service_server_is_available: get_..._matched_status failed\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-  *is_available = ps.current_count \u003E 0 \u0026\u0026 cs.current_count \u003E 0;\n-  return RMW_RET_OK;\n\u002B  return check_for_service_reader_writer(info-\u003Eclient, is_available);\n }\n \n extern \u0022C\u0022 rmw_ret_t rmw_count_publishers(\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "ec81149e75f66d09bf1dd92c3fbb4d9583492ebd",
    "RawMessage": "Mirror rolling to master",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\nnew file mode 100644\nindex 0000000..2885eb4\n--- /dev/null\n\u002B\u002B\u002B .github/workflows/mirror-rolling-to-master.yaml\n@@ -0,0 \u002B1,13 @@\n\u002Bname: Mirror rolling to master\n\u002B\n\u002Bon:\n\u002B  push:\n\u002B    branches: [ rolling ]\n\u002B\n\u002Bjobs:\n\u002B  mirror-to-master:\n\u002B    runs-on: ubuntu-latest\n\u002B    steps:\n\u002B    - uses: zofrex/mirror-branch@v1\n\u002B      with:\n\u002B        target-branch: master\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "020bcd022456ab148dc80bc6b9f30b7d55e1eb65",
    "RawMessage": "Revert raw typesupport patch",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex ee84ed6..bde60e3 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -171,9 \u002B171,7 @@ rmw_create_client(\n   client_info-\u003Eservice_typesupport = type_support;\n   client_info-\u003Esequence_number = 0;\n \n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n   if (request_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\n@@ -186,8 \u002B184,7 @@ rmw_create_client(\n     goto fail;\n   }\n \n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n   if (response_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\ndiff --git rmw_gurumdds_cpp/src/rmw_publisher.cpp rmw_gurumdds_cpp/src/rmw_publisher.cpp\nindex e4bef0c..628fdbe 100644\n--- rmw_gurumdds_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_publisher.cpp\n@@ -159,9 \u002B159,7 @@ rmw_create_publisher(\n     return nullptr;\n   }\n \n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n   if (dds_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex 8c9d0bf..27e62d2 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -162,9 \u002B162,7 @@ rmw_create_service(\n   service_info-\u003Eimplementation_identifier = gurum_gurumdds_identifier;\n   service_info-\u003Eservice_typesupport = type_support;\n \n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, request_metastring.c_str(), typehash);\n-  request_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  request_typesupport = dds_TypeSupport_create(request_metastring.c_str());\n   if (request_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\n@@ -177,8 \u002B175,7 @@ rmw_create_service(\n     goto fail;\n   }\n \n-  dds_DomainParticipant_generate_typehash(participant, response_metastring.c_str(), typehash);\n-  response_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  response_typesupport = dds_TypeSupport_create(response_metastring.c_str());\n   if (response_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex fb0d05a..f9720a2 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -161,9 \u002B161,7 @@ rmw_create_subscription(\n     return nullptr;\n   }\n \n-  uint8_t typehash[16];\n-  dds_DomainParticipant_generate_typehash(participant, metastring.c_str(), typehash);\n-  dds_typesupport = dds_TypeSupport_raw_create_w_typehash(typehash, false);\n\u002B  dds_typesupport = dds_TypeSupport_create(metastring.c_str());\n   if (dds_typesupport == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create typesupport\u0022);\n     goto fail;\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "edd65bfc5fca267c8ec842e8e66c404e5bcb0138",
    "RawMessage": "use int64_t for period. (#1010)",
    "Changes": "diff --git rcl/src/rcl/timer.c rcl/src/rcl/timer.c\nindex 77239fb..e5df59f 100644\n--- rcl/src/rcl/timer.c\n\u002B\u002B\u002B rcl/src/rcl/timer.c\n@@ -38,8 \u002B38,9 @@ struct rcl_timer_impl_s\n   rcl_guard_condition_t guard_condition;\n   // The user supplied callback.\n   atomic_uintptr_t callback;\n-  // This is a duration in nanoseconds.\n-  atomic_uint_least64_t period;\n\u002B  // This is a duration in nanoseconds, which is initialized as int64_t\n\u002B  // to be used for internal time calculation.\n\u002B  atomic_int_least64_t period;\n   // This is a time in nanoseconds since an unspecified time.\n   atomic_int_least64_t last_call_time;\n   // This is a time in nanoseconds since an unspecified time.\n@@ -92,7 \u002B93,7 @@ void _rcl_timer_time_jump(\n     }\n     const int64_t last_call_time = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Elast_call_time);\n     const int64_t next_call_time = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Enext_call_time);\n-    const int64_t period = rcutils_atomic_load_uint64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n\u002B    const int64_t period = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n     if (RCL_ROS_TIME_ACTIVATED == time_jump-\u003Eclock_change ||\n       RCL_ROS_TIME_DEACTIVATED == time_jump-\u003Eclock_change)\n     {\n@@ -264,7 \u002B265,7 @@ rcl_timer_call(rcl_timer_t * timer)\n     (rcl_timer_callback_t)rcutils_atomic_load_uintptr_t(\u0026timer-\u003Eimpl-\u003Ecallback);\n \n   int64_t next_call_time = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Enext_call_time);\n-  int64_t period = rcutils_atomic_load_uint64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n\u002B  int64_t period = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n   // always move the next call time by exactly period forward\n   // don\u0027t use now as the base to avoid extending each cycle by the time\n   // between the timer being ready and the callback being triggered\n@@ -352,7 \u002B353,7 @@ rcl_timer_get_period(const rcl_timer_t * timer, int64_t * period)\n   RCL_CHECK_ARGUMENT_FOR_NULL(timer, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(timer-\u003Eimpl, RCL_RET_TIMER_INVALID);\n   RCL_CHECK_ARGUMENT_FOR_NULL(period, RCL_RET_INVALID_ARGUMENT);\n-  *period = rcutils_atomic_load_uint64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n\u002B  *period = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n   return RCL_RET_OK;\n }\n \n@@ -364,7 \u002B365,7 @@ rcl_timer_exchange_period(const rcl_timer_t * timer, int64_t new_period, int64_t\n   RCL_CHECK_ARGUMENT_FOR_NULL(timer, RCL_RET_INVALID_ARGUMENT);\n   RCL_CHECK_ARGUMENT_FOR_NULL(timer-\u003Eimpl, RCL_RET_TIMER_INVALID);\n   RCL_CHECK_ARGUMENT_FOR_NULL(old_period, RCL_RET_INVALID_ARGUMENT);\n-  *old_period = rcutils_atomic_exchange_uint64_t(\u0026timer-\u003Eimpl-\u003Eperiod, new_period);\n\u002B  *old_period = rcutils_atomic_exchange_int64_t(\u0026timer-\u003Eimpl-\u003Eperiod, new_period);\n   RCUTILS_LOG_DEBUG_NAMED(\n     ROS_PACKAGE_NAME, \u0022Updated timer period from \u0027%\u0022 PRIu64 \u0022ns\u0027 to \u0027%\u0022 PRIu64 \u0022ns\u0027\u0022,\n     *old_period, new_period);\n@@ -424,7 \u002B425,7 @@ rcl_timer_reset(rcl_timer_t * timer)\n   if (now_ret != RCL_RET_OK) {\n     return now_ret;  // rcl error state should already be set.\n   }\n-  int64_t period = rcutils_atomic_load_uint64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n\u002B  int64_t period = rcutils_atomic_load_int64_t(\u0026timer-\u003Eimpl-\u003Eperiod);\n   rcutils_atomic_store(\u0026timer-\u003Eimpl-\u003Enext_call_time, now \u002B period);\n   rcutils_atomic_store(\u0026timer-\u003Eimpl-\u003Ecanceled, false);\n   rcl_ret_t ret = rcl_trigger_guard_condition(\u0026timer-\u003Eimpl-\u003Eguard_condition);\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "62e86b90ad3e67e84c660c11e894fe4ab9b11e41",
    "RawMessage": "Check if the queue is empty before using it",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_request.cpp rmw_gurumdds_cpp/src/rmw_request.cpp\nindex b24c847..5881c58 100644\n--- rmw_gurumdds_cpp/src/rmw_request.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_request.cpp\n@@ -155,6 \u002B155,10 @@ rmw_take_request(\n     return RMW_RET_ERROR;\n   }\n \n\u002B  if (service_info-\u003Emessage_queue.empty()) {\n\u002B    return RMW_RET_OK;\n\u002B  }\n\u002B\n   service_info-\u003Equeue_mutex.lock();\n   auto msg = service_info-\u003Emessage_queue.front();\n   service_info-\u003Emessage_queue.pop();\ndiff --git rmw_gurumdds_cpp/src/rmw_response.cpp rmw_gurumdds_cpp/src/rmw_response.cpp\nindex 8ed52bb..acf9cd0 100644\n--- rmw_gurumdds_cpp/src/rmw_response.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_response.cpp\n@@ -74,6 \u002B74,10 @@ rmw_take_response(\n     return RMW_RET_ERROR;\n   }\n \n\u002B  if (client_info-\u003Emessage_queue.empty()) {\n\u002B    return RMW_RET_OK;\n\u002B  }\n\u002B\n   client_info-\u003Equeue_mutex.lock();\n   auto msg = client_info-\u003Emessage_queue.front();\n   client_info-\u003Emessage_queue.pop();\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "9b1e6c9d520f09338b789058571c63d283a5c128",
    "RawMessage": "Only compile the tests once. (#2590)",
    "Changes": "diff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex b171b215..756e1c67 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -99,17 \u002B99,6 @@ ament_add_gtest(test_create_subscription test_create_subscription.cpp)\n if(TARGET test_create_subscription)\n   target_link_libraries(test_create_subscription ${PROJECT_NAME} ${test_msgs_TARGETS})\n endif()\n-function(test_add_callback_groups_to_executor_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_add_callback_groups_to_executor${target_suffix} test_add_callback_groups_to_executor.cpp\n-    ENV ${rmw_implementation_env_var}\n-    TIMEOUT 120\n-  )\n-  if(TARGET test_add_callback_groups_to_executor${target_suffix})\n-    target_link_libraries(test_add_callback_groups_to_executor${target_suffix} ${PROJECT_NAME} ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_add_callback_groups_to_executor_for_rmw_implementation)\n ament_add_gtest(test_expand_topic_or_service_name test_expand_topic_or_service_name.cpp)\n ament_add_test_label(test_expand_topic_or_service_name mimick)\n if(TARGET test_expand_topic_or_service_name)\n@@ -337,28 \u002B326,6 @@ if(TARGET test_qos)\n     rmw::rmw\n   )\n endif()\n-function(test_generic_pubsub_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_generic_pubsub${target_suffix} test_generic_pubsub.cpp\n-    ENV ${rmw_implementation_env_var}\n-  )\n-  if(TARGET test_generic_pubsub${target_suffix})\n-    target_link_libraries(test_generic_pubsub${target_suffix} ${PROJECT_NAME} rcl::rcl ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_generic_pubsub_for_rmw_implementation)\n-\n-function(test_qos_event_for_rmw_implementation)\n-  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_qos_event${target_suffix} test_qos_event.cpp\n-    ENV ${rmw_implementation_env_var}\n-  )\n-  ament_add_test_label(test_qos_event${target_suffix} mimick)\n-  if(TARGET test_qos_event${target_suffix})\n-    target_link_libraries(test_qos_event${target_suffix} ${PROJECT_NAME} mimick rcutils::rcutils rmw::rmw ${test_msgs_TARGETS})\n-  endif()\n-endfunction()\n-call_for_each_rmw_implementation(test_qos_event_for_rmw_implementation)\n \n ament_add_gmock(test_qos_overriding_options test_qos_overriding_options.cpp)\n if(TARGET test_qos_overriding_options)\n@@ -650,16 \u002B617,51 @@ if(TARGET test_graph_listener)\n   target_link_libraries(test_graph_listener ${PROJECT_NAME} mimick)\n endif()\n \n-function(test_subscription_content_filter_for_rmw_implementation)\n\u002Bament_add_gmock_executable(test_qos_event test_qos_event.cpp)\n\u002Bif(TARGET test_qos_event)\n\u002B  target_link_libraries(test_qos_event ${PROJECT_NAME} mimick rcutils::rcutils rmw::rmw ${test_msgs_TARGETS})\n\u002Bendif()\n\u002B\n\u002Bament_add_gmock_executable(test_generic_pubsub test_generic_pubsub.cpp)\n\u002Bif(TARGET test_generic_pubsub)\n\u002B  target_link_libraries(test_generic_pubsub ${PROJECT_NAME} rcl::rcl ${test_msgs_TARGETS})\n\u002Bendif()\n\u002B\n\u002Bament_add_gmock_executable(test_add_callback_groups_to_executor test_add_callback_groups_to_executor.cpp)\n\u002Bif(TARGET test_add_callback_groups_to_executor)\n\u002B  target_link_libraries(test_add_callback_groups_to_executor ${PROJECT_NAME} ${test_msgs_TARGETS})\n\u002Bendif()\n\u002B\n\u002Bament_add_gmock_executable(test_subscription_content_filter test_subscription_content_filter.cpp)\n\u002Bif(TARGET test_subscription_content_filter)\n\u002B  target_link_libraries(test_subscription_content_filter ${PROJECT_NAME} mimick ${test_msgs_TARGETS})\n\u002Bendif()\n\u002B\n\u002Bfunction(test_on_all_rmws)\n   set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n-  ament_add_gmock(test_subscription_content_filter${target_suffix}\n-    test_subscription_content_filter.cpp\n\u002B\n\u002B  ament_add_gmock_test(test_qos_event\n\u002B    TEST_NAME test_qos_event${target_suffix}\n\u002B    ENV ${rmw_implementation_env_var}\n\u002B  )\n\u002B  ament_add_test_label(test_qos_event${target_suffix} mimick)\n\u002B\n\u002B  ament_add_gmock_test(test_generic_pubsub\n\u002B    TEST_NAME test_generic_pubsub${target_suffix}\n\u002B    ENV ${rmw_implementation_env_var}\n\u002B  )\n\u002B\n\u002B  ament_add_gmock_test(test_add_callback_groups_to_executor\n\u002B    TEST_NAME test_add_callback_groups_to_executor${target_suffix}\n\u002B    ENV ${rmw_implementation_env_var}\n\u002B    TIMEOUT 120\n\u002B  )\n\u002B\n\u002B  ament_add_gmock_test(test_subscription_content_filter\n\u002B    TEST_NAME test_subscription_content_filter${target_suffix}\n     ENV ${rmw_implementation_env_var}\n     TIMEOUT 120\n   )\n   ament_add_test_label(test_subscription_content_filter${target_suffix} mimick)\n-  if(TARGET test_subscription_content_filter${target_suffix})\n-    target_link_libraries(test_subscription_content_filter${target_suffix} ${PROJECT_NAME} mimick ${test_msgs_TARGETS})\n-  endif()\n endfunction()\n-call_for_each_rmw_implementation(test_subscription_content_filter_for_rmw_implementation)\n\u002Bcall_for_each_rmw_implementation(test_on_all_rmws)\ndiff --git rclcpp/test/rclcpp/test_subscription_content_filter.cpp rclcpp/test/rclcpp/test_subscription_content_filter.cpp\nindex 372af036..4b8baf4a 100644\n--- rclcpp/test/rclcpp/test_subscription_content_filter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_content_filter.cpp\n@@ -30,14 \u002B30,7 @@\n \n #include \u0022test_msgs/msg/basic_types.hpp\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n-class CLASSNAME (TestContentFilterSubscription, RMW_IMPLEMENTATION) : public ::testing::Test\n\u002Bclass TestContentFilterSubscription : public ::testing::Test\n {\n public:\n   static void SetUpTestCase()\n@@ -113,7 \u002B106,8 @@ bool operator==(const test_msgs::msg::BasicTypes \u0026 m1, const test_msgs::msg::Bas\n          m1.uint64_value == m2.uint64_value;\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), is_cft_enabled) {\n\u002BTEST_F(TestContentFilterSubscription, is_cft_enabled)\n\u002B{\n   {\n     auto mock = mocking_utils::patch_and_return(\n       \u0022lib:rclcpp\u0022, rcl_subscription_is_cft_enabled, false);\n@@ -127,7 \u002B121,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), is_cft_enab\n   }\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content_filter_error) {\n\u002BTEST_F(TestContentFilterSubscription, get_content_filter_error)\n\u002B{\n   auto mock = mocking_utils::patch_and_return(\n     \u0022lib:rclcpp\u0022, rcl_subscription_get_content_filter, RCL_RET_ERROR);\n \n@@ -137,7 \u002B132,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content\n     rclcpp::exceptions::RCLError);\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content_filter_error) {\n\u002BTEST_F(TestContentFilterSubscription, set_content_filter_error)\n\u002B{\n   auto mock = mocking_utils::patch_and_return(\n     \u0022lib:rclcpp\u0022, rcl_subscription_set_content_filter, RCL_RET_ERROR);\n \n@@ -148,7 \u002B144,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content\n     rclcpp::exceptions::RCLError);\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content_filter) {\n\u002BTEST_F(TestContentFilterSubscription, get_content_filter)\n\u002B{\n   rclcpp::ContentFilterOptions options;\n \n   if (sub-\u003Eis_cft_enabled()) {\n@@ -164,7 \u002B161,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), get_content\n   }\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content_filter) {\n\u002BTEST_F(TestContentFilterSubscription, set_content_filter)\n\u002B{\n   if (sub-\u003Eis_cft_enabled()) {\n     EXPECT_NO_THROW(\n       sub-\u003Eset_content_filter(filter_expression_init, expression_parameters_2));\n@@ -175,7 \u002B173,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), set_content\n   }\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_get_begin) {\n\u002BTEST_F(TestContentFilterSubscription, content_filter_get_begin)\n\u002B{\n   using namespace std::chrono_literals;\n   {\n     test_msgs::msg::BasicTypes msg;\n@@ -217,7 \u002B216,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_fil\n   }\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_get_later) {\n\u002BTEST_F(TestContentFilterSubscription, content_filter_get_later)\n\u002B{\n   using namespace std::chrono_literals;\n   {\n     test_msgs::msg::BasicTypes msg;\n@@ -264,7 \u002B264,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_fil\n   }\n }\n \n-TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_filter_reset) {\n\u002BTEST_F(TestContentFilterSubscription, content_filter_reset)\n\u002B{\n   using namespace std::chrono_literals;\n   {\n     test_msgs::msg::BasicTypes msg;\n@@ -311,11 \u002B312,8 @@ TEST_F(CLASSNAME(TestContentFilterSubscription, RMW_IMPLEMENTATION), content_fil\n   }\n }\n \n-TEST_F(\n-  CLASSNAME(\n-    TestContentFilterSubscription,\n-    RMW_IMPLEMENTATION), create_two_content_filters_with_same_topic_name_and_destroy) {\n-\n\u002BTEST_F(TestContentFilterSubscription, create_two_content_filters_with_same_topic_name_and_destroy)\n\u002B{\n   // Create another content filter\n   auto options = rclcpp::SubscriptionOptions();\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "ab75a166b5d08883dae8d7da50e64c422accf882",
    "RawMessage": "Add init options API test coverage. (#108)",
    "Changes": "diff --git test_rmw_implementation/CMakeLists.txt test_rmw_implementation/CMakeLists.txt\nindex 14ad1ba..49695af 100644\n--- test_rmw_implementation/CMakeLists.txt\n\u002B\u002B\u002B test_rmw_implementation/CMakeLists.txt\n@@ -36,6 \u002B36,16 @@ if(BUILD_TESTING)\n     ament_target_dependencies(test_init_shutdown${target_suffix}\n       osrf_testing_tools_cpp rcutils rmw rmw_implementation\n     )\n\u002B\n\u002B    ament_add_gtest(test_init_options${target_suffix}\n\u002B      test/test_init_options.cpp\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n\u002B    target_compile_definitions(test_init_options${target_suffix}\n\u002B      PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n\u002B    ament_target_dependencies(test_init_options${target_suffix}\n\u002B      osrf_testing_tools_cpp rcutils rmw rmw_implementation\n\u002B    )\n   endmacro()\n \n   call_for_each_rmw_implementation(test_api)\ndiff --git test_rmw_implementation/test/allocator_testing_utils.h test_rmw_implementation/test/allocator_testing_utils.h\nnew file mode 100644\nindex 0000000..786b2f7\n--- /dev/null\n\u002B\u002B\u002B test_rmw_implementation/test/allocator_testing_utils.h\n@@ -0,0 \u002B1,94 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef ALLOCATOR_TESTING_UTILS_H_\n\u002B#define ALLOCATOR_TESTING_UTILS_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B#include \u003Cstddef.h\u003E\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B\n\u002Btypedef struct __failing_allocator_state\n\u002B{\n\u002B  bool is_failing;\n\u002B} __failing_allocator_state;\n\u002B\n\u002Bvoid *\n\u002Bfailing_malloc(size_t size, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().allocate(size, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid *\n\u002Bfailing_realloc(void * pointer, size_t size, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().reallocate(\n\u002B    pointer, size, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bfailing_free(void * pointer, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return;\n\u002B  }\n\u002B  rcutils_get_default_allocator().deallocate(pointer, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid *\n\u002Bfailing_calloc(size_t number_of_elements, size_t size_of_element, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().zero_allocate(\n\u002B    number_of_elements, size_of_element, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bstatic inline rcutils_allocator_t\n\u002Bget_failing_allocator(void)\n\u002B{\n\u002B  static __failing_allocator_state state;\n\u002B  state.is_failing = true;\n\u002B  auto failing_allocator = rcutils_get_default_allocator();\n\u002B  failing_allocator.allocate = failing_malloc;\n\u002B  failing_allocator.deallocate = failing_free;\n\u002B  failing_allocator.reallocate = failing_realloc;\n\u002B  failing_allocator.zero_allocate = failing_calloc;\n\u002B  failing_allocator.state = \u0026state;\n\u002B  return failing_allocator;\n\u002B}\n\u002B\n\u002Bstatic inline void\n\u002Bset_failing_allocator_is_failing(rcutils_allocator_t \u0026 failing_allocator, bool state)\n\u002B{\n\u002B  ((__failing_allocator_state *)failing_allocator.state)-\u003Eis_failing = state;\n\u002B}\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // ALLOCATOR_TESTING_UTILS_H_\ndiff --git test_rmw_implementation/test/test_init_options.cpp test_rmw_implementation/test/test_init_options.cpp\nnew file mode 100644\nindex 0000000..ec976d7\n--- /dev/null\n\u002B\u002B\u002B test_rmw_implementation/test/test_init_options.cpp\n@@ -0,0 \u002B1,149 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B\n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B\n\u002B#include \u0022./allocator_testing_utils.h\u0022\n\u002B\n\u002B#ifdef RMW_IMPLEMENTATION\n\u002B# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n\u002B# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n\u002B#else\n\u002B# define CLASSNAME(NAME, SUFFIX) NAME\n\u002B#endif\n\u002B\n\u002Bclass CLASSNAME (TestInitOptions, RMW_IMPLEMENTATION) : public ::testing::Test {};\n\u002B\n\u002BTEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), init_copy_fini) {\n\u002B  rmw_init_options_t src_options = rmw_get_zero_initialized_init_options();\n\u002B  rmw_ret_t ret = rmw_init_options_init(\u0026src_options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  // Initializing twice fails.\n\u002B  ret = rmw_init_options_init(\u0026src_options, rcutils_get_default_allocator());\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  rmw_init_options_t dst_options = rmw_get_zero_initialized_init_options();\n\u002B  ret = rmw_init_options_copy(\u0026src_options, \u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  // Copying twice fails.\n\u002B  ret = rmw_init_options_copy(\u0026src_options, \u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_fini(\u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  ret = rmw_init_options_fini(\u0026src_options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  // Finalizing twice fails.\n\u002B  ret = rmw_init_options_fini(\u0026src_options);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), init_with_bad_arguments) {\n\u002B  rmw_init_options_t options = rmw_get_zero_initialized_init_options();\n\u002B  rmw_ret_t ret = rmw_init_options_init(\u0026options, rcutils_get_zero_initialized_allocator());\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_init(nullptr, rcutils_get_default_allocator());\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  // Initialization and finalization should still succeed.\n\u002B  ret = rmw_init_options_init(\u0026options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  ret = rmw_init_options_fini(\u0026options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), copy_with_bad_arguments) {\n\u002B  rmw_init_options_t src_options = rmw_get_zero_initialized_init_options();\n\u002B  rmw_init_options_t dst_options = rmw_get_zero_initialized_init_options();\n\u002B\n\u002B  rmw_ret_t ret = rmw_init_options_copy(nullptr, \u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_copy(\u0026src_options, nullptr);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_copy(\u0026src_options, \u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_init(\u0026src_options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    rmw_ret_t ret = rmw_init_options_fini(\u0026src_options);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  const char * implementation_identifier = src_options.implementation_identifier;\n\u002B  src_options.implementation_identifier = \u0022not-an-rmw-implementation-identifier\u0022;\n\u002B  ret = rmw_init_options_copy(\u0026src_options, \u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n\u002B  src_options.implementation_identifier = implementation_identifier;\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  // Initialization and finalization should still succeed.\n\u002B  ret = rmw_init_options_init(\u0026dst_options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  ret = rmw_init_options_fini(\u0026dst_options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestInitOptions, RMW_IMPLEMENTATION), fini_with_bad_arguments) {\n\u002B  rmw_init_options_t options = rmw_get_zero_initialized_init_options();\n\u002B  rmw_ret_t ret = rmw_init_options_fini(\u0026options);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_fini(nullptr);\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, ret);\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_init(\u0026options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  const char * implementation_identifier = options.implementation_identifier;\n\u002B  options.implementation_identifier = \u0022not-an-rmw-implementation-identifier\u0022;\n\u002B  ret = rmw_init_options_fini(\u0026options);\n\u002B  EXPECT_EQ(RMW_RET_INCORRECT_RMW_IMPLEMENTATION, ret);\n\u002B  options.implementation_identifier = implementation_identifier;\n\u002B  rcutils_reset_error();\n\u002B\n\u002B  ret = rmw_init_options_fini(\u0026options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B\n\u002B  // Initialization and finalization should still succeed.\n\u002B  ret = rmw_init_options_init(\u0026options, rcutils_get_default_allocator());\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B  ret = rmw_init_options_fini(\u0026options);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "f338416b76049e79ada9aa00e41ea52137e35029",
    "RawMessage": "Add types to wait_for_message.py and moves Handles into type stubs (#1325)",
    "Changes": "diff --git rclpy/rclpy/clock.py rclpy/rclpy/clock.py\nindex 712ae4f..3b9f363 100644\n--- rclpy/rclpy/clock.py\n\u002B\u002B\u002B rclpy/rclpy/clock.py\n@@ -14,16 \u002B14,15 @@\n \n from enum import IntEnum\n from types import TracebackType\n-from typing import Callable, Optional, Protocol, Type, TYPE_CHECKING, TypedDict\n\u002Bfrom typing import Callable, Optional, Type, TYPE_CHECKING, TypedDict\n \n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n \n from .clock_type import ClockType\n from .context import Context\n-from .destroyable import DestroyableType\n from .duration import Duration\n from .exceptions import NotInitializedException\n-from .time import Time, TimeHandle\n\u002Bfrom .time import Time\n from .utilities import get_default_context\n \n \n@@ -146,39 \u002B145,10 @@ class JumpHandle:\n         self.unregister()\n \n \n-class ClockHandle(DestroyableType, Protocol):\n-    \u0022\u0022\u0022Generic alias of _rclpy.Clock.\u0022\u0022\u0022\n-\n-    def get_now(self) -\u003E TimeHandle:\n-        \u0022\u0022\u0022Value of the clock.\u0022\u0022\u0022\n-        ...\n-\n-    def get_ros_time_override_is_enabled(self) -\u003E bool:\n-        \u0022\u0022\u0022Return if a clock using ROS time has the ROS time override enabled.\u0022\u0022\u0022\n-        ...\n-\n-    def set_ros_time_override_is_enabled(self, enabled: bool) -\u003E None:\n-        \u0022\u0022\u0022Set if a clock using ROS time has the ROS time override enabled.\u0022\u0022\u0022\n-        ...\n-\n-    def set_ros_time_override(self, time_point: TimeHandle) -\u003E None:\n-        \u0022\u0022\u0022Set the ROS time override for a clock using ROS time.\u0022\u0022\u0022\n-        ...\n-\n-    def add_clock_callback(self, pyjump_handle: JumpHandle,\n-                           on_clock_change: bool, min_forward: int, min_backward: int) -\u003E None:\n-        \u0022\u0022\u0022Add a time jump callback to a clock.\u0022\u0022\u0022\n-        ...\n-\n-    def remove_clock_callback(self, pyjump_handle: JumpHandle) -\u003E None:\n-        \u0022\u0022\u0022Remove a time jump callback from a clock.\u0022\u0022\u0022\n-        ...\n-\n-\n class Clock:\n \n     if TYPE_CHECKING:\n-        __clock: ClockHandle\n\u002B        __clock: _rclpy.Clock\n         _clock_type: ClockType\n \n     def __new__(cls, *,\n@@ -198,7 \u002B168,7 @@ class Clock:\n         return self._clock_type\n \n     @property\n-    def handle(self) -\u003E ClockHandle:\n\u002B    def handle(self) -\u003E _rclpy.Clock:\n         \u0022\u0022\u0022\n         Return the internal instance of \u0060\u0060rclpy::Clock\u0060\u0060.\n \ndiff --git rclpy/rclpy/context.py rclpy/rclpy/context.py\nindex 5563b09..9919867 100644\n--- rclpy/rclpy/context.py\n\u002B\u002B\u002B rclpy/rclpy/context.py\n@@ -20,31 \u002B20,17 @@ from typing import Callable\n from typing import ContextManager\n from typing import List\n from typing import Optional\n-from typing import Protocol\n from typing import Type\n from typing import TYPE_CHECKING\n from typing import Union\n import warnings\n import weakref\n \n-from rclpy.destroyable import DestroyableType\n\u002Bfrom rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n \n if TYPE_CHECKING:\n     from rclpy.node import Node\n \n-\n-class ContextHandle(DestroyableType, Protocol):\n-\n-    def ok(self) -\u003E bool:\n-        ...\n-\n-    def get_domain_id(self) -\u003E int:\n-        ...\n-\n-    def shutdown(self) -\u003E None:\n-        ...\n-\n-\n g_logging_configure_lock = threading.Lock()\n g_logging_ref_count: int = 0\n \n@@ -68,11 \u002B54,11 @@ class Context(ContextManager[\u0027Context\u0027]):\n         self._lock = threading.RLock()\n         self._callbacks: List[Union[\u0027weakref.WeakMethod[MethodType]\u0027, Callable[[], None]]] = []\n         self._logging_initialized = False\n-        self.__context: Optional[ContextHandle] = None\n\u002B        self.__context: Optional[_rclpy.Context] = None\n         self.__node_weak_ref_list: List[weakref.ReferenceType[\u0027Node\u0027]] = []\n \n     @property\n-    def handle(self) -\u003E Optional[ContextHandle]:\n\u002B    def handle(self) -\u003E Optional[_rclpy.Context]:\n         return self.__context\n \n     def destroy(self) -\u003E None:\ndiff --git rclpy/rclpy/destroyable.py rclpy/rclpy/destroyable.py\ndeleted file mode 100644\nindex 8c05792..0000000\n--- rclpy/rclpy/destroyable.py\n\u002B\u002B\u002B /dev/null\n@@ -1,29 \u002B0,0 @@\n-# Copyright 2024 Open Source Robotics Foundation, Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-from types import TracebackType\n-from typing import Optional, Protocol, Type\n-\n-\n-class DestroyableType(Protocol):\n-\n-    def __enter__(self) -\u003E None:\n-        ...\n-\n-    def __exit__(self, exc_type: Optional[Type[BaseException]],\n-                 exc_val: Optional[BaseException], exctb: Optional[TracebackType]) -\u003E None:\n-        ...\n-\n-    def destroy_when_not_in_use(self) -\u003E None:\n-        ...\ndiff --git rclpy/rclpy/duration.py rclpy/rclpy/duration.py\nindex c3356cb..ac4655b 100644\n--- rclpy/rclpy/duration.py\n\u002B\u002B\u002B rclpy/rclpy/duration.py\n@@ -12,19 \u002B12,13 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Protocol, Union\n\u002Bfrom typing import Union\n \n import builtin_interfaces.msg\n from rclpy.constants import S_TO_NS\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n \n \n-class DurationHandle(Protocol):\n-    \u0022\u0022\u0022Type alias of _rclpy.rcl_duration_t.\u0022\u0022\u0022\n-\n-    nanoseconds: int\n-\n-\n class Duration:\n     \u0022\u0022\u0022A period between two time points, with nanosecond precision.\u0022\u0022\u0022\n \n@@ -41,7 \u002B35,7 @@ class Duration:\n             # pybind11 would raise TypeError, but we want OverflowError\n             raise OverflowError(\n                 \u0027Total nanoseconds value is too large to store in C duration.\u0027)\n-        self._duration_handle: DurationHandle = _rclpy.rcl_duration_t(total_nanoseconds)\n\u002B        self._duration_handle = _rclpy.rcl_duration_t(total_nanoseconds)\n \n     @property\n     def nanoseconds(self) -\u003E int:\n@@ -106,7 \u002B100,7 @@ class Duration:\n             raise TypeError(\u0027Must pass a builtin_interfaces.msg.Duration object\u0027)\n         return cls(seconds=msg.sec, nanoseconds=msg.nanosec)\n \n-    def get_c_duration(self) -\u003E DurationHandle:\n\u002B    def get_c_duration(self) -\u003E _rclpy.rcl_duration_t:\n         return self._duration_handle\n \n \ndiff --git rclpy/rclpy/event_handler.py rclpy/rclpy/event_handler.py\nindex 427313c..e846b91 100644\n--- rclpy/rclpy/event_handler.py\n\u002B\u002B\u002B rclpy/rclpy/event_handler.py\n@@ -32,10 \u002B32,6 @@ if TYPE_CHECKING:\n     from typing import TypeAlias\n \n \n-if TYPE_CHECKING:\n-    from rclpy.subscription import SubscriptionHandle\n-\n-\n QoSPublisherEventType = _rclpy.rcl_publisher_event_type_t\n QoSSubscriptionEventType = _rclpy.rcl_subscription_event_type_t\n \n@@ -201,7 \u002B197,7 @@ class SubscriptionEventCallbacks:\n         self.use_default_callbacks = use_default_callbacks\n \n     def create_event_handlers(\n-        self, callback_group: CallbackGroup, subscription: \u0027SubscriptionHandle\u0027,\n\u002B        self, callback_group: CallbackGroup, subscription: \u0027_rclpy.Subscription\u0027,\n             topic_name: str) -\u003E List[EventHandler]:\n         with subscription:\n             logger = get_logger(subscription.get_logger_name())\ndiff --git rclpy/rclpy/guard_condition.py rclpy/rclpy/guard_condition.py\nindex fb36923..416cf18 100644\n--- rclpy/rclpy/guard_condition.py\n\u002B\u002B\u002B rclpy/rclpy/guard_condition.py\n@@ -12,21 \u002B12,14 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Callable, Optional, Protocol\n\u002Bfrom typing import Callable, Optional\n \n from rclpy.callback_groups import CallbackGroup\n from rclpy.context import Context\n-from rclpy.destroyable import DestroyableType\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.utilities import get_default_context\n \n \n-class GuardConditionHandle(DestroyableType, Protocol):\n-\n-    def trigger_guard_condition(self) -\u003E None:\n-        ...\n-\n-\n class GuardCondition:\n \n     def __init__(self, callback: Optional[Callable],\n@@ -44,7 \u002B37,7 @@ class GuardCondition:\n             raise RuntimeError(\u0027Context must be initialized a GuardCondition can be created\u0027)\n \n         with self._context.handle:\n-            self.__gc: GuardConditionHandle = _rclpy.GuardCondition(self._context.handle)\n\u002B            self.__gc = _rclpy.GuardCondition(self._context.handle)\n         self.callback = callback\n         self.callback_group = callback_group\n         # True when the callback is ready to fire but has not been \u0022taken\u0022 by an executor\n@@ -57,7 \u002B50,7 @@ class GuardCondition:\n             self.__gc.trigger_guard_condition()\n \n     @property\n-    def handle(self) -\u003E GuardConditionHandle:\n\u002B    def handle(self) -\u003E _rclpy.GuardCondition:\n         return self.__gc\n \n     def destroy(self) -\u003E None:\ndiff --git rclpy/rclpy/impl/_rclpy_pybind11.pyi rclpy/rclpy/impl/_rclpy_pybind11.pyi\nindex df259e4..75427df 100644\n--- rclpy/rclpy/impl/_rclpy_pybind11.pyi\n\u002B\u002B\u002B rclpy/rclpy/impl/_rclpy_pybind11.pyi\n@@ -12,11 \u002B12,324 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Sequence\n\u002Bfrom __future__ import annotations\n \n\u002Bfrom enum import IntEnum\n\u002Bfrom types import TracebackType\n\u002Bfrom typing import Any, Generic, Literal, overload, Sequence, TypedDict\n \n-def rclpy_remove_ros_args(pycli_args: Sequence[str]) -\u003E list[str]: ...\n-\u0022\u0022\u0022Remove ROS-specific arguments from argument vector.\u0022\u0022\u0022\n\u002Bfrom rclpy.clock import JumpHandle\n\u002Bfrom rclpy.clock_type import ClockType\n\u002Bfrom rclpy.qos import (QoSDurabilityPolicy, QoSHistoryPolicy, QoSLivelinessPolicy,\n\u002B                       QoSReliabilityPolicy)\n\u002Bfrom rclpy.subscription import MessageInfo\n\u002Bfrom rclpy.type_support import MsgT\n \n-def rclpy_get_rmw_implementation_identifier() -\u003E str: ...\n-\u0022\u0022\u0022Retrieve the identifier for the active RMW implementation.\u0022\u0022\u0022\n\u002B\n\u002Bdef rclpy_remove_ros_args(pycli_args: Sequence[str]) -\u003E list[str]:\n\u002B    \u0022\u0022\u0022Remove ROS-specific arguments from argument vector.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bdef rclpy_get_rmw_implementation_identifier() -\u003E str:\n\u002B    \u0022\u0022\u0022Retrieve the identifier for the active RMW implementation.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass Client:\n\u002B    pass\n\u002B\n\u002B\n\u002Bclass rcl_time_point_t:\n\u002B    nanoseconds: int\n\u002B    clock_type: ClockType\n\u002B\n\u002B\n\u002Bclass Destroyable:\n\u002B\n\u002B    def __enter__(self) -\u003E None: ...\n\u002B\n\u002B    def __exit__(self, exc_type: type[BaseException] | None,\n\u002B                 exc_val: BaseException | None, exctb: TracebackType | None) -\u003E None: ...\n\u002B\n\u002B    def destroy_when_not_in_use(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Destroy the rcl object as soon as it\u0027s not actively being used.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass Clock(Destroyable):\n\u002B\n\u002B    def __init__(self, clock_type: int) -\u003E None: ...\n\u002B\n\u002B    def get_now(self) -\u003E rcl_time_point_t:\n\u002B        \u0022\u0022\u0022Value of the clock.\u0022\u0022\u0022\n\u002B\n\u002B    def get_ros_time_override_is_enabled(self) -\u003E bool:\n\u002B        \u0022\u0022\u0022Return if a clock using ROS time has the ROS time override enabled.\u0022\u0022\u0022\n\u002B\n\u002B    def set_ros_time_override_is_enabled(self, enabled: bool) -\u003E None:\n\u002B        \u0022\u0022\u0022Set if a clock using ROS time has the ROS time override enabled.\u0022\u0022\u0022\n\u002B\n\u002B    def set_ros_time_override(self, time_point: rcl_time_point_t) -\u003E None:\n\u002B        \u0022\u0022\u0022Set the ROS time override for a clock using ROS time.\u0022\u0022\u0022\n\u002B\n\u002B    def add_clock_callback(self, pyjump_handle: JumpHandle,\n\u002B                           on_clock_change: bool, min_forward: int,\n\u002B                           min_backward: int) -\u003E None:\n\u002B        \u0022\u0022\u0022Add a time jump callback to a clock.\u0022\u0022\u0022\n\u002B\n\u002B    def remove_clock_callback(self, pyjump_handle: JumpHandle) -\u003E None:\n\u002B        \u0022\u0022\u0022Remove a time jump callback from a clock.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass Context(Destroyable):\n\u002B\n\u002B    def __init__(self, pyargs: list[str], domain_id: int) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def get_domain_id(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Retrieve domain id from init_options of context.\u0022\u0022\u0022\n\u002B\n\u002B    def ok(self) -\u003E bool:\n\u002B        \u0022\u0022\u0022Status of the the client library.\u0022\u0022\u0022\n\u002B\n\u002B    def shutdown(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Shutdown context.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass rcl_duration_t:\n\u002B    nanoseconds: int\n\u002B\n\u002B\n\u002Bclass rcl_subscription_event_type_t(IntEnum):\n\u002B    RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED: int\n\u002B    RCL_SUBSCRIPTION_LIVELINESS_CHANGED: int\n\u002B    RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS: int\n\u002B    RCL_SUBSCRIPTION_MESSAGE_LOST: int\n\u002B    RCL_SUBSCRIPTION_INCOMPATIBLE_TYPE: int\n\u002B    RCL_SUBSCRIPTION_MATCHED: int\n\u002B\n\u002B\n\u002Bclass rcl_publisher_event_type_t(IntEnum):\n\u002B    RCL_PUBLISHER_OFFERED_DEADLINE_MISSED: int\n\u002B    RCL_PUBLISHER_LIVELINESS_LOST: int\n\u002B    RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS: int\n\u002B    RCL_PUBLISHER_INCOMPATIBLE_TYPE: int\n\u002B    RCL_PUBLISHER_MATCHED: int\n\u002B\n\u002B\n\u002Bclass EventHandle(Destroyable):\n\u002B\n\u002B    @overload\n\u002B    def __init__(self, subcription: Subscription,\n\u002B                 event_type: rcl_subscription_event_type_t) -\u003E None: ...\n\u002B\n\u002B    @overload\n\u002B    def __init__(self, publisher: Publisher, event_type: rcl_publisher_event_type_t) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def take_event(self) -\u003E Any | None:\n\u002B        \u0022\u0022\u0022Get pending data from a ready event.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass GuardCondition(Destroyable):\n\u002B\n\u002B    def __init__(self, context: Context) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def trigger_guard_condition(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Trigger a general purpose guard condition.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass Service:\n\u002B    pass\n\u002B\n\u002B\n\u002Bclass Subscription(Destroyable, Generic[MsgT]):\n\u002B\n\u002B    def __init__(self, node: Node, pymsg_type: type[MsgT], topic: str,\n\u002B                 pyqos_profile: rmw_qos_profile_t) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def take_message(self, pymsg_type: type[MsgT], raw: bool) -\u003E tuple[MsgT, MessageInfo]:\n\u002B        \u0022\u0022\u0022Take a message and its metadata from a subscription.\u0022\u0022\u0022\n\u002B\n\u002B    def get_logger_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the name of the logger associated with the node of the subscription.\u0022\u0022\u0022\n\u002B\n\u002B    def get_topic_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Return the resolved topic name of a subscription.\u0022\u0022\u0022\n\u002B\n\u002B    def get_publisher_count(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Count the publishers from a subscription.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass Node:\n\u002B    pass\n\u002B\n\u002B\n\u002Bclass Publisher(Destroyable, Generic[MsgT]):\n\u002B\n\u002B    def __init__(self, arg0: Node, arg1: type[MsgT], arg2: str, arg3: rmw_qos_profile_t) -\u003E None:\n\u002B        \u0022\u0022\u0022Create _rclpy.Publisher.\u0022\u0022\u0022\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def get_logger_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the name of the logger associated with the node of the publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def get_subscription_count(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Count subscribers from a publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def get_topic_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Retrieve the topic name from a Publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def publish(self, arg0: MsgT) -\u003E None:\n\u002B        \u0022\u0022\u0022Publish a message.\u0022\u0022\u0022\n\u002B\n\u002B    def publish_raw(self, arg0: bytes) -\u003E None:\n\u002B        \u0022\u0022\u0022Publish a serialized message.\u0022\u0022\u0022\n\u002B\n\u002B    def wait_for_all_acked(self, arg0: rcl_duration_t) -\u003E bool:\n\u002B        \u0022\u0022\u0022Wait until all published message data is acknowledged.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002Bclass TimeInfoDict(TypedDict):\n\u002B    expected_call_time: int\n\u002B    actual_call_time: int\n\u002B\n\u002B\n\u002Bclass Timer(Destroyable):\n\u002B\n\u002B    def __init__(self, clock: Clock, context: Context, period_nsec: int,\n\u002B                 autostart: bool) -\u003E None: ...\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def reset_timer(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Reset a timer.\u0022\u0022\u0022\n\u002B\n\u002B    def is_timer_ready(self) -\u003E bool:\n\u002B        \u0022\u0022\u0022Check if a timer as reached timeout.\u0022\u0022\u0022\n\u002B\n\u002B    def call_timer(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Call a timer and starts counting again.\u0022\u0022\u0022\n\u002B\n\u002B    def call_timer_with_info(self) -\u003E TimeInfoDict:\n\u002B        \u0022\u0022\u0022Call a timer and starts counting again, retrieves actual and expected call time.\u0022\u0022\u0022\n\u002B\n\u002B    def change_timer_period(self, period_nsec: int) -\u003E None:\n\u002B        \u0022\u0022\u0022Set the period of a timer.\u0022\u0022\u0022\n\u002B\n\u002B    def time_until_next_call(self) -\u003E int | None:\n\u002B        \u0022\u0022\u0022Get the remaining time before timer is ready.\u0022\u0022\u0022\n\u002B\n\u002B    def time_since_last_call(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the elapsed time since last timer call.\u0022\u0022\u0022\n\u002B\n\u002B    def get_timer_period(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the period of a timer.\u0022\u0022\u0022\n\u002B\n\u002B    def cancel_timer(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Cancel a timer.\u0022\u0022\u0022\n\u002B\n\u002B    def is_timer_canceled(self) -\u003E bool:\n\u002B        \u0022\u0022\u0022Check if a timer is canceled.\u0022\u0022\u0022\n\u002B\n\u002B\n\u002BPredefinedQosProfileTNames = Literal[\u0027qos_profile_sensor_data\u0027, \u0027qos_profile_default\u0027,\n\u002B                                     \u0027qos_profile_system_default\u0027, \u0027qos_profile_services_default\u0027,\n\u002B                                     \u0027qos_profile_unknown\u0027, \u0027qos_profile_parameters\u0027,\n\u002B                                     \u0027qos_profile_parameter_events\u0027, \u0027qos_profile_best_available\u0027]\n\u002B\n\u002B\n\u002Bclass rmw_qos_profile_dict(TypedDict):\n\u002B    qos_history: QoSHistoryPolicy | int\n\u002B    qos_depth: int\n\u002B    qos_reliability: QoSReliabilityPolicy | int\n\u002B    qos_durability: QoSDurabilityPolicy | int\n\u002B    pyqos_lifespan: rcl_duration_t\n\u002B    pyqos_deadline: rcl_duration_t\n\u002B    qos_liveliness: QoSLivelinessPolicy | int\n\u002B    pyqos_liveliness_lease_duration: rcl_duration_t\n\u002B    avoid_ros_namespace_conventions: bool\n\u002B\n\u002B\n\u002Bclass rmw_qos_profile_t:\n\u002B\n\u002B    def __init__(\n\u002B        self,\n\u002B        qos_history: int,\n\u002B        qos_depth: int,\n\u002B        qos_reliability: int,\n\u002B        qos_durability: int,\n\u002B        pyqos_lifespan: rcl_duration_t,\n\u002B        pyqos_deadline: rcl_duration_t,\n\u002B        qos_liveliness: int,\n\u002B        pyqos_liveliness_lease_duration: rcl_duration_t,\n\u002B        avoid_ros_namespace_conventions: bool\n\u002B    ) -\u003E None: ...\n\u002B\n\u002B    def to_dict(self) -\u003E rmw_qos_profile_dict: ...\n\u002B\n\u002B    @staticmethod\n\u002B    def predefined(qos_profile_name: PredefinedQosProfileTNames) -\u003E rmw_qos_profile_t: ...\n\u002B\n\u002B\n\u002BIsReadyValues = Literal[\u0027subscription\u0027, \u0027client\u0027, \u0027service\u0027, \u0027timer\u0027, \u0027guard_condition\u0027, \u0027event\u0027]\n\u002BGetReadyEntityValues = Literal[\u0027subscription\u0027, \u0027client\u0027, \u0027service\u0027, \u0027timer\u0027, \u0027guard_condition\u0027]\n\u002B\n\u002B\n\u002Bclass WaitSet(Destroyable):\n\u002B\n\u002B    def __init__(self, number_of_subscriptions: int, number_of_guard_conditions: int,\n\u002B                 number_of_timers: int, number_of_clients: int, number_of_services: int,\n\u002B                 number_of_events: int, context: Context) -\u003E None:\n\u002B        \u0022\u0022\u0022Construct a WaitSet.\u0022\u0022\u0022\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def clear_entities(self) -\u003E None:\n\u002B        \u0022\u0022\u0022Clear all the pointers in the wait set.\u0022\u0022\u0022\n\u002B\n\u002B    def add_service(self, service: Service) -\u003E int:\n\u002B        \u0022\u0022\u0022Add a service to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def add_subscription(self, subscription: Subscription[Any]) -\u003E int:\n\u002B        \u0022\u0022\u0022Add a subcription to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def add_client(self, client: Client) -\u003E int:\n\u002B        \u0022\u0022\u0022Add a client to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def add_guard_condition(self, guard_condition: GuardCondition) -\u003E int:\n\u002B        \u0022\u0022\u0022Add a guard condition to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def add_timer(self, timer: Timer) -\u003E int:\n\u002B        \u0022\u0022\u0022Add a timer to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def add_event(self, event: EventHandle) -\u003E int:\n\u002B        \u0022\u0022\u0022Add an event to the wait set structure.\u0022\u0022\u0022\n\u002B\n\u002B    def is_ready(self, entity_type: IsReadyValues, index: int) -\u003E bool:\n\u002B        \u0022\u0022\u0022Check if an entity in the wait set is ready by its index.\u0022\u0022\u0022\n\u002B\n\u002B    def get_ready_entities(self, entity_type: GetReadyEntityValues) -\u003E list[int]:\n\u002B        \u0022\u0022\u0022Get list of entities ready by entity type.\u0022\u0022\u0022\n\u002B\n\u002B    def wait(self, timeout: int) -\u003E None:\n\u002B        \u0022\u0022\u0022Wait until timeout is reached or event happened.\u0022\u0022\u0022\ndiff --git rclpy/rclpy/impl/implementation_singleton.py rclpy/rclpy/impl/implementation_singleton.py\nindex ba7f55f..3e31228 100644\n--- rclpy/rclpy/impl/implementation_singleton.py\n\u002B\u002B\u002B rclpy/rclpy/impl/implementation_singleton.py\n@@ -27,6 \u002B27,7 @@ For example, you might use it like this:\n \u0022\u0022\u0022\n \n from rpyutils import import_c_library\n\u002B\n package = \u0027rclpy\u0027\n \n rclpy_implementation = import_c_library(\u0027._rclpy_pybind11\u0027, package)\ndiff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex e51dbcd..cba822b 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -79,7 \u002B79,6 @@ from rclpy.qos_overriding_options import QoSOverridingOptions\n from rclpy.service import Service\n from rclpy.subscription import MessageInfo\n from rclpy.subscription import Subscription\n-from rclpy.subscription import SubscriptionHandle\n from rclpy.time_source import TimeSource\n from rclpy.timer import Rate\n from rclpy.timer import Timer, TimerInfo\n@@ -114,10 \u002B113,6 @@ SrvTypeResponse = TypeVar(\u0027SrvTypeResponse\u0027)\n NodeNameNonExistentError = _rclpy.NodeNameNonExistentError\n \n \n-class NodeHandle:\n-    pass\n-\n-\n class Node:\n     \u0022\u0022\u0022\n     A Node in the ROS graph.\n@@ -1658,7 \u002B1653,7 @@ class Node:\n         check_is_valid_msg_type(msg_type)\n         try:\n             with self.handle:\n-                subscription_object: SubscriptionHandle[MsgT] = _rclpy.Subscription(\n\u002B                subscription_object = _rclpy.Subscription(\n                     self.handle, msg_type, topic, qos_profile.get_c_qos_profile())\n         except ValueError:\n             failed = True\ndiff --git rclpy/rclpy/publisher.py rclpy/rclpy/publisher.py\nindex 41835d4..66797f2 100644\n--- rclpy/rclpy/publisher.py\n\u002B\u002B\u002B rclpy/rclpy/publisher.py\n@@ -13,11 \u002B13,10 @@\n # limitations under the License.\n \n from types import TracebackType\n-from typing import Generic, List, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union\n\u002Bfrom typing import Generic, List, Optional, Type, TypeVar, Union\n \n from rclpy.callback_groups import CallbackGroup\n-from rclpy.destroyable import DestroyableType\n-from rclpy.duration import Duration, DurationHandle\n\u002Bfrom rclpy.duration import Duration\n from rclpy.event_handler import EventHandler, PublisherEventCallbacks\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n@@ -26,43 \u002B25,12 @@ from rclpy.type_support import MsgT\n # Left to support Legacy TypeVars.\n MsgType = TypeVar(\u0027MsgType\u0027)\n \n-if TYPE_CHECKING:\n-    from rclpy.node import NodeHandle\n-\n-\n-class PublisherHandle(DestroyableType, Protocol[MsgT]):\n-\n-    def __init__(self, arg0: \u0027NodeHandle\u0027, arg1: Type[MsgT], arg2: str, arg3: object) -\u003E None:\n-        \u0022\u0022\u0022Create PublisherHandle.\u0022\u0022\u0022\n-\n-    @property\n-    def pointer(self) -\u003E int:\n-        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n-\n-    def get_logger_name(self) -\u003E str:\n-        \u0022\u0022\u0022Get the name of the logger associated with the node of the publisher.\u0022\u0022\u0022\n-\n-    def get_subscription_count(self) -\u003E int:\n-        \u0022\u0022\u0022Count subscribers from a publisher.\u0022\u0022\u0022\n-\n-    def get_topic_name(self) -\u003E str:\n-        \u0022\u0022\u0022Retrieve the topic name from a Publisher.\u0022\u0022\u0022\n-\n-    def publish(self, arg0: MsgT) -\u003E None:\n-        \u0022\u0022\u0022Publish a message.\u0022\u0022\u0022\n-\n-    def publish_raw(self, arg0: bytes) -\u003E None:\n-        \u0022\u0022\u0022Publish a serialized message.\u0022\u0022\u0022\n-\n-    def wait_for_all_acked(self, arg0: DurationHandle) -\u003E bool:\n-        \u0022\u0022\u0022Wait until all published message data is acknowledged.\u0022\u0022\u0022\n-\n \n class Publisher(Generic[MsgT]):\n \n     def __init__(\n         self,\n-        publisher_impl: PublisherHandle[MsgT],\n\u002B        publisher_impl: \u0027_rclpy.Publisher[MsgT]\u0027,\n         msg_type: Type[MsgT],\n         topic: str,\n         qos_profile: QoSProfile,\n@@ -118,7 \u002B86,7 @@ class Publisher(Generic[MsgT]):\n             return self.__publisher.get_topic_name()\n \n     @property\n-    def handle(self) -\u003E PublisherHandle[MsgT]:\n\u002B    def handle(self) -\u003E \u0027_rclpy.Publisher[MsgT]\u0027:\n         return self.__publisher\n \n     def destroy(self) -\u003E None:\ndiff --git rclpy/rclpy/qos.py rclpy/rclpy/qos.py\nindex ba54943..6c8b18f 100644\n--- rclpy/rclpy/qos.py\n\u002B\u002B\u002B rclpy/rclpy/qos.py\n@@ -13,11 \u002B13,11 @@\n # limitations under the License.\n \n from enum import Enum, IntEnum\n-from typing import (Callable, Iterable, List, Optional, Protocol, Tuple, Type, TYPE_CHECKING,\n\u002Bfrom typing import (Callable, Iterable, List, Optional, Tuple, Type, TYPE_CHECKING,\n                     TypedDict, TypeVar, Union)\n import warnings\n \n-from rclpy.duration import Duration, DurationHandle\n\u002Bfrom rclpy.duration import Duration\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n \n if TYPE_CHECKING:\n@@ -56,18 \u002B56,6 @@ class InvalidQoSProfileException(Exception):\n         Exception(self, f\u0027Invalid QoSProfile: {message}\u0027)\n \n \n-class QoSProfileHandle(Protocol):\n-    qos_history: Union[\u0027QoSHistoryPolicy\u0027, int]\n-    qos_depth: int\n-    qos_reliability: Union[\u0027QoSReliabilityPolicy\u0027, int]\n-    qos_durability: Union[\u0027QoSDurabilityPolicy\u0027, int]\n-    pyqos_lifespan: DurationHandle\n-    pyqos_deadline: DurationHandle\n-    qos_liveliness: Union[\u0027QoSLivelinessPolicy\u0027, int]\n-    pyqos_liveliness_lease_duration: DurationHandle\n-    avoid_ros_namespace_conventions: bool\n-\n-\n class QoSProfileDictionary(TypedDict):\n     history: \u0027QoSHistoryPolicy\u0027\n     depth: int\n@@ -276,7 \u002B264,7 @@ class QoSProfile:\n         assert isinstance(value, bool)\n         self._avoid_ros_namespace_conventions = value\n \n-    def get_c_qos_profile(self) -\u003E QoSProfileHandle:\n\u002B    def get_c_qos_profile(self) -\u003E _rclpy.rmw_qos_profile_t:\n         return _rclpy.rmw_qos_profile_t(\n             self.history,\n             self.depth,\ndiff --git rclpy/rclpy/subscription.py rclpy/rclpy/subscription.py\nindex 564742d..86eedb0 100644\n--- rclpy/rclpy/subscription.py\n\u002B\u002B\u002B rclpy/rclpy/subscription.py\n@@ -16,11 \u002B16,11 @@\n from enum import Enum\n import inspect\n from types import TracebackType\n-from typing import Callable, Generic, Optional, Protocol, Tuple, Type, TypedDict, TypeVar, Union\n\u002Bfrom typing import Callable, Generic, Optional, Type, TypedDict, TypeVar, Union\n \n from rclpy.callback_groups import CallbackGroup\n-from rclpy.destroyable import DestroyableType\n from rclpy.event_handler import SubscriptionEventCallbacks\n\u002Bfrom rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n from rclpy.type_support import MsgT\n \n@@ -32,30 \u002B32,6 @@ class MessageInfo(TypedDict):\n     reception_sequence_number: Optional[int]\n \n \n-class SubscriptionHandle(DestroyableType, Protocol[MsgT]):\n-\n-    @property\n-    def pointer(self) -\u003E int:\n-        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n-        ...\n-\n-    def take_message(self, pymsg_type: Type[MsgT], raw: bool) -\u003E Tuple[MsgT, MessageInfo]:\n-        \u0022\u0022\u0022Take a message and its metadata from a subscription.\u0022\u0022\u0022\n-        ...\n-\n-    def get_logger_name(self) -\u003E str:\n-        \u0022\u0022\u0022Get the name of the logger associated with the node of the subscription.\u0022\u0022\u0022\n-        ...\n-\n-    def get_topic_name(self) -\u003E str:\n-        \u0022\u0022\u0022Return the resolved topic name of a subscription.\u0022\u0022\u0022\n-        ...\n-\n-    def get_publisher_count(self) -\u003E int:\n-        \u0022\u0022\u0022Count the publishers from a subscription.\u0022\u0022\u0022\n-        ...\n-\n-\n # Left to support Legacy TypeVars.\n MsgType = TypeVar(\u0027MsgType\u0027)\n \n@@ -68,7 \u002B44,7 @@ class Subscription(Generic[MsgT]):\n \n     def __init__(\n          self,\n-         subscription_impl: SubscriptionHandle[MsgT],\n\u002B         subscription_impl: \u0027_rclpy.Subscription[MsgT]\u0027,\n          msg_type: Type[MsgT],\n          topic: str,\n          callback: Union[Callable[[MsgT], None], Callable[[MsgT, MessageInfo], None]],\n@@ -114,7 \u002B90,7 @@ class Subscription(Generic[MsgT]):\n             return self.__subscription.get_publisher_count()\n \n     @property\n-    def handle(self) -\u003E SubscriptionHandle[MsgT]:\n\u002B    def handle(self) -\u003E \u0027_rclpy.Subscription[MsgT]\u0027:\n         return self.__subscription\n \n     def destroy(self) -\u003E None:\n@@ -157,7 \u002B133,7 @@ class Subscription(Generic[MsgT]):\n             \u0027Subscription.__init__(): callback should be either be callable with one argument\u0027\n             \u0027(to get only the message) or two (to get message and message info)\u0027)\n \n-    def __enter__(self) -\u003E \u0027Subscription\u0027:\n\u002B    def __enter__(self) -\u003E \u0027Subscription[MsgT]\u0027:\n         return self\n \n     def __exit__(\ndiff --git rclpy/rclpy/time.py rclpy/rclpy/time.py\nindex 57693a0..a6f89aa 100644\n--- rclpy/rclpy/time.py\n\u002B\u002B\u002B rclpy/rclpy/time.py\n@@ -12,7 \u002B12,7 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import overload, Protocol, Tuple, Union\n\u002Bfrom typing import overload, Tuple, Union\n \n import builtin_interfaces.msg\n \n@@ -23,13 \u002B23,6 @@ from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from .clock_type import ClockType\n \n \n-class TimeHandle(Protocol):\n-    \u0022\u0022\u0022Type alias of _rclpy.rcl_time_point_t.\u0022\u0022\u0022\n-\n-    nanoseconds: int\n-    clock_type: ClockType\n-\n-\n class Time:\n     \u0022\u0022\u0022\n     Represents a point in time.\n@@ -56,7 \u002B49,7 @@ class Time:\n             # pybind11 would raise TypeError, but we want OverflowError\n             raise OverflowError(\n                 \u0027Total nanoseconds value is too large to store in C time point.\u0027)\n-        self._time_handle: TimeHandle = _rclpy.rcl_time_point_t(total_nanoseconds, clock_type)\n\u002B        self._time_handle = _rclpy.rcl_time_point_t(total_nanoseconds, clock_type)\n \n     @property\n     def nanoseconds(self) -\u003E int:\n@@ -119,40 \u002B112,40 @@ class Time:\n         else:\n             return NotImplemented\n \n-    def __eq__(self, other: object) -\u003E bool:\n\u002B    def __eq__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             if self.clock_type != other.clock_type:\n                 raise TypeError(\u0022Can\u0027t compare times with different clock types\u0022)\n             return self.nanoseconds == other.nanoseconds\n         return NotImplemented\n \n-    def __ne__(self, other: object) -\u003E bool:\n\u002B    def __ne__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             return not self.__eq__(other)\n         return NotImplemented\n \n-    def __lt__(self, other: object) -\u003E bool:\n\u002B    def __lt__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             if self.clock_type != other.clock_type:\n                 raise TypeError(\u0022Can\u0027t compare times with different clock types\u0022)\n             return self.nanoseconds \u003C other.nanoseconds\n         return NotImplemented\n \n-    def __le__(self, other: object) -\u003E bool:\n\u002B    def __le__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             if self.clock_type != other.clock_type:\n                 raise TypeError(\u0022Can\u0027t compare times with different clock types\u0022)\n             return self.nanoseconds \u003C= other.nanoseconds\n         return NotImplemented\n \n-    def __gt__(self, other: object) -\u003E bool:\n\u002B    def __gt__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             if self.clock_type != other.clock_type:\n                 raise TypeError(\u0022Can\u0027t compare times with different clock types\u0022)\n             return self.nanoseconds \u003E other.nanoseconds\n         return NotImplemented\n \n-    def __ge__(self, other: object) -\u003E bool:\n\u002B    def __ge__(self, other: \u0027Time\u0027) -\u003E bool:\n         if isinstance(other, Time):\n             if self.clock_type != other.clock_type:\n                 raise TypeError(\u0022Can\u0027t compare times with different clock types\u0022)\ndiff --git rclpy/rclpy/timer.py rclpy/rclpy/timer.py\nindex 7e1b1fe..c5b5770 100644\n--- rclpy/rclpy/timer.py\n\u002B\u002B\u002B rclpy/rclpy/timer.py\n@@ -17,7 \u002B17,6 @@ import threading\n from types import TracebackType\n from typing import Callable\n from typing import Optional\n-from typing import Protocol\n from typing import Type\n from typing import Union\n \n@@ -25,44 \u002B24,12 @@ from rclpy.callback_groups import CallbackGroup\n from rclpy.clock import Clock\n from rclpy.clock_type import ClockType\n from rclpy.context import Context\n-from rclpy.destroyable import DestroyableType\n from rclpy.exceptions import InvalidHandle, ROSInterruptException\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.time import Time\n from rclpy.utilities import get_default_context\n \n \n-class TimerHandle(DestroyableType, Protocol):\n-    \u0022\u0022\u0022Type alias of _rclpy.Timer.\u0022\u0022\u0022\n-\n-    def reset_timer(self) -\u003E None:\n-        ...\n-\n-    def is_timer_ready(self) -\u003E bool:\n-        ...\n-\n-    def call_timer(self) -\u003E None:\n-        ...\n-\n-    def change_timer_period(self, period_nsec: int) -\u003E None:\n-        ...\n-\n-    def time_until_next_call(self) -\u003E Optional[int]:\n-        ...\n-\n-    def time_since_last_call(self) -\u003E int:\n-        ...\n-\n-    def get_timer_period(self) -\u003E int:\n-        ...\n-\n-    def cancel_timer(self) -\u003E None:\n-        ...\n-\n-    def is_timer_canceled(self) -\u003E bool:\n-        ...\n-\n-\n class TimerInfo:\n     \u0022\u0022\u0022\n     Represents a timer call information.\n@@ -130,9 \u002B97,9 @@ class Timer:\n         self._context = get_default_context() if context is None else context\n         self._clock = clock\n         if self._context.handle is None:\n-            raise RuntimeError(\u0027Context must be initialized before create a TimerHandle.\u0027)\n\u002B            raise RuntimeError(\u0027Context must be initialized before create a _rclpy.Timer.\u0027)\n         with self._clock.handle, self._context.handle:\n-            self.__timer: TimerHandle = _rclpy.Timer(\n\u002B            self.__timer = _rclpy.Timer(\n                 self._clock.handle, self._context.handle, timer_period_ns, autostart)\n         self.timer_period_ns = timer_period_ns\n         self.callback = callback\n@@ -141,7 \u002B108,7 @@ class Timer:\n         self._executor_event = False\n \n     @property\n-    def handle(self) -\u003E TimerHandle:\n\u002B    def handle(self) -\u003E _rclpy.Timer:\n         return self.__timer\n \n     def destroy(self) -\u003E None:\ndiff --git rclpy/rclpy/wait_for_message.py rclpy/rclpy/wait_for_message.py\nindex a26eb75..82302ff 100644\n--- rclpy/rclpy/wait_for_message.py\n\u002B\u002B\u002B rclpy/rclpy/wait_for_message.py\n@@ -12,23 \u002B12,24 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Union\n\u002Bfrom typing import Literal, Tuple, Type, Union\n \n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.node import Node\n from rclpy.qos import QoSProfile\n from rclpy.signals import SignalHandlerGuardCondition\n\u002Bfrom rclpy.type_support import MsgT\n from rclpy.utilities import timeout_sec_to_nsec\n \n \n def wait_for_message(\n-    msg_type,\n\u002B    msg_type: Type[MsgT],\n     node: \u0027Node\u0027,\n     topic: str,\n     *,\n     qos_profile: Union[QoSProfile, int] = 1,\n-    time_to_wait=-1\n-):\n\u002B    time_to_wait: Union[int, float] = -1\n\u002B) -\u003E Union[Tuple[Literal[True], MsgT], Tuple[Literal[False], None]]:\n     \u0022\u0022\u0022\n     Wait for the next incoming message.\n \n@@ -41,6 \u002B42,10 @@ def wait_for_message(\n         could not be obtained or shutdown was triggered asynchronously on the context.\n     \u0022\u0022\u0022\n     context = node.context\n\u002B\n\u002B    if context.handle is None:\n\u002B        raise RuntimeError(\u0027Cannot create Waitset without a context.handle\u0027)\n\u002B\n     wait_set = _rclpy.WaitSet(1, 1, 0, 0, 0, 0, context.handle)\n     wait_set.clear_entities()\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "865b02bee84e75bde175515a2c71b667617187d1",
    "RawMessage": "Provide lifecycle services in the rclc lifecycle nodes (#51)",
    "Changes": "diff --git rclc/CMakeLists.txt rclc/CMakeLists.txt\nindex f5f60a8..5c6bd6b 100644\n--- rclc/CMakeLists.txt\n\u002B\u002B\u002B rclc/CMakeLists.txt\n@@ -34,12 \u002B34,14 @@ find_package(rosidl_generator_c REQUIRED)\n find_package(std_msgs REQUIRED)\n \n if(\u0022${rcl_VERSION}\u0022 VERSION_LESS \u00221.0.0\u0022)\n-  message(STATUS \u0022Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\u0022)\n\u002B  message(STATUS\n\u002B    \u0022Found rcl version ${rcl_VERSION}, which belongs to Dashing or Eloquent\u0022)\n   # Later, with CMake 3.12\u002B use:\n   # add_compile_definitions(USE_RCL_WAIT_SET_IS_VALID_BACKPORT)\n   add_definitions(-DUSE_RCL_WAIT_SET_IS_VALID_BACKPORT)\n else()\n-  message(STATUS \u0022Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\u0022)\n\u002B  message(STATUS\n\u002B    \u0022Found rcl version ${rcl_VERSION}, which belongs to Foxy or later\u0022)\n   find_package(rosidl_runtime_c REQUIRED)\n endif()\n \n@@ -60,7 \u002B62,8 @@ add_library(${PROJECT_NAME}\n   src/rclc/sleep.c\n )\n if(\u0022${rcl_VERSION}\u0022 VERSION_LESS \u00221.0.0\u0022)\n-  target_sources(${PROJECT_NAME} PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)\n\u002B  target_sources(${PROJECT_NAME}\n\u002B    PRIVATE src/rclc/rcl_wait_set_is_valid_backport.c)\n endif()\n \n target_include_directories(${PROJECT_NAME}\n@@ -119,11 \u002B122,13 @@ endif()\n if(BUILD_TESTING)\n   find_package(ament_cmake_gtest REQUIRED)\n   find_package(ament_lint_auto REQUIRED)\n-  set(ament_cmake_copyright_FOUND TRUE) # No copyright header check since link to NOTICE file is not recognized properly.\n   find_package(osrf_testing_tools_cpp REQUIRED)\n   find_package(std_msgs REQUIRED)\n   find_package(example_interfaces REQUIRED)\n \n\u002B  # No copyright header check since link to NOTICE file is not recognized properly.\n\u002B  set(ament_cmake_copyright_FOUND TRUE)\n\u002B\n   ament_lint_auto_find_test_dependencies()\n \n   ament_add_gtest(${PROJECT_NAME}_test\ndiff --git rclc_examples/src/example_client_node.c rclc_examples/src/example_client_node.c\nindex 9a55cca..46a8242 100644\n--- rclc_examples/src/example_client_node.c\n\u002B\u002B\u002B rclc_examples/src/example_client_node.c\n@@ -47,7 \u002B47,7 @@ int main(int argc, const char * const * argv)\n   RCCHECK(rclc_support_init(\u0026support, 0, NULL, \u0026allocator));\n \n   // create node\n-  rcl_node_t node = rcl_get_zero_initialized_node();\n\u002B  rcl_node_t node;\n   RCCHECK(rclc_node_init_default(\u0026node, \u0022add_twoints_client_rclc\u0022, \u0022\u0022, \u0026support));\n \n   // create client\ndiff --git rclc_examples/src/example_lifecycle_node.c rclc_examples/src/example_lifecycle_node.c\nindex 69e4d8d..ad86acd 100644\n--- rclc_examples/src/example_lifecycle_node.c\n\u002B\u002B\u002B rclc_examples/src/example_lifecycle_node.c\n@@ -26,8 \u002B26,15 @@\n #include \u003Clifecycle_msgs/srv/get_available_states.h\u003E\n #include \u003Clifecycle_msgs/srv/get_available_transitions.h\u003E\n \n\u002B#include \u003Crclc/executor.h\u003E\n\u002B\n #include \u0022rclc_lifecycle/rclc_lifecycle.h\u0022\n \n\u002B#define RCCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n\u002B        \u0022Failed status on line %d: %d. Aborting.\\n\u0022, __LINE__, (int)temp_rc); return 1;}}\n\u002B#define RCSOFTCHECK(fn) {rcl_ret_t temp_rc = fn; if ((temp_rc != RCL_RET_OK)) {printf( \\\n\u002B        \u0022Failed status on line %d: %d. Continuing.\\n\u0022, __LINE__, (int)temp_rc);}}\n\u002B\n rcl_ret_t my_on_configure()\n {\n   printf(\u0022  \u003E\u003E\u003E lifecycle_node: on_configure() callback called.\\n\u0022);\n@@ -66,7 \u002B73,7 @@ int main(int argc, const char * argv[])\n   }\n \n   // create rcl_node\n-  rcl_node_t my_node = rcl_get_zero_initialized_node();\n\u002B  rcl_node_t my_node;\n   rc = rclc_node_init_default(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026support);\n   if (rc != RCL_RET_OK) {\n     printf(\u0022Error in rclc_node_init_default\\n\u0022);\n@@ -74,7 \u002B81,7 @@ int main(int argc, const char * argv[])\n   }\n \n   // make it a lifecycle node\n-  printf(\u0022make it a lifecycle node...\\n\u0022);\n\u002B  printf(\u0022creating lifecycle node...\\n\u0022);\n   rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n   rclc_lifecycle_node_t lifecycle_node;\n   rc = rclc_make_node_a_lifecycle_node(\n@@ -88,62 \u002B95,38 @@ int main(int argc, const char * argv[])\n     return -1;\n   }\n \n-  // register callbacks\n\u002B  // Executor\n\u002B  rclc_executor_t executor;\n\u002B  RCCHECK(rclc_executor_init(\n\u002B    \u0026executor,\n\u002B    \u0026support.context,\n\u002B    4,  // 1 for the node \u002B 1 for each lifecycle service\n\u002B    \u0026allocator));\n\u002B\n\u002B  unsigned int rcl_wait_timeout = 1000;  // in ms\n\u002B  RCCHECK(rclc_executor_set_timeout(\u0026executor, RCL_MS_TO_NS(rcl_wait_timeout)));\n\u002B\n\u002B  // Register lifecycle services\n\u002B  printf(\u0022registering lifecycle services...\\n\u0022);\n\u002B  RCCHECK(rclc_lifecycle_init_get_state_server(\u0026lifecycle_node, \u0026executor));\n\u002B  RCCHECK(rclc_lifecycle_init_get_available_states_server(\u0026lifecycle_node, \u0026executor));\n\u002B  RCCHECK(rclc_lifecycle_init_change_state_server(\u0026lifecycle_node, \u0026executor));\n\u002B\n\u002B  // Register lifecycle service callbacks\n\u002B  printf(\u0022registering callbacks...\\n\u0022);\n   rclc_lifecycle_register_on_configure(\u0026lifecycle_node, \u0026my_on_configure);\n\u002B  rclc_lifecycle_register_on_activate(\u0026lifecycle_node, \u0026my_on_activate);\n   rclc_lifecycle_register_on_deactivate(\u0026lifecycle_node, \u0026my_on_deactivate);\n\u002B  rclc_lifecycle_register_on_cleanup(\u0026lifecycle_node, \u0026my_on_cleanup);\n \n-  printf(\u0022 \u003Econfiguring lifecycle node...\\n\u0022);\n-  rc = rclc_lifecycle_change_state(\n-    \u0026lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\u0022Error in TRANSITION_CONFIGURE\\n\u0022);\n-    return -1;\n-  }\n-\n-  printf(\u0022 \u003Eactivating lifecycle node...\\n\u0022);\n-  rc = rclc_lifecycle_change_state(\n-    \u0026lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\u0022Error in TRANSITION_ACTIVATE\\n\u0022);\n-    return -1;\n-  }\n-\n-  printf(\u0022 \u003Edeactivating lifecycle node...\\n\u0022);\n-  rc = rclc_lifecycle_change_state(\n-    \u0026lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_DEACTIVATE,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\u0022Error in TRANSITION_DEACTIVATE\\n\u0022);\n-    return -1;\n-  }\n-\n-  printf(\u0022 \u003Ecleaning rcl node up...\\n\u0022);\n-  rc = rclc_lifecycle_change_state(\n-    \u0026lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_CLEANUP,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\u0022Error in TRANSITION_CLEANUP\\n\u0022);\n-    return -1;\n-  }\n-\n-  printf(\u0022 \u003Edestroying lifecycle node...\\n\u0022);\n-  rc = rclc_lifecycle_change_state(\n-    \u0026lifecycle_node,\n-    lifecycle_msgs__msg__Transition__TRANSITION_UNCONFIGURED_SHUTDOWN,\n-    true);\n-  if (rc != RCL_RET_OK) {\n-    printf(\u0022Error in TRANSITION_UNCONFIGURED_SHUTDOWN\\n\u0022);\n-    return -1;\n-  }\n\u002B  // Run\n\u002B  RCSOFTCHECK(rclc_executor_spin(\u0026executor));\n \n\u002B  // Cleanup\n   printf(\u0022cleaning up...\\n\u0022);\n-  rc = rcl_lifecycle_node_fini(\u0026lifecycle_node, \u0026allocator);\n\u002B  rc = rclc_lifecycle_node_fini(\u0026lifecycle_node, \u0026allocator);\n\u002B  rc \u002B= rcl_node_fini(\u0026my_node);\n\u002B  rc \u002B= rclc_executor_fini(\u0026executor);\n   rc \u002B= rclc_support_fini(\u0026support);\n \n   if (rc != RCL_RET_OK) {\ndiff --git rclc_examples/src/example_service_node.c rclc_examples/src/example_service_node.c\nindex dc7d019..4c5631d 100644\n--- rclc_examples/src/example_service_node.c\n\u002B\u002B\u002B rclc_examples/src/example_service_node.c\n@@ -54,7 \u002B54,7 @@ int main(int argc, const char * const * argv)\n   RCCHECK(rclc_support_init(\u0026support, 0, NULL, \u0026allocator));\n \n   // create node\n-  rcl_node_t node = rcl_get_zero_initialized_node();\n\u002B  rcl_node_t node;\n   RCCHECK(rclc_node_init_default(\u0026node, \u0022add_twoints_client_rclc\u0022, \u0022\u0022, \u0026support));\n \n   // create service\n@@ -68,7 \u002B68,7 @@ int main(int argc, const char * const * argv)\n   rclc_executor_t executor = rclc_executor_get_zero_initialized_executor();\n   RCCHECK(rclc_executor_init(\u0026executor, \u0026support.context, 1, \u0026allocator));\n \n-  unsigned int rcl_wait_timeout = 10;         // in ms\n\u002B  unsigned int rcl_wait_timeout = 1000;  // in ms\n   RCCHECK(rclc_executor_set_timeout(\u0026executor, RCL_MS_TO_NS(rcl_wait_timeout)));\n \n   RCCHECK(rclc_executor_add_service(\u0026executor, \u0026service, \u0026req, \u0026res, service_callback));\ndiff --git rclc_lifecycle/CMakeLists.txt rclc_lifecycle/CMakeLists.txt\nindex 71129ee..e759b74 100644\n--- rclc_lifecycle/CMakeLists.txt\n\u002B\u002B\u002B rclc_lifecycle/CMakeLists.txt\n@@ -6,8 \u002B6,13 @@ if(NOT CMAKE_C_STANDARD)\n   set(CMAKE_C_STANDARD 99)\n endif()\n \n\u002B# maximum string length - should cover all lifecycle state and transition names\n\u002Bset(RCLC_LIFECYCLE_MAX_STRING_LENGTH 20 CACHE STRING \u0022Set the maximum length for strings.\u0022)\n\u002Badd_definitions(-DRCLC_LIFECYCLE_MAX_STRING_LENGTH=${RCLC_LIFECYCLE_MAX_STRING_LENGTH})\n\u002B\n # find dependencies\n find_package(ament_cmake_ros REQUIRED)\n\u002Bfind_package(std_msgs REQUIRED)\n find_package(lifecycle_msgs REQUIRED)\n find_package(rcl_lifecycle REQUIRED)\n find_package(rclc REQUIRED)\n@@ -41,6 \u002B46,7 @@ ament_target_dependencies(${PROJECT_NAME}\n   rclc\n   rcutils\n   rcl_lifecycle\n\u002B  std_msgs\n   lifecycle_msgs\n )\n \ndiff --git rclc_lifecycle/README.md rclc_lifecycle/README.md\nindex d665d26..abb8ac0 100644\n--- rclc_lifecycle/README.md\n\u002B\u002B\u002B rclc_lifecycle/README.md\n@@ -11,7 \u002B11,7 @@ The API of the RCLC Lifecycle Node can be divided in several phases: Initializat\n \n ### Initialization\n \n-Creation of a lifecycle node as a bundle of an rcl node and the rcl Node Lifecycle state machine.\n\u002BCreation of a lifecycle node as a bundle of an rcl node and the rcl Node Lifecycle state machine:  \n \n \u0060\u0060\u0060C\n #include \u0022rclc_lifecycle/rclc_lifecycle.h\u0022\n@@ -22,11 \u002B22,11 @@ rcl_ret_t rc;\n \n // create rcl node\n rc = rclc_support_init(\u0026support, argc, argv, \u0026allocator);\n-rcl_node_t my_node = rcl_get_zero_initialized_node();\n\u002Brcl_node_t my_node;\n rc = rclc_node_init_default(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026support);\n \n // rcl state machine\n-rcl_lifecycle_state_machine_t state_machine_ =   \n\u002Brcl_lifecycle_state_machine_t state_machine_ =\n   rcl_lifecycle_get_zero_initialized_state_machine();\n ...\n \n@@ -39,45 \u002B39,36 @@ rcl_ret_t rc = rclc_make_node_a_lifecycle_node(\n   \u0026allocator);\n \u0060\u0060\u0060\n \n-Optionally create hooks for lifecycle state changes.\n\u002BRegister lifecycle services and optionally create callbacks for state changes. Executor needsto be equipped with 1 handle per node _and_ per service:  \n \n \u0060\u0060\u0060C\n-// declare callback\n-rcl_ret_t my_on_configure() {\n-  printf(\u0022  \u003E\u003E\u003E lifecycle_node: on_configure() callback called.\\n\u0022);\n-  return RCL_RET_OK;\n-}\n\u002B// Executor\n\u002Brclc_executor_t executor = rclc_executor_get_zero_initialized_executor();\n\u002Brclc_executor_init(\n\u002B  \u0026executor,\n\u002B  \u0026support.context,\n\u002B  4,  // 1 for the node \u002B 1 for each lifecycle service\n\u002B  \u0026allocator));\n ...\n \n-// register callbacks\n-rclc_lifecycle_register_on_configure(\u0026lifecycle_node, \u0026my_on_configure);\n-\u0060\u0060\u0060\n-\n-### Running\n\u002B// Register lifecycle services\n\u002Brclc_lifecycle_add_get_state_service(\u0026lifecycle_node, \u0026executor);\n\u002Brclc_lifecycle_add_get_available_states_service(\u0026lifecycle_node, \u0026executor);\n\u002Brclc_lifecycle_add_change_state_service(\u0026lifecycle_node, \u0026executor);\n \n-Change states of the lifecycle node, e.g.\n-\n-\u0060\u0060\u0060C\n-bool publish_transition = true;\n-rc \u002B= rclc_lifecycle_change_state(\n-  \u0026lifecycle_node,\n-  lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n-  publish_transition);\n-rc \u002B= rclc_lifecycle_change_state(\n-  \u0026lifecycle_node,\n-  lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n-  publish_transition);\n\u002B// Register lifecycle service callbacks\n\u002Brclc_lifecycle_register_on_configure(\u0026lifecycle_node, \u0026my_on_configure);\n\u002Brclc_lifecycle_register_on_activate(\u0026lifecycle_node, \u0026my_on_activate);\n ...\n \u0060\u0060\u0060\n \n-Except for error processing transitions, transitions are usually triggered from outside, e.g., by ROS 2 services.\n-\n ### Cleaning Up\n \n-To clean everything up, simply do\n\u002BTo clean everything up, do:  \n \n \u0060\u0060\u0060C\n rc \u002B= rcl_lifecycle_node_fini(\u0026lifecycle_node, \u0026allocator);\n\u002B...\n \u0060\u0060\u0060\n \n ## Example\n@@ -86,4 \u002B77,4 @@ An example, how to use the RCLC Lifecycle Node is given in the file \u0060lifecycle_n\n \n ## Limitations\n \n-The state machine publishes state changes, however, lifecycle services are not yet exposed via ROS 2 services (tbd).\n\u002B* Lifecycle services cannot yet be called via \u0060ros2 lifecycle\u0060 CLI, e.g., \u0060ros2 lifecycle set /node configure\u0060. Instead use the \u0060ros2 service\u0060 CLI, e.g., \u0060ros2 service call /node/change_state lifecycle_msgs/ChangeState \u0022{transition: {id: 1, label: configure}}\u0022\u0060.\ndiff --git rclc_lifecycle/include/rclc_lifecycle/rclc_lifecycle.h rclc_lifecycle/include/rclc_lifecycle/rclc_lifecycle.h\nindex 4935655..6e50d60 100644\n--- rclc_lifecycle/include/rclc_lifecycle/rclc_lifecycle.h\n\u002B\u002B\u002B rclc_lifecycle/include/rclc_lifecycle/rclc_lifecycle.h\n@@ -23,7 \u002B23,12 @@\n #include \u003Crcl/error_handling.h\u003E\n #include \u003Crcl_lifecycle/rcl_lifecycle.h\u003E\n \n-#include \u0022rclc/node.h\u0022\n\u002B#include \u003Clifecycle_msgs/srv/change_state.h\u003E\n\u002B#include \u003Clifecycle_msgs/srv/get_state.h\u003E\n\u002B#include \u003Clifecycle_msgs/srv/get_available_states.h\u003E\n\u002B\n\u002B#include \u003Crclc/node.h\u003E\n\u002B#include \u003Crclc/executor.h\u003E\n #include \u0022rclc_lifecycle/visibility_control.h\u0022\n \n typedef struct rclc_lifecycle_callback_map_t\n@@ -38,8 \u002B43,61 @@ typedef struct rclc_lifecycle_node_t\n   rcl_node_t * node;\n   rcl_lifecycle_state_machine_t * state_machine;\n   rclc_lifecycle_callback_map_t callbacks;\n\u002B  bool publish_transitions;\n\u002B\n\u002B  lifecycle_msgs__srv__ChangeState_Request cs_req;\n\u002B  lifecycle_msgs__srv__ChangeState_Response cs_res;\n\u002B  lifecycle_msgs__srv__GetState_Request gs_req;\n\u002B  lifecycle_msgs__srv__GetState_Response gs_res;\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Request gas_req;\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Response gas_res;\n } rclc_lifecycle_node_t;\n \n\u002B/// Structure which encapsulates a ROS Lifecycle Node.\n\u002Btypedef struct rclc_lifecycle_service_context_t\n\u002B{\n\u002B  rclc_lifecycle_node_t * lifecycle_node;\n\u002B} rclc_lifecycle_service_context_t;\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_get_state_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor);\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_get_available_states_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor);\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_change_state_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor);\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Bvoid\n\u002Brclc_lifecycle_get_state_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context);\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Bvoid\n\u002Brclc_lifecycle_get_available_states_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context);\n\u002B\n\u002BRCLC_LIFECYCLE_PUBLIC\n\u002Bvoid\n\u002Brclc_lifecycle_change_state_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context);\n\u002B\n RCLC_LIFECYCLE_PUBLIC\n rcl_ret_t\n rclc_make_node_a_lifecycle_node(\n@@ -95,7 \u002B153,7 @@ rclc_lifecycle_execute_callback(\n \n RCLC_LIFECYCLE_PUBLIC\n rcl_ret_t\n-rcl_lifecycle_node_fini(\n\u002Brclc_lifecycle_node_fini(\n   rclc_lifecycle_node_t * node,\n   rcl_allocator_t * allocator);\n \ndiff --git rclc_lifecycle/package.xml rclc_lifecycle/package.xml\nindex d0f06c3..8bb759b 100644\n--- rclc_lifecycle/package.xml\n\u002B\u002B\u002B rclc_lifecycle/package.xml\n@@ -7,13 \u002B7,14 @@\n   \u003Cmaintainer email=\u0022jan.staschulat@de.bosch.com\u0022\u003EJan Staschulat\u003C/maintainer\u003E\n \n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n-  \n\u002B\n   \u003Cauthor email=\u0022arne.nordmann@de.bosch.com\u0022\u003EArne Nordmann\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Erclc\u003C/depend\u003E\n   \u003Cdepend\u003Ercl_lifecycle\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Estd_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Elifecycle_msgs\u003C/depend\u003E\n \n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\ndiff --git rclc_lifecycle/src/rclc_lifecycle/rclc_lifecycle.c rclc_lifecycle/src/rclc_lifecycle/rclc_lifecycle.c\nindex 1e62a74..b6cd0ae 100644\n--- rclc_lifecycle/src/rclc_lifecycle/rclc_lifecycle.c\n\u002B\u002B\u002B rclc_lifecycle/src/rclc_lifecycle/rclc_lifecycle.c\n@@ -19,9 \u002B19,13 @@\n #include \u003Crcl/error_handling.h\u003E\n #include \u003Crcutils/logging_macros.h\u003E\n \n\u002B#include \u003Crclc/types.h\u003E\n #include \u003Crcl_lifecycle/rcl_lifecycle.h\u003E\n #include \u003Crcl_lifecycle/transition_map.h\u003E\n \n\u002B#include \u003Crosidl_runtime_c/string_functions.h\u003E\n\u002B#include \u003Cstd_msgs/msg/string.h\u003E\n\u002B#include \u003Clifecycle_msgs/msg/state.h\u003E\n #include \u003Clifecycle_msgs/msg/transition_description.h\u003E\n #include \u003Clifecycle_msgs/msg/transition_event.h\u003E\n #include \u003Clifecycle_msgs/srv/change_state.h\u003E\n@@ -39,6 \u002B43,15 @@ rclc_make_node_a_lifecycle_node(\n   bool enable_communication_interface\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    node, \u0022node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    allocator, \u0022allocator is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  lifecycle_node-\u003Enode = node;\n\u002B\n   rcl_lifecycle_state_machine_options_t state_machine_options =\n     rcl_lifecycle_get_default_state_machine_options();\n   state_machine_options.enable_com_interface = enable_communication_interface;\n@@ -56,16 \u002B69,40 @@ rclc_make_node_a_lifecycle_node(\n     \u0026state_machine_options);\n   if (rcl_ret != RCL_RET_OK) {\n     // state machine not initialized, return uninitilized\n-    // @todo(anordman): how/what to return in this case?\n     RCUTILS_LOG_ERROR(\n       \u0022Unable to initialize state machine: %s\u0022,\n       rcl_get_error_string().str);\n     return RCL_RET_ERROR;\n   }\n \n-  lifecycle_node-\u003Enode = node;\n   lifecycle_node-\u003Estate_machine = state_machine;\n \n\u002B  // Pre-init messages and strings\n\u002B  static char empty_string[RCLC_LIFECYCLE_MAX_STRING_LENGTH];\n\u002B  memset(empty_string, \u0027 \u0027, RCLC_LIFECYCLE_MAX_STRING_LENGTH);\n\u002B  empty_string[RCLC_LIFECYCLE_MAX_STRING_LENGTH - 1] = \u0027\\0\u0027;\n\u002B\n\u002B  lifecycle_msgs__srv__ChangeState_Request__init(\u0026lifecycle_node-\u003Ecs_req);\n\u002B  lifecycle_msgs__srv__ChangeState_Response__init(\u0026lifecycle_node-\u003Ecs_res);\n\u002B\n\u002B  lifecycle_msgs__srv__GetState_Request__init(\u0026lifecycle_node-\u003Egs_req);\n\u002B  lifecycle_msgs__srv__GetState_Response__init(\u0026lifecycle_node-\u003Egs_res);\n\u002B  rosidl_runtime_c__String__assign(\n\u002B    \u0026lifecycle_node-\u003Egs_res.current_state.label,\n\u002B    (const char *) empty_string);\n\u002B\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Request__init(\u0026lifecycle_node-\u003Egas_req);\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Response__init(\u0026lifecycle_node-\u003Egas_res);\n\u002B  lifecycle_msgs__msg__State__Sequence__init(\n\u002B    \u0026lifecycle_node-\u003Egas_res.available_states,\n\u002B    state_machine-\u003Etransition_map.states_size);\n\u002B  lifecycle_node-\u003Egas_res.available_states.size = 0;\n\u002B  for (size_t i = 0; i \u003C state_machine-\u003Etransition_map.states_size; \u002B\u002Bi) {\n\u002B    rosidl_runtime_c__String__assign(\n\u002B      \u0026lifecycle_node-\u003Egas_res.available_states.data[i].label,\n\u002B      (const char *) empty_string);\n\u002B  }\n\u002B\n   return RCL_RET_OK;\n }\n \n@@ -76,6 \u002B113,9 @@ rclc_lifecycle_change_state(\n   bool publish_update\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   if (rcl_lifecycle_state_machine_is_initialized(lifecycle_node-\u003Estate_machine) != RCL_RET_OK) {\n     RCUTILS_LOG_ERROR(\n       \u0022Unable to change state for state machine: %s\u0022,\n@@ -184,6 \u002B224,9 @@ rclc_lifecycle_register_on_configure(\n   int (* cb)(void)\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    node, \u0022node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   return rclc_lifecycle_register_callback(\n     node,\n     lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n@@ -196,6 \u002B239,9 @@ rclc_lifecycle_register_on_activate(\n   int (* cb)(void)\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    node, \u0022node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   return rclc_lifecycle_register_callback(\n     node,\n     lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n@@ -208,6 \u002B254,9 @@ rclc_lifecycle_register_on_deactivate(\n   int (* cb)(void)\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    node, \u0022node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   return rclc_lifecycle_register_callback(\n     node,\n     lifecycle_msgs__msg__Transition__TRANSITION_DEACTIVATE,\n@@ -220,6 \u002B269,9 @@ rclc_lifecycle_register_on_cleanup(\n   int (* cb)(void)\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    node, \u0022node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   return rclc_lifecycle_register_callback(\n     node,\n     lifecycle_msgs__msg__Transition__TRANSITION_CLEANUP,\n@@ -227,11 \u002B279,16 @@ rclc_lifecycle_register_on_cleanup(\n }\n \n rcl_ret_t\n-rcl_lifecycle_node_fini(\n\u002Brclc_lifecycle_node_fini(\n   rclc_lifecycle_node_t * lifecycle_node,\n   rcl_allocator_t * allocator\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    allocator, \u0022allocator is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   rcl_ret_t rcl_ret = RCL_RET_OK;\n   RCLC_UNUSED(allocator);\n \n@@ -240,14 \u002B297,20 @@ rcl_lifecycle_node_fini(\n     lifecycle_node-\u003Estate_machine,\n     lifecycle_node-\u003Enode);\n   if (rcl_ret != RCL_RET_OK) {\n\u002B    RCUTILS_LOG_ERROR(\n\u002B      \u0022Unable to clean up state machine: %s\u0022,\n\u002B      rcl_get_error_string().str);\n\u002B    rcutils_reset_error();\n     return RCL_RET_ERROR;\n   }\n \n-  // Cleanup node\n-  rcl_ret = rcl_node_fini(lifecycle_node-\u003Enode);\n-  if (rcl_ret != RCL_RET_OK) {\n-    return RCL_RET_ERROR;\n-  }\n\u002B  // Cleanup service messages\n\u002B  lifecycle_msgs__srv__GetState_Request__fini(\u0026lifecycle_node-\u003Egs_req);\n\u002B  lifecycle_msgs__srv__GetState_Response__fini(\u0026lifecycle_node-\u003Egs_res);\n\u002B  lifecycle_msgs__srv__ChangeState_Request__fini(\u0026lifecycle_node-\u003Ecs_req);\n\u002B  lifecycle_msgs__srv__ChangeState_Response__fini(\u0026lifecycle_node-\u003Ecs_res);\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Request__fini(\u0026lifecycle_node-\u003Egas_req);\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Response__fini(\u0026lifecycle_node-\u003Egas_res);\n \n   return rcl_ret;\n }\n@@ -258,6 \u002B321,9 @@ rclc_lifecycle_execute_callback(\n   unsigned int transition_id\n )\n {\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n   if (!lifecycle_node-\u003Ecallbacks.goal_states[transition_id]) {\n     // no callback, so process, all good\n     return RCL_RET_OK;\n@@ -265,3 \u002B331,168 @@ rclc_lifecycle_execute_callback(\n \n   return (*lifecycle_node-\u003Ecallbacks.fun_ptrs[transition_id])();\n }\n\u002B\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_get_state_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor)\n\u002B{\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    executor, \u0022executor is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  rclc_lifecycle_service_context_t context;\n\u002B  context.lifecycle_node = lifecycle_node;\n\u002B\n\u002B  rcl_ret_t rc = rclc_executor_add_service_with_context(\n\u002B    executor,\n\u002B    \u0026lifecycle_node-\u003Estate_machine-\u003Ecom_interface.srv_get_state,\n\u002B    \u0026lifecycle_node-\u003Egs_req,\n\u002B    \u0026lifecycle_node-\u003Egs_res,\n\u002B    rclc_lifecycle_get_state_callback,\n\u002B    \u0026context);\n\u002B  if (rc != RCL_RET_OK) {\n\u002B    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n\u002B    return RCL_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  return rc;\n\u002B}\n\u002B\n\u002Bvoid\n\u002Brclc_lifecycle_get_state_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context)\n\u002B{\n\u002B  RCL_UNUSED(req);\n\u002B  lifecycle_msgs__srv__GetState_Response * res_in =\n\u002B    (lifecycle_msgs__srv__GetState_Response *) res;\n\u002B  rclc_lifecycle_service_context_t * context_in =\n\u002B    (rclc_lifecycle_service_context_t *) context;\n\u002B\n\u002B  rcl_lifecycle_state_machine_t * sm =\n\u002B    context_in-\u003Elifecycle_node-\u003Estate_machine;\n\u002B\n\u002B  res_in-\u003Ecurrent_state.id = sm-\u003Ecurrent_state-\u003Eid;\n\u002B  bool success = rosidl_runtime_c__String__assign(\n\u002B    \u0026res_in-\u003Ecurrent_state.label,\n\u002B    sm-\u003Ecurrent_state-\u003Elabel);\n\u002B  if (!success) {\n\u002B    PRINT_RCLC_ERROR(\n\u002B      rclc_lifecycle_get_state_callback,\n\u002B      rosidl_runtime_c__String__assign);\n\u002B  }\n\u002B}\n\u002B\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_get_available_states_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor)\n\u002B{\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    executor, \u0022executor is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  rclc_lifecycle_service_context_t context;\n\u002B  context.lifecycle_node = lifecycle_node;\n\u002B\n\u002B  rcl_ret_t rc = rclc_executor_add_service_with_context(\n\u002B    executor,\n\u002B    \u0026lifecycle_node-\u003Estate_machine-\u003Ecom_interface.srv_get_available_states,\n\u002B    \u0026lifecycle_node-\u003Egas_req,\n\u002B    \u0026lifecycle_node-\u003Egas_res,\n\u002B    rclc_lifecycle_get_available_states_callback,\n\u002B    \u0026context);\n\u002B  if (rc != RCL_RET_OK) {\n\u002B    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n\u002B    return RCL_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  return rc;\n\u002B}\n\u002B\n\u002Bvoid\n\u002Brclc_lifecycle_get_available_states_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context)\n\u002B{\n\u002B  RCL_UNUSED(req);\n\u002B  lifecycle_msgs__srv__GetAvailableStates_Response * res_in =\n\u002B    (lifecycle_msgs__srv__GetAvailableStates_Response *) res;\n\u002B  rclc_lifecycle_service_context_t * context_in =\n\u002B    (rclc_lifecycle_service_context_t *) context;\n\u002B\n\u002B  rcl_lifecycle_state_machine_t * sm =\n\u002B    context_in-\u003Elifecycle_node-\u003Estate_machine;\n\u002B\n\u002B  bool success = true;\n\u002B  res_in-\u003Eavailable_states.size = sm-\u003Etransition_map.states_size;\n\u002B  for (unsigned int i = 0; i \u003C sm-\u003Etransition_map.states_size; \u002B\u002Bi) {\n\u002B    res_in-\u003Eavailable_states.data[i].id = sm-\u003Etransition_map.states[i].id;\n\u002B    success \u0026= rosidl_runtime_c__String__assign(\n\u002B      \u0026res_in-\u003Eavailable_states.data[i].label,\n\u002B      sm-\u003Etransition_map.states[i].label);\n\u002B  }\n\u002B\n\u002B  if (!success) {\n\u002B    PRINT_RCLC_ERROR(\n\u002B      rclc_lifecycle_get_available_states_callback,\n\u002B      rosidl_runtime_c__String__assign);\n\u002B  }\n\u002B}\n\u002B\n\u002Brcl_ret_t\n\u002Brclc_lifecycle_init_change_state_server(\n\u002B  rclc_lifecycle_node_t * lifecycle_node,\n\u002B  rclc_executor_t * executor)\n\u002B{\n\u002B  RCL_CHECK_FOR_NULL_WITH_MSG(\n\u002B    lifecycle_node, \u0022lifecycle_node is a null pointer\u0022, return RCL_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  rclc_lifecycle_service_context_t context;\n\u002B  context.lifecycle_node = lifecycle_node;\n\u002B\n\u002B  rcl_ret_t rc = rclc_executor_add_service_with_context(\n\u002B    executor,\n\u002B    \u0026lifecycle_node-\u003Estate_machine-\u003Ecom_interface.srv_change_state,\n\u002B    \u0026lifecycle_node-\u003Ecs_req,\n\u002B    \u0026lifecycle_node-\u003Ecs_res,\n\u002B    rclc_lifecycle_change_state_callback,\n\u002B    \u0026context);\n\u002B  if (rc != RCL_RET_OK) {\n\u002B    PRINT_RCLC_ERROR(main, rclc_executor_add_service_with_context);\n\u002B    return RCL_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  return rc;\n\u002B}\n\u002B\n\u002Bvoid\n\u002Brclc_lifecycle_change_state_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * context)\n\u002B{\n\u002B  lifecycle_msgs__srv__ChangeState_Request * req_in =\n\u002B    (lifecycle_msgs__srv__ChangeState_Request *) req;\n\u002B  lifecycle_msgs__srv__ChangeState_Response * res_in =\n\u002B    (lifecycle_msgs__srv__ChangeState_Response *) res;\n\u002B  rclc_lifecycle_service_context_t * context_in =\n\u002B    (rclc_lifecycle_service_context_t *) context;\n\u002B\n\u002B  rclc_lifecycle_node_t * ln = context_in-\u003Elifecycle_node;\n\u002B  rcl_ret_t rc = rclc_lifecycle_change_state(ln, req_in-\u003Etransition.id, true);\n\u002B\n\u002B  lifecycle_msgs__srv__ChangeState_Response__init(res_in);\n\u002B  if (rc != RCL_RET_OK) {\n\u002B    PRINT_RCLC_ERROR(\n\u002B      rclc_lifecycle_change_state_callback,\n\u002B      rclc_lifecycle_change_state);\n\u002B    res_in-\u003Esuccess = false;\n\u002B  } else {\n\u002B    res_in-\u003Esuccess = true;\n\u002B  }\n\u002B}\ndiff --git rclc_lifecycle/test/test_lifecycle.cpp rclc_lifecycle/test/test_lifecycle.cpp\nindex d4b481c..ee952ac 100644\n--- rclc_lifecycle/test/test_lifecycle.cpp\n\u002B\u002B\u002B rclc_lifecycle/test/test_lifecycle.cpp\n@@ -65,12 \u002B65,12 @@ TEST(TestRclcLifecycle, lifecycle_node) {\n   res \u002B= rcl_node_init(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026context, \u0026node_ops);\n \n   rclc_lifecycle_node_t lifecycle_node;\n-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n\u002B  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();\n \n   res \u002B= rclc_make_node_a_lifecycle_node(\n     \u0026lifecycle_node,\n     \u0026my_node,\n-    \u0026state_machine_,\n\u002B    \u0026state_machine,\n     \u0026allocator,\n     true);\n \n@@ -102,12 \u002B102,12 @@ TEST(TestRclcLifecycle, lifecycle_node_transitions) {\n   res \u002B= rcl_node_init(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026context, \u0026node_ops);\n \n   rclc_lifecycle_node_t lifecycle_node;\n-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n\u002B  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();\n \n   res \u002B= rclc_make_node_a_lifecycle_node(\n     \u0026lifecycle_node,\n     \u0026my_node,\n-    \u0026state_machine_,\n\u002B    \u0026state_machine,\n     \u0026allocator,\n     false);\n \n@@ -172,12 \u002B172,12 @@ TEST(TestRclcLifecycle, lifecycle_node_callbacks) {\n   res \u002B= rcl_node_init(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026context, \u0026node_ops);\n \n   rclc_lifecycle_node_t lifecycle_node;\n-  rcl_lifecycle_state_machine_t state_machine_ = rcl_lifecycle_get_zero_initialized_state_machine();\n\u002B  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();\n \n   res \u002B= rclc_make_node_a_lifecycle_node(\n     \u0026lifecycle_node,\n     \u0026my_node,\n-    \u0026state_machine_,\n\u002B    \u0026state_machine,\n     \u0026allocator,\n     true);\n \n@@ -192,19 \u002B192,27 @@ TEST(TestRclcLifecycle, lifecycle_node_callbacks) {\n     \u0026lifecycle_node,\n     lifecycle_msgs__msg__Transition__TRANSITION_CONFIGURE,\n     true);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  EXPECT_EQ(1, callback_mockup_counter);\n\u002B\n   res \u002B= rclc_lifecycle_change_state(\n     \u0026lifecycle_node,\n     lifecycle_msgs__msg__Transition__TRANSITION_ACTIVATE,\n     true);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  EXPECT_EQ(3, callback_mockup_counter);\n\u002B\n   res \u002B= rclc_lifecycle_change_state(\n     \u0026lifecycle_node,\n     lifecycle_msgs__msg__Transition__TRANSITION_DEACTIVATE,\n     true);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  EXPECT_EQ(7, callback_mockup_counter);\n\u002B\n   res \u002B= rclc_lifecycle_change_state(\n     \u0026lifecycle_node,\n     lifecycle_msgs__msg__Transition__TRANSITION_CLEANUP,\n     true);\n-\n   EXPECT_EQ(RCL_RET_OK, res);\n   EXPECT_EQ(15, callback_mockup_counter);\n \n@@ -215,3 \u002B223,68 @@ TEST(TestRclcLifecycle, lifecycle_node_callbacks) {\n   res = rcl_init_options_fini(\u0026init_options);\n   EXPECT_EQ(RCL_RET_OK, res);\n }\n\u002B\n\u002BTEST(TestRclcLifecycle, lifecycle_node_servers) {\n\u002B  rcl_context_t context = rcl_get_zero_initialized_context();\n\u002B  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n\u002B  rcl_allocator_t allocator = rcl_get_default_allocator();\n\u002B\n\u002B  rcl_ret_t res = rcl_init_options_init(\u0026init_options, allocator);\n\u002B  res \u002B= rcl_init(0, nullptr, \u0026init_options, \u0026context);\n\u002B\n\u002B  rcl_node_t my_node = rcl_get_zero_initialized_node();\n\u002B  rcl_node_options_t node_ops = rcl_node_get_default_options();\n\u002B  res \u002B= rcl_node_init(\u0026my_node, \u0022lifecycle_node\u0022, \u0022rclc\u0022, \u0026context, \u0026node_ops);\n\u002B\n\u002B  rclc_lifecycle_node_t lifecycle_node;\n\u002B  rcl_lifecycle_state_machine_t state_machine = rcl_lifecycle_get_zero_initialized_state_machine();\n\u002B\n\u002B  res \u002B= rclc_make_node_a_lifecycle_node(\n\u002B    \u0026lifecycle_node,\n\u002B    \u0026my_node,\n\u002B    \u0026state_machine,\n\u002B    \u0026allocator,\n\u002B    true);\n\u002B\n\u002B  // register callbacks\n\u002B  rclc_lifecycle_register_on_configure(\u0026lifecycle_node, \u0026callback_mockup_0);\n\u002B  rclc_lifecycle_register_on_activate(\u0026lifecycle_node, \u0026callback_mockup_1);\n\u002B  rclc_lifecycle_register_on_deactivate(\u0026lifecycle_node, \u0026callback_mockup_2);\n\u002B  rclc_lifecycle_register_on_cleanup(\u0026lifecycle_node, \u0026callback_mockup_3);\n\u002B\n\u002B  // create lifecycle servers\n\u002B  rclc_executor_t executor;\n\u002B  res = rclc_executor_init(\n\u002B    \u0026executor,\n\u002B    \u0026context,\n\u002B    1,  // too little\n\u002B    \u0026allocator);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B\n\u002B  // Too little executor handles\n\u002B  res = rclc_lifecycle_init_get_state_server(\u0026lifecycle_node, \u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  res = rclc_lifecycle_init_get_available_states_server(\u0026lifecycle_node, \u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_ERROR, res);\n\u002B\n\u002B  // Now with correct number of handles\n\u002B  rclc_executor_init(\n\u002B    \u0026executor,\n\u002B    \u0026context,\n\u002B    3,  // 1 for each lifecycle service\n\u002B    \u0026allocator);\n\u002B  res = rclc_lifecycle_init_get_state_server(\u0026lifecycle_node, \u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  res = rclc_lifecycle_init_get_available_states_server(\u0026lifecycle_node, \u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  res = rclc_lifecycle_init_change_state_server(\u0026lifecycle_node, \u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B\n\u002B  // Cleanup\n\u002B  res = rclc_lifecycle_node_fini(\u0026lifecycle_node, \u0026allocator);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  res = rcl_node_fini(\u0026my_node);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B  res = rclc_executor_fini(\u0026executor);\n\u002B  EXPECT_EQ(RCL_RET_OK, res);\n\u002B}\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "938d7d10de56528a32de020ebb9e5d56b5b24076",
    "RawMessage": "Use the new rmw_dds_common::get_security_files API (#61)",
    "Changes": "diff --git rmw_connextdds_common/src/common/rmw_context.cpp rmw_connextdds_common/src/common/rmw_context.cpp\nindex c6ee6f4..5410204 100644\n--- rmw_connextdds_common/src/common/rmw_context.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_context.cpp\n@@ -15,11 \u002B15,14 @@\n #include \u003Cfunctional\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cunordered_map\u003E\n \n #include \u0022rmw_connextdds/rmw_impl.hpp\u0022\n #include \u0022rmw_connextdds/discovery.hpp\u0022\n #include \u0022rmw_connextdds/graph_cache.hpp\u0022\n \n\u002B#include \u0022rmw_dds_common/security.hpp\u0022\n\u002B\n #include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/filesystem.h\u0022\n \n@@ -1117,10 \u002B1120,6 @@ rmw_connextdds_configure_security(\n     return rc;\n   }\n \n-  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n-  rcutils_allocator_t * const allocator_ptr = \u0026allocator;\n-  std::ostringstream ss;\n-  std::string prop_uri;\n #if !RMW_CONNEXT_DDS_API_PRO_LEGACY\n   static const char * const uri_prefix = \u0022file:\u0022;\n #else\n@@ -1128,168 \u002B1127,97 @@ rmw_connextdds_configure_security(\n   static const char * const uri_prefix = \u0022\u0022;\n #endif /* !RMW_CONNEXT_DDS_API_PRO_LEGACY */\n \n-  char * const prop_identity_ca =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022identity_ca.cert.pem\u0022,\n-    allocator);\n-  auto scope_exit_prop_identity_ca = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_identity_ca]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_identity_ca, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_identity_ca;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n\u002B  std::unordered_map\u003Cstd::string, std::string\u003E security_files;\n\u002B  if (!rmw_dds_common::get_security_files(\n\u002B      uri_prefix, ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path, security_files))\n\u002B  {\n\u002B    RMW_CONNEXT_LOG_ERROR(\u0022couldn\u0027t find all security files\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n   /* X509 Certificate of the Identity CA */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_IDENTITY_CA_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022IDENTITY_CA\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_IDENTITY_CA_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_IDENTITY_CA_PROPERTY, security_files[\u0022IDENTITY_CA\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n \n-  char * const prop_perm_ca =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022permissions_ca.cert.pem\u0022,\n-    allocator);\n-  auto scope_exit_prop_perm_ca = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_perm_ca]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_perm_ca, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_perm_ca;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n   /* X509 Certificate of the Permissions CA */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PERMISSIONS_CA_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022PERMISSIONS_CA\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PERMISSIONS_CA_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_PERMISSIONS_CA_PROPERTY, security_files[\u0022PERMISSIONS_CA\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n \n-  char * const prop_peer_key =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022key.pem\u0022,\n-    allocator);\n-  auto scope_exit_prop_peer_key = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_peer_key]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_peer_key, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_peer_key;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n   /* Private Key of the DomainParticipant\u0027s identity */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PRIVATE_KEY_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022PRIVATE_KEY\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PRIVATE_KEY_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_PRIVATE_KEY_PROPERTY, security_files[\u0022PRIVATE_KEY\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n \n-  char * const prop_peer_cert =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022cert.pem\u0022,\n-    allocator);\n-  auto scope_exit_prop_peer_cert = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_peer_cert]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_peer_cert, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_peer_cert;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n   /* Public certificate of the DomainParticipant\u0027s identity, signed\n    * by the Certificate Authority */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022CERTIFICATE\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_IDENTITY_CERTIFICATE_PROPERTY, security_files[\u0022CERTIFICATE\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n-\n-  char * const prop_governance =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022governance.p7s\u0022,\n-    allocator);\n-  auto scope_exit_prop_governance = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_governance]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_governance, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_governance;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n   /* XML file containing domain governance configuration, signed by\n    * the Permission CA */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_GOVERNANCE_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022GOVERNANCE\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_GOVERNANCE_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_GOVERNANCE_PROPERTY, security_files[\u0022GOVERNANCE\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n \n-  char * const prop_permissions =\n-    rcutils_join_path(\n-    ctx-\u003Ebase-\u003Eoptions.security_options.security_root_path,\n-    \u0022permissions.p7s\u0022,\n-    allocator);\n-  auto scope_exit_prop_permissions = rcpputils::make_scope_exit(\n-    [allocator_ptr, prop_permissions]()\n-    {\n-      allocator_ptr-\u003Edeallocate(prop_permissions, allocator_ptr-\u003Estate);\n-    });\n-  ss \u003C\u003C uri_prefix \u003C\u003C prop_permissions;\n-  prop_uri = ss.str();\n-  ss.str(\u0022\u0022);\n   /* XML file containing domain permissions configuration, signed by\n    * the Permission CA */\n   if (DDS_RETCODE_OK !=\n     DDS_PropertyQosPolicyHelper_assert_property(\n       \u0026qos-\u003Eproperty,\n       DDS_SECURITY_PERMISSIONS_PROPERTY,\n-      prop_uri.c_str(),\n\u002B      security_files[\u0022PERMISSIONS\u0022].c_str(),\n       RTI_FALSE))\n   {\n     RMW_CONNEXT_LOG_ERROR_A_SET(\n       \u0022failed to assert DDS property: \u0027%s\u0027 = \u0027%s\u0027\u0022,\n-      DDS_SECURITY_PERMISSIONS_PROPERTY, prop_uri.c_str())\n\u002B      DDS_SECURITY_PERMISSIONS_PROPERTY, security_files[\u0022PERMISSIONS\u0022].c_str())\n     return RMW_RET_ERROR;\n   }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "31c537f27dfffc6ebbacb0d03648e73a47ee1e07",
    "RawMessage": "Don\u0027t install python tf2_geometry_msgs (#299)",
    "Changes": "diff --git tf2_geometry_msgs/CMakeLists.txt tf2_geometry_msgs/CMakeLists.txt\nindex 39c4cc04..a427ac4b 100644\n--- tf2_geometry_msgs/CMakeLists.txt\n\u002B\u002B\u002B tf2_geometry_msgs/CMakeLists.txt\n@@ -18,10 \u002B18,11 @@ set(required_dependencies\n )\n ament_auto_find_build_dependencies(REQUIRED ${required_dependencies})\n \n-ament_python_install_package(${PROJECT_NAME}\n-     PACKAGE_DIR src/${PROJECT_NAME})\n\u002B# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n\u002B# ament_python_install_package(${PROJECT_NAME}\n\u002B#      PACKAGE_DIR src/${PROJECT_NAME})\n \n-# TODO (ahcorde) Port python once https://github.com/ros2/orocos_kinematics_dynamics/pull/4 is merged\n\u002B# TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n # install(PROGRAMS scripts/test.py\n #    DESTINATION lib/${PROJECT_NAME}\n # )\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "4b3a05eb729a03d17bf4dc24303162f1cd4a3439",
    "RawMessage": "Update is_type_self_contained",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/TypeSupport_impl.hpp rmw_cyclonedds_cpp/src/TypeSupport_impl.hpp\nindex a8d30bf..11ab6be 100644\n--- rmw_cyclonedds_cpp/src/TypeSupport_impl.hpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/TypeSupport_impl.hpp\n@@ -502,7 \u002B502,6 @@ std::string TypeSupport\u003CMembersType\u003E::getName()\n template\u003Ctypename MembersType\u003E\n bool TypeSupport\u003CMembersType\u003E::is_type_self_contained(const MembersType * members)\n {\n-  bool ret = true;\n   for (uint32_t idx = 0; idx \u003C members-\u003Emember_count_; \u002B\u002Bidx) {\n     const auto member = members-\u003Emembers_[idx];\n     // if the message is not self contained,\n@@ -514,15 \u002B513,17 @@ bool TypeSupport\u003CMembersType\u003E::is_type_self_contained(const MembersType * member\n       // bounded sequence =\u003E is_array = true, array size \u003E 0, upper_bound = 1\n       (member.is_array_ \u0026\u0026 (!member.array_size_ || member.is_upper_bound_)))\n     {\n-      ret \u0026= false;  // type is not self contained\n\u002B      return false;  // type is not self contained\n     } else if (member.type_id_ == ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE) {\n       // handle nested messages\n       auto sub_members = (const MembersType *)member.members_-\u003Edata;\n-      ret \u0026= is_type_self_contained(sub_members);\n\u002B      if (!is_type_self_contained(sub_members)) {\n\u002B        return false;\n\u002B      }\n     }\n   }\n \n-  return ret;\n\u002B  return true;\n }\n \n template\u003Ctypename MembersType\u003E\ndiff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 17cd9d5..e7d853a 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1185,7 \u002B1185,7 @@ static void * init_and_alloc_sample(\n     return nullptr);\n   auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n   ice_hdr-\u003Edata_size = sample_size;\n-  auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n\u002B  auto ptr = SHIFT_PAST_ICEORYX_HEADER(chunk_ptr);\n   // initialize the memory for message\n   rmw_cyclonedds_cpp::init_message(\u0026entity-\u003Etype_supports, ptr);\n   return ptr;\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "936a5a045de0fb635d8023f198c44baba3f4058e",
    "RawMessage": "add doc section for Zero Copy Data Sharing. (#718)",
    "Changes": "diff --git README.md README.md\nindex b8fa2f4..9b8dcc5 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -40,6 \u002B40,7 @@ However, \u0060rmw_fastrtps\u0060 offers the possibility to further configure Fast DDS:\n * [Change publication mode](#change-publication-mode)\n * [Full QoS configuration](#full-qos-configuration)\n * [Change participant discovery options](#change-participant-discovery-options)\n\u002B* [Enable Zero Copy Data Sharing](#enable-zero-copy-data-sharing)\n \n ### Change publication mode\n \n@@ -234,6 \u002B235,40 @@ ROS 2 allows controlling participant discovery with two environment variables: \u0060\n Full configuration of participant discovery can also be set with XML files; however, the ROS specific environment variables should be disabled to prevent them from interfering.\n Set \u0060ROS_AUTOMATIC_DISCOVERY_RANGE\u0060 to the value \u0060SYSTEM_DEFAULT\u0060 to disable both ROS specific environment variables.\n \n\u002B### Enable Zero Copy Data Sharing\n\u002B\n\u002BROS 2 provides [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) that allows the user application to loan the message memory from the RMW implementation to eliminate the copy between the ROS 2 application and RMW implementation.\n\u002BAnd Fast DDS \u0060rmw_fastrtps_cpp\u0060 provides [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) features to speed up the localhost communication.\n\u002BTaking advantage of these features all together, it provides significant performance improvement to ROS 2 application.\n\u002B\n\u002BBy default, \u0060rmw_fastrtps_cpp\u0060 tries to use [Shared Memory Transport](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/shared_memory/shared_memory.html) and [Data-sharing delivery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/datasharing.html) for localhost communication along with network communication if the message data type is a bounded type (a fixed sized data object).\n\u002B\n\u002BTo enable [Loaned Messages](https://design.ros2.org/articles/zero_copy.html) with \u0060rmw_fastrtps_cpp\u0060, [Plain Old Data](https://en.wikipedia.org/wiki/Passive_data_structure) is the only requirement to \u0060Iron Irwini\u0060 or later.\n\u002BFor \u0060Humble Hawksbill\u0060, the following XML file needs to be applied to set Fast-DDS \u0060data_sharing\u0060 is explicitly enabled. (see more details for https://github.com/ros2/rmw_fastrtps/pull/568)\n\u002B\n\u002B\u0060\u0060\u0060xml\n\u002B\u003C?xml version=\u00221.0\u0022 encoding=\u0022UTF-8\u0022 ?\u003E\n\u002B\u003Cprofiles xmlns=\u0022http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\u0022\u003E\n\u002B\n\u002B  \u003C!-- Default publisher profile --\u003E\n\u002B  \u003Cdata_writer profile_name=\u0022default publisher profile\u0022 is_default_profile=\u0022true\u0022\u003E\n\u002B    \u003Cqos\u003E\n\u002B      \u003Cdata_sharing\u003E\n\u002B        \u003Ckind\u003EAUTOMATIC\u003C/kind\u003E\n\u002B      \u003C/data_sharing\u003E\n\u002B    \u003C/qos\u003E\n\u002B  \u003C/data_writer\u003E\n\u002B\n\u002B  \u003Cdata_reader profile_name=\u0022default subscription profile\u0022 is_default_profile=\u0022true\u0022\u003E\n\u002B    \u003Cqos\u003E\n\u002B      \u003Cdata_sharing\u003E\n\u002B        \u003Ckind\u003EAUTOMATIC\u003C/kind\u003E\n\u002B      \u003C/data_sharing\u003E\n\u002B    \u003C/qos\u003E\n\u002B  \u003C/data_reader\u003E\n\u002B\u003C/profiles\u003E\n\u002B\u0060\u0060\u0060\n\u002B\n ## Quality Declaration files\n \n Quality Declarations for each package in this repository:\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "4b957f8789e4b040fc8ad1fe8bffb3882c895f80",
    "RawMessage": "Fix segfault on changing filter size for non-existent topic (#597)",
    "Changes": "diff --git rviz_common/include/rviz_common/message_filter_display.hpp rviz_common/include/rviz_common/message_filter_display.hpp\nindex 72b2d1e0..2ad352c7 100644\n--- rviz_common/include/rviz_common/message_filter_display.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/message_filter_display.hpp\n@@ -126,7 \u002B126,9 @@ protected:\n       tf_filter_ =\n         std::make_shared\u003Ctf2_ros::MessageFilter\u003CMessageType, transformation::FrameTransformer\u003E\u003E(\n         *context_-\u003EgetFrameManager()-\u003EgetTransformer(),\n-        fixed_frame_.toStdString(), 10, rviz_ros_node_.lock()-\u003Eget_raw_node());\n\u002B        fixed_frame_.toStdString(),\n\u002B        static_cast\u003Cuint32_t\u003E(message_queue_property_-\u003EgetInt()),\n\u002B        rviz_ros_node_.lock()-\u003Eget_raw_node());\n       tf_filter_-\u003EconnectInput(*subscription_);\n       tf_filter_-\u003EregisterCallback(\n         std::bind(\n@@ -141,7 \u002B143,9 @@ protected:\n \n   void updateMessageQueueSize()\n   {\n-    tf_filter_-\u003EsetQueueSize(static_cast\u003Cuint32_t\u003E(message_queue_property_-\u003EgetInt()));\n\u002B    if (tf_filter_) {\n\u002B      tf_filter_-\u003EsetQueueSize(static_cast\u003Cuint32_t\u003E(message_queue_property_-\u003EgetInt()));\n\u002B    }\n   }\n \n   void transformerChangedCallback() override\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "e06969487b81d97745f7c2da16372075ef153c1f",
    "RawMessage": "Set error status when duplicate markers are in the same MarkerArray (#891)",
    "Changes": "diff --git rviz_default_plugins/src/rviz_default_plugins/displays/marker/marker_common.cpp rviz_default_plugins/src/rviz_default_plugins/displays/marker/marker_common.cpp\nindex 9e048750..bf4efbb8 100644\n--- rviz_default_plugins/src/rviz_default_plugins/displays/marker/marker_common.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/marker/marker_common.cpp\n@@ -31,6 \u002B31,8 @@\n #include \u0022rviz_default_plugins/displays/marker/marker_common.hpp\u0022\n \n #include \u003Cmemory\u003E\n\u002B#include \u003Cset\u003E\n\u002B#include \u003Csstream\u003E\n #include \u003Cstring\u003E\n #include \u003Cutility\u003E\n #include \u003Cvector\u003E\n@@ -153,9 \u002B155,41 @@ void MarkerCommon::addMessage(const visualization_msgs::msg::Marker::ConstShared\n void MarkerCommon::addMessage(\n   const visualization_msgs::msg::MarkerArray::ConstSharedPtr array)\n {\n\u002B  using ns_type = decltype(visualization_msgs::msg::Marker::ns);\n\u002B  using id_type = decltype(visualization_msgs::msg::Marker::id);\n\u002B  using pair_type = std::pair\u003Cid_type, const ns_type \u0026\u003E;\n\u002B\n\u002B  // Keep track of unique markers\n\u002B  std::set\u003Cpair_type\u003E unique_markers;\n\u002B  bool found_duplicate = false;\n\u002B  std::string offending_ns;\n\u002B  id_type offending_id = 0;\n\u002B\n   for (auto const \u0026 marker : array-\u003Emarkers) {\n\u002B    if (!found_duplicate) {\n\u002B      pair_type pair(marker.id, marker.ns);\n\u002B      found_duplicate = !unique_markers.insert(pair).second;\n\u002B      if (found_duplicate) {\n\u002B        offending_ns = marker.ns;\n\u002B        offending_id = marker.id;\n\u002B      }\n\u002B    }\n     addMessage(std::make_shared\u003Cvisualization_msgs::msg::Marker\u003E(marker));\n   }\n\u002B\n\u002B  // Can\u0027t use setMarkerStatus on individual markers because processAdd would clear it.\n\u002B  const char * kDuplicateStatus = \u0022Duplicate Marker Check\u0022;\n\u002B  if (found_duplicate) {\n\u002B    std::stringstream error_stream;\n\u002B    error_stream \u003C\u003C \u0022Multiple Markers in the same MarkerArray message had the same ns and id: \u0022;\n\u002B    error_stream \u003C\u003C \u0022(\u0022 \u003C\u003C offending_ns \u003C\u003C \u0022, \u0022 \u003C\u003C offending_id \u003C\u003C \u0022)\u0022;\n\u002B    display_-\u003EsetStatusStd(\n\u002B      rviz_common::properties::StatusProperty::Error,\n\u002B      kDuplicateStatus,\n\u002B      error_stream.str());\n\u002B  } else {\n\u002B    display_-\u003EdeleteStatusStd(kDuplicateStatus);\n\u002B  }\n }\n \n // TODO(greimela): Revisit after MessageFilter is available in ROS2\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "b949fe767f61ef42dcce3a6445427b4cde93de96",
    "RawMessage": "Fix documented range (#139)",
    "Changes": "diff --git builtin_interfaces/msg/Duration.msg builtin_interfaces/msg/Duration.msg\nindex fab5e4f..e6734af 100644\n--- builtin_interfaces/msg/Duration.msg\n\u002B\u002B\u002B builtin_interfaces/msg/Duration.msg\n@@ -5,5 \u002B5,5 @@\n # Seconds component, range is valid over any possible int32 value.\n int32 sec\n \n-# Nanoseconds component in the range of [0, 10e9).\n\u002B# Nanoseconds component in the range of [0, 1e9).\n uint32 nanosec\ndiff --git builtin_interfaces/msg/Time.msg builtin_interfaces/msg/Time.msg\nindex 874f15e..dffade0 100644\n--- builtin_interfaces/msg/Time.msg\n\u002B\u002B\u002B builtin_interfaces/msg/Time.msg\n@@ -4,5 \u002B4,5 @@\n # The seconds component, valid over all int32 values.\n int32 sec\n \n-# The nanoseconds component, valid in the range [0, 10e9).\n\u002B# The nanoseconds component, valid in the range [0, 1e9).\n uint32 nanosec\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "cd63e71f9d0a1f9c303c42c8c0f609882d4906d8",
    "RawMessage": "reset current line width when calculating text width (#655)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/objects/movable_text.cpp rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\nindex 7c9df6fb..5458b115 100644\n--- rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\n@@ -390,6 \u002B390,7 @@ MovableText::calculateTotalDimensionsForPositioning(float \u0026 total_height, float\n     if (character == \u0027\\n\u0027) {\n       total_height \u002B= effective_char_height \u002B line_spacing_;\n       total_width = current_width \u003E total_width ? current_width : total_width;\n\u002B      current_width = 0;\n     } else if (character == \u0027 \u0027) {\n       current_width \u002B= space_width_;\n     } else {\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "250d820c9f6a0ed60176b0f2dd428097581a68cc",
    "RawMessage": "Stop compiling rcl_action tests multiple times. (#1165)",
    "Changes": "diff --git rcl_action/CMakeLists.txt rcl_action/CMakeLists.txt\nindex 9055f11..c4686c2 100644\n--- rcl_action/CMakeLists.txt\n\u002B\u002B\u002B rcl_action/CMakeLists.txt\n@@ -102,47 \u002B102,56 @@ if(BUILD_TESTING)\n     target_compile_definitions(test_action_client PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n   endif()\n \n-  # get the rmw implementations ahead of time\n-  find_package(rmw_implementation_cmake REQUIRED)\n-  get_available_rmw_implementations(rmw_implementations)\n-  foreach(rmw_implementation ${rmw_implementations})\n-    find_package(\u0022${rmw_implementation}\u0022 REQUIRED)\n-  endforeach()\n-\n-  function(custom_test_c target)\n-    ament_add_gtest(\n-      \u0022${target}${target_suffix}\u0022 ${ARGN}\n-      TIMEOUT 180\n-      ENV\n-      RCL_ASSERT_RMW_ID_MATCHES=${rmw_implementation}\n-      RMW_IMPLEMENTATION=${rmw_implementation}\n\u002B  ament_add_gtest_executable(test_action_communication test/rcl_action/test_action_communication.cpp)\n\u002B  target_link_libraries(test_action_communication\n\u002B    ${PROJECT_NAME}\n\u002B    ${action_msgs_TARGETS}\n\u002B    osrf_testing_tools_cpp::memory_tools\n\u002B    rcl::rcl\n\u002B    rosidl_runtime_c::rosidl_runtime_c\n\u002B    ${test_msgs_TARGETS})\n\u002B\n\u002B  ament_add_gtest_executable(test_action_interaction test/rcl_action/test_action_interaction.cpp)\n\u002B  target_link_libraries(test_action_interaction\n\u002B    ${PROJECT_NAME}\n\u002B    ${action_msgs_TARGETS}\n\u002B    osrf_testing_tools_cpp::memory_tools\n\u002B    rcl::rcl\n\u002B    rosidl_runtime_c::rosidl_runtime_c\n\u002B    ${test_msgs_TARGETS})\n\u002B\n\u002B  ament_add_gtest_executable(test_graph test/rcl_action/test_graph.cpp)\n\u002B  target_compile_definitions(test_graph PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n\u002B  target_link_libraries(test_graph\n\u002B    ${PROJECT_NAME}\n\u002B    ${action_msgs_TARGETS}\n\u002B    osrf_testing_tools_cpp::memory_tools\n\u002B    rcl::rcl\n\u002B    rcutils::rcutils\n\u002B    rosidl_runtime_c::rosidl_runtime_c\n\u002B    ${test_msgs_TARGETS})\n\u002B\n\u002B  function(test_targets)\n\u002B    message(STATUS \u0022Creating tests for \u0027${rmw_implementation}\u0027\u0022)\n\u002B    set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n\u002B\n\u002B    ament_add_gtest_test(test_action_communication\n\u002B      TEST_NAME test_action_communication${target_suffix}\n\u002B      ENV ${rmw_implementation_env_var}\n     )\n-    if(TARGET ${target}${target_suffix})\n-      target_compile_definitions(${target}${target_suffix}\n-        PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n-        target_compile_definitions(${target}${target_suffix}\n-          PUBLIC RCUTILS_ENABLE_FAULT_INJECTION)\n-      target_link_libraries(${target}${target_suffix}\n-        ${PROJECT_NAME}\n-        osrf_testing_tools_cpp::memory_tools\n-        rcl::rcl\n-        rosidl_runtime_c::rosidl_runtime_c\n-        ${test_msgs_TARGETS}\n-      )\n-    endif()\n-  endfunction()\n \n-  macro(targets)\n-    custom_test_c(test_action_communication\n-      \u0022test/rcl_action/test_action_communication.cpp\u0022)\n-    custom_test_c(test_action_interaction\n-      \u0022test/rcl_action/test_action_interaction.cpp\u0022)\n\u002B    ament_add_gtest_test(test_action_interaction\n\u002B      TEST_NAME test_action_interaction${target_suffix}\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n \n-    custom_test_c(test_graph\n-      \u0022test/rcl_action/test_graph.cpp\u0022)\n-  endmacro()\n\u002B    ament_add_gtest_test(test_graph\n\u002B      TEST_NAME test_graph${target_suffix}\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n\u002B  endfunction()\n \n-  call_for_each_rmw_implementation(targets)\n\u002B  call_for_each_rmw_implementation(test_targets)\n \n   ament_add_gtest(test_action_server\n     test/rcl_action/test_action_server.cpp\ndiff --git rcl_action/test/rcl_action/test_action_communication.cpp rcl_action/test/rcl_action/test_action_communication.cpp\nindex c13685e..e2ae3e5 100644\n--- rcl_action/test/rcl_action/test_action_communication.cpp\n\u002B\u002B\u002B rcl_action/test/rcl_action/test_action_communication.cpp\n@@ -27,16 \u002B27,11 @@\n \n #include \u0022rosidl_runtime_c/primitives_sequence_functions.h\u0022\n \n-#include \u0022test_msgs/action/fibonacci.h\u0022\n\u002B#include \u0022action_msgs/srv/cancel_goal.h\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n\u002B#include \u0022test_msgs/action/fibonacci.h\u0022\n \n-class CLASSNAME (TestActionCommunication, RMW_IMPLEMENTATION) : public ::testing::Test\n\u002Bclass TestActionCommunication : public ::testing::Test\n {\n protected:\n   void SetUp() override\n@@ -182,7 \u002B177,7 @@ protected:\n   bool is_result_response_ready;\n };  // class TestActionCommunication\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_goal_comm)\n\u002BTEST_F(TestActionCommunication, test_valid_goal_comm)\n {\n   test_msgs__action__Fibonacci_SendGoal_Request outgoing_goal_request;\n   test_msgs__action__Fibonacci_SendGoal_Request incoming_goal_request;\n@@ -288,8 \u002B283,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_goal_c\n   test_msgs__action__Fibonacci_SendGoal_Response__fini(\u0026outgoing_goal_response);\n }\n \n-\n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_cancel_comm)\n\u002BTEST_F(TestActionCommunication, test_valid_cancel_comm)\n {\n   action_msgs__srv__CancelGoal_Request outgoing_cancel_request;\n   action_msgs__srv__CancelGoal_Request incoming_cancel_request;\n@@ -416,7 \u002B410,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_cancel\n   action_msgs__srv__CancelGoal_Response__fini(\u0026outgoing_cancel_response);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_result_comm)\n\u002BTEST_F(TestActionCommunication, test_valid_result_comm)\n {\n   test_msgs__action__Fibonacci_GetResult_Request outgoing_result_request;\n   test_msgs__action__Fibonacci_GetResult_Request incoming_result_request;\n@@ -531,7 \u002B525,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_result\n   test_msgs__action__Fibonacci_GetResult_Response__fini(\u0026outgoing_result_response);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_status_comm)\n\u002BTEST_F(TestActionCommunication, test_valid_status_comm)\n {\n   action_msgs__msg__GoalStatusArray incoming_status_array;\n   action_msgs__msg__GoalStatusArray__init(\u0026incoming_status_array);\n@@ -607,7 \u002B601,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_status\n   EXPECT_EQ(RCL_RET_OK, rcl_action_goal_handle_fini(goal_handle));\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_feedback_comm)\n\u002BTEST_F(TestActionCommunication, test_valid_feedback_comm)\n {\n   test_msgs__action__Fibonacci_FeedbackMessage outgoing_feedback;\n   test_msgs__action__Fibonacci_FeedbackMessage incoming_feedback;\n@@ -670,7 \u002B664,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_feedba\n   test_msgs__action__Fibonacci_FeedbackMessage__fini(\u0026outgoing_feedback);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal_request_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_goal_request_opts)\n {\n   test_msgs__action__Fibonacci_SendGoal_Request outgoing_goal_request;\n   test_msgs__action__Fibonacci_SendGoal_Request incoming_goal_request;\n@@ -727,7 \u002B721,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal\n   test_msgs__action__Fibonacci_SendGoal_Request__fini(\u0026incoming_goal_request);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal_response_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_goal_response_opts)\n {\n   test_msgs__action__Fibonacci_SendGoal_Response outgoing_goal_response;\n   test_msgs__action__Fibonacci_SendGoal_Response incoming_goal_response;\n@@ -788,7 \u002B782,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_goal\n   test_msgs__action__Fibonacci_SendGoal_Response__fini(\u0026outgoing_goal_response);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_cancel_request_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_cancel_request_opts)\n {\n   action_msgs__srv__CancelGoal_Request outgoing_cancel_request;\n   action_msgs__srv__CancelGoal_Request incoming_cancel_request;\n@@ -846,8 \u002B840,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_canc\n   action_msgs__srv__CancelGoal_Request__fini(\u0026outgoing_cancel_request);\n }\n \n-\n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_cancel_response_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_cancel_response_opts)\n {\n   action_msgs__srv__CancelGoal_Response outgoing_cancel_response;\n   action_msgs__srv__CancelGoal_Response incoming_cancel_response;\n@@ -910,7 \u002B903,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_canc\n   action_msgs__srv__CancelGoal_Response__fini(\u0026outgoing_cancel_response);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_result_request_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_result_request_opts)\n {\n   test_msgs__action__Fibonacci_GetResult_Request outgoing_result_request;\n   test_msgs__action__Fibonacci_GetResult_Request incoming_result_request;\n@@ -966,7 \u002B959,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_resu\n   test_msgs__action__Fibonacci_GetResult_Request__fini(\u0026outgoing_result_request);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_result_response_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_result_response_opts)\n {\n   test_msgs__action__Fibonacci_GetResult_Response outgoing_result_response;\n   test_msgs__action__Fibonacci_GetResult_Response incoming_result_response;\n@@ -1029,7 \u002B1022,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_resu\n   test_msgs__action__Fibonacci_GetResult_Response__fini(\u0026outgoing_result_response);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_feedback_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_feedback_opts)\n {\n   test_msgs__action__Fibonacci_FeedbackMessage outgoing_feedback;\n   test_msgs__action__Fibonacci_FeedbackMessage incoming_feedback;\n@@ -1081,7 \u002B1074,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_feed\n   test_msgs__action__Fibonacci_FeedbackMessage__fini(\u0026outgoing_feedback);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_status_opts)\n\u002BTEST_F(TestActionCommunication, test_invalid_status_opts)\n {\n   action_msgs__msg__GoalStatusArray incoming_status_array;\n   action_msgs__msg__GoalStatusArray__init(\u0026incoming_status_array);\n@@ -1130,7 \u002B1123,7 @@ TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_invalid_stat\n   action_msgs__msg__GoalStatusArray__fini(\u0026incoming_status_array);\n }\n \n-TEST_F(CLASSNAME(TestActionCommunication, RMW_IMPLEMENTATION), test_valid_feedback_comm_maybe_fail)\n\u002BTEST_F(TestActionCommunication, test_valid_feedback_comm_maybe_fail)\n {\n   test_msgs__action__Fibonacci_FeedbackMessage outgoing_feedback;\n   test_msgs__action__Fibonacci_FeedbackMessage incoming_feedback;\ndiff --git rcl_action/test/rcl_action/test_action_interaction.cpp rcl_action/test/rcl_action/test_action_interaction.cpp\nindex c9f023b..0e9ba03 100644\n--- rcl_action/test/rcl_action/test_action_interaction.cpp\n\u002B\u002B\u002B rcl_action/test/rcl_action/test_action_interaction.cpp\n@@ -24,16 \u002B24,11 @@\n \n #include \u0022rosidl_runtime_c/primitives_sequence_functions.h\u0022\n \n-#include \u0022test_msgs/action/fibonacci.h\u0022\n\u002B#include \u0022action_msgs/srv/cancel_goal.h\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n\u002B#include \u0022test_msgs/action/fibonacci.h\u0022\n \n-class CLASSNAME (TestActionClientServerInteraction, RMW_IMPLEMENTATION) : public ::testing::Test\n\u002Bclass TestActionClientServerInteraction : public ::testing::Test\n {\n protected:\n   void SetUp() override\n@@ -204,7 \u002B199,7 @@ protected:\n // Following the goal request, the client makes an asynchronous request for the\n // result. The feedback is published to the action client as it executes the goal.\n // Ultimately, a result message is populated which is then used as part of the result response.\n-TEST_F(CLASSNAME(TestActionClientServerInteraction, RMW_IMPLEMENTATION), test_interaction)\n\u002BTEST_F(TestActionClientServerInteraction, test_interaction)\n {\n   // Initialize goal request\n   init_test_uuid0(this-\u003Eoutgoing_goal_request.goal_id.uuid);\n@@ -467,8 \u002B462,7 @@ TEST_F(CLASSNAME(TestActionClientServerInteraction, RMW_IMPLEMENTATION), test_in\n // This example is almost identical to the first, but this time the action client requests\n // for the goal to be canceled mid-execution. Note that it is allowed to perform any shutdown\n // operations after the cancel request before returning with the cancellation result.\n-TEST_F(\n-  CLASSNAME(TestActionClientServerInteraction, RMW_IMPLEMENTATION), test_interaction_with_cancel)\n\u002BTEST_F(TestActionClientServerInteraction, test_interaction_with_cancel)\n {\n   action_msgs__srv__CancelGoal_Request outgoing_cancel_request;\n   action_msgs__srv__CancelGoal_Request incoming_cancel_request;\ndiff --git rcl_action/test/rcl_action/test_graph.cpp rcl_action/test/rcl_action/test_graph.cpp\nindex ea237f1..6e6b432 100644\n--- rcl_action/test/rcl_action/test_graph.cpp\n\u002B\u002B\u002B rcl_action/test/rcl_action/test_graph.cpp\n@@ -30,19 \u002B30,12 @@\n \n #include \u0022test_msgs/action/fibonacci.h\u0022\n \n-#ifdef RMW_IMPLEMENTATION\n-# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n-# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n-#else\n-# define CLASSNAME(NAME, SUFFIX) NAME\n-#endif\n-\n void * bad_malloc(size_t, void *)\n {\n   return NULL;\n }\n \n-class CLASSNAME (TestActionGraphFixture, RMW_IMPLEMENTATION) : public ::testing::Test\n\u002Bclass TestActionGraphFixture : public ::testing::Test\n {\n public:\n   rcl_allocator_t allocator = rcl_get_default_allocator();\n@@ -106,9 \u002B99,7 @@ public:\n   }\n };\n \n-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_client_names_and_types_by_node)\n\u002BTEST_F(TestActionGraphFixture, test_action_get_client_names_and_types_by_node)\n {\n   rcl_ret_t ret;\n   rcl_names_and_types_t nat = rcl_get_zero_initialized_names_and_types();\n@@ -168,9 \u002B159,7 @@ TEST_F(\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n }\n \n-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_server_names_and_types_by_node)\n\u002BTEST_F(TestActionGraphFixture, test_action_get_server_names_and_types_by_node)\n {\n   rcl_ret_t ret;\n   rcl_names_and_types_t nat = rcl_get_zero_initialized_names_and_types();\n@@ -221,9 \u002B210,7 @@ TEST_F(\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n }\n \n-TEST_F(\n-  CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION),\n-  test_action_get_names_and_types)\n\u002BTEST_F(TestActionGraphFixture, test_action_get_names_and_types)\n {\n   rcl_ret_t ret;\n   rcl_names_and_types_t nat = rcl_get_zero_initialized_names_and_types();\n@@ -268,7 \u002B255,7 @@ typedef std::function\u003C\n  * Extend the TestActionGraphFixture with a multi-node fixture for node discovery and node-graph\n  * perspective.\n  */\n-class TestActionGraphMultiNodeFixture : public CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION)\n\u002Bclass TestActionGraphMultiNodeFixture : public TestActionGraphFixture\n {\n public:\n   const char * remote_node_name = \u0022remote_graph_node\u0022;\n@@ -279,7 \u002B266,7 @@ public:\n \n   void SetUp() override\n   {\n-    CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION) ::SetUp();\n\u002B    TestActionGraphFixture::SetUp();\n \n     rcl_ret_t ret;\n     rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();\n@@ -326,7 \u002B313,7 @@ public:\n \n   void TearDown() override\n   {\n-    CLASSNAME(TestActionGraphFixture, RMW_IMPLEMENTATION) ::TearDown();\n\u002B    TestActionGraphFixture::TearDown();\n \n     rcl_ret_t ret;\n     ret = rcl_node_fini(\u0026this-\u003Eremote_node);\n@@ -395,7 \u002B382,8 @@ public:\n };\n \n // Note, this test could be affected by other communication on the same ROS domain\n-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_names_and_types) {\n\u002BTEST_F(TestActionGraphMultiNodeFixture, test_action_get_names_and_types)\n\u002B{\n   rcl_ret_t ret;\n   // Create an action client\n   rcl_action_client_t action_client = rcl_action_get_zero_initialized_client();\n@@ -472,7 \u002B460,8 @@ TEST_F(TestActionGraphMultiNodeFixture, test_action_get_names_and_types) {\n }\n \n // Note, this test could be affected by other communication on the same ROS domain\n-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_server_names_and_types_by_node) {\n\u002BTEST_F(TestActionGraphMultiNodeFixture, test_action_get_server_names_and_types_by_node)\n\u002B{\n   rcl_ret_t ret;\n   // Create an action client\n   rcl_action_client_t action_client = rcl_action_get_zero_initialized_client();\n@@ -538,7 \u002B527,8 @@ TEST_F(TestActionGraphMultiNodeFixture, test_action_get_server_names_and_types_b\n }\n \n // Note, this test could be affected by other communication on the same ROS domain\n-TEST_F(TestActionGraphMultiNodeFixture, test_action_get_client_names_and_types_by_node) {\n\u002BTEST_F(TestActionGraphMultiNodeFixture, test_action_get_client_names_and_types_by_node)\n\u002B{\n   rcl_ret_t ret;\n   const rosidl_action_type_support_t * action_typesupport =\n     ROSIDL_GET_ACTION_TYPE_SUPPORT(test_msgs, Fibonacci);\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "1961b81ecc1210441d523fe5638045998d9f812c",
    "RawMessage": "point_marker: fix bug where the number of rendered points accumulates over time (#949)",
    "Changes": "diff --git rviz_default_plugins/src/rviz_default_plugins/displays/marker/markers/points_marker.cpp rviz_default_plugins/src/rviz_default_plugins/displays/marker/markers/points_marker.cpp\nindex b5238cde..6221413a 100644\n--- rviz_default_plugins/src/rviz_default_plugins/displays/marker/markers/points_marker.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/marker/markers/points_marker.cpp\n@@ -88,9 \u002B88,9 @@ void PointsMarker::onNewMessage(\n   setPosition(pose);\n   setOrientation(orientation);\n \n-  setRenderModeAndDimensions(new_message, scale);\n\u002B  points_-\u003EclearAndRemoveAllPoints();\n \n-  points_-\u003Eclear();\n\u002B  setRenderModeAndDimensions(new_message, scale);\n \n   if (new_message-\u003Epoints.empty()) {\n     return;\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "9f21d1f8db3244eeab458da505379c87703ec88d",
    "RawMessage": "Cope with base function restrictions in mocks. (#753)",
    "Changes": "diff --git rcl/test/mocking_utils/patch.hpp rcl/test/mocking_utils/patch.hpp\nindex 8bb67d5..7b0d8d8 100644\n--- rcl/test/mocking_utils/patch.hpp\n\u002B\u002B\u002B rcl/test/mocking_utils/patch.hpp\n@@ -473,10 \u002B473,22 @@ auto make_patch(const std::string \u0026 target, std::function\u003CSignatureT\u003E proxy)\n \n /// Patch a \u0060function\u0060 to execute normally but always yield a given \u0060return_code\u0060\n /// in a given \u0060scope\u0060.\n\u002B/**\n\u002B * \\warning On some Linux distributions (e.g. CentOS), pointers to function\n\u002B *   reference their PLT trampolines. In such cases, it is not possible to\n\u002B *   call \u0060function\u0060 from within the mock.\n\u002B */\n #define inject_on_return(scope, function, return_code) \\\n   patch( \\\n     scope, function, ([\u0026, base = function](auto \u0026\u0026 ... __args) { \\\n-      static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      if (base != function) { \\\n\u002B        static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      } else { \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n\u002B          \u0022[WARNING] mocking_utils::inject_on_return() cannot forward call to \u0022 \\\n\u002B          \u0022original \u0027\u0022 RCUTILS_STRINGIFY(function) \u0022\u0027 function before injection\\n\u0022 \\\n\u002B          \u0022    at \u0022 __FILE__ \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022\\n\u0022); \\\n\u002B      } \\\n       return return_code; \\\n     }))\n \ndiff --git rcl/test/rcl/test_logging.cpp rcl/test/rcl/test_logging.cpp\nindex 5ffb95e..1ce2eda 100644\n--- rcl/test/rcl/test_logging.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_logging.cpp\n@@ -242,14 \u002B242,13 @@ TEST(TestLogging, test_failing_external_logging) {\n   std::stringstream stderr_sstream;\n   auto fwrite_mock = mocking_utils::patch(\n     \u0022lib:rcl\u0022, fwrite,\n-    ([\u0026, base = fwrite](const void * ptr, size_t size,\n-    size_t count, FILE * stream)\n\u002B    [\u0026](const void * ptr, size_t size, size_t count, FILE * stream)\n     {\n       if (sizeof(char) == size \u0026\u0026 stderr == stream) {\n         stderr_sstream \u003C\u003C std::string(reinterpret_cast\u003Cconst char *\u003E(ptr), count);\n       }\n-      return base(ptr, size, count, stream);\n-    }));\n\u002B      return count;\n\u002B    });\n \n   constexpr char stderr_message[] = \u0022internal error\u0022;\n #ifdef MOCKING_UTILS_SUPPORT_VA_LIST\ndiff --git rcl/test/rcl/test_rmw_impl_id_check_func.cpp rcl/test/rcl/test_rmw_impl_id_check_func.cpp\nindex 7d576f3..62c3f2e 100644\n--- rcl/test/rcl/test_rmw_impl_id_check_func.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_rmw_impl_id_check_func.cpp\n@@ -128,12 \u002B128,15 @@ TEST(TestRmwCheck, test_mock_rmw_impl_check) {\n \n     auto mock = mocking_utils::patch(\n       \u0022lib:rcl\u0022, rcutils_strdup,\n-      [base = rcutils_strdup](const char * str, auto allocator)\n\u002B      [](const char * str, auto allocator)\n       {\n         static int counter = 1;\n         if (counter == 1) {\n           counter\u002B\u002B;\n-          return base(str, allocator);\n\u002B          char * dup = static_cast\u003Cchar *\u003E(\n\u002B            allocator.allocate(strlen(str) \u002B 1, allocator.state));\n\u002B          memcpy(dup, str, strlen(str) \u002B 1);\n\u002B          return dup;\n         } else {\n           return static_cast\u003Cchar *\u003E(NULL);\n         }\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "c5488cb72db66a6e33f32a1f17cdf8cd51d1571e",
    "RawMessage": "Use DataReader listener for taking data samples",
    "Changes": "diff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\nindex caefa9b..7f69e67 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n@@ -15,6 \u002B15,8 @@\n #ifndef RMW_GURUMDDS_CPP__TYPES_HPP_\n #define RMW_GURUMDDS_CPP__TYPES_HPP_\n \n\u002B#include \u003Cqueue\u003E\n\u002B\n #include \u0022rmw/rmw.h\u0022\n #include \u0022rmw_gurumdds_shared_cpp/types.hpp\u0022\n \n@@ -41,7 \u002B43,9 @@ typedef struct _GurumddsSubscriberInfo : GurumddsEventInfo\n {\n   dds_Subscriber * subscriber;\n   dds_DataReader * topic_reader;\n-  dds_ReadCondition * read_condition;\n\u002B  std::queue\u003CGurumddsMessage\u003E message_queue;\n\u002B  dds_GuardCondition * queue_guard_condition;\n\u002B  std::mutex queue_mutex;\n   dds_TypeSupport * dds_typesupport;\n   const rosidl_message_type_support_t * rosidl_message_typesupport;\n   const char * implementation_identifier;\n@@ -55,13 \u002B59,16 @@ typedef struct _GurumddsServiceInfo\n {\n   const rosidl_service_type_support_t * service_typesupport;\n \n\u002B  std::queue\u003CGurumddsMessage\u003E message_queue;\n\u002B  dds_GuardCondition * queue_guard_condition;\n\u002B  std::mutex queue_mutex;\n\u002B\n   dds_Subscriber * dds_subscriber;\n   dds_DataReader * request_reader;\n \n   dds_Publisher * dds_publisher;\n   dds_DataWriter * response_writer;\n \n-  dds_ReadCondition * read_condition;\n   dds_DomainParticipant * participant;\n   const char * implementation_identifier;\n } GurumddsServiceInfo;\n@@ -70,13 \u002B77,16 @@ typedef struct _GurumddsClientInfo\n {\n   const rosidl_service_type_support_t * service_typesupport;\n \n\u002B  std::queue\u003CGurumddsMessage\u003E message_queue;\n\u002B  dds_GuardCondition * queue_guard_condition;\n\u002B  std::mutex queue_mutex;\n\u002B\n   dds_Publisher * dds_publisher;\n   dds_DataWriter * request_writer;\n \n   dds_Subscriber * dds_subscriber;\n   dds_DataReader * response_reader;\n \n-  dds_ReadCondition * read_condition;\n   dds_DomainParticipant * participant;\n   const char * implementation_identifier;\n \ndiff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex ab71000..231a369 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -94,12 \u002B94,13 @@ rmw_create_client(\n   dds_PublisherQos publisher_qos;\n   dds_DataReaderQos datareader_qos;\n   dds_DataWriterQos datawriter_qos;\n\u002B  dds_DataReaderListener datareader_listener = {};\n \n   dds_Publisher * dds_publisher = nullptr;\n   dds_Subscriber * dds_subscriber = nullptr;\n   dds_DataWriter * request_writer = nullptr;\n   dds_DataReader * response_reader = nullptr;\n-  dds_ReadCondition * read_condition = nullptr;\n\u002B  dds_GuardCondition * queue_guard_condition = nullptr;\n   dds_TypeSupport * request_typesupport = nullptr;\n   dds_TypeSupport * response_typesupport = nullptr;\n \n@@ -212,6 \u002B213,12 @@ rmw_create_client(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -241,6 \u002B248,12 @@ rmw_create_client(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -287,6 \u002B300,12 @@ rmw_create_client(\n   }\n   client_info-\u003Erequest_writer = request_writer;\n \n\u002B  ret = dds_DataWriterQos_finalize(\u0026datawriter_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datawriter qos\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B\n   // Create datareader for response\n   ret = dds_DomainParticipant_get_default_subscriber_qos(participant, \u0026subscriber_qos);\n   if (ret != dds_RETCODE_OK) {\n@@ -314,21 \u002B333,31 @@ rmw_create_client(\n     goto fail;\n   }\n \n\u002B  datareader_listener.on_data_available = reader_on_data_available\u003CGurumddsClientInfo\u003E;\n\u002B\n   response_reader = dds_Subscriber_create_datareader(\n-    dds_subscriber, response_topic, \u0026datareader_qos, nullptr, 0);\n\u002B    dds_subscriber, response_topic, \u0026datareader_qos, \u0026datareader_listener,\n\u002B    dds_DATA_AVAILABLE_STATUS);\n   if (response_reader == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create datareader\u0022);\n     goto fail;\n   }\n   client_info-\u003Eresponse_reader = response_reader;\n \n-  read_condition = dds_DataReader_create_readcondition(\n-    response_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create read condition\u0022);\n\u002B  ret = dds_DataReaderQos_finalize(\u0026datareader_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datareader qos\u0022);\n     goto fail;\n   }\n-  client_info-\u003Eread_condition = read_condition;\n\u002B\n\u002B  dds_DataReader_set_listener_context(client_info-\u003Eresponse_reader, client_info);\n\u002B\n\u002B  queue_guard_condition = dds_GuardCondition_create();\n\u002B  if (queue_guard_condition == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to create guard condition\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B  client_info-\u003Equeue_guard_condition = queue_guard_condition;\n \n   // Set GUID\n   guid_temp = uniform_dist(dre);\n@@ -387,8 \u002B416,8 @@ fail:\n \n   if (dds_subscriber != nullptr) {\n     if (response_reader != nullptr) {\n-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(response_reader, read_condition);\n\u002B      if (queue_guard_condition != nullptr) {\n\u002B        dds_GuardCondition_delete(queue_guard_condition);\n       }\n       dds_Subscriber_delete_datareader(dds_subscriber, response_reader);\n     }\n@@ -449,23 \u002B478,12 @@ rmw_destroy_client(rmw_node_t * node, rmw_client_t * client)\n \n       if (client_info-\u003Edds_subscriber != nullptr) {\n         if (client_info-\u003Eresponse_reader != nullptr) {\n-          if (client_info-\u003Eread_condition != nullptr) {\n-            ret = dds_DataReader_delete_readcondition(\n-              client_info-\u003Eresponse_reader, client_info-\u003Eread_condition);\n-            if (ret != dds_RETCODE_OK) {\n-              RMW_SET_ERROR_MSG(\u0022failed to delete readcondition\u0022);\n-              rmw_ret = RMW_RET_ERROR;\n-            }\n-          }\n           ret = dds_Subscriber_delete_datareader(\n             client_info-\u003Edds_subscriber, client_info-\u003Eresponse_reader);\n           if (ret != dds_RETCODE_OK) {\n             RMW_SET_ERROR_MSG(\u0022failed to delete datareader\u0022);\n             rmw_ret = RMW_RET_ERROR;\n           }\n-        } else if (client_info-\u003Eread_condition != nullptr) {\n-          RMW_SET_ERROR_MSG(\u0022cannot delete readcondition because the datareader is null\u0022);\n-          rmw_ret = RMW_RET_ERROR;\n         }\n         ret = dds_DomainParticipant_delete_subscriber(\n           client_info-\u003Eparticipant, client_info-\u003Edds_subscriber);\n@@ -484,6 \u002B502,22 @@ rmw_destroy_client(rmw_node_t * node, rmw_client_t * client)\n       rmw_ret = RMW_RET_ERROR;\n     }\n \n\u002B    if (client_info-\u003Equeue_guard_condition != nullptr) {\n\u002B      dds_GuardCondition_delete(client_info-\u003Equeue_guard_condition);\n\u002B      client_info-\u003Equeue_guard_condition = nullptr;\n\u002B    }\n\u002B\n\u002B    while (!client_info-\u003Emessage_queue.empty()) {\n\u002B      auto msg = client_info-\u003Emessage_queue.front();\n\u002B      if (msg.sample != nullptr) {\n\u002B        free(msg.sample);\n\u002B      }\n\u002B      if (msg.info != nullptr) {\n\u002B        free(msg.info);\n\u002B      }\n\u002B      client_info-\u003Emessage_queue.pop();\n\u002B    }\n\u002B\n     delete client_info;\n     client-\u003Edata = nullptr;\n     if (client-\u003Eservice_name != nullptr) {\ndiff --git rmw_gurumdds_cpp/src/rmw_publisher.cpp rmw_gurumdds_cpp/src/rmw_publisher.cpp\nindex c7a87b2..6892f4b 100644\n--- rmw_gurumdds_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_publisher.cpp\n@@ -196,6 \u002B196,12 @@ rmw_create_publisher(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -218,6 \u002B224,12 @@ rmw_create_publisher(\n     goto fail;\n   }\n \n\u002B  ret = dds_DataWriterQos_finalize(\u0026datawriter_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datawriter qos\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B\n   publisher_info = new(std::nothrow) GurumddsPublisherInfo();\n   if (publisher_info == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to allocate GurumddsPublisherInfo\u0022);\n@@ -583,6 \u002B595,12 @@ rmw_publisher_get_actual_qos(\n       static_cast\u003Cuint64_t\u003E(dds_qos.liveliness.lease_duration.nanosec);\n   }\n \n\u002B  ret = dds_DataWriterQos_finalize(\u0026dds_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datawriter qos\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n   return RMW_RET_OK;\n }\n \ndiff --git rmw_gurumdds_cpp/src/rmw_request.cpp rmw_gurumdds_cpp/src/rmw_request.cpp\nindex 307b194..8e60c51 100644\n--- rmw_gurumdds_cpp/src/rmw_request.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_request.cpp\n@@ -155,77 \u002B155,42 @@ rmw_take_request(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create data sequence\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info-\u003Evalid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B  service_info-\u003Equeue_mutex.lock();\n\u002B  auto msg = service_info-\u003Emessage_queue.front();\n\u002B  service_info-\u003Emessage_queue.pop();\n\u002B  if (service_info-\u003Emessage_queue.empty()) {\n\u002B    dds_GuardCondition_set_trigger_value(service_info-\u003Equeue_guard_condition, false);\n\u002B  }\n\u002B  service_info-\u003Equeue_mutex.unlock();\n\u002B\n\u002B  if (msg.info-\u003Evalid_data) {\n\u002B    if (msg.sample == nullptr) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Received invalid message\u0022);\n\u002B      free(msg.info);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     int64_t sequence_number = 0;\n     int8_t client_guid[16] = {0};\n     bool res = deserialize_request(\n       type_support-\u003Edata,\n       type_support-\u003Etypesupport_identifier,\n       ros_request,\n-      sample,\n-      static_cast\u003Csize_t\u003E(size),\n\u002B      msg.sample,\n\u002B      static_cast\u003Csize_t\u003E(msg.size),\n       \u0026sequence_number,\n       client_guid\n     );\n \n     if (!res) {\n       // Error message already set\n-      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      free(msg.sample);\n\u002B      free(msg.info);\n       return RMW_RET_ERROR;\n     }\n \n     request_header-\u003Esource_timestamp =\n-      sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-      sample_info-\u003Esource_timestamp.nanosec;\n\u002B      msg.info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B      msg.info-\u003Esource_timestamp.nanosec;\n     // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n     request_header-\u003Ereceived_timestamp = 0;\n     request_header-\u003Erequest_id.sequence_number = sequence_number;\n@@ -234,10 \u002B199,12 @@ rmw_take_request(\n     *taken = true;\n   }\n \n-  dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  if (msg.sample != nullptr) {\n\u002B    free(msg.sample);\n\u002B  }\n\u002B  if (msg.info != nullptr) {\n\u002B    free(msg.info);\n\u002B  }\n \n   return RMW_RET_OK;\n }\ndiff --git rmw_gurumdds_cpp/src/rmw_response.cpp rmw_gurumdds_cpp/src/rmw_response.cpp\nindex ed090fe..8165fce 100644\n--- rmw_gurumdds_cpp/src/rmw_response.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_response.cpp\n@@ -74,78 \u002B74,43 @@ rmw_take_response(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create data sequence\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info-\u003Evalid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B  client_info-\u003Equeue_mutex.lock();\n\u002B  auto msg = client_info-\u003Emessage_queue.front();\n\u002B  client_info-\u003Emessage_queue.pop();\n\u002B  if (client_info-\u003Emessage_queue.empty()) {\n\u002B    dds_GuardCondition_set_trigger_value(client_info-\u003Equeue_guard_condition, false);\n\u002B  }\n\u002B  client_info-\u003Equeue_mutex.unlock();\n\u002B\n\u002B  if (msg.info-\u003Evalid_data) {\n\u002B    if (msg.sample == nullptr) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Received invalid message\u0022);\n\u002B      free(msg.info);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     int64_t sequence_number = 0;\n     int8_t client_guid[16] = {0};\n     bool res = deserialize_response(\n       type_support-\u003Edata,\n       type_support-\u003Etypesupport_identifier,\n       ros_response,\n-      sample,\n-      static_cast\u003Csize_t\u003E(size),\n\u002B      msg.sample,\n\u002B      static_cast\u003Csize_t\u003E(msg.size),\n       \u0026sequence_number,\n       client_guid\n     );\n \n     if (!res) {\n       // Error message already set\n-      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      free(msg.sample);\n\u002B      free(msg.info);\n       return RMW_RET_ERROR;\n     }\n \n     if (memcmp(client_info-\u003Ewriter_guid, client_guid, 16) == 0) {\n       request_header-\u003Esource_timestamp =\n-        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-        sample_info-\u003Esource_timestamp.nanosec;\n\u002B        msg.info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        msg.info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       request_header-\u003Ereceived_timestamp = 0;\n       request_header-\u003Erequest_id.sequence_number = sequence_number;\n@@ -155,10 \u002B120,12 @@ rmw_take_response(\n     }\n   }\n \n-  dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  if (msg.sample != nullptr) {\n\u002B    free(msg.sample);\n\u002B  }\n\u002B  if (msg.info != nullptr) {\n\u002B    free(msg.info);\n\u002B  }\n \n   return RMW_RET_OK;\n }\ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex 1165579..aaa3b29 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -91,12 \u002B91,13 @@ rmw_create_service(\n   dds_PublisherQos publisher_qos;\n   dds_DataReaderQos datareader_qos;\n   dds_DataWriterQos datawriter_qos;\n\u002B  dds_DataReaderListener datareader_listener = {};\n \n   dds_Subscriber * dds_subscriber = nullptr;\n   dds_Publisher * dds_publisher = nullptr;\n   dds_DataReader * request_reader = nullptr;\n   dds_DataWriter * response_writer = nullptr;\n-  dds_ReadCondition * read_condition = nullptr;\n\u002B  dds_GuardCondition * queue_guard_condition = nullptr;\n   dds_TypeSupport * request_typesupport = nullptr;\n   dds_TypeSupport * response_typesupport = nullptr;\n \n@@ -201,6 \u002B202,12 @@ rmw_create_service(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -230,6 \u002B237,12 @@ rmw_create_service(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -269,21 \u002B282,29 @@ rmw_create_service(\n     goto fail;\n   }\n \n\u002B  datareader_listener.on_data_available = reader_on_data_available\u003CGurumddsServiceInfo\u003E;\n\u002B\n   request_reader = dds_Subscriber_create_datareader(\n-    dds_subscriber, request_topic, \u0026datareader_qos, nullptr, 0);\n\u002B    dds_subscriber, request_topic, \u0026datareader_qos, \u0026datareader_listener,\n\u002B    dds_DATA_AVAILABLE_STATUS);\n   if (request_reader == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create datareader\u0022);\n     goto fail;\n   }\n   service_info-\u003Erequest_reader = request_reader;\n \n-  read_condition = dds_DataReader_create_readcondition(\n-    request_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create read condition\u0022);\n\u002B  ret = dds_DataReaderQos_finalize(\u0026datareader_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datareader qos\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B\n\u002B  queue_guard_condition = dds_GuardCondition_create();\n\u002B  if (queue_guard_condition == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to create guard condition\u0022);\n     goto fail;\n   }\n-  service_info-\u003Eread_condition = read_condition;\n\u002B  service_info-\u003Equeue_guard_condition = queue_guard_condition;\n \n   // Create datawriter for response\n   ret = dds_DomainParticipant_get_default_publisher_qos(participant, \u0026publisher_qos);\n@@ -319,6 \u002B340,14 @@ rmw_create_service(\n   }\n   service_info-\u003Eresponse_writer = response_writer;\n \n\u002B  ret = dds_DataWriterQos_finalize(\u0026datawriter_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datawriter qos\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B\n\u002B  dds_DataReader_set_listener_context(service_info-\u003Erequest_reader, service_info);\n\u002B\n   rmw_service = rmw_service_allocate();\n   if (rmw_service == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for service\u0022);\n@@ -363,8 \u002B392,8 @@ fail:\n \n   if (dds_subscriber != nullptr) {\n     if (request_reader != nullptr) {\n-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(request_reader, read_condition);\n\u002B      if (queue_guard_condition != nullptr) {\n\u002B        dds_GuardCondition_delete(queue_guard_condition);\n       }\n       dds_Subscriber_delete_datareader(dds_subscriber, request_reader);\n     }\n@@ -420,23 \u002B449,12 @@ rmw_destroy_service(rmw_node_t * node, rmw_service_t * service)\n     if (service_info-\u003Eparticipant != nullptr) {\n       if (service_info-\u003Edds_subscriber != nullptr) {\n         if (service_info-\u003Erequest_reader != nullptr) {\n-          if (service_info-\u003Eread_condition != nullptr) {\n-            ret = dds_DataReader_delete_readcondition(\n-              service_info-\u003Erequest_reader, service_info-\u003Eread_condition);\n-            if (ret != dds_RETCODE_OK) {\n-              RMW_SET_ERROR_MSG(\u0022failed to delete readcondition\u0022);\n-              rmw_ret = RMW_RET_ERROR;\n-            }\n-          }\n           ret = dds_Subscriber_delete_datareader(\n             service_info-\u003Edds_subscriber, service_info-\u003Erequest_reader);\n           if (ret != dds_RETCODE_OK) {\n             RMW_SET_ERROR_MSG(\u0022failed to delete datareader\u0022);\n             rmw_ret = RMW_RET_ERROR;\n           }\n-        } else if (service_info-\u003Eread_condition != nullptr) {\n-          RMW_SET_ERROR_MSG(\u0022cannot delete readcondition because the datareader is null\u0022);\n-          rmw_ret = RMW_RET_ERROR;\n         }\n         ret = dds_DomainParticipant_delete_subscriber(\n           service_info-\u003Eparticipant, service_info-\u003Edds_subscriber);\n@@ -475,6 \u002B493,22 @@ rmw_destroy_service(rmw_node_t * node, rmw_service_t * service)\n       rmw_ret = RMW_RET_ERROR;\n     }\n \n\u002B    if (service_info-\u003Equeue_guard_condition != nullptr) {\n\u002B      dds_GuardCondition_delete(service_info-\u003Equeue_guard_condition);\n\u002B      service_info-\u003Equeue_guard_condition = nullptr;\n\u002B    }\n\u002B\n\u002B    while (!service_info-\u003Emessage_queue.empty()) {\n\u002B      auto msg = service_info-\u003Emessage_queue.front();\n\u002B      if (msg.sample != nullptr) {\n\u002B        free(msg.sample);\n\u002B      }\n\u002B      if (msg.info != nullptr) {\n\u002B        free(msg.info);\n\u002B      }\n\u002B      service_info-\u003Emessage_queue.pop();\n\u002B    }\n\u002B\n     delete service_info;\n     service-\u003Edata = nullptr;\n     if (service-\u003Eservice_name != nullptr) {\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex 72f8fb0..81a9871 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -121,9 \u002B121,10 @@ rmw_create_subscription(\n   dds_SubscriberQos subscriber_qos;\n   dds_DataReader * topic_reader = nullptr;\n   dds_DataReaderQos datareader_qos;\n\u002B  dds_DataReaderListener datareader_listener = {};\n   dds_Topic * topic = nullptr;\n   dds_TopicDescription * topic_desc = nullptr;\n-  dds_ReadCondition * read_condition = nullptr;\n\u002B  dds_GuardCondition * queue_guard_condition = nullptr;\n   dds_TypeSupport * dds_typesupport = nullptr;\n   dds_ReturnCode_t ret = dds_RETCODE_OK;\n   rmw_ret_t rmw_ret = RMW_RET_OK;\n@@ -198,6 \u002B199,12 @@ rmw_create_subscription(\n       RMW_SET_ERROR_MSG(\u0022failed to create topic\u0022);\n       goto fail;\n     }\n\u002B\n\u002B    ret = dds_TopicQos_finalize(\u0026topic_qos);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to finalize topic qos\u0022);\n\u002B      goto fail;\n\u002B    }\n   } else {\n     dds_Duration_t timeout;\n     timeout.sec = 0;\n@@ -214,17 \u002B221,25 @@ rmw_create_subscription(\n     goto fail;\n   }\n \n-  topic_reader =\n-    dds_Subscriber_create_datareader(dds_subscriber, topic, \u0026datareader_qos, nullptr, 0);\n\u002B  datareader_listener.on_data_available = reader_on_data_available\u003CGurumddsSubscriberInfo\u003E;\n\u002B\n\u002B  topic_reader = dds_Subscriber_create_datareader(\n\u002B    dds_subscriber, topic, \u0026datareader_qos, \u0026datareader_listener,\n\u002B    dds_DATA_AVAILABLE_STATUS);\n   if (topic_reader == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to create datareader\u0022);\n     goto fail;\n   }\n \n-  read_condition = dds_DataReader_create_readcondition(\n-    topic_reader, dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-  if (read_condition == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create read condition\u0022);\n\u002B  ret = dds_DataReaderQos_finalize(\u0026datareader_qos);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to finalize datareader qos\u0022);\n\u002B    goto fail;\n\u002B  }\n\u002B\n\u002B  queue_guard_condition = dds_GuardCondition_create();\n\u002B  if (queue_guard_condition == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to create guard condition\u0022);\n     goto fail;\n   }\n \n@@ -237,10 \u002B252,12 @@ rmw_create_subscription(\n   subscriber_info-\u003Eimplementation_identifier = gurum_gurumdds_identifier;\n   subscriber_info-\u003Esubscriber = dds_subscriber;\n   subscriber_info-\u003Etopic_reader = topic_reader;\n-  subscriber_info-\u003Eread_condition = read_condition;\n\u002B  subscriber_info-\u003Equeue_guard_condition = queue_guard_condition;\n   subscriber_info-\u003Edds_typesupport = dds_typesupport;\n   subscriber_info-\u003Erosidl_message_typesupport = type_support;\n \n\u002B  dds_DataReader_set_listener_context(subscriber_info-\u003Etopic_reader, subscriber_info);\n\u002B\n   subscription = rmw_subscription_allocate();\n   if (subscription == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022failed to allocate subscription\u0022);\n@@ -284,8 \u002B301,8 @@ fail:\n \n   if (dds_subscriber != nullptr) {\n     if (topic_reader != nullptr) {\n-      if (read_condition != nullptr) {\n-        dds_DataReader_delete_readcondition(topic_reader, read_condition);\n\u002B      if (queue_guard_condition != nullptr) {\n\u002B        dds_GuardCondition_delete(queue_guard_condition);\n       }\n       dds_Subscriber_delete_datareader(dds_subscriber, topic_reader);\n     }\n@@ -491,25 \u002B508,12 @@ rmw_destroy_subscription(rmw_node_t * node, rmw_subscription_t * subscription)\n     if (dds_subscriber != nullptr) {\n       dds_DataReader * topic_reader = subscriber_info-\u003Etopic_reader;\n       if (topic_reader != nullptr) {\n-        dds_ReadCondition * read_condition = subscriber_info-\u003Eread_condition;\n-        if (read_condition != nullptr) {\n-          ret = dds_DataReader_delete_readcondition(topic_reader, read_condition);\n-          if (ret != dds_RETCODE_OK) {\n-            RMW_SET_ERROR_MSG(\u0022failed to delete readcondition\u0022);\n-            rmw_ret = RMW_RET_ERROR;\n-          }\n-          subscriber_info-\u003Eread_condition = nullptr;\n-        }\n-\n         ret = dds_Subscriber_delete_datareader(dds_subscriber, topic_reader);\n         if (ret != dds_RETCODE_OK) {\n           RMW_SET_ERROR_MSG(\u0022failed to delete datareader\u0022);\n           rmw_ret = RMW_RET_ERROR;\n         }\n         subscriber_info-\u003Etopic_reader = nullptr;\n-      } else if (subscriber_info-\u003Eread_condition != nullptr) {\n-        RMW_SET_ERROR_MSG(\u0022cannot delete readcondition because the datareader is null\u0022);\n-        rmw_ret = RMW_RET_ERROR;\n       }\n \n       ret = dds_DomainParticipant_delete_subscriber(participant, dds_subscriber);\n@@ -522,6 \u002B526,22 @@ rmw_destroy_subscription(rmw_node_t * node, rmw_subscription_t * subscription)\n       rmw_ret = RMW_RET_ERROR;\n     }\n \n\u002B    if (subscriber_info-\u003Equeue_guard_condition != nullptr) {\n\u002B      dds_GuardCondition_delete(subscriber_info-\u003Equeue_guard_condition);\n\u002B      subscriber_info-\u003Equeue_guard_condition = nullptr;\n\u002B    }\n\u002B\n\u002B    while (!subscriber_info-\u003Emessage_queue.empty()) {\n\u002B      auto msg = subscriber_info-\u003Emessage_queue.front();\n\u002B      if (msg.sample != nullptr) {\n\u002B        free(msg.sample);\n\u002B      }\n\u002B      if (msg.info != nullptr) {\n\u002B        free(msg.info);\n\u002B      }\n\u002B      subscriber_info-\u003Emessage_queue.pop();\n\u002B    }\n\u002B\n     if (subscriber_info-\u003Edds_typesupport != nullptr) {\n       dds_TypeSupport_delete(subscriber_info-\u003Edds_typesupport);\n       subscriber_info-\u003Edds_typesupport = nullptr;\n@@ -570,89 \u002B590,41 @@ _take(\n   dds_DataReader * topic_reader = info-\u003Etopic_reader;\n   RCUTILS_CHECK_FOR_NULL_WITH_MSG(topic_reader, \u0022topic reader is null\u0022, return RMW_RET_ERROR);\n \n-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create data sequence\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample size sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022rmw_gurumdds_cpp\u0022, \u0022No data on topic %s\u0022, topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n\u002B  if (info-\u003Emessage_queue.empty()) {\n     return RMW_RET_OK;\n   }\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \u0022rmw_gurumdds_cpp\u0022, \u0022Received data on topic %s\u0022, topic_name);\n \n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n\u002B  info-\u003Equeue_mutex.lock();\n\u002B  auto msg = info-\u003Emessage_queue.front();\n\u002B  info-\u003Emessage_queue.pop();\n\u002B  if (info-\u003Emessage_queue.empty()) {\n\u002B    dds_GuardCondition_set_trigger_value(info-\u003Equeue_guard_condition, false);\n   }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B  info-\u003Equeue_mutex.unlock();\n \n   bool ignore_sample = false;\n \n-  if (!sample_info-\u003Evalid_data) {\n\u002B  if (!msg.info-\u003Evalid_data) {\n     ignore_sample = true;\n   }\n \n   if (!ignore_sample) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n-      RMW_SET_ERROR_MSG(\u0022failed to get message\u0022);\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B    if (msg.sample == nullptr) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Received invalid message\u0022);\n\u002B      free(msg.info);\n       return RMW_RET_ERROR;\n     }\n-    uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n     bool result = deserialize_cdr_to_ros(\n       info-\u003Erosidl_message_typesupport-\u003Edata,\n       info-\u003Erosidl_message_typesupport-\u003Etypesupport_identifier,\n       ros_message,\n-      sample,\n-      static_cast\u003Csize_t\u003E(sample_size)\n\u002B      msg.sample,\n\u002B      static_cast\u003Csize_t\u003E(msg.size)\n     );\n     if (!result) {\n-      RMW_SET_ERROR_MSG(\u0022failed to deserialize message\u0022);\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      RMW_SET_ERROR_MSG(\u0022Failed to deserialize message\u0022);\n\u002B      free(msg.sample);\n\u002B      free(msg.info);\n       return RMW_RET_ERROR;\n     }\n \n@@ -660,8 \u002B632,8 @@ _take(\n \n     if (message_info != nullptr) {\n       message_info-\u003Esource_timestamp =\n-        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-        sample_info-\u003Esource_timestamp.nanosec;\n\u002B        msg.info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        msg.info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n@@ -669,7 \u002B641,7 @@ _take(\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       auto custom_gid = reinterpret_cast\u003CGurumddsPublisherGID *\u003E(sender_gid-\u003Edata);\n       dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n\u002B        topic_reader, msg.info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n       if (ret != dds_RETCODE_OK) {\n         if (ret == dds_RETCODE_ERROR) {\n           RCUTILS_LOG_WARN_NAMED(\u0022rmw_gurumdds_cpp\u0022, \u0022Failed to get publication handle\u0022);\n@@ -679,10 \u002B651,12 @@ _take(\n     }\n   }\n \n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  if (msg.sample != nullptr) {\n\u002B    free(msg.sample);\n\u002B  }\n\u002B  if (msg.info != nullptr) {\n\u002B    free(msg.info);\n\u002B  }\n \n   return RMW_RET_OK;\n }\n@@ -767,101 \u002B741,48 @@ rmw_take_sequence(\n   dds_DataReader * topic_reader = info-\u003Etopic_reader;\n   RCUTILS_CHECK_FOR_NULL_WITH_MSG(topic_reader, \u0022topic reader is null\u0022, return RMW_RET_ERROR);\n \n-  dds_DataSeq * data_values = dds_DataSeq_create(count);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create data sequence\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(count);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(count);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample size sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022rmw_gurumdds_cpp\u0022, \u0022No data on topic %s\u0022, topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n\u002B  if (info-\u003Emessage_queue.empty()) {\n     return RMW_RET_OK;\n   }\n \n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \u0022rmw_gurumdds_cpp\u0022, \u0022Received data on topic %s\u0022, topic_name);\n-\n-  for (uint32_t i = 0; i \u003C dds_SampleInfoSeq_length(sample_infos); i\u002B\u002B) {\n-    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n-\n\u002B  info-\u003Equeue_mutex.lock();\n\u002B  while (!info-\u003Emessage_queue.empty()) {\n\u002B    auto msg = info-\u003Emessage_queue.front();\n\u002B    info-\u003Emessage_queue.pop();\n\u002B    if (info-\u003Emessage_queue.empty()) {\n\u002B      dds_GuardCondition_set_trigger_value(info-\u003Equeue_guard_condition, false);\n\u002B    }\n     bool ignore_sample = false;\n \n-    if (!sample_info-\u003Evalid_data) {\n\u002B    if (!msg.info-\u003Evalid_data) {\n       ignore_sample = true;\n     }\n \n     if (!ignore_sample) {\n-      void * sample = dds_DataSeq_get(data_values, i);\n-      if (sample == nullptr) {\n-        RMW_SET_ERROR_MSG(\u0022failed to get message\u0022);\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      if (msg.sample == nullptr) {\n\u002B        RMW_SET_ERROR_MSG(\u0022Received invalid message\u0022);\n\u002B        free(msg.info);\n         return RMW_RET_ERROR;\n       }\n-      uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);\n       bool result = deserialize_cdr_to_ros(\n         info-\u003Erosidl_message_typesupport-\u003Edata,\n         info-\u003Erosidl_message_typesupport-\u003Etypesupport_identifier,\n         message_sequence-\u003Edata[*taken],\n-        sample,\n-        static_cast\u003Csize_t\u003E(sample_size)\n\u002B        msg.sample,\n\u002B        static_cast\u003Csize_t\u003E(msg.size)\n       );\n       if (!result) {\n-        RMW_SET_ERROR_MSG(\u0022failed to deserialize message\u0022);\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        RMW_SET_ERROR_MSG(\u0022Failed to deserialize message\u0022);\n\u002B        free(msg.sample);\n\u002B        free(msg.info);\n         return RMW_RET_ERROR;\n       }\n \n       auto message_info = \u0026(message_info_sequence-\u003Edata[*taken]);\n \n       message_info-\u003Esource_timestamp =\n-        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-        sample_info-\u003Esource_timestamp.nanosec;\n\u002B        msg.info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        msg.info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n@@ -869,7 \u002B790,7 @@ rmw_take_sequence(\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       auto custom_gid = reinterpret_cast\u003CGurumddsPublisherGID *\u003E(sender_gid-\u003Edata);\n       dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n\u002B        topic_reader, msg.info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n       if (ret != dds_RETCODE_OK) {\n         if (ret == dds_RETCODE_ERROR) {\n           RCUTILS_LOG_WARN_NAMED(\u0022rmw_gurumdds_cpp\u0022, \u0022Failed to get publication handle\u0022);\n@@ -879,16 \u002B800,21 @@ rmw_take_sequence(\n \n       (*taken)\u002B\u002B;\n     }\n\u002B\n\u002B    if (msg.sample != nullptr) {\n\u002B      free(msg.sample);\n\u002B    }\n\u002B    if (msg.info != nullptr) {\n\u002B      free(msg.info);\n\u002B    }\n   }\n\u002B  info-\u003Equeue_mutex.unlock();\n\u002B\n\u002B  // =============================================================================================\n \n   message_sequence-\u003Esize = *taken;\n   message_info_sequence-\u003Esize = *taken;\n \n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n-\n   return RMW_RET_OK;\n }\n \n@@ -915,98 \u002B841,50 @@ _take_serialized(\n   dds_DataReader * topic_reader = info-\u003Etopic_reader;\n   RCUTILS_CHECK_FOR_NULL_WITH_MSG(topic_reader, \u0022topic reader is null\u0022, return RMW_RET_ERROR);\n \n-  dds_DataSeq * data_values = dds_DataSeq_create(1);\n-  if (data_values == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create data sequence\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_SampleInfoSeq * sample_infos = dds_SampleInfoSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample info sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_UnsignedLongSeq * sample_sizes = dds_UnsignedLongSeq_create(1);\n-  if (sample_infos == nullptr) {\n-    RMW_SET_ERROR_MSG(\u0022failed to create sample size sequence\u0022);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    const char * topic_name =\n-      dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022rmw_gurumdds_cpp\u0022, \u0022No data on topic %s\u0022, topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    *taken = false;\n\u002B  if (info-\u003Emessage_queue.empty()) {\n     return RMW_RET_OK;\n   }\n-  const char * topic_name =\n-    dds_TopicDescription_get_name(dds_DataReader_get_topicdescription(topic_reader));\n-  RCUTILS_LOG_DEBUG_NAMED(\n-    \u0022rmw_gurumdds_cpp\u0022, \u0022Received data on topic %s\u0022, topic_name);\n \n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n\u002B  info-\u003Equeue_mutex.lock();\n\u002B  auto msg = info-\u003Emessage_queue.front();\n\u002B  info-\u003Emessage_queue.pop();\n\u002B  if (info-\u003Emessage_queue.empty()) {\n\u002B    dds_GuardCondition_set_trigger_value(info-\u003Equeue_guard_condition, false);\n   }\n-\n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B  info-\u003Equeue_mutex.unlock();\n \n   bool ignore_sample = false;\n \n-  if (!sample_info-\u003Evalid_data) {\n\u002B  if (!msg.info-\u003Evalid_data) {\n     ignore_sample = true;\n   }\n \n   if (!ignore_sample) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n-      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-      dds_DataSeq_delete(data_values);\n-      dds_SampleInfoSeq_delete(sample_infos);\n-      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B    if (msg.sample == nullptr) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Received invalid message\u0022);\n\u002B      free(msg.info);\n       return RMW_RET_ERROR;\n     }\n \n-    uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    serialized_message-\u003Ebuffer_length = sample_size;\n-    if (serialized_message-\u003Ebuffer_capacity \u003C sample_size) {\n-      rmw_ret_t rmw_ret = rmw_serialized_message_resize(serialized_message, sample_size);\n\u002B    serialized_message-\u003Ebuffer_length = msg.size;\n\u002B    if (serialized_message-\u003Ebuffer_capacity \u003C msg.size) {\n\u002B      rmw_ret_t rmw_ret = rmw_serialized_message_resize(serialized_message, msg.size);\n       if (rmw_ret != RMW_RET_OK) {\n         // Error message already set\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        free(msg.sample);\n\u002B        free(msg.info);\n         return rmw_ret;\n       }\n     }\n \n-    memcpy(serialized_message-\u003Ebuffer, sample, sample_size);\n\u002B    memcpy(serialized_message-\u003Ebuffer, msg.sample, msg.size);\n \n     *taken = true;\n \n     if (message_info != nullptr) {\n       message_info-\u003Esource_timestamp =\n-        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-        sample_info-\u003Esource_timestamp.nanosec;\n\u002B        msg.info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        msg.info-\u003Esource_timestamp.nanosec;\n       // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n       message_info-\u003Ereceived_timestamp = 0;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n@@ -1014,7 \u002B892,7 @@ _take_serialized(\n       memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       auto custom_gid = reinterpret_cast\u003CGurumddsPublisherGID *\u003E(sender_gid-\u003Edata);\n       dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n\u002B        topic_reader, msg.info-\u003Epublication_handle, custom_gid-\u003Epublication_handle);\n       if (ret != dds_RETCODE_OK) {\n         if (ret == dds_RETCODE_ERROR) {\n           RCUTILS_LOG_WARN_NAMED(\u0022rmw_gurumdds_cpp\u0022, \u0022Failed to get publication handle\u0022);\n@@ -1024,10 \u002B902,12 @@ _take_serialized(\n     }\n   }\n \n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  if (msg.sample != nullptr) {\n\u002B    free(msg.sample);\n\u002B  }\n\u002B  if (msg.info != nullptr) {\n\u002B    free(msg.info);\n\u002B  }\n \n   return RMW_RET_OK;\n }\ndiff --git rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_wait.hpp rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_wait.hpp\nindex 8eebb92..6282353 100644\n--- rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_wait.hpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/rmw_wait.hpp\n@@ -233,14 \u002B233,14 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = subscriber_info-\u003Eread_condition;\n-      if (read_condition == nullptr) {\n\u002B      dds_GuardCondition * queue_guard_condition = subscriber_info-\u003Equeue_guard_condition;\n\u002B      if (queue_guard_condition == nullptr) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n \n       dds_ReturnCode_t ret = dds_WaitSet_attach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       CHECK_ATTACH(ret);\n     }\n   }\n@@ -282,14 \u002B282,14 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = service_info-\u003Eread_condition;\n-      if (read_condition == nullptr) {\n\u002B      dds_GuardCondition * queue_guard_condition = service_info-\u003Equeue_guard_condition;\n\u002B      if (queue_guard_condition == nullptr) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n \n       dds_ReturnCode_t ret = dds_WaitSet_attach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       CHECK_ATTACH(ret);\n     }\n   }\n@@ -302,14 \u002B302,14 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = client_info-\u003Eread_condition;\n-      if (read_condition == nullptr) {\n\u002B      dds_GuardCondition * queue_guard_condition = client_info-\u003Equeue_guard_condition;\n\u002B      if (queue_guard_condition == nullptr) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n \n       dds_ReturnCode_t ret = dds_WaitSet_attach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       CHECK_ATTACH(ret);\n     }\n   }\n@@ -410,8 \u002B410,8 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = subscriber_info-\u003Eread_condition;\n-      if (!read_condition) {\n\u002B      dds_GuardCondition * queue_guard_condition = subscriber_info-\u003Equeue_guard_condition;\n\u002B      if (!queue_guard_condition) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n@@ -420,7 \u002B420,7 @@ shared__rmw_wait(\n       for (; j \u003C dds_ConditionSeq_length(active_conditions); \u002B\u002Bj) {\n         if (\n           dds_ConditionSeq_get(active_conditions, j) ==\n-          reinterpret_cast\u003Cdds_Condition *\u003E(read_condition))\n\u002B          reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition))\n         {\n           break;\n         }\n@@ -431,7 \u002B431,7 @@ shared__rmw_wait(\n       }\n \n       rmw_ret_t rmw_ret_code = __detach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       if (rmw_ret_code != RMW_RET_OK) {\n         return rmw_ret_code;\n       }\n@@ -479,8 \u002B479,8 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = service_info-\u003Eread_condition;\n-      if (read_condition == nullptr) {\n\u002B      dds_GuardCondition * queue_guard_condition = service_info-\u003Equeue_guard_condition;\n\u002B      if (queue_guard_condition == nullptr) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n@@ -489,7 \u002B489,7 @@ shared__rmw_wait(\n       for (; j \u003C dds_ConditionSeq_length(active_conditions); \u002B\u002Bj) {\n         if (\n           dds_ConditionSeq_get(active_conditions, j) ==\n-          reinterpret_cast\u003Cdds_Condition *\u003E(read_condition))\n\u002B          reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition))\n         {\n           break;\n         }\n@@ -500,7 \u002B500,7 @@ shared__rmw_wait(\n       }\n \n       rmw_ret_t rmw_ret_code = __detach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       if (rmw_ret_code != RMW_RET_OK) {\n         return rmw_ret_code;\n       }\n@@ -515,8 \u002B515,8 @@ shared__rmw_wait(\n         return RMW_RET_ERROR;\n       }\n \n-      dds_ReadCondition * read_condition = client_info-\u003Eread_condition;\n-      if (read_condition == nullptr) {\n\u002B      dds_GuardCondition * queue_guard_condition = client_info-\u003Equeue_guard_condition;\n\u002B      if (queue_guard_condition == nullptr) {\n         RMW_SET_ERROR_MSG(\u0022read condition handle is null\u0022);\n         return RMW_RET_ERROR;\n       }\n@@ -525,7 \u002B525,7 @@ shared__rmw_wait(\n       for (; j \u003C dds_ConditionSeq_length(active_conditions); \u002B\u002Bj) {\n         if (\n           dds_ConditionSeq_get(active_conditions, j) ==\n-          reinterpret_cast\u003Cdds_Condition *\u003E(read_condition))\n\u002B          reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition))\n         {\n           break;\n         }\n@@ -536,7 \u002B536,7 @@ shared__rmw_wait(\n       }\n \n       rmw_ret_t rmw_ret_code = __detach_condition(\n-        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(read_condition));\n\u002B        dds_wait_set, reinterpret_cast\u003Cdds_Condition *\u003E(queue_guard_condition));\n       if (rmw_ret_code != RMW_RET_OK) {\n         return rmw_ret_code;\n       }\ndiff --git rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/types.hpp rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/types.hpp\nindex c3eeea6..ee00a55 100644\n--- rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/types.hpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/include/rmw_gurumdds_shared_cpp/types.hpp\n@@ -15,6 \u002B15,7 @@\n #ifndef RMW_GURUMDDS_SHARED_CPP__TYPES_HPP_\n #define RMW_GURUMDDS_SHARED_CPP__TYPES_HPP_\n \n\u002B#include \u003Catomic\u003E\n #include \u003Ccassert\u003E\n #include \u003Cexception\u003E\n #include \u003Ciostream\u003E\n@@ -26,7 \u002B27,7 @@\n #include \u003Csstream\u003E\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n-#include \u003Catomic\u003E\n\u002B#include \u003Cutility\u003E\n \n #include \u0022rmw/rmw.h\u0022\n #include \u0022rmw/ret_types.h\u0022\n@@ -48,6 \u002B49,13 @@ typedef struct _ListenerContext\n   const char * implementation_identifier;\n } ListenerContext;\n \n\u002Btypedef struct _GurumddsMessage\n\u002B{\n\u002B  void * sample;\n\u002B  dds_SampleInfo * info;\n\u002B  dds_UnsignedLong size;\n\u002B} GurumddsMessage;\n\u002B\n static void pub_on_data_available(const dds_DataReader * a_reader)\n {\n   dds_DataReader * reader = const_cast\u003Cdds_DataReader *\u003E(a_reader);\n@@ -220,6 \u002B228,67 @@ static void sub_on_data_available(const dds_DataReader * a_reader)\n   dds_DataReader_set_listener_context(reader, context);\n }\n \n\u002Btemplate\u003Ctypename SubscriberInfo\u003E\n\u002Bstatic void reader_on_data_available(const dds_DataReader * a_reader)\n\u002B{\n\u002B  const uint32_t MAX_SAMPLES = 64;\n\u002B  dds_DataReader * reader = const_cast\u003Cdds_DataReader *\u003E(a_reader);\n\u002B  SubscriberInfo * subscriber_info =\n\u002B    reinterpret_cast\u003CSubscriberInfo *\u003E(dds_DataReader_get_listener_context(reader));\n\u002B  if (subscriber_info == nullptr) {\n\u002B    RCUTILS_LOG_ERROR_NAMED(\u0022rmw_gurumdds_cpp\u0022, \u0022Failed to take data: listener context is not set\u0022);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  dds_DataSeq * sample_seq = dds_DataSeq_create(MAX_SAMPLES);\n\u002B  if (sample_seq == nullptr) {\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  dds_SampleInfoSeq * info_seq = dds_SampleInfoSeq_create(MAX_SAMPLES);\n\u002B  if (info_seq == nullptr) {\n\u002B    dds_DataSeq_delete(sample_seq);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  dds_UnsignedLongSeq * size_seq = dds_UnsignedLongSeq_create(MAX_SAMPLES);\n\u002B  if (size_seq == nullptr) {\n\u002B    dds_DataSeq_delete(sample_seq);\n\u002B    dds_SampleInfoSeq_delete(info_seq);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B    reader, dds_HANDLE_NIL, sample_seq, info_seq, size_seq, MAX_SAMPLES,\n\u002B    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n\u002B  if (ret != dds_RETCODE_OK) {\n\u002B    if (ret != dds_RETCODE_NO_DATA) {\n\u002B      RCUTILS_LOG_ERROR_NAMED(\u0022rmw_gurumdds_cpp\u0022, \u0022Failed to take data\u0022);\n\u002B    }\n\u002B    dds_DataSeq_delete(sample_seq);\n\u002B    dds_SampleInfoSeq_delete(info_seq);\n\u002B    dds_UnsignedLongSeq_delete(size_seq);\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  subscriber_info-\u003Equeue_mutex.lock();\n\u002B  dds_GuardCondition_set_trigger_value(subscriber_info-\u003Equeue_guard_condition, true);\n\u002B  for (uint32_t i = 0; i \u003C dds_DataSeq_length(sample_seq); i\u002B\u002B) {\n\u002B    GurumddsMessage msg;\n\u002B    msg.sample = dds_DataSeq_get(sample_seq, i);\n\u002B    msg.info = dds_SampleInfoSeq_get(info_seq, i);\n\u002B    msg.size = dds_UnsignedLongSeq_get(size_seq, i);\n\u002B    subscriber_info-\u003Emessage_queue.push(std::move(msg));\n\u002B  }\n\u002B  subscriber_info-\u003Equeue_mutex.unlock();\n\u002B\n\u002B  // return loan manually after deserialization\n\u002B  // or before destruction of the queue using free()\n\u002B  dds_DataSeq_delete(sample_seq);\n\u002B  dds_SampleInfoSeq_delete(info_seq);\n\u002B  dds_UnsignedLongSeq_delete(size_seq);\n\u002B}\n\u002B\n class GurumddsDataReaderListener\n {\n public:\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "66ba4f12eb21a9a28d5227df2bbb2f236560a63a",
    "RawMessage": "Increase the timeout for the test_msgs rosidl_generated_cpp cpplint. (#163)",
    "Changes": "diff --git test_msgs/CMakeLists.txt test_msgs/CMakeLists.txt\nindex 16ad0bc..433833b 100644\n--- test_msgs/CMakeLists.txt\n\u002B\u002B\u002B test_msgs/CMakeLists.txt\n@@ -57,6 \u002B57,10 @@ if(BUILD_TESTING)\n     test/test_cpp_type_support.cpp)\n   target_link_libraries(test_action_typesupport_cpp_builds\n     \u0022${cpp_typesupport_target}\u0022)\n\u002B\n\u002B  if(TEST cpplint_rosidl_generated_cpp)\n\u002B    set_tests_properties(cpplint_rosidl_generated_cpp PROPERTIES TIMEOUT 180)\n\u002B  endif()\n endif()\n \n if(DEFINED PYTHON_INSTALL_DIR)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "d119157948720f5888d47898e1c59b56fe1f86c5",
    "RawMessage": "Fix bug that a callback not reached (#1640)",
    "Changes": "diff --git rclcpp/include/rclcpp/callback_group.hpp rclcpp/include/rclcpp/callback_group.hpp\nindex 94bceced..7d03edf3 100644\n--- rclcpp/include/rclcpp/callback_group.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/callback_group.hpp\n@@ -16,11 \u002B16,14 @@\n #define RCLCPP__CALLBACK_GROUP_HPP_\n \n #include \u003Catomic\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cmemory\u003E\n #include \u003Cmutex\u003E\n-#include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n #include \u0022rclcpp/client.hpp\u0022\n\u002B#include \u0022rclcpp/context.hpp\u0022\n\u002B#include \u0022rclcpp/guard_condition.hpp\u0022\n #include \u0022rclcpp/publisher_base.hpp\u0022\n #include \u0022rclcpp/service.hpp\u0022\n #include \u0022rclcpp/subscription_base.hpp\u0022\n@@ -95,6 \u002B98,10 @@ public:\n     CallbackGroupType group_type,\n     bool automatically_add_to_executor_with_node = true);\n \n\u002B  /// Default destructor.\n\u002B  RCLCPP_PUBLIC\n\u002B  ~CallbackGroup();\n\u002B\n   template\u003Ctypename Function\u003E\n   rclcpp::SubscriptionBase::SharedPtr\n   find_subscription_ptrs_if(Function func) const\n@@ -171,6 \u002B178,16 @@ public:\n   bool\n   automatically_add_to_executor_with_node() const;\n \n\u002B  /// Defer creating the notify guard condition and return it.\n\u002B  RCLCPP_PUBLIC\n\u002B  rclcpp::GuardCondition::SharedPtr\n\u002B  get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr);\n\u002B\n\u002B  /// Trigger the notify guard condition.\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  trigger_notify_guard_condition();\n\u002B\n protected:\n   RCLCPP_DISABLE_COPY(CallbackGroup)\n \n@@ -213,6 \u002B230,9 @@ protected:\n   std::vector\u003Crclcpp::Waitable::WeakPtr\u003E waitable_ptrs_;\n   std::atomic_bool can_be_taken_from_;\n   const bool automatically_add_to_executor_with_node_;\n\u002B  // defer the creation of the guard condition\n\u002B  std::shared_ptr\u003Crclcpp::GuardCondition\u003E notify_guard_condition_ = nullptr;\n\u002B  std::recursive_mutex notify_guard_condition_mutex_;\n \n private:\n   template\u003Ctypename TypeT, typename Function\u003E\ndiff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex ed2ddc4a..65d0a930 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -560,14 \u002B560,14 @@ protected:\n   virtual void\n   spin_once_impl(std::chrono::nanoseconds timeout);\n \n-  typedef std::map\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n\u002B  typedef std::map\u003Crclcpp::CallbackGroup::WeakPtr,\n       const rclcpp::GuardCondition *,\n-      std::owner_less\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr\u003E\u003E\n-    WeakNodesToGuardConditionsMap;\n\u002B      std::owner_less\u003Crclcpp::CallbackGroup::WeakPtr\u003E\u003E\n\u002B    WeakCallbackGroupsToGuardConditionsMap;\n \n-  /// maps nodes to guard conditions\n-  WeakNodesToGuardConditionsMap\n-  weak_nodes_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B  /// maps callback groups to guard conditions\n\u002B  WeakCallbackGroupsToGuardConditionsMap\n\u002B  weak_groups_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n \n   /// maps callback groups associated to nodes\n   WeakCallbackGroupsToNodesMap\ndiff --git rclcpp/src/rclcpp/callback_group.cpp rclcpp/src/rclcpp/callback_group.cpp\nindex 4b11156c..734c781a 100644\n--- rclcpp/src/rclcpp/callback_group.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/callback_group.cpp\n@@ -12,9 \u002B12,19 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u0022rclcpp/callback_group.hpp\u0022\n\u002B#include \u003Calgorithm\u003E\n\u002B#include \u003Catomic\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cmutex\u003E\n\u002B#include \u003Cstdexcept\u003E\n \n-#include \u003Cvector\u003E\n\u002B#include \u0022rclcpp/callback_group.hpp\u0022\n\u002B#include \u0022rclcpp/client.hpp\u0022\n\u002B#include \u0022rclcpp/service.hpp\u0022\n\u002B#include \u0022rclcpp/subscription_base.hpp\u0022\n\u002B#include \u0022rclcpp/timer.hpp\u0022\n\u002B#include \u0022rclcpp/waitable.hpp\u0022\n \n using rclcpp::CallbackGroup;\n using rclcpp::CallbackGroupType;\n@@ -27,6 \u002B37,10 @@ CallbackGroup::CallbackGroup(\n   automatically_add_to_executor_with_node_(automatically_add_to_executor_with_node)\n {}\n \n\u002BCallbackGroup::~CallbackGroup()\n\u002B{\n\u002B  trigger_notify_guard_condition();\n\u002B}\n \n std::atomic_bool \u0026\n CallbackGroup::can_be_taken_from()\n@@ -97,6 \u002B111,33 @@ CallbackGroup::automatically_add_to_executor_with_node() const\n   return automatically_add_to_executor_with_node_;\n }\n \n\u002Brclcpp::GuardCondition::SharedPtr\n\u002BCallbackGroup::get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr)\n\u002B{\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(notify_guard_condition_mutex_);\n\u002B  if (notify_guard_condition_ \u0026\u0026 context_ptr != notify_guard_condition_-\u003Eget_context()) {\n\u002B    if (associated_with_executor_) {\n\u002B      trigger_notify_guard_condition();\n\u002B    }\n\u002B    notify_guard_condition_ = nullptr;\n\u002B  }\n\u002B\n\u002B  if (!notify_guard_condition_) {\n\u002B    notify_guard_condition_ = std::make_shared\u003Crclcpp::GuardCondition\u003E(context_ptr);\n\u002B  }\n\u002B\n\u002B  return notify_guard_condition_;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BCallbackGroup::trigger_notify_guard_condition()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(notify_guard_condition_mutex_);\n\u002B  if (notify_guard_condition_) {\n\u002B    notify_guard_condition_-\u003Etrigger();\n\u002B  }\n\u002B}\n\u002B\n void\n CallbackGroup::add_subscription(\n   const rclcpp::SubscriptionBase::SharedPtr subscription_ptr)\ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 73b7b8d8..401beb0a 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -106,11 \u002B106,11 @@ Executor::~Executor()\n   weak_groups_associated_with_executor_to_nodes_.clear();\n   weak_groups_to_nodes_associated_with_executor_.clear();\n   weak_groups_to_nodes_.clear();\n-  for (const auto \u0026 pair : weak_nodes_to_guard_conditions_) {\n\u002B  for (const auto \u0026 pair : weak_groups_to_guard_conditions_) {\n     auto guard_condition = pair.second;\n     memory_strategy_-\u003Eremove_guard_condition(guard_condition);\n   }\n-  weak_nodes_to_guard_conditions_.clear();\n\u002B  weak_groups_to_guard_conditions_.clear();\n \n   // Finalize the wait set.\n   if (rcl_wait_set_fini(\u0026wait_set_) != RCL_RET_OK) {\n@@ -204,8 \u002B204,7 @@ Executor::add_callback_group_to_map(\n   if (has_executor.exchange(true)) {\n     throw std::runtime_error(\u0022Callback group has already been added to an executor.\u0022);\n   }\n-  bool is_new_node = !has_node(node_ptr, weak_groups_to_nodes_associated_with_executor_) \u0026\u0026\n-    !has_node(node_ptr, weak_groups_associated_with_executor_to_nodes_);\n\u002B\n   rclcpp::CallbackGroup::WeakPtr weak_group_ptr = group_ptr;\n   auto insert_info =\n     weak_groups_to_nodes.insert(std::make_pair(weak_group_ptr, node_ptr));\n@@ -215,21 \u002B214,24 @@ Executor::add_callback_group_to_map(\n   }\n   // Also add to the map that contains all callback groups\n   weak_groups_to_nodes_.insert(std::make_pair(weak_group_ptr, node_ptr));\n-  if (is_new_node) {\n-    const auto \u0026 gc = node_ptr-\u003Eget_notify_guard_condition();\n-    weak_nodes_to_guard_conditions_[node_ptr] = \u0026gc;\n-    if (notify) {\n-      // Interrupt waiting to handle new node\n-      try {\n-        interrupt_guard_condition_.trigger();\n-      } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n-        throw std::runtime_error(\n-                std::string(\n-                  \u0022Failed to trigger guard condition on callback group add: \u0022) \u002B ex.what());\n-      }\n\u002B\n\u002B  if (node_ptr-\u003Eget_context()-\u003Eis_valid()) {\n\u002B    auto callback_group_guard_condition =\n\u002B      group_ptr-\u003Eget_notify_guard_condition(node_ptr-\u003Eget_context());\n\u002B    weak_groups_to_guard_conditions_[weak_group_ptr] = callback_group_guard_condition.get();\n\u002B    // Add the callback_group\u0027s notify condition to the guard condition handles\n\u002B    memory_strategy_-\u003Eadd_guard_condition(*callback_group_guard_condition);\n\u002B  }\n\u002B\n\u002B  if (notify) {\n\u002B    // Interrupt waiting to handle new node\n\u002B    try {\n\u002B      interrupt_guard_condition_.trigger();\n\u002B    } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n\u002B      throw std::runtime_error(\n\u002B              std::string(\n\u002B                \u0022Failed to trigger guard condition on callback group add: \u0022) \u002B ex.what());\n     }\n-    // Add the node\u0027s notify condition to the guard condition handles\n-    memory_strategy_-\u003Eadd_guard_condition(gc);\n   }\n }\n \n@@ -300,7 \u002B302,12 @@ Executor::remove_callback_group_from_map(\n   if (!has_node(node_ptr, weak_groups_to_nodes_associated_with_executor_) \u0026\u0026\n     !has_node(node_ptr, weak_groups_associated_with_executor_to_nodes_))\n   {\n-    weak_nodes_to_guard_conditions_.erase(node_ptr);\n\u002B    auto iter = weak_groups_to_guard_conditions_.find(weak_group_ptr);\n\u002B    if (iter != weak_groups_to_guard_conditions_.end()) {\n\u002B      memory_strategy_-\u003Eremove_guard_condition(iter-\u003Esecond);\n\u002B    }\n\u002B    weak_groups_to_guard_conditions_.erase(weak_group_ptr);\n\u002B\n     if (notify) {\n       try {\n         interrupt_guard_condition_.trigger();\n@@ -310,7 \u002B317,6 @@ Executor::remove_callback_group_from_map(\n                   \u0022Failed to trigger guard condition on callback group remove: \u0022) \u002B ex.what());\n       }\n     }\n-    memory_strategy_-\u003Eremove_guard_condition(\u0026node_ptr-\u003Eget_notify_guard_condition());\n   }\n }\n \n@@ -700,12 \u002B706,6 @@ Executor::wait_for_work(std::chrono::nanoseconds timeout)\n         auto weak_node_ptr = pair.second;\n         if (weak_group_ptr.expired() || weak_node_ptr.expired()) {\n           invalid_group_ptrs.push_back(weak_group_ptr);\n-          auto node_guard_pair = weak_nodes_to_guard_conditions_.find(weak_node_ptr);\n-          if (node_guard_pair != weak_nodes_to_guard_conditions_.end()) {\n-            auto guard_condition = node_guard_pair-\u003Esecond;\n-            weak_nodes_to_guard_conditions_.erase(weak_node_ptr);\n-            memory_strategy_-\u003Eremove_guard_condition(guard_condition);\n-          }\n         }\n       }\n       std::for_each(\n@@ -721,6 \u002B721,12 @@ Executor::wait_for_work(std::chrono::nanoseconds timeout)\n           {\n             weak_groups_associated_with_executor_to_nodes_.erase(group_ptr);\n           }\n\u002B          auto callback_guard_pair = weak_groups_to_guard_conditions_.find(group_ptr);\n\u002B          if (callback_guard_pair != weak_groups_to_guard_conditions_.end()) {\n\u002B            auto guard_condition = callback_guard_pair-\u003Esecond;\n\u002B            weak_groups_to_guard_conditions_.erase(group_ptr);\n\u002B            memory_strategy_-\u003Eremove_guard_condition(guard_condition);\n\u002B          }\n           weak_groups_to_nodes_.erase(group_ptr);\n         });\n     }\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_services.cpp rclcpp/src/rclcpp/node_interfaces/node_services.cpp\nindex 14ab1c82..2f1afd32 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_services.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_services.cpp\n@@ -35,15 \u002B35,17 @@ NodeServices::add_service(\n       // TODO(jacquelinekay): use custom exception\n       throw std::runtime_error(\u0022Cannot create service, group not in node.\u0022);\n     }\n-    group-\u003Eadd_service(service_base_ptr);\n   } else {\n-    node_base_-\u003Eget_default_callback_group()-\u003Eadd_service(service_base_ptr);\n\u002B    group = node_base_-\u003Eget_default_callback_group();\n   }\n \n\u002B  group-\u003Eadd_service(service_base_ptr);\n\u002B\n   // Notify the executor that a new service was created using the parent Node.\n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on service creation: \u0022) \u002B ex.what());\n@@ -60,15 \u002B62,17 @@ NodeServices::add_client(\n       // TODO(jacquelinekay): use custom exception\n       throw std::runtime_error(\u0022Cannot create client, group not in node.\u0022);\n     }\n-    group-\u003Eadd_client(client_base_ptr);\n   } else {\n-    node_base_-\u003Eget_default_callback_group()-\u003Eadd_client(client_base_ptr);\n\u002B    group = node_base_-\u003Eget_default_callback_group();\n   }\n \n\u002B  group-\u003Eadd_client(client_base_ptr);\n\u002B\n   // Notify the executor that a new client was created using the parent Node.\n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on client creation: \u0022) \u002B ex.what());\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_timers.cpp rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\nindex b463e8a0..d2e821a9 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\n@@ -37,14 \u002B37,15 @@ NodeTimers::add_timer(\n       // TODO(jacquelinekay): use custom exception\n       throw std::runtime_error(\u0022Cannot create timer, group not in node.\u0022);\n     }\n-    callback_group-\u003Eadd_timer(timer);\n   } else {\n-    node_base_-\u003Eget_default_callback_group()-\u003Eadd_timer(timer);\n\u002B    callback_group = node_base_-\u003Eget_default_callback_group();\n   }\n\u002B  callback_group-\u003Eadd_timer(timer);\n \n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on timer creation: \u0022) \u002B ex.what());\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_topics.cpp rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\nindex 15940952..167a35f3 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\n@@ -73,6 \u002B73,7 @@ NodeTopics::add_publisher(\n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on publisher creation: \u0022) \u002B ex.what());\n@@ -121,6 \u002B122,7 @@ NodeTopics::add_subscription(\n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on subscription creation: \u0022) \u002B ex.what());\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\nindex 6f243f60..1d1fe2ce 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\n@@ -35,15 \u002B35,17 @@ NodeWaitables::add_waitable(\n       // TODO(jacobperron): use custom exception\n       throw std::runtime_error(\u0022Cannot create waitable, group not in node.\u0022);\n     }\n-    group-\u003Eadd_waitable(waitable_ptr);\n   } else {\n-    node_base_-\u003Eget_default_callback_group()-\u003Eadd_waitable(waitable_ptr);\n\u002B    group = node_base_-\u003Eget_default_callback_group();\n   }\n \n\u002B  group-\u003Eadd_waitable(waitable_ptr);\n\u002B\n   // Notify the executor that a new waitable was created using the parent Node.\n   auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n     node_gc.trigger();\n\u002B    group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on waitable creation: \u0022) \u002B ex.what());\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex d4e497f4..75aa9ac6 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -100,15 \u002B100,20 @@ if(TARGET test_create_subscription)\n     \u0022test_msgs\u0022\n   )\n endif()\n-ament_add_gtest(test_add_callback_groups_to_executor\n-  test_add_callback_groups_to_executor.cpp\n-  TIMEOUT 120)\n-if(TARGET test_add_callback_groups_to_executor)\n-  target_link_libraries(test_add_callback_groups_to_executor ${PROJECT_NAME})\n-  ament_target_dependencies(test_add_callback_groups_to_executor\n-    \u0022test_msgs\u0022\n\u002Bfunction(test_add_callback_groups_to_executor_for_rmw_implementation)\n\u002B  set(rmw_implementation_env_var RMW_IMPLEMENTATION=${rmw_implementation})\n\u002B  ament_add_gmock(test_add_callback_groups_to_executor${target_suffix} test_add_callback_groups_to_executor.cpp\n\u002B    ENV ${rmw_implementation_env_var}\n\u002B    TIMEOUT 120\n   )\n-endif()\n\u002B  if(TARGET test_add_callback_groups_to_executor${target_suffix})\n\u002B    target_link_libraries(test_add_callback_groups_to_executor${target_suffix} ${PROJECT_NAME})\n\u002B    ament_target_dependencies(test_add_callback_groups_to_executor${target_suffix}\n\u002B      \u0022test_msgs\u0022\n\u002B    )\n\u002B  endif()\n\u002Bendfunction()\n\u002Bcall_for_each_rmw_implementation(test_add_callback_groups_to_executor_for_rmw_implementation)\n ament_add_gtest(test_expand_topic_or_service_name test_expand_topic_or_service_name.cpp)\n if(TARGET test_expand_topic_or_service_name)\n   ament_target_dependencies(test_expand_topic_or_service_name\ndiff --git rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\nindex fa636b71..07ca1e87 100644\n--- rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_add_callback_groups_to_executor.cpp\n@@ -276,6 \u002B276,70 @@ TYPED_TEST(TestAddCallbackGroupsToExecutor, one_node_many_callback_groups_many_e\n   ASSERT_EQ(timer_executor.get_all_callback_groups().size(), 2u);\n }\n \n\u002B/*\n\u002B * Test callback groups from one node to many executors.\n\u002B * A subscriber on a new executor with a callback group not received a message\n\u002B * because the executor can\u0027t be triggered while a subscriber created, see\n\u002B * https://github.com/ros2/rclcpp/issues/1611\n\u002B*/\n\u002BTYPED_TEST(TestAddCallbackGroupsToExecutor, subscriber_triggered_to_receive_message)\n\u002B{\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n\u002B\n\u002B  // create a thread running an executor with a new callback group for a coming subscriber\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_grp = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive, false);\n\u002B  rclcpp::executors::SingleThreadedExecutor cb_grp_executor;\n\u002B\n\u002B  std::promise\u003Cbool\u003E received_message_promise;\n\u002B  auto received_message_future = received_message_promise.get_future();\n\u002B  rclcpp::FutureReturnCode return_code = rclcpp::FutureReturnCode::TIMEOUT;\n\u002B  std::thread cb_grp_thread = std::thread(\n\u002B    [\u0026cb_grp, \u0026node, \u0026cb_grp_executor, \u0026received_message_future, \u0026return_code]() {\n\u002B      cb_grp_executor.add_callback_group(cb_grp, node-\u003Eget_node_base_interface());\n\u002B      return_code = cb_grp_executor.spin_until_future_complete(received_message_future, 10s);\n\u002B    });\n\u002B\n\u002B  // expect the subscriber to receive a message\n\u002B  auto sub_callback = [\u0026received_message_promise](test_msgs::msg::Empty::ConstSharedPtr) {\n\u002B      received_message_promise.set_value(true);\n\u002B    };\n\u002B\n\u002B  rclcpp::Subscription\u003Ctest_msgs::msg::Empty\u003E::SharedPtr subscription;\n\u002B  rclcpp::Publisher\u003Ctest_msgs::msg::Empty\u003E::SharedPtr publisher;\n\u002B  // to create a timer with a callback run on another executor\n\u002B  rclcpp::TimerBase::SharedPtr timer = nullptr;\n\u002B  std::promise\u003Cvoid\u003E timer_promise;\n\u002B  auto timer_callback =\n\u002B    [\u0026subscription, \u0026publisher, \u0026timer, \u0026cb_grp, \u0026node, \u0026sub_callback, \u0026timer_promise]() {\n\u002B      if (timer) {\n\u002B        timer.reset();\n\u002B      }\n\u002B\n\u002B      // create a subscription using the \u0060cb_grp\u0060 callback group\n\u002B      rclcpp::QoS qos = rclcpp::QoS(1).reliable();\n\u002B      auto options = rclcpp::SubscriptionOptions();\n\u002B      options.callback_group = cb_grp;\n\u002B      subscription =\n\u002B        node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\u0022topic_name\u0022, qos, sub_callback, options);\n\u002B      // create a publisher to send data\n\u002B      publisher =\n\u002B        node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic_name\u0022, qos);\n\u002B      publisher-\u003Epublish(test_msgs::msg::Empty());\n\u002B      timer_promise.set_value();\n\u002B    };\n\u002B\n\u002B  rclcpp::executors::SingleThreadedExecutor timer_executor;\n\u002B  timer = node-\u003Ecreate_wall_timer(100ms, timer_callback);\n\u002B  timer_executor.add_node(node);\n\u002B  auto future = timer_promise.get_future();\n\u002B  timer_executor.spin_until_future_complete(future);\n\u002B  cb_grp_thread.join();\n\u002B\n\u002B  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n\u002B  EXPECT_TRUE(received_message_future.get());\n\u002B}\n\u002B\n /*\n  * Test removing callback group from executor that its not associated with.\n  */\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "6bb9407b9079eeaaef005613cef3a5a1224f1a36",
    "RawMessage": "Reduce overhead for inheriting from rclcpp::Executor when base functionality is not reused (#2506)",
    "Changes": "diff --git rclcpp/include/rclcpp/clock.hpp rclcpp/include/rclcpp/clock.hpp\nindex 702b224d..e73f3849 100644\n--- rclcpp/include/rclcpp/clock.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/clock.hpp\n@@ -193,6 \u002B193,16 @@ public:\n   bool\n   ros_time_is_active();\n \n\u002B  /**\n\u002B   * Cancels an ongoing or future sleep operation of one thread.\n\u002B   *\n\u002B   * This function can be used by one thread, to wakeup another thread that is\n\u002B   * blocked using any of the sleep_ or wait_ methods of this class.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  cancel_sleep_or_wait();\n\u002B\n   /// Return the rcl_clock_t clock handle\n   RCLCPP_PUBLIC\n   rcl_clock_t *\ndiff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex 7bdc53d2..5e5a0548 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -272,12 \u002B272,12 @@ public:\n    * \\param[in] node Shared pointer to the node to add.\n    */\n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   spin_node_some(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node);\n \n   /// Convenience function which takes Node and forwards NodeBaseInterface.\n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   spin_node_some(std::shared_ptr\u003Crclcpp::Node\u003E node);\n \n   /// Collect work once and execute all available work, optionally within a max duration.\n@@ -307,14 \u002B307,14 @@ public:\n    * \\param[in] node Shared pointer to the node to add.\n    */\n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   spin_node_all(\n     rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node,\n     std::chrono::nanoseconds max_duration);\n \n   /// Convenience function which takes Node and forwards NodeBaseInterface.\n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   spin_node_all(std::shared_ptr\u003Crclcpp::Node\u003E node, std::chrono::nanoseconds max_duration);\n \n   /// Collect and execute work repeatedly within a duration or until no more work is available.\n@@ -366,52 \u002B366,12 @@ public:\n     const FutureT \u0026 future,\n     std::chrono::duration\u003CTimeRepT, TimeT\u003E timeout = std::chrono::duration\u003CTimeRepT, TimeT\u003E(-1))\n   {\n-    // TODO(wjwwood): does not work recursively; can\u0027t call spin_node_until_future_complete\n-    // inside a callback executed by an executor.\n-\n-    // Check the future before entering the while loop.\n-    // If the future is already complete, don\u0027t try to spin.\n-    std::future_status status = future.wait_for(std::chrono::seconds(0));\n-    if (status == std::future_status::ready) {\n-      return FutureReturnCode::SUCCESS;\n-    }\n-\n-    auto end_time = std::chrono::steady_clock::now();\n-    std::chrono::nanoseconds timeout_ns = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(\n-      timeout);\n-    if (timeout_ns \u003E std::chrono::nanoseconds::zero()) {\n-      end_time \u002B= timeout_ns;\n-    }\n-    std::chrono::nanoseconds timeout_left = timeout_ns;\n-\n-    if (spinning.exchange(true)) {\n-      throw std::runtime_error(\u0022spin_until_future_complete() called while already spinning\u0022);\n-    }\n-    RCPPUTILS_SCOPE_EXIT(this-\u003Espinning.store(false); );\n-    while (rclcpp::ok(this-\u003Econtext_) \u0026\u0026 spinning.load()) {\n-      // Do one item of work.\n-      spin_once_impl(timeout_left);\n-\n-      // Check if the future is set, return SUCCESS if it is.\n-      status = future.wait_for(std::chrono::seconds(0));\n-      if (status == std::future_status::ready) {\n-        return FutureReturnCode::SUCCESS;\n-      }\n-      // If the original timeout is \u003C 0, then this is blocking, never TIMEOUT.\n-      if (timeout_ns \u003C std::chrono::nanoseconds::zero()) {\n-        continue;\n\u002B    return spin_until_future_complete_impl(\n\u002B      std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(timeout),\n\u002B      [\u0026future](std::chrono::nanoseconds wait_time) {\n\u002B        return future.wait_for(wait_time);\n       }\n-      // Otherwise check if we still have time to wait, return TIMEOUT if not.\n-      auto now = std::chrono::steady_clock::now();\n-      if (now \u003E= end_time) {\n-        return FutureReturnCode::TIMEOUT;\n-      }\n-      // Subtract the elapsed time from the original timeout.\n-      timeout_left = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(end_time - now);\n-    }\n-\n-    // The future did not complete before ok() returned false, return INTERRUPTED.\n-    return FutureReturnCode::INTERRUPTED;\n\u002B    );\n   }\n \n   /// Cancel any running spin* function, causing it to return.\n@@ -420,7 \u002B380,7 @@ public:\n    * \\throws std::runtime_error if there is an issue triggering the guard condition\n    */\n   RCLCPP_PUBLIC\n-  void\n\u002B  virtual void\n   cancel();\n \n   /// Returns true if the executor is currently spinning.\n@@ -433,6 \u002B393,14 @@ public:\n   is_spinning();\n \n protected:\n\u002B  /// Constructor that will not initialize any non-trivial members.\n\u002B  /**\n\u002B  * This constructor is intended to be used by any derived executor\n\u002B  * that explicitly does not want to use the default implementation provided\n\u002B  * by this class.\n\u002B  */\n\u002B  explicit Executor(const std::shared_ptr\u003Crclcpp::Context\u003E \u0026 context);\n\u002B\n   /// Add a node to executor, execute the next available unit of work, and remove the node.\n   /**\n    * Implementation of spin_node_once using std::chrono::nanoseconds\n@@ -447,6 \u002B415,23 @@ protected:\n     rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node,\n     std::chrono::nanoseconds timeout);\n \n\u002B  /// Spin (blocking) until the future is complete, it times out waiting, or rclcpp is interrupted.\n\u002B  /**\n\u002B   * \\sa spin_until_future_complete()\n\u002B   * The only difference with spin_until_future_complete() is that the future\u0027s\n\u002B   * type is obscured through a std::function which lets you wait on it\n\u002B   * reguardless of type.\n\u002B   *\n\u002B   * \\param[in] timeout see spin_until_future_complete() for details\n\u002B   * \\param[in] wait_for_future function to wait on the future and get the\n\u002B   *   status after waiting\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  virtual FutureReturnCode\n\u002B  spin_until_future_complete_impl(\n\u002B    std::chrono::nanoseconds timeout,\n\u002B    const std::function\u003Cstd::future_status(std::chrono::nanoseconds wait_time)\u003E \u0026 wait_for_future);\n\u002B\n   /// Collect work and execute available work, optionally within a duration.\n   /**\n    * Implementation of spin_some and spin_all.\ndiff --git rclcpp/src/rclcpp/clock.cpp rclcpp/src/rclcpp/clock.cpp\nindex f46649a7..5c13f19d 100644\n--- rclcpp/src/rclcpp/clock.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/clock.cpp\n@@ -49,6 \u002B49,10 @@ public:\n \n   rcl_clock_t rcl_clock_;\n   rcl_allocator_t allocator_;\n\u002B  bool stop_sleeping_ = false;\n\u002B  bool shutdown_ = false;\n\u002B  std::condition_variable cv_;\n\u002B  std::mutex wait_mutex_;\n   std::mutex clock_mutex_;\n };\n \n@@ -79,8 \u002B83,20 @@ Clock::now() const\n   return now;\n }\n \n\u002Bvoid\n\u002BClock::cancel_sleep_or_wait()\n\u002B{\n\u002B  {\n\u002B    std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B    impl_-\u003Estop_sleeping_ = true;\n\u002B  }\n\u002B  impl_-\u003Ecv_.notify_one();\n\u002B}\n\u002B\n bool\n-Clock::sleep_until(Time until, Context::SharedPtr context)\n\u002BClock::sleep_until(\n\u002B  Time until,\n\u002B  Context::SharedPtr context)\n {\n   if (!context || !context-\u003Eis_valid()) {\n     throw std::runtime_error(\u0022context cannot be slept with because it\u0027s invalid\u0022);\n@@ -91,12 \u002B107,14 @@ Clock::sleep_until(Time until, Context::SharedPtr context)\n   }\n   bool time_source_changed = false;\n \n-  std::condition_variable cv;\n-\n   // Wake this thread if the context is shutdown\n   rclcpp::OnShutdownCallbackHandle shutdown_cb_handle = context-\u003Eadd_on_shutdown_callback(\n-    [\u0026cv]() {\n-      cv.notify_one();\n\u002B    [this]() {\n\u002B      {\n\u002B        std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B        impl_-\u003Eshutdown_ = true;\n\u002B      }\n\u002B      impl_-\u003Ecv_.notify_one();\n     });\n   // No longer need the shutdown callback when this function exits\n   auto callback_remover = rcpputils::scope_exit(\n@@ -112,22 \u002B130,24 @@ Clock::sleep_until(Time until, Context::SharedPtr context)\n     const std::chrono::steady_clock::time_point chrono_until =\n       chrono_entry \u002B std::chrono::nanoseconds(delta_t.nanoseconds());\n \n-    // loop over spurious wakeups but notice shutdown\n-    std::unique_lock lock(impl_-\u003Eclock_mutex_);\n-    while (now() \u003C until \u0026\u0026 context-\u003Eis_valid()) {\n-      cv.wait_until(lock, chrono_until);\n\u002B    // loop over spurious wakeups but notice shutdown or stop of sleep\n\u002B    std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B    while (now() \u003C until \u0026\u0026 !impl_-\u003Estop_sleeping_ \u0026\u0026 !impl_-\u003Eshutdown_ \u0026\u0026 context-\u003Eis_valid()) {\n\u002B      impl_-\u003Ecv_.wait_until(lock, chrono_until);\n     }\n\u002B    impl_-\u003Estop_sleeping_ = false;\n   } else if (this_clock_type == RCL_SYSTEM_TIME) {\n     auto system_time = std::chrono::system_clock::time_point(\n       // Cast because system clock resolution is too big for nanoseconds on some systems\n       std::chrono::duration_cast\u003Cstd::chrono::system_clock::duration\u003E(\n         std::chrono::nanoseconds(until.nanoseconds())));\n \n-    // loop over spurious wakeups but notice shutdown\n-    std::unique_lock lock(impl_-\u003Eclock_mutex_);\n-    while (now() \u003C until \u0026\u0026 context-\u003Eis_valid()) {\n-      cv.wait_until(lock, system_time);\n\u002B    // loop over spurious wakeups but notice shutdown or stop of sleep\n\u002B    std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B    while (now() \u003C until \u0026\u0026 !impl_-\u003Estop_sleeping_ \u0026\u0026 !impl_-\u003Eshutdown_ \u0026\u0026 context-\u003Eis_valid()) {\n\u002B      impl_-\u003Ecv_.wait_until(lock, system_time);\n     }\n\u002B    impl_-\u003Estop_sleeping_ = false;\n   } else if (this_clock_type == RCL_ROS_TIME) {\n     // Install jump handler for any amount of time change, for two purposes:\n     // - if ROS time is active, check if time reached on each new clock sample\n@@ -139,11 \u002B159,12 @@ Clock::sleep_until(Time until, Context::SharedPtr context)\n     threshold.min_forward.nanoseconds = 1;\n     auto clock_handler = create_jump_callback(\n       nullptr,\n-      [\u0026cv, \u0026time_source_changed](const rcl_time_jump_t \u0026 jump) {\n\u002B      [this, \u0026time_source_changed](const rcl_time_jump_t \u0026 jump) {\n         if (jump.clock_change != RCL_ROS_TIME_NO_CHANGE) {\n\u002B          std::lock_guard\u003Cstd::mutex\u003E lk(impl_-\u003Ewait_mutex_);\n           time_source_changed = true;\n         }\n-        cv.notify_one();\n\u002B        impl_-\u003Ecv_.notify_one();\n       },\n       threshold);\n \n@@ -153,19 \u002B174,25 @@ Clock::sleep_until(Time until, Context::SharedPtr context)\n         std::chrono::duration_cast\u003Cstd::chrono::system_clock::duration\u003E(\n           std::chrono::nanoseconds(until.nanoseconds())));\n \n-      // loop over spurious wakeups but notice shutdown or time source change\n-      std::unique_lock lock(impl_-\u003Eclock_mutex_);\n-      while (now() \u003C until \u0026\u0026 context-\u003Eis_valid() \u0026\u0026 !time_source_changed) {\n-        cv.wait_until(lock, system_time);\n\u002B      // loop over spurious wakeups but notice shutdown, stop of sleep or time source change\n\u002B      std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B      while (now() \u003C until \u0026\u0026 !impl_-\u003Estop_sleeping_ \u0026\u0026 !impl_-\u003Eshutdown_ \u0026\u0026 context-\u003Eis_valid() \u0026\u0026\n\u002B        !time_source_changed)\n\u002B      {\n\u002B        impl_-\u003Ecv_.wait_until(lock, system_time);\n       }\n\u002B      impl_-\u003Estop_sleeping_ = false;\n     } else {\n       // RCL_ROS_TIME with ros_time_is_active.\n       // Just wait without \u0022until\u0022 because installed\n       // jump callbacks wake the cv on every new sample.\n-      std::unique_lock lock(impl_-\u003Eclock_mutex_);\n-      while (now() \u003C until \u0026\u0026 context-\u003Eis_valid() \u0026\u0026 !time_source_changed) {\n-        cv.wait(lock);\n\u002B      std::unique_lock lock(impl_-\u003Ewait_mutex_);\n\u002B      while (now() \u003C until \u0026\u0026 !impl_-\u003Estop_sleeping_ \u0026\u0026 !impl_-\u003Eshutdown_ \u0026\u0026 context-\u003Eis_valid() \u0026\u0026\n\u002B        !time_source_changed)\n\u002B      {\n\u002B        impl_-\u003Ecv_.wait(lock);\n       }\n\u002B      impl_-\u003Estop_sleeping_ = false;\n     }\n   }\n \ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 5df70a94..42a4d274 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -50,6 \u002B50,14 @@ static constexpr rclcpp::SubscriptionWaitSetMask kDefaultSubscriptionMask = {tru\n \n class rclcpp::ExecutorImplementation {};\n \n\u002BExecutor::Executor(const std::shared_ptr\u003Crclcpp::Context\u003E \u0026 context)\n\u002B: spinning(false),\n\u002B  entities_need_rebuild_(true),\n\u002B  collector_(nullptr),\n\u002B  wait_set_({}, {}, {}, {}, {}, {}, context)\n\u002B{\n\u002B}\n\u002B\n Executor::Executor(const rclcpp::ExecutorOptions \u0026 options)\n : spinning(false),\n   interrupt_guard_condition_(std::make_shared\u003Crclcpp::GuardCondition\u003E(options.context)),\n@@ -120,7 \u002B128,8 @@ Executor::~Executor()\n   }\n }\n \n-void Executor::trigger_entity_recollect(bool notify)\n\u002Bvoid\n\u002BExecutor::trigger_entity_recollect(bool notify)\n {\n   this-\u003Eentities_need_rebuild_.store(true);\n \n@@ -240,6 \u002B249,59 @@ Executor::spin_node_once_nanoseconds(\n   this-\u003Eremove_node(node, false);\n }\n \n\u002Brclcpp::FutureReturnCode\n\u002BExecutor::spin_until_future_complete_impl(\n\u002B  std::chrono::nanoseconds timeout,\n\u002B  const std::function\u003Cstd::future_status(std::chrono::nanoseconds wait_time)\u003E \u0026 wait_for_future)\n\u002B{\n\u002B  // TODO(wjwwood): does not work recursively; can\u0027t call spin_node_until_future_complete\n\u002B  // inside a callback executed by an executor.\n\u002B\n\u002B  // Check the future before entering the while loop.\n\u002B  // If the future is already complete, don\u0027t try to spin.\n\u002B  std::future_status status = wait_for_future(std::chrono::seconds(0));\n\u002B  if (status == std::future_status::ready) {\n\u002B    return FutureReturnCode::SUCCESS;\n\u002B  }\n\u002B\n\u002B  auto end_time = std::chrono::steady_clock::now();\n\u002B  std::chrono::nanoseconds timeout_ns = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(\n\u002B    timeout);\n\u002B  if (timeout_ns \u003E std::chrono::nanoseconds::zero()) {\n\u002B    end_time \u002B= timeout_ns;\n\u002B  }\n\u002B  std::chrono::nanoseconds timeout_left = timeout_ns;\n\u002B\n\u002B  if (spinning.exchange(true)) {\n\u002B    throw std::runtime_error(\u0022spin_until_future_complete() called while already spinning\u0022);\n\u002B  }\n\u002B  RCPPUTILS_SCOPE_EXIT(this-\u003Espinning.store(false); );\n\u002B  while (rclcpp::ok(this-\u003Econtext_) \u0026\u0026 spinning.load()) {\n\u002B    // Do one item of work.\n\u002B    spin_once_impl(timeout_left);\n\u002B\n\u002B    // Check if the future is set, return SUCCESS if it is.\n\u002B    status = wait_for_future(std::chrono::seconds(0));\n\u002B    if (status == std::future_status::ready) {\n\u002B      return FutureReturnCode::SUCCESS;\n\u002B    }\n\u002B    // If the original timeout is \u003C 0, then this is blocking, never TIMEOUT.\n\u002B    if (timeout_ns \u003C std::chrono::nanoseconds::zero()) {\n\u002B      continue;\n\u002B    }\n\u002B    // Otherwise check if we still have time to wait, return TIMEOUT if not.\n\u002B    auto now = std::chrono::steady_clock::now();\n\u002B    if (now \u003E= end_time) {\n\u002B      return FutureReturnCode::TIMEOUT;\n\u002B    }\n\u002B    // Subtract the elapsed time from the original timeout.\n\u002B    timeout_left = std::chrono::duration_cast\u003Cstd::chrono::nanoseconds\u003E(end_time - now);\n\u002B  }\n\u002B\n\u002B  // The future did not complete before ok() returned false, return INTERRUPTED.\n\u002B  return FutureReturnCode::INTERRUPTED;\n\u002B}\n\u002B\n void\n Executor::spin_node_some(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node)\n {\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex ea29f7a2..844ca630 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -55,6 \u002B55,10 @@ ament_add_gtest(test_client test_client.cpp)\n if(TARGET test_client)\n   target_link_libraries(test_client ${PROJECT_NAME} mimick ${rcl_interfaces_TARGETS} ${test_msgs_TARGETS})\n endif()\n\u002Bament_add_gtest(test_clock test_clock.cpp)\n\u002Bif(TARGET test_clock)\n\u002B  target_link_libraries(test_clock ${PROJECT_NAME} mimick ${rcl_interfaces_TARGETS} ${test_msgs_TARGETS})\n\u002Bendif()\n ament_add_gtest(test_copy_all_parameter_values test_copy_all_parameter_values.cpp)\n if(TARGET test_copy_all_parameter_values)\n   target_link_libraries(test_copy_all_parameter_values ${PROJECT_NAME})\ndiff --git rclcpp/test/rclcpp/test_clock.cpp rclcpp/test/rclcpp/test_clock.cpp\nnew file mode 100644\nindex 00000000..2ddd7757\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_clock.cpp\n@@ -0,0 \u002B1,229 @@\n\u002B// Copyright 2024 Cellumation GmbH\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cchrono\u003E\n\u002B\n\u002B#include \u0022rcl/error_handling.h\u0022\n\u002B#include \u0022rcl/time.h\u0022\n\u002B#include \u0022rclcpp/clock.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022rclcpp/time_source.hpp\u0022\n\u002B\n\u002B#include \u0022../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n\u002Busing namespace std::chrono_literals;\n\u002B\n\u002Bclass TestClockWakeup : public ::testing::TestWithParam\u003Crcl_clock_type_e\u003E\n\u002B{\n\u002Bpublic:\n\u002B  void test_wakeup_before_sleep(const rclcpp::Clock::SharedPtr \u0026 clock)\n\u002B  {\n\u002B    std::atomic_bool thread_finished = false;\n\u002B\n\u002B    std::thread wait_thread = std::thread(\n\u002B      [\u0026clock, \u0026thread_finished]()\n\u002B      {\n\u002B        // make sure the thread starts sleeping late\n\u002B        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B        clock-\u003Esleep_until(clock-\u003Enow() \u002B std::chrono::seconds(3));\n\u002B        thread_finished = true;\n\u002B      });\n\u002B\n\u002B    // notify the clock, that the sleep shall be interrupted\n\u002B    clock-\u003Ecancel_sleep_or_wait();\n\u002B\n\u002B    auto start_time = std::chrono::steady_clock::now();\n\u002B    auto cur_time = start_time;\n\u002B    while (!thread_finished \u0026\u0026 start_time \u002B std::chrono::seconds(1) \u003E cur_time) {\n\u002B      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\u002B      cur_time = std::chrono::steady_clock::now();\n\u002B    }\n\u002B\n\u002B    wait_thread.join();\n\u002B\n\u002B    EXPECT_TRUE(thread_finished);\n\u002B    EXPECT_LT(cur_time, start_time \u002B std::chrono::seconds(1));\n\u002B  }\n\u002B\n\u002B  void test_wakeup_after_sleep(const rclcpp::Clock::SharedPtr \u0026 clock)\n\u002B  {\n\u002B    std::atomic_bool thread_finished = false;\n\u002B\n\u002B    std::thread wait_thread = std::thread(\n\u002B      [\u0026clock, \u0026thread_finished]()\n\u002B      {\n\u002B        clock-\u003Esleep_until(clock-\u003Enow() \u002B std::chrono::seconds(3));\n\u002B        thread_finished = true;\n\u002B      });\n\u002B\n\u002B    // make sure the thread is already sleeping before we send the cancel\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B\n\u002B    // notify the clock, that the sleep shall be interrupted\n\u002B    clock-\u003Ecancel_sleep_or_wait();\n\u002B\n\u002B    auto start_time = std::chrono::steady_clock::now();\n\u002B    auto cur_time = start_time;\n\u002B    while (!thread_finished \u0026\u0026 start_time \u002B std::chrono::seconds(1) \u003E cur_time) {\n\u002B      std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\u002B      cur_time = std::chrono::steady_clock::now();\n\u002B    }\n\u002B\n\u002B    wait_thread.join();\n\u002B\n\u002B    EXPECT_TRUE(thread_finished);\n\u002B    EXPECT_LT(cur_time, start_time \u002B std::chrono::seconds(1));\n\u002B  }\n\u002B\n\u002Bprotected:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void SetUp()\n\u002B  {\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    node.reset();\n\u002B  }\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B};\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  Clocks,\n\u002B  TestClockWakeup,\n\u002B  ::testing::Values(\n\u002B    RCL_SYSTEM_TIME, RCL_ROS_TIME, RCL_STEADY_TIME\n\u002B));\n\u002B\n\u002BTEST_P(TestClockWakeup, wakeup_sleep) {\n\u002B  auto clock = std::make_shared\u003Crclcpp::Clock\u003E(GetParam());\n\u002B  test_wakeup_after_sleep(clock);\n\u002B  test_wakeup_before_sleep(clock);\n\u002B}\n\u002B\n\u002BTEST_F(TestClockWakeup, wakeup_sleep_ros_time_active) {\n\u002B  node-\u003Eset_parameter({\u0022use_sim_time\u0022, true});\n\u002B  auto clock = std::make_shared\u003Crclcpp::Clock\u003E(RCL_ROS_TIME);\n\u002B  rclcpp::TimeSource time_source(node);\n\u002B  time_source.attachClock(clock);\n\u002B\n\u002B  EXPECT_TRUE(clock-\u003Eros_time_is_active());\n\u002B\n\u002B  test_wakeup_after_sleep(clock);\n\u002B  test_wakeup_before_sleep(clock);\n\u002B}\n\u002B\n\u002BTEST_F(TestClockWakeup, no_wakeup_on_sim_time) {\n\u002B  node-\u003Eset_parameter({\u0022use_sim_time\u0022, true});\n\u002B  auto clock = std::make_shared\u003Crclcpp::Clock\u003E(RCL_ROS_TIME);\n\u002B  rclcpp::TimeSource time_source(node);\n\u002B  time_source.attachClock(clock);\n\u002B\n\u002B  EXPECT_TRUE(clock-\u003Eros_time_is_active());\n\u002B\n\u002B  std::atomic_bool thread_finished = false;\n\u002B\n\u002B  std::thread wait_thread = std::thread(\n\u002B    [\u0026clock, \u0026thread_finished]()\n\u002B    {\n\u002B      // make sure the thread starts sleeping late\n\u002B      clock-\u003Esleep_until(clock-\u003Enow() \u002B std::chrono::milliseconds(10));\n\u002B      thread_finished = true;\n\u002B    });\n\u002B\n\u002B  // make sure, that the sim time clock does not wakeup, as no clock is provided\n\u002B  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n\u002B  EXPECT_FALSE(thread_finished);\n\u002B\n\u002B  // notify the clock, that the sleep shall be interrupted\n\u002B  clock-\u003Ecancel_sleep_or_wait();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  auto cur_time = start_time;\n\u002B  while (!thread_finished \u0026\u0026 start_time \u002B std::chrono::seconds(1) \u003E cur_time) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\u002B    cur_time = std::chrono::steady_clock::now();\n\u002B  }\n\u002B\n\u002B  wait_thread.join();\n\u002B\n\u002B  EXPECT_TRUE(thread_finished);\n\u002B  EXPECT_LT(cur_time, start_time \u002B std::chrono::seconds(1));\n\u002B}\n\u002B\n\u002BTEST_F(TestClockWakeup, multiple_threads_wait_on_one_clock) {\n\u002B  auto clock = std::make_shared\u003Crclcpp::Clock\u003E(RCL_ROS_TIME);\n\u002B\n\u002B  std::vector\u003Cbool\u003E thread_finished(10, false);\n\u002B\n\u002B  std::vector\u003Cstd::thread\u003E threads;\n\u002B\n\u002B  for (size_t nr = 0; nr \u003C thread_finished.size(); nr\u002B\u002B) {\n\u002B    threads.push_back(\n\u002B      std::thread(\n\u002B        [\u0026clock, \u0026thread_finished, nr]()\n\u002B        {\n\u002B          // make sure the thread starts sleeping late\n\u002B          clock-\u003Esleep_until(clock-\u003Enow() \u002B std::chrono::seconds(10));\n\u002B          thread_finished[nr] = true;\n\u002B        }));\n\u002B  }\n\u002B\n\u002B  // wait a bit so all threads can execute the sleep_until\n\u002B  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n\u002B\n\u002B  for (const bool \u0026 finished : thread_finished) {\n\u002B    EXPECT_FALSE(finished);\n\u002B  }\n\u002B\n\u002B  rclcpp::shutdown();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  auto cur_time = start_time;\n\u002B  bool threads_finished = false;\n\u002B  while (!threads_finished \u0026\u0026 start_time \u002B std::chrono::seconds(1) \u003E cur_time) {\n\u002B    threads_finished = true;\n\u002B    for (const bool finished : thread_finished) {\n\u002B      if (!finished) {\n\u002B        threads_finished = false;\n\u002B      }\n\u002B    }\n\u002B\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\u002B    cur_time = std::chrono::steady_clock::now();\n\u002B  }\n\u002B\n\u002B  for (const bool finished : thread_finished) {\n\u002B    EXPECT_TRUE(finished);\n\u002B  }\n\u002B\n\u002B  for (auto \u0026 thread : threads) {\n\u002B    thread.join();\n\u002B  }\n\u002B\n\u002B  EXPECT_LT(cur_time, start_time \u002B std::chrono::seconds(1));\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "ac136656581751029e31138f379dcfd54263e114",
    "RawMessage": "Fix memory leak. (#828)",
    "Changes": "diff --git rclpy/src/rclpy/client.cpp rclpy/src/rclpy/client.cpp\nindex f7e2f99..7fa75fc 100644\n--- rclpy/src/rclpy/client.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/client.cpp\n@@ -137,8 \u002B137,6 @@ Client::take_response(py::object pyresponse_type)\n   result_tuple[0] = header;\n \n   result_tuple[1] = convert_to_py(taken_response.get(), pyresponse_type);\n-  // result_tuple now owns the message\n-  taken_response.release();\n \n   return result_tuple;\n }\ndiff --git rclpy/src/rclpy/service.cpp rclpy/src/rclpy/service.cpp\nindex 25426da..952f46c 100644\n--- rclpy/src/rclpy/service.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/service.cpp\n@@ -119,7 \u002B119,6 @@ Service::service_take_request(py::object pyrequest_type)\n \n   result_tuple[1] = header;\n   result_tuple[0] = convert_to_py(taken_request.get(), pyrequest_type);\n-  taken_request.release();\n \n   return result_tuple;\n }\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "4a2231d7a5bbfacaeef5b914a7f8b97500d89ade",
    "RawMessage": "Test exception in spin_until_future_complete. (#1345)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_executor.cpp rclcpp/test/rclcpp/test_executor.cpp\nindex 54451814..7142ca4e 100644\n--- rclcpp/test/rclcpp/test_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_executor.cpp\n@@ -451,3 \u002B451,33 @@ TEST_F(TestExecutor, get_group_by_timer_add_callback_group) {\n \n   ASSERT_EQ(cb_group.get(), dummy.local_get_group_by_timer(timer).get());\n }\n\u002B\n\u002BTEST_F(TestExecutor, spin_until_future_complete_in_spin_until_future_complete) {\n\u002B  DummyExecutor dummy;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  bool spin_until_future_complete_in_spin_until_future_complete = false;\n\u002B  auto timer =\n\u002B    node-\u003Ecreate_wall_timer(\n\u002B    std::chrono::milliseconds(1), [\u0026]() {\n\u002B      try {\n\u002B        std::promise\u003Cvoid\u003E promise;\n\u002B        std::future\u003Cvoid\u003E future = promise.get_future();\n\u002B        dummy.spin_until_future_complete(future, std::chrono::milliseconds(1));\n\u002B      } catch (const std::runtime_error \u0026 err) {\n\u002B        if (err.what() == std::string(\n\u002B          \u0022spin_until_future_complete() called while already spinning\u0022))\n\u002B        {\n\u002B          spin_until_future_complete_in_spin_until_future_complete = true;\n\u002B        }\n\u002B      }\n\u002B    });\n\u002B\n\u002B  dummy.add_node(node);\n\u002B  // Wait for the wall timer to have expired.\n\u002B  std::this_thread::sleep_for(std::chrono::milliseconds(50));\n\u002B  EXPECT_FALSE(spin_until_future_complete_in_spin_until_future_complete);\n\u002B  std::promise\u003Cvoid\u003E promise;\n\u002B  std::future\u003Cvoid\u003E future = promise.get_future();\n\u002B  dummy.spin_until_future_complete(future, std::chrono::milliseconds(1));\n\u002B  EXPECT_TRUE(spin_until_future_complete_in_spin_until_future_complete);\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "5c54f57ba409b1a096f9310a9b75d67731137b39",
    "RawMessage": "Make resource file paths relative (#862)",
    "Changes": "diff --git rviz_ogre_vendor/CMakeLists.txt rviz_ogre_vendor/CMakeLists.txt\nindex faf744d8..7f480f55 100644\n--- rviz_ogre_vendor/CMakeLists.txt\n\u002B\u002B\u002B rviz_ogre_vendor/CMakeLists.txt\n@@ -185,7 \u002B185,8 @@ macro(build_ogre)\n       -Wno-dev\n     PATCH_COMMAND\n       ${Patch_EXECUTABLE} -p1 -N \u003C ${CMAKE_CURRENT_SOURCE_DIR}/pragma-patch.diff \u0026\u0026\n-      ${Patch_EXECUTABLE} -p1 -N \u003C ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff\n\u002B      ${Patch_EXECUTABLE} -p1 -N \u003C ${CMAKE_CURRENT_SOURCE_DIR}/fix-arm64.diff \u0026\u0026\n\u002B      ${Patch_EXECUTABLE} -p1 -N \u003C ${CMAKE_CURRENT_SOURCE_DIR}/relocatable.patch\n     COMMAND\n       ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/FindFreetype.cmake ${CMAKE_CURRENT_BINARY_DIR}/ogre-v1.12.1-prefix/src/ogre-v1.12.1/CMake/Packages/FindFreetype.cmake\n   )\ndiff --git rviz_ogre_vendor/relocatable.patch rviz_ogre_vendor/relocatable.patch\nnew file mode 100644\nindex 00000000..de12e785\n--- /dev/null\n\u002B\u002B\u002B rviz_ogre_vendor/relocatable.patch\n@@ -0,0 \u002B1,24 @@\n\u002Bdiff -uNr a/CMake/InstallResources.cmake b/CMake/InstallResources.cmake\n\u002B--- a/CMake/InstallResources.cmake\t2022-05-09 17:30:13.273565553 -0700\n\u002B\u002B\u002B\u002B b/CMake/InstallResources.cmake\t2022-05-09 17:29:53.013345872 -0700\n\u002B@@ -59,6 \u002B59,20 @@\n\u002B   endif()\n\u002B endif()\n\u002B \n\u002B\u002B# ensure installation is relocatable\n\u002B\u002Bif (IS_ABSOLUTE \u0022${OGRE_MEDIA_DIR_REL}\u0022)\n\u002B\u002B  file(RELATIVE_PATH OGRE_MEDIA_DIR_REL \u0022${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\u0022 \u0022${OGRE_MEDIA_DIR_REL}\u0022)\n\u002B\u002Bendif ()\n\u002B\u002Bif (IS_ABSOLUTE \u0022${OGRE_TEST_MEDIA_DIR_REL}\u0022)\n\u002B\u002B  file(RELATIVE_PATH OGRE_TEST_MEDIA_DIR_REL \u0022${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\u0022 \u0022${OGRE_TEST_MEDIA_DIR_REL}\u0022)\n\u002B\u002Bendif ()\n\u002B\u002Bif (IS_ABSOLUTE \u0022${OGRE_PLUGIN_DIR_REL}\u0022)\n\u002B\u002B  file(RELATIVE_PATH OGRE_PLUGIN_DIR_REL \u0022${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\u0022 \u0022${OGRE_PLUGIN_DIR_REL}\u0022)\n\u002B\u002Bendif ()\n\u002B\u002Bif (IS_ABSOLUTE \u0022${OGRE_SAMPLES_DIR_REL}\u0022)\n\u002B\u002B  file(RELATIVE_PATH OGRE_SAMPLES_DIR_REL \u0022${CMAKE_INSTALL_PREFIX}/${OGRE_CFG_INSTALL_PATH}\u0022 \u0022${OGRE_SAMPLES_DIR_REL}\u0022)\n\u002B\u002Bendif ()\n\u002B\u002B\n\u002B # configure plugins.cfg\n\u002B if (NOT OGRE_BUILD_RENDERSYSTEM_D3D9)\n\u002B   set(OGRE_COMMENT_RENDERSYSTEM_D3D9 \u0022#\u0022)\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2c551ab6876acbedaaaecb6a5b89bccdb92e7258",
    "RawMessage": "Fix typo in the error message",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex e4dfbd0..17cd9d5 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1650,7 \u002B1650,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n     auto sample_ptr = init_and_alloc_sample(pub, d-\u003Etype-\u003Eiox_size);\n     RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n     if (rmw_deserialize(serialized_message, \u0026pub-\u003Etype_supports, sample_ptr) != RMW_RET_OK) {\n-      RMW_SET_ERROR_MSG(\u0022Failed to deserialize sample into laoned memory\u0022);\n\u002B      RMW_SET_ERROR_MSG(\u0022Failed to deserialize sample into loaned memory\u0022);\n       return RMW_RET_ERROR;\n     }\n     d-\u003Eiox_chunk = SHIFT_BACK_TO_ICEORYX_HEADER(sample_ptr);\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "bf660c543d3ecb091cc69e13cdd755d1186aca55",
    "RawMessage": "Tests for LoanedMessage with mocked loaned message publisher (#1366)",
    "Changes": "diff --git rclcpp/test/CMakeLists.txt rclcpp/test/CMakeLists.txt\nindex 68daa38d..a39bb146 100644\n--- rclcpp/test/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/CMakeLists.txt\n@@ -171,7 \u002B171,7 @@ ament_add_gtest(test_loaned_message rclcpp/test_loaned_message.cpp)\n ament_target_dependencies(test_loaned_message\n   \u0022test_msgs\u0022\n )\n-target_link_libraries(test_loaned_message ${PROJECT_NAME})\n\u002Btarget_link_libraries(test_loaned_message ${PROJECT_NAME} mimick)\n \n ament_add_gtest(test_memory_strategy rclcpp/test_memory_strategy.cpp)\n ament_target_dependencies(test_memory_strategy\ndiff --git rclcpp/test/rclcpp/test_loaned_message.cpp rclcpp/test/rclcpp/test_loaned_message.cpp\nindex 651b3670..b68024c7 100644\n--- rclcpp/test/rclcpp/test_loaned_message.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_loaned_message.cpp\n@@ -20,6 \u002B20,8 @@\n \n #include \u0022test_msgs/msg/basic_types.hpp\u0022\n \n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n using MessageT = test_msgs::msg::BasicTypes;\n using LoanedMessageT = rclcpp::LoanedMessage\u003CMessageT\u003E;\n \n@@ -81,3 \u002B83,51 @@ TEST_F(TestLoanedMessage, release) {\n \n   SUCCEED();\n }\n\u002B\n\u002BTEST_F(TestLoanedMessage, construct_with_loaned_message_publisher) {\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022loaned_message_test_node\u0022);\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003CMessageT\u003E(\u0022topic\u0022, 10);\n\u002B  std::allocator\u003CMessageT\u003E allocator;\n\u002B\n\u002B  auto mock_can_loan = mocking_utils::patch_and_return(\n\u002B    \u0022lib:rclcpp\u0022, rcl_publisher_can_loan_messages, true);\n\u002B\n\u002B  {\n\u002B    auto mock_borrow_loaned = mocking_utils::patch_and_return(\n\u002B      \u0022self\u0022, rcl_borrow_loaned_message, RCL_RET_ERROR);\n\u002B\n\u002B    EXPECT_THROW(\n\u002B      std::make_shared\u003CLoanedMessageT\u003E(*publisher.get(), allocator).reset(),\n\u002B      rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B\n\u002B  MessageT message;\n\u002B  auto borrow_loaned_message_callback =\n\u002B    [\u0026message](\n\u002B    const rcl_publisher_t *, const rosidl_message_type_support_t *, void ** ros_message) {\n\u002B      *ros_message = \u0026message;\n\u002B      return RCL_RET_OK;\n\u002B    };\n\u002B  auto mock_borrow_loaned = mocking_utils::patch(\n\u002B    \u0022self\u0022, rcl_borrow_loaned_message, borrow_loaned_message_callback);\n\u002B\n\u002B  {\n\u002B    auto mock_return_loaned = mocking_utils::patch_and_return(\n\u002B      \u0022self\u0022, rcl_return_loaned_message_from_publisher, RCL_RET_OK);\n\u002B\n\u002B    auto loaned_message = std::make_shared\u003CLoanedMessageT\u003E(*publisher.get(), allocator);\n\u002B    EXPECT_TRUE(loaned_message-\u003Eis_valid());\n\u002B    EXPECT_NO_THROW(loaned_message.reset());\n\u002B  }\n\u002B\n\u002B  {\n\u002B    auto loaned_message = std::make_shared\u003CLoanedMessageT\u003E(*publisher.get(), allocator);\n\u002B    EXPECT_TRUE(loaned_message-\u003Eis_valid());\n\u002B\n\u002B    auto mock_return_loaned = mocking_utils::patch_and_return(\n\u002B      \u0022self\u0022, rcl_return_loaned_message_from_publisher, RCL_RET_ERROR);\n\u002B\n\u002B    // No exception, it just logs an error\n\u002B    EXPECT_NO_THROW(loaned_message.reset());\n\u002B  }\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw",
    "SHA": "c5c05f199fe702b62d666ce744801d0fa12d6682",
    "RawMessage": "Add declaration for function to check QoS profile compatibility (#299)",
    "Changes": "diff --git rmw/include/rmw/qos_profiles.h rmw/include/rmw/qos_profiles.h\nindex 0e39c6f..be5c26c 100644\n--- rmw/include/rmw/qos_profiles.h\n\u002B\u002B\u002B rmw/include/rmw/qos_profiles.h\n@@ -113,6 \u002B113,73 @@ static const rmw_qos_profile_t rmw_qos_profile_unknown =\n   false\n };\n \n\u002Btypedef enum RMW_PUBLIC_TYPE rmw_qos_compatibility_type_t\n\u002B{\n\u002B  /// QoS policies are compatible\n\u002B  RMW_QOS_COMPATIBILITY_OK = 0,\n\u002B\n\u002B  /// QoS policies may not be compatible\n\u002B  RMW_QOS_COMPATIBILITY_WARNING,\n\u002B\n\u002B  /// QoS policies are not compatible\n\u002B  RMW_QOS_COMPATIBILITY_ERROR\n\u002B} rmw_qos_compatibility_type_t;\n\u002B\n\u002B\n\u002B/// Check if two QoS profiles are compatible.\n\u002B/**\n\u002B * Two QoS profiles are compatible if a publisher and subcription\n\u002B * using the QoS policies can communicate with each other.\n\u002B *\n\u002B * If any of the profile policies has the value \u0022system default\u0022 or \u0022unknown\u0022, then it may not be\n\u002B * possible to determine the compatibilty.\n\u002B * In this case, the output parameter \u0060compatibility\u0060 is set to \u0060RMW_QOS_COMPATIBILITY_WARNING\u0060\n\u002B * and \u0060reason\u0060 is populated.\n\u002B *\n\u002B * If there is a compatibility warning or error, and a buffer is provided for \u0060reason\u0060, then an\n\u002B * explanation of all warnings and errors will be populated into the buffer, separated by\n\u002B * semi-colons (\u0060;\u0060).\n\u002B * Errors will appear before warnings in the string buffer.\n\u002B * If the provided buffer is not large enough, this function will still write to the buffer, up to\n\u002B * the \u0060reason_size\u0060 number of characters.\n\u002B * Therefore, it is possible that not all errors and warnings are communicated if the buffer size limit\n\u002B * is reached.\n\u002B * A buffer size of 2048 should be more than enough to capture all possible errors and warnings.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | No\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | No\n\u002B * Lock-Free          | Yes\n\u002B *\n\u002B * \\param[in] publisher_profile: The QoS profile used for a publisher.\n\u002B * \\param[in] subscription_profile: The QoS profile used for a subscription.\n\u002B * \\param[out] compatibility: \u0060RMW_QOS_COMPATIBILITY_OK\u0060 if the QoS profiles are compatible, or\n\u002B *   \u0060RMW_QOS_COMPATIBILITY_WARNING\u0060 if the QoS profiles might be compatible, or\n\u002B *   \u0060RMW_QOS_COMPATIBILITY_ERROR\u0060 if the QoS profiles are not compatible.\n\u002B * \\param[out] reason: A detailed reason for a QoS incompatibility or potential incompatibility.\n\u002B *   Must be pre-allocated by the caller.\n\u002B *   This parameter is optional and may be set to \u0060NULL\u0060 if the reason information is not\n\u002B *   desired.\n\u002B * \\param[in] reason_size: Size of the string buffer \u0060reason\u0060, if one is provided.\n\u002B *   If \u0060reason\u0060 is \u0060nullptr\u0060, then this parameter must be zero.\n\u002B * \\return \u0060RMW_RET_OK\u0060 if the check was successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060compatiblity\u0060 is \u0060nullptr\u0060, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060reason\u0060 is \u0060NULL\u0060 and  \u0060reason_size\u0060 is not zero, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 if there is an unexpected error.\n\u002B */\n\u002BRMW_PUBLIC\n\u002BRMW_WARN_UNUSED\n\u002Brmw_ret_t\n\u002Brmw_qos_profile_check_compatible(\n\u002B  const rmw_qos_profile_t publisher_profile,\n\u002B  const rmw_qos_profile_t subscription_profile,\n\u002B  rmw_qos_compatibility_type_t * compatibility,\n\u002B  char * reason,\n\u002B  size_t reason_size);\n\u002B\n #ifdef __cplusplus\n }\n #endif\ndiff --git rmw/include/rmw/rmw.h rmw/include/rmw/rmw.h\nindex 08da4ee..d9714ed 100644\n--- rmw/include/rmw/rmw.h\n\u002B\u002B\u002B rmw/include/rmw/rmw.h\n@@ -40,6 \u002B40,9 @@\n  * - A function to validate a node\u0027s name\n  *   - rmw_validate_node_name()\n  *   - rmw/validate_node_name.h\n\u002B * - A function to validate the compatibility of two QoS profiles\n\u002B *   - rmw_qos_profile_check_compatible()\n\u002B *   - rmw/qos_profiles.h\n  *\n  * It also has some machinery that is necessary to wait on and act on these concepts:\n  *\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "47fdb6326a2300ef6aa12f628565d177cb26a9eb",
    "RawMessage": "Add in additional tests for parameter_client.cpp coverage.",
    "Changes": "diff --git rclcpp/test/rclcpp/test_parameter_client.cpp rclcpp/test/rclcpp/test_parameter_client.cpp\nindex 523cd3fd..9e5bcdd4 100644\n--- rclcpp/test/rclcpp/test_parameter_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_client.cpp\n@@ -14,8 \u002B14,13 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n-#include \u003Cstring\u003E\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cfuture\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n \n #include \u0022rclcpp/rclcpp.hpp\u0022\n \n@@ -182,3 \u002B187,107 @@ TEST_F(TestParameterClient, sync_parameter_is_ready) {\n   EXPECT_TRUE(client.wait_for_service());\n   EXPECT_TRUE(client.service_is_ready());\n }\n\u002B\n\u002B/*\n\u002B  Coverage for async get_parameter_types\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_get_parameter_types) {\n\u002B  auto asynchronous_client = std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(node);\n\u002B  bool callback_called = false;\n\u002B  auto callback = [\u0026callback_called](std::shared_future\u003Cstd::vector\u003Crclcpp::ParameterType\u003E\u003E result)\n\u002B    {\n\u002B      // We expect the result to be empty since we tried to get a parameter that didn\u0027t exist.\n\u002B      if (result.valid() \u0026\u0026 result.get().size() == 0) {\n\u002B        callback_called = true;\n\u002B      }\n\u002B    };\n\u002B  std::vector\u003Cstd::string\u003E names{\u0022foo\u0022};\n\u002B  std::shared_future\u003Cstd::vector\u003Crclcpp::ParameterType\u003E\u003E future =\n\u002B    asynchronous_client-\u003Eget_parameter_types(names, callback);\n\u002B  auto return_code = rclcpp::spin_until_future_complete(\n\u002B    node, future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n\u002B  ASSERT_TRUE(callback_called);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async get_parameters\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_get_parameters) {\n\u002B  auto asynchronous_client = std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(node);\n\u002B  bool callback_called = false;\n\u002B  auto callback = [\u0026callback_called](std::shared_future\u003Cstd::vector\u003Crclcpp::Parameter\u003E\u003E result)\n\u002B    {\n\u002B      if (result.valid() \u0026\u0026 result.get().size() == 1 \u0026\u0026 result.get()[0].get_name() == \u0022foo\u0022) {\n\u002B        callback_called = true;\n\u002B      }\n\u002B    };\n\u002B  std::vector\u003Cstd::string\u003E names{\u0022foo\u0022};\n\u002B  std::shared_future\u003Cstd::vector\u003Crclcpp::Parameter\u003E\u003E future = asynchronous_client-\u003Eget_parameters(\n\u002B    names, callback);\n\u002B  auto return_code = rclcpp::spin_until_future_complete(\n\u002B    node, future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n\u002B  ASSERT_TRUE(callback_called);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async set_parameters_atomically\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_set_parameters_atomically) {\n\u002B  auto asynchronous_client = std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(node);\n\u002B  bool callback_called = false;\n\u002B  auto callback =\n\u002B    [\u0026callback_called](std::shared_future\u003Crcl_interfaces::msg::SetParametersResult\u003E result)\n\u002B    {\n\u002B      // We expect this to fail since we didn\u0027t declare the parameter first.\n\u002B      if (result.valid() \u0026\u0026 !result.get().successful \u0026\u0026\n\u002B        result.get().reason == \u0022One or more parameters were not declared before setting\u0022)\n\u002B      {\n\u002B        callback_called = true;\n\u002B      }\n\u002B    };\n\u002B  std::vector\u003Crclcpp::Parameter\u003E parameters;\n\u002B  parameters.emplace_back(rclcpp::Parameter(\u0022foo\u0022));\n\u002B  std::shared_future\u003Crcl_interfaces::msg::SetParametersResult\u003E future =\n\u002B    asynchronous_client-\u003Eset_parameters_atomically(parameters, callback);\n\u002B  auto return_code = rclcpp::spin_until_future_complete(\n\u002B    node, future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n\u002B  ASSERT_TRUE(callback_called);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for async list_parameters\n\u002B */\n\u002BTEST_F(TestParameterClient, async_parameter_list_parameters) {\n\u002B  auto asynchronous_client = std::make_shared\u003Crclcpp::AsyncParametersClient\u003E(node);\n\u002B  bool callback_called = false;\n\u002B  auto callback =\n\u002B    [\u0026callback_called](std::shared_future\u003Crcl_interfaces::msg::ListParametersResult\u003E result)\n\u002B    {\n\u002B      if (result.valid() \u0026\u0026 result.get().names.size() == 0 \u0026\u0026 result.get().prefixes.size() == 0) {\n\u002B        callback_called = true;\n\u002B      }\n\u002B    };\n\u002B  std::vector\u003Cstd::string\u003E prefixes{\u0022foo\u0022};\n\u002B  std::shared_future\u003Crcl_interfaces::msg::ListParametersResult\u003E future =\n\u002B    asynchronous_client-\u003Elist_parameters(prefixes, 0, callback);\n\u002B  auto return_code = rclcpp::spin_until_future_complete(\n\u002B    node, future, std::chrono::milliseconds(100));\n\u002B  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, return_code);\n\u002B  ASSERT_TRUE(callback_called);\n\u002B}\n\u002B\n\u002B/*\n\u002B  Coverage for sync get_parameter_types\n\u002B */\n\u002BTEST_F(TestParameterClient, sync_parameter_get_parameter_types) {\n\u002B  node-\u003Edeclare_parameter(\u0022foo\u0022, 4);\n\u002B  auto synchronous_client = std::make_shared\u003Crclcpp::SyncParametersClient\u003E(node);\n\u002B  std::vector\u003Cstd::string\u003E names{\u0022foo\u0022};\n\u002B  std::vector\u003Crclcpp::ParameterType\u003E parameter_types =\n\u002B    synchronous_client-\u003Eget_parameter_types(names);\n\u002B  ASSERT_EQ(1u, parameter_types.size());\n\u002B  ASSERT_EQ(rclcpp::ParameterType::PARAMETER_INTEGER, parameter_types[0]);\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "8e4c601a896931287f33a6a7ca536f98952f7d40",
    "RawMessage": "Clarify storing of current_time. (#850)",
    "Changes": "diff --git rcl/src/rcl/time.c rcl/src/rcl/time.c\nindex 852cb8f..22426f0 100644\n--- rcl/src/rcl/time.c\n\u002B\u002B\u002B rcl/src/rcl/time.c\n@@ -370,10 \u002B370,10 @@ rcl_set_ros_time_override(\n     }\n     time_jump.delta.nanoseconds = time_value - current_time;\n     rcl_clock_call_callbacks(clock, \u0026time_jump, true);\n-  }\n-  rcutils_atomic_store(\u0026(storage-\u003Ecurrent_time), time_value);\n-  if (storage-\u003Eactive) {\n\u002B    rcutils_atomic_store(\u0026(storage-\u003Ecurrent_time), time_value);\n     rcl_clock_call_callbacks(clock, \u0026time_jump, false);\n\u002B  } else {\n\u002B    rcutils_atomic_store(\u0026(storage-\u003Ecurrent_time), time_value);\n   }\n   return RCL_RET_OK;\n }\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "4d0be32e6c455edbf708003dffb67b11d512c5a6",
    "RawMessage": "Capture \u0060std::bad_alloc\u0060 on deserializeROSmessage. (#665)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/type_support_common.cpp rmw_fastrtps_cpp/src/type_support_common.cpp\nindex 4e5dff1..eb3d382 100644\n--- rmw_fastrtps_cpp/src/type_support_common.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/type_support_common.cpp\n@@ -119,6 \u002B119,11 @@ bool TypeSupport::deserializeROSmessage(\n       \u0022Fast CDR exception deserializing message of type %s.\u0022,\n       getName());\n     return false;\n\u002B  } catch (const std::bad_alloc \u0026) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022\u0027Bad alloc\u0027 exception deserializing message of type %s.\u0022,\n\u002B      getName());\n\u002B    return false;\n   }\n \n   return true;\ndiff --git rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\nindex f673fe0..899119f 100644\n--- rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/include/rmw_fastrtps_dynamic_cpp/TypeSupport_impl.hpp\n@@ -983,6 \u002B983,11 @@ bool TypeSupport\u003CMembersType\u003E::deserializeROSmessage(\n       \u0022Fast CDR exception deserializing message of type %s.\u0022,\n       getName());\n     return false;\n\u002B  } catch (const std::bad_alloc \u0026) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022\u0027Bad alloc\u0027 exception deserializing message of type %s.\u0022,\n\u002B      getName());\n\u002B    return false;\n   }\n \n   return true;\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "7c883f21bc3fa5462788b2f8e0919f44cec7f393",
    "RawMessage": "Use rosidl_get_typesupport_target and target_link_libraries (#57)",
    "Changes": "diff --git rmw_dds_common/CMakeLists.txt rmw_dds_common/CMakeLists.txt\nindex 93d86c5..2f6baec 100644\n--- rmw_dds_common/CMakeLists.txt\n\u002B\u002B\u002B rmw_dds_common/CMakeLists.txt\n@@ -21,7 \u002B21,6 @@ ament_export_dependencies(ament_cmake_core)\n ament_export_dependencies(rcpputils)\n ament_export_dependencies(rcutils)\n ament_export_dependencies(rmw)\n-ament_export_dependencies(rosidl_default_runtime)\n \n rosidl_generate_interfaces(\n   ${PROJECT_NAME}\n@@ -39,20 \u002B38,25 @@ add_library(${PROJECT_NAME}_library SHARED\n \n set_target_properties(${PROJECT_NAME}_library\n   PROPERTIES OUTPUT_NAME ${PROJECT_NAME})\n-ament_target_dependencies(${PROJECT_NAME}_library\n-  \u0022rcpputils\u0022\n-  \u0022rcutils\u0022\n-  \u0022rmw\u0022\n-  \u0022rosidl_runtime_cpp\u0022)\n-add_dependencies(${PROJECT_NAME}_library\n-  ${PROJECT_NAME})\n\u002Btarget_link_libraries(${PROJECT_NAME}_library PUBLIC\n\u002B  rcutils::rcutils\n\u002B  rmw::rmw)\n\u002Btarget_link_libraries(${PROJECT_NAME}_library PRIVATE\n\u002B  rcpputils::rcpputils)\n target_include_directories(${PROJECT_NAME}_library\n   PUBLIC\n   \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n-  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_c\u003E\u0022\n-  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp\u003E\u0022\n   \u0022$\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\u0022)\n \n\u002B# Wait for all rosidl generators to finish before building this library\n\u002Badd_dependencies(${PROJECT_NAME}_library\n\u002B  ${PROJECT_NAME})\n\u002B\n\u002B# Depend on the generated C\u002B\u002B messages\n\u002Brosidl_get_typesupport_target(cpp_typesupport_target \u0022${PROJECT_NAME}\u0022 \u0022rosidl_generator_cpp\u0022)\n\u002Btarget_link_libraries(${PROJECT_NAME}_library PUBLIC\n\u002B  ${cpp_typesupport_target})\n\u002B\n # Causes the visibility macros to use dllexport rather than dllimport,\n # which is appropriate when building the dll but not consuming it.\n target_compile_definitions(${PROJECT_NAME}_library\n@@ -110,7 \u002B114,9 @@ if(BUILD_TESTING)\n \n   ament_add_gmock(test_security test/test_security.cpp)\n   if(TARGET test_security)\n-    target_link_libraries(test_security ${PROJECT_NAME}_library)\n\u002B    target_link_libraries(test_security\n\u002B      ${PROJECT_NAME}_library\n\u002B      rcpputils::rcpputils)\n   endif()\n \n   add_performance_test(benchmark_graph_cache test/benchmark/benchmark_graph_cache.cpp)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "96cccf5fdef6401b14974595d3481f9cc2223d30",
    "RawMessage": "fix topic stats test, wait for more messages, only check the ones with samples (#1274)",
    "Changes": "diff --git rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\nindex dc4e1fa8..de3bd00b 100644\n--- rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n@@ -284,7 \u002B284,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n   auto statistics_listener = std::make_shared\u003Crclcpp::topic_statistics::MetricsMessageSubscriber\u003E(\n     \u0022test_receive_single_empty_stats_message_listener\u0022,\n     \u0022/statistics\u0022,\n-    2);\n\u002B    4);\n \n   auto empty_subscriber = std::make_shared\u003CEmptySubscriber\u003E(\n     kTestSubNodeName,\n@@ -301,12 \u002B301,12 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n     kTestDuration);\n \n   // Compare message counts, sample count should be the same as published and received count\n-  EXPECT_EQ(2, statistics_listener-\u003EGetNumberOfMessagesReceived());\n\u002B  EXPECT_EQ(4, statistics_listener-\u003EGetNumberOfMessagesReceived());\n \n   // Check the received message and the data types\n   const auto received_messages = statistics_listener-\u003EGetReceivedMessages();\n \n-  EXPECT_EQ(2u, received_messages.size());\n\u002B  EXPECT_EQ(4u, received_messages.size());\n \n   std::set\u003Cstd::string\u003E received_metrics;\n   for (const auto \u0026 msg : received_messages) {\n@@ -318,10 \u002B318,27 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n   // Check the collected statistics for message period.\n   // Message age statistics will not be calculated because Empty messages\n   // don\u0027t have a \u0060header\u0060 with timestamp.\n\u002B  bool any_samples = false;\n   for (const auto \u0026 msg : received_messages) {\n     if (msg.metrics_source != \u0022message_period\u0022) {\n       continue;\n     }\n\u002B    // skip messages without samples\n\u002B    bool has_samples = false;\n\u002B    for (const auto \u0026 stats_point : msg.statistics) {\n\u002B      const auto type = stats_point.data_type;\n\u002B      if (\n\u002B        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type \u0026\u0026\n\u002B        stats_point.data \u003E 0)\n\u002B      {\n\u002B        has_samples = true;\n\u002B        break;\n\u002B      }\n\u002B    }\n\u002B    if (!has_samples) {\n\u002B      continue;\n\u002B    }\n\u002B    any_samples = true;\n     for (const auto \u0026 stats_point : msg.statistics) {\n       const auto type = stats_point.data_type;\n       switch (type) {\n@@ -346,6 \u002B363,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n       }\n     }\n   }\n\u002B  EXPECT_TRUE(any_samples) \u003C\u003C \u0022All received metrics messages had zero samples\u0022;\n }\n \n TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_with_header)\n@@ -361,7 \u002B379,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n   auto statistics_listener = std::make_shared\u003Crclcpp::topic_statistics::MetricsMessageSubscriber\u003E(\n     \u0022test_receive_stats_for_message_with_header\u0022,\n     \u0022/statistics\u0022,\n-    2);\n\u002B    4);\n \n   auto msg_with_header_subscriber = std::make_shared\u003CMessageWithHeaderSubscriber\u003E(\n     kTestSubNodeName,\n@@ -378,12 \u002B396,12 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n     kTestDuration);\n \n   // Compare message counts, sample count should be the same as published and received count\n-  EXPECT_EQ(2, statistics_listener-\u003EGetNumberOfMessagesReceived());\n\u002B  EXPECT_EQ(4, statistics_listener-\u003EGetNumberOfMessagesReceived());\n \n   // Check the received message and the data types\n   const auto received_messages = statistics_listener-\u003EGetReceivedMessages();\n \n-  EXPECT_EQ(2u, received_messages.size());\n\u002B  EXPECT_EQ(4u, received_messages.size());\n \n   std::set\u003Cstd::string\u003E received_metrics;\n   for (const auto \u0026 msg : received_messages) {\n@@ -393,7 \u002B411,24 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n   EXPECT_TRUE(received_metrics.find(\u0022message_period\u0022) != received_metrics.end());\n \n   // Check the collected statistics for message period.\n\u002B  bool any_samples = false;\n   for (const auto \u0026 msg : received_messages) {\n\u002B    // skip messages without samples\n\u002B    bool has_samples = false;\n\u002B    for (const auto \u0026 stats_point : msg.statistics) {\n\u002B      const auto type = stats_point.data_type;\n\u002B      if (\n\u002B        StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT == type \u0026\u0026\n\u002B        stats_point.data \u003E 0)\n\u002B      {\n\u002B        has_samples = true;\n\u002B        break;\n\u002B      }\n\u002B    }\n\u002B    if (!has_samples) {\n\u002B      continue;\n\u002B    }\n\u002B    any_samples = true;\n     for (const auto \u0026 stats_point : msg.statistics) {\n       const auto type = stats_point.data_type;\n       switch (type) {\n@@ -418,4 \u002B453,5 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n       }\n     }\n   }\n\u002B  EXPECT_TRUE(any_samples) \u003C\u003C \u0022All received metrics messages had zero samples\u0022;\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw",
    "SHA": "9ad0ac4dc74ffbd7991b7d57739f3777ca2529db",
    "RawMessage": "Remove unnecessary c\u002B\u002B14 flag. (#360)",
    "Changes": "diff --git rmw/test/CMakeLists.txt rmw/test/CMakeLists.txt\nindex ff63281..3e4f0b1 100644\n--- rmw/test/CMakeLists.txt\n\u002B\u002B\u002B rmw/test/CMakeLists.txt\n@@ -176,9 \u002B176,6 @@ if(TARGET test_validate_namespace)\n   if(UNIX AND NOT APPLE AND NOT ANDROID)\n     target_link_libraries(test_validate_namespace pthread)\n   endif()\n-  if(NOT WIN32)\n-    set_target_properties(test_validate_namespace PROPERTIES COMPILE_FLAGS \u0022-std=c\u002B\u002B14\u0022)\n-  endif()\n endif()\n \n ament_add_gmock(test_topic_endpoint_info_array\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "7fb093ba17daa6fdacb22d383c1e90933b860de9",
    "RawMessage": "Remove \u0060SHARED\u0060 (#1305)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 15ce01a..389bdf4 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -78,7 \u002B78,7 @@ function(configure_build_install_location _library_name)\n endfunction()\n \n # Split from main extension and converted to pybind11\n-pybind11_add_module(_rclpy_pybind11 SHARED\n\u002Bpybind11_add_module(_rclpy_pybind11\n   src/rclpy/_rclpy_logging.cpp\n   src/rclpy/_rclpy_pybind11.cpp\n   src/rclpy/action_client.cpp\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "01f6ebdd3d0c679adfd4c64fcd06f5133164ed40",
    "RawMessage": "RCLCPP_PUBLIC -\u003E RCLCPP_LIFECYCLE_PUBLIC (#1732)",
    "Changes": "diff --git rclcpp_lifecycle/include/rclcpp_lifecycle/lifecycle_node.hpp rclcpp_lifecycle/include/rclcpp_lifecycle/lifecycle_node.hpp\nindex 028afe4b..4442304c 100644\n--- rclcpp_lifecycle/include/rclcpp_lifecycle/lifecycle_node.hpp\n\u002B\u002B\u002B rclcpp_lifecycle/include/rclcpp_lifecycle/lifecycle_node.hpp\n@@ -193,7 \u002B193,7 @@ public:\n     bool automatically_add_to_executor_with_node = true);\n \n   /// Iterate over the callback groups in the node, calling func on each valid one.\n-  RCLCPP_PUBLIC\n\u002B  RCLCPP_LIFECYCLE_PUBLIC\n   void\n   for_each_callback_group(\n     const rclcpp::node_interfaces::NodeBaseInterface::CallbackGroupFunction \u0026 func);\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "9a144bf040fb8c74058c6b4fd9830fd0e0e3594e",
    "RawMessage": "Check if Task(Future) is canceled. (#1377)",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex 9e4c7e4..b74727d 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -348,14 \u002B348,24 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n         future.add_done_callback(lambda x: self.wake())\n \n         if timeout_sec is None or timeout_sec \u003C 0:\n-            while self._context.ok() and not future.done() and not self._is_shutdown:\n\u002B            while (\n\u002B                self._context.ok()\n\u002B                and not future.done()\n\u002B                and not future.cancelled()\n\u002B                and not self._is_shutdown\n\u002B            ):\n                 self._spin_once_until_future_complete(future, timeout_sec)\n         else:\n             start = time.monotonic()\n             end = start \u002B timeout_sec\n             timeout_left = TimeoutObject(timeout_sec)\n \n-            while self._context.ok() and not future.done() and not self._is_shutdown:\n\u002B            while (\n\u002B                self._context.ok()\n\u002B                and not future.done()\n\u002B                and not future.cancelled()\n\u002B                and not self._is_shutdown\n\u002B            ):\n                 self._spin_once_until_future_complete(future, timeout_left)\n                 now = time.monotonic()\n \n@@ -653,6 \u002B663,8 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n                 with self._tasks_lock:\n                     # Get rid of any tasks that are done\n                     self._tasks = list(filter(lambda t_e_n: not t_e_n[0].done(), self._tasks))\n\u002B                    # Get rid of any tasks that are cancelled\n\u002B                    self._tasks = list(filter(lambda t_e_n: not t_e_n[0].cancelled(), self._tasks))\n \n             # Gather entities that can be waited on\n             subscriptions: List[Subscription[Any, ]] = []\ndiff --git rclpy/rclpy/task.py rclpy/rclpy/task.py\nindex 10fae27..9bc3b14 100644\n--- rclpy/rclpy/task.py\n\u002B\u002B\u002B rclpy/rclpy/task.py\n@@ -12,6 \u002B12,7 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n\u002Bfrom enum import Enum\n import inspect\n import sys\n import threading\n@@ -36,14 \u002B37,19 @@ def _fake_weakref() -\u003E None:\n     return None\n \n \n\u002Bclass FutureState(Enum):\n\u002B    \u0022\u0022\u0022States defining the lifecycle of a future.\u0022\u0022\u0022\n\u002B\n\u002B    PENDING = \u0027PENDING\u0027\n\u002B    CANCELLED = \u0027CANCELLED\u0027\n\u002B    FINISHED = \u0027FINISHED\u0027\n\u002B\n\u002B\n class Future(Generic[T]):\n     \u0022\u0022\u0022Represent the outcome of a task in the future.\u0022\u0022\u0022\n \n     def __init__(self, *, executor: Optional[\u0027Executor\u0027] = None) -\u003E None:\n-        # true if the task is done or cancelled\n-        self._done = False\n-        # true if the task is cancelled\n-        self._cancelled = False\n\u002B        self._state = FutureState.PENDING\n         # the final return value of the handler\n         self._result: Optional[T] = None\n         # An exception raised by the handler when called\n@@ -66,15 \u002B72,20 @@ class Future(Generic[T]):\n \n     def __await__(self) -\u003E Generator[None, None, Optional[T]]:\n         # Yield if the task is not finished\n-        while not self._done:\n\u002B        while self._pending():\n             yield\n         return self.result()\n \n\u002B    def _pending(self) -\u003E bool:\n\u002B        return self._state == FutureState.PENDING\n\u002B\n     def cancel(self) -\u003E None:\n         \u0022\u0022\u0022Request cancellation of the running task if it is not done already.\u0022\u0022\u0022\n         with self._lock:\n-            if not self._done:\n-                self._cancelled = True\n\u002B            if not self._pending():\n\u002B                return\n\u002B\n\u002B        self._state = FutureState.CANCELLED\n         self._schedule_or_invoke_done_callbacks()\n \n     def cancelled(self) -\u003E bool:\n@@ -83,7 \u002B94,7 @@ class Future(Generic[T]):\n \n         :return: True if the task was cancelled\n         \u0022\u0022\u0022\n-        return self._cancelled\n\u002B        return self._state == FutureState.CANCELLED\n \n     def done(self) -\u003E bool:\n         \u0022\u0022\u0022\n@@ -91,7 \u002B102,7 @@ class Future(Generic[T]):\n \n         :return: True if the task is finished or raised while it was executing\n         \u0022\u0022\u0022\n-        return self._done\n\u002B        return self._state == FutureState.FINISHED\n \n     def result(self) -\u003E Optional[T]:\n         \u0022\u0022\u0022\n@@ -123,8 \u002B134,8 @@ class Future(Generic[T]):\n         \u0022\u0022\u0022\n         with self._lock:\n             self._result = result\n-            self._done = True\n-            self._cancelled = False\n\u002B            self._state = FutureState.FINISHED\n\u002B\n         self._schedule_or_invoke_done_callbacks()\n \n     def set_exception(self, exception: Exception) -\u003E None:\n@@ -136,8 \u002B147,8 @@ class Future(Generic[T]):\n         with self._lock:\n             self._exception = exception\n             self._exception_fetched = False\n-            self._done = True\n-            self._cancelled = False\n\u002B            self._state = FutureState.FINISHED\n\u002B\n         self._schedule_or_invoke_done_callbacks()\n \n     def _schedule_or_invoke_done_callbacks(self) -\u003E None:\n@@ -186,7 \u002B197,7 @@ class Future(Generic[T]):\n         \u0022\u0022\u0022\n         invoke = False\n         with self._lock:\n-            if self._done:\n\u002B            if not self._pending():\n                 assert self._executor is not None\n                 executor = self._executor()\n                 if executor is not None:\n@@ -251,10 \u002B262,14 @@ class Task(Future[T]):\n \n         The return value of the handler is stored as the task result.\n         \u0022\u0022\u0022\n-        if self._done or self._executing or not self._task_lock.acquire(blocking=False):\n\u002B        if (\n\u002B            not self._pending() or\n\u002B            self._executing or\n\u002B            not self._task_lock.acquire(blocking=False)\n\u002B        ):\n             return\n         try:\n-            if self._done:\n\u002B            if not self._pending():\n                 return\n             self._executing = True\n \n@@ -265,7 \u002B280,6 @@ class Task(Future[T]):\n                     handler.send(None)\n                 except StopIteration as e:\n                     # The coroutine finished; store the result\n-                    handler.close()\n                     self.set_result(e.value)\n                     self._complete_task()\n                 except Exception as e:\n@@ -297,3 \u002B311,9 @@ class Task(Future[T]):\n         :return: True if the task is currently executing.\n         \u0022\u0022\u0022\n         return self._executing\n\u002B\n\u002B    def cancel(self) -\u003E None:\n\u002B        if self._pending() and inspect.iscoroutine(self._handler):\n\u002B            self._handler.close()\n\u002B\n\u002B        super().cancel()\ndiff --git rclpy/test/test_executor.py rclpy/test/test_executor.py\nindex 7b70274..2501d4b 100644\n--- rclpy/test/test_executor.py\n\u002B\u002B\u002B rclpy/test/test_executor.py\n@@ -273,6 \u002B273,26 @@ class TestExecutor(unittest.TestCase):\n         self.assertTrue(future.done())\n         self.assertEqual(\u0027Sentinel Result\u0027, future.result())\n \n\u002B    def test_create_task_coroutine_cancel(self) -\u003E None:\n\u002B        self.assertIsNotNone(self.node.handle)\n\u002B        executor = SingleThreadedExecutor(context=self.context)\n\u002B        executor.add_node(self.node)\n\u002B\n\u002B        async def coroutine():\n\u002B            return \u0027Sentinel Result\u0027\n\u002B\n\u002B        future = executor.create_task(coroutine)\n\u002B        self.assertFalse(future.done())\n\u002B        self.assertFalse(future.cancelled())\n\u002B\n\u002B        future.cancel()\n\u002B        self.assertTrue(future.cancelled())\n\u002B\n\u002B        executor.spin_until_future_complete(future)\n\u002B        self.assertFalse(future.done())\n\u002B        self.assertTrue(future.cancelled())\n\u002B        self.assertEqual(None, future.result())\n\u002B\n     def test_create_task_normal_function(self) -\u003E None:\n         self.assertIsNotNone(self.node.handle)\n         executor = SingleThreadedExecutor(context=self.context)\ndiff --git rclpy/test/test_task.py rclpy/test/test_task.py\nindex c742896..b911ad4 100644\n--- rclpy/test/test_task.py\n\u002B\u002B\u002B rclpy/test/test_task.py\n@@ -322,6 \u002B322,39 @@ class TestFuture(unittest.TestCase):\n         f.add_done_callback(cb)\n         assert called\n \n\u002B    def test_set_result_on_done_future_without_exception(self) -\u003E None:\n\u002B        f = Future()\n\u002B        f.set_result(None)\n\u002B        self.assertTrue(f.done())\n\u002B        self.assertFalse(f.cancelled())\n\u002B        f.set_result(None)\n\u002B        self.assertTrue(f.done())\n\u002B        self.assertFalse(f.cancelled())\n\u002B\n\u002B    def test_set_result_on_cancelled_future_without_exception(self) -\u003E None:\n\u002B        f = Future()\n\u002B        f.cancel()\n\u002B        self.assertTrue(f.cancelled())\n\u002B        self.assertFalse(f.done())\n\u002B        f.set_result(None)\n\u002B        self.assertTrue(f.done())\n\u002B\n\u002B    def test_set_exception_on_done_future_without_exception(self) -\u003E None:\n\u002B        f = Future()\n\u002B        f.set_result(None)\n\u002B        self.assertIsNone(f.exception())\n\u002B        f.set_exception(Exception())\n\u002B        f.set_result(None)\n\u002B        self.assertIsNotNone(f.exception())\n\u002B\n\u002B    def test_set_exception_on_cancelled_future_without_exception(self) -\u003E None:\n\u002B        f = Future()\n\u002B        f.cancel()\n\u002B        self.assertTrue(f.cancelled())\n\u002B        self.assertIsNone(f.exception())\n\u002B        f.set_exception(Exception())\n\u002B        self.assertIsNotNone(f.exception())\n\u002B\n \n if __name__ == \u0027__main__\u0027:\n     unittest.main()\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "79241a3cdc2815e6156f5f83aaceab1014db1847",
    "RawMessage": "spin_all with a zero timeout. (#1878)",
    "Changes": "diff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex f3f6e9bf..a2dd124f 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -305,7 \u002B305,9 @@ public:\n    * If the time that waitables take to be executed is longer than the period on which new waitables\n    * become ready, this method will execute work repeatedly until \u0060max_duration\u0060 has elapsed.\n    *\n-   * \\param[in] max_duration The maximum amount of time to spend executing work. Must be positive.\n\u002B   * \\param[in] max_duration The maximum amount of time to spend executing work, must be \u003E= 0.\n\u002B   *   \u00600\u0060 is potentially block forever until no more work is available.\n\u002B   * \\throw throw std::invalid_argument if max_duration is less than 0.\n    * Note that spin_all() may take longer than this time as it only returns once max_duration has\n    * been exceeded.\n    */\ndiff --git rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\nindex 61da15e1..5294605e 100644\n--- rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/static_single_threaded_executor.hpp\n@@ -99,9 \u002B99,10 @@ public:\n \n   /// Static executor implementation of spin all\n   /**\n-   * This non-blocking function will execute entities until\n-   * timeout or no more work available. If new entities get ready\n-   * while executing work available, they will be executed\n\u002B   * This non-blocking function will execute entities until timeout (must be \u003E= 0)\n\u002B   * or no more work available.\n\u002B   * If timeout is \u00600\u0060, potentially it blocks forever until no more work is available.\n\u002B   * If new entities get ready while executing work available, they will be executed\n    * as long as the timeout hasn\u0027t expired.\n    *\n    * Example:\ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 6ed3ace5..73b7b8d8 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -414,8 \u002B414,8 @@ void Executor::spin_some(std::chrono::nanoseconds max_duration)\n \n void Executor::spin_all(std::chrono::nanoseconds max_duration)\n {\n-  if (max_duration \u003C= 0ns) {\n-    throw std::invalid_argument(\u0022max_duration must be positive\u0022);\n\u002B  if (max_duration \u003C 0ns) {\n\u002B    throw std::invalid_argument(\u0022max_duration must be greater than or equal to 0\u0022);\n   }\n   return this-\u003Espin_some_impl(max_duration, true);\n }\ndiff --git rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\nindex 683d300c..209fcde5 100644\n--- rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n@@ -71,8 \u002B71,8 @@ StaticSingleThreadedExecutor::spin_some(std::chrono::nanoseconds max_duration)\n void\n StaticSingleThreadedExecutor::spin_all(std::chrono::nanoseconds max_duration)\n {\n-  if (max_duration \u003C= std::chrono::nanoseconds(0)) {\n-    throw std::invalid_argument(\u0022max_duration must be positive\u0022);\n\u002B  if (max_duration \u003C std::chrono::nanoseconds(0)) {\n\u002B    throw std::invalid_argument(\u0022max_duration must be greater than or equal to 0\u0022);\n   }\n   return this-\u003Espin_some_impl(max_duration, true);\n }\ndiff --git rclcpp/test/rclcpp/test_executor.cpp rclcpp/test/rclcpp/test_executor.cpp\nindex 0b007d51..bdbb0a10 100644\n--- rclcpp/test/rclcpp/test_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_executor.cpp\n@@ -248,7 \u002B248,7 @@ TEST_F(TestExecutor, spin_all_invalid_duration) {\n \n   RCLCPP_EXPECT_THROW_EQ(\n     dummy.spin_all(std::chrono::nanoseconds(-1)),\n-    std::invalid_argument(\u0022max_duration must be positive\u0022));\n\u002B    std::invalid_argument(\u0022max_duration must be greater than or equal to 0\u0022));\n }\n \n TEST_F(TestExecutor, spin_some_in_spin_some) {\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "d5b274fae5829ad43b12abbbb1f29f773fa6a6ce",
    "RawMessage": "Fixed screw display (#1093)",
    "Changes": "diff --git rviz_default_plugins/src/rviz_default_plugins/displays/screw/screw_display.cpp rviz_default_plugins/src/rviz_default_plugins/displays/screw/screw_display.cpp\nindex e9a95c09..c2788f02 100644\n--- rviz_default_plugins/src/rviz_default_plugins/displays/screw/screw_display.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/screw/screw_display.cpp\n@@ -224,19 \u002B224,14 @@ void ScrewDisplay\u003CMessageType\u003E::processMessagePrivate(\n   visual-\u003EsetFramePosition(position);\n   visual-\u003EsetFrameOrientation(orientation);\n   float alpha = alpha_property_-\u003EgetFloat();\n-  float linear_scale = linear_scale_property_-\u003EgetFloat();\n-  float angular_scale = angular_scale_property_-\u003EgetFloat();\n-  float width = width_property_-\u003EgetFloat();\n   Ogre::ColourValue linear_color = linear_color_property_-\u003EgetOgreColor();\n   Ogre::ColourValue angular_color = angular_color_property_-\u003EgetOgreColor();\n   visual-\u003EsetLinearColor(linear_color.r, linear_color.g, linear_color.b, alpha);\n   visual-\u003EsetAngularColor(angular_color.r, angular_color.g, angular_color.b, alpha);\n-  visual-\u003EsetLinearScale(linear_scale);\n-  visual-\u003EsetAngularScale(angular_scale);\n-  visual-\u003EsetWidth(width);\n-  visual-\u003EsetScrew(\n-    Ogre::Vector3(linear.x, linear.y, linear.z),\n-    Ogre::Vector3(angular.x, angular.y, angular.z));\n\u002B  visual-\u003EsetLinearScale(linear_scale_property_-\u003EgetFloat());\n\u002B  visual-\u003EsetAngularScale(angular_scale_property_-\u003EgetFloat());\n\u002B  visual-\u003EsetWidth(width_property_-\u003EgetFloat());\n\u002B  visual-\u003EsetHideSmallValues(hide_small_values_property_-\u003EgetBool());\n \n   // And send it to the end of the circular buffer\n   visuals_.push_back(visual);\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "launch_ros",
    "SHA": "8c05ebb4be52dcd360e47694875643e4f53a010e",
    "RawMessage": "Fix documentation typo (#167)",
    "Changes": "diff --git launch_ros/launch_ros/actions/push_ros_namespace.py launch_ros/launch_ros/actions/push_ros_namespace.py\nindex 26a10ee..7467d1d 100644\n--- launch_ros/launch_ros/actions/push_ros_namespace.py\n\u002B\u002B\u002B launch_ros/launch_ros/actions/push_ros_namespace.py\n@@ -39,7 \u002B39,7 @@ class PushRosNamespace(Action):\n     Action that pushes the ros namespace.\n \n     It\u0027s automatically popped when used inside a scoped \u0060GroupAction\u0060.\n-    There\u0027s not other way of popping it.\n\u002B    There\u0027s no other way of popping it.\n     \u0022\u0022\u0022\n \n     def __init__(\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "07b6ea0ff4f2e5c29dab9b068814576343122f56",
    "RawMessage": "Declare parameters uninitialized (#1673)",
    "Changes": "diff --git rclcpp/include/rclcpp/exceptions/exceptions.hpp rclcpp/include/rclcpp/exceptions/exceptions.hpp\nindex 27c695c0..524ccf73 100644\n--- rclcpp/include/rclcpp/exceptions/exceptions.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/exceptions/exceptions.hpp\n@@ -282,8 \u002B282,8 @@ class ParameterModifiedInCallbackException : public std::runtime_error\n   using std::runtime_error::runtime_error;\n };\n \n-/// Thrown when a parameter override wasn\u0027t provided and one was required.\n-class NoParameterOverrideProvided : public std::runtime_error\n\u002B/// Thrown when an uninitialized parameter is accessed.\n\u002Bclass ParameterUninitializedException : public std::runtime_error\n {\n public:\n   /// Construct an instance.\n@@ -291,8 \u002B291,8 @@ public:\n    * \\param[in] name the name of the parameter.\n    * \\param[in] message custom exception message.\n    */\n-  explicit NoParameterOverrideProvided(const std::string \u0026 name)\n-  : std::runtime_error(\u0022parameter \u0027\u0022 \u002B name \u002B \u0022\u0027 requires an user provided parameter override\u0022)\n\u002B  explicit ParameterUninitializedException(const std::string \u0026 name)\n\u002B  : std::runtime_error(\u0022parameter \u0027\u0022 \u002B name \u002B \u0022\u0027 is not initialized\u0022)\n   {}\n };\n \ndiff --git rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\nindex 1f9e32ac..3d91943b 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n@@ -349,6 \u002B349,21 @@ __declare_parameter_common(\n     initial_value = \u0026overrides_it-\u003Esecond;\n   }\n \n\u002B  // If there is no initial value, then skip initialization\n\u002B  if (initial_value-\u003Eget_type() == rclcpp::PARAMETER_NOT_SET) {\n\u002B    // Add declared parameters to storage (without a value)\n\u002B    parameter_infos[name].descriptor.name = name;\n\u002B    if (parameter_descriptor.dynamic_typing) {\n\u002B      parameter_infos[name].descriptor.type = rclcpp::PARAMETER_NOT_SET;\n\u002B    } else {\n\u002B      parameter_infos[name].descriptor.type = parameter_descriptor.type;\n\u002B    }\n\u002B    parameters_out[name] = parameter_infos.at(name);\n\u002B    rcl_interfaces::msg::SetParametersResult result;\n\u002B    result.successful = true;\n\u002B    return result;\n\u002B  }\n\u002B\n   // Check with the user\u0027s callback to see if the initial value can be set.\n   std::vector\u003Crclcpp::Parameter\u003E parameter_wrappers {rclcpp::Parameter(name, *initial_value)};\n   // This function also takes care of default vs initial value.\n@@ -413,14 \u002B428,6 @@ declare_parameter_helper(\n     parameter_descriptor.type = static_cast\u003Cuint8_t\u003E(type);\n   }\n \n-  if (\n-    rclcpp::PARAMETER_NOT_SET == default_value.get_type() \u0026\u0026\n-    overrides.find(name) == overrides.end() \u0026\u0026\n-    parameter_descriptor.dynamic_typing == false)\n-  {\n-    throw rclcpp::exceptions::NoParameterOverrideProvided(name);\n-  }\n-\n   rcl_interfaces::msg::ParameterEvent parameter_event;\n   auto result = __declare_parameter_common(\n     name,\n@@ -806,14 \u002B813,21 @@ NodeParameters::get_parameters(const std::vector\u003Cstd::string\u003E \u0026 names) const\n rclcpp::Parameter\n NodeParameters::get_parameter(const std::string \u0026 name) const\n {\n-  rclcpp::Parameter parameter;\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(mutex_);\n \n-  if (get_parameter(name, parameter)) {\n-    return parameter;\n\u002B  auto param_iter = parameters_.find(name);\n\u002B  if (\n\u002B    parameters_.end() != param_iter \u0026\u0026\n\u002B    (param_iter-\u003Esecond.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n\u002B    param_iter-\u003Esecond.descriptor.dynamic_typing))\n\u002B  {\n\u002B    return rclcpp::Parameter{name, param_iter-\u003Esecond.value};\n   } else if (this-\u003Eallow_undeclared_) {\n-    return parameter;\n-  } else {\n\u002B    return rclcpp::Parameter{};\n\u002B  } else if (parameters_.end() == param_iter) {\n     throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n\u002B  } else {\n\u002B    throw rclcpp::exceptions::ParameterUninitializedException(name);\n   }\n }\n \ndiff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex dff05a06..8d2e8a84 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -335,9 \u002B335,14 @@ TEST_F(TestNode, declare_parameter_with_no_initial_values) {\n     rcl_interfaces::msg::ParameterDescriptor descriptor;\n     descriptor.dynamic_typing = true;\n     // no default, no initial\n\u002B    const std::string parameter_name = \u0022parameter\u0022_unq;\n     rclcpp::ParameterValue value = node-\u003Edeclare_parameter(\n-      \u0022parameter\u0022_unq, rclcpp::ParameterValue{}, descriptor);\n\u002B      parameter_name, rclcpp::ParameterValue{}, descriptor);\n     EXPECT_EQ(value.get_type(), rclcpp::PARAMETER_NOT_SET);\n\u002B    // Does not throw if unset before access\n\u002B    EXPECT_EQ(\n\u002B      rclcpp::PARAMETER_NOT_SET,\n\u002B      node-\u003Eget_parameter(parameter_name).get_parameter_value().get_type());\n   }\n   {\n     // int default, no initial\n@@ -2798,9 \u002B2803,20 @@ TEST_F(TestNode, static_and_dynamic_typing) {\n     EXPECT_EQ(\u0022hello!\u0022, param);\n   }\n   {\n\u002B    auto param = node-\u003Edeclare_parameter(\u0022integer_override_not_given\u0022, rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n\u002B    // Throws if not set before access\n     EXPECT_THROW(\n-      node-\u003Edeclare_parameter(\u0022integer_override_not_given\u0022, rclcpp::PARAMETER_INTEGER),\n-      rclcpp::exceptions::NoParameterOverrideProvided);\n\u002B      node-\u003Eget_parameter(\u0022integer_override_not_given\u0022),\n\u002B      rclcpp::exceptions::ParameterUninitializedException);\n\u002B  }\n\u002B  {\n\u002B    auto param = node-\u003Edeclare_parameter(\u0022integer_set_after_declare\u0022, rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n\u002B    auto result = node-\u003Eset_parameter(rclcpp::Parameter{\u0022integer_set_after_declare\u0022, 44});\n\u002B    ASSERT_TRUE(result.successful) \u003C\u003C result.reason;\n\u002B    auto get_param = node-\u003Eget_parameter(\u0022integer_set_after_declare\u0022);\n\u002B    EXPECT_EQ(44, get_param.as_int());\n   }\n   {\n     EXPECT_THROW(\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "7843766bad1d10449243d2de2883e16203bff8c7",
    "RawMessage": "Increase Quality level of packages to 3 (#108)",
    "Changes": "diff --git action_msgs/QUALITY_DECLARATION.md action_msgs/QUALITY_DECLARATION.md\nindex 04f85b0..ff206c1 100644\n--- action_msgs/QUALITY_DECLARATION.md\n\u002B\u002B\u002B action_msgs/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060action_msgs\u0060 package\n \n # \u0060action_msgs\u0060 Quality Declaration\n \n-The package \u0060action_msgs\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060action_msgs\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,10 \u002B86,10 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060action_msgs\u0060 has the following runtime ROS dependencies:\n-* \u0060builtin_interfaces\u0060\n-* \u0060rosidl_default_runtime\u0060\n-* \u0060unique_identifier_msgs\u0060\n\u002B\u0060action_msgs\u0060 has the following runtime ROS dependencies, which are at or above QL 3:\n\u002B* \u0060builtin_interfaces\u0060: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n\u002B* \u0060unique_identifier_msgs\u0060: [QL 3](https://github.com/ros2/unique_identifier_msgs/tree/master/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git action_msgs/README.md action_msgs/README.md\nindex cb10d34..985d27d 100644\n--- action_msgs/README.md\n\u002B\u002B\u002B action_msgs/README.md\n@@ -13,4 \u002B13,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [CancelGoal](srv/CancelGoal.srv): Cancel Goals either by id and/or timestamp.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git builtin_interfaces/QUALITY_DECLARATION.md builtin_interfaces/QUALITY_DECLARATION.md\nindex cbb9bde..807fa6a 100644\n--- builtin_interfaces/QUALITY_DECLARATION.md\n\u002B\u002B\u002B builtin_interfaces/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060builtin_interfaces\u0060\n \n # \u0060builtin_interfaces\u0060 Quality Declaration\n \n-The package \u0060builtin_interfaces\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060builtin_interfaces\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,8 \u002B86,8 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060builtin_interfaces\u0060 has the following ROS dependencies:\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060builtin_interfaces\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git builtin_interfaces/README.md builtin_interfaces/README.md\nindex 50d6089..e9b3cd2 100644\n--- builtin_interfaces/README.md\n\u002B\u002B\u002B builtin_interfaces/README.md\n@@ -10,4 \u002B10,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [Time](msg/Time.msg): Describes a point in time, composed of seconds and nanoseconds components.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git composition_interfaces/QUALITY_DECLARATION.md composition_interfaces/QUALITY_DECLARATION.md\nindex 11ce88f..fa8263a 100644\n--- composition_interfaces/QUALITY_DECLARATION.md\n\u002B\u002B\u002B composition_interfaces/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060composition_interfac\n \n # \u0060composition_interfaces\u0060 Quality Declaration\n \n-The package \u0060composition_interfaces\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060composition_interfaces\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,8 \u002B86,8 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060composition_interfaces\u0060 has the following ROS dependencies:\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060composition_interfaces\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git composition_interfaces/README.md composition_interfaces/README.md\nindex c3a2a03..7fead35 100644\n--- composition_interfaces/README.md\n\u002B\u002B\u002B composition_interfaces/README.md\n@@ -10,4 \u002B10,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [UnloadNode](srv/UnloadNode.srv): Unload a specified node by its id.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git lifecycle_msgs/QUALITY_DECLARATION.md lifecycle_msgs/QUALITY_DECLARATION.md\nindex 7912a7c..291106a 100644\n--- lifecycle_msgs/QUALITY_DECLARATION.md\n\u002B\u002B\u002B lifecycle_msgs/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060lifecycle_msgs\u0060 pack\n \n # \u0060lifecycle_msgs\u0060 Quality Declaration\n \n-The package \u0060lifecycle_msgs\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060lifecycle_msgs\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,8 \u002B86,8 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060lifecycle_msgs\u0060 has the following ROS dependencies:\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060lifecycle_msgs\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git lifecycle_msgs/README.md lifecycle_msgs/README.md\nindex b3e4bc1..db602ad 100644\n--- lifecycle_msgs/README.md\n\u002B\u002B\u002B lifecycle_msgs/README.md\n@@ -20,4 \u002B20,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [GetState](srv/GetState.srv): Request the current lifecycle state of this node.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git rcl_interfaces/QUALITY_DECLARATION.md rcl_interfaces/QUALITY_DECLARATION.md\nindex 09fccf8..733423f 100644\n--- rcl_interfaces/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rcl_interfaces/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rcl_interfaces\u0060 pack\n \n # \u0060rcl_interfaces\u0060 Quality Declaration\n \n-The package \u0060rcl_interfaces\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rcl_interfaces\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -84,9 \u002B84,9 @@ There is an automated test which runs a linter that ensures each file has at lea\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060rcl_interfaces\u0060 has the following ROS dependencies:\n-* \u0060builtin_interfaces\u0060\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060rcl_interfaces\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060builtin_interfaces\u0060: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git rcl_interfaces/README.md rcl_interfaces/README.md\nindex d8571cc..69e4ab7 100644\n--- rcl_interfaces/README.md\n\u002B\u002B\u002B rcl_interfaces/README.md\n@@ -56,4 \u002B56,4 @@ The ROS API for a node will be as follows inside the node\u0027s namespace.\n * [SetParametersAtomically](srv/SetParametersAtomically.srv): Add or change all parameters in a list or none at all.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git rosgraph_msgs/QUALITY_DECLARATION.md rosgraph_msgs/QUALITY_DECLARATION.md\nindex 5657632..fc0bbf6 100644\n--- rosgraph_msgs/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rosgraph_msgs/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rosgraph_msgs\u0060 packa\n \n # \u0060rosgraph_msgs\u0060 Quality Declaration\n \n-The package \u0060rosgraph_msgs\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rosgraph_msgs\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,9 \u002B86,9 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060rosgraph_msgs\u0060 has the following ROS dependencies:\n-* \u0060builtin_interfaces\u0060\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060rosgraph_msgs\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060builtin_interfaces\u0060: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git rosgraph_msgs/README.md rosgraph_msgs/README.md\nindex cca2b73..030eda5 100644\n--- rosgraph_msgs/README.md\n\u002B\u002B\u002B rosgraph_msgs/README.md\n@@ -9,4 \u002B9,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [Clock](msg/Clock.msg): Communicates the current ROS time.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\ndiff --git statistics_msgs/QUALITY_DECLARATION.md statistics_msgs/QUALITY_DECLARATION.md\nindex 9533415..4936606 100644\n--- statistics_msgs/QUALITY_DECLARATION.md\n\u002B\u002B\u002B statistics_msgs/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060statistics_msgs\u0060 pac\n \n # \u0060statistics_msgs\u0060 Quality Declaration\n \n-The package \u0060statistics_msgs\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060statistics_msgs\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -86,9 \u002B86,9 @@ The nightly test can be found at [here](http://build.ros2.org/view/Epr/job/Epr__\n \n ### Direct Runtime ROS Dependencies [5.i]/[5.ii]\n \n-\u0060statistics_msgs\u0060 has the following ROS dependencies:\n-* \u0060builtin_interfaces\u0060\n-* \u0060rosidl_default_runtime\u0060\n\u002B\u0060statistics_msgs\u0060 has the following ROS dependencies, which are at or above QL 3:\n\u002B* \u0060builtin_interfaces\u0060: [QL 3](../builtin_interfaces/QUALITY_DECLARATION.md)\n\u002B* \u0060rosidl_default_runtime\u0060: [QL 3](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)\n \n It has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n \ndiff --git statistics_msgs/README.md statistics_msgs/README.md\nindex 6c4776b..014bdd8 100644\n--- statistics_msgs/README.md\n\u002B\u002B\u002B statistics_msgs/README.md\n@@ -37,4 \u002B37,4 @@ statistics for topics and system resources.\n    of collected metrics.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "43c07027bb653350a2111393ba9758c93120b0f9",
    "RawMessage": "Complete coverage of Parameter and ParameterValue API (#1344)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_parameter.cpp rclcpp/test/rclcpp/test_parameter.cpp\nindex 0c93204d..0d798dc4 100644\n--- rclcpp/test/rclcpp/test_parameter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter.cpp\n@@ -44,6 \u002B44,9 @@ TEST_F(TestParameter, not_set_variant) {\n   rclcpp::Parameter not_set_variant;\n   EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, not_set_variant.get_type());\n   EXPECT_EQ(\u0022not set\u0022, not_set_variant.get_type_name());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C not_set_variant;\n\u002B  EXPECT_EQ(\u0022{\\\u0022name\\\u0022: \\\u0022\\\u0022, \\\u0022type\\\u0022: \\\u0022not set\\\u0022, \\\u0022value\\\u0022: \\\u0022not set\\\u0022}\u0022, ss.str());\n \n   EXPECT_THROW(not_set_variant.as_bool(), rclcpp::ParameterTypeException);\n   EXPECT_THROW(not_set_variant.as_int(), rclcpp::ParameterTypeException);\n@@ -67,6 \u002B70,13 @@ TEST_F(TestParameter, not_set_variant) {\n   EXPECT_THROW(\n     not_set_variant.get_value\u003Cint\u003E(),\n     rclcpp::exceptions::InvalidParameterTypeException);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(not_set_variant, not_set_variant);\n\u002B  rclcpp::Parameter not_set_variant2;\n\u002B  EXPECT_EQ(not_set_variant, not_set_variant2);\n\u002B  rclcpp::Parameter bool_variant(\u0022bool_param\u0022, true);\n\u002B  EXPECT_NE(not_set_variant, bool_variant);\n }\n \n TEST_F(TestParameter, bool_variant) {\n@@ -92,6 \u002B102,10 @@ TEST_F(TestParameter, bool_variant) {\n   EXPECT_THROW(bool_variant_true.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u0022true\u0022, bool_variant_true.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C bool_variant_true;\n\u002B  EXPECT_EQ(\u0022{\\\u0022name\\\u0022: \\\u0022bool_param\\\u0022, \\\u0022type\\\u0022: \\\u0022bool\\\u0022, \\\u0022value\\\u0022: \\\u0022true\\\u0022}\u0022, ss.str());\n\u002B\n \n   rclcpp::Parameter bool_variant_false(\u0022bool_param\u0022, false);\n   EXPECT_FALSE(bool_variant_false.get_value\u003Crclcpp::ParameterType::PARAMETER_BOOL\u003E());\n@@ -125,6 \u002B139,11 @@ TEST_F(TestParameter, bool_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_BOOL,\n     bool_variant_false.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(bool_variant_true, bool_variant_true);\n\u002B  EXPECT_NE(bool_variant_false, bool_variant_true);\n\u002B  EXPECT_EQ(bool_variant_true, from_msg_true);\n }\n \n TEST_F(TestParameter, integer_variant) {\n@@ -154,6 \u002B173,9 @@ TEST_F(TestParameter, integer_variant) {\n   EXPECT_THROW(integer_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u002242\u0022, integer_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C integer_variant;\n\u002B  EXPECT_EQ(\u0022{\\\u0022name\\\u0022: \\\u0022integer_param\\\u0022, \\\u0022type\\\u0022: \\\u0022integer\\\u0022, \\\u0022value\\\u0022: \\\u002242\\\u0022}\u0022, ss.str());\n \n   rcl_interfaces::msg::Parameter integer_param = integer_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022integer_param\u0022, integer_param.name);\n@@ -173,6 \u002B195,11 @@ TEST_F(TestParameter, integer_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(integer_variant, integer_variant);\n\u002B  EXPECT_NE(integer_variant, rclcpp::Parameter(\u0022integer_param\u0022, 41));\n\u002B  EXPECT_EQ(integer_variant, from_msg);\n }\n \n TEST_F(TestParameter, long_integer_variant) {\n@@ -202,6 \u002B229,12 @@ TEST_F(TestParameter, long_integer_variant) {\n   EXPECT_THROW(long_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u00229223372036854775807\u0022, long_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C long_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022long_integer_param\\\u0022, \\\u0022type\\\u0022: \\\u0022integer\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u00229223372036854775807\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter integer_param = long_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022long_integer_param\u0022, integer_param.name);\n@@ -221,6 \u002B254,12 @@ TEST_F(TestParameter, long_integer_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER,\n     from_msg.get_value_message().type);\n\u002B\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(long_variant, long_variant);\n\u002B  EXPECT_NE(long_variant, rclcpp::Parameter(\u0022long_integer_param\u0022, 41));\n\u002B  EXPECT_EQ(long_variant, from_msg);\n }\n \n TEST_F(TestParameter, float_variant) {\n@@ -250,6 \u002B289,10 @@ TEST_F(TestParameter, float_variant) {\n   EXPECT_THROW(float_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u002242.000000\u0022, float_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C float_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022float_param\\\u0022, \\\u0022type\\\u0022: \\\u0022double\\\u0022, \\\u0022value\\\u0022: \\\u002242.000000\\\u0022}\u0022, ss.str());\n \n   rcl_interfaces::msg::Parameter float_param = float_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022float_param\u0022, float_param.name);\n@@ -269,6 \u002B312,11 @@ TEST_F(TestParameter, float_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(float_variant, float_variant);\n\u002B  EXPECT_NE(float_variant, rclcpp::Parameter(\u0022float_param\u0022, 41.0));\n\u002B  EXPECT_EQ(float_variant, from_msg);\n }\n \n TEST_F(TestParameter, double_variant) {\n@@ -298,6 \u002B346,10 @@ TEST_F(TestParameter, double_variant) {\n   EXPECT_THROW(double_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u0022-42.100000\u0022, double_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C double_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022double_param\\\u0022, \\\u0022type\\\u0022: \\\u0022double\\\u0022, \\\u0022value\\\u0022: \\\u0022-42.100000\\\u0022}\u0022, ss.str());\n \n   rcl_interfaces::msg::Parameter double_param = double_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022double_param\u0022, double_param.name);\n@@ -317,6 \u002B369,11 @@ TEST_F(TestParameter, double_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(double_variant, double_variant);\n\u002B  EXPECT_NE(double_variant, rclcpp::Parameter(\u0022double_param\u0022, -41.2));\n\u002B  EXPECT_EQ(double_variant, from_msg);\n }\n \n TEST_F(TestParameter, string_variant) {\n@@ -346,6 \u002B403,9 @@ TEST_F(TestParameter, string_variant) {\n   EXPECT_THROW(string_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(TEST_VALUE, string_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C string_variant;\n\u002B  EXPECT_EQ(\u0022{\\\u0022name\\\u0022: \\\u0022string_param\\\u0022, \\\u0022type\\\u0022: \\\u0022string\\\u0022, \\\u0022value\\\u0022: \\\u0022ROS2\\\u0022}\u0022, ss.str());\n \n   rcl_interfaces::msg::Parameter string_param = string_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022string_param\u0022, string_param.name);\n@@ -363,6 \u002B423,11 @@ TEST_F(TestParameter, string_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_STRING,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  EXPECT_EQ(string_variant, string_variant);\n\u002B  EXPECT_NE(string_variant, rclcpp::Parameter(\u0022string_param\u0022, \u0022ROS1\u0022));\n\u002B  EXPECT_EQ(string_variant, from_msg);\n }\n \n TEST_F(TestParameter, byte_array_variant) {\n@@ -392,6 \u002B457,12 @@ TEST_F(TestParameter, byte_array_variant) {\n   EXPECT_THROW(byte_array_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u0022[0x52, 0x4f, 0x53, 0x32]\u0022, byte_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C byte_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022byte_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022byte_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[0x52, 0x4f, 0x53, 0x32]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter byte_array_param = byte_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022byte_array_param\u0022, byte_array_param.name);\n@@ -411,6 \u002B482,12 @@ TEST_F(TestParameter, byte_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_BYTE_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cuint8_t\u003E TEST_VALUE2 {0x1, 0x2, 0x3, 0x4};\n\u002B  EXPECT_EQ(byte_array_variant, byte_array_variant);\n\u002B  EXPECT_NE(byte_array_variant, rclcpp::Parameter(\u0022byte_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(byte_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, bool_array_variant) {\n@@ -440,6 \u002B517,12 @@ TEST_F(TestParameter, bool_array_variant) {\n   EXPECT_THROW(bool_array_variant.as_string_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u0022[false, true, true, false, false, true]\u0022, bool_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C bool_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022bool_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022bool_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[false, true, true, false, false, true]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter bool_array_param = bool_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022bool_array_param\u0022, bool_array_param.name);\n@@ -459,6 \u002B542,12 @@ TEST_F(TestParameter, bool_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_BOOL_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cbool\u003E TEST_VALUE2 {true, true, true};\n\u002B  EXPECT_EQ(bool_array_variant, bool_array_variant);\n\u002B  EXPECT_NE(bool_array_variant, rclcpp::Parameter(\u0022bool_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(bool_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, integer_array_variant) {\n@@ -506,6 \u002B595,12 @@ TEST_F(TestParameter, integer_array_variant) {\n   EXPECT_EQ(\n     \u0022[42, -99, 2147483647, -2147483648, 0]\u0022,\n     integer_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C integer_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022integer_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022integer_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[42, -99, 2147483647, -2147483648, 0]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter integer_array_param = integer_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022integer_array_param\u0022, integer_array_param.name);\n@@ -538,6 \u002B633,12 @@ TEST_F(TestParameter, integer_array_variant) {\n   EXPECT_EQ(\n     from_msg.get_value_message().type,\n     rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cint\u003E TEST_VALUE2{1, 2, 3, 4, 5};\n\u002B  EXPECT_EQ(integer_array_variant, integer_array_variant);\n\u002B  EXPECT_NE(integer_array_variant, rclcpp::Parameter(\u0022integer_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(integer_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, long_integer_array_variant) {\n@@ -571,6 \u002B672,12 @@ TEST_F(TestParameter, long_integer_array_variant) {\n   EXPECT_EQ(\n     \u0022[42, -99, 9223372036854775807, -9223372036854775808, 0]\u0022,\n     long_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C long_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022long_integer_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022integer_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[42, -99, 9223372036854775807, -9223372036854775808, 0]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter integer_array_param = long_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022long_integer_array_param\u0022, integer_array_param.name);\n@@ -592,6 \u002B699,12 @@ TEST_F(TestParameter, long_integer_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cint64_t\u003E TEST_VALUE2{1, 2, 3, 4, 5};\n\u002B  EXPECT_EQ(long_array_variant, long_array_variant);\n\u002B  EXPECT_NE(long_array_variant, rclcpp::Parameter(\u0022long_integer_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(long_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, float_array_variant) {\n@@ -639,6 \u002B752,12 @@ TEST_F(TestParameter, float_array_variant) {\n   EXPECT_EQ(\n     \u0022[42.1, -99.1, 3.40282e\u002B38, -3.40282e\u002B38, 0.1]\u0022,\n     float_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C float_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022float_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022double_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[42.1, -99.1, 3.40282e\u002B38, -3.40282e\u002B38, 0.1]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter float_array_param = float_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022float_array_param\u0022, float_array_param.name);\n@@ -671,6 \u002B790,12 @@ TEST_F(TestParameter, float_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cfloat\u003E TEST_VALUE2{1.0, 2.0, 3.0, 4.0};\n\u002B  EXPECT_EQ(float_array_variant, float_array_variant);\n\u002B  EXPECT_NE(float_array_variant, rclcpp::Parameter(\u0022float_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(float_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, double_array_variant) {\n@@ -704,6 \u002B829,12 @@ TEST_F(TestParameter, double_array_variant) {\n   EXPECT_EQ(\n     \u0022[42.1, -99.1, 1.79769e\u002B308, -1.79769e\u002B308, 0.1]\u0022,\n     double_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C double_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022double_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022double_array\\\u0022, \\\u0022value\\\u0022: \u0022\n\u002B    \u0022\\\u0022[42.1, -99.1, 1.79769e\u002B308, -1.79769e\u002B308, 0.1]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter double_array_param = double_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022double_array_param\u0022, double_array_param.name);\n@@ -725,6 \u002B856,12 @@ TEST_F(TestParameter, double_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cdouble\u003E TEST_VALUE2{1.0, 2.0, 3.0, 4.0};\n\u002B  EXPECT_EQ(double_array_variant, double_array_variant);\n\u002B  EXPECT_NE(double_array_variant, rclcpp::Parameter(\u0022double_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(double_array_variant, from_msg);\n }\n \n TEST_F(TestParameter, string_array_variant) {\n@@ -756,6 \u002B893,11 @@ TEST_F(TestParameter, string_array_variant) {\n   EXPECT_THROW(string_array_variant.as_double_array(), rclcpp::ParameterTypeException);\n \n   EXPECT_EQ(\u0022[R, O, S2]\u0022, string_array_variant.value_to_string());\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C string_array_variant;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\\\u0022name\\\u0022: \\\u0022string_array_param\\\u0022, \\\u0022type\\\u0022: \\\u0022string_array\\\u0022, \\\u0022value\\\u0022: \\\u0022[R, O, S2]\\\u0022}\u0022,\n\u002B    ss.str());\n \n   rcl_interfaces::msg::Parameter string_array_param = string_array_variant.to_parameter_msg();\n   EXPECT_EQ(\u0022string_array_param\u0022, string_array_param.name);\n@@ -777,4 \u002B919,31 @@ TEST_F(TestParameter, string_array_variant) {\n   EXPECT_EQ(\n     rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY,\n     from_msg.get_value_message().type);\n\u002B\n\u002B  // Check == and != operators work as expected\n\u002B  const std::vector\u003Cstd::string\u003E TEST_VALUE2{\u0022R\u0022, \u0022O\u0022, \u0022S1\u0022};\n\u002B  EXPECT_EQ(string_array_variant, string_array_variant);\n\u002B  EXPECT_NE(string_array_variant, rclcpp::Parameter(\u0022string_array_param\u0022, TEST_VALUE2));\n\u002B  EXPECT_EQ(string_array_variant, from_msg);\n\u002B}\n\u002B\n\u002BTEST_F(TestParameter, parameter_vector_stringification) {\n\u002B  const std::vector\u003Crclcpp::Parameter\u003E parameters = {\n\u002B    rclcpp::Parameter(),\n\u002B    rclcpp::Parameter(\u0022bool_param\u0022, true),\n\u002B    rclcpp::Parameter(\u0022integer_param\u0022, 42),\n\u002B    rclcpp::Parameter(\u0022double_param\u0022, 3.14159),\n\u002B    rclcpp::Parameter(\u0022string_param\u0022, \u0022I\u0027m a string\u0022),\n\u002B  };\n\u002B\n\u002B  std::stringstream ss;\n\u002B  ss \u003C\u003C parameters;\n\u002B  EXPECT_EQ(\n\u002B    \u0022{\u0022\n\u002B    \u0022\\\u0022\\\u0022: {\\\u0022type\\\u0022: \\\u0022not set\\\u0022, \\\u0022value\\\u0022: \\\u0022not set\\\u0022}, \u0022\n\u002B    \u0022\\\u0022bool_param\\\u0022: {\\\u0022type\\\u0022: \\\u0022bool\\\u0022, \\\u0022value\\\u0022: \\\u0022true\\\u0022}, \u0022\n\u002B    \u0022\\\u0022integer_param\\\u0022: {\\\u0022type\\\u0022: \\\u0022integer\\\u0022, \\\u0022value\\\u0022: \\\u002242\\\u0022}, \u0022\n\u002B    \u0022\\\u0022double_param\\\u0022: {\\\u0022type\\\u0022: \\\u0022double\\\u0022, \\\u0022value\\\u0022: \\\u00223.141590\\\u0022}, \u0022\n\u002B    \u0022\\\u0022string_param\\\u0022: {\\\u0022type\\\u0022: \\\u0022string\\\u0022, \\\u0022value\\\u0022: \\\u0022I\u0027m a string\\\u0022}}\u0022,\n\u002B    ss.str());\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "9b7e50b9c5c57c9e542d6f6d00f1e4b3c0698863",
    "RawMessage": "Add Clock.sleep_until (#858)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 8012e0f..694c3e3 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -109,6 \u002B109,7 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/context.cpp\n   src/rclpy/destroyable.cpp\n   src/rclpy/duration.cpp\n\u002B  src/rclpy/clock_event.cpp\n   src/rclpy/exceptions.cpp\n   src/rclpy/graph.cpp\n   src/rclpy/guard_condition.cpp\ndiff --git rclpy/rclpy/clock.py rclpy/rclpy/clock.py\nindex da10f73..2bcb210 100644\n--- rclpy/rclpy/clock.py\n\u002B\u002B\u002B rclpy/rclpy/clock.py\n@@ -15,7 \u002B15,9 @@\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n \n from .duration import Duration\n\u002Bfrom .exceptions import NotInitializedException\n from .time import Time\n\u002Bfrom .utilities import get_default_context\n \n \n ClockType = _rclpy.ClockType\n@@ -172,6 \u002B174,68 @@ class Clock:\n             clock=self, threshold=threshold, pre_callback=pre_callback,\n             post_callback=post_callback)\n \n\u002B    def sleep_until(self, until: Time, context=None) -\u003E bool:\n\u002B        \u0022\u0022\u0022\n\u002B        Sleep until a Time on this Clock is reached.\n\u002B\n\u002B        When using a ROSClock, this may sleep forever if the TimeSource is misconfigured and the\n\u002B        context is never shut down.\n\u002B        ROS time being activated or deactivated causes this function to cease sleeping and return\n\u002B        False.\n\u002B\n\u002B        :param until: Time at which this function should stop sleeping.\n\u002B        :param context: Context which when shut down will cause this sleep to wake early.\n\u002B            If context is None, then the default context is used.\n\u002B        :return: True if until was reached, or False if it woke for another reason.\n\u002B        :raises ValueError: until is specified for a different type of clock than this one.\n\u002B        :raises NotInitializedException: context has not been initialized or is shutdown.\n\u002B        \u0022\u0022\u0022\n\u002B        if context is None:\n\u002B            context = get_default_context()\n\u002B\n\u002B        if not context.ok():\n\u002B            raise NotInitializedException()\n\u002B\n\u002B        if until.clock_type != self._clock_type:\n\u002B            raise ValueError(\u0022until\u0027s clock type does not match this clock\u0027s type\u0022)\n\u002B\n\u002B        event = _rclpy.ClockEvent()\n\u002B        time_source_changed = False\n\u002B\n\u002B        def on_time_jump(time_jump: TimeJump):\n\u002B            \u0022\u0022\u0022Wake when time jumps and is past target time.\u0022\u0022\u0022\n\u002B            nonlocal time_source_changed\n\u002B\n\u002B            # ROS time being activated or deactivated changes the epoch, so sleep\n\u002B            # time loses its meaning\n\u002B            time_source_changed = (\n\u002B                time_source_changed or\n\u002B                ClockChange.ROS_TIME_ACTIVATED == time_jump.clock_change or\n\u002B                ClockChange.ROS_TIME_DEACTIVATED == time_jump.clock_change)\n\u002B\n\u002B            if time_source_changed or self.now() \u003E= until:\n\u002B                event.set()\n\u002B\n\u002B        # Wake when context is shut down\n\u002B        context.on_shutdown(event.set)\n\u002B\n\u002B        threshold = JumpThreshold(\n\u002B            min_forward=Duration(nanoseconds=1),\n\u002B            min_backward=None,\n\u002B            on_clock_change=True)\n\u002B        with self.create_jump_callback(threshold, post_callback=on_time_jump):\n\u002B            if ClockType.SYSTEM_TIME == self._clock_type:\n\u002B                event.wait_until_system(self.__clock, until._time_handle)\n\u002B            elif ClockType.STEADY_TIME == self._clock_type:\n\u002B                event.wait_until_steady(self.__clock, until._time_handle)\n\u002B            elif ClockType.ROS_TIME == self._clock_type:\n\u002B                event.wait_until_ros(self.__clock, until._time_handle)\n\u002B\n\u002B        if not context.ok() or time_source_changed:\n\u002B            return False\n\u002B\n\u002B        return self.now() \u003E= until\n\u002B\n \n class ROSClock(Clock):\n \ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex ccf828f..3a78e6b 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -25,6 \u002B25,7 @@\n #include \u0022context.hpp\u0022\n #include \u0022destroyable.hpp\u0022\n #include \u0022duration.hpp\u0022\n\u002B#include \u0022clock_event.hpp\u0022\n #include \u0022exceptions.hpp\u0022\n #include \u0022graph.hpp\u0022\n #include \u0022guard_condition.hpp\u0022\n@@ -228,4 \u002B229,5 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n \n   rclpy::define_logging_api(m);\n   rclpy::define_signal_handler_api(m);\n\u002B  rclpy::define_clock_event(m);\n }\ndiff --git rclpy/src/rclpy/clock_event.cpp rclpy/src/rclpy/clock_event.cpp\nnew file mode 100644\nindex 0000000..b53fb5e\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/clock_event.cpp\n@@ -0,0 \u002B1,120 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcl/rcl.h\u003E\n\u002B#include \u003Crcl/time.h\u003E\n\u002B#include \u003Crcl/types.h\u003E\n\u002B\n\u002B#include \u003Ccondition_variable\u003E\n\u002B#include \u003Ccstring\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n\u002B\n\u002B#include \u0022clock_event.hpp\u0022\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002Btemplate\u003Ctypename ClockType\u003E\n\u002Bvoid ClockEvent::wait_until(std::shared_ptr\u003CClock\u003E clock, rcl_time_point_t until)\n\u002B{\n\u002B  // Synchronize because clock epochs might differ\n\u002B  const rcl_time_point_t rcl_entry = clock-\u003Eget_now();\n\u002B  const typename ClockType::time_point chrono_entry = ClockType::now();\n\u002B\n\u002B  rcl_duration_t delta_t;\n\u002B  rcl_ret_t ret = rcl_difference_times(\u0026rcl_entry, \u0026until, \u0026delta_t);\n\u002B\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw RCLError(\u0022failed to subtract times\u0022);\n\u002B  }\n\u002B\n\u002B  // Cast because system clock resolution is too big for nanoseconds on Windows \u0026 OSX\n\u002B  const typename ClockType::time_point chrono_until = chrono_entry \u002B\n\u002B    std::chrono::duration_cast\u003Ctypename ClockType::duration\u003E(\n\u002B    std::chrono::nanoseconds(delta_t.nanoseconds));\n\u002B\n\u002B  // Could be a long wait, release the gil\n\u002B  py::gil_scoped_release release;\n\u002B  std::unique_lock\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  cv_.wait_until(lock, chrono_until, [this]() {return state_;});\n\u002B}\n\u002B\n\u002Bvoid ClockEvent::wait_until_ros(std::shared_ptr\u003CClock\u003E clock, rcl_time_point_t until)\n\u002B{\n\u002B  // Check if ROS time is enabled in C\u002B\u002B to avoid TOCTTOU with TimeSource by holding GIL\n\u002B  if (clock-\u003Eget_ros_time_override_is_enabled()) {\n\u002B    // Could be a long wait, release the gil\n\u002B    py::gil_scoped_release release;\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lock(mutex_);\n\u002B    // Caller must have setup a time jump callback to wake this event\n\u002B    cv_.wait(lock, [this]() {return state_;});\n\u002B  } else {\n\u002B    // ROS time not enabled is system time\n\u002B    wait_until\u003Cstd::chrono::system_clock\u003E(clock, until);\n\u002B  }\n\u002B}\n\u002B\n\u002Bbool ClockEvent::is_set()\n\u002B{\n\u002B  std::unique_lock\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  return state_;\n\u002B}\n\u002B\n\u002Bvoid ClockEvent::set()\n\u002B{\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lock(mutex_);\n\u002B    state_ = true;\n\u002B  }\n\u002B  cv_.notify_all();\n\u002B}\n\u002B\n\u002Bvoid ClockEvent::clear()\n\u002B{\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lock(mutex_);\n\u002B    state_ = false;\n\u002B  }\n\u002B  cv_.notify_all();\n\u002B}\n\u002B\n\u002Bvoid define_clock_event(py::object module)\n\u002B{\n\u002B  py::class_\u003CClockEvent\u003E(module, \u0022ClockEvent\u0022)\n\u002B  .def(py::init())\n\u002B  .def(\n\u002B    \u0022wait_until_steady\u0022, \u0026ClockEvent::wait_until\u003Cstd::chrono::steady_clock\u003E,\n\u002B    \u0022Wait for the event to be set (monotonic wait)\u0022)\n\u002B  .def(\n\u002B    \u0022wait_until_system\u0022, \u0026ClockEvent::wait_until\u003Cstd::chrono::system_clock\u003E,\n\u002B    \u0022Wait for the event to be set (system timed wait)\u0022)\n\u002B  .def(\n\u002B    \u0022wait_until_ros\u0022, \u0026ClockEvent::wait_until_ros,\n\u002B    \u0022Wait for the event to be set (ROS timed wait)\u0022)\n\u002B  .def(\n\u002B    \u0022is_set\u0022, \u0026ClockEvent::is_set,\n\u002B    \u0022Return True if the event is set, False otherwise.\u0022)\n\u002B  .def(\n\u002B    \u0022set\u0022, \u0026ClockEvent::set,\n\u002B    \u0022Set the event, waking all those who wait on it.\u0022)\n\u002B  .def(\n\u002B    \u0022clear\u0022, \u0026ClockEvent::clear,\n\u002B    \u0022Unset the event.\u0022);\n\u002B}\n\u002B}  // namespace rclpy\ndiff --git rclpy/src/rclpy/clock_event.hpp rclpy/src/rclpy/clock_event.hpp\nnew file mode 100644\nindex 0000000..ab482bb\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/clock_event.hpp\n@@ -0,0 \u002B1,75 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLPY__CLOCK_EVENT_HPP_\n\u002B#define RCLPY__CLOCK_EVENT_HPP_\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcl/rcl.h\u003E\n\u002B#include \u003Crcl/time.h\u003E\n\u002B#include \u003Crcl/types.h\u003E\n\u002B\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Ccondition_variable\u003E\n\u002B#include \u003Ccstring\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cmutex\u003E\n\u002B#include \u003Cstdexcept\u003E\n\u002B\n\u002B#include \u0022clock.hpp\u0022\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002Bclass ClockEvent\n\u002B{\n\u002Bpublic:\n\u002B  /// Wait until a time specified by a system or steady clock.\n\u002B  /// \\param clock the clock to use for time synchronization with until\n\u002B  /// \\param until this method will block until this time is reached.\n\u002B  template\u003Ctypename ClockType\u003E\n\u002B  void wait_until(std::shared_ptr\u003CClock\u003E clock, rcl_time_point_t until);\n\u002B\n\u002B  /// Wait until a time specified by a ROS clock.\n\u002B  /// \\warning the caller is responsible for creating a time jump callback to set this event when\n\u002B  /// the target ROS time is reached.\n\u002B  /// when a given ROS time is reached.\n\u002B  /// \\param clock the clock to use for time synchronization.\n\u002B  /// \\param until this method will block until this time is reached.\n\u002B  void wait_until_ros(std::shared_ptr\u003CClock\u003E clock, rcl_time_point_t until);\n\u002B\n\u002B  /// Indicate if the ClockEvent is set.\n\u002B  /// \\return True if the ClockEvent is set.\n\u002B  bool is_set();\n\u002B\n\u002B  /// Set the event.\n\u002B  void set();\n\u002B\n\u002B  /// Clear the event.\n\u002B  void clear();\n\u002B\n\u002Bprivate:\n\u002B  bool state_ = false;\n\u002B  std::mutex mutex_;\n\u002B  std::condition_variable cv_;\n\u002B};\n\u002B\n\u002B/// Define a pybind11 wrapper for an rclpy::ClockEvent\n\u002Bvoid define_clock_event(py::object module);\n\u002B}  // namespace rclpy\n\u002B\n\u002B#endif  // RCLPY__CLOCK_EVENT_HPP_\ndiff --git rclpy/test/test_clock.py rclpy/test/test_clock.py\nindex e5c2c10..c6a147a 100644\n--- rclpy/test/test_clock.py\n\u002B\u002B\u002B rclpy/test/test_clock.py\n@@ -12,22 \u002B12,30 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n\u002Bimport threading\n import time\n import unittest\n from unittest.mock import Mock\n \n import pytest\n\u002Bimport rclpy\n from rclpy.clock import Clock\n from rclpy.clock import ClockType\n from rclpy.clock import JumpHandle\n from rclpy.clock import JumpThreshold\n from rclpy.clock import ROSClock\n\u002Bfrom rclpy.context import Context\n from rclpy.duration import Duration\n\u002Bfrom rclpy.exceptions import NotInitializedException\n from rclpy.time import Time\n\u002Bfrom rclpy.utilities import get_default_context\n \n from .mock_compat import __name__ as _  # noqa: ignore=F401\n \n \n\u002BA_SMALL_AMOUNT_OF_TIME = Duration(seconds=0.5)\n\u002B\n\u002B\n def test_invalid_jump_threshold():\n     with pytest.raises(ValueError, match=\u0027.*min_forward.*\u0027):\n         JumpThreshold(\n@@ -211,6 \u002B219,145 @@ class TestClock(unittest.TestCase):\n         handler3.unregister()\n \n \n\u002B@pytest.fixture()\n\u002Bdef default_context():\n\u002B    rclpy.init()\n\u002B    yield get_default_context()\n\u002B    rclpy.shutdown()\n\u002B\n\u002B\n\u002B@pytest.fixture()\n\u002Bdef non_default_context():\n\u002B    context = Context()\n\u002B    context.init()\n\u002B    yield context\n\u002B    context.try_shutdown()\n\u002B\n\u002B\n\u002Bdef test_sleep_until_mismatched_clock_type(default_context):\n\u002B    clock = Clock(clock_type=ClockType.SYSTEM_TIME)\n\u002B    with pytest.raises(ValueError, match=\u0027.*clock type does not match.*\u0027):\n\u002B        clock.sleep_until(Time(clock_type=ClockType.STEADY_TIME))\n\u002B\n\u002B\n\u002Bdef test_sleep_until_non_default_context(non_default_context):\n\u002B    clock = Clock()\n\u002B    assert clock.sleep_until(clock.now() \u002B Duration(seconds=0.1), context=non_default_context)\n\u002B\n\u002B\n\u002Bdef test_sleep_until_invalid_context():\n\u002B    clock = Clock()\n\u002B    with pytest.raises(NotInitializedException):\n\u002B        clock.sleep_until(clock.now() \u002B Duration(seconds=0.1), context=Context())\n\u002B\n\u002B\n\u002B@pytest.mark.parametrize(\n\u002B    \u0027clock_type\u0027, (ClockType.SYSTEM_TIME, ClockType.STEADY_TIME, ClockType.ROS_TIME))\n\u002Bdef test_sleep_until_basic(default_context, clock_type):\n\u002B    clock = Clock(clock_type=clock_type)\n\u002B    sleep_duration = Duration(seconds=0.1)\n\u002B    start = clock.now()\n\u002B    assert clock.sleep_until(clock.now() \u002B sleep_duration)\n\u002B    stop = clock.now()\n\u002B    assert stop - start \u003E= sleep_duration\n\u002B\n\u002B\n\u002B@pytest.mark.parametrize(\n\u002B    \u0027clock_type\u0027, (ClockType.SYSTEM_TIME, ClockType.STEADY_TIME, ClockType.ROS_TIME))\n\u002Bdef test_sleep_until_time_in_past(default_context, clock_type):\n\u002B    clock = Clock(clock_type=clock_type)\n\u002B    sleep_duration = Duration(seconds=-1)\n\u002B    start = clock.now()\n\u002B    assert clock.sleep_until(clock.now() \u002B sleep_duration)\n\u002B    stop = clock.now()\n\u002B    assert stop - start \u003C A_SMALL_AMOUNT_OF_TIME\n\u002B\n\u002B\n\u002B@pytest.mark.parametrize(\u0027ros_time_enabled\u0027, (True, False))\n\u002Bdef test_sleep_until_ros_time_toggled(default_context, ros_time_enabled):\n\u002B    clock = ROSClock()\n\u002B    clock._set_ros_time_is_active(not ros_time_enabled)\n\u002B\n\u002B    retval = None\n\u002B\n\u002B    def run():\n\u002B        nonlocal retval\n\u002B        retval = clock.sleep_until(clock.now() \u002B Duration(seconds=10))\n\u002B\n\u002B    t = threading.Thread(target=run)\n\u002B    t.start()\n\u002B\n\u002B    # wait for thread to get inside sleep_until call\n\u002B    time.sleep(0.2)\n\u002B\n\u002B    clock._set_ros_time_is_active(ros_time_enabled)\n\u002B\n\u002B    # wait for thread to exit\n\u002B    start = clock.now()\n\u002B    t.join()\n\u002B    stop = clock.now()\n\u002B    assert stop - start \u003C A_SMALL_AMOUNT_OF_TIME\n\u002B\n\u002B    assert retval is False\n\u002B\n\u002B\n\u002Bdef test_sleep_until_context_shut_down(non_default_context):\n\u002B    clock = Clock()\n\u002B    retval = None\n\u002B\n\u002B    def run():\n\u002B        nonlocal retval\n\u002B        retval = clock.sleep_until(\n\u002B            clock.now() \u002B Duration(seconds=10), context=non_default_context)\n\u002B\n\u002B    t = threading.Thread(target=run)\n\u002B    t.start()\n\u002B\n\u002B    # wait for thread to get inside sleep_until call\n\u002B    time.sleep(0.2)\n\u002B\n\u002B    non_default_context.shutdown()\n\u002B\n\u002B    # wait for thread to exit\n\u002B    start = clock.now()\n\u002B    t.join()\n\u002B    stop = clock.now()\n\u002B    assert stop - start \u003C A_SMALL_AMOUNT_OF_TIME\n\u002B\n\u002B    assert retval is False\n\u002B\n\u002B\n\u002Bdef test_sleep_until_ros_time_enabled(default_context):\n\u002B    clock = ROSClock()\n\u002B    clock._set_ros_time_is_active(True)\n\u002B\n\u002B    start_time = Time(seconds=1, clock_type=ClockType.ROS_TIME)\n\u002B    stop_time = start_time \u002B Duration(seconds=10)\n\u002B    clock.set_ros_time_override(start_time)\n\u002B\n\u002B    retval = None\n\u002B\n\u002B    def run():\n\u002B        nonlocal retval\n\u002B        retval = clock.sleep_until(stop_time)\n\u002B\n\u002B    t = threading.Thread(target=run)\n\u002B    t.start()\n\u002B\n\u002B    # wait for thread to get inside sleep_until call\n\u002B    time.sleep(0.2)\n\u002B\n\u002B    clock.set_ros_time_override(stop_time)\n\u002B\n\u002B    # wait for thread to exit\n\u002B    start = clock.now()\n\u002B    t.join()\n\u002B    stop = clock.now()\n\u002B    assert stop - start \u003C A_SMALL_AMOUNT_OF_TIME\n\u002B\n\u002B    assert retval\n\u002B\n\u002B\n def test_with_jump_handle():\n     clock = ROSClock()\n     clock._set_ros_time_is_active(False)\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "f957cffe324c5ef51154fe076327910fa19f3f5d",
    "RawMessage": "Update Quality Declarations to QL3. (#404)",
    "Changes": "diff --git rmw_fastrtps_cpp/QUALITY_DECLARATION.md rmw_fastrtps_cpp/QUALITY_DECLARATION.md\nindex dac4181..f82209a 100644\n--- rmw_fastrtps_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_cpp/QUALITY_DECLARATION.md\n@@ -160,7 \u002B160,7 @@ This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https\n \n # Current status Summary\n \n-The chart below compares the requirements in the REP-2004 with the current state of the \u0060rmw_dds_common\u0060 package.\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the \u0060rmw_fastrtps_cpp\u0060 package.\n \n |Number| Requirement| Current state |\n |--|--|--|\ndiff --git rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\nindex 2c0f3c3..fd8270c 100644\n--- rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\n@@ -2,9 \u002B2,9 @@ This document is a declaration of software quality for the \u0060rmw_fastrtps_shared_\n \n # \u0060rmw_fastrtps_shared_cpp\u0060 Quality Declaration\n \n-The package \u0060rmw_fastrtps_shared_cpp\u0060 claims to be in the **Quality Level 4** category.\n\u002BThe package \u0060rmw_fastrtps_shared_cpp\u0060 claims to be in the **Quality Level 3** category.\n \n-Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).\n \n ## Version Policy [1]\n \n@@ -72,7 \u002B72,7 @@ The license for \u0060rmw_fastrtps_shared_cpp\u0060 is Apache 2.0, and a summary is in eac\n \n There is an automated test which runs a linter that ensures each file has a license statement.\n \n-Most recent test results can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/1525/testReport/rmw_fastrtps_shared_cpp/copyright/)\n\u002BMost recent test results can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_fastrtps_shared_cpp/copyright/)\n \n ### Copyright Statements [3.iv]\n \n@@ -80,7 \u002B80,7 @@ The copyright holders each provide a statement of copyright in each source code\n \n There is an automated test which runs a linter that ensures each file has at least one copyright statement.\n \n-The results of the test can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/1525/testReport/rmw_fastrtps_shared_cpp/copyright/).\n\u002BThe results of the test can be found [here](https://ci.ros2.org/view/nightly/job/nightly_linux_release/lastBuild/testReport/rmw_fastrtps_shared_cpp/copyright/).\n \n ## Testing [4]\n \n@@ -95,7 \u002B95,24 @@ The latest nightly test results can be seen [here](https://ci.ros2.org/view/nigh\n \n ### Coverage [4.iii]\n \n-\u0060rmw_fastrtps_shared_cpp\u0060 does not currently track test coverage.\n\u002B\u0060rmw_fastrtps_shared_cpp\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- achieving and maintaining a reasonable branch line coverage (90-100%)\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed \n\u002B[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/install_rmw_fastrtps_shared_cpp_include_rmw_fastrtps_shared_cpp/), \n\u002B[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_include_rmw_fastrtps_shared_cpp/), \n\u002B[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_src/), and \n\u002B[here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_fastrtps_rmw_fastrtps_shared_cpp_src_types/).\n\u002BThis package does not yet meet the 95% coverage guideline.\n\u002B\n\u002BA summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \n@@ -137,6 \u002B154,52 @@ Currently nightly results can be seen here:\n * [mac_osx_release](https://ci.ros2.org/view/nightly/job/nightly_osx_release/lastBuild/testReport/rmw_fastrtps_shared_cpp/)\n * [windows_release](https://ci.ros2.org/view/nightly/job/nightly_win_rel/lastBuild/testReport/rmw_fastrtps_shared_cpp/)\n \n-## Vulnerability Disclosure Policy [7.i]\n\u002B## Security [7]\n\u002B\n\u002B### Vulnerability Disclosure Policy [7.i]\n \n This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n\u002B\n\u002B# Current status Summary\n\u002B\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the \u0060rmw_fastrtps_shared_cpp\u0060 package.\n\u002B\n\u002B|Number| Requirement| Current state |\n\u002B|--|--|--|\n\u002B|1| **Version policy** |---|\n\u002B|1.i|Version Policy available | \u0393\u00A3\u00F4 |\n\u002B|1.ii|Stable version |\u0393\u00A3\u00F4 |\n\u002B|1.iii|Declared public API|\u0393\u00A3\u00F4|\n\u002B|1.iv|API stability policy|\u0393\u00A3\u00F4|\n\u002B|1.v|ABI stability policy|\u0393\u00A3\u00F4|\n\u002B|1.vi_|API/ABI stable within ros distribution|\u0393\u00A3\u00F4|\n\u002B|2| **Change control process** |---|\n\u002B|2.i| All changes occur on change request | \u0393\u00A3\u00F4|\n\u002B|2.ii| Contributor origin (DCO, CLA, etc) | \u0393\u00A3\u00F4|\n\u002B|2.iii| Peer review policy | \u0393\u00A3\u00F4 |\n\u002B|2.iv| CI policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|2.v| Documentation policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|3| **Documentation** | --- |\n\u002B|3.i| Per feature documentation | \u0393\u00A3\u00F4 |\n\u002B|3.ii| Per public API item documentation | * |\n\u002B|3.iii| Declared License(s) | \u0393\u00A3\u00F4 |\n\u002B|3.iv| Copyright in source files| \u0393\u00A3\u00F4 |\n\u002B|3.v.a| Quality declaration linked to README | \u0393\u00A3\u00F4 |\n\u002B|3.v.b| Centralized declaration available for peer review |\u0393\u00A3\u00F4|\n\u002B|4| **Testing** | --- |\n\u002B|4.i| Feature items tests | \u0393\u00A3\u00F4 |\n\u002B|4.ii| Public API tests | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Using coverage | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Coverage policy | \u0393\u00A3\u00F4 |\n\u002B|4.iv.a| Performance tests (if applicable) | \u0393\u00FF\u00F4 |\n\u002B|4.iv.b| Performance tests policy| \u0393\u00A3\u00F4 |\n\u002B|4.v.a| Code style enforcement (linters)| \u0393\u00A3\u00F4 |\n\u002B|4.v.b| Use of static analysis tools | \u0393\u00A3\u00F4 |\n\u002B|5| **Dependencies** | --- |\n\u002B|5.i| Must not have ROS lower level dependencies | \u0393\u00A3\u00F4 |\n\u002B|5.ii| Optional ROS lower level dependencies| \u0393\u00A3\u00F4 |\n\u002B|5.iii| Justifies quality use of non-ROS dependencies |\u0393\u00A3\u00F4|\n\u002B|6| **Platform support** | --- |\n\u002B|6.i| Support targets Tier1 ROS platforms| \u0393\u00A3\u00F4 |\n\u002B|7| **Security** | --- |\n\u002B|7.i| Vulnerability Disclosure Policy | \u0393\u00A3\u00F4 |\ndiff --git rmw_fastrtps_shared_cpp/README.md rmw_fastrtps_shared_cpp/README.md\nindex 202b27e..f4242c8 100644\n--- rmw_fastrtps_shared_cpp/README.md\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/README.md\n@@ -4,4 \u002B4,4 @@\n \n ## Quality Declaration\n \n-This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 3** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "e3d9d819af09d3aced7f887b5c9add75f5eaa514",
    "RawMessage": "Create common structures for executors to use (#2143)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex 96351f75..3bd558de 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -59,6 \u002B59,9 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/executable_list.cpp\n   src/rclcpp/executor.cpp\n   src/rclcpp/executors.cpp\n\u002B  src/rclcpp/executors/executor_entities_collection.cpp\n\u002B  src/rclcpp/executors/executor_entities_collector.cpp\n\u002B  src/rclcpp/executors/executor_notify_waitable.cpp\n   src/rclcpp/executors/multi_threaded_executor.cpp\n   src/rclcpp/executors/single_threaded_executor.cpp\n   src/rclcpp/executors/static_executor_entities_collector.cpp\ndiff --git rclcpp/include/rclcpp/callback_group.hpp rclcpp/include/rclcpp/callback_group.hpp\nindex 7d03edf3..97579fcf 100644\n--- rclcpp/include/rclcpp/callback_group.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/callback_group.hpp\n@@ -93,11 \u002B93,54 @@ public:\n    *   determines whether a callback group is automatically added to an executor\n    *   with the node with which it is associated.\n    */\n\u002B  [[deprecated(\u0022Use CallbackGroup constructor with context function argument\u0022)]]\n   RCLCPP_PUBLIC\n   explicit CallbackGroup(\n     CallbackGroupType group_type,\n     bool automatically_add_to_executor_with_node = true);\n \n\u002B  /// Constructor for CallbackGroup.\n\u002B  /**\n\u002B   * Callback Groups have a type, either \u0027Mutually Exclusive\u0027 or \u0027Reentrant\u0027\n\u002B   * and when creating one the type must be specified.\n\u002B   *\n\u002B   * Callbacks in Reentrant Callback Groups must be able to:\n\u002B   *   - run at the same time as themselves (reentrant)\n\u002B   *   - run at the same time as other callbacks in their group\n\u002B   *   - run at the same time as other callbacks in other groups\n\u002B   *\n\u002B   * Callbacks in Mutually Exclusive Callback Groups:\n\u002B   *   - will not be run multiple times simultaneously (non-reentrant)\n\u002B   *   - will not be run at the same time as other callbacks in their group\n\u002B   *   - but must run at the same time as callbacks in other groups\n\u002B   *\n\u002B   * Additionally, callback groups have a property which determines whether or\n\u002B   * not they are added to an executor with their associated node automatically.\n\u002B   * When creating a callback group the automatically_add_to_executor_with_node\n\u002B   * argument determines this behavior, and if true it will cause the newly\n\u002B   * created callback group to be added to an executor with the node when the\n\u002B   * Executor::add_node method is used.\n\u002B   * If false, this callback group will not be added automatically and would\n\u002B   * have to be added to an executor manually using the\n\u002B   * Executor::add_callback_group method.\n\u002B   *\n\u002B   * Whether the node was added to the executor before creating the callback\n\u002B   * group, or after, is irrelevant; the callback group will be automatically\n\u002B   * added to the executor in either case.\n\u002B   *\n\u002B   * \\param[in] group_type The type of the callback group.\n\u002B   * \\param[in] get_node_context Lambda to retrieve the node context when\n\u002B   *   checking that the creating node is valid and using the guard condition.\n\u002B   * \\param[in] automatically_add_to_executor_with_node A boolean that\n\u002B   *   determines whether a callback group is automatically added to an executor\n\u002B   *   with the node with which it is associated.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  explicit CallbackGroup(\n\u002B    CallbackGroupType group_type,\n\u002B    std::function\u003Crclcpp::Context::SharedPtr(void)\u003E get_node_context,\n\u002B    bool automatically_add_to_executor_with_node = true);\n\u002B\n   /// Default destructor.\n   RCLCPP_PUBLIC\n   ~CallbackGroup();\n@@ -178,11 \u002B221,24 @@ public:\n   bool\n   automatically_add_to_executor_with_node() const;\n \n-  /// Defer creating the notify guard condition and return it.\n\u002B  /// Retrieve the guard condition used to signal changes to this callback group.\n\u002B  /**\n\u002B   * \\param[in] context_ptr context to use when creating the guard condition\n\u002B   * \\return guard condition if it is valid, otherwise nullptr.\n\u002B   */\n\u002B  [[deprecated(\u0022Use get_notify_guard_condition() without arguments\u0022)]]\n   RCLCPP_PUBLIC\n   rclcpp::GuardCondition::SharedPtr\n   get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr);\n \n\u002B  /// Retrieve the guard condition used to signal changes to this callback group.\n\u002B  /**\n\u002B   * \\return guard condition if it is valid, otherwise nullptr.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  rclcpp::GuardCondition::SharedPtr\n\u002B  get_notify_guard_condition();\n\u002B\n   /// Trigger the notify guard condition.\n   RCLCPP_PUBLIC\n   void\n@@ -234,6 \u002B290,8 @@ protected:\n   std::shared_ptr\u003Crclcpp::GuardCondition\u003E notify_guard_condition_ = nullptr;\n   std::recursive_mutex notify_guard_condition_mutex_;\n \n\u002B  std::function\u003Crclcpp::Context::SharedPtr(void)\u003E get_context_;\n\u002B\n private:\n   template\u003Ctypename TypeT, typename Function\u003E\n   typename TypeT::SharedPtr _find_ptrs_if_impl(\ndiff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex 94a84885..3e654faa 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -637,8 \u002B637,9 @@ protected:\n   std::atomic_bool spinning;\n \n   /// Guard condition for signaling the rmw layer to wake up for special events.\n-  rclcpp::GuardCondition interrupt_guard_condition_;\n\u002B  std::shared_ptr\u003Crclcpp::GuardCondition\u003E interrupt_guard_condition_;\n \n\u002B  /// Guard condition for signaling the rmw layer to wake up for system shutdown.\n   std::shared_ptr\u003Crclcpp::GuardCondition\u003E shutdown_guard_condition_;\n \n   /// Wait set for managing entities that the rmw layer waits on.\ndiff --git rclcpp/include/rclcpp/executors/executor_entities_collection.hpp rclcpp/include/rclcpp/executors/executor_entities_collection.hpp\nnew file mode 100644\nindex 00000000..98a92ccd\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/executor_entities_collection.hpp\n@@ -0,0 \u002B1,212 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_\n\u002B#define RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_\n\u002B\n\u002B#include \u003Cdeque\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cunordered_map\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u003Crclcpp/any_executable.hpp\u003E\n\u002B#include \u003Crclcpp/node_interfaces/node_base.hpp\u003E\n\u002B#include \u003Crclcpp/callback_group.hpp\u003E\n\u002B#include \u003Crclcpp/executors/executor_notify_waitable.hpp\u003E\n\u002B#include \u003Crclcpp/visibility_control.hpp\u003E\n\u002B#include \u003Crclcpp/wait_result.hpp\u003E\n\u002B#include \u003Crclcpp/wait_set.hpp\u003E\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002B\n\u002B/// Structure to represent a single entity\u0027s entry in a collection\n\u002Btemplate\u003Ctypename EntityValueType\u003E\n\u002Bstruct CollectionEntry\n\u002B{\n\u002B  /// Weak pointer to entity type\n\u002B  using EntityWeakPtr = typename EntityValueType::WeakPtr;\n\u002B  /// Shared pointer to entity type\n\u002B  using EntitySharedPtr = typename EntityValueType::SharedPtr;\n\u002B\n\u002B  /// The entity\n\u002B  EntityWeakPtr entity;\n\u002B\n\u002B  /// If relevant, the entity\u0027s corresponding callback_group\n\u002B  rclcpp::CallbackGroup::WeakPtr callback_group;\n\u002B};\n\u002B\n\u002B/// Update a collection based on another collection\n\u002B/*\n\u002B * Iterates update_from and update_to to see which entities have been added/removed between\n\u002B * the two collections.\n\u002B *\n\u002B * For each new entry (in update_from, but not in update_to),\n\u002B *   add the entity and fire the on_added callback\n\u002B * For each removed entry (in update_to, but not in update_from),\n\u002B *   remove the entity and fire the on_removed callback.\n\u002B *\n\u002B *  \\param[in] update_from The collection representing the next iteration\u0027s state\n\u002B *  \\param[inout] update_to The collection representing the current iteration\u0027s state\n\u002B *  \\param[in] on_added Callback fired when a new entity is detected\n\u002B *  \\param[in] on_removed Callback fired when an entity is removed\n\u002B */\n\u002Btemplate\u003Ctypename CollectionType\u003E\n\u002Bvoid update_entities(\n\u002B  const CollectionType \u0026 update_from,\n\u002B  CollectionType \u0026 update_to,\n\u002B  std::function\u003Cvoid(const typename CollectionType::EntitySharedPtr \u0026)\u003E on_added,\n\u002B  std::function\u003Cvoid(const typename CollectionType::EntitySharedPtr \u0026)\u003E on_removed\n\u002B)\n\u002B{\n\u002B  for (auto it = update_to.begin(); it != update_to.end(); ) {\n\u002B    if (update_from.count(it-\u003Efirst) == 0) {\n\u002B      auto entity = it-\u003Esecond.entity.lock();\n\u002B      if (entity) {\n\u002B        on_removed(entity);\n\u002B      }\n\u002B      it = update_to.erase(it);\n\u002B    } else {\n\u002B      \u002B\u002Bit;\n\u002B    }\n\u002B  }\n\u002B  for (auto it = update_from.begin(); it != update_from.end(); \u002B\u002Bit) {\n\u002B    if (update_to.count(it-\u003Efirst) == 0) {\n\u002B      auto entity = it-\u003Esecond.entity.lock();\n\u002B      if (entity) {\n\u002B        on_added(entity);\n\u002B      }\n\u002B      update_to.insert(*it);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002B/// A collection of entities, indexed by their corresponding handles\n\u002Btemplate\u003Ctypename EntityKeyType, typename EntityValueType\u003E\n\u002Bclass EntityCollection\n\u002B  : public std::unordered_map\u003Cconst EntityKeyType *, CollectionEntry\u003CEntityValueType\u003E\u003E\n\u002B{\n\u002Bpublic:\n\u002B  /// Key type of the map\n\u002B  using Key = const EntityKeyType *;\n\u002B\n\u002B  /// Weak pointer to entity type\n\u002B  using EntityWeakPtr = typename EntityValueType::WeakPtr;\n\u002B\n\u002B  /// Shared pointer to entity type\n\u002B  using EntitySharedPtr = typename EntityValueType::SharedPtr;\n\u002B\n\u002B  /// Update this collection based on the contents of another collection\n\u002B  /**\n\u002B   * Update the internal state of this collection, firing callbacks when entities have been\n\u002B   * added or removed.\n\u002B   *\n\u002B   * \\param[in] other Collection to compare to\n\u002B   * \\param[in] on_added Callback for when entities have been added\n\u002B   * \\param[in] on_removed Callback for when entities have been removed\n\u002B   */\n\u002B  void update(\n\u002B    const EntityCollection\u003CEntityKeyType, EntityValueType\u003E \u0026 other,\n\u002B    std::function\u003Cvoid(const EntitySharedPtr \u0026)\u003E on_added,\n\u002B    std::function\u003Cvoid(const EntitySharedPtr \u0026)\u003E on_removed)\n\u002B  {\n\u002B    update_entities(other, *this, on_added, on_removed);\n\u002B  }\n\u002B};\n\u002B\n\u002B/// Represent the total set of entities for a single executor\n\u002B/**\n\u002B * This allows the entities to be stored from ExecutorEntitiesCollector.\n\u002B * The structure also makes in convenient to re-evaluate when entities have been added or removed.\n\u002B */\n\u002Bstruct ExecutorEntitiesCollection\n\u002B{\n\u002B  /// Collection type for timer entities\n\u002B  using TimerCollection = EntityCollection\u003Crcl_timer_t, rclcpp::TimerBase\u003E;\n\u002B\n\u002B  /// Collection type for subscription entities\n\u002B  using SubscriptionCollection = EntityCollection\u003Crcl_subscription_t, rclcpp::SubscriptionBase\u003E;\n\u002B\n\u002B  /// Collection type for client entities\n\u002B  using ClientCollection = EntityCollection\u003Crcl_client_t, rclcpp::ClientBase\u003E;\n\u002B\n\u002B  /// Collection type for service entities\n\u002B  using ServiceCollection = EntityCollection\u003Crcl_service_t, rclcpp::ServiceBase\u003E;\n\u002B\n\u002B  /// Collection type for waitable entities\n\u002B  using WaitableCollection = EntityCollection\u003Crclcpp::Waitable, rclcpp::Waitable\u003E;\n\u002B\n\u002B  /// Collection type for guard condition entities\n\u002B  using GuardConditionCollection = EntityCollection\u003Crcl_guard_condition_t, rclcpp::GuardCondition\u003E;\n\u002B\n\u002B  /// Collection of timers currently in use by the executor.\n\u002B  TimerCollection timers;\n\u002B\n\u002B  /// Collection of subscriptions currently in use by the executor.\n\u002B  SubscriptionCollection subscriptions;\n\u002B\n\u002B  /// Collection of clients currently in use by the executor.\n\u002B  ClientCollection clients;\n\u002B\n\u002B  /// Collection of services currently in use by the executor.\n\u002B  ServiceCollection services;\n\u002B\n\u002B  /// Collection of guard conditions currently in use by the executor.\n\u002B  GuardConditionCollection guard_conditions;\n\u002B\n\u002B  /// Collection of waitables currently in use by the executor.\n\u002B  WaitableCollection waitables;\n\u002B\n\u002B  /// Check if the entities collection is empty\n\u002B  /**\n\u002B   * \\return true if all member collections are empty, false otherwise\n\u002B  */\n\u002B  bool empty() const;\n\u002B\n\u002B  /// Clear the entities collection\n\u002B  void clear();\n\u002B};\n\u002B\n\u002B/// Build an entities collection from callback groups\n\u002B/**\n\u002B * Iterates a list of callback groups and adds entities from each valid group\n\u002B *\n\u002B * \\param[in] callback_groups List of callback groups to check for entities\n\u002B * \\param[inout] colletion Entities collection to populate with found entities\n\u002B */\n\u002Bvoid\n\u002Bbuild_entities_collection(\n\u002B  const std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E \u0026 callback_groups,\n\u002B  ExecutorEntitiesCollection \u0026 collection);\n\u002B\n\u002B/// Build a queue of executables ready to be executed\n\u002B/**\n\u002B * Iterates a list of entities and adds them to a queue if they are ready.\n\u002B *\n\u002B * \\param[in] collection Collection of entities corresponding to the current wait set.\n\u002B * \\param[in] wait_result Result of rclcpp::WaitSet::wait corresponding to the collection.\n\u002B * \\return A queue of executables that have been marked ready by the waitset.\n\u002B */\n\u002Bstd::deque\u003Crclcpp::AnyExecutable\u003E\n\u002Bready_executables(\n\u002B  const ExecutorEntitiesCollection \u0026 collection,\n\u002B  rclcpp::WaitResult\u003Crclcpp::WaitSet\u003E \u0026 wait_result\n\u002B);\n\u002B\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\n\u002B\n\u002B#endif  // RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTION_HPP_\ndiff --git rclcpp/include/rclcpp/executors/executor_entities_collector.hpp rclcpp/include/rclcpp/executors/executor_entities_collector.hpp\nnew file mode 100644\nindex 00000000..ad9bc84f\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/executor_entities_collector.hpp\n@@ -0,0 \u002B1,270 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_\n\u002B#define RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_\n\u002B\n\u002B#include \u003Cmap\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cmutex\u003E\n\u002B#include \u003Cset\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u0022rcpputils/thread_safety_annotations.hpp\u0022\n\u002B\n\u002B#include \u003Crclcpp/any_executable.hpp\u003E\n\u002B#include \u003Crclcpp/node_interfaces/node_base.hpp\u003E\n\u002B#include \u003Crclcpp/callback_group.hpp\u003E\n\u002B#include \u003Crclcpp/executors/executor_notify_waitable.hpp\u003E\n\u002B#include \u003Crclcpp/visibility_control.hpp\u003E\n\u002B#include \u003Crclcpp/wait_set.hpp\u003E\n\u002B#include \u003Crclcpp/wait_result.hpp\u003E\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002B\n\u002B/// Class to monitor a set of nodes and callback groups for changes in entity membership\n\u002B/**\n\u002B * This is to be used with an executor to track the membership of various nodes, groups,\n\u002B * and entities (timers, subscriptions, clients, services, etc) and report status to the\n\u002B * executor.\n\u002B *\n\u002B * In general, users will add either nodes or callback groups to an executor.\n\u002B * Each node may have callback groups that are automatically associated with executors,\n\u002B * or callback groups that must be manually associated with an executor.\n\u002B *\n\u002B * This object tracks both types of callback groups as well as nodes that have been\n\u002B * previously added to the executor.\n\u002B * When a new callback group is added/removed or new entities are added/removed, the\n\u002B * corresponding node or callback group will signal this to the executor so that the\n\u002B * entity collection may be rebuilt according to that executor\u0027s implementation.\n\u002B *\n\u002B */\n\u002Bclass ExecutorEntitiesCollector\n\u002B{\n\u002Bpublic:\n\u002B  /// Constructor\n\u002B  /**\n\u002B   * \\param[in] notify_waitable Waitable that is used to signal to the executor\n\u002B   *   when nodes or callback groups have been added or removed.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  explicit ExecutorEntitiesCollector(\n\u002B    std::shared_ptr\u003CExecutorNotifyWaitable\u003E notify_waitable);\n\u002B\n\u002B  /// Destructor\n\u002B  RCLCPP_PUBLIC\n\u002B  ~ExecutorEntitiesCollector();\n\u002B\n\u002B  /// Indicate if the entities collector has pending additions or removals.\n\u002B  /**\n\u002B   * \\return true if there are pending additions or removals\n\u002B   */\n\u002B  bool has_pending() const;\n\u002B\n\u002B  /// Add a node to the entity collector\n\u002B  /**\n\u002B   * \\param[in] node_ptr a shared pointer that points to a node base interface\n\u002B   * \\throw std::runtime_error if the node is associated with an executor\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr);\n\u002B\n\u002B  /// Remove a node from the entity collector\n\u002B  /**\n\u002B   * \\param[in] node_ptr a shared pointer that points to a node base interface\n\u002B   * \\throw std::runtime_error if the node is associated with an executor\n\u002B   * \\throw std::runtime_error if the node is associated with this executor\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  remove_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr);\n\u002B\n\u002B  /// Add a callback group to the entity collector\n\u002B  /**\n\u002B   * \\param[in] group_ptr a shared pointer that points to a callback group\n\u002B   * \\throw std::runtime_error if the callback_group is associated with an executor\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr);\n\u002B\n\u002B  /// Remove a callback group from the entity collector\n\u002B  /**\n\u002B   * \\param[in] group_ptr a shared pointer that points to a callback group\n\u002B   * \\throw std::runtime_error if the callback_group is not associated with an executor\n\u002B   * \\throw std::runtime_error if the callback_group is not associated with this executor\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  remove_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr);\n\u002B\n\u002B  /// Get all callback groups known to this entity collector\n\u002B  /**\n\u002B   * This will include manually added and automatically added (node associated) groups\n\u002B   * \\return vector of all callback groups\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002B  get_all_callback_groups() const;\n\u002B\n\u002B  /// Get manually-added callback groups known to this entity collector\n\u002B  /**\n\u002B   * This will include callback groups that have been added via add_callback_group\n\u002B   * \\return vector of manually-added callback groups\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002B  get_manually_added_callback_groups() const;\n\u002B\n\u002B  /// Get automatically-added callback groups known to this entity collector\n\u002B  /**\n\u002B   * This will include callback groups that are associated with nodes added via add_node\n\u002B   * \\return vector of automatically-added callback groups\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002B  get_automatically_added_callback_groups() const;\n\u002B\n\u002B  /// Update the underlying collections\n\u002B  /**\n\u002B   * This will prune nodes and callback groups that are no longer valid as well\n\u002B   * as add new callback groups from any associated nodes.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  update_collections();\n\u002B\n\u002Bprotected:\n\u002B  using NodeCollection = std::set\u003C\n\u002B    rclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n\u002B    std::owner_less\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr\u003E\u003E;\n\u002B\n\u002B  using CallbackGroupCollection = std::set\u003C\n\u002B    rclcpp::CallbackGroup::WeakPtr,\n\u002B    std::owner_less\u003Crclcpp::CallbackGroup::WeakPtr\u003E\u003E;\n\u002B\n\u002B  using WeakNodesToGuardConditionsMap = std::map\u003C\n\u002B    rclcpp::node_interfaces::NodeBaseInterface::WeakPtr,\n\u002B    rclcpp::GuardCondition::WeakPtr,\n\u002B    std::owner_less\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr\u003E\u003E;\n\u002B\n\u002B  using WeakGroupsToGuardConditionsMap = std::map\u003C\n\u002B    rclcpp::CallbackGroup::WeakPtr,\n\u002B    rclcpp::GuardCondition::WeakPtr,\n\u002B    std::owner_less\u003Crclcpp::CallbackGroup::WeakPtr\u003E\u003E;\n\u002B\n\u002B  /// Implementation of removing a node from the collector.\n\u002B  /**\n\u002B   * This will disassociate the node from the collector and remove any\n\u002B   * automatically-added callback groups\n\u002B   *\n\u002B   * This takes and returns an iterator so it may be used as:\n\u002B   *\n\u002B   * it = remove_weak_node(it);\n\u002B   *\n\u002B   * \\param[in] weak_node iterator to the weak node to be removed\n\u002B   * \\return Valid updated iterator in the same collection\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  NodeCollection::iterator\n\u002B  remove_weak_node(NodeCollection::iterator weak_node) RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// Implementation of removing a callback group from the collector.\n\u002B  /**\n\u002B   * This will disassociate the callback group from the collector\n\u002B   *\n\u002B   * This takes and returns an iterator so it may be used as:\n\u002B   *\n\u002B   * it = remove_weak_callback_group(it);\n\u002B   *\n\u002B   * \\param[in] weak_group_it iterator to the weak group to be removed\n\u002B   * \\param[in] collection the collection to remove the group from\n\u002B   *   (manually or automatically added)\n\u002B   * \\return Valid updated iterator in the same collection\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  CallbackGroupCollection::iterator\n\u002B  remove_weak_callback_group(\n\u002B    CallbackGroupCollection::iterator weak_group_it,\n\u002B    CallbackGroupCollection \u0026 collection) RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// Implementation of adding a callback group\n\u002B  /**\n\u002B   * \\param[in] group_ptr the group to add\n\u002B   * \\param[in] collection the collection to add the group to\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_callback_group_to_collection(\n\u002B    rclcpp::CallbackGroup::SharedPtr group_ptr,\n\u002B    CallbackGroupCollection \u0026 collection)  RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// Iterate over queued added/remove nodes and callback_groups\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  process_queues() RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// Check a collection of nodes and add any new callback_groups that\n\u002B  /// are set to be automatically associated via the node.\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_automatically_associated_callback_groups(\n\u002B    const NodeCollection \u0026 nodes_to_check) RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// Check all nodes and group for expired weak pointers and remove them.\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  prune_invalid_nodes_and_groups() RCPPUTILS_TSA_REQUIRES(mutex_);\n\u002B\n\u002B  /// mutex to protect collections and pending queues\n\u002B  mutable std::mutex mutex_;\n\u002B\n\u002B  /// Callback groups that were added via \u0060add_callback_group\u0060\n\u002B  CallbackGroupCollection manually_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// Callback groups that were added by their association with added nodes\n\u002B  CallbackGroupCollection automatically_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// nodes that are associated with the executor\n\u002B  NodeCollection weak_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// Track guard conditions associated with added nodes\n\u002B  WeakNodesToGuardConditionsMap weak_nodes_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// Track guard conditions associated with added callback groups\n\u002B  WeakGroupsToGuardConditionsMap weak_groups_to_guard_conditions_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// nodes that have been added since the last update.\n\u002B  NodeCollection pending_added_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// nodes that have been removed since the last update.\n\u002B  NodeCollection pending_removed_nodes_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// callback groups that have been added since the last update.\n\u002B  CallbackGroupCollection pending_manually_added_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// callback groups that have been removed since the last update.\n\u002B  CallbackGroupCollection pending_manually_removed_groups_ RCPPUTILS_TSA_GUARDED_BY(mutex_);\n\u002B\n\u002B  /// Waitable to add guard conditions to\n\u002B  std::shared_ptr\u003CExecutorNotifyWaitable\u003E notify_waitable_;\n\u002B};\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\n\u002B//\n\u002B#endif  // RCLCPP__EXECUTORS__EXECUTOR_ENTITIES_COLLECTOR_HPP_\ndiff --git rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp\nnew file mode 100644\nindex 00000000..88158952\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/executors/executor_notify_waitable.hpp\n@@ -0,0 \u002B1,129 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_\n\u002B#define RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_\n\u002B\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cmutex\u003E\n\u002B#include \u003Cset\u003E\n\u002B\n\u002B#include \u0022rclcpp/guard_condition.hpp\u0022\n\u002B#include \u0022rclcpp/waitable.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002B\n\u002B/// Maintain a collection of guard conditions from associated nodes and callback groups\n\u002B/// to signal to the executor when associated entities have changed.\n\u002Bclass ExecutorNotifyWaitable : public rclcpp::Waitable\n\u002B{\n\u002Bpublic:\n\u002B  RCLCPP_SMART_PTR_DEFINITIONS(ExecutorNotifyWaitable)\n\u002B\n\u002B  // Constructor\n\u002B  /**\n\u002B   * \\param[in] on_execute_callback Callback to execute when one of the conditions\n\u002B   *   of this waitable has signaled the wait_set.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  explicit ExecutorNotifyWaitable(std::function\u003Cvoid(void)\u003E on_execute_callback = {});\n\u002B\n\u002B  // Destructor\n\u002B  RCLCPP_PUBLIC\n\u002B  ~ExecutorNotifyWaitable() override = default;\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  ExecutorNotifyWaitable(const ExecutorNotifyWaitable \u0026 other);\n\u002B\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  ExecutorNotifyWaitable \u0026 operator=(const ExecutorNotifyWaitable \u0026 other);\n\u002B\n\u002B  /// Add conditions to the wait set\n\u002B  /**\n\u002B   * \\param[inout] wait_set structure that conditions will be added to\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_to_wait_set(rcl_wait_set_t * wait_set) override;\n\u002B\n\u002B  /// Check conditions against the wait set\n\u002B  /**\n\u002B   * \\param[inout] wait_set structure that internal elements will be checked against.\n\u002B   * \\return true if this waitable is ready to be executed, false otherwise.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  bool\n\u002B  is_ready(rcl_wait_set_t * wait_set) override;\n\u002B\n\u002B  /// Perform work associated with the waitable.\n\u002B  /**\n\u002B   * This will call the callback provided in the constructor.\n\u002B   * \\param[in] data Data to be use for the execute, if available, else nullptr.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  execute(std::shared_ptr\u003Cvoid\u003E \u0026 data) override;\n\u002B\n\u002B  /// Retrieve data to be used in the next execute call.\n\u002B  /**\n\u002B   * \\return If available, data to be used, otherwise nullptr\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  std::shared_ptr\u003Cvoid\u003E\n\u002B  take_data() override;\n\u002B\n\u002B  /// Add a guard condition to be waited on.\n\u002B  /**\n\u002B   * \\param[in] guard_condition The guard condition to add.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  add_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition);\n\u002B\n\u002B  /// Remove a guard condition from being waited on.\n\u002B  /**\n\u002B   * \\param[in] guard_condition The guard condition to remove.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  remove_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition);\n\u002B\n\u002B  /// Get the number of ready guard_conditions\n\u002B  /**\n\u002B   * \\return The number of guard_conditions associated with the Waitable.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  size_t\n\u002B  get_number_of_ready_guard_conditions() override;\n\u002B\n\u002Bprivate:\n\u002B  /// Callback to run when waitable executes\n\u002B  std::function\u003Cvoid(void)\u003E execute_callback_;\n\u002B\n\u002B  std::mutex guard_condition_mutex_;\n\u002B\n\u002B  /// The collection of guard conditions to be waited on.\n\u002B  std::set\u003Crclcpp::GuardCondition::WeakPtr,\n\u002B    std::owner_less\u003Crclcpp::GuardCondition::WeakPtr\u003E\u003E notify_guard_conditions_;\n\u002B};\n\u002B\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\n\u002B\n\u002B#endif  // RCLCPP__EXECUTORS__EXECUTOR_NOTIFY_WAITABLE_HPP_\ndiff --git rclcpp/include/rclcpp/node_interfaces/node_base.hpp rclcpp/include/rclcpp/node_interfaces/node_base.hpp\nindex a6c84e4a..6173a08d 100644\n--- rclcpp/include/rclcpp/node_interfaces/node_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_interfaces/node_base.hpp\n@@ -121,10 \u002B121,19 @@ public:\n   std::atomic_bool \u0026\n   get_associated_with_executor_atomic() override;\n \n\u002B  [[deprecated(\u0022Use get_shared_notify_guard_condition or trigger_notify_guard_condition instead\u0022)]]\n   RCLCPP_PUBLIC\n   rclcpp::GuardCondition \u0026\n   get_notify_guard_condition() override;\n \n\u002B  RCLCPP_PUBLIC\n\u002B  rclcpp::GuardCondition::SharedPtr\n\u002B  get_shared_notify_guard_condition() override;\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  trigger_notify_guard_condition() override;\n\u002B\n   RCLCPP_PUBLIC\n   bool\n   get_use_intra_process_default() const override;\n@@ -153,7 \u002B162,7 @@ private:\n \n   /// Guard condition for notifying the Executor of changes to this node.\n   mutable std::recursive_mutex notify_guard_condition_mutex_;\n-  rclcpp::GuardCondition notify_guard_condition_;\n\u002B  std::shared_ptr\u003Crclcpp::GuardCondition\u003E notify_guard_condition_;\n   bool notify_guard_condition_is_valid_;\n };\n \ndiff --git rclcpp/include/rclcpp/node_interfaces/node_base_interface.hpp rclcpp/include/rclcpp/node_interfaces/node_base_interface.hpp\nindex fd4f64b2..e5a31982 100644\n--- rclcpp/include/rclcpp/node_interfaces/node_base_interface.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_interfaces/node_base_interface.hpp\n@@ -148,13 \u002B148,33 @@ public:\n   /**\n    * For example, this should be notified when a publisher is added or removed.\n    *\n-   * \\return the GuardCondition if it is valid, else thow runtime error\n\u002B   * \\return the GuardCondition if it is valid, else throw runtime error\n    */\n   RCLCPP_PUBLIC\n   virtual\n   rclcpp::GuardCondition \u0026\n   get_notify_guard_condition() = 0;\n \n\u002B  /// Return a guard condition that should be notified when the internal node state changes.\n\u002B  /**\n\u002B   * For example, this should be notified when a publisher is added or removed.\n\u002B   *\n\u002B   * \\return the GuardCondition if it is valid, else nullptr\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  virtual\n\u002B  rclcpp::GuardCondition::SharedPtr\n\u002B  get_shared_notify_guard_condition() = 0;\n\u002B\n\u002B  /// Trigger the guard condition that notifies of internal node state changes.\n\u002B  /**\n\u002B   * For example, this should be notified when a publisher is added or removed.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  virtual\n\u002B  void\n\u002B  trigger_notify_guard_condition() = 0;\n\u002B\n   /// Return the default preference for using intra process communication.\n   RCLCPP_PUBLIC\n   virtual\ndiff --git rclcpp/src/rclcpp/callback_group.cpp rclcpp/src/rclcpp/callback_group.cpp\nindex 734c781a..753a4413 100644\n--- rclcpp/src/rclcpp/callback_group.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/callback_group.cpp\n@@ -31,10 \u002B31,12 @@ using rclcpp::CallbackGroupType;\n \n CallbackGroup::CallbackGroup(\n   CallbackGroupType group_type,\n\u002B  std::function\u003Crclcpp::Context::SharedPtr(void)\u003E get_context,\n   bool automatically_add_to_executor_with_node)\n : type_(group_type), associated_with_executor_(false),\n   can_be_taken_from_(true),\n-  automatically_add_to_executor_with_node_(automatically_add_to_executor_with_node)\n\u002B  automatically_add_to_executor_with_node_(automatically_add_to_executor_with_node),\n\u002B  get_context_(get_context)\n {}\n \n CallbackGroup::~CallbackGroup()\n@@ -111,6 \u002B113,7 @@ CallbackGroup::automatically_add_to_executor_with_node() const\n   return automatically_add_to_executor_with_node_;\n }\n \n\u002B// \\TODO(mjcarroll) Deprecated, remove on tock\n rclcpp::GuardCondition::SharedPtr\n CallbackGroup::get_notify_guard_condition(const rclcpp::Context::SharedPtr context_ptr)\n {\n@@ -129,6 \u002B132,29 @@ CallbackGroup::get_notify_guard_condition(const rclcpp::Context::SharedPtr conte\n   return notify_guard_condition_;\n }\n \n\u002Brclcpp::GuardCondition::SharedPtr\n\u002BCallbackGroup::get_notify_guard_condition()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(notify_guard_condition_mutex_);\n\u002B  if (!this-\u003Eget_context_) {\n\u002B    throw std::runtime_error(\u0022Callback group was created without context and not passed context\u0022);\n\u002B  }\n\u002B  auto context_ptr = this-\u003Eget_context_();\n\u002B  if (context_ptr \u0026\u0026 context_ptr-\u003Eis_valid()) {\n\u002B    if (notify_guard_condition_ \u0026\u0026 context_ptr != notify_guard_condition_-\u003Eget_context()) {\n\u002B      if (associated_with_executor_) {\n\u002B        trigger_notify_guard_condition();\n\u002B      }\n\u002B      notify_guard_condition_ = nullptr;\n\u002B    }\n\u002B    if (!notify_guard_condition_) {\n\u002B      notify_guard_condition_ = std::make_shared\u003Crclcpp::GuardCondition\u003E(context_ptr);\n\u002B    }\n\u002B    return notify_guard_condition_;\n\u002B  }\n\u002B  return nullptr;\n\u002B}\n\u002B\n void\n CallbackGroup::trigger_notify_guard_condition()\n {\ndiff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 2986cec8..ccd1b610 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -39,14 \u002B39,11 @@\n using namespace std::chrono_literals;\n \n using rclcpp::exceptions::throw_from_rcl_error;\n-using rclcpp::AnyExecutable;\n using rclcpp::Executor;\n-using rclcpp::ExecutorOptions;\n-using rclcpp::FutureReturnCode;\n \n Executor::Executor(const rclcpp::ExecutorOptions \u0026 options)\n : spinning(false),\n-  interrupt_guard_condition_(options.context),\n\u002B  interrupt_guard_condition_(std::make_shared\u003Crclcpp::GuardCondition\u003E(options.context)),\n   shutdown_guard_condition_(std::make_shared\u003Crclcpp::GuardCondition\u003E(options.context)),\n   memory_strategy_(options.memory_strategy)\n {\n@@ -66,7 \u002B63,7 @@ Executor::Executor(const rclcpp::ExecutorOptions \u0026 options)\n   memory_strategy_-\u003Eadd_guard_condition(*shutdown_guard_condition_.get());\n \n   // Put the executor\u0027s guard condition in\n-  memory_strategy_-\u003Eadd_guard_condition(interrupt_guard_condition_);\n\u002B  memory_strategy_-\u003Eadd_guard_condition(*interrupt_guard_condition_.get());\n   rcl_allocator_t allocator = memory_strategy_-\u003Eget_allocator();\n \n   rcl_ret_t ret = rcl_wait_set_init(\n@@ -128,7 \u002B125,7 @@ Executor::~Executor()\n   }\n   // Remove and release the sigint guard condition\n   memory_strategy_-\u003Eremove_guard_condition(shutdown_guard_condition_.get());\n-  memory_strategy_-\u003Eremove_guard_condition(\u0026interrupt_guard_condition_);\n\u002B  memory_strategy_-\u003Eremove_guard_condition(interrupt_guard_condition_.get());\n \n   // Remove shutdown callback handle registered to Context\n   if (!context_-\u003Eremove_on_shutdown_callback(shutdown_callback_handle_)) {\n@@ -223,8 \u002B220,7 @@ Executor::add_callback_group_to_map(\n   weak_groups_to_nodes_.insert(std::make_pair(weak_group_ptr, node_ptr));\n \n   if (node_ptr-\u003Eget_context()-\u003Eis_valid()) {\n-    auto callback_group_guard_condition =\n-      group_ptr-\u003Eget_notify_guard_condition(node_ptr-\u003Eget_context());\n\u002B    auto callback_group_guard_condition = group_ptr-\u003Eget_notify_guard_condition();\n     weak_groups_to_guard_conditions_[weak_group_ptr] = callback_group_guard_condition.get();\n     // Add the callback_group\u0027s notify condition to the guard condition handles\n     memory_strategy_-\u003Eadd_guard_condition(*callback_group_guard_condition);\n@@ -233,7 \u002B229,7 @@ Executor::add_callback_group_to_map(\n   if (notify) {\n     // Interrupt waiting to handle new node\n     try {\n-      interrupt_guard_condition_.trigger();\n\u002B      interrupt_guard_condition_-\u003Etrigger();\n     } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n       throw std::runtime_error(\n               std::string(\n@@ -281,10 \u002B277,10 @@ Executor::add_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_pt\n       }\n     });\n \n-  const auto \u0026 gc = node_ptr-\u003Eget_notify_guard_condition();\n-  weak_nodes_to_guard_conditions_[node_ptr] = \u0026gc;\n\u002B  const auto gc = node_ptr-\u003Eget_shared_notify_guard_condition();\n\u002B  weak_nodes_to_guard_conditions_[node_ptr] = gc.get();\n   // Add the node\u0027s notify condition to the guard condition handles\n-  memory_strategy_-\u003Eadd_guard_condition(gc);\n\u002B  memory_strategy_-\u003Eadd_guard_condition(*gc);\n   weak_nodes_.push_back(node_ptr);\n }\n \n@@ -321,7 \u002B317,7 @@ Executor::remove_callback_group_from_map(\n \n     if (notify) {\n       try {\n-        interrupt_guard_condition_.trigger();\n\u002B        interrupt_guard_condition_-\u003Etrigger();\n       } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n         throw std::runtime_error(\n                 std::string(\n@@ -389,7 \u002B385,7 @@ Executor::remove_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node\n     }\n   }\n \n-  memory_strategy_-\u003Eremove_guard_condition(\u0026node_ptr-\u003Eget_notify_guard_condition());\n\u002B  memory_strategy_-\u003Eremove_guard_condition(node_ptr-\u003Eget_shared_notify_guard_condition().get());\n   weak_nodes_to_guard_conditions_.erase(node_ptr);\n \n   std::atomic_bool \u0026 has_executor = node_ptr-\u003Eget_associated_with_executor_atomic();\n@@ -502,7 \u002B498,7 @@ Executor::cancel()\n {\n   spinning.store(false);\n   try {\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022Failed to trigger guard condition in cancel: \u0022) \u002B ex.what());\n@@ -551,7 \u002B547,7 @@ Executor::execute_any_executable(AnyExecutable \u0026 any_exec)\n   // Wake the wait, because it may need to be recalculated or work that\n   // was previously blocked is now available.\n   try {\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\ndiff --git rclcpp/src/rclcpp/executors/executor_entities_collection.cpp rclcpp/src/rclcpp/executors/executor_entities_collection.cpp\nnew file mode 100644\nindex 00000000..567b2801\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/executor_entities_collection.cpp\n@@ -0,0 \u002B1,203 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022rclcpp/executors/executor_entities_collection.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002Bbool ExecutorEntitiesCollection::empty() const\n\u002B{\n\u002B  return subscriptions.empty() \u0026\u0026\n\u002B         timers.empty() \u0026\u0026\n\u002B         guard_conditions.empty() \u0026\u0026\n\u002B         clients.empty() \u0026\u0026\n\u002B         services.empty() \u0026\u0026\n\u002B         waitables.empty();\n\u002B}\n\u002B\n\u002Bvoid ExecutorEntitiesCollection::clear()\n\u002B{\n\u002B  subscriptions.clear();\n\u002B  timers.clear();\n\u002B  guard_conditions.clear();\n\u002B  clients.clear();\n\u002B  services.clear();\n\u002B  waitables.clear();\n\u002B}\n\u002B\n\u002B\n\u002Bvoid\n\u002Bbuild_entities_collection(\n\u002B  const std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E \u0026 callback_groups,\n\u002B  ExecutorEntitiesCollection \u0026 collection)\n\u002B{\n\u002B  collection.clear();\n\u002B\n\u002B  for (auto weak_group_ptr : callback_groups) {\n\u002B    auto group_ptr = weak_group_ptr.lock();\n\u002B    if (!group_ptr) {\n\u002B      continue;\n\u002B    }\n\u002B\n\u002B    if (group_ptr-\u003Ecan_be_taken_from().load()) {\n\u002B      group_ptr-\u003Ecollect_all_ptrs(\n\u002B        [\u0026collection, weak_group_ptr](const rclcpp::SubscriptionBase::SharedPtr \u0026 subscription) {\n\u002B          collection.subscriptions.insert(\n\u002B            {\n\u002B              subscription-\u003Eget_subscription_handle().get(),\n\u002B              {subscription, weak_group_ptr}\n\u002B            });\n\u002B        },\n\u002B        [\u0026collection, weak_group_ptr](const rclcpp::ServiceBase::SharedPtr \u0026 service) {\n\u002B          collection.services.insert(\n\u002B            {\n\u002B              service-\u003Eget_service_handle().get(),\n\u002B              {service, weak_group_ptr}\n\u002B            });\n\u002B        },\n\u002B        [\u0026collection, weak_group_ptr](const rclcpp::ClientBase::SharedPtr \u0026 client) {\n\u002B          collection.clients.insert(\n\u002B            {\n\u002B              client-\u003Eget_client_handle().get(),\n\u002B              {client, weak_group_ptr}\n\u002B            });\n\u002B        },\n\u002B        [\u0026collection, weak_group_ptr](const rclcpp::TimerBase::SharedPtr \u0026 timer) {\n\u002B          collection.timers.insert(\n\u002B            {\n\u002B              timer-\u003Eget_timer_handle().get(),\n\u002B              {timer, weak_group_ptr}\n\u002B            });\n\u002B        },\n\u002B        [\u0026collection, weak_group_ptr](const rclcpp::Waitable::SharedPtr \u0026 waitable) {\n\u002B          collection.waitables.insert(\n\u002B            {\n\u002B              waitable.get(),\n\u002B              {waitable, weak_group_ptr}\n\u002B            });\n\u002B        }\n\u002B      );\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename EntityCollectionType\u003E\n\u002Bvoid check_ready(\n\u002B  EntityCollectionType \u0026 collection,\n\u002B  std::deque\u003Crclcpp::AnyExecutable\u003E \u0026 executables,\n\u002B  size_t size_of_waited_entities,\n\u002B  typename EntityCollectionType::Key * waited_entities,\n\u002B  std::function\u003Cbool(rclcpp::AnyExecutable \u0026,\n\u002B  typename EntityCollectionType::EntitySharedPtr \u0026)\u003E fill_executable)\n\u002B{\n\u002B  for (size_t ii = 0; ii \u003C size_of_waited_entities; \u002B\u002Bii) {\n\u002B    if (!waited_entities[ii]) {continue;}\n\u002B    auto entity_iter = collection.find(waited_entities[ii]);\n\u002B    if (entity_iter != collection.end()) {\n\u002B      auto entity = entity_iter-\u003Esecond.entity.lock();\n\u002B      if (!entity) {\n\u002B        continue;\n\u002B      }\n\u002B\n\u002B      auto callback_group = entity_iter-\u003Esecond.callback_group.lock();\n\u002B      if (callback_group \u0026\u0026 !callback_group-\u003Ecan_be_taken_from().load()) {\n\u002B        continue;\n\u002B      }\n\u002B      rclcpp::AnyExecutable exec;\n\u002B\n\u002B      exec.callback_group = callback_group;\n\u002B      if (fill_executable(exec, entity)) {\n\u002B        executables.push_back(exec);\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bstd::deque\u003Crclcpp::AnyExecutable\u003E\n\u002Bready_executables(\n\u002B  const ExecutorEntitiesCollection \u0026 collection,\n\u002B  rclcpp::WaitResult\u003Crclcpp::WaitSet\u003E \u0026 wait_result\n\u002B)\n\u002B{\n\u002B  std::deque\u003Crclcpp::AnyExecutable\u003E ret;\n\u002B\n\u002B  if (wait_result.kind() != rclcpp::WaitResultKind::Ready) {\n\u002B    return ret;\n\u002B  }\n\u002B  auto rcl_wait_set = wait_result.get_wait_set().get_rcl_wait_set();\n\u002B  check_ready(\n\u002B    collection.timers,\n\u002B    ret,\n\u002B    rcl_wait_set.size_of_timers,\n\u002B    rcl_wait_set.timers,\n\u002B    [](rclcpp::AnyExecutable \u0026 exec, auto timer) {\n\u002B      if (!timer-\u003Ecall()) {\n\u002B        return false;\n\u002B      }\n\u002B      exec.timer = timer;\n\u002B      return true;\n\u002B    });\n\u002B\n\u002B  check_ready(\n\u002B    collection.subscriptions,\n\u002B    ret,\n\u002B    rcl_wait_set.size_of_subscriptions,\n\u002B    rcl_wait_set.subscriptions,\n\u002B    [](rclcpp::AnyExecutable \u0026 exec, auto subscription) {\n\u002B      exec.subscription = subscription;\n\u002B      return true;\n\u002B    });\n\u002B\n\u002B\n\u002B  check_ready(\n\u002B    collection.services,\n\u002B    ret,\n\u002B    rcl_wait_set.size_of_services,\n\u002B    rcl_wait_set.services,\n\u002B    [](rclcpp::AnyExecutable \u0026 exec, auto service) {\n\u002B      exec.service = service;\n\u002B      return true;\n\u002B    });\n\u002B\n\u002B  check_ready(\n\u002B    collection.clients,\n\u002B    ret,\n\u002B    rcl_wait_set.size_of_clients,\n\u002B    rcl_wait_set.clients,\n\u002B    [](rclcpp::AnyExecutable \u0026 exec, auto client) {\n\u002B      exec.client = client;\n\u002B      return true;\n\u002B    });\n\u002B\n\u002B  for (auto \u0026 [handle, entry] : collection.waitables) {\n\u002B    auto waitable = entry.entity.lock();\n\u002B    if (waitable \u0026\u0026 waitable-\u003Eis_ready(\u0026rcl_wait_set)) {\n\u002B      auto group = entry.callback_group.lock();\n\u002B      if (group \u0026\u0026 !group-\u003Ecan_be_taken_from().load()) {\n\u002B        continue;\n\u002B      }\n\u002B\n\u002B      rclcpp::AnyExecutable exec;\n\u002B      exec.waitable = waitable;\n\u002B      exec.callback_group = group;\n\u002B      ret.push_back(exec);\n\u002B    }\n\u002B  }\n\u002B  return ret;\n\u002B}\n\u002B\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/executors/executor_entities_collector.cpp rclcpp/src/rclcpp/executors/executor_entities_collector.cpp\nnew file mode 100644\nindex 00000000..84ada649\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/executor_entities_collector.cpp\n@@ -0,0 \u002B1,416 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cset\u003E\n\u002B\n\u002B#include \u0022rclcpp/executors/executor_entities_collector.hpp\u0022\n\u002B#include \u0022rclcpp/executors/executor_notify_waitable.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_base_interface.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002B\n\u002BExecutorEntitiesCollector::ExecutorEntitiesCollector(\n\u002B  std::shared_ptr\u003CExecutorNotifyWaitable\u003E notify_waitable)\n\u002B: notify_waitable_(notify_waitable)\n\u002B{\n\u002B}\n\u002B\n\u002BExecutorEntitiesCollector::~ExecutorEntitiesCollector()\n\u002B{\n\u002B  for (auto weak_node_it = weak_nodes_.begin(); weak_node_it != weak_nodes_.end(); ) {\n\u002B    weak_node_it = remove_weak_node(weak_node_it);\n\u002B  }\n\u002B\n\u002B  for (auto weak_group_it = automatically_added_groups_.begin();\n\u002B    weak_group_it != automatically_added_groups_.end(); )\n\u002B  {\n\u002B    weak_group_it = remove_weak_callback_group(weak_group_it, automatically_added_groups_);\n\u002B  }\n\u002B\n\u002B  for (auto weak_group_it = manually_added_groups_.begin();\n\u002B    weak_group_it != manually_added_groups_.end(); )\n\u002B  {\n\u002B    weak_group_it = remove_weak_callback_group(weak_group_it, manually_added_groups_);\n\u002B  }\n\u002B\n\u002B  for (auto weak_node_ptr : pending_added_nodes_) {\n\u002B    auto node_ptr = weak_node_ptr.lock();\n\u002B    if (node_ptr) {\n\u002B      node_ptr-\u003Eget_associated_with_executor_atomic().store(false);\n\u002B    }\n\u002B  }\n\u002B  pending_added_nodes_.clear();\n\u002B  pending_removed_nodes_.clear();\n\u002B\n\u002B  for (auto weak_group_ptr : pending_manually_added_groups_) {\n\u002B    auto group_ptr = weak_group_ptr.lock();\n\u002B    if (group_ptr) {\n\u002B      group_ptr-\u003Eget_associated_with_executor_atomic().store(false);\n\u002B    }\n\u002B  }\n\u002B  pending_manually_added_groups_.clear();\n\u002B  pending_manually_removed_groups_.clear();\n\u002B}\n\u002B\n\u002Bbool\n\u002BExecutorEntitiesCollector::has_pending() const\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  return pending_manually_added_groups_.size() != 0 ||\n\u002B         pending_manually_removed_groups_.size() != 0 ||\n\u002B         pending_added_nodes_.size() != 0 ||\n\u002B         pending_removed_nodes_.size() != 0;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::add_node(rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)\n\u002B{\n\u002B  // If the node already has an executor\n\u002B  std::atomic_bool \u0026 has_executor = node_ptr-\u003Eget_associated_with_executor_atomic();\n\u002B  if (has_executor.exchange(true)) {\n\u002B    throw std::runtime_error(\n\u002B            std::string(\u0022Node \u0027\u0022) \u002B node_ptr-\u003Eget_fully_qualified_name() \u002B\n\u002B            \u0022\u0027 has already been added to an executor.\u0022);\n\u002B  }\n\u002B\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  bool associated = weak_nodes_.count(node_ptr) != 0;\n\u002B  bool add_queued = pending_added_nodes_.count(node_ptr) != 0;\n\u002B  bool remove_queued = pending_removed_nodes_.count(node_ptr) != 0;\n\u002B\n\u002B  if ((associated || add_queued) \u0026\u0026 !remove_queued) {\n\u002B    throw std::runtime_error(\n\u002B            std::string(\u0022Node \u0027\u0022) \u002B node_ptr-\u003Eget_fully_qualified_name() \u002B\n\u002B            \u0022\u0027 has already been added to this executor.\u0022);\n\u002B  }\n\u002B\n\u002B  this-\u003Epending_added_nodes_.insert(node_ptr);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::remove_node(\n\u002B  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_ptr)\n\u002B{\n\u002B  if (!node_ptr-\u003Eget_associated_with_executor_atomic().load()) {\n\u002B    throw std::runtime_error(\n\u002B            std::string(\u0022Node \u0027\u0022) \u002B node_ptr-\u003Eget_fully_qualified_name() \u002B\n\u002B            \u0022\u0027 needs to be associated with an executor.\u0022);\n\u002B  }\n\u002B\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  bool associated = weak_nodes_.count(node_ptr) != 0;\n\u002B  bool add_queued = pending_added_nodes_.count(node_ptr) != 0;\n\u002B  bool remove_queued = pending_removed_nodes_.count(node_ptr) != 0;\n\u002B\n\u002B  if (!(associated || add_queued) || remove_queued) {\n\u002B    throw std::runtime_error(\n\u002B            std::string(\u0022Node \u0027\u0022) \u002B node_ptr-\u003Eget_fully_qualified_name() \u002B\n\u002B            \u0022\u0027 needs to be associated with this executor.\u0022);\n\u002B  }\n\u002B\n\u002B  this-\u003Epending_removed_nodes_.insert(node_ptr);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::add_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr)\n\u002B{\n\u002B  std::atomic_bool \u0026 has_executor = group_ptr-\u003Eget_associated_with_executor_atomic();\n\u002B  if (has_executor.exchange(true)) {\n\u002B    throw std::runtime_error(\u0022Callback group has already been added to an executor.\u0022);\n\u002B  }\n\u002B\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  bool associated = manually_added_groups_.count(group_ptr) != 0;\n\u002B  bool add_queued = pending_manually_added_groups_.count(group_ptr) != 0;\n\u002B  bool remove_queued = pending_manually_removed_groups_.count(group_ptr) != 0;\n\u002B\n\u002B  if ((associated || add_queued) \u0026\u0026 !remove_queued) {\n\u002B    throw std::runtime_error(\u0022Callback group has already been added to this executor.\u0022);\n\u002B  }\n\u002B\n\u002B  this-\u003Epending_manually_added_groups_.insert(group_ptr);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::remove_callback_group(rclcpp::CallbackGroup::SharedPtr group_ptr)\n\u002B{\n\u002B  if (!group_ptr-\u003Eget_associated_with_executor_atomic().load()) {\n\u002B    throw std::runtime_error(\u0022Callback group needs to be associated with an executor.\u0022);\n\u002B  }\n\u002B  /**\n\u002B   * TODO(mjcarroll): The callback groups, being created by a node, should never outlive\n\u002B   * the node. Since we haven\u0027t historically enforced this, turning this on may cause\n\u002B   * previously-functional code to fail.\n\u002B   * Consider re-enablng this check (along with corresponding CallbackGroup::has_valid_node),\n\u002B   * when we can guarantee node/group lifetimes.\n\u002B  if (!group_ptr-\u003Ehas_valid_node()) {\n\u002B    throw std::runtime_error(\u0022Node must not be deleted before its callback group(s).\u0022);\n\u002B  }\n\u002B  */\n\u002B\n\u002B  auto weak_group_ptr = rclcpp::CallbackGroup::WeakPtr(group_ptr);\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  bool associated = manually_added_groups_.count(group_ptr) != 0;\n\u002B  bool add_queued = pending_manually_added_groups_.count(group_ptr) != 0;\n\u002B  bool remove_queued = pending_manually_removed_groups_.count(group_ptr) != 0;\n\u002B\n\u002B  if (!(associated || add_queued) || remove_queued) {\n\u002B    throw std::runtime_error(\u0022Callback group needs to be associated with this executor.\u0022);\n\u002B  }\n\u002B\n\u002B  this-\u003Epending_manually_removed_groups_.insert(group_ptr);\n\u002B}\n\u002B\n\u002Bstd::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002BExecutorEntitiesCollector::get_all_callback_groups() const\n\u002B{\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E groups;\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  for (const auto \u0026 group_ptr : manually_added_groups_) {\n\u002B    groups.push_back(group_ptr);\n\u002B  }\n\u002B  for (auto const \u0026 group_ptr : automatically_added_groups_) {\n\u002B    groups.push_back(group_ptr);\n\u002B  }\n\u002B  return groups;\n\u002B}\n\u002B\n\u002Bstd::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002BExecutorEntitiesCollector::get_manually_added_callback_groups() const\n\u002B{\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E groups;\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  for (const auto \u0026 group_ptr : manually_added_groups_) {\n\u002B    groups.push_back(group_ptr);\n\u002B  }\n\u002B  return groups;\n\u002B}\n\u002B\n\u002Bstd::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E\n\u002BExecutorEntitiesCollector::get_automatically_added_callback_groups() const\n\u002B{\n\u002B  std::vector\u003Crclcpp::CallbackGroup::WeakPtr\u003E groups;\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  for (auto const \u0026 group_ptr : automatically_added_groups_) {\n\u002B    groups.push_back(group_ptr);\n\u002B  }\n\u002B  return groups;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::update_collections()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n\u002B  this-\u003Eprocess_queues();\n\u002B  this-\u003Eadd_automatically_associated_callback_groups(this-\u003Eweak_nodes_);\n\u002B  this-\u003Eprune_invalid_nodes_and_groups();\n\u002B}\n\u002B\n\u002BExecutorEntitiesCollector::NodeCollection::iterator\n\u002BExecutorEntitiesCollector::remove_weak_node(NodeCollection::iterator weak_node)\n\u002B{\n\u002B  // Disassociate the guard condition from the executor notify waitable\n\u002B  auto guard_condition_it = weak_nodes_to_guard_conditions_.find(*weak_node);\n\u002B  if (guard_condition_it != weak_nodes_to_guard_conditions_.end()) {\n\u002B    this-\u003Enotify_waitable_-\u003Eremove_guard_condition(guard_condition_it-\u003Esecond);\n\u002B    weak_nodes_to_guard_conditions_.erase(guard_condition_it);\n\u002B  }\n\u002B\n\u002B  // Mark the node as disassociated (if the node is still valid)\n\u002B  auto node_ptr = weak_node-\u003Elock();\n\u002B  if (node_ptr) {\n\u002B    std::atomic_bool \u0026 has_executor = node_ptr-\u003Eget_associated_with_executor_atomic();\n\u002B    has_executor.store(false);\n\u002B  }\n\u002B\n\u002B  // Remove the node from tracked nodes\n\u002B  return weak_nodes_.erase(weak_node);\n\u002B}\n\u002B\n\u002BExecutorEntitiesCollector::CallbackGroupCollection::iterator\n\u002BExecutorEntitiesCollector::remove_weak_callback_group(\n\u002B  CallbackGroupCollection::iterator weak_group_it,\n\u002B  CallbackGroupCollection \u0026 collection\n\u002B)\n\u002B{\n\u002B  // Disassociate the guard condition from the executor notify waitable\n\u002B  auto guard_condition_it = weak_groups_to_guard_conditions_.find(*weak_group_it);\n\u002B  if (guard_condition_it != weak_groups_to_guard_conditions_.end()) {\n\u002B    this-\u003Enotify_waitable_-\u003Eremove_guard_condition(guard_condition_it-\u003Esecond);\n\u002B    weak_groups_to_guard_conditions_.erase(guard_condition_it);\n\u002B  }\n\u002B\n\u002B  // Mark the node as disassociated (if the group is still valid)\n\u002B  auto group_ptr = weak_group_it-\u003Elock();\n\u002B  if (group_ptr) {\n\u002B    /**\n\u002B     * TODO(mjcarroll): The callback groups, being created by a node, should never outlive\n\u002B     * the node. Since we haven\u0027t historically enforced this, turning this on may cause\n\u002B     * previously-functional code to fail.\n\u002B     * Consider re-enablng this check (along with corresponding CallbackGroup::has_valid_node),\n\u002B     * when we can guarantee node/group lifetimes.\n\u002B    if (!group_ptr-\u003Ehas_valid_node()) {\n\u002B      throw std::runtime_error(\u0022Node must not be deleted before its callback group(s).\u0022);\n\u002B    }\n\u002B    */\n\u002B    std::atomic_bool \u0026 has_executor = group_ptr-\u003Eget_associated_with_executor_atomic();\n\u002B    has_executor.store(false);\n\u002B  }\n\u002B\n\u002B  // Remove the node from tracked nodes\n\u002B  return collection.erase(weak_group_it);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::add_callback_group_to_collection(\n\u002B  rclcpp::CallbackGroup::SharedPtr group_ptr,\n\u002B  CallbackGroupCollection \u0026 collection)\n\u002B{\n\u002B  auto iter = collection.insert(group_ptr);\n\u002B  if (iter.second == false) {\n\u002B    throw std::runtime_error(\u0022Callback group has already been added to this executor.\u0022);\n\u002B  }\n\u002B\n\u002B  // Store node guard condition in map and add it to the notify waitable\n\u002B  auto group_guard_condition = group_ptr-\u003Eget_notify_guard_condition();\n\u002B  weak_groups_to_guard_conditions_.insert({group_ptr, group_guard_condition});\n\u002B  this-\u003Enotify_waitable_-\u003Eadd_guard_condition(group_guard_condition);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::process_queues()\n\u002B{\n\u002B  for (auto weak_node_ptr : pending_added_nodes_) {\n\u002B    auto node_ptr = weak_node_ptr.lock();\n\u002B    if (!node_ptr) {\n\u002B      continue;\n\u002B    }\n\u002B    weak_nodes_.insert(weak_node_ptr);\n\u002B    this-\u003Eadd_automatically_associated_callback_groups({weak_node_ptr});\n\u002B\n\u002B    // Store node guard condition in map and add it to the notify waitable\n\u002B    auto node_guard_condition = node_ptr-\u003Eget_shared_notify_guard_condition();\n\u002B    weak_nodes_to_guard_conditions_.insert({weak_node_ptr, node_guard_condition});\n\u002B    this-\u003Enotify_waitable_-\u003Eadd_guard_condition(node_guard_condition);\n\u002B  }\n\u002B  pending_added_nodes_.clear();\n\u002B\n\u002B  for (auto weak_node_ptr : pending_removed_nodes_) {\n\u002B    auto node_it = weak_nodes_.find(weak_node_ptr);\n\u002B    if (node_it != weak_nodes_.end()) {\n\u002B      remove_weak_node(node_it);\n\u002B    } else {\n\u002B      throw std::runtime_error(\u0022Node needs to be associated with this executor.\u0022);\n\u002B    }\n\u002B\n\u002B    auto node_ptr = weak_node_ptr.lock();\n\u002B    if (node_ptr) {\n\u002B      for (auto group_it = automatically_added_groups_.begin();\n\u002B        group_it != automatically_added_groups_.end(); )\n\u002B      {\n\u002B        auto group_ptr = group_it-\u003Elock();\n\u002B        if (node_ptr-\u003Ecallback_group_in_node(group_ptr)) {\n\u002B          group_it = remove_weak_callback_group(group_it, automatically_added_groups_);\n\u002B        } else {\n\u002B          \u002B\u002Bgroup_it;\n\u002B        }\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B  pending_removed_nodes_.clear();\n\u002B\n\u002B  for (auto weak_group_ptr : pending_manually_added_groups_) {\n\u002B    auto group_ptr = weak_group_ptr.lock();\n\u002B    if (group_ptr) {\n\u002B      this-\u003Eadd_callback_group_to_collection(group_ptr, manually_added_groups_);\n\u002B    }\n\u002B  }\n\u002B  pending_manually_added_groups_.clear();\n\u002B\n\u002B  for (auto weak_group_ptr : pending_manually_removed_groups_) {\n\u002B    auto group_ptr = weak_group_ptr.lock();\n\u002B    if (group_ptr) {\n\u002B      auto group_it = manually_added_groups_.find(group_ptr);\n\u002B      if (group_it != manually_added_groups_.end()) {\n\u002B        remove_weak_callback_group(group_it, manually_added_groups_);\n\u002B      } else {\n\u002B        throw std::runtime_error(\n\u002B                \u0022Attempting to remove a callback group not added to this executor.\u0022);\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B  pending_manually_removed_groups_.clear();\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::add_automatically_associated_callback_groups(\n\u002B  const NodeCollection \u0026 nodes_to_check)\n\u002B{\n\u002B  for (auto \u0026 weak_node : nodes_to_check) {\n\u002B    auto node = weak_node.lock();\n\u002B    if (node) {\n\u002B      node-\u003Efor_each_callback_group(\n\u002B        [this, node](rclcpp::CallbackGroup::SharedPtr group_ptr)\n\u002B        {\n\u002B          if (!group_ptr-\u003Eget_associated_with_executor_atomic().load() \u0026\u0026\n\u002B          group_ptr-\u003Eautomatically_add_to_executor_with_node())\n\u002B          {\n\u002B            std::atomic_bool \u0026 has_executor = group_ptr-\u003Eget_associated_with_executor_atomic();\n\u002B            if (has_executor.exchange(true)) {\n\u002B              throw std::runtime_error(\u0022Callback group has already been added to an executor.\u0022);\n\u002B            }\n\u002B            this-\u003Eadd_callback_group_to_collection(group_ptr, this-\u003Eautomatically_added_groups_);\n\u002B          }\n\u002B        });\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorEntitiesCollector::prune_invalid_nodes_and_groups()\n\u002B{\n\u002B  for (auto node_it = weak_nodes_.begin();\n\u002B    node_it != weak_nodes_.end(); )\n\u002B  {\n\u002B    if (node_it-\u003Eexpired()) {\n\u002B      node_it = remove_weak_node(node_it);\n\u002B    } else {\n\u002B      node_it\u002B\u002B;\n\u002B    }\n\u002B  }\n\u002B  for (auto group_it = automatically_added_groups_.begin();\n\u002B    group_it != automatically_added_groups_.end(); )\n\u002B  {\n\u002B    if (group_it-\u003Eexpired()) {\n\u002B      group_it = remove_weak_callback_group(group_it, automatically_added_groups_);\n\u002B    } else {\n\u002B      group_it\u002B\u002B;\n\u002B    }\n\u002B  }\n\u002B  for (auto group_it = manually_added_groups_.begin();\n\u002B    group_it != manually_added_groups_.end(); )\n\u002B  {\n\u002B    if (group_it-\u003Eexpired()) {\n\u002B      group_it = remove_weak_callback_group(group_it, manually_added_groups_);\n\u002B    } else {\n\u002B      group_it\u002B\u002B;\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\nnew file mode 100644\nindex 00000000..c0ad8a25\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/executor_notify_waitable.cpp\n@@ -0,0 \u002B1,129 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Ciostream\u003E\n\u002B\n\u002B#include \u0022rclcpp/exceptions.hpp\u0022\n\u002B#include \u0022rclcpp/executors/executor_notify_waitable.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bnamespace executors\n\u002B{\n\u002B\n\u002BExecutorNotifyWaitable::ExecutorNotifyWaitable(std::function\u003Cvoid(void)\u003E on_execute_callback)\n\u002B: execute_callback_(on_execute_callback)\n\u002B{\n\u002B}\n\u002B\n\u002BExecutorNotifyWaitable::ExecutorNotifyWaitable(const ExecutorNotifyWaitable \u0026 other)\n\u002B: ExecutorNotifyWaitable(other.execute_callback_)\n\u002B{\n\u002B  this-\u003Enotify_guard_conditions_ = other.notify_guard_conditions_;\n\u002B}\n\u002B\n\u002BExecutorNotifyWaitable \u0026 ExecutorNotifyWaitable::operator=(const ExecutorNotifyWaitable \u0026 other)\n\u002B{\n\u002B  if (this != \u0026other) {\n\u002B    this-\u003Eexecute_callback_ = other.execute_callback_;\n\u002B    this-\u003Enotify_guard_conditions_ = other.notify_guard_conditions_;\n\u002B  }\n\u002B  return *this;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorNotifyWaitable::add_to_wait_set(rcl_wait_set_t * wait_set)\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n\u002B\n\u002B  for (auto weak_guard_condition : this-\u003Enotify_guard_conditions_) {\n\u002B    auto guard_condition = weak_guard_condition.lock();\n\u002B    if (guard_condition) {\n\u002B      auto rcl_guard_condition = \u0026guard_condition-\u003Eget_rcl_guard_condition();\n\u002B\n\u002B      rcl_ret_t ret = rcl_wait_set_add_guard_condition(\n\u002B        wait_set,\n\u002B        rcl_guard_condition, NULL);\n\u002B\n\u002B      if (RCL_RET_OK != ret) {\n\u002B        rclcpp::exceptions::throw_from_rcl_error(\n\u002B          ret, \u0022failed to add guard condition to wait set\u0022);\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bbool\n\u002BExecutorNotifyWaitable::is_ready(rcl_wait_set_t * wait_set)\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n\u002B\n\u002B  bool any_ready = false;\n\u002B  for (size_t ii = 0; ii \u003C wait_set-\u003Esize_of_guard_conditions; \u002B\u002Bii) {\n\u002B    auto rcl_guard_condition = wait_set-\u003Eguard_conditions[ii];\n\u002B\n\u002B    if (nullptr == rcl_guard_condition) {\n\u002B      continue;\n\u002B    }\n\u002B    for (auto weak_guard_condition : this-\u003Enotify_guard_conditions_) {\n\u002B      auto guard_condition = weak_guard_condition.lock();\n\u002B      if (guard_condition \u0026\u0026 \u0026guard_condition-\u003Eget_rcl_guard_condition() == rcl_guard_condition) {\n\u002B        any_ready = true;\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B  return any_ready;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorNotifyWaitable::execute(std::shared_ptr\u003Cvoid\u003E \u0026 data)\n\u002B{\n\u002B  (void) data;\n\u002B  this-\u003Eexecute_callback_();\n\u002B}\n\u002B\n\u002Bstd::shared_ptr\u003Cvoid\u003E\n\u002BExecutorNotifyWaitable::take_data()\n\u002B{\n\u002B  return nullptr;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorNotifyWaitable::add_guard_condition(rclcpp::GuardCondition::WeakPtr weak_guard_condition)\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n\u002B  auto guard_condition = weak_guard_condition.lock();\n\u002B  if (guard_condition \u0026\u0026 notify_guard_conditions_.count(weak_guard_condition) == 0) {\n\u002B    notify_guard_conditions_.insert(weak_guard_condition);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002BExecutorNotifyWaitable::remove_guard_condition(rclcpp::GuardCondition::WeakPtr guard_condition)\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n\u002B  if (notify_guard_conditions_.count(guard_condition) != 0) {\n\u002B    notify_guard_conditions_.erase(guard_condition);\n\u002B  }\n\u002B}\n\u002B\n\u002Bsize_t\n\u002BExecutorNotifyWaitable::get_number_of_ready_guard_conditions()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(guard_condition_mutex_);\n\u002B  return notify_guard_conditions_.size();\n\u002B}\n\u002B\n\u002B}  // namespace executors\n\u002B}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\nindex bf50e062..6fd0b56a 100644\n--- rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/static_executor_entities_collector.cpp\n@@ -109,8 \u002B109,8 @@ StaticExecutorEntitiesCollector::execute(std::shared_ptr\u003Cvoid\u003E \u0026 data)\n   std::lock_guard\u003Cstd::mutex\u003E guard{new_nodes_mutex_};\n   for (const auto \u0026 weak_node : new_nodes_) {\n     if (auto node_ptr = weak_node.lock()) {\n-      const auto \u0026 gc = node_ptr-\u003Eget_notify_guard_condition();\n-      weak_nodes_to_guard_conditions_[node_ptr] = \u0026gc;\n\u002B      weak_nodes_to_guard_conditions_[node_ptr] =\n\u002B        node_ptr-\u003Eget_shared_notify_guard_condition().get();\n     }\n   }\n   new_nodes_.clear();\ndiff --git rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\nindex 209fcde5..3c14b37b 100644\n--- rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executors/static_single_threaded_executor.cpp\n@@ -139,7 \u002B139,7 @@ StaticSingleThreadedExecutor::add_callback_group(\n   bool is_new_node = entities_collector_-\u003Eadd_callback_group(group_ptr, node_ptr);\n   if (is_new_node \u0026\u0026 notify) {\n     // Interrupt waiting to handle new node\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   }\n }\n \n@@ -150,7 \u002B150,7 @@ StaticSingleThreadedExecutor::add_node(\n   bool is_new_node = entities_collector_-\u003Eadd_node(node_ptr);\n   if (is_new_node \u0026\u0026 notify) {\n     // Interrupt waiting to handle new node\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   }\n }\n \n@@ -167,7 \u002B167,7 @@ StaticSingleThreadedExecutor::remove_callback_group(\n   bool node_removed = entities_collector_-\u003Eremove_callback_group(group_ptr);\n   // If the node was matched and removed, interrupt waiting\n   if (node_removed \u0026\u0026 notify) {\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   }\n }\n \n@@ -181,7 \u002B181,7 @@ StaticSingleThreadedExecutor::remove_node(\n   }\n   // If the node was matched and removed, interrupt waiting\n   if (notify) {\n-    interrupt_guard_condition_.trigger();\n\u002B    interrupt_guard_condition_-\u003Etrigger();\n   }\n }\n \ndiff --git rclcpp/src/rclcpp/node_interfaces/node_base.cpp rclcpp/src/rclcpp/node_interfaces/node_base.cpp\nindex 89d8acf6..6544d692 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_base.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_base.cpp\n@@ -45,7 \u002B45,7 @@ NodeBase::NodeBase(\n   node_handle_(nullptr),\n   default_callback_group_(default_callback_group),\n   associated_with_executor_(false),\n-  notify_guard_condition_(context),\n\u002B  notify_guard_condition_(std::make_shared\u003Crclcpp::GuardCondition\u003E(context)),\n   notify_guard_condition_is_valid_(false)\n {\n   // Create the rcl node and store it in a shared_ptr with a custom destructor.\n@@ -132,8 \u002B132,10 @@ NodeBase::NodeBase(\n   // Create the default callback group, if needed.\n   if (nullptr == default_callback_group_) {\n     using rclcpp::CallbackGroupType;\n\u002B    // Default callback group is mutually exclusive and automatically associated with\n\u002B    // any executors that this node is added to.\n     default_callback_group_ =\n-      NodeBase::create_callback_group(CallbackGroupType::MutuallyExclusive);\n\u002B      NodeBase::create_callback_group(CallbackGroupType::MutuallyExclusive, true);\n   }\n \n   // Indicate the notify_guard_condition is now valid.\n@@ -202,11 \u002B204,27 @@ NodeBase::create_callback_group(\n   rclcpp::CallbackGroupType group_type,\n   bool automatically_add_to_executor_with_node)\n {\n\u002B  auto weak_context = this-\u003Eget_context()-\u003Eweak_from_this();\n\u002B  auto get_node_context = [weak_context]() -\u003E rclcpp::Context::SharedPtr {\n\u002B      return weak_context.lock();\n\u002B    };\n\u002B\n   auto group = std::make_shared\u003Crclcpp::CallbackGroup\u003E(\n     group_type,\n\u002B    get_node_context,\n     automatically_add_to_executor_with_node);\n   std::lock_guard\u003Cstd::mutex\u003E lock(callback_groups_mutex_);\n   callback_groups_.push_back(group);\n\u002B\n\u002B  // This guard condition is generally used to signal to this node\u0027s executor that a callback\n\u002B  // group has been added that should be considered for new entities.\n\u002B  // If this is creating the default callback group, then the notify guard condition won\u0027t be\n\u002B  // ready or needed yet, as the node is not done being constructed and therefore cannot be added.\n\u002B  // If the callback group is not automatically associated with this node\u0027s executors, then\n\u002B  // triggering the guard condition is also unnecessary, it will be manually added to an exector.\n\u002B  if (notify_guard_condition_is_valid_ \u0026\u0026 automatically_add_to_executor_with_node) {\n\u002B    this-\u003Etrigger_notify_guard_condition();\n\u002B  }\n   return group;\n }\n \n@@ -253,9 \u002B271,29 @@ NodeBase::get_notify_guard_condition()\n   if (!notify_guard_condition_is_valid_) {\n     throw std::runtime_error(\u0022failed to get notify guard condition because it is invalid\u0022);\n   }\n\u002B  return *notify_guard_condition_;\n\u002B}\n\u002B\n\u002Brclcpp::GuardCondition::SharedPtr\n\u002BNodeBase::get_shared_notify_guard_condition()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E notify_condition_lock(notify_guard_condition_mutex_);\n\u002B  if (!notify_guard_condition_is_valid_) {\n\u002B    return nullptr;\n\u002B  }\n   return notify_guard_condition_;\n }\n \n\u002Bvoid\n\u002BNodeBase::trigger_notify_guard_condition()\n\u002B{\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E notify_condition_lock(notify_guard_condition_mutex_);\n\u002B  if (!notify_guard_condition_is_valid_) {\n\u002B    throw std::runtime_error(\u0022failed to trigger notify guard condition because it is invalid\u0022);\n\u002B  }\n\u002B  notify_guard_condition_-\u003Etrigger();\n\u002B}\n\u002B\n bool\n NodeBase::get_use_intra_process_default() const\n {\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_graph.cpp rclcpp/src/rclcpp/node_interfaces/node_graph.cpp\nindex 6f6ed13b..1228703c 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_graph.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_graph.cpp\n@@ -533,9 \u002B533,8 @@ NodeGraph::notify_graph_change()\n     }\n   }\n   graph_cv_.notify_all();\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n             std::string(\u0022failed to notify wait set on graph change: \u0022) \u002B ex.what());\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_services.cpp rclcpp/src/rclcpp/node_interfaces/node_services.cpp\nindex 2f1afd32..e9c4a526 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_services.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_services.cpp\n@@ -42,9 \u002B42,8 @@ NodeServices::add_service(\n   group-\u003Eadd_service(service_base_ptr);\n \n   // Notify the executor that a new service was created using the parent Node.\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n@@ -69,9 \u002B68,8 @@ NodeServices::add_client(\n   group-\u003Eadd_client(client_base_ptr);\n \n   // Notify the executor that a new client was created using the parent Node.\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_timers.cpp rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\nindex d2e821a9..96097def 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_timers.cpp\n@@ -42,9 \u002B42,8 @@ NodeTimers::add_timer(\n   }\n   callback_group-\u003Eadd_timer(timer);\n \n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_topics.cpp rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\nindex 167a35f3..659129d6 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_topics.cpp\n@@ -70,9 \u002B70,8 @@ NodeTopics::add_publisher(\n   }\n \n   // Notify the executor that a new publisher was created using the parent Node.\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\n@@ -119,9 \u002B118,8 @@ NodeTopics::add_subscription(\n   }\n \n   // Notify the executor that a new subscription was created using the parent Node.\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     callback_group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\nindex 1d1fe2ce..02a9de82 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_waitables.cpp\n@@ -42,9 \u002B42,8 @@ NodeWaitables::add_waitable(\n   group-\u003Eadd_waitable(waitable_ptr);\n \n   // Notify the executor that a new waitable was created using the parent Node.\n-  auto \u0026 node_gc = node_base_-\u003Eget_notify_guard_condition();\n   try {\n-    node_gc.trigger();\n\u002B    node_base_-\u003Etrigger_notify_guard_condition();\n     group-\u003Etrigger_notify_guard_condition();\n   } catch (const rclcpp::exceptions::RCLError \u0026 ex) {\n     throw std::runtime_error(\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex d4da759c..ddb219b5 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -688,6 \u002B688,24 @@ if(TARGET test_static_executor_entities_collector)\n   target_link_libraries(test_static_executor_entities_collector ${PROJECT_NAME} mimick)\n endif()\n \n\u002Bament_add_gtest(test_entities_collector executors/test_entities_collector.cpp\n\u002B  APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022 TIMEOUT 120)\n\u002Bif(TARGET test_entities_collector)\n\u002B  ament_target_dependencies(test_entities_collector\n\u002B    \u0022rcl\u0022\n\u002B    \u0022test_msgs\u0022)\n\u002B  target_link_libraries(test_entities_collector ${PROJECT_NAME} mimick)\n\u002Bendif()\n\u002B\n\u002Bament_add_gtest(test_executor_notify_waitable executors/test_executor_notify_waitable.cpp\n\u002B  APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022 TIMEOUT 120)\n\u002Bif(TARGET test_executor_notify_waitable)\n\u002B  ament_target_dependencies(test_executor_notify_waitable\n\u002B    \u0022rcl\u0022\n\u002B    \u0022test_msgs\u0022)\n\u002B  target_link_libraries(test_executor_notify_waitable ${PROJECT_NAME} mimick)\n\u002Bendif()\n\u002B\n ament_add_gtest(test_guard_condition test_guard_condition.cpp\n   APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022)\n if(TARGET test_guard_condition)\ndiff --git rclcpp/test/rclcpp/executors/test_entities_collector.cpp rclcpp/test/rclcpp/executors/test_entities_collector.cpp\nnew file mode 100644\nindex 00000000..930dc68a\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_entities_collector.cpp\n@@ -0,0 \u002B1,320 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022rclcpp/executors/executor_notify_waitable.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022rclcpp/executors/executor_entities_collector.hpp\u0022\n\u002B\n\u002B#include \u0022../../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n\u002Bclass TestExecutorEntitiesCollector : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B\n\u002B    notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B    entities_collector = std::make_shared\u003Crclcpp::executors::ExecutorEntitiesCollector\u003E(\n\u002B      notify_waitable);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E notify_waitable;\n\u002B  std::shared_ptr\u003Crclcpp::executors::ExecutorEntitiesCollector\u003E entities_collector;\n\u002B};\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_remove_node) {\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // Add a node\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eadd_node(node1-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eupdate_collections());\n\u002B\n\u002B  // Remove a node\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eremove_node(node1-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eupdate_collections());\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_node_twice) {\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eadd_node(node1-\u003Eget_node_base_interface()));\n\u002B\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector-\u003Eadd_node(node1-\u003Eget_node_base_interface()),\n\u002B    std::runtime_error(\u0022Node \u0027/ns/node1\u0027 has already been added to an executor.\u0022));\n\u002B\n\u002B  EXPECT_NO_THROW(entities_collector-\u003Eupdate_collections());\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_associated_node) {\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // Simulate node being associated somewhere else\n\u002B  auto \u0026 has_executor = node1-\u003Eget_node_base_interface()-\u003Eget_associated_with_executor_atomic();\n\u002B  has_executor.store(true);\n\u002B\n\u002B  // Add an already-associated node\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector-\u003Eremove_node(node1-\u003Eget_node_base_interface()),\n\u002B    std::runtime_error(\u0022Node \u0027/ns/node1\u0027 needs to be associated with this executor.\u0022));\n\u002B\n\u002B  has_executor.store(false);\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, remove_unassociated_node) {\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // Add an already-associated node\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector-\u003Eremove_node(node1-\u003Eget_node_base_interface()),\n\u002B    std::runtime_error(\u0022Node \u0027/ns/node1\u0027 needs to be associated with an executor.\u0022));\n\u002B\n\u002B  // Simulate node being associated somewhere else\n\u002B  auto \u0026 has_executor = node1-\u003Eget_node_base_interface()-\u003Eget_associated_with_executor_atomic();\n\u002B  has_executor.store(true);\n\u002B\n\u002B  // Add an already-associated node\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector-\u003Eremove_node(node1-\u003Eget_node_base_interface()),\n\u002B    std::runtime_error(\u0022Node \u0027/ns/node1\u0027 needs to be associated with this executor.\u0022));\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_remove_node_before_update) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  auto node2 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // Add and remove nodes without running updatenode\n\u002B  EXPECT_NO_THROW(entities_collector.add_node(node1-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector.add_node(node2-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector.remove_node(node1-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector.remove_node(node2-\u003Eget_node_base_interface()));\n\u002B  EXPECT_NO_THROW(entities_collector.update_collections());\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_callback_group) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  // Add a callback group and update\n\u002B  entities_collector.add_callback_group(cb_group);\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  // Remove callback group and update\n\u002B  entities_collector.remove_callback_group(cb_group);\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_node_default_callback_group) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  entities_collector.add_node(node-\u003Eget_node_base_interface());\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 1u);\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_callback_group_after_add_node) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  entities_collector.add_node(node-\u003Eget_node_base_interface());\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 2u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 2u);\n\u002B\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector.add_callback_group(cb_group),\n\u002B    std::runtime_error(\u0022Callback group has already been added to an executor.\u0022));\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, add_callback_group_twice) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  entities_collector.add_callback_group(cb_group);\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  cb_group-\u003Eget_associated_with_executor_atomic().exchange(false);\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector.add_callback_group(cb_group),\n\u002B    std::runtime_error(\u0022Callback group has already been added to this executor.\u0022));\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, remove_callback_group_after_node) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  entities_collector.add_callback_group(cb_group);\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  node.reset();\n\u002B\n\u002B  /**\n\u002B   * TODO(mjcarroll): Assert this when we are enforcing that nodes must be destroyed\n\u002B   * after their created callback groups.\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector.remove_callback_group(cb_group),\n\u002B    std::runtime_error(\u0022Node must not be deleted before its callback group(s).\u0022));\n\u002B  */\n\u002B  EXPECT_NO_THROW(entities_collector.update_collections());\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, remove_callback_group_after_node2) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  entities_collector.add_callback_group(cb_group);\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 0u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  EXPECT_NO_THROW(entities_collector.remove_callback_group(cb_group));\n\u002B\n\u002B  node.reset();\n\u002B\n\u002B  /**\n\u002B   * TODO(mjcarroll): Assert this when we are enforcing that nodes must be destroyed\n\u002B   * after their created callback groups.\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector.remove_callback_group(cb_group),\n\u002B    std::runtime_error(\u0022Node must not be deleted before its callback group(s).\u0022));\n\u002B  */\n\u002B  EXPECT_NO_THROW(entities_collector.update_collections());\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, remove_callback_group_twice) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  entities_collector.add_callback_group(cb_group);\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  ASSERT_EQ(entities_collector.get_all_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_manually_added_callback_groups().size(), 1u);\n\u002B  ASSERT_EQ(entities_collector.get_automatically_added_callback_groups().size(), 0u);\n\u002B\n\u002B  entities_collector.remove_callback_group(cb_group);\n\u002B  entities_collector.update_collections();\n\u002B\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    entities_collector.remove_callback_group(cb_group),\n\u002B    std::runtime_error(\u0022Callback group needs to be associated with an executor.\u0022));\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorEntitiesCollector, remove_node_opposite_order) {\n\u002B  auto notify_waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B  auto entities_collector = rclcpp::executors::ExecutorEntitiesCollector(notify_waitable);\n\u002B\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  EXPECT_NO_THROW(entities_collector.add_node(node1-\u003Eget_node_base_interface()));\n\u002B\n\u002B  auto node2 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B  EXPECT_NO_THROW(entities_collector.add_node(node2-\u003Eget_node_base_interface()));\n\u002B\n\u002B  EXPECT_NO_THROW(entities_collector.remove_node(node2-\u003Eget_node_base_interface()));\n\u002B}\ndiff --git rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp\nnew file mode 100644\nindex 00000000..ab7f730a\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executor_notify_waitable.cpp\n@@ -0,0 \u002B1,97 @@\n\u002B// Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n\u002B\n\u002B#include \u0022rclcpp/executors/single_threaded_executor.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002B#include \u0022rcpputils/scope_exit.hpp\u0022\n\u002B\n\u002B#include \u0022rclcpp/executors/executor_notify_waitable.hpp\u0022\n\u002B\n\u002B#include \u0022../../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n\u002B\n\u002Bclass TestExecutorNotifyWaitable : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestExecutorNotifyWaitable, construct_destruct) {\n\u002B  {\n\u002B    auto waitable = std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E();\n\u002B    waitable.reset();\n\u002B  }\n\u002B  {\n\u002B    auto on_execute_callback = []() {};\n\u002B    auto waitable =\n\u002B      std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(on_execute_callback);\n\u002B    waitable.reset();\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorNotifyWaitable, add_remove_guard_conditions) {\n\u002B  auto on_execute_callback = []() {};\n\u002B  auto waitable =\n\u002B    std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(on_execute_callback);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n\u002B  auto notify_guard_condition =\n\u002B\n\u002B    node-\u003Eget_node_base_interface()-\u003Eget_shared_notify_guard_condition();\n\u002B  EXPECT_NO_THROW(waitable-\u003Eadd_guard_condition(notify_guard_condition));\n\u002B  EXPECT_NO_THROW(waitable-\u003Eremove_guard_condition(notify_guard_condition));\n\u002B}\n\u002B\n\u002BTEST_F(TestExecutorNotifyWaitable, wait) {\n\u002B  int on_execute_calls = 0;\n\u002B  auto on_execute_callback = [\u0026on_execute_calls]() {on_execute_calls\u002B\u002B;};\n\u002B\n\u002B  auto waitable =\n\u002B    std::make_shared\u003Crclcpp::executors::ExecutorNotifyWaitable\u003E(on_execute_callback);\n\u002B\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n\u002B  auto notify_guard_condition =\n\u002B    node-\u003Eget_node_base_interface()-\u003Eget_shared_notify_guard_condition();\n\u002B  EXPECT_NO_THROW(waitable-\u003Eadd_guard_condition(notify_guard_condition));\n\u002B\n\u002B  auto default_cbg = node-\u003Eget_node_base_interface()-\u003Eget_default_callback_group();\n\u002B  ASSERT_NE(nullptr, default_cbg-\u003Eget_notify_guard_condition());\n\u002B\n\u002B  auto waitables = node-\u003Eget_node_waitables_interface();\n\u002B  waitables-\u003Eadd_waitable(std::static_pointer_cast\u003Crclcpp::Waitable\u003E(waitable), default_cbg);\n\u002B\n\u002B  rclcpp::executors::SingleThreadedExecutor executor;\n\u002B  executor.add_node(node);\n\u002B  executor.spin_all(std::chrono::seconds(1));\n\u002B  EXPECT_EQ(1u, on_execute_calls);\n\u002B\n\u002B  // on_execute_callback doesn\u0027t change if the topology doesn\u0027t change\n\u002B  executor.spin_all(std::chrono::seconds(1));\n\u002B  EXPECT_EQ(1u, on_execute_calls);\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "9984197c292d6c5ae0e7661aaea245ffb0fea057",
    "RawMessage": "Omnibus fixes for running tests with Connext. (#2684)",
    "Changes": "diff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 55635ac5..90508c73 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -714,6 \u002B714,13 @@ TYPED_TEST(TestExecutors, notifyTwiceWhileSpinning)\n       sub1_msg_count\u002B\u002B;\n     });\n \n\u002B  // Wait for the subscription to be matched\n\u002B  size_t tries = 10000;\n\u002B  while (this-\u003Epublisher-\u003Eget_subscription_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(this-\u003Epublisher-\u003Eget_subscription_count(), 2);\n\u002B\n   // Publish a message and verify it\u0027s received\n   this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n   auto start = std::chrono::steady_clock::now();\n@@ -731,6 \u002B738,13 @@ TYPED_TEST(TestExecutors, notifyTwiceWhileSpinning)\n       sub2_msg_count\u002B\u002B;\n     });\n \n\u002B  // Wait for the subscription to be matched\n\u002B  tries = 10000;\n\u002B  while (this-\u003Epublisher-\u003Eget_subscription_count() \u003C 3 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(this-\u003Epublisher-\u003Eget_subscription_count(), 3);\n\u002B\n   // Publish a message and verify it\u0027s received by both subscriptions\n   this-\u003Epublisher-\u003Epublish(test_msgs::msg::Empty());\n   start = std::chrono::steady_clock::now();\ndiff --git rclcpp/test/rclcpp/test_client_common.cpp rclcpp/test/rclcpp/test_client_common.cpp\nindex 65475bd8..62aa2c05 100644\n--- rclcpp/test/rclcpp/test_client_common.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_client_common.cpp\n@@ -431,7 \u002B431,7 @@ TYPED_TEST(TestAllClientTypesWithServer, client_qos)\n \n   rclcpp::ServicesQoS qos_profile;\n   qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n\u002B  rclcpp::Duration duration(std::chrono::milliseconds(1));\n   qos_profile.deadline(duration);\n   qos_profile.lifespan(duration);\n   qos_profile.liveliness_lease_duration(duration);\ndiff --git rclcpp/test/rclcpp/test_generic_service.cpp rclcpp/test/rclcpp/test_generic_service.cpp\nindex 554fdf0c..dd75120c 100644\n--- rclcpp/test/rclcpp/test_generic_service.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_generic_service.cpp\n@@ -320,7 \u002B320,7 @@ TEST_F(TestGenericService, rcl_service_request_subscription_get_actual_qos_error\n TEST_F(TestGenericService, generic_service_qos) {\n   rclcpp::ServicesQoS qos_profile;\n   qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n\u002B  rclcpp::Duration duration(std::chrono::milliseconds(1));\n   qos_profile.deadline(duration);\n   qos_profile.lifespan(duration);\n   qos_profile.liveliness_lease_duration(duration);\ndiff --git rclcpp/test/rclcpp/test_service.cpp rclcpp/test/rclcpp/test_service.cpp\nindex c6b3d3ac..fc3756a0 100644\n--- rclcpp/test/rclcpp/test_service.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_service.cpp\n@@ -335,7 \u002B335,7 @@ TEST_F(TestService, rcl_service_request_subscription_get_actual_qos_error) {\n TEST_F(TestService, server_qos) {\n   rclcpp::ServicesQoS qos_profile;\n   qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n\u002B  rclcpp::Duration duration(std::chrono::milliseconds(1));\n   qos_profile.deadline(duration);\n   qos_profile.lifespan(duration);\n   qos_profile.liveliness_lease_duration(duration);\ndiff --git rclcpp/test/rclcpp/test_service_introspection.cpp rclcpp/test/rclcpp/test_service_introspection.cpp\nindex af60eec2..d037be3d 100644\n--- rclcpp/test/rclcpp/test_service_introspection.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_service_introspection.cpp\n@@ -92,9 \u002B92,16 @@ TEST_F(TestServiceIntrospection, service_introspection_nominal)\n   request-\u003Eset__int64_value(42);\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  size_t tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   auto future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -163,9 \u002B170,11 @@ TEST_F(TestServiceIntrospection, service_introspection_nominal)\n TEST_F(TestServiceIntrospection, service_introspection_enable_disable_events)\n {\n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 0);\n \n   auto request = std::make_shared\u003CBasicTypes::Request\u003E();\n   request-\u003Eset__bool_value(true);\n@@ -183,9 \u002B192,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_events)\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  size_t tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 1 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 1u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -200,9 \u002B216,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_events)\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_OFF);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 1 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 1u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -217,9 \u002B240,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_events)\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -235,9 \u002B265,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_events)\n TEST_F(TestServiceIntrospection, service_introspection_enable_disable_event_content)\n {\n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  size_t tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   auto request = std::make_shared\u003CBasicTypes::Request\u003E();\n   request-\u003Eset__bool_value(true);\n@@ -259,9 \u002B296,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_event_cont\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -292,9 \u002B336,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_event_cont\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_METADATA);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n@@ -325,9 \u002B376,16 @@ TEST_F(TestServiceIntrospection, service_introspection_enable_disable_event_cont\n   events.clear();\n \n   client-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n   service-\u003Econfigure_introspection(\n-    node-\u003Eget_clock(), rclcpp::SystemDefaultsQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B    node-\u003Eget_clock(), rclcpp::ServicesQoS(), RCL_SERVICE_INTROSPECTION_CONTENTS);\n\u002B\n\u002B  // Wait for the introspection to attach to our subscription\n\u002B  tries = 1000;\n\u002B  while (this-\u003Esub-\u003Eget_publisher_count() \u003C 2 \u0026\u0026 tries-- \u003E 0) {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\u002B  }\n\u002B  ASSERT_EQ(sub-\u003Eget_publisher_count(), 2u);\n \n   future = client-\u003Easync_send_request(request);\n   ASSERT_EQ(\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "f051028b255845d50f27743e931b99b5ec27b679",
    "RawMessage": "Fix one more instance of index.ros.org. (#49)",
    "Changes": "diff --git rmw_dds_common/QUALITY_DECLARATION.md rmw_dds_common/QUALITY_DECLARATION.md\nindex 3b8e525..7762a4f 100644\n--- rmw_dds_common/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_dds_common/QUALITY_DECLARATION.md\n@@ -97,7 \u002B97,7 @@ The tests aim to cover both typical usage and corner cases, but are quantified b\n \n ### Coverage [4.iii]\n \n-\u0060rmw_dds_common\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n\u002B\u0060rmw_dds_common\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#code-coverage), and opts to use branch coverage instead of line coverage.\n \n This includes:\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "343b29b617b163ad72b9fe3f6441dd4ed3d3af09",
    "RawMessage": "add impl pointer for ExecutorOptions (#2523)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex 33d21e1b..b1dbfec2 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -63,6 \u002B63,7 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/exceptions/exceptions.cpp\n   src/rclcpp/executable_list.cpp\n   src/rclcpp/executor.cpp\n\u002B  src/rclcpp/executor_options.cpp\n   src/rclcpp/executors.cpp\n   src/rclcpp/executors/executor_entities_collection.cpp\n   src/rclcpp/executors/executor_entities_collector.cpp\ndiff --git rclcpp/include/rclcpp/executor_options.hpp rclcpp/include/rclcpp/executor_options.hpp\nindex 066f29eb..a8fd5b73 100644\n--- rclcpp/include/rclcpp/executor_options.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor_options.hpp\n@@ -15,6 \u002B15,8 @@\n #ifndef RCLCPP__EXECUTOR_OPTIONS_HPP_\n #define RCLCPP__EXECUTOR_OPTIONS_HPP_\n \n\u002B#include \u003Cmemory\u003E\n\u002B\n #include \u0022rclcpp/context.hpp\u0022\n #include \u0022rclcpp/contexts/default_context.hpp\u0022\n #include \u0022rclcpp/memory_strategies.hpp\u0022\n@@ -24,18 \u002B26,30 @@\n namespace rclcpp\n {\n \n\u002Bclass ExecutorOptionsImplementation;\n\u002B\n /// Options to be passed to the executor constructor.\n struct ExecutorOptions\n {\n-  ExecutorOptions()\n-  : memory_strategy(rclcpp::memory_strategies::create_default_strategy()),\n-    context(rclcpp::contexts::get_global_default_context()),\n-    max_conditions(0)\n-  {}\n\u002B  RCLCPP_PUBLIC\n\u002B  ExecutorOptions();\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  virtual ~ExecutorOptions();\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  ExecutorOptions(const ExecutorOptions \u0026);\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  ExecutorOptions \u0026 operator=(const ExecutorOptions \u0026);\n \n   rclcpp::memory_strategy::MemoryStrategy::SharedPtr memory_strategy;\n   rclcpp::Context::SharedPtr context;\n   size_t max_conditions;\n\u002B\n\u002Bprivate:\n\u002B  /// Pointer to implementation\n\u002B  std::unique_ptr\u003CExecutorOptionsImplementation\u003E impl_;\n };\n \n }  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/executor_options.cpp rclcpp/src/rclcpp/executor_options.cpp\nnew file mode 100644\nindex 00000000..018d1261\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor_options.cpp\n@@ -0,0 \u002B1,55 @@\n\u002B// Copyright 2024 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022rclcpp/executor_options.hpp\u0022\n\u002B\n\u002Busing rclcpp::ExecutorOptions;\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002B\n\u002Bclass ExecutorOptionsImplementation {};\n\u002B\n\u002B}  // namespace rclcpp\n\u002B\n\u002BExecutorOptions::ExecutorOptions()\n\u002B: memory_strategy(rclcpp::memory_strategies::create_default_strategy()),\n\u002B  context(rclcpp::contexts::get_global_default_context()),\n\u002B  max_conditions(0),\n\u002B  impl_(nullptr)\n\u002B{}\n\u002B\n\u002BExecutorOptions::~ExecutorOptions()\n\u002B{}\n\u002B\n\u002BExecutorOptions::ExecutorOptions(const ExecutorOptions \u0026 other)\n\u002B{\n\u002B  *this = other;\n\u002B}\n\u002B\n\u002BExecutorOptions \u0026 ExecutorOptions::operator=(const ExecutorOptions \u0026 other)\n\u002B{\n\u002B  if (this == \u0026other) {\n\u002B    return *this;\n\u002B  }\n\u002B\n\u002B  this-\u003Ememory_strategy = other.memory_strategy;\n\u002B  this-\u003Econtext = other.context;\n\u002B  this-\u003Emax_conditions = other.max_conditions;\n\u002B  if (nullptr != other.impl_) {\n\u002B    this-\u003Eimpl_ = std::make_unique\u003CExecutorOptionsImplementation\u003E(*other.impl_);\n\u002B  }\n\u002B\n\u002B  return *this;\n\u002B}\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "17a5a7c2f62531266a08f78bd45b17718f190b86",
    "RawMessage": "Change index.ros.org -\u003E docs.ros.org links. (#317)",
    "Changes": "diff --git README.md README.md\nindex 6d55a58..1aa034b 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -2,7 \u002B2,7 @@\n \n **Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS 2. Make your **\u2261\u0192\u00C9\u00F3 run like a \u2261\u0192\u00DC\u00C7** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n \n-This package lets [*ROS 2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n\u002BThis package lets [*ROS 2*](https://docs.ros.org/en/rolling/) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS 2 experience. Let the Cyclone blow you away!\n \n 1. Install:\n@@ -45,23 \u002B45,23 @@ Here are some ways to generate additional debugging info that can help identify\n * Configure Cyclone to create richer debugging output:\n \n   * To see the output live:\n-    \n\u002B\n     \u0060export CYCLONEDDS_URI=\u0027\u003CTracing\u003E\u003CVerbosity\u003Etrace\u003C/\u003E\u003COut\u003Estderr\u003C/\u003E\u003C/\u003E\u0027\u0060\n \n   * To send to \u0060/var/log/\u0060:\n-    \n\u002B\n     \u0060export CYCLONEDDS_URI=\u0027\u003CTracing\u003E\u003CVerbosity\u003Etrace\u003C/\u003E\u003COut\u003E/var/log/cyclonedds.${CYCLONEDDS_PID}.log\u003C/\u003E\u003C/\u003E\u0027\u0060\n \n * Create a Wireshark capture:\n-  \n\u002B\n   \u0060wireshark -k -w wireshark.pcap.gz\u0060\n \n ## Building from source and contributing\n \n The following branches are actively maintained:\n \n-* \u0060master\u0060, which targets the upcoming ROS version, [*Foxy*](https://index.ros.org/doc/ros2/Releases/Release-Foxy-Fitzroy/).\n-* \u0060dashing-eloquent\u0060, which maintains compatibility with ROS releases [*Dashing*](https://index.ros.org/doc/ros2/Releases/Release-Dashing-Diademata/) and [*Eloquent*](https://index.ros.org/doc/ros2/Releases/Release-Eloquent-Elusor/)\n\u002B* \u0060master\u0060, which targets the upcoming ROS version, [*Foxy*](https://docs.ros.org/en/rolling/Releases/Release-Foxy-Fitzroy.html)\n\u002B* \u0060dashing-eloquent\u0060, which maintains compatibility with ROS releases [*Dashing*](https://docs.ros.org/en/rolling/Releases/Release-Dashing-Diademata.html) and [*Eloquent*](https://docs.ros.org/en/rolling/Releases/Release-Eloquent-Elusor.html)\n \n If building ROS 2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/master/ros2.repos)), you already have this package and Cyclone DDS:\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "126321d4a0dd212df810431cf2fba627c807d69a",
    "RawMessage": "Make sure to call rcl_arguments_fini at the end of the test.",
    "Changes": "diff --git rcl/test/rcl/test_node.cpp rcl/test/rcl/test_node.cpp\nindex 87817ca..a044110 100644\n--- rcl/test/rcl/test_node.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_node.cpp\n@@ -767,4 \u002B767,6 @@ TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_options_fai\n \n   rcl_node_options_t default_options = rcl_node_get_default_options();\n   EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_node_options_copy(\u0026default_options, \u0026prev_ini_options));\n\u002B\n\u002B  EXPECT_EQ(RCL_RET_OK, rcl_arguments_fini(\u0026prev_ini_options.arguments));\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "c767f0b4c446adf2922bb28546a3a8cdf9ca8b72",
    "RawMessage": "Add tests for declaring statically typed parameters when undeclared parameters are allowed (#1575)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex 1302b11b..6297c4eb 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -409,6 \u002B409,46 @@ TEST_F(TestNode, declare_parameter_with_no_initial_values) {\n   }\n }\n \n\u002BTEST_F(TestNode, declare_parameter_with_allow_undeclared_parameters) {\n\u002B  // test cases without initial values\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022test_declare_parameter_node\u0022_unq, \u0022/\u0022,\n\u002B    rclcpp::NodeOptions{}.allow_undeclared_parameters(true));\n\u002B  {\n\u002B    // declared parameters static typing is still enforced\n\u002B    auto param_name = \u0022parameter\u0022_unq;\n\u002B    auto value = node-\u003Edeclare_parameter(param_name, 5);\n\u002B    EXPECT_EQ(value, 5);\n\u002B    EXPECT_FALSE(node-\u003Eset_parameter({param_name, \u0022asd\u0022}).successful);\n\u002B    auto param = node-\u003Eget_parameter(param_name);\n\u002B    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(param.get_value\u003Cint64_t\u003E(), 5);\n\u002B  }\n\u002B  {\n\u002B    // not for automatically declared parameters\n\u002B    auto param_name = \u0022parameter\u0022_unq;\n\u002B    EXPECT_TRUE(node-\u003Eset_parameter({param_name, 5}).successful);\n\u002B    auto param = node-\u003Eget_parameter(param_name);\n\u002B    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(param.get_value\u003Cint64_t\u003E(), 5);\n\u002B    EXPECT_TRUE(node-\u003Eset_parameter({param_name, \u0022asd\u0022}).successful);\n\u002B    param = node-\u003Eget_parameter(param_name);\n\u002B    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_STRING);\n\u002B    EXPECT_EQ(param.get_value\u003Cstd::string\u003E(), \u0022asd\u0022);\n\u002B  }\n\u002B  {\n\u002B    // declare after set is invalid\n\u002B    auto param_name = \u0022parameter\u0022_unq;\n\u002B    EXPECT_TRUE(node-\u003Eset_parameter({param_name, 5}).successful);\n\u002B    auto param = node-\u003Eget_parameter(param_name);\n\u002B    EXPECT_EQ(param.get_type(), rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(param.get_value\u003Cint64_t\u003E(), 5);\n\u002B    EXPECT_THROW(\n\u002B      node-\u003Edeclare_parameter(param_name, 5),\n\u002B      rclcpp::exceptions::ParameterAlreadyDeclaredException);\n\u002B  }\n\u002B}\n\u002B\n auto get_fixed_on_parameter_set_callback(const std::string \u0026 name, bool successful)\n {\n   return\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "b659bb23fdf2150172b6d90b9275fffc5e88188c",
    "RawMessage": "Convert ActionServer to use C\u002B\u002B Classes (#766)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 7d1f80c..b1abfd7 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -155,6 \u002B155,7 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/_rclpy_pycapsule.cpp\n   src/rclpy/action_client.cpp\n   src/rclpy/action_goal_handle.cpp\n\u002B  src/rclpy/action_server.cpp\n   src/rclpy/client.cpp\n   src/rclpy/clock.cpp\n   src/rclpy/context.cpp\ndiff --git rclpy/rclpy/action/server.py rclpy/rclpy/action/server.py\nindex aa27f91..ef9ded1 100644\n--- rclpy/rclpy/action/server.py\n\u002B\u002B\u002B rclpy/rclpy/action/server.py\n@@ -110,7 \u002B110,7 @@ class ServerGoalHandle:\n             self._goal.update_goal_state(event)\n \n             # Publish state change\n-            _rclpy.rclpy_action_publish_status(self._action_server._handle)\n\u002B            self._action_server._handle.publish_status()\n \n             # If it\u0027s a terminal state, then also notify the action server\n             if not self._goal.is_active():\n@@ -140,8 \u002B140,7 @@ class ServerGoalHandle:\n             feedback_message.feedback = feedback\n \n             # Publish\n-            _rclpy.rclpy_action_publish_feedback(\n-                self._action_server._handle, feedback_message)\n\u002B            self._action_server._handle.publish_feedback(feedback_message)\n \n     def succeed(self):\n         self._update_state(_rclpy.GoalEvent.SUCCEED)\n@@ -239,7 \u002B238,7 @@ class ActionServer(Waitable):\n         self._node = node\n         self._action_type = action_type\n         with node.handle as node_capsule, node.get_clock().handle:\n-            self._handle = _rclpy.rclpy_action_create_server(\n\u002B            self._handle = _rclpy.ActionServer(\n                 node_capsule,\n                 node.get_clock().handle,\n                 action_type,\n@@ -268,7 \u002B267,7 @@ class ActionServer(Waitable):\n \n         # Check if goal ID is already being tracked by this action server\n         with self._lock:\n-            goal_id_exists = _rclpy.rclpy_action_server_goal_exists(self._handle, goal_info)\n\u002B            goal_id_exists = self._handle.goal_exists(goal_info)\n \n         accepted = False\n         if not goal_id_exists:\n@@ -299,11 \u002B298,7 @@ class ActionServer(Waitable):\n         response_msg = self._action_type.Impl.SendGoalService.Response()\n         response_msg.accepted = accepted\n         response_msg.stamp = goal_info.stamp\n-        _rclpy.rclpy_action_send_goal_response(\n-            self._handle,\n-            request_header,\n-            response_msg,\n-        )\n\u002B        self._handle.send_goal_response(request_header, response_msg)\n \n         if not accepted:\n             self._node.get_logger().debug(\u0027New goal rejected: {0}\u0027.format(goal_uuid.uuid))\n@@ -349,8 \u002B344,8 @@ class ActionServer(Waitable):\n \n         with self._lock:\n             # Get list of goals that are requested to be canceled\n-            cancel_response = _rclpy.rclpy_action_process_cancel_request(\n-                self._handle, cancel_request, self._action_type.Impl.CancelGoalService.Response)\n\u002B            cancel_response = self._handle.process_cancel_request(\n\u002B                cancel_request, self._action_type.Impl.CancelGoalService.Response)\n \n         for goal_info in cancel_response.goals_canceling:\n             goal_uuid = bytes(goal_info.goal_id.uuid)\n@@ -369,11 \u002B364,7 @@ class ActionServer(Waitable):\n                 # Remove from response\n                 cancel_response.goals_canceling.remove(goal_info)\n \n-        _rclpy.rclpy_action_send_cancel_response(\n-            self._handle,\n-            request_header,\n-            cancel_response,\n-        )\n\u002B        self._handle.send_cancel_response(request_header, cancel_response)\n \n     async def _execute_get_result_request(self, request_header_and_message):\n         request_header, result_request = request_header_and_message\n@@ -388,11 \u002B379,7 @@ class ActionServer(Waitable):\n                 \u0027Sending result response for unknown goal ID: {0}\u0027.format(goal_uuid))\n             result_response = self._action_type.Impl.GetResultService.Response()\n             result_response.status = GoalStatus.STATUS_UNKNOWN\n-            _rclpy.rclpy_action_send_result_response(\n-                self._handle,\n-                request_header,\n-                result_response,\n-            )\n\u002B            self._handle.send_result_response(request_header, result_response)\n             return\n \n         # There is an accepted goal matching the goal ID, register a callback to send the\n@@ -406,11 \u002B393,7 @@ class ActionServer(Waitable):\n             del self._goal_handles[goal_uuid]\n \n     def _send_result_response(self, request_header, future):\n-        _rclpy.rclpy_action_send_result_response(\n-            self._handle,\n-            request_header,\n-            future.result(),\n-        )\n\u002B        self._handle.send_result_response(request_header, future.result())\n \n     @property\n     def action_type(self):\n@@ -420,7 \u002B403,7 @@ class ActionServer(Waitable):\n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if one or more entities are ready in the wait set.\u0022\u0022\u0022\n         with self._lock:\n-            ready_entities = _rclpy.rclpy_action_wait_set_is_ready(self._handle, wait_set)\n\u002B            ready_entities = self._handle.is_ready(wait_set)\n         self._is_goal_request_ready = ready_entities[0]\n         self._is_cancel_request_ready = ready_entities[1]\n         self._is_result_request_ready = ready_entities[2]\n@@ -432,8 \u002B415,7 @@ class ActionServer(Waitable):\n         data = {}\n         if self._is_goal_request_ready:\n             with self._lock:\n-                taken_data = _rclpy.rclpy_action_take_goal_request(\n-                    self._handle,\n\u002B                taken_data = self._handle.take_goal_request(\n                     self._action_type.Impl.SendGoalService.Request,\n                 )\n                 # If take fails, then we get (None, None)\n@@ -442,8 \u002B424,7 @@ class ActionServer(Waitable):\n \n         if self._is_cancel_request_ready:\n             with self._lock:\n-                taken_data = _rclpy.rclpy_action_take_cancel_request(\n-                    self._handle,\n\u002B                taken_data = self._handle.take_cancel_request(\n                     self._action_type.Impl.CancelGoalService.Request,\n                 )\n                 # If take fails, then we get (None, None)\n@@ -452,8 \u002B433,7 @@ class ActionServer(Waitable):\n \n         if self._is_result_request_ready:\n             with self._lock:\n-                taken_data = _rclpy.rclpy_action_take_result_request(\n-                    self._handle,\n\u002B                taken_data = self._handle.take_result_request(\n                     self._action_type.Impl.GetResultService.Request,\n                 )\n                 # If take fails, then we get (None, None)\n@@ -462,10 \u002B442,7 @@ class ActionServer(Waitable):\n \n         if self._is_goal_expired:\n             with self._lock:\n-                data[\u0027expired\u0027] = _rclpy.rclpy_action_expire_goals(\n-                    self._handle,\n-                    len(self._goal_handles),\n-                )\n\u002B                data[\u0027expired\u0027] = self._handle.expire_goals(len(self._goal_handles))\n \n         return data\n \n@@ -490,7 \u002B467,7 @@ class ActionServer(Waitable):\n \n     def get_num_entities(self):\n         \u0022\u0022\u0022Return number of each type of entity used in the wait set.\u0022\u0022\u0022\n-        num_entities = _rclpy.rclpy_action_wait_set_get_num_entities(self._handle)\n\u002B        num_entities = self._handle.get_num_entities()\n         return NumberOfEntities(\n             num_entities[0],\n             num_entities[1],\n@@ -501,7 \u002B478,7 @@ class ActionServer(Waitable):\n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n         with self._lock:\n-            _rclpy.rclpy_action_wait_set_add(self._handle, wait_set)\n\u002B            self._handle.add_to_waitset(wait_set)\n     # End Waitable API\n \n     def notify_execute(self, goal_handle, execute_callback):\n@@ -516,7 \u002B493,7 @@ class ActionServer(Waitable):\n \n     def notify_goal_done(self):\n         with self._lock:\n-            _rclpy.rclpy_action_notify_goal_done(self._handle)\n\u002B            self._handle.notify_goal_done()\n \n     def register_handle_accepted_callback(self, handle_accepted_callback):\n         \u0022\u0022\u0022\n@@ -604,8 \u002B581,7 @@ class ActionServer(Waitable):\n         for goal_handle in self._goal_handles.values():\n             goal_handle.destroy()\n \n-        with self._node.handle as node_capsule:\n-            _rclpy.rclpy_action_destroy_entity(self._handle, node_capsule)\n\u002B        self._handle.destroy_when_not_in_use()\n         self._node.remove_waitable(self)\n         self._handle = None\n \ndiff --git rclpy/src/rclpy/_rclpy_action.cpp rclpy/src/rclpy/_rclpy_action.cpp\nindex 2f55d18..8b51219 100644\n--- rclpy/src/rclpy/_rclpy_action.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_action.cpp\n@@ -28,6 \u002B28,7 @@\n \n #include \u0022action_client.hpp\u0022\n #include \u0022action_goal_handle.hpp\u0022\n\u002B#include \u0022action_server.hpp\u0022\n #include \u0022clock.hpp\u0022\n \n namespace py = pybind11;\n@@ -49,45 \u002B50,6 @@ get_pointer(py::capsule \u0026 capsule, const char * name)\n   return static_cast\u003CT\u003E(capsule);\n }\n \n-\n-/// Destroy an rcl_action entity.\n-/**\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyentity Capsule pointing to the entity to destroy.\n- * \\param[in] pynode Capsule pointing to the node the action client was added to.\n- */\n-void\n-rclpy_action_destroy_entity(py::capsule pyentity, py::capsule pynode)\n-{\n-  rcl_node_t * node = static_cast\u003Crcl_node_t *\u003E(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_ret_t ret;\n-  if (0 == std::strcmp(\u0022rcl_action_server_t\u0022, pyentity.name())) {\n-    auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyentity, \u0022rcl_action_server_t\u0022);\n-    ret = rcl_action_server_fini(action_server, node);\n-    PyMem_Free(action_server);\n-  } else {\n-    std::string entity_name = pyentity.name();\n-    throw std::runtime_error(entity_name \u002B \u0022 is not a known entity\u0022);\n-  }\n-\n-  if (ret != RCL_RET_OK) {\n-    std::string error_text = \u0022Failed to fini \u0027\u0022;\n-    error_text \u002B= pyentity.name();\n-    error_text \u002B= \u0022\u0027\u0022;\n-    throw rclpy::RCLError(error_text);\n-  }\n-\n-  if (PyCapsule_SetName(pyentity.ptr(), \u0022_destroyed_by_rclpy_action_destroy_entity_\u0022)) {\n-    throw py::error_already_set();\n-  }\n-}\n-\n /// Fetch a predefined qos_profile from rcl_action and convert it to a Python QoSProfile object.\n /**\n  * Raises RuntimeError if the QoS profile is unknown.\n@@ -111,697 \u002B73,6 @@ rclpy_action_get_rmw_qos_profile(const char * rmw_profile)\n   return py::reinterpret_steal\u003Cpy::dict\u003E(pyqos_profile);\n }\n \n-/// Add an action entitiy to a wait set.\n-/**\n- * Raises RuntimeError on failure.\n- * \\param[in] pyentity Capsule pointer to an action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n- */\n-void\n-rclpy_action_wait_set_add(py::capsule pyentity, py::capsule pywait_set)\n-{\n-  auto wait_set = get_pointer\u003Crcl_wait_set_t *\u003E(pywait_set, \u0022rcl_wait_set_t\u0022);\n-\n-  rcl_ret_t ret;\n-  if (0 == strcmp(pyentity.name(), \u0022rcl_action_server_t\u0022)) {\n-    auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyentity, \u0022rcl_action_server_t\u0022);\n-    ret = rcl_action_wait_set_add_action_server(wait_set, action_server, NULL);\n-  } else {\n-    std::string error_text{\u0022Unknown entity: \u0022};\n-    error_text \u002B= pyentity.name();\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\u0022Failed to add \u0027\u0022};\n-    error_text \u002B= pyentity.name();\n-    error_text \u002B= \u0022\u0027 to wait set\u0022;\n-    throw rclpy::RCLError(error_text);\n-  }\n-}\n-\n-/// Get the number of wait set entities that make up an action entity.\n-/**\n- * \\param[in] pyentity Capsule pointer to an action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\return Tuple containing the number of wait set entities:\n- *   (num_subscriptions,\n- *    num_guard_conditions,\n- *    num_timers,\n- *    num_clients,\n- *    num_services)\n- */\n-py::tuple\n-rclpy_action_wait_set_get_num_entities(py::capsule pyentity)\n-{\n-  size_t num_subscriptions = 0u;\n-  size_t num_guard_conditions = 0u;\n-  size_t num_timers = 0u;\n-  size_t num_clients = 0u;\n-  size_t num_services = 0u;\n-\n-  rcl_ret_t ret;\n-  if (0 == strcmp(pyentity.name(), \u0022rcl_action_server_t\u0022)) {\n-    auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyentity, \u0022rcl_action_server_t\u0022);\n-\n-    ret = rcl_action_server_wait_set_get_num_entities(\n-      action_server,\n-      \u0026num_subscriptions,\n-      \u0026num_guard_conditions,\n-      \u0026num_timers,\n-      \u0026num_clients,\n-      \u0026num_services);\n-  } else {\n-    std::string error_text{\u0022Unknown entity: \u0022};\n-    error_text \u002B= pyentity.name();\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\u0022Failed to get number of entities for \u0027\u0022};\n-    error_text \u002B= pyentity.name();\n-    error_text \u002B= \u0022\u0027\u0022;\n-    throw rclpy::RCLError(error_text);\n-  }\n-\n-  py::tuple result_tuple(5);\n-  result_tuple[0] = py::int_(num_subscriptions);\n-  result_tuple[1] = py::int_(num_guard_conditions);\n-  result_tuple[2] = py::int_(num_timers);\n-  result_tuple[3] = py::int_(num_clients);\n-  result_tuple[4] = py::int_(num_services);\n-  return result_tuple;\n-}\n-\n-/// Check if an action entity has any ready wait set entities.\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] entity Capsule pointing to the action entity\n- *   (rcl_action_client_t or rcl_action_server_t).\n- * \\param[in] pywait_set Capsule pointing to the wait set structure.\n- * \\return A tuple of Bool representing the ready sub-entities.\n- *     For a rcl_action_client_t:\n- *       (is_feedback_ready,\n- *        is_status_ready,\n- *        is_goal_response_ready,\n- *        is_cancel_response_ready,\n- *        is_result_response_ready)\n- *\n- *     For a rcl_action_server_t:\n- *       (is_goal_request_ready,\n- *        is_cancel_request_ready,\n- *        is_result_request_ready,\n- *        is_goal_expired)\n- */\n-py::tuple\n-rclpy_action_wait_set_is_ready(py::capsule pyentity, py::capsule pywait_set)\n-{\n-  auto wait_set = get_pointer\u003Crcl_wait_set_t *\u003E(pywait_set, \u0022rcl_wait_set_t\u0022);\n-\n-  if (0 == strcmp(pyentity.name(), \u0022rcl_action_client_t\u0022)) {\n-    auto action_client = get_pointer\u003Crcl_action_client_t *\u003E(pyentity, \u0022rcl_action_client_t\u0022);\n-    bool is_feedback_ready = false;\n-    bool is_status_ready = false;\n-    bool is_goal_response_ready = false;\n-    bool is_cancel_response_ready = false;\n-    bool is_result_response_ready = false;\n-    rcl_ret_t ret = rcl_action_client_wait_set_get_entities_ready(\n-      wait_set,\n-      action_client,\n-      \u0026is_feedback_ready,\n-      \u0026is_status_ready,\n-      \u0026is_goal_response_ready,\n-      \u0026is_cancel_response_ready,\n-      \u0026is_result_response_ready);\n-    if (RCL_RET_OK != ret) {\n-      throw rclpy::RCLError(\u0022Failed to get number of ready entities for action client\u0022);\n-    }\n-\n-    py::tuple result_tuple(5);\n-    result_tuple[0] = py::bool_(is_feedback_ready);\n-    result_tuple[1] = py::bool_(is_status_ready);\n-    result_tuple[2] = py::bool_(is_goal_response_ready);\n-    result_tuple[3] = py::bool_(is_cancel_response_ready);\n-    result_tuple[4] = py::bool_(is_result_response_ready);\n-    return result_tuple;\n-  } else if (0 == strcmp(pyentity.name(), \u0022rcl_action_server_t\u0022)) {\n-    auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyentity, \u0022rcl_action_server_t\u0022);\n-    bool is_goal_request_ready = false;\n-    bool is_cancel_request_ready = false;\n-    bool is_result_request_ready = false;\n-    bool is_goal_expired = false;\n-    rcl_ret_t ret = rcl_action_server_wait_set_get_entities_ready(\n-      wait_set,\n-      action_server,\n-      \u0026is_goal_request_ready,\n-      \u0026is_cancel_request_ready,\n-      \u0026is_result_request_ready,\n-      \u0026is_goal_expired);\n-    if (RCL_RET_OK != ret) {\n-      throw rclpy::RCLError(\u0022Failed to get number of ready entities for action server\u0022);\n-    }\n-\n-    py::tuple result_tuple(4);\n-    result_tuple[0] = py::bool_(is_goal_request_ready);\n-    result_tuple[1] = py::bool_(is_cancel_request_ready);\n-    result_tuple[2] = py::bool_(is_result_request_ready);\n-    result_tuple[3] = py::bool_(is_goal_expired);\n-    return result_tuple;\n-  }\n-\n-  std::string error_text{\u0022Unknown entity: \u0022};\n-  error_text \u002B= pyentity.name();\n-  throw std::runtime_error(error_text);\n-}\n-\n-/// Create an action client.\n-/**\n- * This function will create an action client for the given action name.\n- * This client will use the typesupport defined in the action module\n- * provided as pyaction_type to send messages over the wire.\n- *\n- * On a successful call a capsule referencing the created rcl_action_client_t structure\n- * is returned.\n- *\n- * Raises ValueError if action name is invalid\n- * Raises RuntimeError if the action client could not be created.\n- *\n- * \\remark Call rclpy_action_destroy_entity() to destroy an action client.\n- * \\param[in] pynode Capsule pointing to the node to add the action client to.\n- * \\param[in] pyaction_type Action module associated with the action client.\n- * \\param[in] pyaction_name Python object containing the action name.\n- * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n- * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n- * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n- * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n- * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n- * \\return Capsule named \u0027rcl_action_client_t\u0027, or\n- * \\return NULL on failure.\n- */\n-py::capsule\n-rclpy_action_create_client(\n-  py::capsule pynode,\n-  py::object pyaction_type,\n-  const char * action_name,\n-  const rmw_qos_profile_t \u0026 goal_service_qos,\n-  const rmw_qos_profile_t \u0026 result_service_qos,\n-  const rmw_qos_profile_t \u0026 cancel_service_qos,\n-  const rmw_qos_profile_t \u0026 feedback_topic_qos,\n-  const rmw_qos_profile_t \u0026 status_topic_qos)\n-{\n-  rcl_node_t * node = static_cast\u003Crcl_node_t *\u003E(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rosidl_action_type_support_t * ts =\n-    static_cast\u003Crosidl_action_type_support_t *\u003E(rclpy_common_get_type_support(\n-      pyaction_type.ptr()));\n-  if (!ts) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_action_client_options_t action_client_ops = rcl_action_client_get_default_options();\n-\n-  action_client_ops.goal_service_qos = goal_service_qos;\n-  action_client_ops.result_service_qos = result_service_qos;\n-  action_client_ops.cancel_service_qos = cancel_service_qos;\n-  action_client_ops.feedback_topic_qos = feedback_topic_qos;\n-  action_client_ops.status_topic_qos = status_topic_qos;\n-\n-  auto deleter = [](rcl_action_client_t * ptr) {PyMem_Free(ptr);};\n-  auto action_client = std::unique_ptr\u003Crcl_action_client_t, decltype(deleter)\u003E(\n-    static_cast\u003Crcl_action_client_t *\u003E(PyMem_Malloc(sizeof(rcl_action_client_t))),\n-    deleter);\n-  if (!action_client) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *action_client = rcl_action_get_zero_initialized_client();\n-  rcl_ret_t ret = rcl_action_client_init(\n-    action_client.get(),\n-    node,\n-    ts,\n-    action_name,\n-    \u0026action_client_ops);\n-  if (ret == RCL_RET_ACTION_NAME_INVALID) {\n-    std::string error_text{\u0022Failed to create action client due to invalid topic name \u0027\u0022};\n-    error_text \u002B= action_name;\n-    error_text \u002B= \u0022\u0027 : \u0022;\n-    error_text \u002B= rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  } else if (ret != RCL_RET_OK) {\n-    std::string error_text{\u0022Failed to create action client: \u0022};\n-    error_text \u002B= rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  }\n-\n-  return py::capsule(action_client.release(), \u0022rcl_action_client_t\u0022);\n-}\n-\n-/// Create an action server.\n-/**\n- * This function will create an action server for the given action name.\n- * This server will use the typesupport defined in the action module\n- * provided as pyaction_type to send messages over the wire.\n- *\n- * On a successful call a capsule referencing the created rcl_action_server_t structure\n- * is returned.\n- *\n- * Raises AttributeError if action type is invalid\n- * Raises ValueError if action name is invalid\n- * Raises RuntimeError if the action server could not be created.\n- *\n- * \\remark Call rclpy_action_destroy_entity() to destroy an action server.\n- * \\param[in] pynode Capsule pointing to the node to add the action server to.\n- * \\param[in] pyaction_type Action module associated with the action server.\n- * \\param[in] pyaction_name Python object containing the action name.\n- * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n- * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n- * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n- * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n- * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n- * \\return Capsule named \u0027rcl_action_server_t\u0027, or\n- * \\return NULL on failure.\n- */\n-py::capsule\n-rclpy_action_create_server(\n-  py::capsule pynode,\n-  const rclpy::Clock \u0026 rclpy_clock,\n-  py::object pyaction_type,\n-  const char * action_name,\n-  const rmw_qos_profile_t \u0026 goal_service_qos,\n-  const rmw_qos_profile_t \u0026 result_service_qos,\n-  const rmw_qos_profile_t \u0026 cancel_service_qos,\n-  const rmw_qos_profile_t \u0026 feedback_topic_qos,\n-  const rmw_qos_profile_t \u0026 status_topic_qos,\n-  double result_timeout)\n-{\n-  rcl_node_t * node = static_cast\u003Crcl_node_t *\u003E(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_clock_t * clock = rclpy_clock.rcl_ptr();\n-\n-  rosidl_action_type_support_t * ts = static_cast\u003Crosidl_action_type_support_t *\u003E(\n-    rclpy_common_get_type_support(pyaction_type.ptr()));\n-  if (!ts) {\n-    throw py::error_already_set();\n-  }\n-\n-  rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();\n-\n-  action_server_ops.goal_service_qos = goal_service_qos;\n-  action_server_ops.result_service_qos = result_service_qos;\n-  action_server_ops.cancel_service_qos = cancel_service_qos;\n-  action_server_ops.feedback_topic_qos = feedback_topic_qos;\n-  action_server_ops.status_topic_qos = status_topic_qos;\n-  action_server_ops.result_timeout.nanoseconds = (rcl_duration_value_t)RCL_S_TO_NS(result_timeout);\n-\n-  auto deleter = [](rcl_action_server_t * ptr) {PyMem_Free(ptr);};\n-  auto action_server = std::unique_ptr\u003Crcl_action_server_t, decltype(deleter)\u003E(\n-    static_cast\u003Crcl_action_server_t *\u003E(PyMem_Malloc(sizeof(rcl_action_server_t))),\n-    deleter);\n-  if (!action_server) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *action_server = rcl_action_get_zero_initialized_server();\n-  rcl_ret_t ret = rcl_action_server_init(\n-    action_server.get(),\n-    node,\n-    clock,\n-    ts,\n-    action_name,\n-    \u0026action_server_ops);\n-  if (ret == RCL_RET_ACTION_NAME_INVALID) {\n-    std::string error_text{\u0022Failed to create action server due to invalid topic name \u0027\u0022};\n-    error_text \u002B= action_name;\n-    error_text \u002B= \u0022\u0027 : \u0022;\n-    error_text \u002B= rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  } else if (ret != RCL_RET_OK) {\n-    std::string error_text{\u0022Failed to create action server: \u0022};\n-    error_text \u002B= rcl_get_error_string().str;\n-    rcl_reset_error();\n-    throw py::value_error(error_text);\n-  }\n-\n-  return py::capsule(action_server.release(), \u0022rcl_action_server_t\u0022);\n-}\n-\n-\n-/// Check if an action server is available for the given action client.\n-/**\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pynode Capsule pointing to the node to associated with the action client.\n- * \\param[in] pyaction_client The action client to use when checking for an available server.\n- * \\return True if an action server is available, False otherwise.\n- */\n-bool\n-rclpy_action_server_is_available(py::capsule pynode, py::capsule pyaction_client)\n-{\n-  rcl_node_t * node = static_cast\u003Crcl_node_t *\u003E(\n-    rclpy_handle_get_pointer_from_capsule(pynode.ptr(), \u0022rcl_node_t\u0022));\n-  if (!node) {\n-    throw py::error_already_set();\n-  }\n-\n-  auto action_client = get_pointer\u003Crcl_action_client_t *\u003E(pyaction_client, \u0022rcl_action_client_t\u0022);\n-\n-  bool is_available = false;\n-  rcl_ret_t ret = rcl_action_server_is_available(node, action_client, \u0026is_available);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed to check if action server is available\u0022);\n-  }\n-  return is_available;\n-}\n-\n-#define SEND_SERVICE_RESPONSE(Type) \\\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022); \\\n-  destroy_ros_message_signature * destroy_ros_message = NULL; \\\n-  void * raw_ros_response = rclpy_convert_from_py(pyresponse.ptr(), \u0026destroy_ros_message); \\\n-  if (!raw_ros_response) { \\\n-    throw py::error_already_set(); \\\n-  } \\\n-  rcl_ret_t ret = rcl_action_send_ ## Type ## _response(action_server, header, raw_ros_response); \\\n-  destroy_ros_message(raw_ros_response); \\\n-  if (ret != RCL_RET_OK) { \\\n-    throw rclpy::RCLError(\u0022Failed to send \u0022 #Type \u0022 response\u0022); \\\n-  }\n-\n-#define TAKE_SERVICE_REQUEST(Type) \\\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022); \\\n-  destroy_ros_message_signature * destroy_ros_message = NULL; \\\n-  /* taken_msg is always destroyed in this function */ \\\n-  void * taken_msg = rclpy_create_from_py(pymsg_type.ptr(), \u0026destroy_ros_message); \\\n-  if (!taken_msg) { \\\n-    throw py::error_already_set(); \\\n-  } \\\n-  auto taken_msg_ptr = \\\n-    std::unique_ptr\u003Cvoid, destroy_ros_message_signature *\u003E(taken_msg, destroy_ros_message); \\\n-  rmw_request_id_t header; \\\n-  rcl_ret_t ret = \\\n-    rcl_action_take_ ## Type ## _request(action_server, \u0026header, taken_msg_ptr.get()); \\\n-  /* Create the tuple to return */ \\\n-  py::tuple pytuple(2); \\\n-  if (ret == RCL_RET_ACTION_CLIENT_TAKE_FAILED || ret == RCL_RET_ACTION_SERVER_TAKE_FAILED) { \\\n-    pytuple[0] = py::none(); \\\n-    pytuple[1] = py::none(); \\\n-    return pytuple; \\\n-  } else if (ret != RCL_RET_OK) { \\\n-    throw rclpy::RCLError(\u0022Failed to take \u0022 #Type); \\\n-  } \\\n-  pytuple[0] = header; \\\n-  pytuple[1] = py::reinterpret_steal\u003Cpy::object\u003E( \\\n-    rclpy_convert_to_py(taken_msg_ptr.get(), pymsg_type.ptr())); \\\n-  return pytuple;\n-\n-/// Take an action goal request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pygoal_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pygoal_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \u0022rclpy.rmw_request_id_t\u0022 type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_goal_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(goal)\n-}\n-\n-/// Send an action goal response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pygoal_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] header Pointer to the message header.\n- * \\param[in] pygoal_response The response message to send.\n- * \\return None\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_goal_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(goal)\n-}\n-\n-/// Take an action result request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyresult_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pyresult_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \u0022rclpy.rmw_request_id_t\u0022 type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_result_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(result)\n-}\n-\n-/// Send an action result response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyresult_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] pyheader Pointer to the message header.\n- * \\param[in] pyresult_response The response message to send.\n- * \\return None\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_result_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(result)\n-}\n-\n-/// Take an action cancel request.\n-/**\n- * Raises AttributeError if there is an issue parsing the pycancel_request_type.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when taking the request.\n- * \\param[in] pycancel_request_type An instance of the type of request message to take.\n- * \\return 2-tuple (header, received request message) where the header is an\n- *   \u0022rmw_request_id_t\u0022 type, or\n- * \\return 2-tuple (None, None) if there as no message to take, or\n- * \\return NULL if there is a failure.\n- */\n-py::tuple\n-rclpy_action_take_cancel_request(py::capsule pyaction_server, py::object pymsg_type)\n-{\n-  TAKE_SERVICE_REQUEST(cancel)\n-}\n-\n-/// Send an action cancel response.\n-/**\n- * Raises AttributeError if there is an issue parsing the pycancel_response.\n- * Raises RuntimeError on failure.\n- *\n- * \\param[in] pyaction_server The action server to use when sending the response.\n- * \\param[in] pyheader Pointer to the message header.\n- * \\param[in] pycancel_response The response message to send.\n- * \\return sequence_number PyLong object representing the index of the sent response, or\n- * \\return NULL if there is a failure.\n- */\n-void\n-rclpy_action_send_cancel_response(\n-  py::capsule pyaction_server, rmw_request_id_t * header, py::object pyresponse)\n-{\n-  SEND_SERVICE_RESPONSE(cancel)\n-}\n-\n-\n-/// Publish a feedback message from a given action server.\n-/**\n- * Raises AttributeError if there is an issue parsing the pyfeedback_msg.\n- * Raises RuntimeError on failure while publishing a feedback message.\n- *\n- * \\param[in] pyaction_server Capsule pointing to the action server to publish the message.\n- * \\param[in] pyfeedback_msg The feedback message to publish.\n- * \\return None\n- */\n-void\n-rclpy_action_publish_feedback(py::capsule pyaction_server, py::object pymsg)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  void * raw_ros_message = rclpy_convert_from_py(pymsg.ptr(), \u0026destroy_ros_message);\n-  if (!raw_ros_message) {\n-    throw py::error_already_set();\n-  }\n-  auto raw_ros_message_ptr = std::unique_ptr\u003Cvoid, decltype(destroy_ros_message)\u003E(\n-    raw_ros_message, destroy_ros_message);\n-  rcl_ret_t ret = rcl_action_publish_feedback(action_server, raw_ros_message);\n-  if (ret != RCL_RET_OK) {\n-    throw rclpy::RCLError(\u0022Failed to publish feedback with an action server\u0022);\n-  }\n-}\n-\n-/// Publish a status message from a given action server.\n-/**\n- * Raises RuntimeError on failure while publishing a status message.\n- *\n- * \\param[in] pyaction_server Capsule pointing to the action server to publish the message.\n- * \\return None\n- */\n-void\n-rclpy_action_publish_status(py::capsule pyaction_server)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-  rcl_action_goal_status_array_t status_message =\n-    rcl_action_get_zero_initialized_goal_status_array();\n-  rcl_ret_t ret = rcl_action_get_goal_status_array(action_server, \u0026status_message);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed get goal status array\u0022);\n-  }\n-\n-  ret = rcl_action_publish_status(action_server, \u0026status_message);\n-\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed publish goal status array\u0022);\n-  }\n-}\n-\n-rclpy::ActionGoalHandle\n-rclpy_action_accept_new_goal(py::capsule pyaction_server, py::object pygoal_info_msg)\n-{\n-  return rclpy::ActionGoalHandle(pyaction_server, pygoal_info_msg);\n-}\n-\n-void\n-rclpy_action_notify_goal_done(py::capsule pyaction_server)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-  rcl_ret_t ret = rcl_action_notify_goal_done(action_server);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed to notfiy action server of goal done\u0022);\n-  }\n-}\n-\n-bool\n-rclpy_action_server_goal_exists(py::capsule pyaction_server, py::object pygoal_info)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-  destroy_ros_message_signature * destroy_ros_message = NULL;\n-  rcl_action_goal_info_t * goal_info = static_cast\u003Crcl_action_goal_info_t *\u003E(\n-    rclpy_convert_from_py(pygoal_info.ptr(), \u0026destroy_ros_message));\n-  if (!goal_info) {\n-    throw py::error_already_set();\n-  }\n-\n-  auto goal_info_ptr = std::unique_ptr\u003Crcl_action_goal_info_t, decltype(destroy_ros_message)\u003E(\n-    goal_info, destroy_ros_message);\n-\n-  return rcl_action_server_goal_exists(action_server, goal_info);\n-}\n-\n-py::object\n-rclpy_action_process_cancel_request(\n-  py::capsule pyaction_server, py::object pycancel_request, py::object pycancel_response_type)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-\n-  destroy_ros_message_signature * destroy_cancel_request = NULL;\n-  rcl_action_cancel_request_t * cancel_request = static_cast\u003Crcl_action_cancel_request_t *\u003E(\n-    rclpy_convert_from_py(pycancel_request.ptr(), \u0026destroy_cancel_request));\n-  if (!cancel_request) {\n-    throw py::error_already_set();\n-  }\n-  auto cancel_request_ptr =\n-    std::unique_ptr\u003Crcl_action_cancel_request_t, decltype(destroy_cancel_request)\u003E(\n-    cancel_request, destroy_cancel_request);\n-\n-  rcl_action_cancel_response_t cancel_response = rcl_action_get_zero_initialized_cancel_response();\n-  rcl_ret_t ret = rcl_action_process_cancel_request(\n-    action_server, cancel_request, \u0026cancel_response);\n-\n-  if (RCL_RET_OK != ret) {\n-    std::string error_text{\u0022Failed to process cancel request: \u0022};\n-    error_text \u002B= rcl_get_error_string().str;\n-    rcl_reset_error();\n-\n-    ret = rcl_action_cancel_response_fini(\u0026cancel_response);\n-    if (RCL_RET_OK != ret) {\n-      error_text \u002B= \u0022.  Also failed to cleanup response: \u0022;\n-      error_text \u002B= rcl_get_error_string().str;\n-      rcl_reset_error();\n-    }\n-    throw std::runtime_error(error_text);\n-  }\n-\n-  PyObject * pycancel_response =\n-    rclpy_convert_to_py(\u0026cancel_response.msg, pycancel_response_type.ptr());\n-  if (!pycancel_response) {\n-    rcl_ret_t ignore = rcl_action_cancel_response_fini(\u0026cancel_response);\n-    (void) ignore;\n-    throw py::error_already_set();\n-  }\n-  py::object return_value = py::reinterpret_steal\u003Cpy::object\u003E(pycancel_response);\n-\n-  ret = rcl_action_cancel_response_fini(\u0026cancel_response);\n-\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed to finalize cancel response\u0022);\n-  }\n-  return return_value;\n-}\n-\n-py::tuple\n-rclpy_action_expire_goals(py::capsule pyaction_server, int64_t max_num_goals)\n-{\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(pyaction_server, \u0022rcl_action_server_t\u0022);\n-\n-  auto expired_goals =\n-    std::unique_ptr\u003Crcl_action_goal_info_t[]\u003E(new rcl_action_goal_info_t[max_num_goals]);\n-  size_t num_expired;\n-  rcl_ret_t ret = rcl_action_expire_goals(\n-    action_server, expired_goals.get(), max_num_goals, \u0026num_expired);\n-  if (RCL_RET_OK != ret) {\n-    throw rclpy::RCLError(\u0022Failed to expire goals\u0022);\n-  }\n-\n-  // Get Python GoalInfo type\n-  py::module pyaction_msgs_module = py::module::import(\u0022action_msgs.msg\u0022);\n-  py::object pygoal_info_class = pyaction_msgs_module.attr(\u0022GoalInfo\u0022);\n-  py::object pygoal_info_type = pygoal_info_class();\n-\n-  // Create a tuple of GoalInfo instances to return\n-  py::tuple result_tuple(num_expired);\n-\n-  for (size_t i = 0; i \u003C num_expired; \u002B\u002Bi) {\n-    result_tuple[i] = py::reinterpret_steal\u003Cpy::object\u003E(\n-      rclpy_convert_to_py(\u0026(expired_goals.get()[i]), pygoal_info_type.ptr()));\n-  }\n-\n-  return result_tuple;\n-}\n-\n-\n py::object\n rclpy_action_get_client_names_and_types_by_node(\n   py::capsule pynode, const char * remote_node_name, const char * remote_node_namespace)\n@@ -892,69 \u002B163,12 @@ namespace rclpy\n void\n define_action_api(py::module m)\n {\n-  m.def(\n-    \u0022rclpy_action_destroy_entity\u0022, \u0026rclpy_action_destroy_entity,\n-    \u0022Destroy a rclpy_action entity.\u0022);\n   m.def(\n     \u0022rclpy_action_get_rmw_qos_profile\u0022, \u0026rclpy_action_get_rmw_qos_profile,\n     \u0022Get an action RMW QoS profile.\u0022);\n-  m.def(\n-    \u0022rclpy_action_wait_set_add\u0022, \u0026rclpy_action_wait_set_add,\n-    \u0022Add an action entitiy to a wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_action_wait_set_get_num_entities\u0022, \u0026rclpy_action_wait_set_get_num_entities,\n-    \u0022Get the number of wait set entities for an action entitity.\u0022);\n-  m.def(\n-    \u0022rclpy_action_wait_set_is_ready\u0022, \u0026rclpy_action_wait_set_is_ready,\n-    \u0022Check if an action entity has any sub-entities ready in a wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_action_create_server\u0022, \u0026rclpy_action_create_server,\n-    \u0022Create an action server.\u0022);\n-  m.def(\n-    \u0022rclpy_action_server_is_available\u0022, \u0026rclpy_action_server_is_available,\n-    \u0022Check if an action server is available for a given client.\u0022);\n-  m.def(\n-    \u0022rclpy_action_take_goal_request\u0022, \u0026rclpy_action_take_goal_request,\n-    \u0022Take a goal request.\u0022);\n-  m.def(\n-    \u0022rclpy_action_send_goal_response\u0022, \u0026rclpy_action_send_goal_response,\n-    \u0022Send a goal response.\u0022);\n-  m.def(\n-    \u0022rclpy_action_take_result_request\u0022, \u0026rclpy_action_take_result_request,\n-    \u0022Take a result request.\u0022);\n-  m.def(\n-    \u0022rclpy_action_send_result_response\u0022, \u0026rclpy_action_send_result_response,\n-    \u0022Send a result response.\u0022);\n-  m.def(\n-    \u0022rclpy_action_take_cancel_request\u0022, \u0026rclpy_action_take_cancel_request,\n-    \u0022Take a cancel request.\u0022);\n-  m.def(\n-    \u0022rclpy_action_send_cancel_response\u0022, \u0026rclpy_action_send_cancel_response,\n-    \u0022Send a cancel response.\u0022);\n-  m.def(\n-    \u0022rclpy_action_publish_feedback\u0022, \u0026rclpy_action_publish_feedback,\n-    \u0022Publish a feedback message.\u0022);\n-  m.def(\n-    \u0022rclpy_action_publish_status\u0022, \u0026rclpy_action_publish_status,\n-    \u0022Publish a status message.\u0022);\n-  m.def(\n-    \u0022rclpy_action_accept_new_goal\u0022, \u0026rclpy_action_accept_new_goal,\n-    \u0022Accept a new goal using an action server.\u0022);\n-  m.def(\n-    \u0022rclpy_action_notify_goal_done\u0022, \u0026rclpy_action_notify_goal_done,\n-    \u0022Notify and action server that a goal has reached a terminal state.\u0022);\n-\n   define_action_goal_handle(m);\n\u002B  define_action_server(m);\n \n-  m.def(\n-    \u0022rclpy_action_server_goal_exists\u0022, \u0026rclpy_action_server_goal_exists,\n-    \u0022Check if a goal being tracked by an action server.\u0022);\n-  m.def(\n-    \u0022rclpy_action_process_cancel_request\u0022, \u0026rclpy_action_process_cancel_request,\n-    \u0022Process a cancel request to determine what goals should be canceled.\u0022);\n-  m.def(\n-    \u0022rclpy_action_expire_goals\u0022, \u0026rclpy_action_expire_goals,\n-    \u0022Expire goals associated with an action server.\u0022);\n   m.def(\n     \u0022rclpy_action_get_client_names_and_types_by_node\u0022,\n     \u0026rclpy_action_get_client_names_and_types_by_node,\ndiff --git rclpy/src/rclpy/action_goal_handle.cpp rclpy/src/rclpy/action_goal_handle.cpp\nindex 9ca6b84..4590404 100644\n--- rclpy/src/rclpy/action_goal_handle.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_goal_handle.cpp\n@@ -29,28 \u002B29,9 @@ namespace py = pybind11;\n \n namespace rclpy\n {\n-template\u003Ctypename T\u003E\n-T\n-get_pointer(py::capsule \u0026 capsule, const char * name)\n-{\n-  if (strcmp(name, capsule.name())) {\n-    std::string error_text{\u0022Expected capusle with name \u0027\u0022};\n-    error_text \u002B= name;\n-    error_text \u002B= \u0022\u0027 but got \u0027\u0022;\n-    error_text \u002B= capsule.name();\n-    error_text \u002B= \u0022\u0027\u0022;\n-    throw py::value_error(error_text);\n-  }\n-  // TODO(sloretz) use get_pointer() in pybind11 2.6\u002B\n-  return static_cast\u003CT\u003E(capsule);\n-}\n-\n ActionGoalHandle::ActionGoalHandle(\n-  py::capsule pyaction_server, py::object pygoal_info_msg)\n\u002B  rclpy::ActionServer \u0026 action_server, py::object pygoal_info_msg)\n {\n-  auto action_server = get_pointer\u003Crcl_action_server_t *\u003E(\n-    pyaction_server, \u0022rcl_action_server_t\u0022);\n-\n   destroy_ros_message_signature * destroy_ros_message = NULL;\n   auto goal_info_msg = static_cast\u003Crcl_action_goal_info_t *\u003E(\n     rclpy_convert_from_py(pygoal_info_msg.ptr(), \u0026destroy_ros_message));\n@@ -62,7 \u002B43,8 @@ ActionGoalHandle::ActionGoalHandle(\n   auto goal_info_msg_ptr = std::unique_ptr\u003Crcl_action_goal_info_t, decltype(destroy_ros_message)\u003E(\n     goal_info_msg, destroy_ros_message);\n \n-  auto rcl_handle = rcl_action_accept_new_goal(action_server, goal_info_msg);\n\u002B  auto rcl_handle = rcl_action_accept_new_goal(\n\u002B    action_server.rcl_ptr(), goal_info_msg);\n   if (!rcl_handle) {\n     throw rclpy::RCLError(\u0022Failed to accept new goal\u0022);\n   }\n@@ -117,9 \u002B99,8 @@ void\n define_action_goal_handle(py::module module)\n {\n   py::class_\u003CActionGoalHandle, Destroyable, std::shared_ptr\u003CActionGoalHandle\u003E\u003E(\n-    module,\n-    \u0022ActionGoalHandle\u0022)\n-  .def(py::init\u003Cpy::capsule, py::object\u003E())\n\u002B    module, \u0022ActionGoalHandle\u0022)\n\u002B  .def(py::init\u003Crclpy::ActionServer \u0026, py::object\u003E())\n   .def_property_readonly(\n     \u0022pointer\u0022, [](const ActionGoalHandle \u0026 handle) {\n       return reinterpret_cast\u003Csize_t\u003E(handle.rcl_ptr());\ndiff --git rclpy/src/rclpy/action_goal_handle.hpp rclpy/src/rclpy/action_goal_handle.hpp\nindex e2c054a..b1e1bfc 100644\n--- rclpy/src/rclpy/action_goal_handle.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_goal_handle.hpp\n@@ -21,6 \u002B21,7 @@\n \n #include \u003Cmemory\u003E\n \n\u002B#include \u0022action_server.hpp\u0022\n #include \u0022destroyable.hpp\u0022\n #include \u0022handle.hpp\u0022\n \n@@ -28,7 \u002B29,10 @@ namespace py = pybind11;\n \n namespace rclpy\n {\n-class ActionGoalHandle : public Destroyable\n\u002B\n\u002Bclass ActionServer;\n\u002B\n\u002Bclass ActionGoalHandle : public Destroyable, public std::enable_shared_from_this\u003CActionGoalHandle\u003E\n {\n public:\n   /// Create an action goal handle\n@@ -42,7 \u002B46,7 @@ public:\n    * \\param[in] pyaction_server handle to the action server that is accepting the goal\n    * \\param[in] pygoal_info_msg a message containing info about the goal being accepted\n    */\n-  ActionGoalHandle(py::capsule pyaction_server, py::object pygoal_info_msg);\n\u002B  ActionGoalHandle(rclpy::ActionServer \u0026 action_server, py::object pygoal_info_msg);\n \n   ~ActionGoalHandle() = default;\n \ndiff --git rclpy/src/rclpy/action_server.cpp rclpy/src/rclpy/action_server.cpp\nnew file mode 100644\nindex 0000000..5bc7919\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.cpp\n@@ -0,0 \u002B1,414 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B// Include pybind11 before rclpy_common/handle.h includes Python.h\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcpputils/scope_exit.hpp\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rclpy_common/common.h\u0022\n\u002B#include \u0022rclpy_common/exceptions.hpp\u0022\n\u002B#include \u0022rclpy_common/handle.h\u0022\n\u002B\n\u002B#include \u0022action_server.hpp\u0022\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B\n\u002Bvoid\n\u002BActionServer::destroy()\n\u002B{\n\u002B  rcl_action_server_.reset();\n\u002B  node_handle_.reset();\n\u002B}\n\u002B\n\u002BActionServer::ActionServer(\n\u002B  py::capsule pynode,\n\u002B  const rclpy::Clock \u0026 rclpy_clock,\n\u002B  py::object pyaction_type,\n\u002B  const char * action_name,\n\u002B  const rmw_qos_profile_t \u0026 goal_service_qos,\n\u002B  const rmw_qos_profile_t \u0026 result_service_qos,\n\u002B  const rmw_qos_profile_t \u0026 cancel_service_qos,\n\u002B  const rmw_qos_profile_t \u0026 feedback_topic_qos,\n\u002B  const rmw_qos_profile_t \u0026 status_topic_qos,\n\u002B  double result_timeout)\n\u002B: node_handle_(std::make_shared\u003CHandle\u003E(pynode))\n\u002B{\n\u002B  auto node = node_handle_-\u003Ecast\u003Crcl_node_t *\u003E(\u0022rcl_node_t\u0022);\n\u002B\n\u002B  rcl_clock_t * clock = rclpy_clock.rcl_ptr();\n\u002B\n\u002B  rosidl_action_type_support_t * ts = static_cast\u003Crosidl_action_type_support_t *\u003E(\n\u002B    rclpy_common_get_type_support(pyaction_type.ptr()));\n\u002B  if (!ts) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  rcl_action_server_options_t action_server_ops = rcl_action_server_get_default_options();\n\u002B\n\u002B  action_server_ops.goal_service_qos = goal_service_qos;\n\u002B  action_server_ops.result_service_qos = result_service_qos;\n\u002B  action_server_ops.cancel_service_qos = cancel_service_qos;\n\u002B  action_server_ops.feedback_topic_qos = feedback_topic_qos;\n\u002B  action_server_ops.status_topic_qos = status_topic_qos;\n\u002B  action_server_ops.result_timeout.nanoseconds = (rcl_duration_value_t)RCL_S_TO_NS(result_timeout);\n\u002B\n\u002B  rcl_action_server_ = std::shared_ptr\u003Crcl_action_server_t\u003E(\n\u002B    new rcl_action_server_t,\n\u002B    [this](rcl_action_server_t * action_server)\n\u002B    {\n\u002B      auto node = node_handle_-\u003Ecast_or_warn\u003Crcl_node_t *\u003E(\u0022rcl_node_t\u0022);\n\u002B\n\u002B      rcl_ret_t ret = rcl_action_server_fini(action_server, node);\n\u002B      if (RCL_RET_OK != ret) {\n\u002B        // Warning should use line number of the current stack frame\n\u002B        int stack_level = 1;\n\u002B        PyErr_WarnFormat(\n\u002B          PyExc_RuntimeWarning, stack_level, \u0022Failed to fini publisher: %s\u0022,\n\u002B          rcl_get_error_string().str);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B      delete action_server;\n\u002B    });\n\u002B\n\u002B  *rcl_action_server_ = rcl_action_get_zero_initialized_server();\n\u002B\n\u002B  rcl_ret_t ret = rcl_action_server_init(\n\u002B    rcl_action_server_.get(),\n\u002B    node,\n\u002B    clock,\n\u002B    ts,\n\u002B    action_name,\n\u002B    \u0026action_server_ops);\n\u002B  if (RCL_RET_ACTION_NAME_INVALID == ret) {\n\u002B    std::string error_text{\u0022Failed to create action server due to invalid topic name \u0027\u0022};\n\u002B    error_text \u002B= action_name;\n\u002B    error_text \u002B= \u0022\u0027 : \u0022;\n\u002B    error_text \u002B= rcl_get_error_string().str;\n\u002B    rcl_reset_error();\n\u002B    throw py::value_error(error_text);\n\u002B  } else if (RCL_RET_OK != ret) {\n\u002B    std::string error_text{\u0022Failed to create action server: \u0022};\n\u002B    error_text \u002B= rcl_get_error_string().str;\n\u002B    rcl_reset_error();\n\u002B    throw py::value_error(error_text);\n\u002B  }\n\u002B}\n\u002B\n\u002B#define TAKE_SERVICE_REQUEST(Type) \\\n\u002B  /* taken_msg is always destroyed in this function */ \\\n\u002B  auto taken_msg = create_from_py(pymsg_type); \\\n\u002B  rmw_request_id_t header; \\\n\u002B  rcl_ret_t ret = \\\n\u002B    rcl_action_take_ ## Type ## _request(rcl_action_server_.get(), \u0026header, taken_msg.get()); \\\n\u002B  /* Create the tuple to return */ \\\n\u002B  if (ret == RCL_RET_ACTION_CLIENT_TAKE_FAILED || ret == RCL_RET_ACTION_SERVER_TAKE_FAILED) { \\\n\u002B    return py::make_tuple(py::none(), py::none()); \\\n\u002B  } else if (RCL_RET_OK != ret) { \\\n\u002B    throw rclpy::RCLError(\u0022Failed to take \u0022 #Type); \\\n\u002B  } \\\n\u002B  return py::make_tuple(header, convert_to_py(taken_msg.get(), pymsg_type)); \\\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::take_goal_request(py::object pymsg_type)\n\u002B{\n\u002B  TAKE_SERVICE_REQUEST(goal)\n\u002B}\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::take_result_request(py::object pymsg_type)\n\u002B{\n\u002B  TAKE_SERVICE_REQUEST(result)\n\u002B}\n\u002B\n\u002B#define SEND_SERVICE_RESPONSE(Type) \\\n\u002B  auto ros_response = convert_from_py(pyresponse); \\\n\u002B  rcl_ret_t ret = rcl_action_send_ ## Type ## _response( \\\n\u002B    rcl_action_server_.get(), header, ros_response.get()); \\\n\u002B  if (RCL_RET_OK != ret) { \\\n\u002B    throw rclpy::RCLError(\u0022Failed to send \u0022 #Type \u0022 response\u0022); \\\n\u002B  }\n\u002B\n\u002Bvoid\n\u002BActionServer::send_goal_response(\n\u002B  rmw_request_id_t * header, py::object pyresponse)\n\u002B{\n\u002B  SEND_SERVICE_RESPONSE(goal)\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::send_result_response(\n\u002B  rmw_request_id_t * header, py::object pyresponse)\n\u002B{\n\u002B  SEND_SERVICE_RESPONSE(result)\n\u002B}\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::take_cancel_request(py::object pymsg_type)\n\u002B{\n\u002B  TAKE_SERVICE_REQUEST(cancel)\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::send_cancel_response(\n\u002B  rmw_request_id_t * header, py::object pyresponse)\n\u002B{\n\u002B  SEND_SERVICE_RESPONSE(cancel)\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::publish_feedback(py::object pymsg)\n\u002B{\n\u002B  auto ros_message = convert_from_py(pymsg);\n\u002B  rcl_ret_t ret = rcl_action_publish_feedback(rcl_action_server_.get(), ros_message.get());\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed to publish feedback with an action server\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::publish_status()\n\u002B{\n\u002B  rcl_action_goal_status_array_t status_message =\n\u002B    rcl_action_get_zero_initialized_goal_status_array();\n\u002B  rcl_ret_t ret = rcl_action_get_goal_status_array(rcl_action_server_.get(), \u0026status_message);\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed get goal status array\u0022);\n\u002B  }\n\u002B\n\u002B  ret = rcl_action_publish_status(rcl_action_server_.get(), \u0026status_message);\n\u002B\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed publish goal status array\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::notify_goal_done()\n\u002B{\n\u002B  rcl_ret_t ret = rcl_action_notify_goal_done(rcl_action_server_.get());\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed to notfiy action server of goal done\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bbool\n\u002BActionServer::goal_exists(py::object pygoal_info)\n\u002B{\n\u002B  auto goal_info = convert_from_py(pygoal_info);\n\u002B  rcl_action_goal_info_t * goal_info_type = static_cast\u003Crcl_action_goal_info_t *\u003E(goal_info.get());\n\u002B  return rcl_action_server_goal_exists(rcl_action_server_.get(), goal_info_type);\n\u002B}\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::get_num_entities()\n\u002B{\n\u002B  size_t num_subscriptions = 0u;\n\u002B  size_t num_guard_conditions = 0u;\n\u002B  size_t num_timers = 0u;\n\u002B  size_t num_clients = 0u;\n\u002B  size_t num_services = 0u;\n\u002B\n\u002B  rcl_ret_t ret = rcl_action_server_wait_set_get_num_entities(\n\u002B    rcl_action_server_.get(),\n\u002B    \u0026num_subscriptions,\n\u002B    \u0026num_guard_conditions,\n\u002B    \u0026num_timers,\n\u002B    \u0026num_clients,\n\u002B    \u0026num_services);\n\u002B\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    std::string error_text{\u0022Failed to get number of entities for \u0027rcl_action_server_t\u0027\u0022};\n\u002B    throw rclpy::RCLError(error_text);\n\u002B  }\n\u002B\n\u002B  py::tuple result_tuple(5);\n\u002B  result_tuple[0] = py::int_(num_subscriptions);\n\u002B  result_tuple[1] = py::int_(num_guard_conditions);\n\u002B  result_tuple[2] = py::int_(num_timers);\n\u002B  result_tuple[3] = py::int_(num_clients);\n\u002B  result_tuple[4] = py::int_(num_services);\n\u002B  return result_tuple;\n\u002B}\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::is_ready(py::capsule pywait_set)\n\u002B{\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B  bool is_goal_request_ready = false;\n\u002B  bool is_cancel_request_ready = false;\n\u002B  bool is_result_request_ready = false;\n\u002B  bool is_goal_expired = false;\n\u002B  rcl_ret_t ret = rcl_action_server_wait_set_get_entities_ready(\n\u002B    wait_set,\n\u002B    rcl_action_server_.get(),\n\u002B    \u0026is_goal_request_ready,\n\u002B    \u0026is_cancel_request_ready,\n\u002B    \u0026is_result_request_ready,\n\u002B    \u0026is_goal_expired);\n\u002B\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed to get number of ready entities for action server\u0022);\n\u002B  }\n\u002B\n\u002B  py::tuple result_tuple(4);\n\u002B  result_tuple[0] = py::bool_(is_goal_request_ready);\n\u002B  result_tuple[1] = py::bool_(is_cancel_request_ready);\n\u002B  result_tuple[2] = py::bool_(is_result_request_ready);\n\u002B  result_tuple[3] = py::bool_(is_goal_expired);\n\u002B  return result_tuple;\n\u002B}\n\u002B\n\u002Bvoid\n\u002BActionServer::add_to_waitset(py::capsule pywait_set)\n\u002B{\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B  rcl_ret_t ret = rcl_action_wait_set_add_action_server(wait_set, rcl_action_server_.get(), NULL);\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed to add \u0027rcl_action_server_t\u0027 to wait set\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bpy::object\n\u002BActionServer::process_cancel_request(\n\u002B  py::object pycancel_request, py::object pycancel_response_type)\n\u002B{\n\u002B  auto cancel_request = convert_from_py(pycancel_request);\n\u002B  rcl_action_cancel_request_t * cancel_request_tmp = static_cast\u003Crcl_action_cancel_request_t *\u003E(\n\u002B    cancel_request.get());\n\u002B\n\u002B  rcl_action_cancel_response_t cancel_response = rcl_action_get_zero_initialized_cancel_response();\n\u002B  rcl_ret_t ret = rcl_action_process_cancel_request(\n\u002B    rcl_action_server_.get(), cancel_request_tmp, \u0026cancel_response);\n\u002B\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    std::string error_text{\u0022Failed to process cancel request: \u0022};\n\u002B    error_text \u002B= rcl_get_error_string().str;\n\u002B    rcl_reset_error();\n\u002B\n\u002B    ret = rcl_action_cancel_response_fini(\u0026cancel_response);\n\u002B    if (RCL_RET_OK != ret) {\n\u002B      error_text \u002B= \u0022.  Also failed to cleanup response: \u0022;\n\u002B      error_text \u002B= rcl_get_error_string().str;\n\u002B      rcl_reset_error();\n\u002B    }\n\u002B    throw std::runtime_error(error_text);\n\u002B  }\n\u002B\n\u002B  py::object return_value = convert_to_py(\u0026cancel_response.msg, pycancel_response_type);\n\u002B  RCPPUTILS_SCOPE_EXIT(\n\u002B    {\n\u002B      ret = rcl_action_cancel_response_fini(\u0026cancel_response);\n\u002B\n\u002B      if (RCL_RET_OK != ret) {\n\u002B        throw rclpy::RCLError(\u0022Failed to finalize cancel response\u0022);\n\u002B      }\n\u002B    });\n\u002B  return return_value;\n\u002B}\n\u002B\n\u002Bpy::tuple\n\u002BActionServer::expire_goals(int64_t max_num_goals)\n\u002B{\n\u002B  auto expired_goals =\n\u002B    std::unique_ptr\u003Crcl_action_goal_info_t[]\u003E(new rcl_action_goal_info_t[max_num_goals]);\n\u002B  size_t num_expired;\n\u002B  rcl_ret_t ret = rcl_action_expire_goals(\n\u002B    rcl_action_server_.get(), expired_goals.get(), max_num_goals, \u0026num_expired);\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    throw rclpy::RCLError(\u0022Failed to expire goals\u0022);\n\u002B  }\n\u002B\n\u002B  // Get Python GoalInfo type\n\u002B  py::module pyaction_msgs_module = py::module::import(\u0022action_msgs.msg\u0022);\n\u002B  py::object pygoal_info_class = pyaction_msgs_module.attr(\u0022GoalInfo\u0022);\n\u002B  py::object pygoal_info_type = pygoal_info_class();\n\u002B\n\u002B  // Create a tuple of GoalInfo instances to return\n\u002B  py::tuple result_tuple(num_expired);\n\u002B\n\u002B  for (size_t i = 0; i \u003C num_expired; \u002B\u002Bi) {\n\u002B    result_tuple[i] =\n\u002B      convert_to_py(\u0026(expired_goals.get()[i]), pygoal_info_type);\n\u002B  }\n\u002B\n\u002B  return result_tuple;\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bdefine_action_server(py::object module)\n\u002B{\n\u002B  py::class_\u003CActionServer, Destroyable, std::shared_ptr\u003CActionServer\u003E\u003E(module, \u0022ActionServer\u0022)\n\u002B  .def(\n\u002B    py::init\u003Cpy::capsule, const rclpy::Clock \u0026, py::object, const char *,\n\u002B    const rmw_qos_profile_t \u0026, const rmw_qos_profile_t \u0026, const rmw_qos_profile_t \u0026,\n\u002B    const rmw_qos_profile_t \u0026, const rmw_qos_profile_t \u0026, double\u003E())\n\u002B  .def_property_readonly(\n\u002B    \u0022pointer\u0022, [](const ActionServer \u0026 action_server) {\n\u002B      return reinterpret_cast\u003Csize_t\u003E(action_server.rcl_ptr());\n\u002B    },\n\u002B    \u0022Get the address of the entity as an integer\u0022)\n\u002B  .def(\n\u002B    \u0022take_goal_request\u0022, \u0026ActionServer::take_goal_request,\n\u002B    \u0022Take an action goal request.\u0022)\n\u002B  .def(\n\u002B    \u0022send_goal_response\u0022, \u0026ActionServer::send_goal_response,\n\u002B    \u0022Send an action goal response.\u0022)\n\u002B  .def(\n\u002B    \u0022send_result_response\u0022, \u0026ActionServer::send_result_response,\n\u002B    \u0022Send an action result response.\u0022)\n\u002B  .def(\n\u002B    \u0022take_cancel_request\u0022, \u0026ActionServer::take_cancel_request,\n\u002B    \u0022Take an action cancel request.\u0022)\n\u002B  .def(\n\u002B    \u0022take_result_request\u0022, \u0026ActionServer::take_result_request,\n\u002B    \u0022Take an action result request.\u0022)\n\u002B  .def(\n\u002B    \u0022send_cancel_response\u0022, \u0026ActionServer::send_cancel_response,\n\u002B    \u0022Send an action cancel response.\u0022)\n\u002B  .def(\n\u002B    \u0022publish_feedback\u0022, \u0026ActionServer::publish_feedback,\n\u002B    \u0022 Publish a feedback message from a given action server.\u0022)\n\u002B  .def(\n\u002B    \u0022publish_status\u0022, \u0026ActionServer::publish_status,\n\u002B    \u0022Publish a status message from a given action server.\u0022)\n\u002B  .def(\n\u002B    \u0022notify_goal_done\u0022, \u0026ActionServer::notify_goal_done,\n\u002B    \u0022Notify goal is done.\u0022)\n\u002B  .def(\n\u002B    \u0022goal_exists\u0022, \u0026ActionServer::goal_exists,\n\u002B    \u0022Check is a goal exists in the server.\u0022)\n\u002B  .def(\n\u002B    \u0022process_cancel_request\u0022, \u0026ActionServer::process_cancel_request,\n\u002B    \u0022Process a cancel request\u0022)\n\u002B  .def(\n\u002B    \u0022expire_goals\u0022, \u0026ActionServer::expire_goals,\n\u002B    \u0022Expired goals.\u0022)\n\u002B  .def(\n\u002B    \u0022get_num_entities\u0022, \u0026ActionServer::get_num_entities,\n\u002B    \u0022Get the number of wait set entities that make up an action entity.\u0022)\n\u002B  .def(\n\u002B    \u0022is_ready\u0022, \u0026ActionServer::is_ready,\n\u002B    \u0022Check if an action entity has any ready wait set entities.\u0022)\n\u002B  .def(\n\u002B    \u0022add_to_waitset\u0022, \u0026ActionServer::add_to_waitset,\n\u002B    \u0022Add an action entitiy to a wait set.\u0022);\n\u002B}\n\u002B\n\u002B}  // namespace rclpy\ndiff --git rclpy/src/rclpy/action_server.hpp rclpy/src/rclpy/action_server.hpp\nnew file mode 100644\nindex 0000000..f5008a9\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.hpp\n@@ -0,0 \u002B1,264 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLPY__ACTION_SERVER_HPP_\n\u002B#define RCLPY__ACTION_SERVER_HPP_\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Crcl_action/rcl_action.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022clock.hpp\u0022\n\u002B#include \u0022destroyable.hpp\u0022\n\u002B#include \u0022handle.hpp\u0022\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B/*\n\u002B  * This class will create an action server for the given action name.\n\u002B  * This client will use the typesupport defined in the action module\n\u002B  * provided as pyaction_type to send messages.\n\u002B  */\n\u002Bclass ActionServer : public Destroyable, public std::enable_shared_from_this\u003CActionServer\u003E\n\u002B{\n\u002Bpublic:\n\u002B  /// Create an action server.\n\u002B  /**\n\u002B   * Raises AttributeError if action type is invalid\n\u002B   * Raises ValueError if action name is invalid\n\u002B   * Raises RuntimeError if the action server could not be created.\n\u002B   *\n\u002B   * \\param[in] pynode Capsule pointing to the node to add the action server to.\n\u002B   * \\param[in] rclpy_clock Clock use to create the action server.\n\u002B   * \\param[in] pyaction_type Action module associated with the action server.\n\u002B   * \\param[in] pyaction_name Python object containing the action name.\n\u002B   * \\param[in] goal_service_qos rmw_qos_profile_t object for the goal service.\n\u002B   * \\param[in] result_service_qos rmw_qos_profile_t object for the result service.\n\u002B   * \\param[in] cancel_service_qos rmw_qos_profile_t object for the cancel service.\n\u002B   * \\param[in] feedback_qos rmw_qos_profile_t object for the feedback subscriber.\n\u002B   * \\param[in] status_qos rmw_qos_profile_t object for the status subscriber.\n\u002B   */\n\u002B  ActionServer(\n\u002B    py::capsule pynode,\n\u002B    const rclpy::Clock \u0026 rclpy_clock,\n\u002B    py::object pyaction_type,\n\u002B    const char * action_name,\n\u002B    const rmw_qos_profile_t \u0026 goal_service_qos,\n\u002B    const rmw_qos_profile_t \u0026 result_service_qos,\n\u002B    const rmw_qos_profile_t \u0026 cancel_service_qos,\n\u002B    const rmw_qos_profile_t \u0026 feedback_topic_qos,\n\u002B    const rmw_qos_profile_t \u0026 status_topic_qos,\n\u002B    double result_timeout);\n\u002B\n\u002B  /// Take an action goal request.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] pymsg_type An instance of the type of request message to take.\n\u002B   * \\return 2-tuple (header, received request message) where the header is an\n\u002B   *   \u0022rclpy.rmw_request_id_t\u0022 type, or\n\u002B   * \\return 2-tuple (None, None) if there as no message to take\n\u002B   */\n\u002B  py::tuple\n\u002B  take_goal_request(py::object pymsg_type);\n\u002B\n\u002B  /// Send an action goal response.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] header Pointer to the message header.\n\u002B   * \\param[in] pyresponse The response message to send.\n\u002B   */\n\u002B  void\n\u002B  send_goal_response(\n\u002B    rmw_request_id_t * header, py::object pyresponse);\n\u002B\n\u002B  /// Send an action result response.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] pyheader Pointer to the message header.\n\u002B   * \\param[in] pyresponse The response message to send.\n\u002B   */\n\u002B  void\n\u002B  send_result_response(\n\u002B    rmw_request_id_t * header, py::object pyresponse);\n\u002B\n\u002B  /// Take an action cancel request.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] pymsg_type An instance of the type of request message to take.\n\u002B   * \\return 2-tuple (header, received request message) where the header is an\n\u002B   *   \u0022rmw_request_id_t\u0022 type, or\n\u002B   * \\return 2-tuple (None, None) if there as no message to take\n\u002B   */\n\u002B  py::tuple\n\u002B  take_cancel_request(py::object pymsg_type);\n\u002B\n\u002B  /// Take an action result request.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] pymsg_type An instance of the type of request message to take.\n\u002B   * \\return 2-tuple (header, received request message) where the header is an\n\u002B   *   \u0022rclpy.rmw_request_id_t\u0022 type, or\n\u002B   * \\return 2-tuple (None, None) if there as no message to take\n\u002B   */\n\u002B  py::tuple\n\u002B  take_result_request(py::object pymsg_type);\n\u002B\n\u002B  /// Send an action cancel response.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure.\n\u002B   *\n\u002B   * \\param[in] pyheader Pointer to the message header.\n\u002B   * \\param[in] pyresponse The response message to send.\n\u002B   */\n\u002B  void\n\u002B  send_cancel_response(\n\u002B    rmw_request_id_t * header, py::object pyresponse);\n\u002B\n\u002B  /// Publish a feedback message from a given action server.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure while publishing a feedback message.\n\u002B   *\n\u002B   * \\param[in] pymsg The feedback message to publish.\n\u002B   */\n\u002B  void\n\u002B  publish_feedback(py::object pymsg);\n\u002B\n\u002B  /// Publish a status message from a given action server.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   * Raises RuntimeError on failure while publishing a status message.\n\u002B   */\n\u002B  void\n\u002B  publish_status();\n\u002B\n\u002B  /// Notifies action server that a goal handle reached a terminal state.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   */\n\u002B  void\n\u002B  notify_goal_done();\n\u002B\n\u002B  /// Check if a goal is already being tracked by an action server.\n\u002B  /*\n\u002B   * Raises AttributeError if there is an issue parsing the pygoal_info.\n\u002B   *\n\u002B   * \\param[in] pygoal_info the identifiers of goals that expired, or set to \u0060NULL\u0060 if unused\n\u002B   * \\return True if the goal exists, false otherwise.\n\u002B   */\n\u002B  bool\n\u002B  goal_exists(py::object pygoal_info);\n\u002B\n\u002B  /// Process a cancel request using an action server.\n\u002B  /**\n\u002B   * This is a non-blocking call.\n\u002B   *\n\u002B   * Raises RuntimeError on failure while publishing a status message.\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   *\n\u002B   * \\return the cancel response message\n\u002B   */\n\u002B  py::object\n\u002B  process_cancel_request(\n\u002B    py::object pycancel_request, py::object pycancel_response_type);\n\u002B\n\u002B  /// Expires goals associated with an action server.\n\u002B  py::tuple\n\u002B  expire_goals(int64_t max_num_goals);\n\u002B\n\u002B  /// Get the number of wait set entities that make up an action entity.\n\u002B  /**\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   *\n\u002B   * \\return Tuple containing the number of wait set entities:\n\u002B   *   (num_subscriptions,\n\u002B   *    num_guard_conditions,\n\u002B   *    num_timers,\n\u002B   *    num_clients,\n\u002B   *    num_services)\n\u002B   */\n\u002B  py::tuple\n\u002B  get_num_entities();\n\u002B\n\u002B  /// Check if an action entity has any ready wait set entities.\n\u002B  /**\n\u002B   * This must be called after waiting on the wait set.\n\u002B   * Raises RuntimeError on failure.\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   *\n\u002B   * \\param[in] pywait_set Capsule pointing to the wait set structure.\n\u002B   * \\return A tuple of booleans representing ready sub-entities.\n\u002B   *       (is_goal_request_ready,\n\u002B   *        is_cancel_request_ready,\n\u002B   *        is_result_request_ready,\n\u002B   *        is_goal_expired)\n\u002B   */\n\u002B  py::tuple\n\u002B  is_ready(py::capsule pywait_set);\n\u002B\n\u002B  /// Add an action entitiy to a wait set.\n\u002B  /**\n\u002B   * Raises RuntimeError on failure.\n\u002B   * Raises RCLError if an error occurs in rcl\n\u002B   *\n\u002B   * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n\u002B   */\n\u002B  void\n\u002B  add_to_waitset(py::capsule pywait_set);\n\u002B\n\u002B  /// Get rcl_client_t pointer\n\u002B  rcl_action_server_t *\n\u002B  rcl_ptr() const\n\u002B  {\n\u002B    return rcl_action_server_.get();\n\u002B  }\n\u002B\n\u002B  /// Get rcl_client_t pointer\n\u002B  std::shared_ptr\u003Crcl_action_server_t\u003E\n\u002B  get_rcl_shared_ptr()\n\u002B  {\n\u002B    return rcl_action_server_;\n\u002B  }\n\u002B\n\u002B  /// Force an early destruction of this object\n\u002B  void\n\u002B  destroy() override;\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003CHandle\u003E node_handle_;\n\u002B  std::shared_ptr\u003Crcl_action_server_t\u003E rcl_action_server_;\n\u002B};\n\u002B/// Define a pybind11 wrapper for an rcl_time_point_t\n\u002B/**\n\u002B * \\param[in] module a pybind11 module to add the definition to\n\u002B */\n\u002Bvoid define_action_server(py::object module);\n\u002B}  // namespace rclpy\n\u002B\n\u002B#endif  // RCLPY__ACTION_SERVER_HPP_\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rcutils",
    "SHA": "20a23ea7b39146cd58f98cc07c7be74a22f70f4a",
    "RawMessage": "Fix setting allocator to NULL. (#478)",
    "Changes": "diff --git src/allocator.c src/allocator.c\nindex 75cf3d5..d364bde 100644\n--- src/allocator.c\n\u002B\u002B\u002B src/allocator.c\n@@ -65,13 \u002B65,7 @@ __default_zero_allocate(size_t number_of_elements, size_t size_of_element, void\n rcutils_allocator_t\n rcutils_get_zero_initialized_allocator(void)\n {\n-  static rcutils_allocator_t zero_allocator = {\n-    .allocate = NULL,\n-    .deallocate = NULL,\n-    .reallocate = NULL,\n-    .zero_allocate = NULL,\n-    .state = NULL,\n-  };\n\u002B  static rcutils_allocator_t zero_allocator = {0};\n   return zero_allocator;\n }\n \ndiff --git src/array_list.c src/array_list.c\nindex a9a08db..8761cec 100644\n--- src/array_list.c\n\u002B\u002B\u002B src/array_list.c\n@@ -44,7 \u002B44,7 @@ typedef struct rcutils_array_list_impl_s\n rcutils_array_list_t\n rcutils_get_zero_initialized_array_list(void)\n {\n-  static rcutils_array_list_t zero_initialized_array_list = {NULL};\n\u002B  static rcutils_array_list_t zero_initialized_array_list = {0};\n   return zero_initialized_array_list;\n }\n \ndiff --git src/char_array.c src/char_array.c\nindex aa24b05..76743d1 100644\n--- src/char_array.c\n\u002B\u002B\u002B src/char_array.c\n@@ -21,13 \u002B21,7 @@\n rcutils_char_array_t\n rcutils_get_zero_initialized_char_array(void)\n {\n-  static rcutils_char_array_t char_array = {\n-    .buffer = NULL,\n-    .owns_buffer = true,\n-    .buffer_length = 0u,\n-    .buffer_capacity = 0u\n-  };\n-  char_array.allocator = rcutils_get_zero_initialized_allocator();\n\u002B  static rcutils_char_array_t char_array = {0};\n   return char_array;\n }\n \ndiff --git src/hash_map.c src/hash_map.c\nindex 4939c1c..28748d6 100644\n--- src/hash_map.c\n\u002B\u002B\u002B src/hash_map.c\n@@ -77,7 \u002B77,7 @@ int rcutils_hash_map_string_cmp_func(const void * val1, const void * val2)\n rcutils_hash_map_t\n rcutils_get_zero_initialized_hash_map(void)\n {\n-  static rcutils_hash_map_t zero_initialized_hash_map = {NULL};\n\u002B  static rcutils_hash_map_t zero_initialized_hash_map = {0};\n   return zero_initialized_hash_map;\n }\n \ndiff --git src/shared_library.c src/shared_library.c\nindex dd367ff..077478f 100644\n--- src/shared_library.c\n\u002B\u002B\u002B src/shared_library.c\n@@ -56,10 \u002B56,7 @@ C_ASSERT(sizeof(char) == sizeof(TCHAR));\n rcutils_shared_library_t\n rcutils_get_zero_initialized_shared_library(void)\n {\n-  rcutils_shared_library_t zero_initialized_shared_library;\n-  zero_initialized_shared_library.library_path = NULL;\n-  zero_initialized_shared_library.lib_pointer = NULL;\n-  zero_initialized_shared_library.allocator = rcutils_get_zero_initialized_allocator();\n\u002B  static rcutils_shared_library_t zero_initialized_shared_library = {0};\n   return zero_initialized_shared_library;\n }\n \ndiff --git src/string_array.c src/string_array.c\nindex 40adb54..e279a37 100644\n--- src/string_array.c\n\u002B\u002B\u002B src/string_array.c\n@@ -28,11 \u002B28,7 @@ extern \u0022C\u0022\n rcutils_string_array_t\n rcutils_get_zero_initialized_string_array(void)\n {\n-  static rcutils_string_array_t array = {\n-    .size = 0,\n-    .data = NULL,\n-  };\n-  array.allocator = rcutils_get_zero_initialized_allocator();\n\u002B  static rcutils_string_array_t array = {0};\n   return array;\n }\n \ndiff --git src/string_map.c src/string_map.c\nindex 4624ed9..47688e0 100644\n--- src/string_map.c\n\u002B\u002B\u002B src/string_map.c\n@@ -46,8 \u002B46,7 @@ typedef struct rcutils_string_map_impl_s\n rcutils_string_map_t\n rcutils_get_zero_initialized_string_map(void)\n {\n-  static rcutils_string_map_t zero_initialized_string_map;\n-  zero_initialized_string_map.impl = NULL;\n\u002B  static rcutils_string_map_t zero_initialized_string_map = {0};\n   return zero_initialized_string_map;\n }\n \ndiff --git src/uint8_array.c src/uint8_array.c\nindex 5c34803..844d370 100644\n--- src/uint8_array.c\n\u002B\u002B\u002B src/uint8_array.c\n@@ -18,12 \u002B18,7 @@\n rcutils_uint8_array_t\n rcutils_get_zero_initialized_uint8_array(void)\n {\n-  static rcutils_uint8_array_t uint8_array = {\n-    .buffer = NULL,\n-    .buffer_length = 0lu,\n-    .buffer_capacity = 0lu\n-  };\n-  uint8_array.allocator = rcutils_get_zero_initialized_allocator();\n\u002B  static rcutils_uint8_array_t uint8_array = {0};\n   return uint8_array;\n }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "b30838530c1aee8f6ddcbd11db258fbd24e57935",
    "RawMessage": "Fixed transport name in DepthCloud plugin (#1134)",
    "Changes": "diff --git rviz_default_plugins/src/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.cpp rviz_default_plugins/src/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.cpp\nindex 73621da8..9958c68f 100644\n--- rviz_default_plugins/src/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.cpp\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.cpp\n@@ -200,15 \u002B200,10 @@ void DepthCloudDisplay::setTopic(const QString \u0026 topic, const QString \u0026 datatype\n     depth_transport_property_-\u003EsetStdString(\u0022raw\u0022);\n     depth_topic_property_-\u003EsetString(topic);\n   } else {\n-    int index = topic.lastIndexOf(\u0022/\u0022);\n-    if (index == -1) {\n-      return;\n-    }\n-    QString transport = topic.mid(index \u002B 1);\n-    QString base_topic = topic.mid(0, index);\n-\n-    depth_transport_property_-\u003EsetString(transport);\n-    depth_topic_property_-\u003EsetString(base_topic);\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusProperty::Warn,\n\u002B      \u0022Message\u0022,\n\u002B      \u0022Expected topic type of \u0027sensor_msgs/msg/Image\u0027, saw topic type \u0027\u0022 \u002B datatype \u002B \u0022\u0027\u0022);\n   }\n }\n \n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "2cc43b327405f82d8192267714d509074ef2915f",
    "RawMessage": "update doc section for spin_xxx methods. (#2730)",
    "Changes": "diff --git rclcpp/include/rclcpp/executor.hpp rclcpp/include/rclcpp/executor.hpp\nindex ae2087bb..4b75cc87 100644\n--- rclcpp/include/rclcpp/executor.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/executor.hpp\n@@ -287,6 \u002B287,18 @@ public:\n    * Adding subscriptions, timers, services, etc. with blocking or long running\n    * callbacks may cause the function exceed the max_duration significantly.\n    *\n\u002B   * Work that is ready to be done is collected only once, and when collecting that work\n\u002B   * entities which may have multiple pieces of work ready will only be executed at most\n\u002B   * one time.\n\u002B   * The reason for this is that it is not possible to tell if, for example, a ready\n\u002B   * subscription has only one message ready or multiple without checking again.\n\u002B   * Because, in order to find out if there are multiple messages, one message must\n\u002B   * be taken and executed before checking again if that subscription is still ready.\n\u002B   * However, this function only checks for ready entities to work on once,\n\u002B   * and so it will never execute a single entity more than once per call to this function.\n\u002B   * See spin_all() variants for a function that will repeatedly work on a single entity\n\u002B   * in a single call.\n\u002B   *\n    * If there is no work to be done when this called, it will return immediately\n    * because the collecting of available work is non-blocking.\n    * Before each piece of ready work is executed this function checks if the\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "efe3f2bf932aabd70e875228e39b843103f2c4b3",
    "RawMessage": "Update taking API documentation. (#271)",
    "Changes": "diff --git rmw/include/rmw/rmw.h rmw/include/rmw/rmw.h\nindex 01c75b2..36871f0 100644\n--- rmw/include/rmw/rmw.h\n\u002B\u002B\u002B rmw/include/rmw/rmw.h\n@@ -1041,15 \u002B1041,79 @@ rmw_subscription_get_actual_qos(\n   const rmw_subscription_t * subscription,\n   rmw_qos_profile_t * qos);\n \n-/// Take an incoming message from a subscription.\n\u002B/// Take an incoming ROS message.\n /**\n- * Take an incoming ROS message from a given subscription.\n\u002B * Take a ROS message already received by the given subscription, removing it from internal queues.\n\u002B * This function will succeed even if no ROS message was received, but \u0060taken\u0060 will be false.\n  *\n- * \\param[in] subscription The subscription object to take from.\n- * \\param[out] ros_message The ROS message data on success.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * \\remarks The same ROS message cannot be taken twice.\n\u002B *   Callers do not have to deal with duplicates.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a ROS message is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n\u002B *   but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations that deserialize ROS messages received over\n\u002B *   the wire may need to perform additional memory allocations when dealing with\n\u002B *   unbounded (dynamically-sized) fields.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation\n\u002B *   guarantees when taking ROS messages with and without subscription allocations.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking regular ROS messages:\n\u002B *   - Access to the given ROS message is not synchronized.\n\u002B *     It is not safe to read or write \u0060ros_message\u0060 while rmw_take() uses it.\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 while rmw_take() uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while rmw_take() uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre Given \u0060ros_message\u0060 must be a valid message, whose type matches the message type support\n\u002B *   registered with the \u0060subscription\u0060 on creation.\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with the \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060ros_message\u0060 will remain a valid message.\n\u002B *   It will be left unchanged if this function fails early due to a logical error, such as an\n\u002B *   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n\u002B *   It will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take message from.\n\u002B * \\param[out] ros_message Type erased ROS message to write to.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060ros_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060\n\u002B *   implementation identifier does not match this implementation, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1061,16 \u002B1125,81 @@ rmw_take(\n   bool * taken,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Take an incoming message from a subscription with additional metadata.\n\u002B/// Take an incoming ROS message with its metadata.\n /**\n- * Take an incoming ROS message from a given subscription.\n\u002B * Same as rmw_take(), except it also takes ROS message metadata.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n  *\n- * \\param[in] subscription The subscription object to take from.\n- * \\param[out] ros_message The ROS message data on success.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info Additional message metadata.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a ROS message with its metadata is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n\u002B *   but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations that deserialize ROS messages received over\n\u002B *   the wire may need to perform additional memory allocations when dealing with\n\u002B *   unbounded (dynamically-sized) fields.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation\n\u002B *   guarantees when taking ROS messages with and without subscription allocations.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking regular ROS messages with metadata:\n\u002B *   - Access to the given ROS message is not synchronized.\n\u002B *     It is not safe to read or write \u0060ros_message\u0060 while rmw_take_with_info() uses it.\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 while rmw_take_with_info() uses it.\n\u002B *   - Access to the given ROS message metadata is not synchronized.\n\u002B *     It is not safe to read or write \u0060message_info\u0060 while rmw_take_with_info() uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while rmw_take_with_info()\n\u002B *     uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre Given \u0060ros_message\u0060 must be a valid message, whose type matches\n\u002B *   the message type support registered with the \u0060subscription\u0060 on creation.\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation\n\u002B *   initialized with rmw_subscription_allocation_init() with a message type support\n\u002B *   that matches the one registered with the \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060ros_message\u0060 will remain a valid message, and\n\u002B *   \u0060message_info\u0060, valid message metadata.\n\u002B *   Both will be left unchanged if this function fails early due to a logical error, such as\n\u002B *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n\u002B *   Both will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n\u002B * \\param[out] ros_message Type erased ROS message to write to.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[out] message_info Taken ROS message metadata.\n\u002B * \\param[in] allocation Pre-allocated memory to be used. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060ros_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_info\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060\n\u002B *   implementation identifier does not match this implementation, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1083,31 \u002B1212,107 @@ rmw_take_with_info(\n   rmw_message_info_t * message_info,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Take multiple incoming messages from a subscription with additional metadata.\n\u002B/// Take multiple incoming ROS messages with their metadata.\n /**\n- * Take a sequence of ROS messgages from a given subscription.\n\u002B * Take a sequence of consecutive ROS messages already received by the given\n\u002B * subscription, removing them from internal queues.\n\u002B * While \u0060count\u0060 ROS messages may be requested, fewer messages may have been\n\u002B * received by the subscription.\n\u002B * This function will only take what has been already received, and it will\n\u002B * succeed even if fewer (or zero) messages were received.\n\u002B * In this case, only currently available messages will be returned.\n\u002B * The \u0060taken\u0060 flag indicates the number of ROS messages actually taken.\n\u002B *\n\u002B * \\remarks Once taken, ROS messages in the sequence cannot be taken again.\n\u002B *   Callers do not have to deal with duplicates.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n  *\n- * While \u0060count\u0060 messages may be requested, fewer messages may be available on the subscription.\n- * In this case, only the currently available messages will be returned.\n- * The \u0060taken\u0060 flag indicates the number of messages actually taken.\n- * The method will return \u0060RMW_RET_OK\u0060 even in the case that fewer (or zero) messages were retrieved.\n- * from the subscription, and will \u0060RMW_RET_ERROR\u0060 in the case of unexpected errors.\n- * In the case that \u0060count\u0060 is zero, the function will return \u0060RMW_RET_INVALID_ARGUMENT\u0060.\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n  *\n- * \u0060message_sequence\u0060 and \u0060message_info_sequence\u0060 should be initialized and have sufficient capacity.\n- * It is not critical that the sequence sizes match, and they may be reused from previous calls.\n- * Both must be valid (not NULL) for the method to run successfully.\n\u002B * \\par Runtime behavior\n\u002B *   To take a sequence of ROS messages is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n\u002B *   but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n  *\n- * \\param[in] subscription The subscription object to take from.\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations that deserialize ROS messages received over\n\u002B *   the wire may need to perform additional memory allocations when dealing with\n\u002B *   unbounded (dynamically-sized) fields.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation\n\u002B *   guarantees when taking ROS messages with and without subscription allocations.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to\n\u002B *   preserve the order in the subscription queues, despite any concurrent takes.\n\u002B *   However, when taking a sequence of ROS messages with metadata:\n\u002B *   - Access to the given ROS message sequence is not synchronized.\n\u002B *     It is not safe to read or write \u0060message_sequence\u0060 while rmw_take_sequence() uses it.\n\u002B *   - Access to the given ROS message metadata sequence is not synchronized.\n\u002B *     It is not safe to read or write \u0060message_info_sequence\u0060 while rmw_take_sequence() uses it.\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 while rmw_take_sequence() uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while rmw_take_sequence()\n\u002B *     uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre Given \u0060message_sequence\u0060 must be a valid message sequence, initialized\n\u002B *   by rmw_message_sequence_init() and populated with ROS messages whose\n\u002B *   type matches the message type support registered with the \u0060subscription\u0060\n\u002B *   on creation.\n\u002B * \\pre Given \u0060message_info_sequence\u0060 must be a valid message metadata sequence,\n\u002B *   initialized by rmw_message_info_sequence_init().\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060message_sequence\u0060 will remain a valid message sequence, and\n\u002B *   \u0060message_info_sequence\u0060, a valid message metadata sequence.\n\u002B *   Both will be left unchanged if this function fails early due to a logical error, such as\n\u002B *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.\n\u002B *   Both will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n  * \\param[in] count Number of messages to attempt to take.\n- * \\param[out] message_sequence The sequence of ROS message data on success.\n- * \\param[out] message_info_sequence The sequence of additional message metadata on success.\n\u002B * \\param[out] message_sequence Sequence of type erase ROS messages to write to.\n\u002B *   Message sequence capacity has to be enough to hold all requested messages\n\u002B *   i.e. capacity has to be equal or greater than \u0060count\u0060.\n\u002B *   It does not have to match that of \u0060message_info_sequence\u0060.\n\u002B * \\param[out] message_info_sequence Sequence of additional message metadata.\n\u002B *   Message info sequence capacity has to be enough to hold all requested messages\n\u002B *   metadata i.e. capacity has to be equal or greater than \u0060count\u0060.\n\u002B *   It does not have to match that of \u0060message_sequence\u0060.\n  * \\param[out] taken Number of messages actually taken from subscription.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * \\param[in] allocation Pre-allocated memory to use. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n- * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if an argument is invalid, or\n- * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation failed, or\n- * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the rmw implementation does not match, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_sequence\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_info_sequence\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060count\u0060 is 0, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_sequence\u0060 capacity is less than \u0060count\u0060, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_info_sequence\u0060 capacity is less than \u0060count\u0060, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1121,21 \u002B1326,90 @@ rmw_take_sequence(\n   size_t * taken,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Take a message without deserializing it.\n\u002B/// Take an incoming ROS message as a byte stream.\n /**\n- * The message is taken in its serialized form. In contrast to rmw_take, the message\n- * is not deserialized in its ROS type but rather returned as a byte stream.\n- * The subscriber has to be registered for a specific type. But instead of receiving\n- * the message as its corresponding message type, it is taken as a byte stream.\n- * If needed, this byte stream can then be deserialized in a ROS message with a call to\n- * rmw_deserialize.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[out] serialized_message The destination in which to store the serialized message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * Take a ROS message already received by the given subscription, removing it from internal queues.\n\u002B * This function will succeed even if no ROS message was received, but \u0060taken\u0060 will be false.\n\u002B * Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.\n\u002B * If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().\n\u002B *\n\u002B * \\remarks The same ROS message, serialized or not, cannot be taken twice.\n\u002B *   Callers do not have to deal with duplicates.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a ROS message a byte stream is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n\u002B *   but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations may have to perform additional memory allocations\n\u002B *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n\u002B *   i.e. these implementations may have to resize the given byte stream.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation guarantees\n\u002B *   when taking serialized ROS messages with and without subscription allocations.\n\u002B * \\par\n\u002B *   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n\u002B *   their size using rmw_get_serialized_message_size() and resize \u0060serialized_message\u0060\n\u002B *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n\u002B *   on take.\n\u002B *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking serialized ROS messages:\n\u002B *   - Access to the given byte stream for serialized ROS messages is not synchronized.\n\u002B *     It is not safe to read or write \u0060serialized_message\u0060 while\n\u002B *     rmw_take_serialized_message() uses it.\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 while rmw_take_serialized_message() uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while\n\u002B *     rmw_take_serialized_message() uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned by\n\u002B *   rmw_create_subscription().\n\u002B * \\pre Given \u0060serialized_message\u0060 must be a valid serialized message, initialized by\n\u002B *   rmw_serialized_message_init().\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060serialized_message\u0060 will remain a valid serialized message.\n\u002B *   It will be left unchanged if this function fails early due to a logical error,\n\u002B *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n\u002B *   runtime error.\n\u002B *   It will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n\u002B * \\param[out] serialized_message Byte stream to write to.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[in] allocation Pre-allocated memory to use. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n- * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation failed, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060serialized_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1147,18 \u002B1421,89 @@ rmw_take_serialized_message(\n   bool * taken,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Take a message without deserializing it and with its additional message information.\n\u002B/// Take an incoming ROS message as a byte stream with its metadata.\n /**\n- * The same as rmw_take_serialized_message(), except it also includes the\n- * rmw_message_info_t.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[out] serialized_message The destination in which to store the serialized message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info A structure containing meta information about the taken message.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * Same as rmw_take_serialized_message(), except it also takes ROS message metadata.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a ROS message a byte stream with its metadata is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,\n\u002B *   but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations may have to perform additional memory allocations\n\u002B *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields\n\u002B *   i.e. these implementations may have to resize the given byte stream.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation guarantees\n\u002B *   when taking serialized ROS messages with and without subscription allocations.\n\u002B * \\par\n\u002B *   For ROS messages that only contain bounded (fixed-size) fields, callers can query\n\u002B *   their size using rmw_get_serialized_message_size() and resize \u0060serialized_message\u0060\n\u002B *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing\n\u002B *   on take.\n\u002B *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking serialized ROS messages with metadata:\n\u002B *   - Access to the given byte stream for serialized ROS messages is not synchronized.\n\u002B *     It is not safe to read or write \u0060serialized_message\u0060 while\n\u002B *     rmw_take_serialized_message_with_info() uses it.\n\u002B *   - Access to the given ROS message metadata is not synchronized.\n\u002B *     It is not safe to read or write \u0060message_info\u0060 while\n\u002B *     rmw_take_serialized_message_with_info() uses it.\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 while rmw_take_serialized_message_with_info()\n\u002B *     uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while\n\u002B *     rmw_take_serialized_message_with_info() uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060serialized_message\u0060 must be a valid serialized message, initialized by\n\u002B *   rmw_serialized_message_init().\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060serialized_message\u0060 will remain a valid serialized message, and \u0060message_info\u0060,\n\u002B *   valid message metadata.\n\u002B *   Both will be left unchanged if this function fails early due to a logical error,\n\u002B *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n\u002B *   runtime error.\n\u002B *   It will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n\u002B * \\param[out] serialized_message Byte stream to write to.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[out] message_info Taken ROS message metadata.\n\u002B * \\param[in] allocation Pre-allocated memory to use. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n- * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation failed, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060serialized_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_info\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1171,19 \u002B1516,81 @@ rmw_take_serialized_message_with_info(\n   rmw_message_info_t * message_info,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Take a loaned message.\n\u002B/// Take an incoming ROS message, loaned by the middleware.\n /**\n- * If capable, the middleware can loan messages containing incoming messages.\n- * The message is owned by the middleware and thus has to be returned\n- * with a call to \\sa rmw_return_loaned_message_from_subscription.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[inout] loaned_message The destination in which to store the loaned message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * Take a ROS message already received by the given subscription, removing it from internal queues.\n\u002B * This function will succeed even if no ROS message was received, but \u0060taken\u0060 will be false.\n\u002B * The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid\n\u002B * memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().\n\u002B *\n\u002B * \\remarks The same ROS message, loaned or not, cannot be taken twice.\n\u002B *   Callers do not have to deal with duplicates.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a loaned ROS message is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n\u002B *   nor for internal memory loaning pools, if any, to be replenished, but it is not\n\u002B *   guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations that deserialize ROS messages received over\n\u002B *   the wire may need to perform additional memory allocations when dealing with\n\u002B *   unbounded (dynamically-sized) fields.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation\n\u002B *   guarantees when taking loaned ROS messages with and without subscription allocations.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking loaned ROS messages:\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 nor \u0060loaned_message\u0060\n\u002B *     while rmw_take_loaned_message() uses them.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while\n\u002B *     rmw_take_loaned_message() uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060loaned_message\u0060 will remain unchanged, or point to a valid message if\n\u002B *   this function was successful and \u0060taken\u0060 is true.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n\u002B * \\param[inout] loaned_message Pointer to type erased ROS message taken\n\u002B *   and loaned by the middleware.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[in] allocation Pre-allocated memory to use. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n- * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation failed, or\n- * \\return \u0060RMW_RET_UNSUPPORTED\u0060 if the rmw_implementation does not support loaned_message, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060loaned_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060*loaned_message\u0060 is not NULL (to prevent leaks), or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n\u002B * \\return \u0060RMW_RET_UNSUPPORTED\u0060 if the implementation does not support loaned ROS messages, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1197,18 \u002B1604,83 @@ rmw_take_loaned_message(\n \n /// Take a loaned message and with its additional message information.\n /**\n- * If capable, the middleware can loan messages containing incoming messages.\n- * The message is owned by the middleware and thus has to be returned\n- * with a call to \\sa rmw_release_loaned_message.\n- *\n- * \\param[in] subscription Subscription object to take from.\n- * \\param[inout] loaned_message The destination in which to store the loaned message.\n- * \\param[out] taken Boolean flag indicating if a message was taken or not.\n- * \\param[out] message_info A structure containing meta information about the taken message.\n- * \\param[in] allocation Preallocated buffer to use (may be NULL).\n\u002B * Same as rmw_take_loaned_message(), except it also takes ROS message metadata.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To take a loaned ROS message with its metadata is a synchronous operation.\n\u002B *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive\n\u002B *   nor for internal memory loaning pools, if any, to be replenished, but it is not\n\u002B *   guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Memory allocation\n\u002B *   It is implementation defined whether memory will be allocated on take or not.\n\u002B *   For instance, implementations that deserialize ROS messages received over\n\u002B *   the wire may need to perform additional memory allocations when dealing with\n\u002B *   unbounded (dynamically-sized) fields.\n\u002B *   A subscription allocation, if provided, may or may not be used.\n\u002B *   Check the implementation documentation to learn about memory allocation\n\u002B *   guarantees when taking loaned ROS messages with and without subscription allocations.\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to take from the same subscription concurrently.\n\u002B *   However, when taking loaned ROS messages with metadata:\n\u002B *   - Access to given primitive data-type arguments is not synchronized.\n\u002B *     It is not safe to read or write \u0060taken\u0060 nor \u0060loaned_message\u0060\n\u002B *     while rmw_take_loaned_message_with_info() uses them.\n\u002B *   - Access to the given ROS message metadata is not synchronized.\n\u002B *     It is not safe to read or write \u0060message_info\u0060 while\n\u002B *     rmw_take_loaned_message_with_info() uses it.\n\u002B *   - Access to the given subscription allocation is not synchronized,\n\u002B *     unless specifically stated otherwise by the implementation.\n\u002B *     Thus, it is generally not safe to read or write \u0060allocation\u0060 while\n\u002B *     rmw_take_loaned_message_with_info() uses it.\n\u002B *     Check the implementation documentation to learn about subscription allocations\u0027\n\u002B *     thread-safety.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre If not NULL, given \u0060allocation\u0060 must be a valid subscription allocation initialized\n\u002B *   with rmw_subscription_allocation_init() with a message type support that matches the\n\u002B *   one registered with \u0060subscription\u0060 on creation.\n\u002B * \\post Given \u0060loaned_message\u0060 will remain unchanged, or point to a valid message if\n\u002B *   this function was successful and \u0060taken\u0060 is true.\n\u002B * \\post Given \u0060message_info\u0060 will remain valid message metadata.\n\u002B *   It will be left unchanged if this function fails early due to a logical error,\n\u002B *   such as an invalid argument, or in an unknown yet valid state if it fails due to a\n\u002B *   runtime error.\n\u002B *   It will also be left unchanged if this function succeeds but \u0060taken\u0060 is false.\n\u002B *\n\u002B * \\param[in] subscription Subscription to take ROS message from.\n\u002B * \\param[inout] loaned_message Pointer to type erased ROS message taken\n\u002B *   and loaned by the middleware.\n\u002B * \\param[out] taken Boolean flag indicating if a ROS message was taken or not.\n\u002B * \\param[out] message_info Taken ROS message metadata.\n\u002B * \\param[in] allocation Pre-allocated memory to use. May be NULL.\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n- * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation failed, or\n- * \\return \u0060RMW_RET_UNSUPPORTED\u0060 if the rmw_implementation does not support loaned_message, or\n\u002B * \\return \u0060RMW_RET_BAD_ALLOC\u0060 if memory allocation fails, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060loaned_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060*loaned_message\u0060 is not NULL to prevent leaks, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060taken\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060message_info\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n\u002B * \\return \u0060RMW_RET_UNSUPPORTED\u0060 if the implementation does not support loaned ROS messages, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -1221,16 \u002B1693,54 @@ rmw_take_loaned_message_with_info(\n   rmw_message_info_t * message_info,\n   rmw_subscription_allocation_t * allocation);\n \n-/// Return a loaned message previously taken from a subscription.\n\u002B/// Return a loaned ROS message previously taken from a subscription.\n /**\n- * After the taking a loaned message from the middleware, the middleware has to keep the memory\n- * for the loaned message alive and valid as long as the user is working with that loan.\n- * In order to indicate that the loaned message is no longer needed, the call to\n- * \\sa rmw_return_loaned_message_from_subscription tells the middleware that memory can be\n- * deallocated/destroyed.\n- *\n- * \\param[in] subscription The subscription instance which loaned the message.\n- * \\param[in] loaned_message The message to be released.\n\u002B * Tells the middleware that previously loaned ROS message is no longer needed by the caller.\n\u002B * If this function fails early due to a logical error, such as an invalid argument,\n\u002B * the loaned ROS message will be left unchanged.\n\u002B * Otherwise, ownership of the ROS message will be given back to the middleware.\n\u002B * It is up to the middleware what will be made of the returned ROS message.\n\u002B * It is undefined behavior to use a loaned ROS message after returning it.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | No\n\u002B * Thread-Safe        | Yes\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B *\n\u002B * \u003Ci\u003E[1] implementation defined, check implementation documentation.\u003C/i\u003E\n\u002B *\n\u002B * \\par Runtime behavior\n\u002B *   To return a loaned ROS message is a synchronous operation.\n\u002B *   It is also non-blocking, but it is not guaranteed to be lock-free.\n\u002B *   Generally speaking, implementations may synchronize access to internal resources using\n\u002B *   locks but are not allowed to wait for events with no guaranteed time bound (barring\n\u002B *   the effects of starvation due to OS scheduling).\n\u002B *\n\u002B * \\par Thread-safety\n\u002B *   Subscriptions are thread-safe objects, and so are all operations on them except for\n\u002B *   finalization.\n\u002B *   Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.\n\u002B *   However, since ownership of the loaned ROS message is given back to middleware and this\n\u002B *   transfer is not synchronized, it is not safe to return the same loaned ROS message\n\u002B *   concurrently.\n\u002B *\n\u002B * \\pre Given \u0060subscription\u0060 must be a valid subscription, as returned\n\u002B *   by rmw_create_subscription().\n\u002B * \\pre Given \u0060loaned_message\u0060 must be a loaned ROS message, previously taken from\n\u002B *   \u0060subscription\u0060 using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().\n\u002B *\n\u002B * \\param[in] subscription Subscription the ROS message was taken and loaned from.\n\u002B * \\param[in] loaned_message Loaned type erased ROS message to be returned to the middleware.\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060subscription\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if \u0060loaned_message\u0060 is NULL, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if the \u0060subscription\u0060 implementation\n\u002B *   identifier does not match this implementation, or\n\u002B * \\return \u0060RMW_RET_UNSUPPORTED\u0060 if the implementation does not support loaned ROS messages, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n RMW_WARN_UNUSED\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "f3fc36cc06395035748d71c672cb3e40995eb850",
    "RawMessage": "Maintaining consistency of automatically putting time stamps in the service and action calls similiar to publishing in rostopics. (#961)",
    "Changes": "diff --git ros2action/ros2action/verb/send_goal.py ros2action/ros2action/verb/send_goal.py\nindex 97970a4..f1aa2c6 100644\n--- ros2action/ros2action/verb/send_goal.py\n\u002B\u002B\u002B ros2action/ros2action/verb/send_goal.py\n@@ -109,14 \u002B109,20 @@ def send_goal(action_name, action_type, goal_values, feedback_callback):\n \n         goal = action_module.Goal()\n \n\u002B        timestamp_fields = []\n         try:\n-            set_message_fields(goal, goal_dict)\n\u002B            timestamp_fields = set_message_fields(\n\u002B                goal, goal_dict, expand_header_auto=True, expand_time_now=True)\n         except Exception as ex:\n             return \u0027Failed to populate message fields: {!r}\u0027.format(ex)\n \n         print(\u0027Waiting for an action server to become available...\u0027)\n         action_client.wait_for_server()\n \n\u002B        stamp_now = node.get_clock().now().to_msg()\n\u002B        for field_setter in timestamp_fields:\n\u002B            field_setter(stamp_now)\n\u002B\n         print(\u0027Sending goal:\\n     {}\u0027.format(message_to_yaml(goal)))\n         goal_future = action_client.send_goal_async(goal, feedback_callback)\n         rclpy.spin_until_future_complete(node, goal_future)\n@@ -175,6 \u002B181,7 @@ def send_goal(action_name, action_type, goal_values, feedback_callback):\n \n         print(\u0027Result:\\n    {}\u0027.format(message_to_yaml(result.result)))\n         print(\u0027Goal finished with status: {}\u0027.format(_goal_status_to_string(result.status)))\n\u002B\n     finally:\n         if action_client is not None:\n             action_client.destroy()\ndiff --git ros2service/ros2service/verb/call.py ros2service/ros2service/verb/call.py\nindex 4f75f54..7ee5dd8 100644\n--- ros2service/ros2service/verb/call.py\n\u002B\u002B\u002B ros2service/ros2service/verb/call.py\n@@ -96,8 \u002B96,10 @@ def requester(service_type, service_name, values, period):\n \n         request = srv_module.Request()\n \n\u002B        timestamp_fields = []\n         try:\n-            set_message_fields(request, values_dictionary)\n\u002B            timestamp_fields = set_message_fields(\n\u002B                request, values_dictionary, expand_header_auto=True, expand_time_now=True)\n         except Exception as e:\n             return \u0027Failed to populate field: {0}\u0027.format(e)\n \n@@ -106,6 \u002B108,9 @@ def requester(service_type, service_name, values, period):\n             cli.wait_for_service()\n \n         while True:\n\u002B            stamp_now = node.get_clock().now().to_msg()\n\u002B            for field_setter in timestamp_fields:\n\u002B                field_setter(stamp_now)\n             print(\u0027requester: making request: %r\\n\u0027 % request)\n             last_call = time.time()\n             future = cli.call_async(request)\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "40aae88941629868ce7ff8bf3dcd1e26083bc471",
    "RawMessage": "Increase rmw testing coverage",
    "Changes": "diff --git rmw/test/allocator_testing_utils.h rmw/test/allocator_testing_utils.h\nnew file mode 100644\nindex 0000000..c7f4c54\n--- /dev/null\n\u002B\u002B\u002B rmw/test/allocator_testing_utils.h\n@@ -0,0 \u002B1,94 @@\n\u002B// Copyright 2017 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef ALLOCATOR_TESTING_UTILS_H_\n\u002B#define ALLOCATOR_TESTING_UTILS_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B#include \u003Cstddef.h\u003E\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B\n\u002Btypedef struct __failing_allocator_state\n\u002B{\n\u002B  bool is_failing;\n\u002B} __failing_allocator_state;\n\u002B\n\u002Bvoid *\n\u002Bfailing_malloc(size_t size, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().allocate(size, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid *\n\u002Bfailing_realloc(void * pointer, size_t size, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().reallocate(\n\u002B    pointer, size, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bfailing_free(void * pointer, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return;\n\u002B  }\n\u002B  rcutils_get_default_allocator().deallocate(pointer, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bvoid *\n\u002Bfailing_calloc(size_t number_of_elements, size_t size_of_element, void * state)\n\u002B{\n\u002B  if (((__failing_allocator_state *)state)-\u003Eis_failing) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  return rcutils_get_default_allocator().zero_allocate(\n\u002B    number_of_elements, size_of_element, rcutils_get_default_allocator().state);\n\u002B}\n\u002B\n\u002Bstatic inline rcutils_allocator_t\n\u002Bget_failing_allocator(void)\n\u002B{\n\u002B  static __failing_allocator_state state;\n\u002B  state.is_failing = true;\n\u002B  auto failing_allocator = rcutils_get_default_allocator();\n\u002B  failing_allocator.allocate = failing_malloc;\n\u002B  failing_allocator.deallocate = failing_free;\n\u002B  failing_allocator.reallocate = failing_realloc;\n\u002B  failing_allocator.zero_allocate = failing_calloc;\n\u002B  failing_allocator.state = \u0026state;\n\u002B  return failing_allocator;\n\u002B}\n\u002B\n\u002Bstatic inline void\n\u002Bset_failing_allocator_is_failing(rcutils_allocator_t \u0026 failing_allocator, bool state)\n\u002B{\n\u002B  ((__failing_allocator_state *)failing_allocator.state)-\u003Eis_failing = state;\n\u002B}\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // ALLOCATOR_TESTING_UTILS_H_\ndiff --git rmw/test/test_message_sequence.cpp rmw/test/test_message_sequence.cpp\nindex bfaf6e5..f323e1b 100644\n--- rmw/test/test_message_sequence.cpp\n\u002B\u002B\u002B rmw/test/test_message_sequence.cpp\n@@ -16,6 \u002B16,8 @@\n \n #include \u0022rcutils/allocator.h\u0022\n \n\u002B#include \u0022./allocator_testing_utils.h\u0022\n\u002B#include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/message_sequence.h\u0022\n \n TEST(test_message_info_sequence, default_initialization) {\n@@ -49,6 \u002B51,31 @@ TEST(test_message_info_sequence, initialization_with_size) {\n   EXPECT_EQ(nullptr, info_sequence.data);\n }\n \n\u002BTEST(test_message_info_sequence, bad_arguments) {\n\u002B  auto info_sequence = rmw_get_zero_initialized_message_info_sequence();\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_info_sequence_init(nullptr, 5u, \u0026allocator));\n\u002B  EXPECT_EQ(0u, info_sequence.size);\n\u002B  EXPECT_EQ(0u, info_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, info_sequence.data);\n\u002B  rmw_reset_error();\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_info_sequence_init(\u0026info_sequence, 5u, nullptr));\n\u002B  EXPECT_EQ(0u, info_sequence.size);\n\u002B  EXPECT_EQ(0u, info_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, info_sequence.data);\n\u002B  rmw_reset_error();\n\u002B\n\u002B  rcutils_allocator_t failing_allocator = get_failing_allocator();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_BAD_ALLOC, rmw_message_info_sequence_init(\u0026info_sequence, 5u, \u0026failing_allocator));\n\u002B  EXPECT_EQ(0u, info_sequence.size);\n\u002B  EXPECT_EQ(0u, info_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, info_sequence.data);\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n TEST(test_message_sequence, default_initialization) {\n   auto message_sequence = rmw_get_zero_initialized_message_sequence();\n   auto allocator = rcutils_get_default_allocator();\n@@ -79,3 \u002B106,28 @@ TEST(test_message_sequence, initialization_with_size) {\n   EXPECT_EQ(0u, message_sequence.capacity);\n   EXPECT_EQ(nullptr, message_sequence.data);\n }\n\u002B\n\u002BTEST(test_message_sequence, bad_arguments) {\n\u002B  auto message_sequence = rmw_get_zero_initialized_message_sequence();\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_sequence_init(nullptr, 5u, \u0026allocator));\n\u002B  EXPECT_EQ(0u, message_sequence.size);\n\u002B  EXPECT_EQ(0u, message_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, message_sequence.data);\n\u002B  rmw_reset_error();\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_message_sequence_init(\u0026message_sequence, 5u, nullptr));\n\u002B  EXPECT_EQ(0u, message_sequence.size);\n\u002B  EXPECT_EQ(0u, message_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, message_sequence.data);\n\u002B  rmw_reset_error();\n\u002B\n\u002B  rcutils_allocator_t failing_allocator = get_failing_allocator();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_BAD_ALLOC, rmw_message_sequence_init(\u0026message_sequence, 5u, \u0026failing_allocator));\n\u002B  EXPECT_EQ(0u, message_sequence.size);\n\u002B  EXPECT_EQ(0u, message_sequence.capacity);\n\u002B  EXPECT_EQ(nullptr, message_sequence.data);\n\u002B  rmw_reset_error();\n\u002B}\ndiff --git rmw/test/test_security_options.cpp rmw/test/test_security_options.cpp\nindex e8ccd6f..5e0550c 100644\n--- rmw/test/test_security_options.cpp\n\u002B\u002B\u002B rmw/test/test_security_options.cpp\n@@ -14,6 \u002B14,7 @@\n \n #include \u0022gmock/gmock.h\u0022\n \n\u002B#include \u0022./allocator_testing_utils.h\u0022\n #include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/security_options.h\u0022\n \n@@ -31,6 \u002B32,38 @@ TEST(rmw_security_options, get_default_init)\n   EXPECT_EQ(options.security_root_path, nullptr);\n }\n \n\u002BTEST(rmw_security_options, options_copy) {\n\u002B  rmw_security_options_t source = rmw_get_default_security_options();\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_security_options_set_root_path(\u0022root_path\u0022, \u0026allocator, \u0026source));\n\u002B\n\u002B  rmw_security_options_t destination = rmw_get_zero_initialized_security_options();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_INVALID_ARGUMENT,\n\u002B    rmw_security_options_copy(nullptr, \u0026allocator, \u0026destination));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_INVALID_ARGUMENT,\n\u002B    rmw_security_options_copy(\u0026source, nullptr, \u0026destination));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_INVALID_ARGUMENT,\n\u002B    rmw_security_options_copy(\u0026source, \u0026allocator, nullptr));\n\u002B\n\u002B\n\u002B  rcutils_allocator_t failing_allocator = get_failing_allocator();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_BAD_ALLOC,\n\u002B    rmw_security_options_copy(\u0026source, \u0026failing_allocator, \u0026destination));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_OK,\n\u002B    rmw_security_options_copy(\u0026source, \u0026allocator, \u0026destination));\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(\u0026source, \u0026allocator));\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(\u0026destination, \u0026allocator));\n\u002B}\n\u002B\n TEST(rmw_security_options, security_root_path) {\n   rmw_security_options_t options = rmw_get_default_security_options();\n   EXPECT_EQ(options.enforce_security, RMW_SECURITY_ENFORCEMENT_PERMISSIVE);\n@@ -60,3 \u002B93,16 @@ TEST(rmw_security_options, security_root_path) {\n \n   EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(\u0026options, \u0026allocator));\n }\n\u002B\n\u002BTEST(rmw_security_options, security_options_fini) {\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_security_options_fini(nullptr, \u0026allocator));\n\u002B\n\u002B  rmw_security_options_t options = rmw_get_zero_initialized_security_options();\n\u002B  EXPECT_EQ(RMW_RET_INVALID_ARGUMENT, rmw_security_options_fini(\u0026options, nullptr));\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(\u0026options, \u0026allocator));\n\u002B\n\u002B  options = rmw_get_default_security_options();\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_security_options_fini(\u0026options, \u0026allocator));\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcutils",
    "SHA": "82aa706a292b778f54692e7392f4ddafccfb4450",
    "RawMessage": "Remove dst_size from strlen usage (#353)",
    "Changes": "diff --git src/error_handling_helpers.h src/error_handling_helpers.h\nindex 70acb4e..4914c4f 100644\n--- src/error_handling_helpers.h\n\u002B\u002B\u002B src/error_handling_helpers.h\n@@ -54,7 \u002B54,7 @@ __rcutils_copy_string(char * dst, size_t dst_size, const char * src)\n   assert(dst_size \u003E 0);\n   assert(src != NULL);\n   // doesn\u0027t matter how long src actually is if it is longer than dst, so limit to dst \u002B 1\n-  size_t src_length = strnlen(src, dst_size);\n\u002B  size_t src_length = strlen(src);\n   size_t size_to_copy = src_length;\n   // the destination must be one byte bigger to store the NULL terminating character\n   if (src_length \u003E= dst_size) {\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "e439c8f46609174ebf5caa35bb8e2cf13b3d510c",
    "RawMessage": "document special costmap color for value 0 (#1199)",
    "Changes": "diff --git docs/FEATURES.md docs/FEATURES.md\nindex c546ded5..ef6204be 100644\n--- docs/FEATURES.md\n\u002B\u002B\u002B docs/FEATURES.md\n@@ -32,8 \u002B32,8 @@ In general, values between 0 and 100 are regarded as valid (often interpreted as\n * *Map:* Paint valid points between 0 and 100 from white (0) to black (100). \n   Paint valid value -1 in a blueish, greenish, grayish color (it might be used to indicate unchartered territory for instance). \n   Invalid points between 101 and 127 are painted in green, while invalid negative numbers are painted in shades from red to yellow.\n-* *Costmap:* Paint valid points between 0 and 98 from blue to red. \n-  Paint points with value 99 in cyan (obstacle value) and points with value 100 in purple (lethal obstacle). \n\u002B* *Costmap:* Paint valid points between 1 and 98 from blue to red. \n\u002B  Paint points with value 0 in black, points with value 99 in cyan (obstacle value) and points with value 100 in purple (lethal obstacle). \n   The valid value -1 is painted in a blueish, greenish, grayish color. \n   Invalid points between 101 and 127 are painted in green, while invalid negative numbers are painted in shades from red to yellow.\n \n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "common_interfaces",
    "SHA": "467f4489799b7fa13e8270693d36e05603aa864a",
    "RawMessage": "Port pointcloud creation to numpy. (#175)",
    "Changes": "diff --git .gitignore .gitignore\nindex b8bd026..9cfa5df 100644\n--- .gitignore\n\u002B\u002B\u002B .gitignore\n@@ -26,3 \u002B26,7 @@\n *.exe\n *.out\n *.app\n\u002B\n\u002B# Python temporary files\n\u002B*.pyc\n\u002B__pycache__/\ndiff --git sensor_msgs_py/package.xml sensor_msgs_py/package.xml\nindex 670488c..8558d1d 100644\n--- sensor_msgs_py/package.xml\n\u002B\u002B\u002B sensor_msgs_py/package.xml\n@@ -15,6 \u002B15,7 @@\n   \u003Cauthor email=\u0022sebastian.grans@gmail.com\u0022\u003ESebastian Grans\u003C/author\u003E\n \n   \u003Cexec_depend\u003Esensor_msgs\u003C/exec_depend\u003E\n\u002B  \u003Cexec_depend\u003Epython3-numpy\u003C/exec_depend\u003E\n \n   \u003Ctest_depend\u003Eament_copyright\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_flake8\u003C/test_depend\u003E\ndiff --git sensor_msgs_py/sensor_msgs_py/point_cloud2.py sensor_msgs_py/sensor_msgs_py/point_cloud2.py\nindex 4a56c3c..55c37fc 100644\n--- sensor_msgs_py/sensor_msgs_py/point_cloud2.py\n\u002B\u002B\u002B sensor_msgs_py/sensor_msgs_py/point_cloud2.py\n@@ -37,27 \u002B37,37 @@ https://github.com/ros/common_msgs/blob/f48b00d43cdb82ed9367e0956db332484f676598\n sensor_msgs/src/sensor_msgs/point_cloud2.py\n \u0022\u0022\u0022\n \n\u002Bimport array\n from collections import namedtuple\n-import ctypes\n-import math\n-import struct\n import sys\n\u002Bfrom typing import Iterable, List, NamedTuple, Optional\n \n\u002Bimport numpy as np\n\u002Bfrom numpy.lib.recfunctions import (structured_to_unstructured,\n\u002B                                    unstructured_to_structured)\n from sensor_msgs.msg import PointCloud2, PointField\n\u002Bfrom std_msgs.msg import Header\n \n \n _DATATYPES = {}\n-_DATATYPES[PointField.INT8] = (\u0027b\u0027, 1)\n-_DATATYPES[PointField.UINT8] = (\u0027B\u0027, 1)\n-_DATATYPES[PointField.INT16] = (\u0027h\u0027, 2)\n-_DATATYPES[PointField.UINT16] = (\u0027H\u0027, 2)\n-_DATATYPES[PointField.INT32] = (\u0027i\u0027, 4)\n-_DATATYPES[PointField.UINT32] = (\u0027I\u0027, 4)\n-_DATATYPES[PointField.FLOAT32] = (\u0027f\u0027, 4)\n-_DATATYPES[PointField.FLOAT64] = (\u0027d\u0027, 8)\n-\n-\n-def read_points(cloud, field_names=None, skip_nans=False, uvs=[]):\n\u002B_DATATYPES[PointField.INT8] = np.dtype(np.int8)\n\u002B_DATATYPES[PointField.UINT8] = np.dtype(np.uint8)\n\u002B_DATATYPES[PointField.INT16] = np.dtype(np.int16)\n\u002B_DATATYPES[PointField.UINT16] = np.dtype(np.uint16)\n\u002B_DATATYPES[PointField.INT32] = np.dtype(np.int32)\n\u002B_DATATYPES[PointField.UINT32] = np.dtype(np.uint32)\n\u002B_DATATYPES[PointField.FLOAT32] = np.dtype(np.float32)\n\u002B_DATATYPES[PointField.FLOAT64] = np.dtype(np.float64)\n\u002B\n\u002BDUMMY_FIELD_PREFIX = \u0027unnamed_field\u0027\n\u002B\n\u002B\n\u002Bdef read_points(\n\u002B        cloud: PointCloud2,\n\u002B        field_names: Optional[List[str]] = None,\n\u002B        skip_nans: bool = False,\n\u002B        uvs: Optional[Iterable] = None,\n\u002B        reshape_organized_cloud: bool = False) -\u003E np.ndarray:\n     \u0022\u0022\u0022\n     Read points from a sensor_msgs.PointCloud2 message.\n \n@@ -67,56 \u002B77,92 @@ def read_points(cloud, field_names=None, skip_nans=False, uvs=[]):\n     :param skip_nans: If True, then don\u0027t return any point with a NaN value.\n                       (Type: Bool, Default: False)\n     :param uvs: If specified, then only return the points at the given\n-        coordinates. (Type: Iterable, Default: empty list)\n-    :return: Generator which yields a list of values for each point.\n\u002B        coordinates. (Type: Iterable, Default: None)\n\u002B    :param reshape_organized_cloud: Returns the array as an 2D organized point cloud if set.\n\u002B    :return: Structured NumPy array containing all points.\n     \u0022\u0022\u0022\n     assert isinstance(cloud, PointCloud2), \\\n-        \u0027cloud is not a sensor_msgs.msg.PointCloud2\u0027\n-    fmt = _get_struct_fmt(cloud.is_bigendian, cloud.fields, field_names)\n-    width, height, point_step, row_step, data, isnan = \\\n-        cloud.width, cloud.height, \\\n-        cloud.point_step, cloud.row_step, \\\n-        cloud.data, math.isnan\n-\n-    unpack_from = struct.Struct(fmt).unpack_from\n-\n-    if skip_nans:\n-        if uvs:\n-            for u, v in uvs:\n-                p = unpack_from(data, (row_step * v) \u002B (point_step * u))\n-                has_nan = False\n-                for pv in p:\n-                    if isnan(pv):\n-                        has_nan = True\n-                        break\n-                if not has_nan:\n-                    yield p\n-        else:\n-            for v in range(height):\n-                offset = row_step * v\n-                for u in range(width):\n-                    p = unpack_from(data, offset)\n-                    has_nan = False\n-                    for pv in p:\n-                        if isnan(pv):\n-                            has_nan = True\n-                            break\n-                    if not has_nan:\n-                        yield p\n-                    offset \u002B= point_step\n-    else:\n-        if uvs:\n-            for u, v in uvs:\n-                yield unpack_from(data, (row_step * v) \u002B (point_step * u))\n-        else:\n-            for v in range(height):\n-                offset = row_step * v\n-                for u in range(width):\n-                    yield unpack_from(data, offset)\n-                    offset \u002B= point_step\n\u002B        \u0027Cloud is not a sensor_msgs.msg.PointCloud2\u0027\n\u002B\n\u002B    # Cast bytes to numpy array\n\u002B    points = np.ndarray(\n\u002B        shape=(cloud.width * cloud.height, ),\n\u002B        dtype=dtype_from_fields(cloud.fields),\n\u002B        buffer=cloud.data)\n\u002B\n\u002B    # Keep only the requested fields\n\u002B    if field_names is not None:\n\u002B        assert all(field_name in points.dtype.names for field_name in field_names), \\\n\u002B            \u0027Requests field is not in the fields of the PointCloud!\u0027\n\u002B        # Mask fields\n\u002B        points = points[list(field_names)]\n\u002B\n\u002B    # Swap array if byte order does not match\n\u002B    if bool(sys.byteorder != \u0027little\u0027) != bool(cloud.is_bigendian):\n\u002B        points = points.byteswap(inplace=True)\n\u002B\n\u002B    # Check if we want to drop points with nan values\n\u002B    if skip_nans and not cloud.is_dense:\n\u002B        # Init mask which selects all points\n\u002B        not_nan_mask = np.ones(len(points), dtype=bool)\n\u002B        for field_name in points.dtype.names:\n\u002B            # Only keep points without any non values in the mask\n\u002B            not_nan_mask = np.logical_and(\n\u002B                not_nan_mask, ~np.isnan(points[field_name]))\n\u002B        # Select these points\n\u002B        points = points[not_nan_mask]\n\u002B\n\u002B    # Select points indexed by the uvs field\n\u002B    if uvs is not None:\n\u002B        # Don\u0027t convert to numpy array if it is already one\n\u002B        if not isinstance(uvs, np.ndarray):\n\u002B            uvs = np.fromiter(uvs, int)\n\u002B        # Index requested points\n\u002B        points = points[uvs]\n\u002B\n\u002B    # Cast into 2d array if cloud is \u0027organized\u0027\n\u002B    if reshape_organized_cloud and cloud.height \u003E 1:\n\u002B        points = points.reshape(cloud.width, cloud.height)\n\u002B\n\u002B    return points\n\u002B\n\u002B\n\u002Bdef read_points_numpy(\n\u002B        cloud: PointCloud2,\n\u002B        field_names: Optional[List[str]] = None,\n\u002B        skip_nans: bool = False,\n\u002B        uvs: Optional[Iterable] = None,\n\u002B        reshape_organized_cloud: bool = False) -\u003E np.ndarray:\n\u002B    \u0022\u0022\u0022\n\u002B    Read equally typed fields from sensor_msgs.PointCloud2 message as a unstructured numpy array.\n \n\u002B    This method is better suited if one wants to perform math operations\n\u002B    on e.g. all x,y,z fields.\n\u002B    But it is limited to fields with the same dtype as unstructured numpy arrays\n\u002B    only contain one dtype.\n \n-def read_points_list(cloud, field_names=None, skip_nans=False, uvs=[]):\n\u002B    :param cloud: The point cloud to read from sensor_msgs.PointCloud2.\n\u002B    :param field_names: The names of fields to read. If None, read all fields.\n\u002B                        (Type: Iterable, Default: None)\n\u002B    :param skip_nans: If True, then don\u0027t return any point with a NaN value.\n\u002B                      (Type: Bool, Default: False)\n\u002B    :param uvs: If specified, then only return the points at the given\n\u002B        coordinates. (Type: Iterable, Default: None)\n\u002B    :param reshape_organized_cloud: Returns the array as an 2D organized point cloud if set.\n\u002B    :return: Numpy array containing all points.\n\u002B    \u0022\u0022\u0022\n\u002B    assert all(cloud.fields[0].datatype == field.datatype for field in cloud.fields[1:]), \\\n\u002B        \u0027All fields need to have the same datatype. Use \u0060read_points()\u0060 otherwise.\u0027\n\u002B    structured_numpy_array = read_points(\n\u002B        cloud, field_names, skip_nans, uvs, reshape_organized_cloud)\n\u002B    return structured_to_unstructured(structured_numpy_array)\n\u002B\n\u002B\n\u002Bdef read_points_list(\n\u002B        cloud: PointCloud2,\n\u002B        field_names: Optional[List[str]] = None,\n\u002B        skip_nans: bool = False,\n\u002B        uvs: Optional[Iterable] = None) -\u003E List[NamedTuple]:\n     \u0022\u0022\u0022\n     Read points from a sensor_msgs.PointCloud2 message.\n \n@@ -129,7 \u002B175,7 @@ def read_points_list(cloud, field_names=None, skip_nans=False, uvs=[]):\n     :param skip_nans: If True, then don\u0027t return any point with a NaN value.\n                       (Type: Bool, Default: False)\n     :param uvs: If specified, then only return the points at the given\n-                coordinates. (Type: Iterable, Default: empty list]\n\u002B                coordinates. (Type: Iterable, Default: None]\n     :return: List of namedtuples containing the values for each point\n     \u0022\u0022\u0022\n     assert isinstance(cloud, PointCloud2), \\\n@@ -144,7 \u002B190,53 @@ def read_points_list(cloud, field_names=None, skip_nans=False, uvs=[]):\n                                                 skip_nans, uvs)]\n \n \n-def create_cloud(header, fields, points):\n\u002Bdef dtype_from_fields(fields: Iterable[PointField]) -\u003E np.dtype:\n\u002B    \u0022\u0022\u0022\n\u002B    Convert a Iterable of sensor_msgs.msg.PointField messages to a np.dtype.\n\u002B\n\u002B    :param fields: The point cloud fields.\n\u002B                   (Type: iterable of sensor_msgs.msg.PointField)\n\u002B    :returns: NumPy datatype\n\u002B    \u0022\u0022\u0022\n\u002B    # Create a lists containing the names, offsets and datatypes of all fields\n\u002B    field_names = []\n\u002B    field_offsets = []\n\u002B    field_datatypes = []\n\u002B    for i, field in enumerate(fields):\n\u002B        # Datatype as numpy datatype\n\u002B        datatype = _DATATYPES[field.datatype]\n\u002B        # Name field\n\u002B        if field.name == \u0027\u0027:\n\u002B            name = f\u0027{DUMMY_FIELD_PREFIX}_{i}\u0027\n\u002B        else:\n\u002B            name = field.name\n\u002B        # Handle fields with count \u003E 1 by creating subfields with a suffix consiting\n\u002B        # of \u0022_\u0022 followed by the subfield counter [0 -\u003E (count - 1)]\n\u002B        assert field.count \u003E 0, \u0022Can\u0027t process fields with count = 0.\u0022\n\u002B        for a in range(field.count):\n\u002B            # Add suffix if we have multiple subfields\n\u002B            if field.count \u003E 1:\n\u002B                subfield_name = f\u0027{name}_{a}\u0027\n\u002B            else:\n\u002B                subfield_name = name\n\u002B            assert subfield_name not in field_names, \u0027Duplicate field names are not allowed!\u0027\n\u002B            field_names.append(subfield_name)\n\u002B            # Create new offset that includes subfields\n\u002B            field_offsets.append(field.offset \u002B a * datatype.itemsize)\n\u002B            field_datatypes.append(datatype.str)\n\u002B\n\u002B    # Create a tuple for each field containing name and data type\n\u002B    return np.dtype({\n\u002B        \u0027names\u0027: field_names,\n\u002B        \u0027formats\u0027: field_datatypes,\n\u002B        \u0027offsets\u0027: field_offsets,\n\u002B    })\n\u002B\n\u002B\n\u002Bdef create_cloud(\n\u002B        header: Header,\n\u002B        fields: Iterable[PointField],\n\u002B        points: Iterable) -\u003E PointCloud2:\n     \u0022\u0022\u0022\n     Create a sensor_msgs.msg.PointCloud2 message.\n \n@@ -157,28 \u002B249,61 @@ def create_cloud(header, fields, points):\n                    the fields parameter)\n     :return: The point cloud as sensor_msgs.msg.PointCloud2\n     \u0022\u0022\u0022\n-    cloud_struct = struct.Struct(_get_struct_fmt(False, fields))\n-\n-    buff = ctypes.create_string_buffer(cloud_struct.size * len(points))\n-\n-    point_step, pack_into = cloud_struct.size, cloud_struct.pack_into\n-    offset = 0\n-    for p in points:\n-        pack_into(buff, offset, *p)\n-        offset \u002B= point_step\n-\n-    return PointCloud2(header=header,\n-                       height=1,\n-                       width=len(points),\n-                       is_dense=False,\n-                       is_bigendian=False,\n-                       fields=fields,\n-                       point_step=cloud_struct.size,\n-                       row_step=cloud_struct.size * len(points),\n-                       data=buff.raw)\n-\n-\n-def create_cloud_xyz32(header, points):\n\u002B    # Check if input is numpy array\n\u002B    if isinstance(points, np.ndarray):\n\u002B        # Check if this is an unstructured array\n\u002B        if points.dtype.names is None:\n\u002B            assert all(fields[0].datatype == field.datatype for field in fields[1:]), \\\n\u002B                \u0027All fields need to have the same datatype. Pass a structured NumPy array \\\n\u002B                    with multiple dtypes otherwise.\u0027\n\u002B            # Convert unstructured to structured array\n\u002B            points = unstructured_to_structured(\n\u002B                points,\n\u002B                dtype=dtype_from_fields(fields))\n\u002B        else:\n\u002B            assert points.dtype == dtype_from_fields(fields), \\\n\u002B                \u0027PointFields and structured NumPy array dtype do not match for all fields! \\\n\u002B                    Check their field order, names and types.\u0027\n\u002B    else:\n\u002B        # Cast python objects to structured NumPy array (slow)\n\u002B        points = np.array(\n\u002B            # Points need to be tuples in the structured array\n\u002B            list(map(tuple, points)),\n\u002B            dtype=dtype_from_fields(fields))\n\u002B\n\u002B    # Handle organized clouds\n\u002B    assert len(points.shape) \u003C= 2, \\\n\u002B        \u0027Too many dimensions for organized cloud! \\\n\u002B            Points can only be organized in max. two dimensional space\u0027\n\u002B    height = 1\n\u002B    width = points.shape[0]\n\u002B    # Check if input points are an organized cloud (2D array of points)\n\u002B    if len(points.shape) == 2:\n\u002B        height = points.shape[1]\n\u002B\n\u002B    # Convert numpy points to array.array\n\u002B    memory_view = memoryview(points)\n\u002B    casted = memory_view.cast(\u0027B\u0027)\n\u002B    array_array = array.array(\u0027B\u0027)\n\u002B    array_array.frombytes(casted)\n\u002B\n\u002B    # Put everything together\n\u002B    cloud = PointCloud2(\n\u002B        header=header,\n\u002B        height=height,\n\u002B        width=width,\n\u002B        is_dense=False,\n\u002B        is_bigendian=sys.byteorder != \u0027little\u0027,\n\u002B        fields=fields,\n\u002B        point_step=points.dtype.itemsize,\n\u002B        row_step=(points.dtype.itemsize * width))\n\u002B    # Set cloud via property instead of the constructor because of the bug described in\n\u002B    # https://github.com/ros2/common_interfaces/issues/176\n\u002B    cloud.data = array_array\n\u002B    return cloud\n\u002B\n\u002B\n\u002Bdef create_cloud_xyz32(header: Header, points: Iterable) -\u003E PointCloud2:\n     \u0022\u0022\u0022\n     Create a sensor_msgs.msg.PointCloud2 message with (x, y, z) fields.\n \n@@ -193,23 \u002B318,3 @@ def create_cloud_xyz32(header, points):\n               PointField(name=\u0027z\u0027, offset=8,\n                          datatype=PointField.FLOAT32, count=1)]\n     return create_cloud(header, fields, points)\n-\n-\n-def _get_struct_fmt(is_bigendian, fields, field_names=None):\n-    fmt = \u0027\u003E\u0027 if is_bigendian else \u0027\u003C\u0027\n-\n-    offset = 0\n-    for field in (f for f in sorted(fields, key=lambda f: f.offset)\n-                  if field_names is None or f.name in field_names):\n-        if offset \u003C field.offset:\n-            fmt \u002B= \u0027x\u0027 * (field.offset - offset)\n-            offset = field.offset\n-        if field.datatype not in _DATATYPES:\n-            print(\u0027Skipping unknown PointField datatype [%d]\u0027 %\n-                  field.datatype, file=sys.stderr)\n-        else:\n-            datatype_fmt, datatype_length = _DATATYPES[field.datatype]\n-            fmt \u002B= field.count * datatype_fmt\n-            offset \u002B= field.count * datatype_length\n-\n-    return fmt\ndiff --git sensor_msgs_py/test/test_point_cloud2.py sensor_msgs_py/test/test_point_cloud2.py\nindex f2851b0..95aa09e 100644\n--- sensor_msgs_py/test/test_point_cloud2.py\n\u002B\u002B\u002B sensor_msgs_py/test/test_point_cloud2.py\n@@ -27,21 \u002B27,21 @@\n # POSSIBILITY OF SUCH DAMAGE.\n \n \n\u002Bimport sys\n import unittest\n \n import numpy as np\n-\n-from sensor_msgs.msg import PointCloud2\n-from sensor_msgs.msg import PointField\n\u002Bfrom numpy.lib.recfunctions import structured_to_unstructured\n\u002Bfrom sensor_msgs.msg import PointCloud2, PointField\n from sensor_msgs_py import point_cloud2\n from std_msgs.msg import Header\n \n-\n pylist = [[0.0, 0.1, 0.2],\n           [1.0, 1.1, 1.2],\n           [2.0, 2.1, 2.2],\n           [3.0, 3.1, 3.2],\n-          [4.0, np.nan, 4.2]]\n\u002B          [4.0, np.nan, 4.2],\n\u002B          [5.0, 5.1, 5.2]]\n points = np.array(pylist, dtype=np.float32)\n \n fields = [PointField(name=\u0027x\u0027, offset=0, datatype=PointField.FLOAT32, count=1),\n@@ -57,7 \u002B57,7 @@ pcd = PointCloud2(\n     height=1,\n     width=points.shape[0],\n     is_dense=False,\n-    is_bigendian=False,  # Not sure how to properly determine this.\n\u002B    is_bigendian=sys.byteorder != \u0027little\u0027,\n     fields=fields,\n     point_step=(itemsize * 3),  # Every point consists of three float32s.\n     row_step=(itemsize * 3 * points.shape[0]),\n@@ -77,25 \u002B77,92 @@ pcd2 = PointCloud2(\n     height=1,\n     width=points.shape[0],\n     is_dense=False,\n-    is_bigendian=False,  # Not sure how to properly determine this.\n\u002B    is_bigendian=sys.byteorder != \u0027little\u0027,\n     fields=fields,\n-    point_step=(itemsize * 2),  # Every point consists of three float32s.\n\u002B    point_step=(itemsize * 2),  # Every point consists of two float32s.\n     row_step=(itemsize * 2 * points.shape[0]),\n     data=data\n )\n \n\u002B# Organized point cloud (Points are aligned in 2D matrix)\n\u002Bpoints3 = points.reshape(2, 3, -1)\n\u002Bpcd3 = PointCloud2(\n\u002B    header=Header(frame_id=\u0027frame\u0027),\n\u002B    height=points3.shape[1],\n\u002B    width=points3.shape[0],\n\u002B    is_dense=False,\n\u002B    is_bigendian=sys.byteorder != \u0027little\u0027,\n\u002B    fields=fields,\n\u002B    # Every point consists of three float32s.\n\u002B    point_step=(itemsize * points3.shape[-1]),\n\u002B    row_step=(itemsize * points3.shape[-1] * points3.shape[0]),\n\u002B    data=points3.tobytes()\n\u002B)\n\u002B\n\u002B# Check multiple datatype pointclouds\n\u002Bstruct_points = np.array(\n\u002B    # Make each point a tuple\n\u002B    list(map(tuple, points)),\n\u002B    dtype=[\n\u002B        (\u0027a\u0027, np.float32),\n\u002B        (\u0027b\u0027, np.float64),\n\u002B        (\u0027c\u0027, np.uint8),\n\u002B    ])\n\u002B\n\u002Bstruct_points_itemsize = struct_points.itemsize\n\u002B\n\u002Bstruct_points_fields = [\n\u002B    PointField(name=\u0027a\u0027, offset=0, datatype=PointField.FLOAT32, count=1),\n\u002B    PointField(name=\u0027b\u0027, offset=4, datatype=PointField.FLOAT64, count=1),\n\u002B    PointField(name=\u0027c\u0027, offset=12, datatype=PointField.UINT8, count=1)]\n\u002B\n\u002Bpcd4 = PointCloud2(\n\u002B    header=Header(frame_id=\u0027frame\u0027),\n\u002B    height=1,\n\u002B    width=struct_points.shape[0],\n\u002B    is_dense=False,\n\u002B    is_bigendian=sys.byteorder != \u0027little\u0027,\n\u002B    fields=struct_points_fields,\n\u002B    # This time a struct array is used.\n\u002B    # The itemsize therfore represents the size of a complete point\n\u002B    point_step=struct_points_itemsize,\n\u002B    row_step=(struct_points_itemsize * points.shape[0]),\n\u002B    data=struct_points.tobytes()\n\u002B)\n\u002B\n\u002B# Point cloud with a field with count \u003E 1\n\u002Bcount = 3\n\u002Bfields5 = [PointField(name=\u0027x\u0027, offset=0, datatype=PointField.FLOAT32, count=3)]\n\u002B\n\u002Bitemsize = points.itemsize * count\n\u002Bdata = points.tobytes()\n\u002B\n\u002Bpcd5 = PointCloud2(\n\u002B    header=Header(frame_id=\u0027frame\u0027),\n\u002B    height=1,\n\u002B    width=points.shape[0],\n\u002B    is_dense=False,\n\u002B    is_bigendian=sys.byteorder != \u0027little\u0027,\n\u002B    fields=fields5,\n\u002B    point_step=(itemsize),\n\u002B    row_step=(itemsize * points.shape[0]),\n\u002B    data=data\n\u002B)\n\u002B\n \n class TestPointCloud2Methods(unittest.TestCase):\n \n     def test_read_points(self):\n         # Test that converting a PointCloud2 to a list, is equivalent to\n         # the original list of points.\n-        pcd_list = list(point_cloud2.read_points(pcd))\n\u002B        pcd_list = list(map(list, point_cloud2.read_points(pcd)))\n         self.assertTrue(np.allclose(pcd_list, pylist, equal_nan=True))\n \n     def test_read_points_field(self):\n         # Test that field selection is working.\n-        pcd_list = list(point_cloud2.read_points(pcd, field_names=[\u0027x\u0027, \u0027z\u0027]))\n\u002B        pcd_list = list(map(\n\u002B            list,\n\u002B            point_cloud2.read_points(pcd, field_names=[\u0027x\u0027, \u0027z\u0027])))\n         # Check correct shape.\n         self.assertTrue(np.array(pcd_list).shape == points[:, [0, 2]].shape)\n         # Check \u0022correct\u0022 values.\n@@ -104,7 \u002B171,9 @@ class TestPointCloud2Methods(unittest.TestCase):\n \n     def test_read_points_skip_nan(self):\n         # Test that removing NaNs work.\n-        pcd_list = list(point_cloud2.read_points(pcd, skip_nans=True))\n\u002B        pcd_list = list(map(\n\u002B            list,\n\u002B            point_cloud2.read_points(pcd, skip_nans=True)))\n         points_nonan = points[~np.any(np.isnan(points), axis=1)]\n         # Check correct shape\n         self.assertTrue(np.array(pcd_list).shape == points_nonan.shape)\n@@ -117,12 \u002B186,51 @@ class TestPointCloud2Methods(unittest.TestCase):\n         # Check that reading a PointCloud2 message to a list is performed\n         # correctly.\n         points_named = point_cloud2.read_points_list(pcd)\n-        self.assertTrue(np.allclose(np.array(points_named), points, equal_nan=True))\n\u002B        self.assertTrue(np.allclose(\n\u002B            np.array(points_named), points, equal_nan=True))\n\u002B\n\u002B    def test_read_points_organized(self):\n\u002B        # Checks if organized clouds are handled correctly\n\u002B        # Test if it is converted into a unorganized one by default\n\u002B        pcd_list = list(map(list, point_cloud2.read_points(pcd3)))\n\u002B        self.assertTrue(np.allclose(pcd_list, pylist, equal_nan=True))\n\u002B        # Test if organization is correctly if requested\n\u002B        pcd_points = point_cloud2.read_points(\n\u002B            pcd3, reshape_organized_cloud=True)\n\u002B        # Because we have a 2d array of points now it is easier to cat it into a\n\u002B        # unstructured NumPy array instead of converting it into a list of lists\n\u002B        pcd_points = structured_to_unstructured(pcd_points)\n\u002B        self.assertTrue(np.allclose(pcd_points, points3, equal_nan=True))\n\u002B\n\u002B    def test_read_points_numpy(self):\n\u002B        # Checks if the deserialization to an unstructured numpy array works\n\u002B        pcd_points = point_cloud2.read_points_numpy(pcd)\n\u002B        self.assertTrue(np.allclose(pcd_points, points, equal_nan=True))\n\u002B\n\u002B    def test_read_points_different_types(self):\n\u002B        # Checks if the deserialization to an unstructured numpy array works\n\u002B        pcd_points = point_cloud2.read_points(pcd4)\n\u002B        self.assertTrue(\n\u002B            all(np.allclose(pcd_points[name], struct_points[name], equal_nan=True)\n\u002B                for name in struct_points.dtype.names))\n\u002B        self.assertEqual(struct_points.dtype, pcd_points.dtype)\n\u002B\n\u002B    def test_read_points_non_one_count(self):\n\u002B        pcd_points = point_cloud2.read_points_numpy(pcd5)\n\u002B        self.assertTrue(\n\u002B            np.allclose(pcd_points, points, equal_nan=True))\n\u002B\n\u002B    def test_read_points_non_one_count_structured(self):\n\u002B        pcd_points = point_cloud2.read_points(pcd5)\n\u002B        pcd_points_unstructured = structured_to_unstructured(pcd_points)\n\u002B        self.assertTrue(\n\u002B            np.allclose(pcd_points_unstructured, points, equal_nan=True))\n\u002B        self.assertEqual(pcd_points.dtype.names, (\u0027x_0\u0027, \u0027x_1\u0027, \u0027x_2\u0027))\n \n     def test_create_cloud(self):\n         thispcd = point_cloud2.create_cloud(Header(frame_id=\u0027frame\u0027),\n                                             fields, pylist)\n-        self.assertTrue(thispcd == pcd)\n\u002B        self.assertEqual(thispcd, pcd)\n         thispcd = point_cloud2.create_cloud(Header(frame_id=\u0027frame2\u0027),\n                                             fields, pylist)\n         self.assertFalse(thispcd == pcd)\n@@ -130,10 \u002B238,35 @@ class TestPointCloud2Methods(unittest.TestCase):\n                                             fields2, pylist2)\n         self.assertFalse(thispcd == pcd)\n \n\u002B    def test_create_cloud_different_types(self):\n\u002B        # Check if we are able to create a point cloud with different data\n\u002B        thispcd = point_cloud2.create_cloud(\n\u002B            Header(frame_id=\u0027frame\u0027),\n\u002B            struct_points_fields,\n\u002B            struct_points)\n\u002B        self.assertEqual(thispcd, pcd4)\n\u002B\n     def test_create_cloud_xyz32(self):\n-        thispcd = point_cloud2.create_cloud_xyz32(Header(frame_id=\u0027frame\u0027),\n-                                                  pylist)\n-        self.assertTrue(thispcd == pcd)\n\u002B        thispcd = point_cloud2.create_cloud_xyz32(\n\u002B            Header(frame_id=\u0027frame\u0027),\n\u002B            pylist)\n\u002B        self.assertEqual(thispcd, pcd)\n\u002B\n\u002B    def test_create_cloud_xyz32_organized(self):\n\u002B        # Checks if organized clouds are handled correctly\n\u002B        thispcd = point_cloud2.create_cloud_xyz32(\n\u002B            Header(frame_id=\u0027frame\u0027),\n\u002B            points3)\n\u002B        print(thispcd)\n\u002B        print(pcd3)\n\u002B        self.assertEqual(thispcd, pcd3)\n\u002B\n\u002B    def test_create_cloud__non_one_count(self):\n\u002B        thispcd = point_cloud2.create_cloud(\n\u002B            Header(frame_id=\u0027frame\u0027),\n\u002B            fields5,\n\u002B            points)\n\u002B        self.assertEqual(thispcd, pcd5)\n \n \n if __name__ == \u0027__main__\u0027:\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "04fc1d0b27de1209449fe07b8851aec4292a8093",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#124)",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\ndeleted file mode 100644\nindex 2885eb4..0000000\n--- .github/workflows/mirror-rolling-to-master.yaml\n\u002B\u002B\u002B /dev/null\n@@ -1,13 \u002B0,0 @@\n-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\ndiff --git CODEOWNERS CODEOWNERS\ndeleted file mode 100644\nindex 2a976b9..0000000\n--- CODEOWNERS\n\u002B\u002B\u002B /dev/null\n@@ -1,2 \u002B0,0 @@\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "facbd8dad32acb40b8ccae485f66e8e17bf8f8cd",
    "RawMessage": "Instrument client/service for end-to-end request/response tracking",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex 90a9ca0..31f6e33 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -28,6 \u002B28,8 @@\n \n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n\u002B#include \u0022tracetools/tracetools.h\u0022\n\u002B\n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n@@ -393,6 \u002B395,12 @@ rmw_create_client(\n     service_name, node-\u003Enamespace_,\n     node-\u003Enamespace_[strlen(node-\u003Enamespace_) - 1] == \u0027/\u0027 ? \u0022\u0022 : \u0022/\u0022, node-\u003Ename);\n \n\u002B  if (TRACETOOLS_TRACEPOINT_ENABLED(rmw_client_init)) {\n\u002B    TRACETOOLS_DO_TRACEPOINT(\n\u002B      rmw_client_init, static_cast\u003Cconst void *\u003E(rmw_client),\n\u002B      client_info-\u003Esubscriber_gid.data);\n\u002B  }\n\u002B\n   return rmw_client;\n \n fail:\n@@ -820,6 \u002B828,12 @@ rmw_send_request(\n       reinterpret_cast\u003Cconst uint8_t *\u003E(client_info-\u003Ewriter_guid),\n       reinterpret_cast\u003Cuint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n \n\u002B      TRACETOOLS_TRACEPOINT(\n\u002B        rmw_send_request,\n\u002B        static_cast\u003Cconst void *\u003E(client),\n\u002B        static_cast\u003Cconst void *\u003E(ros_request),\n\u002B        *sequence_id);\n\u002B\n     if (dds_DataWriter_raw_write_w_sampleinfoex(\n         request_writer, dds_request, size, \u0026sampleinfo_ex) != dds_RETCODE_OK)\n     {\n@@ -1051,6 \u002B1065,14 @@ rmw_take_response(\n   dds_SampleInfoSeq_delete(sample_infos);\n   dds_UnsignedLongSeq_delete(sample_sizes);\n \n\u002B  TRACETOOLS_TRACEPOINT(\n\u002B    rmw_take_response,\n\u002B    static_cast\u003Cconst void *\u003E(client),\n\u002B    static_cast\u003Cconst void *\u003E(ros_response),\n\u002B    request_header-\u003Erequest_id.sequence_number,\n\u002B    request_header-\u003Esource_timestamp,\n\u002B    *taken);\n\u002B\n   return RMW_RET_OK;\n }\n \ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex 9c2c066..02974b7 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -25,6 \u002B25,8 @@\n \n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n\u002B#include \u0022tracetools/tracetools.h\u0022\n\u002B\n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n@@ -803,6 \u002B805,15 @@ rmw_take_request(\n   }\n \n   *taken = true;\n\u002B\n\u002B  TRACETOOLS_TRACEPOINT(\n\u002B    rmw_take_request,\n\u002B    static_cast\u003Cconst void *\u003E(service),\n\u002B    static_cast\u003Cconst void *\u003E(ros_request),\n\u002B    request_header-\u003Erequest_id.writer_guid,\n\u002B    request_header-\u003Erequest_id.sequence_number,\n\u002B    *taken);\n\u002B\n   return RMW_RET_OK;\n }\n \n@@ -908,6 \u002B919,15 @@ rmw_send_response(\n       request_header-\u003Ewriter_guid,\n       reinterpret_cast\u003Cuint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n \n\u002B    dds_Time_get_current_time(\u0026sampleinfo_ex.info.source_timestamp);\n\u002B    TRACETOOLS_TRACEPOINT(\n\u002B      rmw_send_response,\n\u002B      static_cast\u003Cconst void *\u003E(service),\n\u002B      static_cast\u003Cconst void *\u003E(ros_response),\n\u002B      request_header-\u003Ewriter_guid,\n\u002B      request_header-\u003Esequence_number,\n\u002B      rmw_gurumdds_cpp::dds_time_to_i64(sampleinfo_ex.info.source_timestamp));\n\u002B\n     if (dds_DataWriter_raw_write_w_sampleinfoex(\n         response_writer, dds_response, size, \u0026sampleinfo_ex) != dds_RETCODE_OK)\n     {\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "a0376768f7d077d7543bb9a2cdd9d2a72b495538",
    "RawMessage": "Unittests for memory strategy files, except allocator_memory_strategy (#1189)",
    "Changes": "diff --git rclcpp/test/CMakeLists.txt rclcpp/test/CMakeLists.txt\nindex f9dbf0c4..bf2fa94a 100644\n--- rclcpp/test/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/CMakeLists.txt\n@@ -25,6 \u002B25,14 @@ if(TARGET test_allocator_memory_strategy)\n   )\n   target_link_libraries(test_allocator_memory_strategy ${PROJECT_NAME})\n endif()\n\u002Bament_add_gtest(test_message_pool_memory_strategy rclcpp/strategies/test_message_pool_memory_strategy.cpp)\n\u002Bif(TARGET test_message_pool_memory_strategy)\n\u002B  ament_target_dependencies(test_message_pool_memory_strategy\n\u002B    \u0022rcl\u0022\n\u002B    \u0022test_msgs\u0022\n\u002B  )\n\u002B  target_link_libraries(test_message_pool_memory_strategy ${PROJECT_NAME})\n\u002Bendif()\n ament_add_gtest(test_any_service_callback rclcpp/test_any_service_callback.cpp)\n if(TARGET test_any_service_callback)\n   ament_target_dependencies(test_any_service_callback\n@@ -126,6 \u002B134,18 @@ ament_target_dependencies(test_loaned_message\n )\n target_link_libraries(test_loaned_message ${PROJECT_NAME})\n \n\u002Bament_add_gtest(test_memory_strategy rclcpp/test_memory_strategy.cpp)\n\u002Bament_target_dependencies(test_memory_strategy\n\u002B  \u0022test_msgs\u0022\n\u002B)\n\u002Btarget_link_libraries(test_memory_strategy ${PROJECT_NAME})\n\u002B\n\u002Bament_add_gtest(test_message_memory_strategy rclcpp/test_message_memory_strategy.cpp)\n\u002Bament_target_dependencies(test_message_memory_strategy\n\u002B  \u0022test_msgs\u0022\n\u002B)\n\u002Btarget_link_libraries(test_message_memory_strategy ${PROJECT_NAME})\n\u002B\n ament_add_gtest(test_node rclcpp/test_node.cpp TIMEOUT 240)\n if(TARGET test_node)\n   ament_target_dependencies(test_node\ndiff --git rclcpp/test/rclcpp/strategies/test_message_pool_memory_strategy.cpp rclcpp/test/rclcpp/strategies/test_message_pool_memory_strategy.cpp\nnew file mode 100644\nindex 00000000..b68bc96a\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/strategies/test_message_pool_memory_strategy.cpp\n@@ -0,0 \u002B1,73 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rclcpp/strategies/message_pool_memory_strategy.hpp\u0022\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B#include \u0022../../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n\u002Busing rclcpp::strategies::message_pool_memory_strategy::MessagePoolMemoryStrategy;\n\u002B\n\u002Bclass TestMessagePoolMemoryStrategy : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    message_memory_strategy_ =\n\u002B      std::make_shared\u003CMessagePoolMemoryStrategy\u003Ctest_msgs::msg::Empty, 1\u003E\u003E();\n\u002B  }\n\u002B\n\u002Bprotected:\n\u002B  std::shared_ptr\u003CMessagePoolMemoryStrategy\u003Ctest_msgs::msg::Empty, 1\u003E\u003E message_memory_strategy_;\n\u002B};\n\u002B\n\u002BTEST_F(TestMessagePoolMemoryStrategy, construct_destruct) {\n\u002B  ASSERT_NE(nullptr, message_memory_strategy_);\n\u002B  EXPECT_NE(nullptr, message_memory_strategy_-\u003Emessage_allocator_);\n\u002B  EXPECT_NE(nullptr, message_memory_strategy_-\u003Eserialized_message_allocator_);\n\u002B  EXPECT_NE(nullptr, message_memory_strategy_-\u003Ebuffer_allocator_);\n\u002B}\n\u002B\n\u002BTEST_F(TestMessagePoolMemoryStrategy, borrow_return) {\n\u002B  auto message = message_memory_strategy_-\u003Eborrow_message();\n\u002B  ASSERT_NE(nullptr, message);\n\u002B\n\u002B  EXPECT_NO_THROW(message_memory_strategy_-\u003Ereturn_message(message));\n\u002B}\n\u002B\n\u002BTEST_F(TestMessagePoolMemoryStrategy, borrow_too_many) {\n\u002B  auto message = message_memory_strategy_-\u003Eborrow_message();\n\u002B  ASSERT_NE(nullptr, message);\n\u002B\n\u002B  // Size is 1, borrowing second time should fail\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    message_memory_strategy_-\u003Eborrow_message(),\n\u002B    std::runtime_error(\u0022Tried to access message that was still in use! Abort.\u0022));\n\u002B  EXPECT_NO_THROW(message_memory_strategy_-\u003Ereturn_message(message));\n\u002B}\n\u002B\n\u002BTEST_F(TestMessagePoolMemoryStrategy, return_unrecognized) {\n\u002B  auto message = message_memory_strategy_-\u003Eborrow_message();\n\u002B  ASSERT_NE(nullptr, message);\n\u002B\n\u002B  auto unrecognized = std::make_shared\u003Ctest_msgs::msg::Empty\u003E();\n\u002B  // Unrecognized does not belong to pool\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    message_memory_strategy_-\u003Ereturn_message(unrecognized),\n\u002B    std::runtime_error(\u0022Unrecognized message ptr in return_message.\u0022));\n\u002B  EXPECT_NO_THROW(message_memory_strategy_-\u003Ereturn_message(message));\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_memory_strategy.cpp rclcpp/test/rclcpp/test_memory_strategy.cpp\nnew file mode 100644\nindex 00000000..f0760946\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_memory_strategy.cpp\n@@ -0,0 \u002B1,400 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Clist\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022rclcpp/strategies/allocator_memory_strategy.hpp\u0022\n\u002B#include \u0022rclcpp/memory_strategy.hpp\u0022\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B#include \u0022test_msgs/srv/empty.hpp\u0022\n\u002B\n\u002Busing rclcpp::memory_strategy::MemoryStrategy;\n\u002Busing WeakNodeList = std::list\u003Crclcpp::node_interfaces::NodeBaseInterface::WeakPtr\u003E;\n\u002B\n\u002B/**\n\u002B * Mock Waitable class\n\u002B */\n\u002Bclass TestWaitable : public rclcpp::Waitable\n\u002B{\n\u002Bpublic:\n\u002B  bool add_to_wait_set(rcl_wait_set_t *) override {return true;}\n\u002B  bool is_ready(rcl_wait_set_t *) override {return true;}\n\u002B  void execute() override {}\n\u002B};\n\u002B\n\u002Bclass TestMemoryStrategy : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  TestMemoryStrategy()\n\u002B  : memory_strategy_(nullptr) {}\n\u002B\n\u002B  void SetUp() override\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B\n\u002B    // This doesn\u0027t test AllocatorMemoryStrategy directly, so we cast to the base class.\n\u002B    // AllocatorMemoryStrategy is more commonly used than MessagePoolMemoryStrategy\n\u002B    // so we use this derived class for these tests.\n\u002B    memory_strategy_ =\n\u002B      std::make_shared\u003C\n\u002B      rclcpp::memory_strategies::allocator_memory_strategy::AllocatorMemoryStrategy\u003C\u003E\u003E();\n\u002B  }\n\u002B\n\u002B  void TearDown() override\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002Bprotected:\n\u002B  std::shared_ptr\u003CMemoryStrategy\u003E memory_strategy()\n\u002B  {\n\u002B    return memory_strategy_;\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003CMemoryStrategy\u003E memory_strategy_;\n\u002B};\n\u002B\n\u002BTEST_F(TestMemoryStrategy, construct_destruct) {\n\u002B  EXPECT_NE(nullptr, memory_strategy());\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_subscription_by_handle) {\n\u002B  WeakNodeList nodes;\n\u002B  std::shared_ptr\u003Cconst rcl_subscription_t\u003E subscription_handle;\n\u002B  rclcpp::SubscriptionBase::SharedPtr found_subscription = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B      const rclcpp::QoS qos(10);\n\u002B\n\u002B      {\n\u002B        auto subscription = node-\u003Ecreate_subscription\u003C\n\u002B          test_msgs::msg::Empty, decltype(subscription_callback)\u003E(\n\u002B          \u0022topic\u0022, qos, std::move(subscription_callback));\n\u002B\n\u002B        subscription_handle = subscription-\u003Eget_subscription_handle();\n\u002B\n\u002B        EXPECT_EQ(\n\u002B          subscription,\n\u002B          memory_strategy()-\u003Eget_subscription_by_handle(subscription_handle, nodes));\n\u002B      }  // subscription goes out of scope\n\u002B      EXPECT_EQ(\n\u002B        nullptr,\n\u002B        memory_strategy()-\u003Eget_subscription_by_handle(subscription_handle, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_subscription_by_handle(subscription_handle, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_subscription_by_handle(subscription_handle, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_service_by_handle) {\n\u002B  WeakNodeList nodes;\n\u002B  std::shared_ptr\u003Cconst rcl_service_t\u003E service_handle;\n\u002B  rclcpp::ServiceBase::SharedPtr found_service = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      auto service_callback =\n\u002B        [](const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B          test_msgs::srv::Empty::Response::SharedPtr) {};\n\u002B      const rclcpp::QoS qos(10);\n\u002B\n\u002B      {\n\u002B        auto service = node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n\u002B          \u0022service\u0022, std::move(service_callback),\n\u002B          rmw_qos_profile_services_default, callback_group);\n\u002B\n\u002B        service_handle = service-\u003Eget_service_handle();\n\u002B\n\u002B        EXPECT_EQ(\n\u002B          service,\n\u002B          memory_strategy()-\u003Eget_service_by_handle(service_handle, nodes));\n\u002B      }  // service goes out of scope\n\u002B      EXPECT_EQ(\n\u002B        nullptr,\n\u002B        memory_strategy()-\u003Eget_service_by_handle(service_handle, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_service_by_handle(service_handle, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_service_by_handle(service_handle, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_client_by_handle) {\n\u002B  WeakNodeList nodes;\n\u002B  std::shared_ptr\u003Cconst rcl_client_t\u003E client_handle;\n\u002B  rclcpp::ClientBase::SharedPtr found_client = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      {\n\u002B        auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\n\u002B          \u0022service\u0022, rmw_qos_profile_services_default, callback_group);\n\u002B\n\u002B        client_handle = client-\u003Eget_client_handle();\n\u002B\n\u002B        EXPECT_EQ(\n\u002B          client,\n\u002B          memory_strategy()-\u003Eget_client_by_handle(client_handle, nodes));\n\u002B      }  // client goes out of scope\n\u002B      EXPECT_EQ(\n\u002B        nullptr,\n\u002B        memory_strategy()-\u003Eget_client_by_handle(client_handle, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_client_by_handle(client_handle, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_client_by_handle(client_handle, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_timer_by_handle) {\n\u002B  WeakNodeList nodes;\n\u002B  std::shared_ptr\u003Cconst rcl_timer_t\u003E timer_handle;\n\u002B  rclcpp::TimerBase::SharedPtr found_timer = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      {\n\u002B        auto timer_callback = []() {};\n\u002B        auto timer = node-\u003Ecreate_wall_timer(\n\u002B          std::chrono::milliseconds(1), timer_callback, callback_group);\n\u002B\n\u002B        timer_handle = timer-\u003Eget_timer_handle();\n\u002B\n\u002B        EXPECT_EQ(\n\u002B          timer,\n\u002B          memory_strategy()-\u003Eget_timer_by_handle(timer_handle, nodes));\n\u002B      }  // timer goes out of scope\n\u002B      EXPECT_EQ(\n\u002B        nullptr,\n\u002B        memory_strategy()-\u003Eget_timer_by_handle(timer_handle, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_timer_by_handle(timer_handle, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_timer_by_handle(timer_handle, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_node_by_group) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::CallbackGroup::SharedPtr callback_group = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    auto node_handle = node-\u003Eget_node_base_interface();\n\u002B    nodes.push_back(node_handle);\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_node_by_group(nullptr, nodes));\n\u002B\n\u002B    callback_group =\n\u002B      node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      node_handle,\n\u002B      memory_strategy()-\u003Eget_node_by_group(callback_group, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_node_by_group(callback_group, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_group_by_subscription) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::SubscriptionBase::SharedPtr subscription = nullptr;\n\u002B  rclcpp::CallbackGroup::SharedPtr callback_group = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      // This group is just used to test that a callback group that is held as a weak pointer\n\u002B      // by node, doesn\u0027t confuse get_group_by_subscription() when it goes out of scope\n\u002B      auto non_persistant_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B      callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      auto subscription_callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B      const rclcpp::QoS qos(10);\n\u002B\n\u002B      rclcpp::SubscriptionOptions subscription_options;\n\u002B\n\u002B      // This callback group is held as a shared_ptr in subscription_options, which means it\n\u002B      // stays alive as long as subscription does.\n\u002B      subscription_options.callback_group = callback_group;\n\u002B\n\u002B      subscription = node-\u003Ecreate_subscription\u003C\n\u002B        test_msgs::msg::Empty, decltype(subscription_callback)\u003E(\n\u002B        \u0022topic\u0022, qos, std::move(subscription_callback), subscription_options);\n\u002B\n\u002B      EXPECT_EQ(\n\u002B        callback_group,\n\u002B        memory_strategy()-\u003Eget_group_by_subscription(subscription, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      callback_group,\n\u002B      memory_strategy()-\u003Eget_group_by_subscription(subscription, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_group_by_subscription(subscription, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_group_by_service) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::ServiceBase::SharedPtr service = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      auto service_callback =\n\u002B        [](const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B          test_msgs::srv::Empty::Response::SharedPtr) {};\n\u002B      const rclcpp::QoS qos(10);\n\u002B\n\u002B      service = node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n\u002B        \u0022service\u0022, std::move(service_callback),\n\u002B        rmw_qos_profile_services_default, callback_group);\n\u002B\n\u002B      EXPECT_EQ(\n\u002B        callback_group,\n\u002B        memory_strategy()-\u003Eget_group_by_service(service, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_group_by_service(service, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_group_by_service(service, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_group_by_client) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::ClientBase::SharedPtr client = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B      client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\n\u002B        \u0022service\u0022, rmw_qos_profile_services_default, callback_group);\n\u002B\n\u002B      EXPECT_EQ(\n\u002B        callback_group,\n\u002B        memory_strategy()-\u003Eget_group_by_client(client, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_group_by_client(client, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_group_by_client(client, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_group_by_timer) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::TimerBase::SharedPtr timer = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      auto timer_callback = []() {};\n\u002B      timer = node-\u003Ecreate_wall_timer(\n\u002B        std::chrono::milliseconds(1), timer_callback, callback_group);\n\u002B\n\u002B      EXPECT_EQ(\n\u002B        callback_group,\n\u002B        memory_strategy()-\u003Eget_group_by_timer(timer, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_group_by_timer(timer, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_group_by_timer(timer, nodes));\n\u002B}\n\u002B\n\u002BTEST_F(TestMemoryStrategy, get_group_by_waitable) {\n\u002B  WeakNodeList nodes;\n\u002B  rclcpp::Waitable::SharedPtr waitable = nullptr;\n\u002B  {\n\u002B    auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B    nodes.push_back(node-\u003Eget_node_base_interface());\n\u002B    memory_strategy()-\u003Ecollect_entities(nodes);\n\u002B    {\n\u002B      waitable = std::make_shared\u003CTestWaitable\u003E();\n\u002B      auto callback_group =\n\u002B        node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B      node-\u003Eget_node_waitables_interface()-\u003Eadd_waitable(waitable, callback_group);\n\u002B\n\u002B      EXPECT_EQ(\n\u002B        callback_group,\n\u002B        memory_strategy()-\u003Eget_group_by_waitable(waitable, nodes));\n\u002B    }  // callback_group goes out of scope\n\u002B    EXPECT_EQ(\n\u002B      nullptr,\n\u002B      memory_strategy()-\u003Eget_group_by_waitable(waitable, nodes));\n\u002B  }  // Node goes out of scope\n\u002B  EXPECT_EQ(\n\u002B    nullptr,\n\u002B    memory_strategy()-\u003Eget_group_by_waitable(waitable, nodes));\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_message_memory_strategy.cpp rclcpp/test/rclcpp/test_message_memory_strategy.cpp\nnew file mode 100644\nindex 00000000..26ebd5ec\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_message_memory_strategy.cpp\n@@ -0,0 \u002B1,58 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022rclcpp/message_memory_strategy.hpp\u0022\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B\n\u002BTEST(TestMemoryStrategies, construct_destruct) {\n\u002B  rclcpp::message_memory_strategy::MessageMemoryStrategy\u003Ctest_msgs::msg::Empty\u003E memory_strategy1;\n\u002B\n\u002B  EXPECT_NE(nullptr, memory_strategy1.message_allocator_);\n\u002B  EXPECT_NE(nullptr, memory_strategy1.serialized_message_allocator_);\n\u002B  EXPECT_NE(nullptr, memory_strategy1.buffer_allocator_);\n\u002B\n\u002B  auto allocator = std::make_shared\u003Cstd::allocator\u003Cvoid\u003E\u003E();\n\u002B  rclcpp::message_memory_strategy::MessageMemoryStrategy\u003Ctest_msgs::msg::Empty\u003E memory_strategy2(\n\u002B    allocator);\n\u002B\n\u002B  EXPECT_NE(nullptr, memory_strategy2.message_allocator_);\n\u002B  EXPECT_NE(nullptr, memory_strategy2.serialized_message_allocator_);\n\u002B  EXPECT_NE(nullptr, memory_strategy2.buffer_allocator_);\n\u002B}\n\u002B\n\u002BTEST(TestMemoryStrategies, standard_allocation) {\n\u002B  auto memory_strategy =\n\u002B    rclcpp::message_memory_strategy::MessageMemoryStrategy\u003C\n\u002B    test_msgs::msg::Empty\u003E::create_default();\n\u002B  ASSERT_NE(nullptr, memory_strategy);\n\u002B\n\u002B  auto borrowed_message = memory_strategy-\u003Eborrow_message();\n\u002B  ASSERT_NE(nullptr, borrowed_message);\n\u002B  EXPECT_NO_THROW(memory_strategy-\u003Ereturn_message(borrowed_message));\n\u002B\n\u002B  auto serialized_message = memory_strategy-\u003Eborrow_serialized_message();\n\u002B  ASSERT_NE(nullptr, serialized_message);\n\u002B  EXPECT_EQ(0u, serialized_message-\u003Ecapacity());\n\u002B  EXPECT_NO_THROW(memory_strategy-\u003Ereturn_serialized_message(serialized_message));\n\u002B\n\u002B  memory_strategy-\u003Eset_default_buffer_capacity(42);\n\u002B  serialized_message = memory_strategy-\u003Eborrow_serialized_message();\n\u002B  ASSERT_NE(nullptr, serialized_message);\n\u002B  EXPECT_EQ(42u, serialized_message-\u003Ecapacity());\n\u002B  EXPECT_NO_THROW(memory_strategy-\u003Ereturn_serialized_message(serialized_message));\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "edbfe1404b24d0bc85ff88e8ff1f006670788e46",
    "RawMessage": "LifecycleNode on_configure doc fix. (#2034)",
    "Changes": "diff --git rclcpp_lifecycle/include/rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp rclcpp_lifecycle/include/rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\nindex e653ad41..ed919ca5 100644\n--- rclcpp_lifecycle/include/rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\n\u002B\u002B\u002B rclcpp_lifecycle/include/rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\n@@ -53,7 \u002B53,7 @@ public:\n \n   /// Callback function for configure transition\n   /*\n-   * \\return true by default\n\u002B   * \\return SUCCESS by default\n    */\n   RCLCPP_LIFECYCLE_PUBLIC\n   virtual CallbackReturn\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "c3d40c855afa2afd1eb88636d9ba4d59ad1991a7",
    "RawMessage": "Provide external dependencies QD links",
    "Changes": "diff --git rmw_fastrtps_cpp/QUALITY_DECLARATION.md rmw_fastrtps_cpp/QUALITY_DECLARATION.md\nindex 223deb7..4a4e835 100644\n--- rmw_fastrtps_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_cpp/QUALITY_DECLARATION.md\n@@ -149,8 \u002B149,8 @@ It also has several test dependencies, which do not affect the resulting quality\n ### Direct Runtime Non-ROS Dependencies [5.iii]\n \n \u0060rmw_fastrtps_cpp\u0060 has the following runtime non-ROS dependencies.\n-* \u0060fastcdr\u0060\n-* \u0060fastrtps\u0060\n\u002B* \u0060fastcdr\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n\u002B* \u0060fastrtps\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)\n \n ## Platform Support [6]\n \ndiff --git rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\nindex 61ef51c..acd8051 100644\n--- rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/QUALITY_DECLARATION.md\n@@ -139,8 \u002B139,8 @@ It also has several test dependencies, which do not affect the resulting quality\n ### Direct Runtime Non-ROS Dependencies [5.iii]\n \n \u0060rmw_fastrtps_cpp\u0060 has the following runtime non-ROS dependencies.\n-* \u0060fastcdr\u0060\n-* \u0060fastrtps\u0060\n\u002B* \u0060fastcdr\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n\u002B* \u0060fastrtps\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)\n \n ## Platform Support [6]\n \ndiff --git rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\nindex 5a0885c..f49efca 100644\n--- rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/QUALITY_DECLARATION.md\n@@ -149,8 \u002B149,8 @@ It also has several test dependencies, which do not affect the resulting quality\n ### Direct Runtime Non-ROS Dependencies [5.iii]\n \n \u0060rmw_fastrtps_shared_cpp\u0060 has the following runtime non-ROS dependencies.\n-* \u0060fastcdr\u0060\n-* \u0060fastrtps\u0060\n\u002B* \u0060fastcdr\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-CDR/blob/master/QUALITY.md)\n\u002B* \u0060fastrtps\u0060: [QUALITY DECLARATION](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md)\n \n ## Platform Support [6]\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "df8ebfb4ab410100c5fd78b8d4b78312c28dc42e",
    "RawMessage": "Refactor event info types",
    "Changes": "diff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/rmw_context_impl.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/rmw_context_impl.hpp\nindex 13cdd1c..bf67ba5 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/rmw_context_impl.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/rmw_context_impl.hpp\n@@ -41,6 \u002B41,24 @@\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n \n\u002Bnamespace rmw_gurumdds_cpp\n\u002B{\n\u002Bvoid on_participant_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_ParticipantBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle);\n\u002B\n\u002Bvoid on_publication_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_PublicationBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle);\n\u002B\n\u002Bvoid on_subscription_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_SubscriptionBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle);\n\u002B} // namespace rmw_gurumdds_cpp\n\u002B\n struct rmw_context_impl_s\n {\n   rmw_dds_common::Context common_ctx;\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\nindex 6113288..be32e77 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/types.hpp\n@@ -40,28 \u002B40,6 @@\n \n namespace rmw_gurumdds_cpp\n {\n-void on_participant_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_ParticipantBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-void on_publication_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_PublicationBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-void on_subscription_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_SubscriptionBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle);\n-\n-struct WaitSetInfo\n-{\n-  dds_WaitSet * wait_set;\n-  dds_ConditionSeq * active_conditions;\n-  dds_ConditionSeq * attached_conditions;\n-};\n-\n struct event_callback_data_t\n {\n   std::mutex mutex;\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/wait.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/wait.hpp\nindex 2f02e18..f2d8d46 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/wait.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/wait.hpp\n@@ -19,6 \u002B19,13 @@\n \n namespace rmw_gurumdds_cpp\n {\n\u002Bstruct WaitSetInfo\n\u002B{\n\u002B  dds_WaitSet * wait_set;\n\u002B  dds_ConditionSeq * active_conditions;\n\u002B  dds_ConditionSeq * attached_conditions;\n\u002B};\n\u002B\n rmw_ret_t\n wait(\n   const char * implementation_identifier,\ndiff --git rmw_gurumdds_cpp/src/context_listener_thread.cpp rmw_gurumdds_cpp/src/context_listener_thread.cpp\nindex 4394674..39e3fec 100644\n--- rmw_gurumdds_cpp/src/context_listener_thread.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/context_listener_thread.cpp\n@@ -32,6 \u002B32,7 @@\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/wait.hpp\u0022\n \n static\n dds_Condition *\ndiff --git rmw_gurumdds_cpp/src/rmw_context_impl.cpp rmw_gurumdds_cpp/src/rmw_context_impl.cpp\nindex 41cd817..0f95ac8 100644\n--- rmw_gurumdds_cpp/src/rmw_context_impl.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_context_impl.cpp\n@@ -12,12 \u002B12,204 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n\u002B#include \u003Ccstdint\u003E\n #include \u003Ccstring\u003E\n\u002B#include \u003Cmap\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n \n\u002B#include \u0022rmw/impl/cpp/key_value.hpp\u0022\n\u002B\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n \n using rmw_dds_common::msg::ParticipantEntitiesInfo;\n \n\u002Bnamespace rmw_gurumdds_cpp\n\u002B{\n\u002Bstatic inline std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E\n\u002Bparse_map(uint8_t * const data, const uint32_t data_len)\n\u002B{\n\u002B  std::vector\u003Cuint8_t\u003E data_vec(data, data \u002B data_len);\n\u002B  std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E map\n\u002B    = rmw::impl::cpp::parse_key_value(data_vec);\n\u002B  return map;\n\u002B}\n\u002B\n\u002Bstatic inline rmw_ret_t\n\u002Bget_user_data_key(\n\u002B  dds_ParticipantBuiltinTopicData * data,\n\u002B  const std::string\u0026 key,\n\u002B  std::string \u0026 value,\n\u002B  bool \u0026 found)\n\u002B{\n\u002B  found = false;\n\u002B  uint8_t * user_data =\n\u002B    static_cast\u003Cuint8_t *\u003E(data-\u003Euser_data.value);\n\u002B  const uint32_t user_data_len = data-\u003Euser_data.size;\n\u002B  if (user_data_len == 0) {\n\u002B    return RMW_RET_OK;\n\u002B  }\n\u002B\n\u002B  auto map = parse_map(user_data, user_data_len);\n\u002B  auto name_found = map.find(key);\n\u002B  if (name_found != map.end()) {\n\u002B    value = std::string(name_found-\u003Esecond.begin(), name_found-\u003Esecond.end());\n\u002B    found = true;\n\u002B  }\n\u002B\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n\u002Bvoid on_participant_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_ParticipantBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle)\n\u002B{\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n\u002B  if (ctx == nullptr) {\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid{*data};\n\u002B  if (handle == dds_HANDLE_NIL) {\n\u002B    rmw_gurumdds_cpp::graph_cache::remove_participant(ctx, \u0026dp_guid);\n\u002B  } else {\n\u002B    std::string enclave_str;\n\u002B    bool enclave_found;\n\u002B    dds_ReturnCode_t rc =\n\u002B      get_user_data_key(\n\u002B      const_cast\u003Cdds_ParticipantBuiltinTopicData *\u003E(data),\n\u002B      \u0022securitycontext\u0022, enclave_str, enclave_found);\n\u002B    if (RMW_RET_OK != rc) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to parse user data for enclave\u0022);\n\u002B    }\n\u002B\n\u002B    const char * enclave = nullptr;\n\u002B    if (enclave_found) {\n\u002B      enclave = enclave_str.c_str();\n\u002B    }\n\u002B\n\u002B    if (RMW_RET_OK != rmw_gurumdds_cpp::graph_cache::add_participant(ctx, \u0026dp_guid, enclave)) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to assert remote participant in graph\u0022);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid on_publication_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_PublicationBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle)\n\u002B{\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n\u002B  if (ctx == nullptr) {\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n\u002B  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n\u002B  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n\u002B  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n\u002B  if (handle == dds_HANDLE_NIL) {\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      \u0022pub on data available\u0022,\n\u002B      \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n\u002B      endp_guid.entityId);\n\u002B    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n\u002B  } else {\n\u002B    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n\u002B      ctx,\n\u002B      \u0026endp_guid,\n\u002B      \u0026dp_guid,\n\u002B      data-\u003Etopic_name,\n\u002B      data-\u003Etype_name,\n\u002B      data-\u003Euser_data,\n\u002B      \u0026data-\u003Ereliability,\n\u002B      \u0026data-\u003Edurability,\n\u002B      \u0026data-\u003Edeadline,\n\u002B      \u0026data-\u003Eliveliness,\n\u002B      \u0026data-\u003Elifespan,\n\u002B      false);\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      \u0022pub on data available\u0022,\n\u002B      \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n\u002B      \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n\u002B      dp_guid_prefix[0],\n\u002B      dp_guid_prefix[1],\n\u002B      dp_guid_prefix[2],\n\u002B      dp_guid.entityId,\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n\u002B      endp_guid.entityId);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid on_subscription_changed(\n\u002B  const dds_DomainParticipant * a_participant,\n\u002B  const dds_SubscriptionBuiltinTopicData * data,\n\u002B  dds_InstanceHandle_t handle)\n\u002B{\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n\u002B  if (ctx == nullptr) {\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n\u002B  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n\u002B  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n\u002B  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n\u002B  if (handle == dds_HANDLE_NIL) {\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      \u0022sub on data available\u0022,\n\u002B      \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n\u002B      endp_guid.entityId);\n\u002B    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n\u002B  } else {\n\u002B    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n\u002B      ctx,\n\u002B      \u0026endp_guid,\n\u002B      \u0026dp_guid,\n\u002B      data-\u003Etopic_name,\n\u002B      data-\u003Etype_name,\n\u002B      data-\u003Euser_data,\n\u002B      \u0026data-\u003Ereliability,\n\u002B      \u0026data-\u003Edurability,\n\u002B      \u0026data-\u003Edeadline,\n\u002B      \u0026data-\u003Eliveliness,\n\u002B      nullptr,\n\u002B      true);\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      \u0022sub on data available\u0022,\n\u002B      \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n\u002B      \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n\u002B      dp_guid_prefix[0],\n\u002B      dp_guid_prefix[1],\n\u002B      dp_guid_prefix[2],\n\u002B      dp_guid.entityId,\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n\u002B      endp_guid.entityId);\n\u002B  }\n\u002B}\n\u002B} // namespace rmw_gurumdds_cpp\n\u002B\n rmw_context_impl_s::rmw_context_impl_s(rmw_context_t* const base)\n   : common_ctx(),\n   base(base),\ndiff --git rmw_gurumdds_cpp/src/types.cpp rmw_gurumdds_cpp/src/types.cpp\nindex f80f865..bc8eafb 100644\n--- rmw_gurumdds_cpp/src/types.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/types.cpp\n@@ -14,8 \u002B14,6 @@\n \n #include \u003Ccstdint\u003E\n \n-#include \u0022rmw/impl/cpp/key_value.hpp\u0022\n-\n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n@@ -301,188 \u002B299,6 @@ bool PublisherInfo::has_callback_unsafe(rmw_event_type_t event_type) const\n   return ((mask | dds_INCONSISTENT_TOPIC_STATUS) \u0026 rmw_gurumdds_cpp::get_status_kind_from_rmw(event_type)) \u003E 0;\n }\n \n-static inline std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E\n-parse_map(uint8_t * const data, const uint32_t data_len)\n-{\n-  std::vector\u003Cuint8_t\u003E data_vec(data, data \u002B data_len);\n-  std::map\u003Cstd::string, std::vector\u003Cuint8_t\u003E\u003E map\n-    = rmw::impl::cpp::parse_key_value(data_vec);\n-  return map;\n-}\n-\n-static inline rmw_ret_t\n-get_user_data_key(\n-  dds_ParticipantBuiltinTopicData * data,\n-  const std::string\u0026 key,\n-  std::string \u0026 value,\n-  bool \u0026 found)\n-{\n-  found = false;\n-  uint8_t * user_data =\n-    static_cast\u003Cuint8_t *\u003E(data-\u003Euser_data.value);\n-  const uint32_t user_data_len = data-\u003Euser_data.size;\n-  if (user_data_len == 0) {\n-    return RMW_RET_OK;\n-  }\n-\n-  auto map = parse_map(user_data, user_data_len);\n-  auto name_found = map.find(key);\n-  if (name_found != map.end()) {\n-    value = std::string(name_found-\u003Esecond.begin(), name_found-\u003Esecond.end());\n-    found = true;\n-  }\n-\n-  return RMW_RET_OK;\n-}\n-\n-void on_participant_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_ParticipantBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid{*data};\n-  if (handle == dds_HANDLE_NIL) {\n-    rmw_gurumdds_cpp::graph_cache::remove_participant(ctx, \u0026dp_guid);\n-  } else {\n-    std::string enclave_str;\n-    bool enclave_found;\n-    dds_ReturnCode_t rc =\n-      get_user_data_key(\n-      const_cast\u003Cdds_ParticipantBuiltinTopicData *\u003E(data),\n-      \u0022securitycontext\u0022, enclave_str, enclave_found);\n-    if (RMW_RET_OK != rc) {\n-      RMW_SET_ERROR_MSG(\u0022failed to parse user data for enclave\u0022);\n-    }\n-\n-    const char * enclave = nullptr;\n-    if (enclave_found) {\n-      enclave = enclave_str.c_str();\n-    }\n-\n-    if (RMW_RET_OK != rmw_gurumdds_cpp::graph_cache::add_participant(ctx, \u0026dp_guid, enclave)) {\n-      RMW_SET_ERROR_MSG(\u0022failed to assert remote participant in graph\u0022);\n-    }\n-  }\n-}\n-\n-void on_publication_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_PublicationBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n-  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n-  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n-  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n-  if (handle == dds_HANDLE_NIL) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022pub on data available\u0022,\n-      \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n-  } else {\n-    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n-      ctx,\n-      \u0026endp_guid,\n-      \u0026dp_guid,\n-      data-\u003Etopic_name,\n-      data-\u003Etype_name,\n-      data-\u003Euser_data,\n-      \u0026data-\u003Ereliability,\n-      \u0026data-\u003Edurability,\n-      \u0026data-\u003Edeadline,\n-      \u0026data-\u003Eliveliness,\n-      \u0026data-\u003Elifespan,\n-      false);\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022pub on data available\u0022,\n-      \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n-      \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n-      dp_guid_prefix[0],\n-      dp_guid_prefix[1],\n-      dp_guid_prefix[2],\n-      dp_guid.entityId,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-  }\n-}\n-\n-void on_subscription_changed(\n-  const dds_DomainParticipant * a_participant,\n-  const dds_SubscriptionBuiltinTopicData * data,\n-  dds_InstanceHandle_t handle)\n-{\n-  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n-  );\n-  if (ctx == nullptr) {\n-    return;\n-  }\n-\n-  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n-  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n-  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n-  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n-  if (handle == dds_HANDLE_NIL) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022sub on data available\u0022,\n-      \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-    rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n-  } else {\n-    rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n-      ctx,\n-      \u0026endp_guid,\n-      \u0026dp_guid,\n-      data-\u003Etopic_name,\n-      data-\u003Etype_name,\n-      data-\u003Euser_data,\n-      \u0026data-\u003Ereliability,\n-      \u0026data-\u003Edurability,\n-      \u0026data-\u003Edeadline,\n-      \u0026data-\u003Eliveliness,\n-      nullptr,\n-      true);\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      \u0022sub on data available\u0022,\n-      \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n-      \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n-      dp_guid_prefix[0],\n-      dp_guid_prefix[1],\n-      dp_guid_prefix[2],\n-      dp_guid.entityId,\n-      endp_guid_prefix[0],\n-      endp_guid_prefix[1],\n-      endp_guid_prefix[2],\n-      endp_guid.entityId);\n-  }\n-}\n-\n rmw_ret_t SubscriberInfo::set_on_new_event_callback(\n   rmw_event_type_t event_type,\n   const void * user_data,\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "1de5341620d82edca803892becfffa98ba467ce4",
    "RawMessage": "Add serialize/deserialize API test coverage. (#118)",
    "Changes": "diff --git test_rmw_implementation/CMakeLists.txt test_rmw_implementation/CMakeLists.txt\nindex bcce172..e08a439 100644\n--- test_rmw_implementation/CMakeLists.txt\n\u002B\u002B\u002B test_rmw_implementation/CMakeLists.txt\n@@ -77,6 \u002B77,16 @@ if(BUILD_TESTING)\n     ament_target_dependencies(test_subscription${target_suffix}\n       rcutils rmw rmw_implementation test_msgs\n     )\n\u002B\n\u002B    ament_add_gtest(test_serialize_deserialize${target_suffix}\n\u002B      test/test_serialize_deserialize.cpp\n\u002B      ENV ${rmw_implementation_env_var}\n\u002B    )\n\u002B    target_compile_definitions(test_serialize_deserialize${target_suffix}\n\u002B      PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n\u002B    ament_target_dependencies(test_serialize_deserialize${target_suffix}\n\u002B      rcutils rmw rmw_implementation test_msgs\n\u002B    )\n   endmacro()\n \n   call_for_each_rmw_implementation(test_api)\ndiff --git test_rmw_implementation/test/test_serialize_deserialize.cpp test_rmw_implementation/test/test_serialize_deserialize.cpp\nnew file mode 100644\nindex 0000000..071099e\n--- /dev/null\n\u002B\u002B\u002B test_rmw_implementation/test/test_serialize_deserialize.cpp\n@@ -0,0 \u002B1,118 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B\n\u002B#include \u0022rosidl_typesupport_cpp/message_type_support.hpp\u0022\n\u002B\n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B\n\u002B#include \u0022test_msgs/msg/basic_types.h\u0022\n\u002B#include \u0022test_msgs/msg/basic_types.hpp\u0022\n\u002B\n\u002B#include \u0022./allocator_testing_utils.h\u0022\n\u002B\n\u002B#ifdef RMW_IMPLEMENTATION\n\u002B# define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n\u002B# define CLASSNAME(NAME, SUFFIX) CLASSNAME_(NAME, SUFFIX)\n\u002B#else\n\u002B# define CLASSNAME(NAME, SUFFIX) NAME\n\u002B#endif\n\u002B\n\u002Bclass CLASSNAME (TestSerializeDeserialize, RMW_IMPLEMENTATION) : public ::testing::Test\n\u002B{\n\u002B};\n\u002B\n\u002BTEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), serialize_with_bad_arguments) {\n\u002B  const rosidl_message_type_support_t * ts{\n\u002B    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n\u002B  test_msgs__msg__BasicTypes input_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026input_message));\n\u002B  rcutils_allocator_t failing_allocator = get_failing_allocator();\n\u002B  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n\u002B  ASSERT_EQ(\n\u002B    RMW_RET_OK, rmw_serialized_message_init(\n\u002B      \u0026serialized_message, 0lu, \u0026failing_allocator)) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  EXPECT_NE(RMW_RET_OK, rmw_serialize(\u0026input_message, ts, \u0026serialized_message));\n\u002B  rmw_reset_error();\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(\u0026serialized_message)) \u003C\u003C\n\u002B    rmw_get_error_string().str;\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), clean_round_trip_for_c_message) {\n\u002B  const rosidl_message_type_support_t * ts{\n\u002B    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n\u002B  test_msgs__msg__BasicTypes input_message{};\n\u002B  test_msgs__msg__BasicTypes output_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026input_message));\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n\u002B  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n\u002B  ASSERT_EQ(\n\u002B    RMW_RET_OK, rmw_serialized_message_init(\n\u002B      \u0026serialized_message, 0lu, \u0026default_allocator)) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  // Make input_message not equal to output_message.\n\u002B  input_message.bool_value = !output_message.bool_value;\n\u002B  input_message.int16_value = output_message.int16_value - 1;\n\u002B  input_message.uint32_value = output_message.uint32_value \u002B 1000000;\n\u002B\n\u002B  rmw_ret_t ret = rmw_serialize(\u0026input_message, ts, \u0026serialized_message);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_NE(nullptr, serialized_message.buffer);\n\u002B  EXPECT_GT(serialized_message.buffer_length, 0lu);\n\u002B\n\u002B  ret = rmw_deserialize(\u0026serialized_message, ts, \u0026output_message);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(input_message.bool_value, output_message.bool_value);\n\u002B  EXPECT_EQ(input_message.int16_value, output_message.int16_value);\n\u002B  EXPECT_EQ(input_message.uint32_value, output_message.uint32_value);\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(\u0026serialized_message)) \u003C\u003C\n\u002B    rmw_get_error_string().str;\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestSerializeDeserialize, RMW_IMPLEMENTATION), clean_round_trip_for_cpp_message) {\n\u002B  const rosidl_message_type_support_t * ts =\n\u002B    rosidl_typesupport_cpp::get_message_type_support_handle\u003Ctest_msgs::msg::BasicTypes\u003E();\n\u002B  test_msgs::msg::BasicTypes input_message{};\n\u002B  test_msgs::msg::BasicTypes output_message{};\n\u002B  rcutils_allocator_t default_allocator = rcutils_get_default_allocator();\n\u002B  rmw_serialized_message_t serialized_message = rmw_get_zero_initialized_serialized_message();\n\u002B  ASSERT_EQ(\n\u002B    RMW_RET_OK, rmw_serialized_message_init(\n\u002B      \u0026serialized_message, 0lu, \u0026default_allocator)) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  // Make input_message not equal to output_message.\n\u002B  input_message.bool_value = !output_message.bool_value;\n\u002B  input_message.int16_value = output_message.int16_value - 1;\n\u002B  input_message.uint32_value = output_message.uint32_value \u002B 1000000;\n\u002B\n\u002B  rmw_ret_t ret = rmw_serialize(\u0026input_message, ts, \u0026serialized_message);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_NE(nullptr, serialized_message.buffer);\n\u002B  EXPECT_GT(serialized_message.buffer_length, 0lu);\n\u002B\n\u002B  ret = rmw_deserialize(\u0026serialized_message, ts, \u0026output_message);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B  EXPECT_EQ(input_message, output_message);\n\u002B\n\u002B  EXPECT_EQ(RMW_RET_OK, rmw_serialized_message_fini(\u0026serialized_message)) \u003C\u003C\n\u002B    rmw_get_error_string().str;\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "0034929eef9f6626530d8207030b791e121a5415",
    "RawMessage": "to support declare parameter with int and float vector (#1696)",
    "Changes": "diff --git rclcpp/include/rclcpp/parameter_value.hpp rclcpp/include/rclcpp/parameter_value.hpp\nindex 77bcdec5..f74c36a8 100644\n--- rclcpp/include/rclcpp/parameter_value.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_value.hpp\n@@ -301,6 \u002B301,16 @@ public:\n     return get\u003CParameterType::PARAMETER_BOOL_ARRAY\u003E();\n   }\n \n\u002B  template\u003Ctypename type\u003E\n\u002B  constexpr\n\u002B  typename std::enable_if\u003C\n\u002B    std::is_convertible\u003C\n\u002B      type, const std::vector\u003Cint\u003E \u0026\u003E::value, const std::vector\u003Cint64_t\u003E \u0026\u003E::type\n\u002B  get() const\n\u002B  {\n\u002B    return get\u003CParameterType::PARAMETER_INTEGER_ARRAY\u003E();\n\u002B  }\n\u002B\n   template\u003Ctypename type\u003E\n   constexpr\n   typename std::enable_if\u003C\n@@ -311,6 \u002B321,16 @@ public:\n     return get\u003CParameterType::PARAMETER_INTEGER_ARRAY\u003E();\n   }\n \n\u002B  template\u003Ctypename type\u003E\n\u002B  constexpr\n\u002B  typename std::enable_if\u003C\n\u002B    std::is_convertible\u003C\n\u002B      type, const std::vector\u003Cfloat\u003E \u0026\u003E::value, const std::vector\u003Cdouble\u003E \u0026\u003E::type\n\u002B  get() const\n\u002B  {\n\u002B    return get\u003CParameterType::PARAMETER_DOUBLE_ARRAY\u003E();\n\u002B  }\n\u002B\n   template\u003Ctypename type\u003E\n   constexpr\n   typename std::enable_if\u003C\ndiff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex 8d2e8a84..1ac009eb 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -16,6 \u002B16,7 @@\n \n #include \u003Cchrono\u003E\n #include \u003Cfunctional\u003E\n\u002B#include \u003Climits\u003E\n #include \u003Cmap\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n@@ -2515,6 \u002B2516,59 @@ TEST_F(TestNode, get_parameter_types_undeclared_parameters_allowed) {\n   }\n }\n \n\u002B// test declare parameter with int, int64_t, float and double vector\n\u002BTEST_F(TestNode, declare_parameter_with_vector) {\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022test_declare_parameter_with_vector\u0022_unq,\n\u002B    rclcpp::NodeOptions().allow_undeclared_parameters(true));\n\u002B  {\n\u002B    // declare parameter and then get types to check\n\u002B    auto name1 = \u0022parameter\u0022_unq;\n\u002B    auto name2 = \u0022parameter\u0022_unq;\n\u002B    auto name3 = \u0022parameter\u0022_unq;\n\u002B    auto name4 = \u0022parameter\u0022_unq;\n\u002B\n\u002B    node-\u003Edeclare_parameter(name1, std::vector\u003Cint\u003E{});\n\u002B    node-\u003Edeclare_parameter(name2, std::vector\u003Cint64_t\u003E{});\n\u002B    node-\u003Edeclare_parameter(name3, std::vector\u003Cfloat\u003E{});\n\u002B    node-\u003Edeclare_parameter(name4, std::vector\u003Cdouble\u003E{});\n\u002B\n\u002B    EXPECT_TRUE(node-\u003Ehas_parameter(name1));\n\u002B    EXPECT_TRUE(node-\u003Ehas_parameter(name2));\n\u002B    EXPECT_TRUE(node-\u003Ehas_parameter(name3));\n\u002B    EXPECT_TRUE(node-\u003Ehas_parameter(name4));\n\u002B\n\u002B    auto results = node-\u003Eget_parameter_types({name1, name2, name3, name4});\n\u002B    EXPECT_EQ(results.size(), 4u);\n\u002B    EXPECT_EQ(results[0], rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY);\n\u002B    EXPECT_EQ(results[1], rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY);\n\u002B    EXPECT_EQ(results[2], rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY);\n\u002B    EXPECT_EQ(results[3], rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE_ARRAY);\n\u002B  }\n\u002B  {\n\u002B    // declare parameter and then get values to check\n\u002B    auto name1 = \u0022parameter\u0022_unq;\n\u002B    auto name2 = \u0022parameter\u0022_unq;\n\u002B    auto name3 = \u0022parameter\u0022_unq;\n\u002B    auto name4 = \u0022parameter\u0022_unq;\n\u002B\n\u002B    int64_t bigger_than_int = INT64_MAX - 42;\n\u002B    double bigger_than_float = std::numeric_limits\u003Cdouble\u003E::max() - 42;\n\u002B    node-\u003Edeclare_parameter(name1, std::vector\u003Cint\u003E{1, 2});\n\u002B    node-\u003Edeclare_parameter(name2, std::vector\u003Cint64_t\u003E{3, bigger_than_int});\n\u002B    node-\u003Edeclare_parameter(name3, std::vector\u003Cfloat\u003E{1.5f, 2.8f});\n\u002B    node-\u003Edeclare_parameter(name4, std::vector\u003Cdouble\u003E{3.0, bigger_than_float});\n\u002B\n\u002B    std::vector\u003Crclcpp::Parameter\u003E expected = {\n\u002B      {name1, std::vector\u003Cint\u003E{1, 2}},\n\u002B      {name2, std::vector\u003Cint64_t\u003E{3, bigger_than_int}},\n\u002B      {name3, std::vector\u003Cfloat\u003E{1.5f, 2.8f}},\n\u002B      {name4, std::vector\u003Cdouble\u003E{3.0, bigger_than_float}},\n\u002B    };\n\u002B    EXPECT_EQ(node-\u003Eget_parameters({name1, name2, name3, name4}), expected);\n\u002B  }\n\u002B}\n\u002B\n void expect_qos_profile_eq(\n   const rmw_qos_profile_t \u0026 qos1, const rmw_qos_profile_t \u0026 qos2, bool is_publisher)\n {\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "22297618b040a20ec496a06247b855714a4e01f6",
    "RawMessage": "Remove sleep before fill tnat",
    "Changes": "diff --git rmw_gurumdds_shared_cpp/src/rmw_topic_names_and_types.cpp rmw_gurumdds_shared_cpp/src/rmw_topic_names_and_types.cpp\nindex cd4f66f..67b44cb 100644\n--- rmw_gurumdds_shared_cpp/src/rmw_topic_names_and_types.cpp\n\u002B\u002B\u002B rmw_gurumdds_shared_cpp/src/rmw_topic_names_and_types.cpp\n@@ -15,8 \u002B15,6 @@\n #include \u003Cmap\u003E\n #include \u003Cset\u003E\n #include \u003Cstring\u003E\n-#include \u003Cchrono\u003E\n-#include \u003Cthread\u003E\n \n #include \u0022rcutils/allocator.h\u0022\n #include \u0022rcutils/logging_macros.h\u0022\n@@ -72,7 \u002B70,6 @@ shared__rmw_get_topic_names_and_types(\n     return RMW_RET_ERROR;\n   }\n \n-  std::this_thread::sleep_for(std::chrono::microseconds(100));\n   std::map\u003Cstd::string, std::set\u003Cstd::string\u003E\u003E topics;\n   node_info-\u003Epub_listener-\u003Efill_topic_names_and_types(no_demangle, topics);\n   node_info-\u003Esub_listener-\u003Efill_topic_names_and_types(no_demangle, topics);\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "89f56e13095c57f9485e289c916cc62754f02575",
    "RawMessage": "add option to support use_sim_time. (#581)",
    "Changes": "diff --git ros2cli/ros2cli/node/direct.py ros2cli/ros2cli/node/direct.py\nindex d61c491..c426394 100644\n--- ros2cli/ros2cli/node/direct.py\n\u002B\u002B\u002B ros2cli/ros2cli/node/direct.py\n@@ -17,6 \u002B17,7 @@ import os\n import rclpy\n import rclpy.action\n \n\u002Bfrom rclpy.parameter import Parameter\n from ros2cli.node import NODE_NAME_PREFIX\n DEFAULT_TIMEOUT = 0.5\n \n@@ -38,13 \u002B39,18 @@ class DirectNode:\n             args, \u0027node_name_suffix\u0027, \u0027_%d\u0027 % os.getpid())\n         start_parameter_services = getattr(\n             args, \u0027start_parameter_services\u0027, False)\n\u002B        use_sim_time = getattr(args, \u0027use_sim_time\u0027, False)\n \n         if node_name is None:\n             node_name = NODE_NAME_PREFIX \u002B node_name_suffix\n \n         self.node = rclpy.create_node(\n             node_name,\n-            start_parameter_services=start_parameter_services)\n\u002B            start_parameter_services=start_parameter_services,\n\u002B            parameter_overrides=[\n\u002B                Parameter(\u0027use_sim_time\u0027, value=use_sim_time)\n\u002B            ])\n\u002B\n         timeout = getattr(args, \u0027spin_time\u0027, DEFAULT_TIMEOUT)\n         timer = self.node.create_timer(timeout, timer_callback)\n \n@@ -86,3 \u002B92,6 @@ def add_arguments(parser):\n         \u0027--spin-time\u0027, type=float, default=DEFAULT_TIMEOUT,\n         help=\u0027Spin time in seconds to wait for discovery (only applies when \u0027\n              \u0027not using an already running daemon)\u0027)\n\u002B    parser.add_argument(\n\u002B        \u0027-s\u0027, \u0027--use-sim-time\u0027, action=\u0027store_true\u0027,\n\u002B        help=\u0027Enable ROS simulation time\u0027)\ndiff --git ros2cli/test/test_direct.py ros2cli/test/test_direct.py\nnew file mode 100644\nindex 0000000..d7c50ab\n--- /dev/null\n\u002B\u002B\u002B ros2cli/test/test_direct.py\n@@ -0,0 \u002B1,63 @@\n\u002B# Copyright 2020 Sony Corporation.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport argparse\n\u002B\n\u002Bimport pytest\n\u002B\n\u002Bfrom ros2cli.node.direct import add_arguments as add_direct_node_arguments\n\u002Bfrom ros2cli.node.direct import DEFAULT_TIMEOUT\n\u002Bfrom ros2cli.node.direct import DirectNode\n\u002B\n\u002BTEST_NODE_NAME = \u0027test_node\u0027\n\u002B\n\u002B\n\u002B@pytest.fixture(scope=\u0027function\u0027)\n\u002Bdef test_arguments_parser():\n\u002B    parser = argparse.ArgumentParser()\n\u002B    add_direct_node_arguments(parser)\n\u002B    return parser\n\u002B\n\u002B\n\u002Bdef test_default_arguments(test_arguments_parser):\n\u002B    args = test_arguments_parser.parse_args()\n\u002B    assert not args.use_sim_time\n\u002B    assert DEFAULT_TIMEOUT == args.spin_time\n\u002B\n\u002B\n\u002Bdef test_use_sim_time_arguments(test_arguments_parser):\n\u002B    args = test_arguments_parser.parse_args([\u0027--use-sim-time\u0027])\n\u002B    assert args.use_sim_time\n\u002B    assert DEFAULT_TIMEOUT == args.spin_time\n\u002B\n\u002B\n\u002Bdef test_spin_time_arguments(test_arguments_parser):\n\u002B    args = test_arguments_parser.parse_args([\u0027--spin-time\u0027, \u002710.0\u0027])\n\u002B    assert not args.use_sim_time\n\u002B    assert 10.0 == args.spin_time\n\u002B\n\u002B\n\u002Bdef test_use_sim_time_parameter():\n\u002B    with DirectNode(args=[], node_name=TEST_NODE_NAME) as direct_node:\n\u002B        assert not direct_node.node.get_parameter(\u0027use_sim_time\u0027).value\n\u002B\n\u002B    args = argparse.Namespace(use_sim_time=False)\n\u002B    with DirectNode(args, node_name=TEST_NODE_NAME) as direct_node:\n\u002B        assert not direct_node.node.get_parameter(\u0027use_sim_time\u0027).value\n\u002B\n\u002B    # TODO(fujitatomoya): enable this test once /clock callback thread is insulated.\n\u002B    #                     see https://github.com/ros2/rclcpp/issues/1542\n\u002B    # args = argparse.Namespace(use_sim_time=True)\n\u002B    # with DirectNode(args, node_name=TEST_NODE_NAME) as direct_node:\n\u002B    #     assert direct_node.node.get_parameter(\u0027use_sim_time\u0027).value\ndiff --git ros2topic/ros2topic/verb/delay.py ros2topic/ros2topic/verb/delay.py\nindex 0eb7152..d9b876f 100644\n--- ros2topic/ros2topic/verb/delay.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/delay.py\n@@ -40,6 \u002B40,7 @@ import rclpy\n \n from rclpy.qos import qos_profile_sensor_data\n from rclpy.time import Time\n\u002Bfrom ros2cli.node.direct import add_arguments as add_direct_node_arguments\n from ros2cli.node.direct import DirectNode\n from ros2topic.api import get_msg_class\n from ros2topic.api import TopicNameCompleter\n@@ -71,6 \u002B72,7 @@ class DelayVerb(VerbExtension):\n             \u0027--window\u0027, \u0027-w\u0027, type=positive_int, default=DEFAULT_WINDOW_SIZE,\n             help=\u0027window size, in # of messages, for calculating rate, \u0027\n                  \u0027string to (default: %d)\u0027 % DEFAULT_WINDOW_SIZE)\n\u002B        add_direct_node_arguments(parser)\n \n     def main(self, *, args):\n         return main(args)\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "12e514de0d2175b095d420596dc4b661839f570d",
    "RawMessage": "Allow null arguments in the EventsExecutor parameters (#602)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/rmw_client.cpp rmw_fastrtps_cpp/src/rmw_client.cpp\nindex 64cd8d9..d376bdc 100644\n--- rmw_fastrtps_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_client.cpp\n@@ -538,7 \u002B538,6 @@ rmw_client_set_on_new_response_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_client, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_client_set_on_new_response_callback(\n     rmw_client,\ndiff --git rmw_fastrtps_cpp/src/rmw_event.cpp rmw_fastrtps_cpp/src/rmw_event.cpp\nindex e318034..56d8779 100644\n--- rmw_fastrtps_cpp/src/rmw_event.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_event.cpp\n@@ -55,7 \u002B55,6 @@ rmw_event_set_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_event, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_event_set_callback(\n     rmw_event,\ndiff --git rmw_fastrtps_cpp/src/rmw_service.cpp rmw_fastrtps_cpp/src/rmw_service.cpp\nindex 70b3c80..a14d609 100644\n--- rmw_fastrtps_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_service.cpp\n@@ -537,7 \u002B537,6 @@ rmw_service_set_on_new_request_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_service, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_service_set_on_new_request_callback(\n     rmw_service,\ndiff --git rmw_fastrtps_cpp/src/rmw_subscription.cpp rmw_fastrtps_cpp/src/rmw_subscription.cpp\nindex 44df4a4..41172d2 100644\n--- rmw_fastrtps_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_subscription.cpp\n@@ -228,7 \u002B228,6 @@ rmw_subscription_set_on_new_message_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_subscription, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_subscription_set_on_new_message_callback(\n     rmw_subscription,\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_client.cpp rmw_fastrtps_dynamic_cpp/src/rmw_client.cpp\nindex 57a1580..e759cd0 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_client.cpp\n@@ -585,7 \u002B585,6 @@ rmw_client_set_on_new_response_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_client, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_client_set_on_new_response_callback(\n     rmw_client,\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_event.cpp rmw_fastrtps_dynamic_cpp/src/rmw_event.cpp\nindex 869e1f0..1316357 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_event.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_event.cpp\n@@ -55,7 \u002B55,6 @@ rmw_event_set_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_event, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_event_set_callback(\n     rmw_event,\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_service.cpp rmw_fastrtps_dynamic_cpp/src/rmw_service.cpp\nindex 6cf4710..1d0fce7 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_service.cpp\n@@ -584,7 \u002B584,6 @@ rmw_service_set_on_new_request_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_service, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_service_set_on_new_request_callback(\n     rmw_service,\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\nindex 973fed8..5a9933a 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n@@ -229,7 \u002B229,6 @@ rmw_subscription_set_on_new_message_callback(\n   const void * user_data)\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(rmw_subscription, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(callback, RMW_RET_INVALID_ARGUMENT);\n \n   return rmw_fastrtps_shared_cpp::__rmw_subscription_set_on_new_message_callback(\n     rmw_subscription,\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "4ad1eba618fc1d5e11d0319f6648d484daeb3008",
    "RawMessage": "Added CameraInfo display (#1166)",
    "Changes": "diff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex f1f84a69..2d6c3b6c 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -83,6 \u002B83,7 @@ find_package(visualization_msgs REQUIRED)\n set(rviz_default_plugins_headers_to_moc\n   include/rviz_default_plugins/displays/accel/accel_display.hpp\n   include/rviz_default_plugins/displays/axes/axes_display.hpp\n\u002B  include/rviz_default_plugins/displays/camera_info/camera_info_display.hpp\n   include/rviz_default_plugins/displays/camera/camera_display.hpp\n   include/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.hpp\n   include/rviz_default_plugins/displays/effort/effort_display.hpp\n@@ -140,6 \u002B141,7 @@ endforeach()\n set(rviz_default_plugins_source_files\n   src/rviz_default_plugins/displays/accel/accel_display.cpp\n   src/rviz_default_plugins/displays/axes/axes_display.cpp\n\u002B  src/rviz_default_plugins/displays/camera_info/camera_info_display.cpp\n   src/rviz_default_plugins/displays/camera/camera_display.cpp\n   src/rviz_default_plugins/displays/depth_cloud/depth_cloud_display.cpp\n   src/rviz_default_plugins/displays/effort/effort_display.cpp\n@@ -755,6 \u002B757,19 @@ if(BUILD_TESTING)\n     )\n   endif()\n \n\u002B  ament_add_gtest(camera_info_display_visual_test\n\u002B    test/rviz_default_plugins/displays/camera_info/camera_info_display_visual_test.cpp\n\u002B    test/rviz_default_plugins/page_objects/camera_info_display_page_object.cpp\n\u002B    ${SKIP_VISUAL_TESTS}\n\u002B    TIMEOUT 180)\n\u002B  if(TARGET camera_info_display_visual_test)\n\u002B    target_include_directories(camera_info_display_visual_test PRIVATE test)\n\u002B    target_link_libraries(camera_info_display_visual_test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      ogre_testing_environment\n\u002B    )\n\u002B  endif()\n\u002B\n   add_library(point_cloud_common_page_object STATIC test/rviz_default_plugins/page_objects/point_cloud_common_page_object.cpp)\n   target_link_libraries(point_cloud_common_page_object PRIVATE Qt5::Test rviz_visual_testing_framework::rviz_visual_testing_framework)\n \ndiff --git rviz_default_plugins/include/rviz_default_plugins/displays/camera_info/camera_info_display.hpp rviz_default_plugins/include/rviz_default_plugins/displays/camera_info/camera_info_display.hpp\nnew file mode 100644\nindex 00000000..718d73c8\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/camera_info/camera_info_display.hpp\n@@ -0,0 \u002B1,124 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_\n\u002B#define RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_\n\u002B\n\u002B#ifndef Q_MOC_RUN\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u0022rviz_default_plugins/visibility_control.hpp\u0022\n\u002B\n\u002B#include \u003Crviz_common/message_filter_display.hpp\u003E\n\u002B#include \u003Crviz_common/properties/property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/bool_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/color_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/float_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/ros_topic_property.hpp\u003E\n\u002B#include \u003Crviz_rendering/objects/billboard_line.hpp\u003E\n\u002B#include \u003Crviz_rendering/objects/triangle_polygon.hpp\u003E\n\u002B\n\u002B#include \u003Csensor_msgs/msg/camera_info.hpp\u003E\n\u002B#endif\n\u002B\n\u002Bnamespace rviz_default_plugins\n\u002B{\n\u002Bnamespace displays\n\u002B{\n\u002B/**\n\u002B * \\class CameraInfoDisplay\n\u002B *\n\u002B */\n\u002Bclass RVIZ_DEFAULT_PLUGINS_PUBLIC CameraInfoDisplay\n\u002B  : public rviz_common::MessageFilterDisplay\u003Csensor_msgs::msg::CameraInfo\u003E\n\u002B{\n\u002B  Q_OBJECT\n\u002B\n\u002Bpublic:\n\u002B  CameraInfoDisplay();\n\u002B  ~CameraInfoDisplay() override;\n\u002B\n\u002B  // Overrides of public virtual functions from the Display class.\n\u002B  void onInitialize() override;\n\u002B  void reset() override;\n\u002B\n\u002Bprotected:\n\u002B  void processMessage(const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg);\n\u002B\n\u002B  void update(float wall_dt, float ros_dt) override;\n\u002B  bool isSameCameraInfo(\n\u002B    const sensor_msgs::msg::CameraInfo::ConstSharedPtr \u0026 camera_info);\n\u002B  void createCameraInfoShapes(\n\u002B    const sensor_msgs::msg::CameraInfo::ConstSharedPtr \u0026 camera_info);\n\u002B  void addPointToEdge(\n\u002B    const Ogre::Vector3 \u0026 point);\n\u002B  void addPolygon(\n\u002B    const Ogre::Vector3 \u0026 O, const Ogre::Vector3 \u0026 A, const Ogre::Vector3 \u0026 B, std::string name,\n\u002B    bool use_color, bool upper_triangle);\n\u002B  void prepareMaterial();\n\u002B\n\u002B  std::vector\u003Cstd::shared_ptr\u003Crviz_rendering::TrianglePolygon\u003E\u003E polygons_;\n\u002B  std::shared_ptr\u003Crviz_rendering::BillboardLine\u003E edges_;\n\u002B  sensor_msgs::msg::CameraInfo::ConstSharedPtr camera_info_;\n\u002B  Ogre::MaterialPtr material_;\n\u002B  Ogre::TexturePtr texture_;\n\u002B\n\u002B  double alpha_;\n\u002B  double far_clip_distance_;\n\u002B  QColor color_;\n\u002B  QColor edge_color_;\n\u002B  bool show_polygons_;\n\u002B  bool show_edges_;\n\u002B  bool not_show_side_polygons_;\n\u002B\n\u002B  rviz_common::properties::FloatProperty * far_clip_distance_property_;\n\u002B  rviz_common::properties::FloatProperty * alpha_property_;\n\u002B  rviz_common::properties::ColorProperty * color_property_;\n\u002B  rviz_common::properties::ColorProperty * edge_color_property_;\n\u002B  rviz_common::properties::BoolProperty * show_polygons_property_;\n\u002B  rviz_common::properties::BoolProperty * not_show_side_polygons_property_;\n\u002B  rviz_common::properties::BoolProperty * show_edges_property_;\n\u002B\n\u002Bprotected Q_SLOTS:\n\u002B  void updateFarClipDistance();\n\u002B  void updateAlpha();\n\u002B  void updateColor();\n\u002B  void updateShowEdges();\n\u002B  void updateShowPolygons();\n\u002B  void updateNotShowSidePolygons();\n\u002B  void updateEdgeColor();\n\u002B};\n\u002B}  // namespace displays\n\u002B}  // namespace rviz_default_plugins\n\u002B#endif  // RVIZ_DEFAULT_PLUGINS__DISPLAYS__CAMERA_INFO__CAMERA_INFO_DISPLAY_HPP_\ndiff --git rviz_default_plugins/plugins_description.xml rviz_default_plugins/plugins_description.xml\nindex 8bebf818..0b503957 100644\n--- rviz_default_plugins/plugins_description.xml\n\u002B\u002B\u002B rviz_default_plugins/plugins_description.xml\n@@ -46,6 \u002B46,17 @@\n     \u003Cmessage_type\u003Esensor_msgs/msg/Image\u003C/message_type\u003E\n   \u003C/class\u003E\n \n\u002B  \u003Cclass\n\u002B    name=\u0022rviz_default_plugins/CameraInfo\u0022\n\u002B    type=\u0022rviz_default_plugins::displays::CameraInfoDisplay\u0022\n\u002B    base_class_type=\u0022rviz_common::Display\u0022\n\u002B  \u003E\n\u002B    \u003Cdescription\u003E\n\u002B      Displays CameraInfo.\n\u002B    \u003C/description\u003E\n\u002B    \u003Cmessage_type\u003Esensor_msgs/msg/CameraInfo\u003C/message_type\u003E\n\u002B  \u003C/class\u003E\n\u002B\n   \u003Cclass\n     name=\u0022rviz_default_plugins/Effort\u0022\n     type=\u0022rviz_default_plugins::displays::EffortDisplay\u0022\ndiff --git rviz_default_plugins/src/rviz_default_plugins/displays/camera_info/camera_info_display.cpp rviz_default_plugins/src/rviz_default_plugins/displays/camera_info/camera_info_display.cpp\nnew file mode 100644\nindex 00000000..217e14fc\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/camera_info/camera_info_display.cpp\n@@ -0,0 \u002B1,426 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u0022rviz_default_plugins/displays/camera_info/camera_info_display.hpp\u0022\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Csstream\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u003COgreMaterialManager.h\u003E\n\u002B#include \u003COgreTextureManager.h\u003E\n\u002B#include \u003COgreTechnique.h\u003E\n\u002B#include \u003COgreHardwarePixelBuffer.h\u003E\n\u002B\n\u002B#include \u003Crviz_common/uniform_string_stream.hpp\u003E\n\u002B#include \u003Crviz_common/properties/parse_color.hpp\u003E\n\u002B\n\u002B#include \u003Crviz_rendering/objects/triangle_polygon.hpp\u003E\n\u002B\n\u002Bnamespace rviz_default_plugins\n\u002B{\n\u002Bnamespace displays\n\u002B{\n\u002Bstatic const char * const CAM_INFO_STATUS = \u0022Camera Info\u0022;\n\u002B\n\u002BCameraInfoDisplay::CameraInfoDisplay()\n\u002B: rviz_common::MessageFilterDisplay\u003Csensor_msgs::msg::CameraInfo\u003E()\n\u002B{\n\u002B  far_clip_distance_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Far clip\u0022,\n\u002B    1.0,\n\u002B    \u0022Far clip distance from the origin of camera info\u0022,\n\u002B    this, SLOT(updateFarClipDistance()));\n\u002B  show_edges_property_ = new rviz_common::properties::BoolProperty(\n\u002B    \u0022Show edges\u0022,\n\u002B    true,\n\u002B    \u0022Show edges of the region of the camera info\u0022,\n\u002B    this, SLOT(updateShowEdges()));\n\u002B  show_polygons_property_ = new rviz_common::properties::BoolProperty(\n\u002B    \u0022Show polygons\u0022,\n\u002B    true,\n\u002B    \u0022Show polygons of the region of the camera info\u0022,\n\u002B    this, SLOT(updateShowPolygons()));\n\u002B  not_show_side_polygons_property_ = new rviz_common::properties::BoolProperty(\n\u002B    \u0022Not show side polygons\u0022,\n\u002B    true,\n\u002B    \u0022Do not show polygons of the region of the camera info\u0022,\n\u002B    this, SLOT(updateNotShowSidePolygons()));\n\u002B\n\u002B  color_property_ = new rviz_common::properties::ColorProperty(\n\u002B    \u0022Color\u0022,\n\u002B    QColor(85, 255, 255),\n\u002B    \u0022Color of CameraInfo\u0022,\n\u002B    this, SLOT(updateColor()));\n\u002B  edge_color_property_ = new rviz_common::properties::ColorProperty(\n\u002B    \u0022Edge color\u0022,\n\u002B    QColor(125, 125, 125),\n\u002B    \u0022Edge color of CameraInfo\u0022,\n\u002B    this, SLOT(updateEdgeColor()));\n\u002B  alpha_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Alpha\u0022,\n\u002B    0.5,\n\u002B    \u0022Alpha blending value\u0022,\n\u002B    this, SLOT(updateAlpha()));\n\u002B}\n\u002B\n\u002BCameraInfoDisplay::~CameraInfoDisplay()\n\u002B{\n\u002B  if (edges_) {\n\u002B    edges_-\u003Eclear();\n\u002B  }\n\u002B  polygons_.clear();\n\u002B  delete far_clip_distance_property_;\n\u002B  delete color_property_;\n\u002B  delete alpha_property_;\n\u002B  delete show_polygons_property_;\n\u002B  delete edge_color_property_;\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::reset()\n\u002B{\n\u002B  MFDClass::reset();\n\u002B  if (edges_) {\n\u002B    edges_-\u003Eclear();\n\u002B  }\n\u002B  polygons_.clear();\n\u002B  camera_info_ = sensor_msgs::msg::CameraInfo::ConstSharedPtr();\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::onInitialize()\n\u002B{\n\u002B  MFDClass::onInitialize();\n\u002B  scene_node_ = scene_manager_-\u003EgetRootSceneNode()-\u003EcreateChildSceneNode();\n\u002B  updateColor();\n\u002B  updateAlpha();\n\u002B  updateFarClipDistance();\n\u002B  updateShowPolygons();\n\u002B  updateNotShowSidePolygons();\n\u002B  updateShowEdges();\n\u002B  updateEdgeColor();\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::processMessage(\n\u002B  const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg)\n\u002B{\n\u002B  if (!isSameCameraInfo(msg)) {\n\u002B    createCameraInfoShapes(msg);\n\u002B  }\n\u002B  // move scene_node according to tf\n\u002B  Ogre::Vector3 position;\n\u002B  Ogre::Quaternion quaternion;\n\u002B  std::string frame_id = msg-\u003Eheader.frame_id;\n\u002B  if (frame_id[0] == \u0027/\u0027) {\n\u002B    frame_id = frame_id.substr(1, frame_id.size());\n\u002B  }\n\u002B  if (!context_-\u003EgetFrameManager()-\u003EgetTransform(\n\u002B      frame_id,\n\u002B      msg-\u003Eheader.stamp,\n\u002B      position,\n\u002B      quaternion))\n\u002B  {\n\u002B    std::ostringstream sstm;\n\u002B    sstm \u003C\u003C \u0022Error transforming pose \u0027\u0022 \u003C\u003C qPrintable(getName()) \u003C\u003C \u0022\u0027 from frame \u0027\u0022\n\u002B         \u003C\u003C msg-\u003Eheader.frame_id.c_str() \u003C\u003C \u0022\u0027 to frame \u0027\u0022 \u003C\u003C qPrintable(fixed_frame_) \u003C\u003C \u0022\u0027\u0022;\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusLevel::Warn, CAM_INFO_STATUS,\n\u002B      QString(sstm.str().c_str()));\n\u002B  }\n\u002B  scene_node_-\u003EsetPosition(position);\n\u002B  scene_node_-\u003EsetOrientation(quaternion);\n\u002B  camera_info_ = msg;\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::update(float /*wall_dt*/, float /*ros_dt*/)\n\u002B{\n\u002B}\n\u002B\n\u002Bbool CameraInfoDisplay::isSameCameraInfo(\n\u002B  const sensor_msgs::msg::CameraInfo::ConstSharedPtr \u0026 msg)\n\u002B{\n\u002B  if (camera_info_) {\n\u002B    bool meta_same_p =\n\u002B      msg-\u003Eheader.frame_id == camera_info_-\u003Eheader.frame_id \u0026\u0026\n\u002B      msg-\u003Eheight == camera_info_-\u003Eheight \u0026\u0026\n\u002B      msg-\u003Ewidth == camera_info_-\u003Ewidth \u0026\u0026\n\u002B      msg-\u003Edistortion_model == camera_info_-\u003Edistortion_model \u0026\u0026\n\u002B      msg-\u003Eroi.x_offset == camera_info_-\u003Eroi.x_offset \u0026\u0026\n\u002B      msg-\u003Eroi.y_offset == camera_info_-\u003Eroi.y_offset \u0026\u0026\n\u002B      msg-\u003Eroi.height == camera_info_-\u003Eroi.height \u0026\u0026\n\u002B      msg-\u003Eroi.width == camera_info_-\u003Eroi.width;\n\u002B    if (meta_same_p) {\n\u002B      for (size_t i = 0; i \u003C msg-\u003Ep.size(); i\u002B\u002B) {\n\u002B        if (msg-\u003Ep[i] != camera_info_-\u003Ep[i]) {\n\u002B          return false;\n\u002B        }\n\u002B      }\n\u002B      return true;\n\u002B    } else {\n\u002B      return false;\n\u002B    }\n\u002B  } else {\n\u002B    return false;\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::addPointToEdge(\n\u002B  const Ogre::Vector3 \u0026 point)\n\u002B{\n\u002B  edges_-\u003EaddPoint(point);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::addPolygon(\n\u002B  const Ogre::Vector3 \u0026 O, const Ogre::Vector3 \u0026 A, const Ogre::Vector3 \u0026 B,\n\u002B  std::string name, bool use_color, bool upper_triangle)\n\u002B{\n\u002B  Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n\u002B  color.a = alpha_;\n\u002B  std::shared_ptr\u003Crviz_rendering::TrianglePolygon\u003E triangle =\n\u002B    std::make_shared\u003Crviz_rendering::TrianglePolygon\u003E(\n\u002B    scene_manager_,\n\u002B    scene_node_,\n\u002B    O, A, B, name,\n\u002B    color,\n\u002B    use_color,\n\u002B    upper_triangle);\n\u002B  polygons_.push_back(triangle);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::prepareMaterial()\n\u002B{\n\u002B  if (texture_ == nullptr) {\n\u002B    // material\n\u002B    static uint32_t count = 0;\n\u002B    rviz_common::UniformStringStream ss;\n\u002B    ss \u003C\u003C \u0022CameraInfoDisplayPolygon\u0022 \u003C\u003C count\u002B\u002B;\n\u002B    material_ =\n\u002B      Ogre::MaterialManager::getSingletonPtr()-\u003Ecreate(\n\u002B      ss.str(),\n\u002B      Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);\n\u002B    texture_ = Ogre::TextureManager::getSingletonPtr()-\u003EcreateManual(\n\u002B      material_-\u003EgetName() \u002B \u0022Texture\u0022,          // name\n\u002B      Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,\n\u002B      Ogre::TEX_TYPE_2D, 1, 1, 0, Ogre::PF_A8R8G8B8, Ogre::TU_DEFAULT);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetColourWriteEnabled(true);\n\u002B    Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n\u002B    color.a = alpha_;\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetAmbient(color);\n\u002B    material_-\u003EsetReceiveShadows(false);\n\u002B    material_-\u003EgetTechnique(0)-\u003EsetLightingEnabled(true);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetCullingMode(Ogre::CULL_NONE);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetLightingEnabled(false);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetDepthWriteEnabled(false);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetDepthCheckEnabled(true);\n\u002B\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetVertexColourTracking(Ogre::TVC_DIFFUSE);\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EcreateTextureUnitState(texture_-\u003EgetName());\n\u002B    material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);\n\u002B  }\n\u002B}\n\u002B\n\u002BOgre::Vector3 projectPixelTo3dRay(\n\u002B  double x, double y, double fx, double fy, double cx, double cy,\n\u002B  double Tx, double Ty)\n\u002B{\n\u002B  Ogre::Vector3 ray;\n\u002B  ray.x = (x - cx - Tx) / fx;\n\u002B  ray.y = (y - cy - Ty) / fy;\n\u002B  ray.z = 1.0;\n\u002B  return ray;\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::createCameraInfoShapes(\n\u002B  const sensor_msgs::msg::CameraInfo::ConstSharedPtr \u0026 msg)\n\u002B{\n\u002B  polygons_.clear();\n\u002B  if (edges_) {\n\u002B    edges_-\u003Eclear();\n\u002B  }\n\u002B  // fx and fy should not be equal 0.\n\u002B  if (msg-\u003Ep[0] == 0.0 || msg-\u003Ep[5] == 0.0) {\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusProperty::Error, \u0022Camera Info\u0022,\n\u002B      \u0022Invalid intrinsic matrix\u0022);\n\u002B    return;\n\u002B  }\n\u002B  setStatus(rviz_common::properties::StatusProperty::Ok, \u0022Camera Info\u0022, \u0022OK\u0022);\n\u002B\n\u002B  // initialize BillboardLine\n\u002B  if (!edges_) {\n\u002B    edges_.reset(\n\u002B      new rviz_rendering::BillboardLine(\n\u002B        context_-\u003EgetSceneManager(),\n\u002B        scene_node_));\n\u002B    edges_-\u003EsetLineWidth(0.01f);\n\u002B  }\n\u002B\n\u002B  int height = msg-\u003Eroi.height ? msg-\u003Eroi.height : msg-\u003Eheight;\n\u002B  int width = msg-\u003Eroi.width ? msg-\u003Eroi.width : msg-\u003Ewidth;\n\u002B  if (msg-\u003Ebinning_y \u003E 0) {\n\u002B    height /= msg-\u003Ebinning_y;\n\u002B  }\n\u002B  if (msg-\u003Ebinning_x \u003E 0) {\n\u002B    width /= msg-\u003Ebinning_x;\n\u002B  }\n\u002B\n\u002B  Ogre::Vector2 a(0, 0), b(width, 0),\n\u002B  c(width, height), d(0, height);\n\u002B  // all the z = 1.0\n\u002B  Ogre::Vector3 A = projectPixelTo3dRay(\n\u002B    a.x, a.y, msg-\u003Ep[0], msg-\u003Ep[5], msg-\u003Ep[2], msg-\u003Ep[6],\n\u002B    msg-\u003Ep[3], msg-\u003Ep[7]);\n\u002B  Ogre::Vector3 B = projectPixelTo3dRay(\n\u002B    b.x, b.y, msg-\u003Ep[0], msg-\u003Ep[5], msg-\u003Ep[2], msg-\u003Ep[6],\n\u002B    msg-\u003Ep[3], msg-\u003Ep[7]);\n\u002B  Ogre::Vector3 C = projectPixelTo3dRay(\n\u002B    c.x, c.y, msg-\u003Ep[0], msg-\u003Ep[5], msg-\u003Ep[2], msg-\u003Ep[6],\n\u002B    msg-\u003Ep[3], msg-\u003Ep[7]);\n\u002B  Ogre::Vector3 D = projectPixelTo3dRay(\n\u002B    d.x, d.y, msg-\u003Ep[0], msg-\u003Ep[5], msg-\u003Ep[2], msg-\u003Ep[6],\n\u002B    msg-\u003Ep[3], msg-\u003Ep[7]);\n\u002B\n\u002B  Ogre::Vector3 scaled_A = A * far_clip_distance_;\n\u002B  Ogre::Vector3 scaled_B = B * far_clip_distance_;\n\u002B  Ogre::Vector3 scaled_C = C * far_clip_distance_;\n\u002B  Ogre::Vector3 scaled_D = D * far_clip_distance_;\n\u002B\n\u002B  Ogre::Vector3 O(0, 0, 0);\n\u002B\n\u002B  // build polygons\n\u002B  if (show_polygons_) {\n\u002B    Ogre::ColourValue color = rviz_common::properties::qtToOgre(color_);\n\u002B    color.a = alpha_;\n\u002B    prepareMaterial();\n\u002B    if (!not_show_side_polygons_) {\n\u002B      material_-\u003EgetTechnique(0)-\u003EgetPass(0)-\u003EsetAmbient(color);\n\u002B      {\n\u002B        texture_-\u003EgetBuffer()-\u003Elock(Ogre::HardwareBuffer::HBL_NORMAL);\n\u002B        const Ogre::PixelBox \u0026 pixelBox =\n\u002B          texture_-\u003EgetBuffer()-\u003EgetCurrentLock();\n\u002B        Ogre::uint8 * pDest = static_cast\u003COgre::uint8 *\u003E(pixelBox.data);\n\u002B        memset(pDest, 0, 1);\n\u002B        QImage Hud(pDest, 1, 1, QImage::Format_ARGB32);\n\u002B        Hud.setPixel(0, 0, color_.rgba());\n\u002B        texture_-\u003EgetBuffer()-\u003Eunlock();\n\u002B      }\n\u002B      addPolygon(O, scaled_B, scaled_A, material_-\u003EgetName(), true, true);\n\u002B      addPolygon(O, scaled_C, scaled_B, material_-\u003EgetName(), true, true);\n\u002B      addPolygon(O, scaled_D, scaled_C, material_-\u003EgetName(), true, true);\n\u002B      addPolygon(O, scaled_A, scaled_D, material_-\u003EgetName(), true, true);\n\u002B    }\n\u002B  }\n\u002B  if (show_edges_) {\n\u002B    edges_-\u003Eclear();\n\u002B    edges_-\u003EsetMaxPointsPerLine(2);\n\u002B    edges_-\u003EsetNumLines(8);\n\u002B    edges_-\u003EsetColor(\n\u002B      edge_color_.red() / 255.0,\n\u002B      edge_color_.green() / 255.0,\n\u002B      edge_color_.blue() / 255.0,\n\u002B      alpha_);\n\u002B    addPointToEdge(O); addPointToEdge(scaled_A); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(O); addPointToEdge(scaled_B); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(O); addPointToEdge(scaled_C); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(O); addPointToEdge(scaled_D); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(scaled_A); addPointToEdge(scaled_B); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(scaled_B); addPointToEdge(scaled_C); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(scaled_C); addPointToEdge(scaled_D); edges_-\u003EfinishLine();\n\u002B    addPointToEdge(scaled_D); addPointToEdge(scaled_A);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateColor()\n\u002B{\n\u002B  color_ = color_property_-\u003EgetColor();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateEdgeColor()\n\u002B{\n\u002B  edge_color_ = edge_color_property_-\u003EgetColor();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateAlpha()\n\u002B{\n\u002B  alpha_ = alpha_property_-\u003EgetFloat();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateFarClipDistance()\n\u002B{\n\u002B  far_clip_distance_ = far_clip_distance_property_-\u003EgetFloat();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateShowPolygons()\n\u002B{\n\u002B  show_polygons_ = show_polygons_property_-\u003EgetBool();\n\u002B  if (show_polygons_) {\n\u002B    not_show_side_polygons_property_-\u003Eshow();\n\u002B  } else {\n\u002B    not_show_side_polygons_property_-\u003Ehide();\n\u002B  }\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateShowEdges()\n\u002B{\n\u002B  show_edges_ = show_edges_property_-\u003EgetBool();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplay::updateNotShowSidePolygons()\n\u002B{\n\u002B  not_show_side_polygons_ = not_show_side_polygons_property_-\u003EgetBool();\n\u002B  if (camera_info_) {\n\u002B    createCameraInfoShapes(camera_info_);\n\u002B  }\n\u002B}\n\u002B\n\u002B}  // namespace displays\n\u002B}  // namespace rviz_default_plugins\n\u002B\n\u002B#include \u003Cpluginlib/class_list_macros.hpp\u003E  // NOLINT\n\u002BPLUGINLIB_EXPORT_CLASS(rviz_default_plugins::displays::CameraInfoDisplay, rviz_common::Display)\ndiff --git rviz_default_plugins/test/reference_images/camera_info_displayed_ref.png rviz_default_plugins/test/reference_images/camera_info_displayed_ref.png\nnew file mode 100644\nindex 00000000..5fdb2aef\nBinary files /dev/null and rviz_default_plugins/test/reference_images/camera_info_displayed_ref.png differ\ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/camera_info/camera_info_display_visual_test.cpp rviz_default_plugins/test/rviz_default_plugins/displays/camera_info/camera_info_display_visual_test.cpp\nnew file mode 100644\nindex 00000000..572e4f93\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/camera_info/camera_info_display_visual_test.cpp\n@@ -0,0 \u002B1,58 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u0022rviz_visual_testing_framework/visual_test_fixture.hpp\u0022\n\u002B#include \u0022rviz_visual_testing_framework/visual_test_publisher.hpp\u0022\n\u002B\n\u002B#include \u0022../../publishers/camera_info_publisher.hpp\u0022\n\u002B#include \u0022../../page_objects/camera_info_display_page_object.hpp\u0022\n\u002B\n\u002BTEST_F(VisualTestFixture, camera_info_displayed) {\n\u002B  std::vector\u003CPublisherWithFrame\u003E publishers = {\n\u002B    PublisherWithFrame(std::make_shared\u003Cnodes::CameraInfoPublisher\u003E(\u0022map\u0022), \u0022image\u0022),\n\u002B  };\n\u002B  auto cam_publisher = std::make_unique\u003CVisualTestPublisher\u003E(publishers);\n\u002B\n\u002B  auto camera_info_display = addDisplay\u003CCameraInfoDisplayPageObject\u003E();\n\u002B  camera_info_display-\u003EsetTopic(\u0022/image/camera_info\u0022);\n\u002B  camera_info_display-\u003Ecollapse();\n\u002B\n\u002B  captureMainWindow();\n\u002B\n\u002B  camera_info_display-\u003EsetAlpha(0.0f);\n\u002B  captureMainWindow(\u0022empty_scene\u0022);\n\u002B\n\u002B  assertScreenShotsIdentity();\n\u002B}\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/accel_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/accel_display_page_object.cpp\nindex a5a6c2f4..d722d08f 100644\n--- rviz_default_plugins/test/rviz_default_plugins/page_objects/accel_display_page_object.cpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/accel_display_page_object.cpp\n@@ -1,5 \u002B1,5 @@\n /*\n- * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.cpp\nnew file mode 100644\nindex 00000000..d82b350d\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.cpp\n@@ -0,0 \u002B1,76 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u0022camera_info_display_page_object.hpp\u0022\n\u002B\n\u002BCameraInfoDisplayPageObject::CameraInfoDisplayPageObject()\n\u002B: BasePageObject(0, \u0022CameraInfo\u0022)\n\u002B{\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setTopic(QString topic)\n\u002B{\n\u002B  setComboBox(\u0022Topic\u0022, topic);\n\u002B  waitForFirstMessage();\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setFarClip(float far_clip)\n\u002B{\n\u002B  setFloat(\u0022Far clip\u0022, far_clip);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setShowEdged(bool show_edges)\n\u002B{\n\u002B  setBool(\u0022Show edges\u0022, show_edges);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setShowPolygon(bool show_polygon)\n\u002B{\n\u002B  setBool(\u0022Show polygons\u0022, show_polygon);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setNotShowSidePolygon(bool now_show_side_polygon)\n\u002B{\n\u002B  setBool(\u0022Not show side polygons\u0022, now_show_side_polygon);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setColor(int r, int g, int b)\n\u002B{\n\u002B  setColorCode(\u0022Color\u0022, r, g, b);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setEdgeColor(int r, int g, int b)\n\u002B{\n\u002B  setColorCode(\u0022Edge color\u0022, r, g, b);\n\u002B}\n\u002B\n\u002Bvoid CameraInfoDisplayPageObject::setAlpha(float alpha)\n\u002B{\n\u002B  setFloat(\u0022Alpha\u0022, alpha);\n\u002B}\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.hpp rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.hpp\nnew file mode 100644\nindex 00000000..fa795a6a\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/camera_info_display_page_object.hpp\n@@ -0,0 \u002B1,58 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B#ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_\n\u002B#define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_\n\u002B\n\u002B#include \u0022rviz_visual_testing_framework/page_objects/base_page_object.hpp\u0022\n\u002B\n\u002B#include \u003CQString\u003E  // NOLINT\n\u002B\n\u002Bclass CameraInfoDisplayPageObject : public BasePageObject\n\u002B{\n\u002Bpublic:\n\u002B  CameraInfoDisplayPageObject();\n\u002B\n\u002B  void setTopic(QString topic);\n\u002B  void setFarClip(float far_clip);\n\u002B  void setShowEdged(bool show_edges);\n\u002B  void setShowPolygon(bool show_polygon);\n\u002B  void setNotShowSidePolygon(bool now_show_side_polygon);\n\u002B  void setColor(int r, int g, int b);\n\u002B  void setEdgeColor(int r, int g, int b);\n\u002B\n\u002B  void setAlpha(float alpha);\n\u002B  void setAngularColor(int r, int g, int b);\n\u002B  void setLinearColor(int r, int g, int b);\n\u002B  void setAngularScale(float scale);\n\u002B  void setLinearScale(float scale);\n\u002B  void setWidth(float width);\n\u002B  void setHistoryLength(int history);\n\u002B};\n\u002B\n\u002B#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__CAMERA_INFO_DISPLAY_PAGE_OBJECT_HPP_\ndiff --git rviz_default_plugins/test/rviz_default_plugins/publishers/camera_info_publisher.hpp rviz_default_plugins/test/rviz_default_plugins/publishers/camera_info_publisher.hpp\nindex ecbec944..e33685fd 100644\n--- rviz_default_plugins/test/rviz_default_plugins/publishers/camera_info_publisher.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/publishers/camera_info_publisher.hpp\n@@ -30,6 \u002B30,8 @@\n #ifndef RVIZ_DEFAULT_PLUGINS__PUBLISHERS__CAMERA_INFO_PUBLISHER_HPP_\n #define RVIZ_DEFAULT_PLUGINS__PUBLISHERS__CAMERA_INFO_PUBLISHER_HPP_\n \n\u002B#include \u003Cstring\u003E\n\u002B\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp/clock.hpp\u0022\n #include \u0022sensor_msgs/msg/camera_info.hpp\u0022\n@@ -43,11 \u002B45,12 @@ namespace nodes\n class CameraInfoPublisher : public rclcpp::Node\n {\n public:\n-  CameraInfoPublisher()\n\u002B  explicit CameraInfoPublisher(std::string frame_id = \u0022camera_info_frame\u0022)\n   : Node(\u0022camera_info_publisher\u0022)\n   {\n     publisher = this-\u003Ecreate_publisher\u003Csensor_msgs::msg::CameraInfo\u003E(\u0022/image/camera_info\u0022, 10);\n     timer = this-\u003Ecreate_wall_timer(500ms, std::bind(\u0026CameraInfoPublisher::timer_callback, this));\n\u002B    this-\u003Eframe_id = frame_id;\n   }\n \n private:\n@@ -55,7 \u002B58,7 @@ private:\n   {\n     auto message = sensor_msgs::msg::CameraInfo();\n     message.header = std_msgs::msg::Header();\n-    message.header.frame_id = \u0022camera_info_frame\u0022;\n\u002B    message.header.frame_id = this-\u003Eframe_id;\n     message.header.stamp = rclcpp::Clock().now();\n \n     message.width = 320;\n@@ -68,6 \u002B71,7 @@ private:\n \n   rclcpp::TimerBase::SharedPtr timer;\n   rclcpp::Publisher\u003Csensor_msgs::msg::CameraInfo\u003E::SharedPtr publisher;\n\u002B  std::string frame_id;\n };\n \n }  // namespace nodes\ndiff --git rviz_rendering/CMakeLists.txt rviz_rendering/CMakeLists.txt\nindex ce0b8f9d..fee1258b 100644\n--- rviz_rendering/CMakeLists.txt\n\u002B\u002B\u002B rviz_rendering/CMakeLists.txt\n@@ -95,6 \u002B95,7 @@ add_library(rviz_rendering SHARED\n   src/rviz_rendering/objects/point_cloud_renderable.cpp\n   src/rviz_rendering/objects/screw_visual.cpp\n   src/rviz_rendering/objects/shape.cpp\n\u002B  src/rviz_rendering/objects/triangle_polygon.cpp\n   src/rviz_rendering/objects/wrench_visual.cpp\n )\n \n@@ -294,6 \u002B295,18 @@ if(BUILD_TESTING)\n     )\n   endif()\n \n\u002B  ament_add_gmock(triangle_polygon_visual_test_target\n\u002B    test/rviz_rendering/objects/triangle_polygon_test.cpp\n\u002B    ${SKIP_DISPLAY_TESTS})\n\u002B  if(TARGET triangle_polygon_visual_test_target)\n\u002B    target_link_libraries(triangle_polygon_visual_test_target\n\u002B      rviz_ogre_vendor::OgreMain\n\u002B      rviz_rendering\n\u002B      rviz_rendering_test_utils\n\u002B      Qt5::Widgets  # explicitly do this for include directories (not necessary for external use)\n\u002B    )\n\u002B  endif()\n\u002B\n   ament_add_gmock(wrench_visual_test_target\n     test/rviz_rendering/objects/wrench_visual_test.cpp\n     ${SKIP_DISPLAY_TESTS})\ndiff --git rviz_rendering/include/rviz_rendering/objects/triangle_polygon.hpp rviz_rendering/include/rviz_rendering/objects/triangle_polygon.hpp\nnew file mode 100644\nindex 00000000..da012394\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/include/rviz_rendering/objects/triangle_polygon.hpp\n@@ -0,0 \u002B1,72 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_\n\u002B#define RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u003COgreColourValue.h\u003E\n\u002B#include \u003COgreManualObject.h\u003E\n\u002B#include \u003COgreSceneNode.h\u003E\n\u002B#include \u003COgreSceneManager.h\u003E\n\u002B#include \u003COgreVector.h\u003E\n\u002B\n\u002B#include \u0022rviz_rendering/visibility_control.hpp\u0022\n\u002B\n\u002Bnamespace rviz_rendering\n\u002B{\n\u002Bclass TrianglePolygon\n\u002B{\n\u002Bpublic:\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  TrianglePolygon(\n\u002B    Ogre::SceneManager * manager,\n\u002B    Ogre::SceneNode * node,\n\u002B    const Ogre::Vector3 \u0026 O,\n\u002B    const Ogre::Vector3 \u0026 A,\n\u002B    const Ogre::Vector3 \u0026 B,\n\u002B    const std::string \u0026 name,\n\u002B    const Ogre::ColourValue \u0026 color,\n\u002B    bool use_color,\n\u002B    bool upper_triangle);\n\u002B  virtual ~TrianglePolygon();\n\u002B\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  Ogre::ManualObject * getManualObject();\n\u002B\n\u002Bprotected:\n\u002B  Ogre::ManualObject * manual_;\n\u002B  Ogre::SceneManager * manager_;\n\u002B};\n\u002B\n\u002B}  // namespace rviz_rendering\n\u002B#endif  // RVIZ_RENDERING__OBJECTS__TRIANGLE_POLYGON_HPP_\ndiff --git rviz_rendering/src/rviz_rendering/objects/triangle_polygon.cpp rviz_rendering/src/rviz_rendering/objects/triangle_polygon.cpp\nnew file mode 100644\nindex 00000000..3baeda19\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/objects/triangle_polygon.cpp\n@@ -0,0 \u002B1,102 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u0022rviz_rendering/objects/triangle_polygon.hpp\u0022\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u003COgreColourValue.h\u003E\n\u002B#include \u003COgreManualObject.h\u003E\n\u002B#include \u003COgreRenderOperation.h\u003E\n\u002B#include \u003COgreSceneNode.h\u003E\n\u002B#include \u003COgreSceneManager.h\u003E\n\u002B#include \u003COgreVector.h\u003E\n\u002B\n\u002Bnamespace rviz_rendering\n\u002B{\n\u002BTrianglePolygon::TrianglePolygon(\n\u002B  Ogre::SceneManager * manager,\n\u002B  Ogre::SceneNode * node,\n\u002B  const Ogre::Vector3 \u0026 O,\n\u002B  const Ogre::Vector3 \u0026 A,\n\u002B  const Ogre::Vector3 \u0026 B,\n\u002B  const std::string \u0026 name,\n\u002B  const Ogre::ColourValue \u0026 color,\n\u002B  bool use_color,\n\u002B  bool upper_triangle)\n\u002B{\n\u002B  // uniq string is requred for name\n\u002B  manual_ = manager-\u003EcreateManualObject();\n\u002B  manual_-\u003Eclear();\n\u002B  manual_-\u003Ebegin(\n\u002B    name,\n\u002B    Ogre::RenderOperation::OT_TRIANGLE_STRIP);\n\u002B  manual_-\u003Eposition(O.x, O.y, O.z);\n\u002B  if (upper_triangle) {\n\u002B    manual_-\u003EtextureCoord(0, 0);\n\u002B  } else {\n\u002B    manual_-\u003EtextureCoord(1, 0);\n\u002B  }\n\u002B  if (use_color) {\n\u002B    manual_-\u003Ecolour(color);\n\u002B  }\n\u002B  manual_-\u003Eposition(A.x, A.y, A.z);\n\u002B  if (upper_triangle) {\n\u002B    manual_-\u003EtextureCoord(1, 0);\n\u002B  } else {\n\u002B    manual_-\u003EtextureCoord(1, 1);\n\u002B  }\n\u002B  if (use_color) {\n\u002B    manual_-\u003Ecolour(color);\n\u002B  }\n\u002B  manual_-\u003Eposition(B.x, B.y, B.z);\n\u002B  if (upper_triangle) {\n\u002B    manual_-\u003EtextureCoord(0, 1);\n\u002B  } else {\n\u002B    manual_-\u003EtextureCoord(0, 1);\n\u002B  }\n\u002B  if (use_color) {\n\u002B    manual_-\u003Ecolour(color);\n\u002B  }\n\u002B  manual_-\u003Eend();\n\u002B  node-\u003EattachObject(manual_);\n\u002B}\n\u002B\n\u002BTrianglePolygon::~TrianglePolygon()\n\u002B{\n\u002B  manual_-\u003EdetachFromParent();\n\u002B}\n\u002B\n\u002BOgre::ManualObject * TrianglePolygon::getManualObject()\n\u002B{\n\u002B  return manual_;\n\u002B}\n\u002B}  // namespace rviz_rendering\ndiff --git rviz_rendering/test/rviz_rendering/objects/triangle_polygon_test.cpp rviz_rendering/test/rviz_rendering/objects/triangle_polygon_test.cpp\nnew file mode 100644\nindex 00000000..0a6b207f\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/test/rviz_rendering/objects/triangle_polygon_test.cpp\n@@ -0,0 \u002B1,78 @@\n\u002B/*\n\u002B * Copyright (c) 2024, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted (subject to the limitations in the disclaimer\n\u002B * below) provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY\u0027S PATENT RIGHTS ARE GRANTED BY THIS\n\u002B * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\u002B * \u0022AS IS\u0022 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n\u002B * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E  // NOLINT\n\u002B#include \u003Cgmock/gmock.h\u003E  // NOLINT\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u003COgre.h\u003E\n\u002B\n\u002B#include \u0022rviz_rendering/objects/triangle_polygon.hpp\u0022\n\u002B#include \u0022../ogre_testing_environment.hpp\u0022\n\u002B\n\u002B#include \u0022../matcher.hpp\u0022\n\u002B\n\u002Bclass TrianglePolygonTestFixture : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  void SetUp()\n\u002B  {\n\u002B    testing_environment_ = std::make_shared\u003Crviz_rendering::OgreTestingEnvironment\u003E();\n\u002B    testing_environment_-\u003EsetUpOgreTestEnvironment();\n\u002B  }\n\u002B\n\u002B  std::shared_ptr\u003Crviz_rendering::OgreTestingEnvironment\u003E testing_environment_;\n\u002B};\n\u002B\n\u002BTEST_F(TrianglePolygonTestFixture, setPoints_sets_the_line_position_and_size) {\n\u002B  auto scene_manager = Ogre::Root::getSingletonPtr()-\u003EcreateSceneManager();\n\u002B  auto root_node = scene_manager-\u003EgetRootSceneNode();\n\u002B\n\u002B  auto O = Ogre::Vector3(0, 0, 0);\n\u002B  auto A = Ogre::Vector3(0, 1, 0);\n\u002B  auto B = Ogre::Vector3(1, 0.5, 0);\n\u002B  auto color = Ogre::ColourValue(255, 0, 0, 1.0);\n\u002B  auto triangle_polygon = new rviz_rendering::TrianglePolygon(\n\u002B    scene_manager, root_node, O, A, B, \u0022test_triangle\u0022,\n\u002B    color, false, false);\n\u002B\n\u002B  auto manual_object = triangle_polygon-\u003EgetManualObject();\n\u002B\n\u002B\n\u002B  // auto triangle_node = dynamic_cast\u003COgre::SceneNode *\u003E(root_node-\u003EgetChild(0));\n\u002B  auto aabb = manual_object-\u003EgetBoundingBox();\n\u002B\n\u002B  ASSERT_THAT(aabb.getMinimum(), Vector3Eq(Ogre::Vector3(0, 0, 0)));\n\u002B  ASSERT_THAT(aabb.getMaximum(), Vector3Eq(Ogre::Vector3(1, 1, 0)));\n\u002B  delete triangle_polygon;\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "14c53e117b252d068daa15110fa7abf452d7c588",
    "RawMessage": "Increase test coverage of rclcpp_lifecycle to 96% (#1298)",
    "Changes": "diff --git rclcpp_lifecycle/CMakeLists.txt rclcpp_lifecycle/CMakeLists.txt\nindex 953cd0d4..91b300fc 100644\n--- rclcpp_lifecycle/CMakeLists.txt\n\u002B\u002B\u002B rclcpp_lifecycle/CMakeLists.txt\n@@ -56,16 \u002B56,27 @@ if(BUILD_TESTING)\n     ament_target_dependencies(test_lifecycle_node\n       \u0022rcl_lifecycle\u0022\n       \u0022rclcpp\u0022\n\u002B      \u0022rcutils\u0022\n     )\n-    target_link_libraries(test_lifecycle_node ${PROJECT_NAME})\n\u002B    target_link_libraries(test_lifecycle_node ${PROJECT_NAME} mimick)\n\u002B  endif()\n\u002B  ament_add_gtest(test_lifecycle_publisher test/test_lifecycle_publisher.cpp)\n\u002B  if(TARGET test_lifecycle_publisher)\n\u002B    ament_target_dependencies(test_lifecycle_publisher\n\u002B      \u0022rcl_lifecycle\u0022\n\u002B      \u0022rclcpp\u0022\n\u002B      \u0022test_msgs\u0022\n\u002B    )\n\u002B    target_link_libraries(test_lifecycle_publisher ${PROJECT_NAME})\n   endif()\n   ament_add_gtest(test_lifecycle_service_client test/test_lifecycle_service_client.cpp)\n   if(TARGET test_lifecycle_service_client)\n     ament_target_dependencies(test_lifecycle_service_client\n       \u0022rcl_lifecycle\u0022\n       \u0022rclcpp\u0022\n\u002B      \u0022rcutils\u0022\n     )\n-    target_link_libraries(test_lifecycle_service_client ${PROJECT_NAME})\n\u002B    target_link_libraries(test_lifecycle_service_client ${PROJECT_NAME} mimick)\n   endif()\n   ament_add_gtest(test_state_machine_info test/test_state_machine_info.cpp)\n   if(TARGET test_state_machine_info)\n@@ -104,8 \u002B115,12 @@ if(BUILD_TESTING)\n     ament_target_dependencies(test_transition_wrapper\n       \u0022rcl_lifecycle\u0022\n       \u0022rclcpp\u0022\n\u002B      \u0022rcutils\u0022\n\u002B    )\n\u002B    target_link_libraries(test_transition_wrapper ${PROJECT_NAME} mimick)\n\u002B    target_compile_definitions(test_transition_wrapper\n\u002B      PUBLIC RCUTILS_ENABLE_FAULT_INJECTION\n     )\n-    target_link_libraries(test_transition_wrapper ${PROJECT_NAME})\n   endif()\n endif()\n \ndiff --git rclcpp_lifecycle/package.xml rclcpp_lifecycle/package.xml\nindex 83f9a1e5..2139bdcf 100644\n--- rclcpp_lifecycle/package.xml\n\u002B\u002B\u002B rclcpp_lifecycle/package.xml\n@@ -24,6 \u002B24,9 @@\n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Emimick_vendor\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Ercutils\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Etest_msgs\u003C/test_depend\u003E\n \n   \u003Cexport\u003E\n     \u003Cbuild_type\u003Eament_cmake\u003C/build_type\u003E\ndiff --git rclcpp_lifecycle/test/mocking_utils/patch.hpp rclcpp_lifecycle/test/mocking_utils/patch.hpp\nnew file mode 100644\nindex 00000000..7551bebf\n--- /dev/null\n\u002B\u002B\u002B rclcpp_lifecycle/test/mocking_utils/patch.hpp\n@@ -0,0 \u002B1,527 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B// Original file taken from:\n\u002B// https://github.com/ros2/rcutils/blob/master/test/mocking_utils/patch.hpp\n\u002B\n\u002B#ifndef MOCKING_UTILS__PATCH_HPP_\n\u002B#define MOCKING_UTILS__PATCH_HPP_\n\u002B\n\u002B#define MOCKING_UTILS_SUPPORT_VA_LIST\n\u002B#if (defined(__aarch64__) || defined(__arm__) || defined(_M_ARM) || defined(__thumb__))\n\u002B// In ARM machines, va_list does not define comparison operators\n\u002B// nor the compiler allows defining them via operator overloads.\n\u002B// Thus, Mimick argument matching code will not compile.\n\u002B#undef MOCKING_UTILS_SUPPORT_VA_LIST\n\u002B#endif\n\u002B\n\u002B#ifdef MOCKING_UTILS_SUPPORT_VA_LIST\n\u002B#include \u003Ccstdarg\u003E\n\u002B#endif\n\u002B\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Ctype_traits\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022mimick/mimick.h\u0022\n\u002B\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B#include \u0022rcutils/macros.h\u0022\n\u002B\n\u002Bnamespace mocking_utils\n\u002B{\n\u002B\n\u002B/// Mimick specific traits for each mocking_utils::Patch instance.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam SignatureT Type of the symbol to be patched.\n\u002B*/\n\u002Btemplate\u003Csize_t ID, typename SignatureT\u003E\n\u002Bstruct PatchTraits;\n\u002B\n\u002B/// Traits specialization for ReturnT(void) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(void)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(void) free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B */\n\u002Btemplate\u003Csize_t ID\u003E\n\u002Bstruct PatchTraits\u003CID, void(void)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgT0 Argument type.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT, typename ArgT0\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT, ArgT0);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0) free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgT0 Argument type.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ArgT0\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void, ArgT0);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0, ArgT1) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0, ArgT1)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1) free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ArgT0, typename ArgT1\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0, ArgT1)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void, ArgT0, ArgT1);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1, typename ArgT2\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0, ArgT1, ArgT2)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1, ArgT2) free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ArgT0, typename ArgT1, typename ArgT2\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0, ArgT1, ArgT2)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3) free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0, ArgT1, ArgT2, ArgT3)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\n\u002B/// free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3, typename ArgT4\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\n\u002B/// free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3, typename ArgT4\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4)\u003E\n\u002B{\n\u002B  mmk_mock_define(mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4);\n\u002B};\n\u002B\n\u002B/// Traits specialization for ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\n\u002B/// free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3,\n\u002B  typename ArgT4, typename ArgT5\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\u003E\n\u002B{\n\u002B  mmk_mock_define(\n\u002B    mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7)\n\u002B/// free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3,\n\u002B  typename ArgT4, typename ArgT5,\n\u002B  typename ArgT6, typename ArgT7,\n\u002B  typename ArgT8, typename ArgT9\u003E\n\u002Bstruct PatchTraits\u003CID, ReturnT(\n\u002B    ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7, ArgT8, ArgT9)\u003E\n\u002B{\n\u002B  mmk_mock_define(\n\u002B    mock_type, ReturnT, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5, ArgT6, ArgT7, ArgT8, ArgT9);\n\u002B};\n\u002B\n\u002B/// Traits specialization for void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\n\u002B/// free functions.\n\u002B/**\n\u002B * Necessary for Mimick macros to adjust accordingly when the return\n\u002B * type is \u0060void\u0060.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of the patch. Ought to be unique.\n\u002B * \\tparam ArgTx Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID,\n\u002B  typename ArgT0, typename ArgT1,\n\u002B  typename ArgT2, typename ArgT3,\n\u002B  typename ArgT4, typename ArgT5\u003E\n\u002Bstruct PatchTraits\u003CID, void(ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5)\u003E\n\u002B{\n\u002B  mmk_mock_define(\n\u002B    mock_type, void, ArgT0, ArgT1, ArgT2, ArgT3, ArgT4, ArgT5);\n\u002B};\n\u002B\n\u002B/// Generic trampoline to wrap generalized callables in plain functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier of this trampoline. Ought to be unique.\n\u002B * \\tparam SignatureT Type of the symbol this trampoline replaces.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename SignatureT\u003E\n\u002Bstruct Trampoline;\n\u002B\n\u002B/// Trampoline specialization for free functions.\n\u002Btemplate\u003Csize_t ID, typename ReturnT, typename ... ArgTs\u003E\n\u002Bstruct Trampoline\u003CID, ReturnT(ArgTs...)\u003E\n\u002B{\n\u002B  static ReturnT base(ArgTs... args)\n\u002B  {\n\u002B    return target(std::forward\u003CArgTs\u003E(args)...);\n\u002B  }\n\u002B\n\u002B  static std::function\u003CReturnT(ArgTs...)\u003E target;\n\u002B};\n\u002B\n\u002Btemplate\u003Csize_t ID, typename ReturnT, typename ... ArgTs\u003E\n\u002Bstd::function\u003CReturnT(ArgTs...)\u003E\n\u002BTrampoline\u003CID, ReturnT(ArgTs...)\u003E::target;\n\u002B\n\u002B/// Setup trampoline with the given @p target.\n\u002B/**\n\u002B * \\param[in] target Callable that this trampoline will target.\n\u002B * \\return the plain base function of this trampoline.\n\u002B *\n\u002B * \\tparam ID Numerical identifier of this trampoline. Ought to be unique.\n\u002B * \\tparam SignatureT Type of the symbol this trampoline replaces.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename SignatureT\u003E\n\u002Bauto prepare_trampoline(std::function\u003CSignatureT\u003E target)\n\u002B{\n\u002B  Trampoline\u003CID, SignatureT\u003E::target = target;\n\u002B  return Trampoline\u003CID, SignatureT\u003E::base;\n\u002B}\n\u002B\n\u002B/// Patch class for binary API mocking\n\u002B/**\n\u002B * Built on top of Mimick, to enable symbol mocking on a per dynamically\n\u002B * linked binary object basis.\n\u002B *\n\u002B * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n\u002B * \\tparam SignatureT Type of the symbol to be patched.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename SignatureT\u003E\n\u002Bclass Patch;\n\u002B\n\u002B/// Patch specialization for ReturnT(ArgTs...) free functions.\n\u002B/**\n\u002B * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n\u002B * \\tparam ReturnT Return value type.\n\u002B * \\tparam ArgTs Argument types.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename ReturnT, typename ... ArgTs\u003E\n\u002Bclass Patch\u003CID, ReturnT(ArgTs...)\u003E\n\u002B{\n\u002Bpublic:\n\u002B  using mock_type = typename PatchTraits\u003CID, ReturnT(ArgTs...)\u003E::mock_type;\n\u002B\n\u002B  /// Construct a patch.\n\u002B  /**\n\u002B   * \\param[in] target Symbol target string, using Mimick syntax\n\u002B   *   i.e. \u0022symbol(@scope)?\u0022, where scope may be \u0022self\u0022 to target the current\n\u002B   *   binary, \u0022lib:library_name\u0022 to target a given library, \u0022file:path/to/library\u0022\n\u002B   *   to target a given file, or \u0022sym:other_symbol\u0022 to target the first library\n\u002B   *   that defines said symbol.\n\u002B   * \\param[in] proxy An indirection to call the target function.\n\u002B   *   This indirection must ensure this call goes through the function\u0027s\n\u002B   *   trampoline, as setup by the dynamic linker.\n\u002B   * \\return a mocking_utils::Patch instance.\n\u002B   */\n\u002B  explicit Patch(const std::string \u0026 target, std::function\u003CReturnT(ArgTs...)\u003E proxy)\n\u002B  : target_(target), proxy_(proxy)\n\u002B  {\n\u002B  }\n\u002B\n\u002B  // Copy construction and assignment are disabled.\n\u002B  Patch(const Patch \u0026) = delete;\n\u002B  Patch \u0026 operator=(const Patch \u0026) = delete;\n\u002B\n\u002B  Patch(Patch \u0026\u0026 other)\n\u002B  {\n\u002B    mock_ = other.mock_;\n\u002B    other.mock_ = nullptr;\n\u002B  }\n\u002B\n\u002B  Patch \u0026 operator=(Patch \u0026\u0026 other)\n\u002B  {\n\u002B    if (mock_) {\n\u002B      mmk_reset(mock_);\n\u002B    }\n\u002B    mock_ = other.mock_;\n\u002B    other.mock_ = nullptr;\n\u002B  }\n\u002B\n\u002B  ~Patch()\n\u002B  {\n\u002B    if (mock_) {\n\u002B      mmk_reset(mock_);\n\u002B    }\n\u002B  }\n\u002B\n\u002B  /// Inject a @p replacement for the patched function.\n\u002B  Patch \u0026 then_call(std::function\u003CReturnT(ArgTs...)\u003E replacement) \u0026\n\u002B  {\n\u002B    replace_with(replacement);\n\u002B    return *this;\n\u002B  }\n\u002B\n\u002B  /// Inject a @p replacement for the patched function.\n\u002B  Patch \u0026\u0026 then_call(std::function\u003CReturnT(ArgTs...)\u003E replacement) \u0026\u0026\n\u002B  {\n\u002B    replace_with(replacement);\n\u002B    return std::move(*this);\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  // Helper for template parameter pack expansion using \u0060mmk_any\u0060\n\u002B  // macro as pattern.\n\u002B  template\u003Ctypename T\u003E\n\u002B  T any() {return mmk_any(T);}\n\u002B\n\u002B  void replace_with(std::function\u003CReturnT(ArgTs...)\u003E replacement)\n\u002B  {\n\u002B    if (mock_) {\n\u002B      throw std::logic_error(\u0022Cannot configure patch more than once\u0022);\n\u002B    }\n\u002B    auto type_erased_trampoline =\n\u002B      reinterpret_cast\u003Cmmk_fn\u003E(prepare_trampoline\u003CID\u003E(replacement));\n\u002B    auto MMK_MANGLE(mock_type, create) =\n\u002B      PatchTraits\u003CID, ReturnT(ArgTs...)\u003E::MMK_MANGLE(mock_type, create);\n\u002B    mock_ = mmk_mock(target_.c_str(), mock_type);\n\u002B    mmk_when(proxy_(any\u003CArgTs\u003E()...), .then_call = type_erased_trampoline);\n\u002B  }\n\u002B\n\u002B  mock_type mock_{nullptr};\n\u002B  std::string target_;\n\u002B  std::function\u003CReturnT(ArgTs...)\u003E proxy_;\n\u002B};\n\u002B\n\u002B/// Make a patch for a \u0060target\u0060 function.\n\u002B/**\n\u002B * Useful for type deduction during \\ref mocking_utils::Patch construction.\n\u002B *\n\u002B * \\param[in] target Symbol target string, using Mimick syntax.\n\u002B * \\param[in] proxy An indirection to call the target function.\n\u002B * \\return a mocking_utils::Patch instance.\n\u002B *\n\u002B * \\tparam ID Numerical identifier for this patch. Ought to be unique.\n\u002B * \\tparam SignatureT Type of the function to be patched.\n\u002B *\n\u002B * \\sa mocking_utils::Patch for further reference.\n\u002B */\n\u002Btemplate\u003Csize_t ID, typename SignatureT\u003E\n\u002Bauto make_patch(const std::string \u0026 target, std::function\u003CSignatureT\u003E proxy)\n\u002B{\n\u002B  return Patch\u003CID, SignatureT\u003E(target, proxy);\n\u002B}\n\u002B\n\u002B/// Define a dummy operator \u0060op\u0060 for a given \u0060type\u0060.\n\u002B/**\n\u002B * Useful to enable patching functions that take arguments whose types\n\u002B * do not define basic comparison operators, as required by Mimick.\n\u002B*/\n\u002B#define MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(type_, op) \\\n\u002B  template\u003Ctypename T\u003E \\\n\u002B  typename std::enable_if\u003Cstd::is_same\u003CT, type_\u003E::value, bool\u003E::type \\\n\u002B  operator op(const T \u0026, const T \u0026) { \\\n\u002B    return false; \\\n\u002B  }\n\u002B\n\u002B/// Get the exact \\ref mocking_utils::Patch type for a given \u0060id\u0060 and \u0060function\u0060.\n\u002B/**\n\u002B * Useful to avoid ignored attribute warnings when using the \\b decltype operator.\n\u002B */\n\u002B#define MOCKING_UTILS_PATCH_TYPE(id, function) \\\n\u002B  decltype(mocking_utils::make_patch\u003Cid, decltype(function)\u003E(\u0022\u0022, nullptr))\n\u002B\n\u002B/// A transparent forwarding proxy to a given \u0060function\u0060.\n\u002B/**\n\u002B * Useful to ensure a call to \u0060function\u0060 goes through its trampoline.\n\u002B */\n\u002B#define MOCKING_UTILS_PATCH_PROXY(function) \\\n\u002B  [] (auto \u0026\u0026 ... args)-\u003Edecltype(auto) { \\\n\u002B    return function(std::forward\u003Cdecltype(args)\u003E(args)...); \\\n\u002B  }\n\u002B\n\u002B/// Compute a Mimick symbol target string based on which \u0060function\u0060 is to be patched\n\u002B/// in which \u0060scope\u0060.\n\u002B#define MOCKING_UTILS_PATCH_TARGET(scope, function) \\\n\u002B  (std::string(RCUTILS_STRINGIFY(function)) \u002B \u0022@\u0022 \u002B (scope))\n\u002B\n\u002B/// Prepare a mocking_utils::Patch for patching a \u0060function\u0060 in a given \u0060scope\u0060\n\u002B/// but defer applying any changes.\n\u002B#define prepare_patch(scope, function) \\\n\u002B  make_patch\u003C__COUNTER__, decltype(function)\u003E( \\\n\u002B    MOCKING_UTILS_PATCH_TARGET(scope, function), MOCKING_UTILS_PATCH_PROXY(function) \\\n\u002B  )\n\u002B\n\u002B/// Patch a \u0060function\u0060 with a used-provided \u0060replacement\u0060 in a given \u0060scope\u0060.\n\u002B#define patch(scope, function, replacement) \\\n\u002B  prepare_patch(scope, function).then_call(replacement)\n\u002B\n\u002B/// Patch a \u0060function\u0060 to always yield a given \u0060return_code\u0060 in a given \u0060scope\u0060.\n\u002B#define patch_and_return(scope, function, return_code) \\\n\u002B  patch(scope, function, [\u0026](auto \u0026\u0026 ...) {return return_code;})\n\u002B\n\u002B/// Patch a \u0060function\u0060 to always yield a given \u0060return_code\u0060 in a given \u0060scope\u0060.\n\u002B#define patch_to_fail(scope, function, error_message, return_code) \\\n\u002B  patch( \\\n\u002B    scope, function, [\u0026](auto \u0026\u0026 ...) { \\\n\u002B      RCUTILS_SET_ERROR_MSG(error_message); \\\n\u002B      return return_code; \\\n\u002B    })\n\u002B\n\u002B/// Patch a \u0060function\u0060 to execute normally but always yield a given \u0060return_code\u0060\n\u002B/// in a given \u0060scope\u0060.\n\u002B/**\n\u002B * \\warning On some Linux distributions (e.g. CentOS), pointers to function\n\u002B *   reference their PLT trampolines. In such cases, it is not possible to\n\u002B *   call \u0060function\u0060 from within the mock.\n\u002B */\n\u002B#define inject_on_return(scope, function, return_code) \\\n\u002B  patch( \\\n\u002B    scope, function, ([\u0026, base = function](auto \u0026\u0026 ... __args) { \\\n\u002B      if (base != function) { \\\n\u002B        static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      } else { \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n\u002B          \u0022[WARNING] mocking_utils::inject_on_return() cannot forward call to \u0022 \\\n\u002B          \u0022original \u0027\u0022 RCUTILS_STRINGIFY(function) \u0022\u0027 function before injection\\n\u0022 \\\n\u002B          \u0022    at \u0022 __FILE__ \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022\\n\u0022); \\\n\u002B      } \\\n\u002B      return return_code; \\\n\u002B    }))\n\u002B\n\u002B}  // namespace mocking_utils\n\u002B\n\u002B#ifdef MOCKING_UTILS_SUPPORT_VA_LIST\n\u002B// Define dummy comparison operators for C standard va_list type\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, ==)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, !=)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, \u003C)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(va_list, \u003E)\n\u002B#endif\n\u002B\n\u002B#endif  // MOCKING_UTILS__PATCH_HPP_\ndiff --git rclcpp_lifecycle/test/test_lifecycle_node.cpp rclcpp_lifecycle/test/test_lifecycle_node.cpp\nindex 93e42493..34674dd4 100644\n--- rclcpp_lifecycle/test/test_lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_node.cpp\n@@ -24,9 \u002B24,13 @@\n #include \u0022lifecycle_msgs/msg/state.hpp\u0022\n #include \u0022lifecycle_msgs/msg/transition.hpp\u0022\n \n\u002B#include \u0022rcl_lifecycle/rcl_lifecycle.h\u0022\n\u002B\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp_lifecycle/lifecycle_node.hpp\u0022\n \n\u002B#include \u0022./mocking_utils/patch.hpp\u0022\n\u002B\n using lifecycle_msgs::msg::State;\n using lifecycle_msgs::msg::Transition;\n \n@@ -37,13 \u002B41,17 @@ protected:\n   {\n     rclcpp::init(0, nullptr);\n   }\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n };\n \n class EmptyLifecycleNode : public rclcpp_lifecycle::LifecycleNode\n {\n public:\n-  explicit EmptyLifecycleNode(std::string node_name)\n-  : rclcpp_lifecycle::LifecycleNode(std::move(node_name))\n\u002B  explicit EmptyLifecycleNode(const std::string \u0026 node_name)\n\u002B  : rclcpp_lifecycle::LifecycleNode(node_name)\n   {}\n };\n \n@@ -142,6 \u002B150,22 @@ TEST_F(TestDefaultStateMachine, empty_initializer) {\n   EXPECT_EQ(State::PRIMARY_STATE_UNCONFIGURED, test_node-\u003Eget_current_state().id());\n }\n \n\u002BTEST_F(TestDefaultStateMachine, empty_initializer_rcl_errors) {\n\u002B  {\n\u002B    auto patch = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_state_machine_init, RCL_RET_ERROR);\n\u002B    EXPECT_THROW(\n\u002B      std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022).reset(),\n\u002B      std::runtime_error);\n\u002B  }\n\u002B  {\n\u002B    auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n\u002B    auto patch = mocking_utils::inject_on_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_state_machine_fini, RCL_RET_ERROR);\n\u002B    EXPECT_NO_THROW(test_node.reset());\n\u002B  }\n\u002B}\n\u002B\n TEST_F(TestDefaultStateMachine, trigger_transition) {\n   auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n \n@@ -163,6 \u002B187,35 @@ TEST_F(TestDefaultStateMachine, trigger_transition) {\n       rclcpp_lifecycle::Transition(Transition::TRANSITION_UNCONFIGURED_SHUTDOWN)).id());\n }\n \n\u002BTEST_F(TestDefaultStateMachine, trigger_transition_rcl_errors) {\n\u002B  auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_state_machine_is_initialized, RCL_RET_ERROR);\n\u002B    EXPECT_EQ(\n\u002B      State::PRIMARY_STATE_UNCONFIGURED,\n\u002B      test_node-\u003Etrigger_transition(\n\u002B        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n\u002B  }\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_trigger_transition_by_id, RCL_RET_ERROR);\n\u002B    EXPECT_EQ(\n\u002B      State::PRIMARY_STATE_UNCONFIGURED,\n\u002B      test_node-\u003Etrigger_transition(\n\u002B        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n\u002B  }\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_trigger_transition_by_label, RCL_RET_ERROR);\n\u002B    EXPECT_EQ(\n\u002B      State::TRANSITION_STATE_CONFIGURING,\n\u002B      test_node-\u003Etrigger_transition(\n\u002B        rclcpp_lifecycle::Transition(Transition::TRANSITION_CONFIGURE)).id());\n\u002B  }\n\u002B}\n\u002B\n TEST_F(TestDefaultStateMachine, trigger_transition_with_error_code) {\n   auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n   auto success = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n@@ -381,6 \u002B434,8 @@ TEST_F(TestDefaultStateMachine, check_parameters) {\n   auto descriptors = test_node-\u003Edescribe_parameters(parameter_names);\n   EXPECT_EQ(descriptors.size(), parameter_names.size());\n \n\u002B  // This actually throws inside NodeParameters::describe_parameters(), so it\u0027s not currently\n\u002B  // possible to cover this method 100%.\n   EXPECT_THROW(\n     test_node-\u003Edescribe_parameter(\u0022not_a_real_parameter\u0022),\n     rclcpp::exceptions::ParameterNotDeclaredException);\n@@ -437,6 \u002B492,12 @@ TEST_F(TestDefaultStateMachine, check_parameters) {\n   test_node-\u003Eset_parameters({int_parameter});\n   EXPECT_EQ(parameters_set, 2u);\n \n\u002B  test_node-\u003Eremove_on_set_parameters_callback(callback_handle.get());\n\u002B  rclcpp::Parameter bool_parameter2(bool_name, rclcpp::ParameterValue(true));\n\u002B  EXPECT_TRUE(test_node-\u003Eset_parameter(bool_parameter2).successful);\n\u002B  EXPECT_EQ(parameters_set, 2u);\n\u002B\n\u002B\n   // List parameters\n   list_result = test_node-\u003Elist_parameters({}, 0u);\n   EXPECT_EQ(list_result.names.size(), 3u);\n@@ -489,7 \u002B550,7 @@ TEST_F(TestDefaultStateMachine, test_getters) {\n   EXPECT_NE(nullptr, const_cast\u003Cconst EmptyLifecycleNode *\u003E(test_node.get())-\u003Eget_clock());\n }\n \n-TEST_F(TestDefaultStateMachine, test_graph) {\n\u002BTEST_F(TestDefaultStateMachine, test_graph_topics) {\n   auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n   auto names = test_node-\u003Eget_node_names();\n \n@@ -504,6 \u002B565,19 @@ TEST_F(TestDefaultStateMachine, test_graph) {\n     topic_names_and_types[\u0022/testnode/transition_event\u0022][0].c_str(),\n     \u0022lifecycle_msgs/msg/TransitionEvent\u0022);\n \n\u002B  EXPECT_EQ(1u, test_node-\u003Ecount_publishers(\u0022/testnode/transition_event\u0022));\n\u002B  EXPECT_EQ(0u, test_node-\u003Ecount_subscribers(\u0022/testnode/transition_event\u0022));\n\u002B\n\u002B  auto publishers_info = test_node-\u003Eget_publishers_info_by_topic(\u0022/testnode/transition_event\u0022);\n\u002B  EXPECT_EQ(1u, publishers_info.size());\n\u002B  auto subscriptions_info =\n\u002B    test_node-\u003Eget_subscriptions_info_by_topic(\u0022/testnode/transition_event\u0022);\n\u002B  EXPECT_EQ(0u, subscriptions_info.size());\n\u002B}\n\u002B\n\u002BTEST_F(TestDefaultStateMachine, test_graph_services) {\n\u002B  auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n\u002B\n   auto service_names_and_types = test_node-\u003Eget_service_names_and_types();\n   // These are specific to lifecycle nodes, other services are provided by rclcpp::Node\n   ASSERT_NE(\n@@ -540,15 \u002B614,48 @@ TEST_F(TestDefaultStateMachine, test_graph) {\n   EXPECT_STREQ(\n     service_names_and_types[\u0022/testnode/get_transition_graph\u0022][0].c_str(),\n     \u0022lifecycle_msgs/srv/GetAvailableTransitions\u0022);\n\u002B}\n \n-  EXPECT_EQ(1u, test_node-\u003Ecount_publishers(\u0022/testnode/transition_event\u0022));\n-  EXPECT_EQ(0u, test_node-\u003Ecount_subscribers(\u0022/testnode/transition_event\u0022));\n\u002BTEST_F(TestDefaultStateMachine, test_graph_services_by_node) {\n\u002B  auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n \n-  auto publishers_info = test_node-\u003Eget_publishers_info_by_topic(\u0022/testnode/transition_event\u0022);\n-  EXPECT_EQ(publishers_info.size(), 1u);\n-  auto subscriptions_info =\n-    test_node-\u003Eget_subscriptions_info_by_topic(\u0022/testnode/transition_event\u0022);\n-  EXPECT_EQ(subscriptions_info.size(), 0u);\n\u002B  auto service_names_and_types_by_node =\n\u002B    test_node-\u003Eget_service_names_and_types_by_node(\u0022testnode\u0022, \u0022\u0022);\n\u002B  // These are specific to lifecycle nodes, other services are provided by rclcpp::Node\n\u002B  ASSERT_NE(\n\u002B    service_names_and_types_by_node.end(),\n\u002B    service_names_and_types_by_node.find(std::string(\u0022/testnode/change_state\u0022)));\n\u002B  EXPECT_STREQ(\n\u002B    service_names_and_types_by_node[\u0022/testnode/change_state\u0022][0].c_str(),\n\u002B    \u0022lifecycle_msgs/srv/ChangeState\u0022);\n\u002B\n\u002B  ASSERT_NE(\n\u002B    service_names_and_types_by_node.end(),\n\u002B    service_names_and_types_by_node.find(std::string(\u0022/testnode/get_available_states\u0022)));\n\u002B  EXPECT_STREQ(\n\u002B    service_names_and_types_by_node[\u0022/testnode/get_available_states\u0022][0].c_str(),\n\u002B    \u0022lifecycle_msgs/srv/GetAvailableStates\u0022);\n\u002B\n\u002B  ASSERT_NE(\n\u002B    service_names_and_types_by_node.end(),\n\u002B    service_names_and_types_by_node.find(std::string(\u0022/testnode/get_available_transitions\u0022)));\n\u002B  EXPECT_STREQ(\n\u002B    service_names_and_types_by_node[\u0022/testnode/get_available_transitions\u0022][0].c_str(),\n\u002B    \u0022lifecycle_msgs/srv/GetAvailableTransitions\u0022);\n\u002B\n\u002B  ASSERT_NE(\n\u002B    service_names_and_types_by_node.end(),\n\u002B    service_names_and_types_by_node.find(std::string(\u0022/testnode/get_state\u0022)));\n\u002B  EXPECT_STREQ(\n\u002B    service_names_and_types_by_node[\u0022/testnode/get_state\u0022][0].c_str(),\n\u002B    \u0022lifecycle_msgs/srv/GetState\u0022);\n\u002B\n\u002B  ASSERT_NE(\n\u002B    service_names_and_types_by_node.end(),\n\u002B    service_names_and_types_by_node.find(std::string(\u0022/testnode/get_transition_graph\u0022)));\n\u002B  EXPECT_STREQ(\n\u002B    service_names_and_types_by_node[\u0022/testnode/get_transition_graph\u0022][0].c_str(),\n\u002B    \u0022lifecycle_msgs/srv/GetAvailableTransitions\u0022);\n }\n \n TEST_F(TestDefaultStateMachine, test_callback_groups) {\n@@ -564,3 \u002B671,16 @@ TEST_F(TestDefaultStateMachine, test_callback_groups) {\n   EXPECT_EQ(groups.size(), 2u);\n   EXPECT_EQ(groups[1].lock().get(), group.get());\n }\n\u002B\n\u002BTEST_F(TestDefaultStateMachine, wait_for_graph_change)\n\u002B{\n\u002B  auto test_node = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022testnode\u0022);\n\u002B  EXPECT_THROW(\n\u002B    test_node-\u003Ewait_for_graph_change(nullptr, std::chrono::milliseconds(1)),\n\u002B    rclcpp::exceptions::InvalidEventError);\n\u002B\n\u002B  auto event = std::make_shared\u003Crclcpp::Event\u003E();\n\u002B  EXPECT_THROW(\n\u002B    test_node-\u003Ewait_for_graph_change(event, std::chrono::milliseconds(0)),\n\u002B    rclcpp::exceptions::EventNotRegisteredError);\n\u002B}\ndiff --git rclcpp_lifecycle/test/test_lifecycle_publisher.cpp rclcpp_lifecycle/test/test_lifecycle_publisher.cpp\nnew file mode 100644\nindex 00000000..555354a8\n--- /dev/null\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_publisher.cpp\n@@ -0,0 \u002B1,104 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B\n\u002B#include \u0022rclcpp_lifecycle/lifecycle_node.hpp\u0022\n\u002B#include \u0022rclcpp_lifecycle/lifecycle_publisher.hpp\u0022\n\u002B\n\u002Bclass TestDefaultStateMachine : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002Bclass EmptyLifecycleNode : public rclcpp_lifecycle::LifecycleNode\n\u002B{\n\u002Bpublic:\n\u002B  explicit EmptyLifecycleNode(const std::string \u0026 node_name)\n\u002B  : rclcpp_lifecycle::LifecycleNode(node_name)\n\u002B  {\n\u002B    rclcpp::PublisherOptionsWithAllocator\u003Cstd::allocator\u003Cvoid\u003E\u003E options;\n\u002B    publisher_ =\n\u002B      std::make_shared\u003Crclcpp_lifecycle::LifecyclePublisher\u003Ctest_msgs::msg::Empty\u003E\u003E(\n\u002B      get_node_base_interface().get(), std::string(\u0022topic\u0022), rclcpp::QoS(10), options);\n\u002B    add_publisher_handle(publisher_);\n\u002B\n\u002B    // For coverage this is being added here\n\u002B    auto timer = create_wall_timer(std::chrono::seconds(1), []() {});\n\u002B    add_timer_handle(timer);\n\u002B  }\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp_lifecycle::LifecyclePublisher\u003Ctest_msgs::msg::Empty\u003E\u003E publisher()\n\u002B  {\n\u002B    return publisher_;\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003Crclcpp_lifecycle::LifecyclePublisher\u003Ctest_msgs::msg::Empty\u003E\u003E publisher_;\n\u002B};\n\u002B\n\u002Bclass TestLifecyclePublisher : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B    node_ = std::make_shared\u003CEmptyLifecycleNode\u003E(\u0022node\u0022);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002Bprotected:\n\u002B  std::shared_ptr\u003CEmptyLifecycleNode\u003E node_;\n\u002B};\n\u002B\n\u002BTEST_F(TestLifecyclePublisher, publish) {\n\u002B  node_-\u003Epublisher()-\u003Eon_deactivate();\n\u002B  EXPECT_FALSE(node_-\u003Epublisher()-\u003Eis_activated());\n\u002B  {\n\u002B    auto msg_ptr = std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n\u002B    EXPECT_NO_THROW(node_-\u003Epublisher()-\u003Epublish(*msg_ptr));\n\u002B  }\n\u002B  {\n\u002B    auto msg_ptr = std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n\u002B    EXPECT_NO_THROW(node_-\u003Epublisher()-\u003Epublish(std::move(msg_ptr)));\n\u002B  }\n\u002B  node_-\u003Epublisher()-\u003Eon_activate();\n\u002B  EXPECT_TRUE(node_-\u003Epublisher()-\u003Eis_activated());\n\u002B  {\n\u002B    auto msg_ptr = std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n\u002B    EXPECT_NO_THROW(node_-\u003Epublisher()-\u003Epublish(*msg_ptr));\n\u002B  }\n\u002B  {\n\u002B    auto msg_ptr = std::make_unique\u003Ctest_msgs::msg::Empty\u003E();\n\u002B    EXPECT_NO_THROW(node_-\u003Epublisher()-\u003Epublish(std::move(msg_ptr)));\n\u002B  }\n\u002B}\ndiff --git rclcpp_lifecycle/test/test_lifecycle_service_client.cpp rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\nindex 2c7d099f..c0c83325 100644\n--- rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\n@@ -37,6 \u002B37,8 @@\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp_lifecycle/lifecycle_node.hpp\u0022\n \n\u002B#include \u0022./mocking_utils/patch.hpp\u0022\n\u002B\n using namespace std::chrono_literals;\n \n constexpr char const * lifecycle_node_name = \u0022lc_talker\u0022;\n@@ -404,3 \u002B406,56 @@ TEST_F(TestLifecycleServiceClient, wait_for_graph_change)\n     node_graph-\u003Ewait_for_graph_change(event, std::chrono::milliseconds(0)),\n     rclcpp::exceptions::EventNotRegisteredError);\n }\n\u002B\n\u002Bclass TestLifecycleServiceClientRCLErrors : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  void SetUp() override\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown() override\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestLifecycleServiceClientRCLErrors, call_services_rcl_errors) {\n\u002B  auto lifecycle_node = std::make_shared\u003CEmptyLifecycleNode\u003E();\n\u002B  auto lifecycle_client = std::make_shared\u003CLifecycleServiceClient\u003E(\u0022client_with_errors\u0022);\n\u002B\n\u002B  auto mock = mocking_utils::patch_and_return(\n\u002B    \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_state_machine_is_initialized, RCL_RET_ERROR);\n\u002B\n\u002B  // on_change_state\n\u002B  lifecycle_client-\u003Echange_state(\n\u002B    lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE);\n\u002B  rclcpp::spin_some(lifecycle_client);\n\u002B  EXPECT_THROW(\n\u002B    rclcpp::spin_some(lifecycle_node-\u003Eget_node_base_interface()), std::runtime_error);\n\u002B\n\u002B  // on_get_state\n\u002B  lifecycle_client-\u003Eget_state();\n\u002B  rclcpp::spin_some(lifecycle_client);\n\u002B  EXPECT_THROW(\n\u002B    rclcpp::spin_some(lifecycle_node-\u003Eget_node_base_interface()), std::runtime_error);\n\u002B\n\u002B  // on_get_avilable_states\n\u002B  lifecycle_client-\u003Eget_available_states();\n\u002B  rclcpp::spin_some(lifecycle_client);\n\u002B  EXPECT_THROW(\n\u002B    rclcpp::spin_some(lifecycle_node-\u003Eget_node_base_interface()), std::runtime_error);\n\u002B\n\u002B  // on_get_available_transitions\n\u002B  lifecycle_client-\u003Eget_available_transitions();\n\u002B  rclcpp::spin_some(lifecycle_client);\n\u002B  EXPECT_THROW(\n\u002B    rclcpp::spin_some(lifecycle_node-\u003Eget_node_base_interface()), std::runtime_error);\n\u002B\n\u002B  // on_get_transition_graph\n\u002B  lifecycle_client-\u003Eget_transition_graph();\n\u002B  rclcpp::spin_some(lifecycle_client);\n\u002B  EXPECT_THROW(\n\u002B    rclcpp::spin_some(lifecycle_node-\u003Eget_node_base_interface()), std::runtime_error);\n\u002B}\ndiff --git rclcpp_lifecycle/test/test_transition_wrapper.cpp rclcpp_lifecycle/test/test_transition_wrapper.cpp\nindex 9895dc91..4f72d90b 100644\n--- rclcpp_lifecycle/test/test_transition_wrapper.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_transition_wrapper.cpp\n@@ -18,8 \u002B18,12 @@\n #include \u003Cutility\u003E\n #include \u003Cvector\u003E\n \n\u002B#include \u0022rcutils/testing/fault_injection.h\u0022\n\u002B\n #include \u0022rclcpp_lifecycle/lifecycle_node.hpp\u0022\n \n\u002B#include \u0022./mocking_utils/patch.hpp\u0022\n\u002B\n class TestTransitionWrapper : public ::testing::Test\n {\n protected:\n@@ -31,8 \u002B35,11 @@ protected:\n class TransitionDerived : public rclcpp_lifecycle::Transition\n {\n public:\n\u002B  TransitionDerived(const uint8_t id, const std::string \u0026 label)\n\u002B  : Transition(id, label) {}\n\u002B\n   TransitionDerived(\n-    uint8_t id, const std::string \u0026 label,\n\u002B    const uint8_t id, const std::string \u0026 label,\n     rclcpp_lifecycle::State \u0026\u0026 start, rclcpp_lifecycle::State \u0026\u0026 goal)\n   : Transition(id, label, std::move(start), std::move(goal)) {}\n   void expose_reset()\n@@ -125,4 \u002B132,80 @@ TEST_F(TestTransitionWrapper, exceptions) {\n   EXPECT_THROW(a-\u003Egoal_state(), std::runtime_error);\n   EXPECT_THROW(a-\u003Eid(), std::runtime_error);\n   EXPECT_THROW(a-\u003Elabel(), std::runtime_error);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_transition_init, RCL_RET_ERROR);\n\u002B\n\u002B    EXPECT_THROW(\n\u002B      std::make_shared\u003CTransitionDerived\u003E(1, \u0022one\u0022).reset(),\n\u002B      std::runtime_error);\n\u002B\n\u002B    rclcpp_lifecycle::State state1(1, \u0022start_state\u0022);\n\u002B    rclcpp_lifecycle::State state2(2, \u0022goal_state\u0022);\n\u002B    EXPECT_THROW(\n\u002B      std::make_shared\u003CTransitionDerived\u003E(\n\u002B        2, \u0022two\u0022, std::move(start_state), std::move(goal_state)).reset(),\n\u002B      std::runtime_error);\n\u002B  }\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp_lifecycle\u0022, rcl_lifecycle_transition_fini, RCL_RET_ERROR);\n\u002B    auto transition1 = std::make_shared\u003CTransitionDerived\u003E(1, \u0022one\u0022);\n\u002B    EXPECT_NO_THROW(transition1-\u003Eexpose_reset());\n\u002B\n\u002B    rclcpp_lifecycle::State state1(1, \u0022start_state\u0022);\n\u002B    rclcpp_lifecycle::State state2(2, \u0022goal_state\u0022);\n\u002B    auto transition2 =\n\u002B      std::make_shared\u003CTransitionDerived\u003E(2, \u0022two\u0022, std::move(start_state), std::move(goal_state));\n\u002B    EXPECT_NO_THROW(transition2-\u003Eexpose_reset());\n\u002B  }\n\u002B\n\u002B  RCUTILS_FAULT_INJECTION_TEST(\n\u002B  {\n\u002B    std::shared_ptr\u003CTransitionDerived\u003E transition = nullptr;\n\u002B    try {\n\u002B      transition = std::make_shared\u003CTransitionDerived\u003E(1, \u0022one\u0022);\n\u002B    } catch (...) {\n\u002B    }\n\u002B    if (nullptr != transition) {\n\u002B      EXPECT_NO_THROW(transition-\u003Eexpose_reset());\n\u002B    }\n\u002B  });\n\u002B\n\u002B  RCUTILS_FAULT_INJECTION_TEST(\n\u002B  {\n\u002B    std::shared_ptr\u003CTransitionDerived\u003E transition = nullptr;\n\u002B    try {\n\u002B      {\n\u002B        // These will fail due to failed allocations\n\u002B        rclcpp_lifecycle::State state1(1, \u0022start_state\u0022);\n\u002B        rclcpp_lifecycle::State state2(2, \u0022goal_state\u0022);\n\u002B\n\u002B        // Failed allocations and failed rcl init functions\n\u002B        transition = std::make_shared\u003CTransitionDerived\u003E(\n\u002B          2, \u0022two\u0022, std::move(state1), std::move(state2));\n\u002B      }\n\u002B    } catch (...) {\n\u002B    }\n\u002B\n\u002B    if (nullptr != transition) {\n\u002B      EXPECT_NO_THROW(transition-\u003Eexpose_reset());\n\u002B    }\n\u002B  });\n\u002B\n\u002B  RCUTILS_FAULT_INJECTION_TEST(\n\u002B  {\n\u002B    try {\n\u002B      // These will fail due to failed allocations\n\u002B      rclcpp_lifecycle::State state1(1, \u0022start_state\u0022);\n\u002B      rclcpp_lifecycle::State state2(2, \u0022goal_state\u0022);\n\u002B\n\u002B      // Failed allocations and failed rcl init functions\n\u002B      auto a = std::make_shared\u003CTransitionDerived\u003E(2, \u0022two\u0022, std::move(state1), std::move(state2));\n\u002B      auto b = std::make_shared\u003CTransitionDerived\u003E(3, \u0022three\u0022);\n\u002B      *b = *a;\n\u002B    } catch (...) {\n\u002B    }\n\u002B  });\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "7c95abbfc4559b293ebf5e94e20250bdd99d3ac6",
    "RawMessage": "Mitigate discovery race condition between clients and services (#132)",
    "Changes": "diff --git rmw_connextdds_common/include/rmw_connextdds/dds_api.hpp rmw_connextdds_common/include/rmw_connextdds/dds_api.hpp\nindex 55a3a0b..f09caf3 100644\n--- rmw_connextdds_common/include/rmw_connextdds/dds_api.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/dds_api.hpp\n@@ -33,6 \u002B33,10 @@\n #include \u0022rmw/rmw.h\u0022\n #include \u0022rosidl_typesupport_cpp/message_type_support.hpp\u0022\n \n\u002B#ifndef DDS_GUID_INITIALIZER\n\u002B#define DDS_GUID_INITIALIZER        DDS_GUID_DEFAULT\n\u002B#endif /* DDS_GUID_INITIALIZER */\n\u002B\n class RMW_Connext_MessageTypeSupport;\n class RMW_Connext_Publisher;\n class RMW_Connext_Subscriber;\n@@ -292,4 \u002B296,9 @@ rmw_connextdds_get_cft_filter_expression(\n   rcutils_allocator_t * const allocator,\n   rmw_subscription_content_filter_options_t * const options);\n \n\u002Brmw_ret_t\n\u002Brmw_connextdds_guid_to_instance_handle(\n\u002B  const struct DDS_GUID_t * const guid,\n\u002B  DDS_InstanceHandle_t * const instanceHandle);\n\u002B\n #endif  // RMW_CONNEXTDDS__DDS_API_HPP_\ndiff --git rmw_connextdds_common/include/rmw_connextdds/resource_limits.hpp rmw_connextdds_common/include/rmw_connextdds/resource_limits.hpp\nindex f091e2b..f7bd4ae 100644\n--- rmw_connextdds_common/include/rmw_connextdds/resource_limits.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/resource_limits.hpp\n@@ -55,4 \u002B55,13 @@\n #define RMW_CONNEXT_LIMIT_KEEP_ALL_SAMPLES              1000\n #endif /* RMW_CONNEXT_LIMIT_SAMPLES_MAX */\n \n\u002B#ifndef RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT\n\u002B#define RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT     100000 /* 100ms */\n\u002B#endif /* RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT */\n\u002B\n\u002B#ifndef RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE\n\u002B#define RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE    (31536000ull * 1000000ull) /* 1 year */\n\u002B#endif /* RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE */\n\u002B\n\u002B\n #endif  // RMW_CONNEXTDDS__RESOURCE_LIMITS_HPP_\ndiff --git rmw_connextdds_common/include/rmw_connextdds/rmw_impl.hpp rmw_connextdds_common/include/rmw_connextdds/rmw_impl.hpp\nindex 56fffda..943d5f8 100644\n--- rmw_connextdds_common/include/rmw_connextdds/rmw_impl.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/rmw_impl.hpp\n@@ -21,6 \u002B21,7 @@\n #include \u003Cmutex\u003E\n #include \u003Ccondition_variable\u003E\n #include \u003Catomic\u003E\n\u002B#include \u003Cchrono\u003E\n \n #include \u0022rmw_connextdds/context.hpp\u0022\n #include \u0022rmw_connextdds/type_support.hpp\u0022\n@@ -70,6 \u002B71,28 @@ bool rmw_connextdds_find_string_in_list(\n DDS_Duration_t rmw_connextdds_duration_from_ros_time(\n   const rmw_time_t * const ros_time);\n \n\u002Bclass RMW_Connext_OrderedGid\n\u002B{\n\u002Bpublic:\n\u002B  explicit RMW_Connext_OrderedGid(const rmw_gid_t \u0026 value)\n\u002B  : value(value)\n\u002B  {\n\u002B  }\n\u002B\n\u002B  bool operator\u003C(const RMW_Connext_OrderedGid \u0026 other) const\n\u002B  {\n\u002B    return memcmp(value.data, other.value.data, RMW_GID_STORAGE_SIZE) \u003C 0;\n\u002B  }\n\u002B\n\u002B  bool operator==(const RMW_Connext_OrderedGid \u0026 other) const\n\u002B  {\n\u002B    return memcmp(value.data, other.value.data, RMW_GID_STORAGE_SIZE) == 0;\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  rmw_gid_t value;\n\u002B};\n\u002B\n /******************************************************************************\n  * WaitSet wrapper\n  ******************************************************************************/\n@@ -157,7 \u002B180,7 @@ public:\n     RMW_Connext_WriteParams * const params);\n \n   rmw_ret_t\n-  enable() const\n\u002B  enable()\n   {\n     if (DDS_RETCODE_OK !=\n       DDS_Entity_enable(\n@@ -183,6 \u002B206,8 @@ public:\n       return RMW_RET_ERROR;\n     }\n \n\u002B    max_blocking_time = load_max_blocking_time();\n\u002B\n     return RMW_RET_OK;\n   }\n \n@@ -215,6 \u002B240,12 @@ public:\n     DDS_SampleIdentity_t * const sample_identity,\n     DDS_SampleIdentity_t * const related_sample_identity);\n \n\u002B  rmw_ret_t\n\u002B  wait_for_subscription(\n\u002B    rmw_gid_t \u0026 reader_gid,\n\u002B    bool \u0026 unmatched,\n\u002B    rmw_gid_t \u0026 related_writer_gid);\n\u002B\n   DDS_Topic * dds_topic() const\n   {\n     return DDS_DataWriter_get_topic(this-\u003Edds_writer);\n@@ -232,19 \u002B263,82 @@ public:\n     return DDS_Publisher_get_participant(pub);\n   }\n \n\u002B  void\n\u002B  push_related_endpoints(const rmw_gid_t \u0026 endpoint, const rmw_gid_t \u0026 related)\n\u002B  {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E lock(matched_mutex);\n\u002B    known_endpoints.emplace(RMW_Connext_OrderedGid(endpoint), related);\n\u002B    known_endpoints.emplace(RMW_Connext_OrderedGid(related), endpoint);\n\u002B  }\n\u002B\n\u002B  void\n\u002B  on_publication_matched(\n\u002B    const DDS_PublicationMatchedStatus * const status)\n\u002B  {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E lock(matched_mutex);\n\u002B    DDS_ReturnCode_t dds_rc =\n\u002B      DDS_DataWriter_get_matched_subscriptions(writer(), \u0026matched_subscriptions);\n\u002B    if (DDS_RETCODE_OK != dds_rc) {\n\u002B      RMW_CONNEXT_LOG_ERROR_A_SET(\u0022failed to list matched subscriptions: dds_rc=%d\u0022, dds_rc)\n\u002B    }\n\u002B    if (status-\u003Ecurrent_count_change \u003C 0) {\n\u002B      rmw_gid_t unmatched_gid;\n\u002B      rmw_connextdds_ih_to_gid(status-\u003Elast_subscription_handle, unmatched_gid);\n\u002B      pop_related_endpoints(unmatched_gid);\n\u002B    }\n\u002B    matched_cv.notify_all();\n\u002B  }\n\u002B\n\u002B  void\n\u002B  on_related_subscription_matched(\n\u002B    RMW_Connext_Subscriber * const sub,\n\u002B    const DDS_SubscriptionMatchedStatus * const status)\n\u002B  {\n\u002B    UNUSED_ARG(sub);\n\u002B    std::lock_guard\u003Cstd::mutex\u003E lock(matched_mutex);\n\u002B    if (status-\u003Ecurrent_count_change \u003C 0) {\n\u002B      rmw_gid_t unmatched_gid;\n\u002B      rmw_connextdds_ih_to_gid(status-\u003Elast_publication_handle, unmatched_gid);\n\u002B      pop_related_endpoints(unmatched_gid);\n\u002B    }\n\u002B    matched_cv.notify_all();\n\u002B  }\n\u002B\n\u002B  rmw_context_impl_t * const ctx;\n\u002B\n\u002B  ~RMW_Connext_Publisher();\n\u002B\n private:\n-  rmw_context_impl_t * ctx;\n   DDS_DataWriter * dds_writer;\n   RMW_Connext_MessageTypeSupport * type_support;\n   const bool created_topic;\n   rmw_gid_t ros_gid;\n   RMW_Connext_PublisherStatusCondition status_condition;\n\u002B  std::mutex matched_mutex;\n\u002B  std::condition_variable matched_cv;\n\u002B  std::chrono::microseconds max_blocking_time;\n\u002B  std::map\u003CRMW_Connext_OrderedGid, rmw_gid_t\u003E known_endpoints;\n\u002B  DDS_InstanceHandleSeq matched_subscriptions;\n \n   RMW_Connext_Publisher(\n     rmw_context_impl_t * const ctx,\n     DDS_DataWriter * const dds_writer,\n     RMW_Connext_MessageTypeSupport * const type_support,\n     const bool created_topic);\n\u002B\n\u002B  void\n\u002B  pop_related_endpoints(const rmw_gid_t \u0026 endpoint)\n\u002B  {\n\u002B    auto endpoint_entry = known_endpoints.find(RMW_Connext_OrderedGid(endpoint));\n\u002B    if (endpoint_entry == known_endpoints.end()) {\n\u002B      return;\n\u002B    }\n\u002B    known_endpoints.erase(RMW_Connext_OrderedGid(endpoint));\n\u002B    known_endpoints.erase(RMW_Connext_OrderedGid(endpoint_entry-\u003Esecond));\n\u002B  }\n\u002B\n\u002B  std::chrono::microseconds\n\u002B  load_max_blocking_time() const;\n };\n \n rmw_publisher_t *\n@@ -286,7 \u002B380,8 @@ public:\n     const bool intro_members_cpp = false,\n     std::string * const type_name = nullptr,\n     const char * const cft_name = nullptr,\n-    const char * const cft_filter = nullptr);\n\u002B    const char * const cft_filter = nullptr,\n\u002B    RMW_Connext_Publisher * const related_pub = nullptr);\n \n   rmw_ret_t\n   finalize();\n@@ -521,7 \u002B616,7 @@ public:\n   const bool ignore_local;\n \n private:\n-  rmw_context_impl_t * ctx;\n\u002B  rmw_context_impl_t * const ctx;\n   DDS_DataReader * dds_reader;\n   DDS_Topic * dds_topic;\n   DDS_TopicDescription * dds_topic_cft;\n@@ -535,6 \u002B630,7 @@ private:\n   size_t loan_len;\n   size_t loan_next;\n   std::mutex loan_mutex;\n\u002B  RMW_Connext_Publisher * const related_pub;\n \n   RMW_Connext_Subscriber(\n     rmw_context_impl_t * const ctx,\n@@ -545,7 \u002B641,8 @@ private:\n     const bool created_topic,\n     DDS_TopicDescription * const dds_topic_cft,\n     const char * const cft_expression,\n-    const bool internal);\n\u002B    const bool internal,\n\u002B    RMW_Connext_Publisher * const related_pub);\n \n   friend class RMW_Connext_SubscriberStatusCondition;\n };\ndiff --git rmw_connextdds_common/include/rmw_connextdds/rmw_waitset_std.hpp rmw_connextdds_common/include/rmw_connextdds/rmw_waitset_std.hpp\nindex 45bcedf..878b269 100644\n--- rmw_connextdds_common/include/rmw_connextdds/rmw_waitset_std.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/rmw_waitset_std.hpp\n@@ -680,7 \u002B680,9 @@ public:\n     DDS_DataReader * reader);\n \n   rmw_ret_t\n-  install(RMW_Connext_Subscriber * const sub);\n\u002B  install(\n\u002B    RMW_Connext_Subscriber * const sub,\n\u002B    RMW_Connext_Publisher * const related_pub = nullptr);\n \n   void\n   on_requested_deadline_missed(\n@@ -909,7 \u002B911,8 @@ protected:\n   DDS_SampleLostStatus status_sample_lost_last;\n   DDS_SubscriptionMatchedStatus status_matched_last;\n \n-  RMW_Connext_Subscriber * sub;\n\u002B  RMW_Connext_Subscriber * sub{nullptr};\n\u002B  RMW_Connext_Publisher * related_pub{nullptr};\n \n   std::mutex new_data_event_mutex_;\n   rmw_event_callback_t new_data_event_cb_{nullptr};\ndiff --git rmw_connextdds_common/include/rmw_connextdds/type_support.hpp rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\nindex 98c3bad..09b8ae5 100644\n--- rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/type_support.hpp\n@@ -45,6 \u002B45,7 @@ struct RMW_Connext_RequestReplyMessage\n {\n   bool request;\n   rmw_gid_t gid;\n\u002B  rmw_gid_t writer_gid;\n   int64_t sn;\n   void * payload;\n };\ndiff --git rmw_connextdds_common/src/common/rmw_impl.cpp rmw_connextdds_common/src/common/rmw_impl.cpp\nindex 3deb1f1..a6c82e6 100644\n--- rmw_connextdds_common/src/common/rmw_impl.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_impl.cpp\n@@ -658,7 \u002B658,8 @@ RMW_Connext_Publisher::RMW_Connext_Publisher(\n   dds_writer(dds_writer),\n   type_support(type_support),\n   created_topic(created_topic),\n-  status_condition(dds_writer)\n\u002B  status_condition(dds_writer),\n\u002B  matched_subscriptions(DDS_SEQUENCE_INITIALIZER)\n {\n   rmw_connextdds_get_entity_gid(this-\u003Edds_writer, this-\u003Eros_gid);\n   if (RMW_RET_OK != this-\u003Estatus_condition.install(this)) {\n@@ -667,6 \u002B668,11 @@ RMW_Connext_Publisher::RMW_Connext_Publisher(\n   }\n }\n \n\u002BRMW_Connext_Publisher::~RMW_Connext_Publisher()\n\u002B{\n\u002B  DDS_InstanceHandleSeq_finalize(\u0026matched_subscriptions);\n\u002B}\n\u002B\n RMW_Connext_Publisher *\n RMW_Connext_Publisher::create(\n   rmw_context_impl_t * const ctx,\n@@ -884,10 \u002B890,6 @@ RMW_Connext_Publisher::finalize()\n   return RMW_RET_OK;\n }\n \n-#ifndef DDS_GUID_INITIALIZER\n-#define DDS_GUID_INITIALIZER        DDS_GUID_DEFAULT\n-#endif /* DDS_GUID_INITIALIZER */\n-\n rmw_ret_t\n RMW_Connext_Publisher::requestreply_header_to_dds(\n   const RMW_Connext_RequestReplyMessage * const rr_msg,\n@@ -1020,6 \u002B1022,97 @@ RMW_Connext_Publisher::qos(rmw_qos_profile_t * const qos)\n   return rc;\n }\n \n\u002Bstd::chrono::microseconds\n\u002BRMW_Connext_Publisher::load_max_blocking_time() const\n\u002B{\n\u002B#if !RMW_CONNEXT_DDS_API_PRO_LEGACY\n\u002B  DDS_DataWriterQos dw_qos = DDS_DataWriterQos_INITIALIZER;\n\u002B#else\n\u002B  DDS_DataWriterQos dw_qos;\n\u002B  if (DDS_RETCODE_OK != DDS_DataWriterQos_initialize(\u0026dw_qos)) {\n\u002B    RMW_CONNEXT_LOG_ERROR_SET(\u0022failed to initialize datawriter qos\u0022)\n\u002B    return std::chrono::microseconds(0);\n\u002B  }\n\u002B#endif /* !RMW_CONNEXT_DDS_API_PRO_LEGACY */\n\u002B\n\u002B  auto scope_exit_dw_qos_delete =\n\u002B    rcpputils::make_scope_exit(\n\u002B    [\u0026dw_qos]()\n\u002B    {\n\u002B      if (DDS_RETCODE_OK != DDS_DataWriterQos_finalize(\u0026dw_qos)) {\n\u002B        RMW_CONNEXT_LOG_ERROR_SET(\u0022failed to finalize DataWriterQoS\u0022)\n\u002B      }\n\u002B    });\n\u002B\n\u002B  if (DDS_DataWriter_get_qos(writer(), \u0026dw_qos)) {\n\u002B    RMW_CONNEXT_LOG_ERROR_SET(\u0022failed to get datawriter qos\u0022)\n\u002B    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT);\n\u002B  }\n\u002B  if (DDS_Duration_is_auto(\u0026dw_qos.reliability.max_blocking_time)) {\n\u002B    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_DEFAULT);\n\u002B  }\n\u002B  if (DDS_Duration_is_infinite(\u0026dw_qos.reliability.max_blocking_time) ||\n\u002B    DDS_Duration_is_auto(\u0026dw_qos.reliability.max_blocking_time))\n\u002B  {\n\u002B    return std::chrono::microseconds(RMW_CONNEXT_LIMIT_DEFAULT_BLOCKING_TIME_INFINITE);\n\u002B  }\n\u002B  if (DDS_Duration_is_zero(\u0026dw_qos.reliability.max_blocking_time)) {\n\u002B    return std::chrono::microseconds(0);\n\u002B  }\n\u002B  std::chrono::microseconds max_blocking_time =\n\u002B    std::chrono::duration_cast\u003Cstd::chrono::milliseconds\u003E(\n\u002B    std::chrono::seconds(dw_qos.reliability.max_blocking_time.sec) \u002B\n\u002B    std::chrono::nanoseconds(dw_qos.reliability.max_blocking_time.nanosec));\n\u002B\n\u002B  return max_blocking_time;\n\u002B}\n\u002B\n\u002Brmw_ret_t\n\u002BRMW_Connext_Publisher::wait_for_subscription(\n\u002B  rmw_gid_t \u0026 reader_gid,\n\u002B  bool \u0026 unmatched,\n\u002B  rmw_gid_t \u0026 related_writer_gid)\n\u002B{\n\u002B  unmatched = false;\n\u002B\n\u002B  struct DDS_GUID_t reader_guid = DDS_GUID_INITIALIZER;\n\u002B  rmw_ret_t rc = RMW_RET_ERROR;\n\u002B  rc = rmw_connextdds_gid_to_guid(reader_gid, reader_guid);\n\u002B  if (RMW_RET_OK != rc) {\n\u002B    return rc;\n\u002B  }\n\u002B\n\u002B  std::unique_lock\u003Cstd::mutex\u003E lock(matched_mutex);\n\u002B  auto endpoint_entry = known_endpoints.find(RMW_Connext_OrderedGid(reader_gid));\n\u002B  if (endpoint_entry == known_endpoints.end()) {\n\u002B    unmatched = true;\n\u002B    return RMW_RET_OK;\n\u002B  }\n\u002B  related_writer_gid = endpoint_entry-\u003Esecond;\n\u002B\n\u002B  DDS_InstanceHandle_t reader_ih = DDS_HANDLE_NIL;\n\u002B  rc = rmw_connextdds_guid_to_instance_handle(\u0026reader_guid, \u0026reader_ih);\n\u002B  if (RMW_RET_OK != rc) {\n\u002B    return rc;\n\u002B  }\n\u002B  auto done_waiting = [this, \u0026reader_ih]() {\n\u002B      bool matched = false;\n\u002B      const DDS_Long subs_len = DDS_InstanceHandleSeq_get_length(\u0026matched_subscriptions);\n\u002B      for (DDS_Long i = 0; i \u003C subs_len \u0026\u0026 !matched; i\u002B\u002B) {\n\u002B        DDS_InstanceHandle_t * const matched_ih =\n\u002B          DDS_InstanceHandleSeq_get_reference(\u0026matched_subscriptions, i);\n\u002B        matched = DDS_InstanceHandle_compare(matched_ih, \u0026reader_ih) == 0;\n\u002B      }\n\u002B      return matched;\n\u002B    };\n\u002B\n\u002B  if (!matched_cv.wait_for(lock, this-\u003Emax_blocking_time, done_waiting)) {\n\u002B    return RMW_RET_TIMEOUT;\n\u002B  }\n\u002B\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n rmw_publisher_t *\n rmw_connextdds_create_publisher(\n   rmw_context_impl_t * const ctx,\n@@ -1159,7 \u002B1252,8 @@ RMW_Connext_Subscriber::RMW_Connext_Subscriber(\n   const bool created_topic,\n   DDS_TopicDescription * const dds_topic_cft,\n   const char * const cft_expression,\n-  const bool internal)\n\u002B  const bool internal,\n\u002B  RMW_Connext_Publisher * const related_pub)\n : internal(internal),\n   ignore_local(ignore_local),\n   ctx(ctx),\n@@ -1169,7 \u002B1263,8 @@ RMW_Connext_Subscriber::RMW_Connext_Subscriber(\n   cft_expression(cft_expression),\n   type_support(type_support),\n   created_topic(created_topic),\n-  status_condition(dds_reader, ignore_local, internal)\n\u002B  status_condition(dds_reader, ignore_local, internal),\n\u002B  related_pub(related_pub)\n {\n   rmw_connextdds_get_entity_gid(this-\u003Edds_reader, this-\u003Eros_gid);\n \n@@ -1180,7 \u002B1275,7 @@ RMW_Connext_Subscriber::RMW_Connext_Subscriber(\n   this-\u003Eloan_info = def_info_seq;\n   this-\u003Eloan_len = 0;\n   this-\u003Eloan_next = 0;\n-  if (RMW_RET_OK != this-\u003Estatus_condition.install(this)) {\n\u002B  if (RMW_RET_OK != this-\u003Estatus_condition.install(this, this-\u003Erelated_pub)) {\n     RMW_CONNEXT_LOG_ERROR(\u0022failed to install condition on reader\u0022)\n     throw std::runtime_error(\u0022failed to install condition on reader\u0022);\n   }\n@@ -1201,7 \u002B1296,8 @@ RMW_Connext_Subscriber::create(\n   const bool intro_members_cpp,\n   std::string * const type_name,\n   const char * const cft_name,\n-  const char * const cft_filter)\n\u002B  const char * const cft_filter,\n\u002B  RMW_Connext_Publisher * const related_pub)\n {\n   RMW_Connext_MessageTypeSupport * const type_support =\n     RMW_Connext_MessageTypeSupport::register_type_support(\n@@ -1390,7 \u002B1486,8 @@ RMW_Connext_Subscriber::create(\n     topic_created,\n     cft_topic,\n     sub_cft_expr,\n-    internal);\n\u002B    internal,\n\u002B    related_pub);\n \n   if (nullptr == rmw_sub_impl) {\n     RMW_CONNEXT_LOG_ERROR_SET(\u0022failed to allocate RMW subscriber\u0022)\n@@ -1667,17 \u002B1764,21 @@ RMW_Connext_Subscriber::requestreply_header_from_dds(\n {\n   const struct DDS_GUID_t * src_guid = nullptr;\n   const struct DDS_SequenceNumber_t * src_sn = nullptr;\n\u002B  const struct DDS_GUID_t * writer_guid = nullptr;\n \n   if (rr_msg-\u003Erequest) {\n-    src_guid = \u0026sample_identity-\u003Ewriter_guid;\n\u002B    src_guid = \u0026related_sample_identity-\u003Ewriter_guid;\n     src_sn = \u0026sample_identity-\u003Esequence_number;\n\u002B    writer_guid = \u0026sample_identity-\u003Ewriter_guid;\n   } else {\n     src_guid = \u0026related_sample_identity-\u003Ewriter_guid;\n     src_sn = \u0026related_sample_identity-\u003Esequence_number;\n\u002B    writer_guid = \u0026sample_identity-\u003Ewriter_guid;\n   }\n \n   rmw_connextdds_guid_to_gid(*src_guid, rr_msg-\u003Egid);\n   rmw_connextdds_sn_dds_to_ros(*src_sn, rr_msg-\u003Esn);\n\u002B  rmw_connextdds_guid_to_gid(*writer_guid, rr_msg-\u003Ewriter_gid);\n }\n \n rmw_ret_t\n@@ -2515,7 \u002B2616,7 @@ RMW_Connext_Client::create(\n   char * cft_name = nullptr,\n   *cft_filter = nullptr;\n   auto scope_exit_cft_name = rcpputils::make_scope_exit(\n-    [cft_name, cft_filter]()\n\u002B    [\u0026cft_name, \u0026cft_filter]()\n     {\n       if (nullptr != cft_name) {\n         DDS_String_free(cft_name);\n@@ -2662,9 \u002B2763,11 @@ RMW_Connext_Client::take_response(\n   if (taken_msg) {\n     request_header-\u003Erequest_id.sequence_number = rr_msg.sn;\n \n\u002B    /* (asorbini) although messages are correlated using the reply DataReader\u0027s GUID,\n\u002B       we report the writer\u0027s GUID to upper layers. */\n     memcpy(\n       request_header-\u003Erequest_id.writer_guid,\n-      rr_msg.gid.data,\n\u002B      this-\u003Erequest_pub-\u003Egid()-\u003Edata,\n       16);\n \n     if (this-\u003Ectx-\u003Ecyclone_compatible) {\n@@ -2706,10 \u002B2809,15 @@ RMW_Connext_Client::send_request(\n   if (this-\u003Ectx-\u003Erequest_reply_mapping == RMW_Connext_RequestReplyMapping::Basic) {\n     *sequence_id = \u002B\u002Bthis-\u003Enext_request_id;\n     rr_msg.sn = *sequence_id;\n\u002B    rr_msg.gid = *this-\u003Erequest_pub-\u003Egid();\n   } else {\n     rr_msg.sn = -1;\n\u002B    /* (asorbini) use the reply DataReader\u0027s GUID to correlate request and reply, instead of the\n\u002B      request DataWriter\u0027s GUID, so that the service may try to wait for the DataReader to be\n\u002B      matched before writing the reply. */\n\u002B    rr_msg.gid = *this-\u003Ereply_sub-\u003Egid();\n   }\n-  rr_msg.gid = *this-\u003Erequest_pub-\u003Egid();\n\u002B\n   rr_msg.payload = const_cast\u003Cvoid *\u003E(ros_request);\n \n   RMW_CONNEXT_LOG_DEBUG_A(\n@@ -2923,7 \u002B3031,13 @@ RMW_Connext_Service::create(\n     RMW_CONNEXT_MESSAGE_REQUEST,\n     svc_members_req,\n     svc_members_req_cpp,\n-    \u0026request_type);\n\u002B    \u0026request_type,\n\u002B    nullptr /* cft_name */,\n\u002B    nullptr /* cft_filter */,\n\u002B    /* If we are using the extended RPC mapping, then we cache the reply writer\n\u002B       so that we can notify it of \u0022subscription_match\u0022 events. */\n\u002B    (ctx-\u003Erequest_reply_mapping == RMW_Connext_RequestReplyMapping::Extended ?\n\u002B    svc_impl-\u003Ereply_pub : nullptr));\n \n   if (nullptr == svc_impl-\u003Erequest_sub) {\n     RMW_CONNEXT_LOG_ERROR(\u0022failed to create service requester\u0022)\n@@ -2937,14 \u002B3051,14 @@ RMW_Connext_Service::create(\n rmw_ret_t\n RMW_Connext_Service::enable()\n {\n-  rmw_ret_t rc = this-\u003Ereply_pub-\u003Eenable();\n\u002B  rmw_ret_t rc = this-\u003Erequest_sub-\u003Eenable();\n   if (RMW_RET_OK != rc) {\n-    RMW_CONNEXT_LOG_ERROR(\u0022failed to enable service\u0027s publisher\u0022)\n\u002B    RMW_CONNEXT_LOG_ERROR(\u0022failed to enable service\u0027s subscription\u0022)\n     return rc;\n   }\n-  rc = this-\u003Erequest_sub-\u003Eenable();\n\u002B  rc = this-\u003Ereply_pub-\u003Eenable();\n   if (RMW_RET_OK != rc) {\n-    RMW_CONNEXT_LOG_ERROR(\u0022failed to enable service\u0027s subscription\u0022)\n\u002B    RMW_CONNEXT_LOG_ERROR(\u0022failed to enable service\u0027s publisher\u0022)\n     return rc;\n   }\n   return RMW_RET_OK;\n@@ -2984,6 \u002B3098,11 @@ RMW_Connext_Service::take_request(\n     request_header-\u003Esource_timestamp = message_info.source_timestamp;\n     request_header-\u003Ereceived_timestamp = message_info.received_timestamp;\n \n\u002B    if (ctx-\u003Erequest_reply_mapping == RMW_Connext_RequestReplyMapping::Extended) {\n\u002B      /* Cache the writer/reader GUIDs */\n\u002B      reply_pub-\u003Epush_related_endpoints(rr_msg.gid, rr_msg.writer_gid);\n\u002B    }\n\u002B\n     *taken = true;\n \n     RMW_CONNEXT_LOG_DEBUG_A(\n@@ -3035,6 \u002B3154,59 @@ RMW_Connext_Service::send_response(\n     reinterpret_cast\u003Cconst uint32_t *\u003E(rr_msg.gid.data)[3],\n     rr_msg.sn)\n \n\u002B  /* (asorbini) The following logic tries to partially work around some race conditions that exists\n\u002B     in the way request/reply interactions between clients and services are mapped to DDS topics\n\u002B     and endpoints.\n\u002B\n\u002B     It is possible for the service\u0027s request DataReader to receive a request from the client,\n\u002B     handle it, and try to write the response before the service\u0027s reply DataWriter has actually\n\u002B     matched the client\u0027s reply DataReader. If this is the case, the response will be lost\n\u002B     (unless the endpoints have been configured with \u0022transient local\u0022 or higher Durability QoS,\n\u002B     but this is not the default configuration, and it is unlikely to be used in practice...).\n\u002B     The data race and loss of reply message may also occur in the case of an\n\u002B     \u0022asymmetric discovery\u0022 between the client\u0027s reply DataReader and the service\u0027s reply\n\u002B     DataWriter, where the latter has discovered and matched the former, but not viceversa.\n\u002B\n\u002B     The only way to fully resolve these data races is to have the underlying implementation force\n\u002B     a \u0022match ordering\u0022 when dealing with pairs of endpoints used for RPC exchanges. The solution\n\u002B     is described by the OMG DDS-RPC 1.0 specification, section 7.6.2 (Enhanced Service Mapping).\n\u002B     It requires the DDS implementation to prevent the DataWriter from matching its remote\n\u002B     counterpart before the associated DataReader has matched. This behavior must be enforced\n\u002B     by both service and client for all data races to be resolved.\n\u002B\n\u002B     This partial workaround relies on (ab)using the \u0022related sample identity\u0022 field to communicate\n\u002B     the client\u0027s reply DataReader\u0027s GUID to the service. Normally, this field should would be\n\u002B     used to communicate the client\u0027s request DataWriter\u0027s GUID.\n\u002B\n\u002B     When the service detects the presence of an unusual DataReader GUID, it will enter a\n\u002B     (time-bounded) loop to query the reply DataWriter\u0027s list of matched subscriptions, and wait\n\u002B     for the GUID to appear.\n\u002B\n\u002B     If the reader is not matched within the timeout (HistoryQosPolicy::max_blocking_time), the\n\u002B     service will return RMW_RET_TIMEOUT to the upper layers. Otherwise, the response is written\n\u002B     out as normal.\n\u002B\n\u002B     It is still possible for the response to be lost by the client, in case of an asymmetric\n\u002B     discovery, but this issue partially mitigated by the implementation of\n\u002B     Client::is_service_available.\n\u002B  */\n\u002B  if (ctx-\u003Erequest_reply_mapping == RMW_Connext_RequestReplyMapping::Extended) {\n\u002B    struct DDS_GUID_t src_guid = DDS_GUID_INITIALIZER;\n\u002B    rmw_ret_t rc = RMW_RET_ERROR;\n\u002B    rc = rmw_connextdds_gid_to_guid(rr_msg.gid, src_guid);\n\u002B    if (RMW_RET_OK != rc) {\n\u002B      return rc;\n\u002B    }\n\u002B    DDS_RTPS_GUID_t * const rtps_guid = DDS_GUID_as_rtps_guid(\u0026src_guid);\n\u002B    if (rtps_guid-\u003EentityId.entityKind \u0026 0x04) {\n\u002B      bool unmatched = false;\n\u002B      rc = reply_pub-\u003Ewait_for_subscription(rr_msg.gid, unmatched, rr_msg.writer_gid);\n\u002B      if (RMW_RET_OK != rc || unmatched) {\n\u002B        return rc;\n\u002B      }\n\u002B    }\n\u002B  }\n\u002B\n   return this-\u003Ereply_pub-\u003Ewrite(\u0026rr_msg, false /* serialized */, \u0026write_params);\n }\n \ndiff --git rmw_connextdds_common/src/common/rmw_impl_waitset_std.cpp rmw_connextdds_common/src/common/rmw_impl_waitset_std.cpp\nindex d9a4759..6f7f040 100644\n--- rmw_connextdds_common/src/common/rmw_impl_waitset_std.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_impl_waitset_std.cpp\n@@ -614,7 \u002B614,8 @@ RMW_Connext_StatusCondition::update_status_inconsistent_topic(\n \n rmw_ret_t\n RMW_Connext_SubscriberStatusCondition::install(\n-  RMW_Connext_Subscriber * const sub)\n\u002B  RMW_Connext_Subscriber * const sub,\n\u002B  RMW_Connext_Publisher * const related_pub)\n {\n   DDS_DataReaderListener listener = DDS_DataReaderListener_INITIALIZER;\n   DDS_StatusMask listener_mask = DDS_STATUS_MASK_NONE;\n@@ -644,6 \u002B645,9 @@ RMW_Connext_SubscriberStatusCondition::install(\n   rmw_connextdds_configure_subscriber_condition_listener(\n     this, \u0026listener, \u0026listener_mask);\n \n\u002B  this-\u003Esub = sub;\n\u002B  this-\u003Erelated_pub = related_pub;\n\u002B\n   if (DDS_RETCODE_OK !=\n     DDS_DataReader_set_listener(sub-\u003Ereader(), \u0026listener, listener_mask))\n   {\n@@ -662,8 \u002B666,6 @@ RMW_Connext_SubscriberStatusCondition::install(\n     return RMW_RET_ERROR;\n   }\n \n-  this-\u003Esub = sub;\n-\n   return RMW_RET_OK;\n }\n \n@@ -883,6 \u002B885,10 @@ RMW_Connext_SubscriberStatusCondition::update_status_matched(\n   this-\u003Estatus_matched.current_count_change =\n     this-\u003Estatus_matched.current_count - this-\u003Estatus_matched_last.current_count;\n \n\u002B  if (nullptr != this-\u003Esub \u0026\u0026 nullptr != this-\u003Erelated_pub) {\n\u002B    this-\u003Erelated_pub-\u003Eon_related_subscription_matched(this-\u003Esub, status);\n\u002B  }\n\u002B\n   this-\u003Enotify_new_event(RMW_EVENT_SUBSCRIPTION_MATCHED);\n }\n \n@@ -909,6 \u002B915,8 @@ RMW_Connext_PublisherStatusCondition::install(\n     DDS_LIVELINESS_LOST_STATUS |\n     DDS_PUBLICATION_MATCHED_STATUS;\n \n\u002B  this-\u003Epub = pub;\n\u002B\n   if (DDS_RETCODE_OK !=\n     DDS_DataWriter_set_listener(\n       pub-\u003Ewriter(), \u0026listener, listener_mask))\n@@ -934,8 \u002B942,6 @@ RMW_Connext_PublisherStatusCondition::install(\n     return RMW_RET_ERROR;\n   }\n \n-  this-\u003Epub = pub;\n-\n   return RMW_RET_OK;\n }\n \n@@ -1075,5 \u002B1081,9 @@ RMW_Connext_PublisherStatusCondition::update_status_matched(\n   this-\u003Estatus_matched.current_count_change =\n     this-\u003Estatus_matched.current_count - this-\u003Estatus_matched_last.current_count;\n \n\u002B  if (nullptr != this-\u003Epub) {\n\u002B    this-\u003Epub-\u003Eon_publication_matched(status);\n\u002B  }\n\u002B\n   this-\u003Enotify_new_event(RMW_EVENT_PUBLICATION_MATCHED);\n }\ndiff --git rmw_connextdds_common/src/ndds/dds_api_ndds.cpp rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\nindex 42d6ad6..d9fcd91 100644\n--- rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\n@@ -30,6 \u002B30,8 @@\n #include \u0022rmw_connextdds/rmw_impl.hpp\u0022\n #include \u0022rmw_connextdds/graph_cache.hpp\u0022\n \n\u002B#include \u0022dds_c/dds_c_infrastructure_impl.h\u0022\n\u002B\n const char * const RMW_CONNEXTDDS_ID = \u0022rmw_connextdds\u0022;\n const char * const RMW_CONNEXTDDS_SERIALIZATION_FORMAT = \u0022cdr\u0022;\n \n@@ -750,22 \u002B752,20 @@ rmw_connextdds_write_message(\n     const RMW_Connext_RequestReplyMessage * const rr_msg =\n       reinterpret_cast\u003Cconst RMW_Connext_RequestReplyMessage *\u003E(message-\u003Euser_data);\n \n-    if (!rr_msg-\u003Erequest) {\n-      /* If this is a reply, propagate the request\u0027s sample identity\n-         via the related_sample_identity field */\n-      rmw_ret_t rc = RMW_RET_ERROR;\n-\n-      rmw_connextdds_sn_ros_to_dds(\n-        rr_msg-\u003Esn,\n-        write_params.related_sample_identity.sequence_number);\n\u002B    // Propagate the request\u0027s sample identity via the related_sample_identity field\n\u002B    int64_t sn_ros = rr_msg-\u003Esn \u003E= 0 ? rr_msg-\u003Esn : 0;\n\u002B    rmw_connextdds_sn_ros_to_dds(\n\u002B      sn_ros,\n\u002B      write_params.related_sample_identity.sequence_number);\n\u002B\n\u002B    rmw_ret_t rc = rmw_connextdds_gid_to_guid(\n\u002B      rr_msg-\u003Erequest ? rr_msg-\u003Egid : rr_msg-\u003Ewriter_gid,\n\u002B      write_params.related_sample_identity.writer_guid);\n\u002B    if (RMW_RET_OK != rc) {\n\u002B      return rc;\n\u002B    }\n \n-      rc = rmw_connextdds_gid_to_guid(\n-        rr_msg-\u003Egid,\n-        write_params.related_sample_identity.writer_guid);\n-      if (RMW_RET_OK != rc) {\n-        return rc;\n-      }\n-    } else {\n\u002B    if (rr_msg-\u003Erequest) {\n       // enable WriteParams::replace_auto to retrieve SN of published message\n       write_params.replace_auto = DDS_BOOLEAN_TRUE;\n     }\n@@ -1599,3 \u002B1599,12 @@ rmw_connextdds_get_cft_filter_expression(\n \n   return RMW_RET_OK;\n }\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_connextdds_guid_to_instance_handle(\n\u002B  const struct DDS_GUID_t * const guid,\n\u002B  DDS_InstanceHandle_t * const instance_handle)\n\u002B{\n\u002B  DDS_GUID_to_instance_handle(guid, instance_handle);\n\u002B  return RMW_RET_OK;\n\u002B}\ndiff --git rmw_connextdds_common/src/rtime/dds_api_rtime.cpp rmw_connextdds_common/src/rtime/dds_api_rtime.cpp\nindex d0372f9..332a8fc 100644\n--- rmw_connextdds_common/src/rtime/dds_api_rtime.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/rtime/dds_api_rtime.cpp\n@@ -2041,3 \u002B2041,13 @@ rmw_connextdds_get_cft_filter_expression(\n   UNUSED_ARG(options);\n   return RMW_RET_UNSUPPORTED;\n }\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_connextdds_guid_to_instance_handle(\n\u002B  const struct DDS_GUID_t * const guid,\n\u002B  DDS_InstanceHandle_t * const instance_handle)\n\u002B{\n\u002B  UNUSED_ARG(guid);\n\u002B  UNUSED_ARG(instance_handle);\n\u002B  return RMW_RET_UNSUPPORTED;\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "1ea3e191b7fd284718412d97c6ffe34f4bd79fbd",
    "RawMessage": "Enhanced rpc with sampleinfoex",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex bde60e3..1d83c7e 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -110,7 \u002B110,7 @@ rmw_create_client(\n   dds_Topic * request_topic = nullptr;\n   dds_Topic * response_topic = nullptr;\n \n-  uint64_t guid_temp = 0;\n\u002B  uint8_t client_guid[16] = {0};\n   dds_ReturnCode_t ret;\n   rmw_ret_t rmw_ret;\n \n@@ -123,13 \u002B123,6 @@ rmw_create_client(\n   std::string request_metastring;\n   std::string response_metastring;\n \n-  // Random values are required for GUID\n-  std::random_device rd;\n-  std::default_random_engine dre(rd());\n-  std::uniform_int_distribution\u003Cuint64_t\u003E uniform_dist(\n-    (std::numeric_limits\u003Cuint64_t\u003E::min)(),\n-    (std::numeric_limits\u003Cuint64_t\u003E::max)());\n-\n   // Create topic and type name strings\n   service_type_name =\n     create_service_type_name(type_support-\u003Edata, type_support-\u003Etypesupport_identifier);\n@@ -363,10 \u002B356,8 @@ rmw_create_client(\n   client_info-\u003Eread_condition = read_condition;\n \n   // Set GUID\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info-\u003Ewriter_guid, \u0026guid_temp, sizeof(guid_temp));\n-  guid_temp = uniform_dist(dre);\n-  memcpy(client_info-\u003Ewriter_guid \u002B sizeof(guid_temp), \u0026guid_temp, sizeof(guid_temp));\n\u002B  dds_DataWriter_get_guid(request_writer, client_guid);\n\u002B  memcpy(client_info-\u003Ewriter_guid, client_guid, sizeof(client_guid));\n \n   rmw_client = rmw_client_allocate();\n   if (rmw_client == nullptr) {\ndiff --git rmw_gurumdds_cpp/src/rmw_request.cpp rmw_gurumdds_cpp/src/rmw_request.cpp\nindex bffed02..f5c2444 100644\n--- rmw_gurumdds_cpp/src/rmw_request.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_request.cpp\n@@ -41,6 \u002B41,15 @@ rmw_send_request(\n   RMW_CHECK_ARGUMENT_FOR_NULL(ros_request, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(sequence_id, RMW_RET_INVALID_ARGUMENT);\n \n\u002B  const char * env_name = \u0022RMW_GURUMDDS_REQUEST_REPLY_MAPPING\u0022;\n\u002B  char * env_value = nullptr;\n\u002B  bool service_mapping_basic = false;\n\u002B\n\u002B  env_value = getenv(env_name);\n\u002B  if (env_value != nullptr) {\n\u002B    service_mapping_basic = (strcmp(env_value, \u0022basic\u0022) == 0);\n\u002B  }\n\u002B\n   GurumddsClientInfo * client_info = static_cast\u003CGurumddsClientInfo *\u003E(client-\u003Edata);\n   if (client_info == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022client info handle is null\u0022);\n@@ -61,42 \u002B70,84 @@ rmw_send_request(\n \n   size_t size = 0;\n \n-  void * dds_request = allocate_request(\n-    type_support-\u003Edata,\n-    type_support-\u003Etypesupport_identifier,\n-    ros_request,\n-    \u0026size\n-  );\n\u002B  if (service_mapping_basic) {\n\u002B    void * dds_request = allocate_request_basic(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_request,\n\u002B      \u0026size\n\u002B    );\n \n-  if (dds_request == nullptr) {\n-    // Error message already set\n-    return RMW_RET_ERROR;\n-  }\n\u002B    if (dds_request == nullptr) {\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B\n\u002B    bool res = serialize_request_basic(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_request,\n\u002B      dds_request,\n\u002B      size,\n\u002B      \u002B\u002Bclient_info-\u003Esequence_number,\n\u002B      client_info-\u003Ewriter_guid\n\u002B    );\n\u002B\n\u002B    if (!res) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to serialize message\u0022);\n\u002B      free(dds_request);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n \n-  bool res = serialize_request(\n-    type_support-\u003Edata,\n-    type_support-\u003Etypesupport_identifier,\n-    ros_request,\n-    dds_request,\n-    size,\n-    \u002B\u002Bclient_info-\u003Esequence_number,\n-    client_info-\u003Ewriter_guid\n-  );\n-\n-  if (!res) {\n-    RMW_SET_ERROR_MSG(\u0022failed to serialize message\u0022);\n\u002B    if (dds_DataWriter_raw_write(request_writer, dds_request, size) != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to send request\u0022);\n\u002B      free(dds_request);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     free(dds_request);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  } else {\n\u002B    void * dds_request = allocate_request_enhanced(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_request,\n\u002B      \u0026size\n\u002B    );\n\u002B\n\u002B    if (dds_request == nullptr) {\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B\n\u002B    bool res = serialize_request_enhanced(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_request,\n\u002B      dds_request,\n\u002B      size\n\u002B    );\n\u002B\n\u002B    if (!res) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to serialize message\u0022);\n\u002B      free(dds_request);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n \n-  if (dds_DataWriter_raw_write(request_writer, dds_request, size) != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to publish data\u0022);\n\u002B    dds_SampleInfoEx sampleinfo_ex;\n\u002B    memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B    ros_sn_to_dds_sn(\u002B\u002Bclient_info-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n\u002B    ros_guid_to_dds_guid(\n\u002B      reinterpret_cast\u003Cint8_t *\u003E(client_info-\u003Ewriter_guid),\n\u002B      reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n\u002B\n\u002B    if (dds_DataWriter_raw_write_w_sampleinfoex(\n\u002B        request_writer, dds_request, size, \u0026sampleinfo_ex) != dds_RETCODE_OK)\n\u002B    {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to send request\u0022);\n\u002B      free(dds_request);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     free(dds_request);\n-    return RMW_RET_ERROR;\n   }\n \n   *sequence_id = client_info-\u003Esequence_number;\n-  free(dds_request);\n \n   return RMW_RET_OK;\n }\n@@ -119,6 \u002B170,15 @@ rmw_take_request(\n \n   *taken = false;\n \n\u002B  const char * env_name = \u0022RMW_GURUMDDS_REQUEST_REPLY_MAPPING\u0022;\n\u002B  char * env_value = nullptr;\n\u002B  bool service_mapping_basic = false;\n\u002B\n\u002B  env_value = getenv(env_name);\n\u002B  if (env_value != nullptr) {\n\u002B    service_mapping_basic = (strcmp(env_value, \u0022basic\u0022) == 0);\n\u002B  }\n\u002B\n   GurumddsServiceInfo * service_info = static_cast\u003CGurumddsServiceInfo *\u003E(service-\u003Edata);\n   if (service_info == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022service info handle is null\u0022);\n@@ -158,54 \u002B218,91 @@ rmw_take_request(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n\u002B  if (service_mapping_basic) {\n\u002B    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B      request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n\u002B      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n\u002B    if (ret == dds_RETCODE_NO_DATA) {\n\u002B      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B      dds_DataSeq_delete(data_values);\n\u002B      dds_SampleInfoSeq_delete(sample_infos);\n\u002B      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      return RMW_RET_OK;\n\u002B    }\n\u002B\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n\u002B      dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B      dds_DataSeq_delete(data_values);\n\u002B      dds_SampleInfoSeq_delete(sample_infos);\n\u002B      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B\n\u002B    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B    if (sample_info-\u003Evalid_data) {\n\u002B      void * sample = dds_DataSeq_get(data_values, 0);\n\u002B      if (sample == nullptr) {\n\u002B        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B      int32_t sn_high = 0;\n\u002B      uint32_t sn_low = 0;\n\u002B      int8_t client_guid[16] = {0};\n\u002B\n\u002B      bool res = deserialize_request_basic(\n\u002B        type_support-\u003Edata,\n\u002B        type_support-\u003Etypesupport_identifier,\n\u002B        ros_request,\n\u002B        sample,\n\u002B        static_cast\u003Csize_t\u003E(size),\n\u002B        \u0026sn_high,\n\u002B        \u0026sn_low,\n\u002B        client_guid\n\u002B      );\n\u002B\n\u002B      if (!res) {\n\u002B        // Error message already set\n\u002B        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B\n\u002B      request_header-\u003Esource_timestamp =\n\u002B        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sample_info-\u003Esource_timestamp.nanosec;\n\u002B      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n\u002B      request_header-\u003Ereceived_timestamp = 0;\n\u002B      request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n\u002B      memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B    }\n \n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n     dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n     dds_DataSeq_delete(data_values);\n     dds_SampleInfoSeq_delete(sample_infos);\n     dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  } else {\n\u002B    dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n\u002B      request_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n\u002B      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info-\u003Evalid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n\u002B    if (ret == dds_RETCODE_NO_DATA) {\n       dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n       dds_DataSeq_delete(data_values);\n       dds_SampleInfoSeq_delete(sample_infos);\n       dds_UnsignedLongSeq_delete(sample_sizes);\n-      return RMW_RET_ERROR;\n\u002B      return RMW_RET_OK;\n     }\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    int32_t sn_high = 0;\n-    uint32_t sn_low = 0;\n-    int8_t client_guid[16] = {0};\n-    bool res = deserialize_request(\n-      type_support-\u003Edata,\n-      type_support-\u003Etypesupport_identifier,\n-      ros_request,\n-      sample,\n-      static_cast\u003Csize_t\u003E(size),\n-      \u0026sn_high,\n-      \u0026sn_low,\n-      client_guid\n-    );\n \n-    if (!res) {\n-      // Error message already set\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n       dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n       dds_DataSeq_delete(data_values);\n       dds_SampleInfoSeq_delete(sample_infos);\n@@ -213,22 \u002B310,56 @@ rmw_take_request(\n       return RMW_RET_ERROR;\n     }\n \n-    request_header-\u003Esource_timestamp =\n-      sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-      sample_info-\u003Esource_timestamp.nanosec;\n-    // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-    request_header-\u003Ereceived_timestamp = 0;\n-    request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n-    memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B    if (sample_info-\u003Evalid_data) {\n\u002B      void * sample = dds_DataSeq_get(data_values, 0);\n\u002B      if (sample == nullptr) {\n\u002B        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B      int64_t sequence_number = 0;\n\u002B      int8_t client_guid[16] = {0};\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n\u002B      dds_guid_to_ros_guid(reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex-\u003Esrc_guid), client_guid);\n\u002B      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B\n\u002B      bool res = deserialize_request_enhanced(\n\u002B        type_support-\u003Edata,\n\u002B        type_support-\u003Etypesupport_identifier,\n\u002B        ros_request,\n\u002B        sample,\n\u002B        static_cast\u003Csize_t\u003E(size)\n\u002B      );\n\u002B\n\u002B      if (!res) {\n\u002B        // Error message already set\n\u002B        dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B\n\u002B      request_header-\u003Esource_timestamp =\n\u002B        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sample_info-\u003Esource_timestamp.nanosec;\n\u002B      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n\u002B      request_header-\u003Ereceived_timestamp = 0;\n\u002B      request_header-\u003Erequest_id.sequence_number = sequence_number;\n\u002B      memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B    }\n \n-    *taken = true;\n\u002B    dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n\u002B    dds_DataSeq_delete(data_values);\n\u002B    dds_SampleInfoSeq_delete(sample_infos);\n\u002B    dds_UnsignedLongSeq_delete(sample_sizes);\n   }\n \n-  dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n-\n\u002B  *taken = true;\n   return RMW_RET_OK;\n }\n }  // extern \u0022C\u0022\ndiff --git rmw_gurumdds_cpp/src/rmw_response.cpp rmw_gurumdds_cpp/src/rmw_response.cpp\nindex fec04a4..7b0635d 100644\n--- rmw_gurumdds_cpp/src/rmw_response.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_response.cpp\n@@ -45,6 \u002B45,15 @@ rmw_take_response(\n \n   *taken = false;\n \n\u002B  const char * env_name = \u0022RMW_GURUMDDS_REQUEST_REPLY_MAPPING\u0022;\n\u002B  char * env_value = nullptr;\n\u002B  bool service_mapping_basic = false;\n\u002B\n\u002B  env_value = getenv(env_name);\n\u002B  if (env_value != nullptr) {\n\u002B    service_mapping_basic = (strcmp(env_value, \u0022basic\u0022) == 0);\n\u002B  }\n\u002B\n   GurumddsClientInfo * client_info = static_cast\u003CGurumddsClientInfo *\u003E(client-\u003Edata);\n   if (client_info == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022client info handle is null\u0022);\n@@ -84,54 \u002B93,21 @@ rmw_take_response(\n     return RMW_RET_ERROR;\n   }\n \n-  dds_ReturnCode_t ret = dds_DataReader_raw_take(\n-    response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  if (service_mapping_basic) {\n\u002B    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B      response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n\u002B      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n-  dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n-  if (sample_info-\u003Evalid_data) {\n-    void * sample = dds_DataSeq_get(data_values, 0);\n-    if (sample == nullptr) {\n\u002B    if (ret == dds_RETCODE_NO_DATA) {\n       dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n       dds_DataSeq_delete(data_values);\n       dds_SampleInfoSeq_delete(sample_infos);\n       dds_UnsignedLongSeq_delete(sample_sizes);\n-      return RMW_RET_ERROR;\n\u002B      return RMW_RET_OK;\n     }\n-    uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n-    int32_t sn_high = 0;\n-    uint32_t sn_low = 0;\n-    int8_t client_guid[16] = {0};\n-    bool res = deserialize_response(\n-      type_support-\u003Edata,\n-      type_support-\u003Etypesupport_identifier,\n-      ros_response,\n-      sample,\n-      static_cast\u003Csize_t\u003E(size),\n-      \u0026sn_high,\n-      \u0026sn_low,\n-      client_guid\n-    );\n \n-    if (!res) {\n-      // Error message already set\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n       dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n       dds_DataSeq_delete(data_values);\n       dds_SampleInfoSeq_delete(sample_infos);\n@@ -139,7 \u002B115,40 @@ rmw_take_response(\n       return RMW_RET_ERROR;\n     }\n \n-    if (memcmp(client_info-\u003Ewriter_guid, client_guid, 16) == 0) {\n\u002B    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B    if (sample_info-\u003Evalid_data) {\n\u002B      void * sample = dds_DataSeq_get(data_values, 0);\n\u002B      if (sample == nullptr) {\n\u002B        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B      int32_t sn_high = 0;\n\u002B      uint32_t sn_low = 0;\n\u002B      int8_t client_guid[16] = {0};\n\u002B      bool res = deserialize_response_basic(\n\u002B        type_support-\u003Edata,\n\u002B        type_support-\u003Etypesupport_identifier,\n\u002B        ros_response,\n\u002B        sample,\n\u002B        static_cast\u003Csize_t\u003E(size),\n\u002B        \u0026sn_high,\n\u002B        \u0026sn_low,\n\u002B        client_guid\n\u002B      );\n\u002B\n\u002B      if (!res) {\n\u002B        // Error message already set\n\u002B        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B\n       request_header-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n@@ -147,16 \u002B156,86 @@ rmw_take_response(\n       request_header-\u003Ereceived_timestamp = 0;\n       request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n       memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B    }\n\u002B\n\u002B    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B    dds_DataSeq_delete(data_values);\n\u002B    dds_SampleInfoSeq_delete(sample_infos);\n\u002B    dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  } else {\n\u002B    dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n\u002B      response_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, 1,\n\u002B      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n-      *taken = true;\n\u002B    if (ret == dds_RETCODE_NO_DATA) {\n\u002B      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B      dds_DataSeq_delete(data_values);\n\u002B      dds_SampleInfoSeq_delete(sample_infos);\n\u002B      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      return RMW_RET_OK;\n\u002B    }\n\u002B\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n\u002B      dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B      dds_DataSeq_delete(data_values);\n\u002B      dds_SampleInfoSeq_delete(sample_infos);\n\u002B      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      return RMW_RET_ERROR;\n     }\n-  }\n \n-  dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n-  dds_DataSeq_delete(data_values);\n-  dds_SampleInfoSeq_delete(sample_infos);\n-  dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, 0);\n\u002B    if (sample_info-\u003Evalid_data) {\n\u002B      void * sample = dds_DataSeq_get(data_values, 0);\n\u002B      if (sample == nullptr) {\n\u002B        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B      uint32_t size = dds_UnsignedLongSeq_get(sample_sizes, 0);\n\u002B      int64_t sequence_number = 0;\n\u002B      int8_t client_guid[16] = {0};\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n\u002B      dds_guid_to_ros_guid(reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex-\u003Esrc_guid), client_guid);\n\u002B      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B\n\u002B      bool res = deserialize_response_enhanced(\n\u002B        type_support-\u003Edata,\n\u002B        type_support-\u003Etypesupport_identifier,\n\u002B        ros_response,\n\u002B        sample,\n\u002B        static_cast\u003Csize_t\u003E(size)\n\u002B      );\n\u002B\n\u002B      if (!res) {\n\u002B        // Error message already set\n\u002B        dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B        dds_DataSeq_delete(data_values);\n\u002B        dds_SampleInfoSeq_delete(sample_infos);\n\u002B        dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B        return RMW_RET_ERROR;\n\u002B      }\n\u002B\n\u002B      if (memcmp(client_info-\u003Ewriter_guid, client_guid, 16) == 0) {\n\u002B        request_header-\u003Esource_timestamp =\n\u002B          sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B          sample_info-\u003Esource_timestamp.nanosec;\n\u002B        // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n\u002B        request_header-\u003Ereceived_timestamp = 0;\n\u002B        request_header-\u003Erequest_id.sequence_number = sequence_number;\n\u002B        memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B      }\n\u002B    }\n \n\u002B    dds_DataReader_raw_return_loan(response_reader, data_values, sample_infos, sample_sizes);\n\u002B    dds_DataSeq_delete(data_values);\n\u002B    dds_SampleInfoSeq_delete(sample_infos);\n\u002B    dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B  }\n\u002B\n\u002B  *taken = true;\n   return RMW_RET_OK;\n }\n \n@@ -174,6 \u002B253,15 @@ rmw_send_response(\n   RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n \n\u002B  const char * env_name = \u0022RMW_GURUMDDS_REQUEST_REPLY_MAPPING\u0022;\n\u002B  char * env_value = nullptr;\n\u002B  bool service_mapping_basic = false;\n\u002B\n\u002B  env_value = getenv(env_name);\n\u002B  if (env_value != nullptr) {\n\u002B    service_mapping_basic = (strcmp(env_value, \u0022basic\u0022) == 0);\n\u002B  }\n\u002B\n   GurumddsServiceInfo * service_info = static_cast\u003CGurumddsServiceInfo *\u003E(service-\u003Edata);\n   if (service_info == nullptr) {\n     RMW_SET_ERROR_MSG(\u0022service info handle is null\u0022);\n@@ -194,42 \u002B282,84 @@ rmw_send_response(\n \n   size_t size = 0;\n \n-  void * dds_response = allocate_response(\n-    type_support-\u003Edata,\n-    type_support-\u003Etypesupport_identifier,\n-    ros_response,\n-    \u0026size\n-  );\n\u002B  if (service_mapping_basic) {\n\u002B    void * dds_response = allocate_response_basic(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_response,\n\u002B      \u0026size\n\u002B    );\n \n-  if (dds_response == nullptr) {\n-    // Error message already set\n-    return RMW_RET_ERROR;\n-  }\n\u002B    if (dds_response == nullptr) {\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n \n-  bool res = serialize_response(\n-    type_support-\u003Edata,\n-    type_support-\u003Etypesupport_identifier,\n-    ros_response,\n-    dds_response,\n-    size,\n-    request_header-\u003Esequence_number,\n-    request_header-\u003Ewriter_guid\n-  );\n-\n-  if (!res) {\n-    // Error message already set\n\u002B    bool res = serialize_response_basic(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_response,\n\u002B      dds_response,\n\u002B      size,\n\u002B      request_header-\u003Esequence_number,\n\u002B      request_header-\u003Ewriter_guid\n\u002B    );\n\u002B\n\u002B    if (!res) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to serialize message\u0022);\n\u002B      free(dds_response);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B\n\u002B    if (dds_DataWriter_raw_write(response_writer, dds_response, size) != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to publish data\u0022);\n\u002B      free(dds_response);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     free(dds_response);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  } else {\n\u002B    void * dds_response = allocate_response_enhanced(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_response,\n\u002B      \u0026size\n\u002B    );\n\u002B\n\u002B    if (dds_response == nullptr) {\n\u002B      // Error message already set\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n \n-  if (dds_DataWriter_raw_write(response_writer, dds_response, size) != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to publish data\u0022);\n\u002B    bool res = serialize_response_enhanced(\n\u002B      type_support-\u003Edata,\n\u002B      type_support-\u003Etypesupport_identifier,\n\u002B      ros_response,\n\u002B      dds_response,\n\u002B      size\n\u002B    );\n\u002B\n\u002B    if (!res) {\n\u002B      // Error message already set\n\u002B      free(dds_response);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B\n\u002B    dds_SampleInfoEx sampleinfo_ex;\n\u002B    memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B    ros_sn_to_dds_sn(request_header-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n\u002B    ros_guid_to_dds_guid(\n\u002B      request_header-\u003Ewriter_guid,\n\u002B      reinterpret_cast\u003Cint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n\u002B\n\u002B    if (dds_DataWriter_raw_write_w_sampleinfoex(\n\u002B        response_writer, dds_response, size, \u0026sampleinfo_ex) != dds_RETCODE_OK)\n\u002B    {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to send response\u0022);\n\u002B      free(dds_response);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n     free(dds_response);\n-    return RMW_RET_ERROR;\n   }\n \n-  free(dds_response);\n-\n   return RMW_RET_OK;\n }\n }  // extern \u0022C\u0022\ndiff --git rmw_gurumdds_cpp/src/type_support_service.hpp rmw_gurumdds_cpp/src/type_support_service.hpp\nindex e9d58a9..7a1b44c 100644\n--- rmw_gurumdds_cpp/src/type_support_service.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/type_support_service.hpp\n@@ -97,7 \u002B97,7 @@ create_service_metastring(const void * untyped_members, const char * identifier)\n \n template\u003Ctypename ServiceMembersT\u003E\n void *\n-_allocate_request(\n\u002B_allocate_request_basic(\n   const void * untyped_members,\n   const void * ros_request,\n   size_t * size)\n@@ -117,20 \u002B117,20 @@ _allocate_request(\n }\n \n inline void *\n-allocate_request(\n\u002Ballocate_request_basic(\n   const void * untyped_members,\n   const char * identifier,\n   const void * ros_request,\n   size_t * size)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _allocate_request\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _allocate_request_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n       size\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _allocate_request\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _allocate_request_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n       size\n@@ -143,7 \u002B143,7 @@ allocate_request(\n \n template\u003Ctypename ServiceMembersT\u003E\n void *\n-_allocate_response(\n\u002B_allocate_response_basic(\n   const void * untyped_members,\n   const void * ros_response,\n   size_t * size)\n@@ -163,20 \u002B163,112 @@ _allocate_response(\n }\n \n inline void *\n-allocate_response(\n\u002Ballocate_response_basic(\n   const void * untyped_members,\n   const char * identifier,\n   const void * ros_response,\n   size_t * size)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _allocate_response\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _allocate_response_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n       size\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _allocate_response\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _allocate_response_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return nullptr;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bvoid *\n\u002B_allocate_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const void * ros_request,\n\u002B  size_t * size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return nullptr;\n\u002B  }\n\u002B\n\u002B  return _allocate_message\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Erequest_members_),\n\u002B    static_cast\u003Cconst uint8_t *\u003E(ros_request),\n\u002B    size,\n\u002B    false\n\u002B  );\n\u002B}\n\u002B\n\u002Binline void *\n\u002Ballocate_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  const void * ros_request,\n\u002B  size_t * size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _allocate_request_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _allocate_request_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return nullptr;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bvoid *\n\u002B_allocate_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const void * ros_response,\n\u002B  size_t * size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return nullptr;\n\u002B  }\n\u002B\n\u002B  return _allocate_message\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Eresponse_members_),\n\u002B    static_cast\u003Cconst uint8_t *\u003E(ros_response),\n\u002B    size,\n\u002B    false\n\u002B  );\n\u002B}\n\u002B\n\u002Binline void *\n\u002Ballocate_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  const void * ros_response,\n\u002B  size_t * size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _allocate_response_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _allocate_response_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n       size\n@@ -189,7 \u002B281,7 @@ allocate_response(\n \n template\u003Ctypename MessageMembersT\u003E\n bool\n-_serialize_service(\n\u002B_serialize_service_basic(\n   const void * untyped_members,\n   const uint8_t * ros_service,\n   uint8_t * dds_service,\n@@ -232,7 \u002B324,7 @@ _serialize_service(\n }\n \n inline bool\n-serialize_service(\n\u002Bserialize_service_basic(\n   const void * untyped_members,\n   const char * identifier,\n   const void * ros_service,\n@@ -243,7 \u002B335,7 @@ serialize_service(\n   bool is_request)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _serialize_service\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n\u002B    return _serialize_service_basic\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_service),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n@@ -253,7 \u002B345,7 @@ serialize_service(\n       is_request\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _serialize_service\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n\u002B    return _serialize_service_basic\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_service),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n@@ -270,7 \u002B362,7 @@ serialize_service(\n \n template\u003Ctypename ServiceMembersT\u003E\n bool\n-_serialize_request(\n\u002B_serialize_request_basic(\n   const void * untyped_members,\n   const uint8_t * ros_request,\n   uint8_t * dds_request,\n@@ -284,7 \u002B376,7 @@ _serialize_request(\n     return false;\n   }\n \n-  return _serialize_service\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n\u002B  return _serialize_service_basic\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n     static_cast\u003Cconst void *\u003E(members-\u003Erequest_members_),\n     ros_request,\n     dds_request,\n@@ -296,7 \u002B388,7 @@ _serialize_request(\n }\n \n inline bool\n-serialize_request(\n\u002Bserialize_request_basic(\n   const void * untyped_members,\n   const char * identifier,\n   const void * ros_request,\n@@ -306,7 \u002B398,7 @@ serialize_request(\n   const int8_t * client_guid)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _serialize_request\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _serialize_request_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n@@ -315,7 \u002B407,7 @@ serialize_request(\n       client_guid\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _serialize_request\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _serialize_request_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n@@ -331,7 \u002B423,7 @@ serialize_request(\n \n template\u003Ctypename ServiceMembersT\u003E\n bool\n-_serialize_response(\n\u002B_serialize_response_basic(\n   const void * untyped_members,\n   const uint8_t * ros_response,\n   uint8_t * dds_response,\n@@ -345,7 \u002B437,7 @@ _serialize_response(\n     return false;\n   }\n \n-  return _serialize_service\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n\u002B  return _serialize_service_basic\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n     static_cast\u003Cconst void *\u003E(members-\u003Eresponse_members_),\n     ros_response,\n     dds_response,\n@@ -357,7 \u002B449,7 @@ _serialize_response(\n }\n \n inline bool\n-serialize_response(\n\u002Bserialize_response_basic(\n   const void * untyped_members,\n   const char * identifier,\n   const void * ros_response,\n@@ -367,7 \u002B459,7 @@ serialize_response(\n   const int8_t * client_guid)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _serialize_response\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _serialize_response_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_response),\n@@ -376,7 \u002B468,7 @@ serialize_response(\n       client_guid\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _serialize_response\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _serialize_response_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_response),\n@@ -392,7 \u002B484,162 @@ serialize_response(\n \n template\u003Ctypename MessageMembersT\u003E\n bool\n-_deserialize_service(\n\u002B_serialize_service_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const uint8_t * ros_service,\n\u002B  uint8_t * dds_service,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members =\n\u002B    static_cast\u003Cconst MessageMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  try {\n\u002B    auto buffer = CDRSerializationBuffer(dds_service, size);\n\u002B    auto serializer = MessageSerializer(buffer);\n\u002B    serializer.serialize(members, ros_service, true);\n\u002B  } catch (std::runtime_error \u0026 e) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022Failed to serialize ros message: %s\u0022, e.what());\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return true;\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bserialize_service_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  const void * ros_service,\n\u002B  void * dds_service,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _serialize_service_enhanced\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_service),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _serialize_service_enhanced\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_service),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bbool\n\u002B_serialize_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const uint8_t * ros_request,\n\u002B  uint8_t * dds_request,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return _serialize_service_enhanced\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Erequest_members_),\n\u002B    ros_request,\n\u002B    dds_request,\n\u002B    size\n\u002B  );\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bserialize_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  const void * ros_request,\n\u002B  void * dds_request,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _serialize_request_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _serialize_request_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_request),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bbool\n\u002B_serialize_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const uint8_t * ros_response,\n\u002B  uint8_t * dds_response,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return _serialize_service_enhanced\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Eresponse_members_),\n\u002B    ros_response,\n\u002B    dds_response,\n\u002B    size\n\u002B  );\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bserialize_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  const void * ros_response,\n\u002B  void * dds_response,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _serialize_response_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_response),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _serialize_response_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cconst uint8_t *\u003E(ros_response),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_response),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MessageMembersT\u003E\n\u002Bbool\n\u002B_deserialize_service_basic(\n   const void * untyped_members,\n   uint8_t * ros_service,\n   uint8_t * dds_service,\n@@ -433,7 \u002B680,7 @@ _deserialize_service(\n }\n \n inline bool\n-deserialize_service(\n\u002Bdeserialize_service_basic(\n   const void * untyped_members,\n   const char * identifier,\n   void * ros_service,\n@@ -445,7 \u002B692,7 @@ deserialize_service(\n   bool is_request)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _deserialize_service\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n\u002B    return _deserialize_service_basic\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_service),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n@@ -456,7 \u002B703,7 @@ deserialize_service(\n       is_request\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _deserialize_service\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n\u002B    return _deserialize_service_basic\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_service),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n@@ -474,7 \u002B721,7 @@ deserialize_service(\n \n template\u003Ctypename ServiceMembersT\u003E\n bool\n-_deserialize_request(\n\u002B_deserialize_request_basic(\n   const void * untyped_members,\n   uint8_t * ros_request,\n   uint8_t * dds_request,\n@@ -489,7 \u002B736,7 @@ _deserialize_request(\n     return false;\n   }\n \n-  return _deserialize_service\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n\u002B  return _deserialize_service_basic\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n     static_cast\u003Cconst void *\u003E(members-\u003Erequest_members_),\n     ros_request,\n     dds_request,\n@@ -502,7 \u002B749,7 @@ _deserialize_request(\n }\n \n inline bool\n-deserialize_request(\n\u002Bdeserialize_request_basic(\n   const void * untyped_members,\n   const char * identifier,\n   void * ros_request,\n@@ -513,7 \u002B760,7 @@ deserialize_request(\n   int8_t * client_guid)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _deserialize_request\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _deserialize_request_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_request),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n@@ -523,7 \u002B770,7 @@ deserialize_request(\n       client_guid\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _deserialize_request\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _deserialize_request_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_request),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n@@ -540,7 \u002B787,7 @@ deserialize_request(\n \n template\u003Ctypename ServiceMembersT\u003E\n bool\n-_deserialize_response(\n\u002B_deserialize_response_basic(\n   const void * untyped_members,\n   uint8_t * ros_response,\n   uint8_t * dds_response,\n@@ -555,7 \u002B802,7 @@ _deserialize_response(\n     return false;\n   }\n \n-  return _deserialize_service\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n\u002B  return _deserialize_service_basic\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n     static_cast\u003Cconst void *\u003E(members-\u003Eresponse_members_),\n     ros_response,\n     dds_response,\n@@ -568,7 \u002B815,7 @@ _deserialize_response(\n }\n \n inline bool\n-deserialize_response(\n\u002Bdeserialize_response_basic(\n   const void * untyped_members,\n   const char * identifier,\n   void * ros_reponse,\n@@ -579,7 \u002B826,7 @@ deserialize_response(\n   int8_t * client_guid)\n {\n   if (identifier == rosidl_typesupport_introspection_c__identifier) {\n-    return _deserialize_response\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B    return _deserialize_response_basic\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_reponse),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_reponse),\n@@ -589,7 \u002B836,7 @@ deserialize_response(\n       client_guid\n     );\n   } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n-    return _deserialize_response\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B    return _deserialize_response_basic\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n       untyped_members,\n       reinterpret_cast\u003Cuint8_t *\u003E(ros_reponse),\n       reinterpret_cast\u003Cuint8_t *\u003E(dds_reponse),\n@@ -604,4 \u002B851,185 @@ deserialize_response(\n   return false;\n }\n \n\u002Btemplate\u003Ctypename MessageMembersT\u003E\n\u002Bbool\n\u002B_deserialize_service_enhanced(\n\u002B  const void * untyped_members,\n\u002B  uint8_t * ros_service,\n\u002B  uint8_t * dds_service,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members =\n\u002B    static_cast\u003Cconst MessageMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  try {\n\u002B    auto buffer = CDRDeserializationBuffer(dds_service, size);\n\u002B    auto deserializer = MessageDeserializer(buffer);\n\u002B    deserializer.deserialize(members, ros_service, true);\n\u002B  } catch (std::runtime_error \u0026 e) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022Failed to deserialize dds message: %s\u0022, e.what());\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return true;\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bdeserialize_service_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  void * ros_service,\n\u002B  void * dds_service,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _deserialize_service_enhanced\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_service),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _deserialize_service_enhanced\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_service),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_service),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bbool\n\u002B_deserialize_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  uint8_t * ros_request,\n\u002B  uint8_t * dds_request,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return _deserialize_service_enhanced\u003CGET_TYPENAME(members-\u003Erequest_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Erequest_members_),\n\u002B    ros_request,\n\u002B    dds_request,\n\u002B    size\n\u002B  );\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bdeserialize_request_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  void * ros_request,\n\u002B  void * dds_request,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _deserialize_request_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_request),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _deserialize_request_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_request),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_request),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename ServiceMembersT\u003E\n\u002Bbool\n\u002B_deserialize_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  uint8_t * ros_response,\n\u002B  uint8_t * dds_response,\n\u002B  size_t size)\n\u002B{\n\u002B  auto members = static_cast\u003Cconst ServiceMembersT *\u003E(untyped_members);\n\u002B  if (members == nullptr) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Members handle is null\u0022);\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return _deserialize_service_enhanced\u003CGET_TYPENAME(members-\u003Eresponse_members_)\u003E(\n\u002B    static_cast\u003Cconst void *\u003E(members-\u003Eresponse_members_),\n\u002B    ros_response,\n\u002B    dds_response,\n\u002B    size\n\u002B  );\n\u002B}\n\u002B\n\u002Binline bool\n\u002Bdeserialize_response_enhanced(\n\u002B  const void * untyped_members,\n\u002B  const char * identifier,\n\u002B  void * ros_reponse,\n\u002B  void * dds_reponse,\n\u002B  size_t size)\n\u002B{\n\u002B  if (identifier == rosidl_typesupport_introspection_c__identifier) {\n\u002B    return _deserialize_response_enhanced\u003Crosidl_typesupport_introspection_c__ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_reponse),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_reponse),\n\u002B      size\n\u002B    );\n\u002B  } else if (identifier == rosidl_typesupport_introspection_cpp::typesupport_identifier) {\n\u002B    return _deserialize_response_enhanced\u003Crosidl_typesupport_introspection_cpp::ServiceMembers\u003E(\n\u002B      untyped_members,\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(ros_reponse),\n\u002B      reinterpret_cast\u003Cuint8_t *\u003E(dds_reponse),\n\u002B      size\n\u002B    );\n\u002B  }\n\u002B\n\u002B  RMW_SET_ERROR_MSG(\u0022Unknown typesupport identifier\u0022);\n\u002B  return false;\n\u002B}\n\u002B\n\u002Binline void\n\u002Bros_guid_to_dds_guid(int8_t * guid_ros, int8_t * guid_dds)\n\u002B{\n\u002B  memcpy(guid_dds, guid_ros, 12);\n\u002B  memcpy(\u0026guid_dds[12], \u0026guid_ros[12], 4);\n\u002B}\n\u002B\n\u002Binline void\n\u002Bdds_guid_to_ros_guid(int8_t * guid_dds, int8_t * guid_ros)\n\u002B{\n\u002B  memcpy(guid_ros, guid_dds, 12);\n\u002B  memcpy(\u0026guid_ros[12], \u0026guid_dds[12], 4);\n\u002B}\n\u002B\n\u002Binline void\n\u002Bros_sn_to_dds_sn(int64_t sn_ros, uint64_t * sn_dds)\n\u002B{\n\u002B  *sn_dds = ((sn_ros) \u0026 0xFFFFFFFF00000000LL) \u003E\u003E 32;\n\u002B  *sn_dds = *sn_dds | ((sn_ros \u0026 0x00000000FFFFFFFFLL) \u003C\u003C 32);\n\u002B}\n\u002B\n\u002Binline void\n\u002Bdds_sn_to_ros_sn(uint64_t sn_dds, int64_t * sn_ros)\n\u002B{\n\u002B  *sn_ros = ((sn_dds \u0026 0x00000000FFFFFFFF) \u003C\u003C 32) | ((sn_dds \u0026 0xFFFFFFFF00000000) \u003E\u003E 32);\n\u002B}\n #endif  // TYPE_SUPPORT_SERVICE_HPP_\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rosidl_python",
    "SHA": "a43ba5da83977d2e53b1f94368c682673aff8075",
    "RawMessage": "Add smoke test for CLI extension (#132)",
    "Changes": "diff --git rosidl_generator_py/CMakeLists.txt rosidl_generator_py/CMakeLists.txt\nindex 082e5f5..d3dbe50 100644\n--- rosidl_generator_py/CMakeLists.txt\n\u002B\u002B\u002B rosidl_generator_py/CMakeLists.txt\n@@ -73,6 \u002B73,8 @@ if(BUILD_TESTING)\n       WORKING_DIRECTORY \u0022${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py\u0022\n     )\n   endif()\n\u002B\n\u002B  ament_add_pytest_test(test_cli_extension test/test_cli_extension.py)\n endif()\n \n ament_package(\ndiff --git rosidl_generator_py/test/test_cli_extension.py rosidl_generator_py/test/test_cli_extension.py\nnew file mode 100644\nindex 0000000..1fe51b2\n--- /dev/null\n\u002B\u002B\u002B rosidl_generator_py/test/test_cli_extension.py\n@@ -0,0 \u002B1,28 @@\n\u002B# Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport pathlib\n\u002B\n\u002Bfrom rosidl_cli.command.generate.api import generate\n\u002B\n\u002BPACKAGE_DIR = str(pathlib.Path(__file__).parent.parent)\n\u002B\n\u002B\n\u002Bdef test_cli_extension_for_smoke(tmp_path):\n\u002B    generate(\n\u002B        package_name=\u0027rosidl_generator_py\u0027,\n\u002B        interface_files=[PACKAGE_DIR \u002B \u0027:msg/StringArrays.msg\u0027],\n\u002B        types=[\u0027py\u0027],\n\u002B        output_path=tmp_path\n\u002B    )\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "d6bd8baac5bc050ab31e4e7e8ee8b482fd469c14",
    "RawMessage": "Add missing header required by the rclcpp::NodeOptions type (#2324)",
    "Changes": "diff --git rclcpp_components/include/rclcpp_components/node_factory.hpp rclcpp_components/include/rclcpp_components/node_factory.hpp\nindex 67e6cd73..7b1f2dca 100644\n--- rclcpp_components/include/rclcpp_components/node_factory.hpp\n\u002B\u002B\u002B rclcpp_components/include/rclcpp_components/node_factory.hpp\n@@ -15,6 \u002B15,7 @@\n #ifndef RCLCPP_COMPONENTS__NODE_FACTORY_HPP__\n #define RCLCPP_COMPONENTS__NODE_FACTORY_HPP__\n \n\u002B#include \u0022rclcpp/node_options.hpp\u0022\n #include \u0022rclcpp_components/node_instance_wrapper.hpp\u0022\n \n namespace rclcpp_components\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "490f06edd5c0cc7424d485ac9ea85e0a24158b99",
    "RawMessage": "Add content filter topic feature (#513)",
    "Changes": "diff --git rmw_fastrtps_cpp/CMakeLists.txt rmw_fastrtps_cpp/CMakeLists.txt\nindex d34ac97..ea82908 100644\n--- rmw_fastrtps_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_fastrtps_cpp/CMakeLists.txt\n@@ -132,8 \u002B132,8 @@ ament_export_dependencies(rosidl_typesupport_fastrtps_c)\n ament_export_dependencies(rosidl_typesupport_fastrtps_cpp)\n \n register_rmw_implementation(\n-  \u0022c:rosidl_typesupport_c:rosidl_typesupport_fastrtps_c\u0022\n-  \u0022cpp:rosidl_typesupport_cpp:rosidl_typesupport_fastrtps_cpp\u0022)\n\u002B  \u0022c:rosidl_typesupport_c:rosidl_typesupport_fastrtps_c:rosidl_typesupport_introspection_c\u0022\n\u002B  \u0022cpp:rosidl_typesupport_cpp:rosidl_typesupport_fastrtps_cpp:rosidl_typesupport_introspection_cpp\u0022)\n \n if(BUILD_TESTING)\n   find_package(ament_lint_auto REQUIRED)\ndiff --git rmw_fastrtps_cpp/src/publisher.cpp rmw_fastrtps_cpp/src/publisher.cpp\nindex db401b7..6aaeed6 100644\n--- rmw_fastrtps_cpp/src/publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/publisher.cpp\n@@ -199,6 \u002B199,13 @@ rmw_fastrtps_cpp::create_publisher(\n   }\n   info-\u003Etype_support_ = fastdds_type;\n \n\u002B  if (!rmw_fastrtps_shared_cpp::register_type_object(type_supports, type_name)) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022failed to register type object with incompatible type %s\u0022,\n\u002B      type_name.c_str());\n\u002B    return nullptr;\n\u002B  }\n\u002B\n   /////\n   // Create Listener\n   if (create_publisher_listener) {\ndiff --git rmw_fastrtps_cpp/src/rmw_subscription.cpp rmw_fastrtps_cpp/src/rmw_subscription.cpp\nindex 58367e4..c254660 100644\n--- rmw_fastrtps_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_subscription.cpp\n@@ -84,7 \u002B84,8 @@ rmw_create_subscription(\n   }\n \n   auto common_context = static_cast\u003Crmw_dds_common::Context *\u003E(node-\u003Econtext-\u003Eimpl-\u003Ecommon);\n-  auto info = static_cast\u003Cconst CustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B  auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B\n   {\n     // Update graph\n     std::lock_guard\u003Cstd::mutex\u003E guard(common_context-\u003Enode_update_mutex);\n@@ -112,6 \u002B113,9 @@ rmw_create_subscription(\n       return nullptr;\n     }\n   }\n\u002B  info-\u003Enode_ = node;\n\u002B  info-\u003Ecommon_context_ = common_context;\n\u002B\n   return subscription;\n }\n \n@@ -148,6 \u002B152,43 @@ rmw_subscription_get_actual_qos(\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_get_actual_qos(subscription, qos);\n }\n \n\u002Brmw_ret_t\n\u002Brmw_subscription_set_content_filter(\n\u002B  rmw_subscription_t * subscription,\n\u002B  const rmw_subscription_content_filter_options_t * options)\n\u002B{\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(options, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_subscription_set_content_filter(\n\u002B    subscription, options);\n\u002B  auto info = static_cast\u003Cconst CustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B  subscription-\u003Eis_cft_enabled = (info \u0026\u0026 info-\u003Efiltered_topic_);\n\u002B  return ret;\n\u002B}\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_subscription_get_content_filter(\n\u002B  const rmw_subscription_t * subscription,\n\u002B  rcutils_allocator_t * allocator,\n\u002B  rmw_subscription_content_filter_options_t * options)\n\u002B{\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(allocator, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(options, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  return rmw_fastrtps_shared_cpp::__rmw_subscription_get_content_filter(\n\u002B    subscription, allocator, options);\n\u002B}\n\u002B\n rmw_ret_t\n rmw_destroy_subscription(rmw_node_t * node, rmw_subscription_t * subscription)\n {\ndiff --git rmw_fastrtps_cpp/src/subscription.cpp rmw_fastrtps_cpp/src/subscription.cpp\nindex c5b5fcb..b1f723c 100644\n--- rmw_fastrtps_cpp/src/subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/subscription.cpp\n@@ -197,6 \u002B197,13 @@ create_subscription(\n   }\n   info-\u003Etype_support_ = fastdds_type;\n \n\u002B  if (!rmw_fastrtps_shared_cpp::register_type_object(type_supports, type_name)) {\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022failed to register type object with incompatible type %s\u0022,\n\u002B      type_name.c_str());\n\u002B    return nullptr;\n\u002B  }\n\u002B\n   /////\n   // Create Listener\n   if (create_subscription_listener) {\n@@ -224,8 \u002B231,30 @@ create_subscription(\n     return nullptr;\n   }\n \n\u002B  info-\u003Edds_participant_ = dds_participant;\n\u002B  info-\u003Esubscriber_ = subscriber;\n\u002B  info-\u003Etopic_name_mangled_ = topic_name_mangled;\n\u002B  info-\u003Etopic_ = topic.desc;\n   des_topic = topic.desc;\n \n\u002B  // Create ContentFilteredTopic\n\u002B  if (subscription_options-\u003Econtent_filter_options) {\n\u002B    rmw_subscription_content_filter_options_t * options =\n\u002B      subscription_options-\u003Econtent_filter_options;\n\u002B    if (nullptr != options-\u003Efilter_expression) {\n\u002B      eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = nullptr;\n\u002B      if (!rmw_fastrtps_shared_cpp::create_content_filtered_topic(\n\u002B          dds_participant, des_topic,\n\u002B          topic_name_mangled, options, \u0026filtered_topic))\n\u002B      {\n\u002B        RMW_SET_ERROR_MSG(\u0022create_contentfilteredtopic() failed to create contentfilteredtopic\u0022);\n\u002B        return nullptr;\n\u002B      }\n\u002B      info-\u003Efiltered_topic_ = filtered_topic;\n\u002B      des_topic = filtered_topic;\n\u002B    }\n\u002B  }\n\u002B\n   /////\n   // Create DataReader\n \n@@ -251,44 \u002B280,18 @@ create_subscription(\n     return nullptr;\n   }\n \n-  eprosima::fastdds::dds::DataReaderQos original_qos = reader_qos;\n-  switch (subscription_options-\u003Erequire_unique_network_flow_endpoints) {\n-    default:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED:\n-      // Unique network flow endpoints not required. We leave the decission to the XML profile.\n-      break;\n-\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED:\n-    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED:\n-      // Ensure we request unique network flow endpoints\n-      if (nullptr ==\n-        PropertyPolicyHelper::find_property(\n-          reader_qos.properties(),\n-          \u0022fastdds.unique_network_flows\u0022))\n-      {\n-        reader_qos.properties().properties().emplace_back(\u0022fastdds.unique_network_flows\u0022, \u0022\u0022);\n-      }\n-      break;\n-  }\n\u002B  info-\u003Edatareader_qos_ = reader_qos;\n \n-  // Creates DataReader (with subscriber name to not change name policy)\n-  info-\u003Edata_reader_ = subscriber-\u003Ecreate_datareader(\n-    des_topic,\n-    reader_qos,\n-    info-\u003Elistener_);\n-  if (!info-\u003Edata_reader_ \u0026\u0026\n-    (RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED ==\n-    subscription_options-\u003Erequire_unique_network_flow_endpoints))\n-  {\n-    info-\u003Edata_reader_ = subscriber-\u003Ecreate_datareader(\n\u002B  // create_datareader\n\u002B  if (!rmw_fastrtps_shared_cpp::create_datareader(\n\u002B      info-\u003Edatareader_qos_,\n\u002B      subscription_options,\n\u002B      subscriber,\n       des_topic,\n-      original_qos,\n-      info-\u003Elistener_);\n-  }\n-\n-  if (!info-\u003Edata_reader_) {\n-    RMW_SET_ERROR_MSG(\u0022create_subscription() could not create data reader\u0022);\n\u002B      info-\u003Elistener_,\n\u002B      \u0026info-\u003Edata_reader_))\n\u002B  {\n\u002B    RMW_SET_ERROR_MSG(\u0022create_datareader() could not create data reader\u0022);\n     return nullptr;\n   }\n \n@@ -327,6 \u002B330,7 @@ create_subscription(\n   }\n   rmw_subscription-\u003Eoptions = *subscription_options;\n   rmw_fastrtps_shared_cpp::__init_subscription_for_loans(rmw_subscription);\n\u002B  rmw_subscription-\u003Eis_cft_enabled = info-\u003Efiltered_topic_ != nullptr;\n \n   topic.should_be_deleted = false;\n   cleanup_rmw_subscription.cancel();\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\nindex 9903756..d3059c4 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n@@ -87,7 \u002B87,7 @@ rmw_create_subscription(\n   }\n \n   auto common_context = static_cast\u003Crmw_dds_common::Context *\u003E(node-\u003Econtext-\u003Eimpl-\u003Ecommon);\n-  auto info = static_cast\u003Cconst CustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B  auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n   {\n     // Update graph\n     std::lock_guard\u003Cstd::mutex\u003E guard(common_context-\u003Enode_update_mutex);\n@@ -115,6 \u002B115,9 @@ rmw_create_subscription(\n       return nullptr;\n     }\n   }\n\u002B  info-\u003Enode_ = node;\n\u002B  info-\u003Ecommon_context_ = common_context;\n\u002B\n   return subscription;\n }\n \n@@ -151,6 \u002B154,32 @@ rmw_subscription_get_actual_qos(\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_get_actual_qos(subscription, qos);\n }\n \n\u002Brmw_ret_t\n\u002Brmw_subscription_set_content_filter(\n\u002B  rmw_subscription_t * subscription,\n\u002B  const rmw_subscription_content_filter_options_t * options)\n\u002B{\n\u002B  // Unused in current implementation.\n\u002B  (void) subscription;\n\u002B  (void) options;\n\u002B  RMW_SET_ERROR_MSG(\u0022unimplemented\u0022);\n\u002B  return RMW_RET_UNSUPPORTED;\n\u002B}\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_subscription_get_content_filter(\n\u002B  const rmw_subscription_t * subscription,\n\u002B  rcutils_allocator_t * allocator,\n\u002B  rmw_subscription_content_filter_options_t * options)\n\u002B{\n\u002B  // Unused in current implementation.\n\u002B  (void) subscription;\n\u002B  (void) allocator;\n\u002B  (void) options;\n\u002B  RMW_SET_ERROR_MSG(\u0022unimplemented\u0022);\n\u002B  return RMW_RET_UNSUPPORTED;\n\u002B}\n\u002B\n using BaseTypeSupport = rmw_fastrtps_dynamic_cpp::BaseTypeSupport;\n \n rmw_ret_t\ndiff --git rmw_fastrtps_dynamic_cpp/src/subscription.cpp rmw_fastrtps_dynamic_cpp/src/subscription.cpp\nindex 2f91134..2637097 100644\n--- rmw_fastrtps_dynamic_cpp/src/subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/subscription.cpp\n@@ -348,6 \u002B348,8 @@ create_subscription(\n \n   rmw_subscription-\u003Eoptions = *subscription_options;\n   rmw_fastrtps_shared_cpp::__init_subscription_for_loans(rmw_subscription);\n\u002B  // TODO(iuhilnehc-ynos): update after rmw_fastrtps_cpp is confirmed\n\u002B  rmw_subscription-\u003Eis_cft_enabled = false;\n \n   topic.should_be_deleted = false;\n   cleanup_rmw_subscription.cancel();\ndiff --git rmw_fastrtps_shared_cpp/CMakeLists.txt rmw_fastrtps_shared_cpp/CMakeLists.txt\nindex fbf7656..a7e1965 100644\n--- rmw_fastrtps_shared_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/CMakeLists.txt\n@@ -38,6 \u002B38,8 @@ find_package(ament_cmake_ros REQUIRED)\n find_package(rcpputils REQUIRED)\n find_package(rcutils REQUIRED)\n find_package(rmw_dds_common REQUIRED)\n\u002Bfind_package(rosidl_typesupport_introspection_c REQUIRED)\n\u002Bfind_package(rosidl_typesupport_introspection_cpp REQUIRED)\n \n find_package(fastrtps_cmake_module REQUIRED)\n find_package(fastcdr REQUIRED CONFIG)\n@@ -105,6 \u002B107,8 @@ ament_target_dependencies(rmw_fastrtps_shared_cpp\n   \u0022rcutils\u0022\n   \u0022rmw\u0022\n   \u0022rmw_dds_common\u0022\n\u002B  \u0022rosidl_typesupport_introspection_c\u0022\n\u002B  \u0022rosidl_typesupport_introspection_cpp\u0022\n )\n \n # Causes the visibility macros to use dllexport rather than dllimport,\n@@ -124,6 \u002B128,8 @@ ament_export_dependencies(rcpputils)\n ament_export_dependencies(rcutils)\n ament_export_dependencies(rmw)\n ament_export_dependencies(rmw_dds_common)\n\u002Bament_export_dependencies(rosidl_typesupport_introspection_c)\n\u002Bament_export_dependencies(rosidl_typesupport_introspection_cpp)\n \n if(BUILD_TESTING)\n   find_package(ament_lint_auto REQUIRED)\ndiff --git rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/TypeSupport.hpp rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/TypeSupport.hpp\nindex 72c905a..0a23d19 100644\n--- rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/TypeSupport.hpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/TypeSupport.hpp\n@@ -28,6 \u002B28,8 @@\n \n #include \u0022rcutils/logging_macros.h\u0022\n \n\u002B#include \u0022rosidl_runtime_c/message_type_support_struct.h\u0022\n\u002B\n #include \u0022./visibility_control.h\u0022\n \n namespace rmw_fastrtps_shared_cpp\n@@ -106,6 \u002B108,11 @@ protected:\n   bool is_plain_;\n };\n \n\u002BRMW_FASTRTPS_SHARED_CPP_PUBLIC\n\u002Bbool register_type_object(\n\u002B  const rosidl_message_type_support_t * type_supports,\n\u002B  const std::string \u0026 type_name);\n\u002B\n }  // namespace rmw_fastrtps_shared_cpp\n \n #endif  // RMW_FASTRTPS_SHARED_CPP__TYPESUPPORT_HPP_\ndiff --git rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp\nindex 9ffe65f..a130f2c 100644\n--- rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp\n@@ -22,6 \u002B22,7 @@\n #include \u003Cmemory\u003E\n #include \u003Cmutex\u003E\n #include \u003Cset\u003E\n\u002B#include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n #include \u0022fastdds/dds/core/status/DeadlineMissedStatus.hpp\u0022\n@@ -29,6 \u002B30,8 @@\n #include \u0022fastdds/dds/core/status/SubscriptionMatchedStatus.hpp\u0022\n #include \u0022fastdds/dds/subscriber/DataReader.hpp\u0022\n #include \u0022fastdds/dds/subscriber/DataReaderListener.hpp\u0022\n\u002B#include \u0022fastdds/dds/subscriber/qos/DataReaderQos.hpp\u0022\n\u002B#include \u0022fastdds/dds/topic/ContentFilteredTopic.hpp\u0022\n #include \u0022fastdds/dds/topic/TypeSupport.hpp\u0022\n \n #include \u0022fastdds/rtps/common/Guid.h\u0022\n@@ -39,6 \u002B42,8 @@\n #include \u0022rmw/impl/cpp/macros.hpp\u0022\n #include \u0022rmw/event_callback_type.h\u0022\n \n\u002B#include \u0022rmw_dds_common/context.hpp\u0022\n\u002B\n #include \u0022rmw_fastrtps_shared_cpp/custom_event_info.hpp\u0022\n \n \n@@ -61,6 \u002B66,16 @@ struct CustomSubscriberInfo : public CustomEventInfo\n   const char * typesupport_identifier_{nullptr};\n   std::shared_ptr\u003Crmw_fastrtps_shared_cpp::LoanManager\u003E loan_manager_;\n \n\u002B  // for re-create or delete content filtered topic\n\u002B  const rmw_node_t * node_ {nullptr};\n\u002B  rmw_dds_common::Context * common_context_ {nullptr};\n\u002B  eprosima::fastdds::dds::DomainParticipant * dds_participant_ {nullptr};\n\u002B  eprosima::fastdds::dds::Subscriber * subscriber_ {nullptr};\n\u002B  std::string topic_name_mangled_;\n\u002B  eprosima::fastdds::dds::TopicDescription * topic_ {nullptr};\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic_ {nullptr};\n\u002B  eprosima::fastdds::dds::DataReaderQos datareader_qos_;\n\u002B\n   RMW_FASTRTPS_SHARED_CPP_PUBLIC\n   EventListenerInterface *\n   getListener() const final;\ndiff --git rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/rmw_common.hpp rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/rmw_common.hpp\nindex 0bc82c7..ede5410 100644\n--- rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/rmw_common.hpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/rmw_common.hpp\n@@ -304,7 \u002B304,8 @@ rmw_ret_t\n __rmw_destroy_subscription(\r\n   const char * identifier,\r\n   const rmw_node_t * node,\r\n-  rmw_subscription_t * subscription);\r\n\u002B  rmw_subscription_t * subscription,\r\n\u002B  bool reset_cft = false);\r\n \r\n RMW_FASTRTPS_SHARED_CPP_PUBLIC\r\n rmw_ret_t\r\n@@ -318,6 \u002B319,19 @@ __rmw_subscription_get_actual_qos(\n   const rmw_subscription_t * subscription,\r\n   rmw_qos_profile_t * qos);\r\n \r\n\u002BRMW_FASTRTPS_SHARED_CPP_PUBLIC\r\n\u002Brmw_ret_t\r\n\u002B__rmw_subscription_set_content_filter(\r\n\u002B  rmw_subscription_t * subscription,\r\n\u002B  const rmw_subscription_content_filter_options_t * options);\r\n\u002B\r\n\u002BRMW_FASTRTPS_SHARED_CPP_PUBLIC\r\n\u002Brmw_ret_t\r\n\u002B__rmw_subscription_get_content_filter(\r\n\u002B  const rmw_subscription_t * subscription,\r\n\u002B  rcutils_allocator_t * allocator,\r\n\u002B  rmw_subscription_content_filter_options_t * options);\r\n\u002B\r\n RMW_FASTRTPS_SHARED_CPP_PUBLIC\r\n rmw_ret_t\r\n __rmw_service_response_publisher_get_actual_qos(\r\ndiff --git rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/subscription.hpp rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/subscription.hpp\nindex 1a3394b..ddd2f07 100644\n--- rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/subscription.hpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/subscription.hpp\n@@ -32,7 \u002B32,8 @@ rmw_ret_t\n destroy_subscription(\n   const char * identifier,\n   CustomParticipantInfo * participant_info,\n-  rmw_subscription_t * subscription);\n\u002B  rmw_subscription_t * subscription,\n\u002B  bool reset_cft = false);\n \n }  // namespace rmw_fastrtps_shared_cpp\n \ndiff --git rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/utils.hpp rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/utils.hpp\nindex 8b6910e..88b8e18 100644\n--- rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/utils.hpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/include/rmw_fastrtps_shared_cpp/utils.hpp\n@@ -24,6 \u002B24,7 @@\n #include \u0022fastrtps/types/TypesBase.h\u0022\n \n #include \u0022rmw_fastrtps_shared_cpp/custom_participant_info.hpp\u0022\n\u002B#include \u0022rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/TypeSupport.hpp\u0022\n \n #include \u0022rmw/rmw.h\u0022\n@@ -137,6 \u002B138,52 @@ remove_topic_and_type(\n   const eprosima::fastdds::dds::TopicDescription * topic,\n   const eprosima::fastdds::dds::TypeSupport \u0026 type);\n \n\u002B/**\n\u002B* Create content filtered topic.\n\u002B*\n\u002B* \\param[in]  participant             DomainParticipant where the topic will be created.\n\u002B* \\param[in]  topic_desc              TopicDescription returned by find_and_check_topic_and_type.\n\u002B* \\param[in]  topic_name_mangled      Mangled Name of the topic.\n\u002B* \\param[in]  options                 Options of the content filtered topic.\n\u002B* \\param[out] content_filtered_topic  Will hold the pointer to the content filtered topic along\n\u002B                                      with the necessary information for its deletion.\n\u002B*\n\u002B* \\return true when the content filtered topic was created\n\u002B* \\return false when the content filtered topic could not be created\n\u002B*/\n\u002BRMW_FASTRTPS_SHARED_CPP_PUBLIC\n\u002Bbool\n\u002Bcreate_content_filtered_topic(\n\u002B  eprosima::fastdds::dds::DomainParticipant * participant,\n\u002B  eprosima::fastdds::dds::TopicDescription * topic_desc,\n\u002B  const std::string \u0026 topic_name_mangled,\n\u002B  const rmw_subscription_content_filter_options_t * options,\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic ** content_filtered_topic);\n\u002B\n\u002B\n\u002B/**\n\u002B* Create data reader.\n\u002B*\n\u002B* \\param[in]  datareader_qos         QoS of data reader.\n\u002B* \\param[in]  subscription_options   Options of the subscription.\n\u002B* \\param[in]  subscriber             A subsciber to create the data reader.\n\u002B* \\param[in]  des_topic              TopicDescription returned by find_and_check_topic_and_type.\n\u002B* \\param[in]  listener               The listener of the data reader.\n\u002B* \\param[out] data_reader            Will hold the pointer to the data reader.\n\u002B*\n\u002B* \\return true when the data reader was created\n\u002B* \\return false when the data reader could not be created\n\u002B*/\n\u002BRMW_FASTRTPS_SHARED_CPP_PUBLIC\n\u002Bbool\n\u002Bcreate_datareader(\n\u002B  const eprosima::fastdds::dds::DataReaderQos \u0026 datareader_qos,\n\u002B  const rmw_subscription_options_t * subscription_options,\n\u002B  eprosima::fastdds::dds::Subscriber * subscriber,\n\u002B  eprosima::fastdds::dds::TopicDescription * des_topic,\n\u002B  SubListener * listener,\n\u002B  eprosima::fastdds::dds::DataReader ** data_reader);\n\u002B\n }  // namespace rmw_fastrtps_shared_cpp\n \n #endif  // RMW_FASTRTPS_SHARED_CPP__UTILS_HPP_\ndiff --git rmw_fastrtps_shared_cpp/package.xml rmw_fastrtps_shared_cpp/package.xml\nindex df653a0..cff628d 100644\n--- rmw_fastrtps_shared_cpp/package.xml\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/package.xml\n@@ -22,6 \u002B22,8 @@\n   \u003Cbuild_depend\u003Ercutils\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Ermw\u003C/build_depend\u003E\n   \u003Cbuild_depend\u003Ermw_dds_common\u003C/build_depend\u003E\n\u002B  \u003Cbuild_depend\u003Erosidl_typesupport_introspection_c\u003C/build_depend\u003E\n\u002B  \u003Cbuild_depend\u003Erosidl_typesupport_introspection_cpp\u003C/build_depend\u003E\n \n   \u003Cbuild_export_depend\u003Efastcdr\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Efastrtps\u003C/build_export_depend\u003E\n@@ -30,6 \u002B32,8 @@\n   \u003Cbuild_export_depend\u003Ercutils\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Ermw\u003C/build_export_depend\u003E\n   \u003Cbuild_export_depend\u003Ermw_dds_common\u003C/build_export_depend\u003E\n\u002B  \u003Cbuild_export_depend\u003Erosidl_typesupport_introspection_c\u003C/build_export_depend\u003E\n\u002B  \u003Cbuild_export_depend\u003Erosidl_typesupport_introspection_cpp\u003C/build_export_depend\u003E\n \n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\ndiff --git rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\nindex 79d756b..87eb46d 100644\n--- rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/TypeSupport_impl.cpp\n@@ -13,7 \u002B13,9 @@\n // limitations under the License.\n \n #include \u003Ccassert\u003E\n\u002B#include \u003Csstream\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n #include \u003Cvector\u003E\n \n #include \u0022fastdds/rtps/common/SerializedPayload.h\u0022\n@@ -21,7 \u002B23,21 @@\n #include \u0022fastcdr/FastBuffer.h\u0022\n #include \u0022fastcdr/Cdr.h\u0022\n \n\u002B#include \u0022fastrtps/rtps/common/SerializedPayload.h\u0022\n\u002B#include \u0022fastrtps/utils/md5.h\u0022\n\u002B#include \u0022fastrtps/types/TypesBase.h\u0022\n\u002B#include \u0022fastrtps/types/TypeObjectFactory.h\u0022\n\u002B#include \u0022fastrtps/types/TypeNamesGenerator.h\u0022\n\u002B#include \u0022fastrtps/types/AnnotationParameterValue.h\u0022\n\u002B\n #include \u0022rmw_fastrtps_shared_cpp/TypeSupport.hpp\u0022\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B\n\u002B#include \u0022rosidl_typesupport_introspection_c/identifier.h\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/identifier.hpp\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_c/message_introspection.h\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/message_introspection.hpp\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/field_types.hpp\u0022\n \n namespace rmw_fastrtps_shared_cpp\n {\n@@ -31,6 \u002B47,8 @@ TypeSupport::TypeSupport()\n   m_isGetKeyDefined = false;\n   max_size_bound_ = false;\n   is_plain_ = false;\n\u002B  auto_fill_type_object(false);\n\u002B  auto_fill_type_information(false);\n }\n \n void TypeSupport::deleteData(void * data)\n@@ -123,4 \u002B141,450 @@ std::function\u003Cuint32_t()\u003E TypeSupport::getSerializedSizeProvider(void * data)\n   return ser_size;\n }\n \n\u002B// TODO(iuhilnehc-ynos): add the following content into new files named TypeObject?\n\u002Busing CompleteStructType = eprosima::fastrtps::types::CompleteStructType;\n\u002Busing CompleteStructMember = eprosima::fastrtps::types::CompleteStructMember;\n\u002Busing MinimalStructType = eprosima::fastrtps::types::MinimalStructType;\n\u002Busing MinimalStructMember = eprosima::fastrtps::types::MinimalStructMember;\n\u002Busing SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;\n\u002Busing TypeNamesGenerator = eprosima::fastrtps::types::TypeNamesGenerator;\n\u002Busing TypeIdentifier = eprosima::fastrtps::types::TypeIdentifier;\n\u002Busing TypeObject = eprosima::fastrtps::types::TypeObject;\n\u002Busing TypeObjectFactory = eprosima::fastrtps::types::TypeObjectFactory;\n\u002B\n\u002Bconst rosidl_message_type_support_t *\n\u002Bget_type_support_introspection(\n\u002B  const rosidl_message_type_support_t * type_supports)\n\u002B{\n\u002B  const rosidl_message_type_support_t * type_support =\n\u002B    get_message_typesupport_handle(\n\u002B    type_supports, rosidl_typesupport_introspection_c__identifier);\n\u002B  if (nullptr == type_support) {\n\u002B    rcutils_error_string_t prev_error_string = rcutils_get_error_string();\n\u002B    rcutils_reset_error();\n\u002B\n\u002B    type_support =\n\u002B      get_message_typesupport_handle(\n\u002B      type_supports,\n\u002B      rosidl_typesupport_introspection_cpp::typesupport_identifier);\n\u002B    if (nullptr == type_support) {\n\u002B      rcutils_error_string_t error_string = rcutils_get_error_string();\n\u002B      rcutils_reset_error();\n\u002B      RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B        \u0022Type support not from this implementation. Got:\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022    %s\\n\u0022\n\u002B        \u0022while fetching it\u0022,\n\u002B        prev_error_string.str, error_string.str);\n\u002B      return nullptr;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return type_support;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Binline std::string\n\u002B_create_type_name(\n\u002B  const MembersType * members)\n\u002B{\n\u002B  if (!members) {\n\u002B    return std::string();\n\u002B  }\n\u002B\n\u002B  std::ostringstream ss;\n\u002B  std::string message_namespace(members-\u003Emessage_namespace_);\n\u002B  std::string message_name(members-\u003Emessage_name_);\n\u002B  if (!message_namespace.empty()) {\n\u002B    ss \u003C\u003C message_namespace \u003C\u003C \u0022::\u0022;\n\u002B  }\n\u002B  ss \u003C\u003C \u0022dds_::\u0022 \u003C\u003C message_name \u003C\u003C \u0022_\u0022;\n\u002B  return ss.str();\n\u002B}\n\u002B\n\u002Btypedef std::pair\u003Cconst TypeIdentifier *, std::string\u003E MemberIdentifierName;\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002BMemberIdentifierName GetTypeIdentifier(const MembersType * member, uint32_t index, bool complete);\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Bconst TypeObject * GetCompleteObject(\n\u002B  const std::string \u0026 type_name,\n\u002B  const MembersType * members)\n\u002B{\n\u002B  const TypeObject * c_type_object =\n\u002B    TypeObjectFactory::get_instance()-\u003Eget_type_object(type_name, true);\n\u002B  if (c_type_object != nullptr \u0026\u0026 c_type_object-\u003E_d() == eprosima::fastrtps::types::EK_COMPLETE) {\n\u002B    return c_type_object;\n\u002B  }\n\u002B\n\u002B  TypeObject * type_object = new TypeObject();\n\u002B\n\u002B  type_object-\u003E_d(eprosima::fastrtps::types::EK_COMPLETE);\n\u002B  type_object-\u003Ecomplete()._d(eprosima::fastrtps::types::TK_STRUCTURE);\n\u002B  type_object-\u003Ecomplete().struct_type().struct_flags().IS_FINAL(false);\n\u002B  type_object-\u003Ecomplete().struct_type().struct_flags().IS_APPENDABLE(false);\n\u002B  type_object-\u003Ecomplete().struct_type().struct_flags().IS_MUTABLE(false);\n\u002B  // Not sure whether current type is nested or not, make all Type Nested\n\u002B  type_object-\u003Ecomplete().struct_type().struct_flags().IS_NESTED(true);\n\u002B  type_object-\u003Ecomplete().struct_type().struct_flags().IS_AUTOID_HASH(false);  // Unsupported\n\u002B\n\u002B  for (uint32_t i = 0; i \u003C members-\u003Emember_count_; \u002B\u002Bi) {\n\u002B    CompleteStructMember cst_field;\n\u002B    cst_field.common().member_id(i);\n\u002B    cst_field.common().member_flags().TRY_CONSTRUCT1(false);  // Unsupported\n\u002B    cst_field.common().member_flags().TRY_CONSTRUCT2(false);  // Unsupported\n\u002B    cst_field.common().member_flags().IS_EXTERNAL(false);  // Unsupported\n\u002B    cst_field.common().member_flags().IS_OPTIONAL(false);\n\u002B    cst_field.common().member_flags().IS_MUST_UNDERSTAND(false);\n\u002B    cst_field.common().member_flags().IS_KEY(false);\n\u002B    cst_field.common().member_flags().IS_DEFAULT(false);  // Doesn\u0027t apply\n\u002B\n\u002B    MemberIdentifierName pair = GetTypeIdentifier(members, i, true);\n\u002B    if (!pair.first) {\n\u002B      continue;\n\u002B    }\n\u002B    cst_field.common().member_type_id(*pair.first);\n\u002B    cst_field.detail().name(pair.second);\n\u002B    type_object-\u003Ecomplete().struct_type().member_seq().emplace_back(cst_field);\n\u002B  }\n\u002B\n\u002B  // Header\n\u002B  type_object-\u003Ecomplete().struct_type().header().detail().type_name(type_name);\n\u002B\n\u002B  TypeIdentifier identifier;\n\u002B  identifier._d(eprosima::fastrtps::types::EK_COMPLETE);\n\u002B\n\u002B  SerializedPayload_t payload(static_cast\u003Cuint32_t\u003E(\n\u002B      CompleteStructType::getCdrSerializedSize(type_object-\u003Ecomplete().struct_type()) \u002B 4));\n\u002B\n\u002B  eprosima::fastcdr::FastBuffer fastbuffer(\n\u002B    reinterpret_cast\u003Cchar *\u003E(payload.data), payload.max_size);\n\u002B\n\u002B  // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for\n\u002B  // DDS document)\n\u002B  eprosima::fastcdr::Cdr ser(\n\u002B    fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n\u002B    eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.\n\u002B  payload.encapsulation = CDR_LE;\n\u002B\n\u002B  type_object-\u003Eserialize(ser);\n\u002B  payload.length =\n\u002B    static_cast\u003Cuint32_t\u003E(ser.getSerializedDataLength());  // Get the serialized length\n\u002B  MD5 objectHash;\n\u002B  objectHash.update(reinterpret_cast\u003Cchar *\u003E(payload.data), payload.length);\n\u002B  objectHash.finalize();\n\u002B  for (int i = 0; i \u003C 14; \u002B\u002Bi) {\n\u002B    identifier.equivalence_hash()[i] = objectHash.digest[i];\n\u002B  }\n\u002B\n\u002B  TypeObjectFactory::get_instance()-\u003Eadd_type_object(type_name, \u0026identifier, type_object);\n\u002B  delete type_object;\n\u002B\n\u002B  return TypeObjectFactory::get_instance()-\u003Eget_type_object(type_name, true);\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Bconst TypeObject * GetMinimalObject(\n\u002B  const std::string \u0026 type_name,\n\u002B  const MembersType * members)\n\u002B{\n\u002B  const TypeObject * c_type_object =\n\u002B    TypeObjectFactory::get_instance()-\u003Eget_type_object(type_name, false);\n\u002B  if (c_type_object != nullptr) {\n\u002B    return c_type_object;\n\u002B  }\n\u002B\n\u002B  TypeObject * type_object = new TypeObject();\n\u002B  type_object-\u003E_d(eprosima::fastrtps::types::EK_MINIMAL);\n\u002B  type_object-\u003Eminimal()._d(eprosima::fastrtps::types::TK_STRUCTURE);\n\u002B  type_object-\u003Eminimal().struct_type().struct_flags().IS_FINAL(false);\n\u002B  type_object-\u003Eminimal().struct_type().struct_flags().IS_APPENDABLE(false);\n\u002B  type_object-\u003Eminimal().struct_type().struct_flags().IS_MUTABLE(false);\n\u002B  type_object-\u003Eminimal().struct_type().struct_flags().IS_NESTED(true);\n\u002B  type_object-\u003Eminimal().struct_type().struct_flags().IS_AUTOID_HASH(false);  // Unsupported\n\u002B\n\u002B  for (uint32_t i = 0; i \u003C members-\u003Emember_count_; \u002B\u002Bi) {\n\u002B    MinimalStructMember mst_field;\n\u002B    mst_field.common().member_id(i);\n\u002B    mst_field.common().member_flags().TRY_CONSTRUCT1(false);  // Unsupported\n\u002B    mst_field.common().member_flags().TRY_CONSTRUCT2(false);  // Unsupported\n\u002B    mst_field.common().member_flags().IS_EXTERNAL(false);  // Unsupported\n\u002B    mst_field.common().member_flags().IS_OPTIONAL(false);\n\u002B    mst_field.common().member_flags().IS_MUST_UNDERSTAND(false);\n\u002B    mst_field.common().member_flags().IS_KEY(false);\n\u002B    mst_field.common().member_flags().IS_DEFAULT(false);  // Doesn\u0027t apply\n\u002B\n\u002B    MemberIdentifierName pair = GetTypeIdentifier(members, i, false);\n\u002B    if (!pair.first) {\n\u002B      continue;\n\u002B    }\n\u002B    mst_field.common().member_type_id(*pair.first);\n\u002B    MD5 field_hash(pair.second);\n\u002B    for (int i = 0; i \u003C 4; \u002B\u002Bi) {\n\u002B      mst_field.detail().name_hash()[i] = field_hash.digest[i];\n\u002B    }\n\u002B    type_object-\u003Eminimal().struct_type().member_seq().emplace_back(mst_field);\n\u002B  }\n\u002B\n\u002B  TypeIdentifier identifier;\n\u002B  identifier._d(eprosima::fastrtps::types::EK_MINIMAL);\n\u002B\n\u002B  SerializedPayload_t payload(\n\u002B    static_cast\u003Cuint32_t\u003E(\n\u002B      MinimalStructType::getCdrSerializedSize(type_object-\u003Eminimal().struct_type()) \u002B 4));\n\u002B\n\u002B  eprosima::fastcdr::FastBuffer fastbuffer(\n\u002B    reinterpret_cast\u003Cchar *\u003E(payload.data), payload.max_size);\n\u002B\n\u002B  // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for\n\u002B  // DDS document)\n\u002B  eprosima::fastcdr::Cdr ser(\n\u002B    fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,\n\u002B    eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.\n\u002B  payload.encapsulation = CDR_LE;\n\u002B\n\u002B  type_object-\u003Eserialize(ser);\n\u002B  payload.length =\n\u002B    static_cast\u003Cuint32_t\u003E(ser.getSerializedDataLength());  // Get the serialized length\n\u002B  MD5 objectHash;\n\u002B  objectHash.update(reinterpret_cast\u003Cchar *\u003E(payload.data), payload.length);\n\u002B  objectHash.finalize();\n\u002B  for (int i = 0; i \u003C 14; \u002B\u002Bi) {\n\u002B    identifier.equivalence_hash()[i] = objectHash.digest[i];\n\u002B  }\n\u002B\n\u002B  TypeObjectFactory::get_instance()-\u003Eadd_type_object(type_name, \u0026identifier, type_object);\n\u002B  delete type_object;\n\u002B  return TypeObjectFactory::get_instance()-\u003Eget_type_object(type_name, false);\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002BMemberIdentifierName GetTypeIdentifier(const MembersType * members, uint32_t index, bool complete)\n\u002B{\n\u002B  const auto member = members-\u003Emembers_ \u002B index;\n\u002B  const TypeIdentifier * type_identifier = nullptr;\n\u002B  std::string name = member-\u003Ename_;\n\u002B\n\u002B  std::string type_name;\n\u002B  bool complete_type = false;\n\u002B  switch (member-\u003Etype_id_) {\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_FLOAT:\n\u002B      {\n\u002B        type_name = \u0022float\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_DOUBLE:\n\u002B      {\n\u002B        type_name = \u0022double\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_LONG_DOUBLE:\n\u002B      {\n\u002B        type_name = \u0022longdouble\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_CHAR:\n\u002B      {\n\u002B        type_name = \u0022char\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WCHAR:\n\u002B      {\n\u002B        type_name = \u0022wchar\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_BOOLEAN:\n\u002B      {\n\u002B        type_name = \u0022bool\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_OCTET:\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT8:\n\u002B      {\n\u002B        type_name = \u0022uint8_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT8:\n\u002B      {\n\u002B        type_name = \u0022int8_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT16:\n\u002B      {\n\u002B        type_name = \u0022uint16_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT16:\n\u002B      {\n\u002B        type_name = \u0022int16_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT32:\n\u002B      {\n\u002B        type_name = \u0022uint32_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT32:\n\u002B      {\n\u002B        type_name = \u0022int32_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_UINT64:\n\u002B      {\n\u002B        type_name = \u0022uint64_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_INT64:\n\u002B      {\n\u002B        type_name = \u0022int64_t\u0022;\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING:\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_WSTRING:\n\u002B      {\n\u002B        uint32_t bound = member-\u003Estring_upper_bound_ ? member-\u003Estring_upper_bound_ : 255;\n\u002B        bool wide =\n\u002B          (member-\u003Etype_id_ == ::rosidl_typesupport_introspection_cpp::ROS_TYPE_STRING) ?\n\u002B          false : true;\n\u002B        TypeObjectFactory::get_instance()-\u003Eget_string_identifier(bound, wide);\n\u002B        type_name = TypeNamesGenerator::get_string_type_name(\n\u002B          bound, wide);\n\u002B        break;\n\u002B      }\n\u002B    case ::rosidl_typesupport_introspection_cpp::ROS_TYPE_MESSAGE:\n\u002B      {\n\u002B        const rosidl_message_type_support_t * type_support_intro =\n\u002B          get_type_support_introspection(member-\u003Emembers_);\n\u002B        const MembersType * sub_members =\n\u002B          static_cast\u003Cconst MembersType *\u003E(type_support_intro-\u003Edata);\n\u002B        std::string sub_type_name = _create_type_name(sub_members);\n\u002B        if (complete) {\n\u002B          GetCompleteObject(sub_type_name, sub_members);\n\u002B        } else {\n\u002B          GetMinimalObject(sub_type_name, sub_members);\n\u002B        }\n\u002B        type_name = sub_type_name;\n\u002B        complete_type = complete;\n\u002B      }\n\u002B      break;\n\u002B    default:\n\u002B      break;\n\u002B  }\n\u002B\n\u002B  if (!type_name.empty()) {\n\u002B    if (!member-\u003Eis_array_) {\n\u002B      type_identifier = TypeObjectFactory::get_instance()-\u003Eget_type_identifier(\n\u002B        type_name, complete_type);\n\u002B    } else if (member-\u003Earray_size_ \u0026\u0026 !member-\u003Eis_upper_bound_) {\n\u002B      type_identifier = TypeObjectFactory::get_instance()-\u003Eget_array_identifier(\n\u002B        type_name, {static_cast\u003Cuint32_t\u003E(member-\u003Earray_size_)}, complete_type);\n\u002B    } else {\n\u002B      type_identifier = TypeObjectFactory::get_instance()-\u003Eget_sequence_identifier(\n\u002B        type_name, 0, complete_type);\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return {type_identifier, name};\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Bconst TypeObject * GetTypeObject(\n\u002B  const std::string \u0026 type_name, bool complete,\n\u002B  const MembersType * members)\n\u002B{\n\u002B  const TypeObject * c_type_object =\n\u002B    TypeObjectFactory::get_instance()-\u003Eget_type_object(type_name, complete);\n\u002B  if (c_type_object != nullptr) {\n\u002B    return c_type_object;\n\u002B  } else if (complete) {\n\u002B    return GetCompleteObject(type_name, members);\n\u002B  }\n\u002B  // else\n\u002B  return GetMinimalObject(type_name, members);\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Bconst TypeIdentifier * GetTypeIdentifier(\n\u002B  const std::string \u0026 type_name, bool complete,\n\u002B  const MembersType * members)\n\u002B{\n\u002B  const TypeIdentifier * c_identifier =\n\u002B    TypeObjectFactory::get_instance()-\u003Eget_type_identifier(type_name, complete);\n\u002B  if (c_identifier != nullptr \u0026\u0026\n\u002B    (!complete || c_identifier-\u003E_d() == eprosima::fastrtps::types::EK_COMPLETE))\n\u002B  {\n\u002B    return c_identifier;\n\u002B  }\n\u002B\n\u002B  GetTypeObject(type_name, complete, members);  // Generated inside\n\u002B  return TypeObjectFactory::get_instance()-\u003Eget_type_identifier(type_name, complete);\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename MembersType\u003E\n\u002Binline bool\n\u002Badd_type_object(\n\u002B  const void * untype_members,\n\u002B  const std::string \u0026 type_name)\n\u002B{\n\u002B  const MembersType * members = static_cast\u003Cconst MembersType *\u003E(untype_members);\n\u002B  if (!members) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  TypeObjectFactory * factory = TypeObjectFactory::get_instance();\n\u002B  if (!factory) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  const TypeIdentifier * identifier = nullptr;\n\u002B  const TypeObject * type_object = nullptr;\n\u002B  identifier = GetTypeIdentifier(type_name, true, members);\n\u002B  if (!identifier) {\n\u002B    return false;\n\u002B  }\n\u002B  type_object = GetTypeObject(type_name, true, members);\n\u002B  if (!type_object) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  factory-\u003Eadd_type_object(type_name, identifier, type_object);\n\u002B\n\u002B  identifier = GetTypeIdentifier(type_name, false, members);\n\u002B  if (!identifier) {\n\u002B    return false;\n\u002B  }\n\u002B  type_object = GetTypeObject(type_name, false, members);\n\u002B  if (!type_object) {\n\u002B    return false;\n\u002B  }\n\u002B  factory-\u003Eadd_type_object(type_name, identifier, type_object);\n\u002B\n\u002B  return true;\n\u002B}\n\u002B\n\u002Bbool register_type_object(\n\u002B  const rosidl_message_type_support_t * type_supports,\n\u002B  const std::string \u0026 type_name)\n\u002B{\n\u002B  const rosidl_message_type_support_t * type_support_intro =\n\u002B    get_type_support_introspection(type_supports);\n\u002B  if (!type_support_intro) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  bool ret = false;\n\u002B  if (type_support_intro-\u003Etypesupport_identifier ==\n\u002B    rosidl_typesupport_introspection_c__identifier)\n\u002B  {\n\u002B    ret = add_type_object\u003Crosidl_typesupport_introspection_c__MessageMembers\u003E(\n\u002B      type_support_intro-\u003Edata, type_name);\n\u002B  } else {\n\u002B    ret = add_type_object\u003Crosidl_typesupport_introspection_cpp::MessageMembers\u003E(\n\u002B      type_support_intro-\u003Edata, type_name);\n\u002B  }\n\u002B\n\u002B  return ret;\n\u002B}\n\u002B\n }  // namespace rmw_fastrtps_shared_cpp\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\nindex b89f753..a521b1a 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n@@ -20,6 \u002B20,8 @@\n #include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/rmw.h\u0022\n \n\u002B#include \u0022rcpputils/scope_exit.hpp\u0022\n\u002B\n #include \u0022fastdds/dds/subscriber/DataReader.hpp\u0022\n #include \u0022fastdds/dds/subscriber/qos/DataReaderQos.hpp\u0022\n \n@@ -30,6 \u002B32,7 @@\n #include \u0022rmw_fastrtps_shared_cpp/rmw_common.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/rmw_context_impl.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/subscription.hpp\u0022\n\u002B#include \u0022rmw_fastrtps_shared_cpp/utils.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/TypeSupport.hpp\u0022\n \n namespace rmw_fastrtps_shared_cpp\n@@ -38,7 \u002B41,8 @@ rmw_ret_t\n __rmw_destroy_subscription(\n   const char * identifier,\n   const rmw_node_t * node,\n-  rmw_subscription_t * subscription)\n\u002B  rmw_subscription_t * subscription,\n\u002B  bool reset_cft)\n {\n   assert(node-\u003Eimplementation_identifier == identifier);\n   assert(subscription-\u003Eimplementation_identifier == identifier);\n@@ -68,7 \u002B72,7 @@ __rmw_destroy_subscription(\n \n   auto participant_info =\n     static_cast\u003CCustomParticipantInfo *\u003E(node-\u003Econtext-\u003Eimpl-\u003Eparticipant_info);\n-  rmw_ret_t local_ret = destroy_subscription(identifier, participant_info, subscription);\n\u002B  rmw_ret_t local_ret = destroy_subscription(identifier, participant_info, subscription, reset_cft);\n   if (RMW_RET_OK != local_ret) {\n     if (RMW_RET_OK != ret) {\n       RMW_SAFE_FWRITE_TO_STDERR(error_string.str);\n@@ -107,6 \u002B111,155 @@ __rmw_subscription_get_actual_qos(\n   return RMW_RET_OK;\n }\n \n\u002Brmw_ret_t\n\u002B__rmw_subscription_set_content_filter(\n\u002B  rmw_subscription_t * subscription,\n\u002B  const rmw_subscription_content_filter_options_t * options\n\u002B)\n\u002B{\n\u002B  auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = info-\u003Efiltered_topic_;\n\u002B  const bool filter_expression_empty = (*options-\u003Efilter_expression == \u0027\\0\u0027);\n\u002B\n\u002B  if (!filtered_topic \u0026\u0026 filter_expression_empty) {\n\u002B    // can\u0027t reset current subscriber\n\u002B    RMW_SET_ERROR_MSG(\n\u002B      \u0022current subscriber has no content filter topic\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  } else if (filtered_topic \u0026\u0026 !filter_expression_empty) {\n\u002B    std::vector\u003Cstd::string\u003E expression_parameters;\n\u002B    for (size_t i = 0; i \u003C options-\u003Eexpression_parameters.size; \u002B\u002Bi) {\n\u002B      expression_parameters.push_back(options-\u003Eexpression_parameters.data[i]);\n\u002B    }\n\u002B\n\u002B    ReturnCode_t ret =\n\u002B      filtered_topic-\u003Eset_filter_expression(options-\u003Efilter_expression, expression_parameters);\n\u002B    if (ret != ReturnCode_t::RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\n\u002B        \u0022failed to set_filter_expression\u0022);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B    return RMW_RET_OK;\n\u002B  }\n\u002B\n\u002B  eprosima::fastdds::dds::DomainParticipant * dds_participant =\n\u002B    info-\u003Edds_participant_;\n\u002B  eprosima::fastdds::dds::TopicDescription * des_topic = nullptr;\n\u002B  const char * eprosima_fastrtps_identifier = subscription-\u003Eimplementation_identifier;\n\u002B\n\u002B  rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_destroy_subscription(\n\u002B    eprosima_fastrtps_identifier,\n\u002B    info-\u003Enode_,\n\u002B    subscription,\n\u002B    true /* reset_cft */);\n\u002B  if (ret != RMW_RET_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022delete subscription with reset cft\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  if (!filtered_topic) {\n\u002B    // create content filtered topic\n\u002B    eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = nullptr;\n\u002B    if (!rmw_fastrtps_shared_cpp::create_content_filtered_topic(\n\u002B        dds_participant, info-\u003Etopic_,\n\u002B        info-\u003Etopic_name_mangled_, options, \u0026filtered_topic))\n\u002B    {\n\u002B      RMW_SET_ERROR_MSG(\u0022create_contentfilteredtopic() failed to create contentfilteredtopic\u0022);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B    info-\u003Efiltered_topic_ = filtered_topic;\n\u002B    des_topic = filtered_topic;\n\u002B  } else {\n\u002B    // use the existing parent topic\n\u002B    des_topic = info-\u003Etopic_;\n\u002B  }\n\u002B\n\u002B  // create data reader\n\u002B  eprosima::fastdds::dds::Subscriber * subscriber = info-\u003Esubscriber_;\n\u002B  const rmw_subscription_options_t * subscription_options =\n\u002B    \u0026subscription-\u003Eoptions;\n\u002B  if (!rmw_fastrtps_shared_cpp::create_datareader(\n\u002B      info-\u003Edatareader_qos_,\n\u002B      subscription_options,\n\u002B      subscriber,\n\u002B      des_topic,\n\u002B      info-\u003Elistener_,\n\u002B      \u0026info-\u003Edata_reader_))\n\u002B  {\n\u002B    RMW_SET_ERROR_MSG(\u0022create_datareader() could not create data reader\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B  // lambda to delete datareader\n\u002B  auto cleanup_datareader = rcpputils::make_scope_exit(\n\u002B    [subscriber, info]() {\n\u002B      subscriber-\u003Edelete_datareader(info-\u003Edata_reader_);\n\u002B    });\n\u002B\n\u002B  /////\n\u002B  // Update RMW GID\n\u002B  info-\u003Esubscription_gid_ = rmw_fastrtps_shared_cpp::create_rmw_gid(\n\u002B    eprosima_fastrtps_identifier, info-\u003Edata_reader_-\u003Eguid());\n\u002B\n\u002B  {\n\u002B    rmw_dds_common::Context * common_context = info-\u003Ecommon_context_;\n\u002B    const rmw_node_t * node = info-\u003Enode_;\n\u002B\n\u002B    // Update graph\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(common_context-\u003Enode_update_mutex);\n\u002B    rmw_dds_common::msg::ParticipantEntitiesInfo msg =\n\u002B      common_context-\u003Egraph_cache.associate_reader(\n\u002B      info-\u003Esubscription_gid_, common_context-\u003Egid, node-\u003Ename, node-\u003Enamespace_);\n\u002B    rmw_ret_t rmw_ret = rmw_fastrtps_shared_cpp::__rmw_publish(\n\u002B      eprosima_fastrtps_identifier,\n\u002B      common_context-\u003Epub,\n\u002B      static_cast\u003Cvoid *\u003E(\u0026msg),\n\u002B      nullptr);\n\u002B    if (RMW_RET_OK != rmw_ret) {\n\u002B      static_cast\u003Cvoid\u003E(common_context-\u003Egraph_cache.dissociate_writer(\n\u002B        info-\u003Esubscription_gid_, common_context-\u003Egid, node-\u003Ename, node-\u003Enamespace_));\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B  }\n\u002B  cleanup_datareader.cancel();\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n\u002Brmw_ret_t\n\u002B__rmw_subscription_get_content_filter(\n\u002B  const rmw_subscription_t * subscription,\n\u002B  rcutils_allocator_t * allocator,\n\u002B  rmw_subscription_content_filter_options_t * options\n\u002B)\n\u002B{\n\u002B  auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic = info-\u003Efiltered_topic_;\n\u002B\n\u002B  if (nullptr == filtered_topic) {\n\u002B    RMW_SET_ERROR_MSG(\u0022this subscriber has not created a ContentFilteredTopic\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B  std::vector\u003Cstd::string\u003E expression_parameters;\n\u002B  ReturnCode_t ret = filtered_topic-\u003Eget_expression_parameters(expression_parameters);\n\u002B  if (ret != ReturnCode_t::RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\n\u002B      \u0022failed to get_expression_parameters\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  std::vector\u003Cconst char *\u003E string_array;\n\u002B  for (size_t i = 0; i \u003C expression_parameters.size(); \u002B\u002Bi) {\n\u002B    string_array.push_back(expression_parameters[i].c_str());\n\u002B  }\n\u002B\n\u002B  return rmw_subscription_content_filter_options_init(\n\u002B    filtered_topic-\u003Eget_filter_expression().c_str(),\n\u002B    string_array.size(),\n\u002B    string_array.data(),\n\u002B    allocator,\n\u002B    options\n\u002B  );\n\u002B}\n\u002B\n rmw_ret_t\n __rmw_subscription_set_on_new_message_callback(\n   rmw_subscription_t * rmw_subscription,\ndiff --git rmw_fastrtps_shared_cpp/src/subscription.cpp rmw_fastrtps_shared_cpp/src/subscription.cpp\nindex cd0cddd..bfb6254 100644\n--- rmw_fastrtps_shared_cpp/src/subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/subscription.cpp\n@@ -34,7 \u002B34,8 @@ rmw_ret_t\n destroy_subscription(\n   const char * identifier,\n   CustomParticipantInfo * participant_info,\n-  rmw_subscription_t * subscription)\n\u002B  rmw_subscription_t * subscription,\n\u002B  bool reset_cft)\n {\n   assert(subscription-\u003Eimplementation_identifier == identifier);\n   static_cast\u003Cvoid\u003E(identifier);\n@@ -45,9 \u002B46,6 @@ destroy_subscription(\n     // Get RMW Subscriber\n     auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n \n-    // Keep pointer to topic, so we can remove it later\n-    auto topic = info-\u003Edata_reader_-\u003Eget_topicdescription();\n-\n     // Delete DataReader\n     ReturnCode_t ret = participant_info-\u003Esubscriber_-\u003Edelete_datareader(info-\u003Edata_reader_);\n     if (ReturnCode_t::RETCODE_OK != ret) {\n@@ -57,11 \u002B55,21 @@ destroy_subscription(\n       return RMW_RET_ERROR;\n     }\n \n\u002B    // Delete ContentFilteredTopic\n\u002B    if (nullptr != info-\u003Efiltered_topic_) {\n\u002B      participant_info-\u003Eparticipant_-\u003Edelete_contentfilteredtopic(info-\u003Efiltered_topic_);\n\u002B      info-\u003Efiltered_topic_ = nullptr;\n\u002B    }\n\u002B\n\u002B    if (reset_cft) {\n\u002B      return RMW_RET_OK;\n\u002B    }\n\u002B\n     // Delete DataReader listener\n     delete info-\u003Elistener_;\n \n     // Delete topic and unregister type\n-    remove_topic_and_type(participant_info, topic, info-\u003Etype_support_);\n\u002B    remove_topic_and_type(participant_info, info-\u003Etopic_, info-\u003Etype_support_);\n \n     // Delete CustomSubscriberInfo structure\n     delete info;\ndiff --git rmw_fastrtps_shared_cpp/src/utils.cpp rmw_fastrtps_shared_cpp/src/utils.cpp\nindex ce541c2..f652abe 100644\n--- rmw_fastrtps_shared_cpp/src/utils.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/utils.cpp\n@@ -26,6 \u002B26,8 @@\n \n using ReturnCode_t = eprosima::fastrtps::types::ReturnCode_t;\n \n\u002Bconst char * const CONTENT_FILTERED_TOPIC_POSTFIX = \u0022_filtered_name\u0022;\n\u002B\n namespace rmw_fastrtps_shared_cpp\n {\n \n@@ -118,6 \u002B120,7 @@ remove_topic_and_type(\n   // change in the future if we start supporting other kinds of TopicDescription\n   // (like ContentFilteredTopic)\n   auto topic = dynamic_cast\u003Cconst eprosima::fastdds::dds::Topic *\u003E(topic_desc);\n\u002B\n   if (nullptr != topic) {\n     participant_info-\u003Eparticipant_-\u003Edelete_topic(topic);\n   }\n@@ -127,4 \u002B130,83 @@ remove_topic_and_type(\n   }\n }\n \n\u002Bbool\n\u002Bcreate_content_filtered_topic(\n\u002B  eprosima::fastdds::dds::DomainParticipant * participant,\n\u002B  eprosima::fastdds::dds::TopicDescription * topic_desc,\n\u002B  const std::string \u0026 topic_name_mangled,\n\u002B  const rmw_subscription_content_filter_options_t * options,\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic ** content_filtered_topic)\n\u002B{\n\u002B  std::vector\u003Cstd::string\u003E expression_parameters;\n\u002B  for (size_t i = 0; i \u003C options-\u003Eexpression_parameters.size; \u002B\u002Bi) {\n\u002B    expression_parameters.push_back(options-\u003Eexpression_parameters.data[i]);\n\u002B  }\n\u002B\n\u002B  auto topic = dynamic_cast\u003Ceprosima::fastdds::dds::Topic *\u003E(topic_desc);\n\u002B  std::string cft_topic_name = topic_name_mangled \u002B CONTENT_FILTERED_TOPIC_POSTFIX;\n\u002B  eprosima::fastdds::dds::ContentFilteredTopic * filtered_topic =\n\u002B    participant-\u003Ecreate_contentfilteredtopic(\n\u002B    cft_topic_name,\n\u002B    topic,\n\u002B    options-\u003Efilter_expression,\n\u002B    expression_parameters);\n\u002B  if (filtered_topic == nullptr) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  *content_filtered_topic = filtered_topic;\n\u002B  return true;\n\u002B}\n\u002B\n\u002Bbool\n\u002Bcreate_datareader(\n\u002B  const eprosima::fastdds::dds::DataReaderQos \u0026 datareader_qos,\n\u002B  const rmw_subscription_options_t * subscription_options,\n\u002B  eprosima::fastdds::dds::Subscriber * subscriber,\n\u002B  eprosima::fastdds::dds::TopicDescription * des_topic,\n\u002B  SubListener * listener,\n\u002B  eprosima::fastdds::dds::DataReader ** data_reader\n\u002B)\n\u002B{\n\u002B  eprosima::fastdds::dds::DataReaderQos updated_qos = datareader_qos;\n\u002B  switch (subscription_options-\u003Erequire_unique_network_flow_endpoints) {\n\u002B    default:\n\u002B    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT:\n\u002B    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED:\n\u002B      // Unique network flow endpoints not required. We leave the decission to the XML profile.\n\u002B      break;\n\u002B\n\u002B    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED:\n\u002B    case RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED:\n\u002B      // Ensure we request unique network flow endpoints\n\u002B      using PropertyPolicyHelper = eprosima::fastrtps::rtps::PropertyPolicyHelper;\n\u002B      if (nullptr ==\n\u002B        PropertyPolicyHelper::find_property(\n\u002B          updated_qos.properties(),\n\u002B          \u0022fastdds.unique_network_flows\u0022))\n\u002B      {\n\u002B        updated_qos.properties().properties().emplace_back(\u0022fastdds.unique_network_flows\u0022, \u0022\u0022);\n\u002B      }\n\u002B      break;\n\u002B  }\n\u002B\n\u002B  // Creates DataReader (with subscriber name to not change name policy)\n\u002B  *data_reader = subscriber-\u003Ecreate_datareader(\n\u002B    des_topic,\n\u002B    updated_qos,\n\u002B    listener);\n\u002B  if (!data_reader \u0026\u0026\n\u002B    (RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED ==\n\u002B    subscription_options-\u003Erequire_unique_network_flow_endpoints))\n\u002B  {\n\u002B    *data_reader = subscriber-\u003Ecreate_datareader(\n\u002B      des_topic,\n\u002B      datareader_qos,\n\u002B      listener);\n\u002B  }\n\u002B  return true;\n\u002B}\n\u002B\n\u002B\n }  // namespace rmw_fastrtps_shared_cpp\n",
    "IsBackported": false
  }
]