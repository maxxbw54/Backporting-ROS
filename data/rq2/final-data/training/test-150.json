[
  {
    "Repository": "rviz",
    "SHA": "3f6108cbf071956bd57d8df946df97bb4bbd2203",
    "RawMessage": "TimePanel port (#599)",
    "Changes": "diff --git README.md README.md\nindex c88b6ab8..c15414ed 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -17,9 \u002B17,9 @@ For some displays, the [documentation is updated](docs/FEATURES.md).\n | Axes                  | Move Camera   | Orbit                 | Displays        |\n | Camera                | Focus Camera  | XY Orbit              | Help            | \n | Fluid Pressure        | Measure       | First Person          | Selections      |\n-| Grid                  | Select        | Third Person Follower | Tool Properties | \n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Views           |\n-| Illuminance           | Publish Point |\n\u002B| Grid                  | Select        | Third Person Follower | Time            |\n\u002B| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n\u002B| Illuminance           | Publish Point |                       | Views           |\n | Image                 | Initial Pose  |\n | Interactive Marker    | Interact      |\n | Laser Scan            |\n@@ -44,9 \u002B44,9 @@ For some displays, the [documentation is updated](docs/FEATURES.md).\n ### Not yet ported\n These features have not been ported to \u0060ros2/rviz\u0060 yet.\n \n-| Displays      | Panels |\n-| ------------- | ------ |\n-| DepthCloud    | Time   |\n\u002B| Displays      |\n\u002B| ------------- |\n\u002B| DepthCloud    |\n | Effort        |\n \n Other features:\ndiff --git rviz_common/CMakeLists.txt rviz_common/CMakeLists.txt\nindex c67d6829..9235a2ad 100644\n--- rviz_common/CMakeLists.txt\n\u002B\u002B\u002B rviz_common/CMakeLists.txt\n@@ -113,6 \u002B113,7 @@ set(rviz_common_headers_to_moc\n   include/rviz_common/interaction/selection_manager.hpp\n   include/rviz_common/interaction/selection_manager_iface.hpp\n   src/rviz_common/splash_screen.hpp\n\u002B  src/rviz_common/time_panel.hpp\n   include/rviz_common/tool.hpp\n   src/rviz_common/tool_manager.hpp\n   src/rviz_common/tool_properties_panel.hpp\n@@ -199,6 \u002B200,7 @@ set(rviz_common_source_files\n   src/rviz_common/interaction/selection_renderer.cpp\n   src/rviz_common/interaction/view_picker.cpp\n   src/rviz_common/splash_screen.cpp\n\u002B  src/rviz_common/time_panel.cpp\n   src/rviz_common/transformation/identity_frame_transformer.cpp\n   src/rviz_common/tool_manager.cpp\n   src/rviz_common/tool_properties_panel.cpp\ndiff --git rviz_common/default.rviz rviz_common/default.rviz\nindex 2a3a24c4..58518ea8 100644\n--- rviz_common/default.rviz\n\u002B\u002B\u002B rviz_common/default.rviz\n@@ -22,11 \u002B22,11 @@ Panels:\n       - /Current View1\n     Name: Views\n     Splitter Ratio: 0.5\n-  # TODO(wjwwood): restore these panels when ported\n-  # - Class: rviz/Time\n-  #   Name: Time\n-  #   SyncMode: 0\n-  #   SyncSource: \u0022\u0022\n\u002B  - Class: rviz_common/Time\n\u002B    Experimental: false\n\u002B    Name: Time\n\u002B    SyncMode: 0\n\u002B    SyncSource: \u0022\u0022\n Visualization Manager:\n   Class: \u0022\u0022\n   Displays:\ndiff --git rviz_common/icons/classes/Time.png rviz_common/icons/classes/Time.png\nnew file mode 100644\nindex 00000000..9431c2d4\nBinary files /dev/null and rviz_common/icons/classes/Time.png differ\ndiff --git rviz_common/src/rviz_common/panel_factory.cpp rviz_common/src/rviz_common/panel_factory.cpp\nindex 98c5c64f..5c4841da 100644\n--- rviz_common/src/rviz_common/panel_factory.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/panel_factory.cpp\n@@ -33,11 \u002B33,10 @@\n \n #include \u003Cstring\u003E\n \n-// TODO(wjwwood): reenable the remaining panels\n #include \u0022./displays_panel.hpp\u0022\n #include \u0022./help_panel.hpp\u0022\n #include \u0022./selection_panel.hpp\u0022\n-// #include \u0022./time_panel.hpp\u0022\n\u002B#include \u0022./time_panel.hpp\u0022\n #include \u0022./tool_properties_panel.hpp\u0022\n #include \u0022./transformation_panel.hpp\u0022\n #include \u0022./views_panel.hpp\u0022\n@@ -49,7 \u002B48,6 @@ namespace rviz_common\n \n static Panel * newHelpPanel() {return new HelpPanel();}\n static Panel * newSelectionPanel() {return new SelectionPanel();}\n-// static Panel * newTimePanel() {return new TimePanel();}\n static Panel * newToolPropertiesPanel() {return new ToolPropertiesPanel();}\n static Panel * newTransformationPanel() {return new TransformationPanel();}\n static Panel * newViewsPanel() {return new ViewsPanel();}\n@@ -71,8 \u002B69,12 @@ PanelFactory::PanelFactory(\n   addBuiltInClass(\n     \u0022rviz_common\u0022, \u0022Selection\u0022,\n     \u0022Show properties of selected objects\u0022, \u0026newSelectionPanel);\n-  // addBuiltInClass(\u0022rviz\u0022, \u0022Time\u0022,\n-  //   \u0022Show the current time\u0022, \u0026newTimePanel);\n\u002B  addBuiltInClass(\n\u002B    \u0022rviz_common\u0022, \u0022Time\u0022,\n\u002B    \u0022Show the current time\u0022,\n\u002B    [manager]() -\u003E Panel * {\n\u002B      return new TimePanel(manager, nullptr);\n\u002B    });\n   addBuiltInClass(\n     \u0022rviz_common\u0022, \u0022Tool Properties\u0022,\n     \u0022Show and edit properties of tools\u0022, \u0026newToolPropertiesPanel);\ndiff --git rviz_common/src/rviz_common/time_panel.cpp rviz_common/src/rviz_common/time_panel.cpp\nindex 5e827da3..a9eaa972 100644\n--- rviz_common/src/rviz_common/time_panel.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/time_panel.cpp\n@@ -39,15 \u002B39,15 @@\n #include \u0022./visualization_manager.hpp\u0022\n #include \u0022frame_manager.hpp\u0022\n \n-#include \u0022include/rviz_common/display_group.hpp\u0022\n\u002B#include \u0022rviz_common/display_group.hpp\u0022\n \n #include \u0022./time_panel.hpp\u0022\n \n-namespace rviz\n\u002Bnamespace rviz_common\n {\n \n-TimePanel::TimePanel(QWidget * parent)\n-: Panel(parent)\n\u002BTimePanel::TimePanel(VisualizationManager * manager, QWidget * parent)\n\u002B: Panel(parent), vis_manager_(manager)\n {\n   wall_time_label_ = makeTimeLabel();\n   wall_elapsed_label_ = makeTimeLabel();\n@@ -121,6 \u002B121,7 @@ void TimePanel::onInitialize()\n   DisplayGroup * display_group = vis_manager_-\u003EgetRootDisplayGroup();\n   onDisplayAdded(display_group);\n \n\u002B  experimentalToggled(false);\n   syncModeSelected(0);\n   pauseToggled(false);\n }\n@@ -153,20 \u002B154,20 @@ void TimePanel::onDisplayAdded(Display * display)\n   DisplayGroup * display_group = qobject_cast\u003CDisplayGroup *\u003E(display);\n   if (display_group) {\n     connect(\n-      display_group, SIGNAL(displayAdded(rviz::Display*)), this,\n-      SLOT(onDisplayAdded(rviz::Display*)));\n\u002B      display_group, \u0026DisplayGroup::displayAdded,\n\u002B      this, \u0026TimePanel::onDisplayAdded);\n     connect(\n-      display_group, SIGNAL(displayRemoved(rviz::Display*)), this,\n-      SLOT(onDisplayRemoved(rviz::Display*)));\n\u002B      display_group, \u0026DisplayGroup::displayRemoved,\n\u002B      this, \u0026TimePanel::onDisplayRemoved);\n \n     for (int i = 0; i \u003C display_group-\u003EnumDisplays(); i\u002B\u002B) {\n-      rviz::Display * display = display_group-\u003EgetDisplayAt(i);\n\u002B      rviz_common::Display * display = display_group-\u003EgetDisplayAt(i);\n       onDisplayAdded(display);\n     }\n   } else {\n     // *INDENT-OFF* - uncrustify cannot deal with commas here\n-    connect(display, SIGNAL(timeSignal(rviz::Display *, ros::Time)), this,\n-      SLOT(onTimeSignal(rviz::Display *, ros::Time)));\n\u002B    connect(display, SIGNAL(timeSignal(rviz_common::Display *, rclcpp::Time)), this,\n\u002B      SLOT(onTimeSignal(rviz_common::Display *, rclcpp::Time)));\n     // *INDENT-ON*\n   }\n }\n@@ -180,7 \u002B181,7 @@ void TimePanel::onDisplayRemoved(Display * display)\n   }\n }\n \n-void TimePanel::onTimeSignal(Display * display, ros::Time time)\n\u002Bvoid TimePanel::onTimeSignal(Display * display, rclcpp::Time time)\n {\n   QString name = display-\u003EgetName();\n   int index = sync_source_selector_-\u003EfindData(QVariant( (qulonglong)display) );\n@@ -246,6 \u002B247,8 @@ void TimePanel::experimentalToggled(bool checked)\n \n void TimePanel::syncSourceSelected(int index)\n {\n\u002B  Q_UNUSED(index);\n\u002B\n   // clear whatever was loaded from the config\n   config_sync_source_.clear();\n   vis_manager_-\u003EnotifyConfigChanged();\n@@ -253,9 \u002B256,9 @@ void TimePanel::syncSourceSelected(int index)\n \n void TimePanel::syncModeSelected(int mode)\n {\n-  vis_manager_-\u003EgetFrameManager()-\u003EsetSyncMode( (FrameManager::SyncMode)mode);\n\u002B  vis_manager_-\u003EgetFrameManager()-\u003EsetSyncMode(FrameManager::SyncMode(mode) );\n   sync_source_selector_-\u003EsetEnabled(mode != FrameManager::SyncOff);\n   vis_manager_-\u003EnotifyConfigChanged();\n }\n \n-}  // namespace rviz\n\u002B}  // namespace rviz_common\ndiff --git rviz_common/src/rviz_common/time_panel.hpp rviz_common/src/rviz_common/time_panel.hpp\nindex c929f50a..403aa469 100644\n--- rviz_common/src/rviz_common/time_panel.hpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/time_panel.hpp\n@@ -30,8 \u002B30,8 @@\n #ifndef RVIZ_COMMON__TIME_PANEL_HPP_\n #define RVIZ_COMMON__TIME_PANEL_HPP_\n \n-#include \u0022rviz_rendering/panel.hpp\u0022\n-#include \u0022ros/time.h\u0022\n\u002B#include \u0022rviz_common/panel.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n \n class QLineEdit;\n class QComboBox;\n@@ -40,7 \u002B40,7 @@ class QPushButton;\n class QHBoxLayout;\n class QWidget;\n \n-namespace rviz\n\u002Bnamespace rviz_common\n {\n \n class VisualizationManager;\n@@ -55,7 \u002B55,9 @@ class TimePanel : public Panel\n   Q_OBJECT\n \n public:\n-  explicit TimePanel(QWidget * parent = 0);\n\u002B  explicit TimePanel(\n\u002B    VisualizationManager * manager,\n\u002B    QWidget * parent = nullptr);\n \n   virtual void onInitialize();\n \n@@ -68,10 \u002B70,10 @@ protected Q_SLOTS:\n   /** Read time values from VisualizationManager and update displays. */\n   void update();\n \n-  void onDisplayAdded(rviz::Display * display);\n-  void onDisplayRemoved(rviz::Display * display);\n\u002B  void onDisplayAdded(rviz_common::Display * display);\n\u002B  void onDisplayRemoved(rviz_common::Display * display);\n \n-  void onTimeSignal(rviz::Display * display, ros::Time time);\n\u002B  void onTimeSignal(rviz_common::Display * display, rclcpp::Time time);\n \n   virtual void load(const Config \u0026 config);\n   virtual void save(Config config) const;\n@@ -98,8 \u002B100,10 @@ protected:\n   QLineEdit * ros_elapsed_label_;\n   QLineEdit * wall_time_label_;\n   QLineEdit * wall_elapsed_label_;\n\u002B\n\u002B  VisualizationManager * vis_manager_;\n };\n \n-}  // namespace rviz\n\u002B}  // namespace rviz_common\n \n #endif  // RVIZ_COMMON__TIME_PANEL_HPP_\ndiff --git rviz_common/src/rviz_common/visualization_manager.cpp rviz_common/src/rviz_common/visualization_manager.cpp\nindex c29049dc..7caf08c8 100644\n--- rviz_common/src/rviz_common/visualization_manager.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/visualization_manager.cpp\n@@ -606,10 \u002B606,7 @@ double VisualizationManager::getWallClockElapsed()\n \n double VisualizationManager::getROSTimeElapsed()\n {\n-  // TODO(wjwwood): why does this function return now - begin, whereas the getWallClockElapsed\n-  //                returns a pre-calculated elapsed value?\n-  //                figure out how this function is being used and make these consistent\n-  return (frame_manager_-\u003EgetTime() - ros_time_begin_).nanoseconds() / 1e9;\n\u002B  return static_cast\u003Cdouble\u003E(ros_time_elapsed_) / 1e9;\n }\n \n void VisualizationManager::updateBackgroundColor()\ndiff --git rviz_default_plugins/icons/classes/Time.svg rviz_default_plugins/icons/classes/Time.svg\ndeleted file mode 100644\nindex afd2603c..00000000\n--- rviz_default_plugins/icons/classes/Time.svg\n\u002B\u002B\u002B /dev/null\n@@ -1,400 \u002B0,0 @@\n-\u003C?xml version=\u00221.0\u0022 encoding=\u0022UTF-8\u0022 standalone=\u0022no\u0022?\u003E\n-\u003C!-- Created with Inkscape (http://www.inkscape.org/) --\u003E\n-\n-\u003Csvg\n-   xmlns:dc=\u0022http://purl.org/dc/elements/1.1/\u0022\n-   xmlns:cc=\u0022http://creativecommons.org/ns#\u0022\n-   xmlns:rdf=\u0022http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0022\n-   xmlns:svg=\u0022http://www.w3.org/2000/svg\u0022\n-   xmlns=\u0022http://www.w3.org/2000/svg\u0022\n-   xmlns:xlink=\u0022http://www.w3.org/1999/xlink\u0022\n-   xmlns:sodipodi=\u0022http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\u0022\n-   xmlns:inkscape=\u0022http://www.inkscape.org/namespaces/inkscape\u0022\n-   width=\u002216px\u0022\n-   height=\u002216px\u0022\n-   id=\u0022svg3851\u0022\n-   version=\u00221.1\u0022\n-   inkscape:version=\u00220.48.3.1 r9886\u0022\n-   sodipodi:docname=\u0022Time.svg\u0022\n-   inkscape:export-filename=\u0022/work/gossow/rviz/rviz/icons/visibility.png\u0022\n-   inkscape:export-xdpi=\u002290\u0022\n-   inkscape:export-ydpi=\u002290\u0022\u003E\n-  \u003Cdefs\n-     id=\u0022defs3853\u0022\u003E\n-    \u003Cinkscape:perspective\n-       sodipodi:type=\u0022inkscape:persp3d\u0022\n-       inkscape:vp_x=\u0022-1.0827572 : -0.75044646 : 1\u0022\n-       inkscape:vp_y=\u00220 : 1000 : 0\u0022\n-       inkscape:vp_z=\u002295.903066 : 6.0333593 : 1\u0022\n-       inkscape:persp3d-origin=\u00228 : 5.3333333 : 1\u0022\n-       id=\u0022perspective3847\u0022 /\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient3837\u0022\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#808080;stop-opacity:1;\u0022\n-         offset=\u00220\u0022\n-         id=\u0022stop3839\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#e9e9e9;stop-opacity:1;\u0022\n-         offset=\u00221\u0022\n-         id=\u0022stop3841\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient3841\u0022\u003E\n-      \u003Cstop\n-         id=\u0022stop3843\u0022\n-         offset=\u00220\u0022\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022\n-         offset=\u00220.34984758\u0022\n-         id=\u0022stop3845\u0022 /\u003E\n-      \u003Cstop\n-         id=\u0022stop3849\u0022\n-         offset=\u00220.5454545\u0022\n-         style=\u0022stop-color:#e8e8e8;stop-opacity:1;\u0022 /\u003E\n-      \u003Cstop\n-         id=\u0022stop3847\u0022\n-         offset=\u00221\u0022\n-         style=\u0022stop-color:#252525;stop-opacity:1;\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient3824\u0022\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022\n-         offset=\u00220\u0022\n-         id=\u0022stop3826\u0022 /\u003E\n-      \u003Cstop\n-         id=\u0022stop3832\u0022\n-         offset=\u00220.5\u0022\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#d2d2d2;stop-opacity:1;\u0022\n-         offset=\u00221\u0022\n-         id=\u0022stop3828\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient3827\u0022\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#8ca6f1;stop-opacity:1;\u0022\n-         offset=\u00220\u0022\n-         id=\u0022stop3829\u0022 /\u003E\n-      \u003Cstop\n-         id=\u0022stop3836\u0022\n-         offset=\u00220.73972601\u0022\n-         style=\u0022stop-color:#5a72b4;stop-opacity:1;\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#293e78;stop-opacity:1;\u0022\n-         offset=\u00221\u0022\n-         id=\u0022stop3831\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect3829\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m 4.8980822,-0.72049866 6.1888208,0\u0022\n-       bendpath2=\u0022M 11.086903,-0.72049866 16.270482,14.741843\u0022\n-       bendpath3=\u0022M -0.25926539,14.751544 16.270482,14.741891\u0022\n-       bendpath4=\u0022M 4.8980822,-0.72049866 -0.25926539,14.751544\u0022\n-       bendpath3-nodetypes=\u0022cc\u0022\n-       bendpath4-nodetypes=\u0022cc\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect3819\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022true\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m -11,0.5 6.0000002,0\u0022\n-       bendpath2=\u0022m -4.9999998,0.5 0,15\u0022\n-       bendpath3=\u0022m -11,15.5 6.0000002,0\u0022\n-       bendpath4=\u0022m -11,0.5 0,15\u0022 /\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient5756\u0022\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#c8c8c8;stop-opacity:1;\u0022\n-         offset=\u00220\u0022\n-         id=\u0022stop5758\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022\n-         offset=\u00221\u0022\n-         id=\u0022stop5760\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-    \u003Cinkscape:path-effect\n-       bendpath4-nodetypes=\u0022cc\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022\n-       bendpath4=\u0022m 0.40934447,12.183659 c 5.22111233,-2.7860162 10.20346753,-2.563681 15.00000053,0\u0022\n-       bendpath3=\u0022m 15.409345,12.183659 0,-6.0000003\u0022\n-       bendpath2=\u0022m 0.40934447,6.1836587 c 5.17204473,-2.752717 10.16772953,-2.683658 15.00000053,0\u0022\n-       bendpath1=\u0022m 0.40934447,12.183659 0,-6.0000003\u0022\n-       xx=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       is_visible=\u0022true\u0022\n-       id=\u0022path-effect5700\u0022\n-       effect=\u0022envelope\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect5673\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m 3.7040018,0.50188195 6.0000002,0\u0022\n-       bendpath2=\u0022m 9.704002,0.50188195 c 2.752717,5.17204475 2.683658,10.16772905 0,15.00000005\u0022\n-       bendpath3=\u0022m 3.7040018,15.501882 6.0000002,0\u0022\n-       bendpath4=\u0022m 3.7040018,0.50188195 c 2.7860161,5.22111235 2.5636809,10.20346705 0,15.00000005\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022\n-       bendpath4-nodetypes=\u0022cc\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022bend_path\u0022\n-       id=\u0022path-effect5590\u0022\n-       is_visible=\u0022true\u0022\n-       bendpath=\u0022m 6.5,8 4,0\u0022\n-       prop_scale=\u00221\u0022\n-       scale_y_rel=\u0022true\u0022\n-       vertical=\u0022false\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022vonkoch\u0022\n-       id=\u0022path-effect5588\u0022\n-       is_visible=\u0022true\u0022\n-       ref_path=\u0022m 6.5,8 4,0\u0022\n-       generator=\u0022m 6.5,15.5 1.3333333,0 m 1.3333334,0 1.3333333,0\u0022\n-       similar_only=\u0022false\u0022\n-       nbgenerations=\u00221\u0022\n-       drawall=\u0022true\u0022\n-       maxComplexity=\u00221000\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022rough_hatches\u0022\n-       id=\u0022path-effect5586\u0022\n-       is_visible=\u0022false\u0022\n-       direction=\u00228.5,3 , 1,0\u0022\n-       dist_rdm=\u002275;1\u0022\n-       growth=\u00220\u0022\n-       do_bend=\u0022true\u0022\n-       bender=\u00228.5,8 , 5,0\u0022\n-       bottom_edge_variation=\u00221.5;1\u0022\n-       top_edge_variation=\u00221.5;1\u0022\n-       bottom_tgt_variation=\u00220;1\u0022\n-       top_tgt_variation=\u00220;1\u0022\n-       scale_bf=\u00221\u0022\n-       scale_bb=\u00221\u0022\n-       scale_tf=\u00221\u0022\n-       scale_tb=\u00221\u0022\n-       top_smth_variation=\u00220;1\u0022\n-       bottom_smth_variation=\u00220;1\u0022\n-       fat_output=\u0022true\u0022\n-       stroke_width_top=\u00221\u0022\n-       stroke_width_bottom=\u00221\u0022\n-       front_thickness=\u00221\u0022\n-       back_thickness=\u00220.25\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect5582\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m 6.5,0.5 4,0\u0022\n-       bendpath2=\u0022m 10.5,0.5 0,15\u0022\n-       bendpath3=\u0022m 6.5,15.5 4,0\u0022\n-       bendpath4=\u0022m 6.5,0.5 0,15\u0022 /\u003E\n-    \u003Cmarker\n-       inkscape:stockid=\u0022Arrow2Lend\u0022\n-       orient=\u0022auto\u0022\n-       refY=\u00220.0\u0022\n-       refX=\u00220.0\u0022\n-       id=\u0022Arrow2Lend\u0022\n-       style=\u0022overflow:visible;\u0022\u003E\n-      \u003Cpath\n-         id=\u0022path4397\u0022\n-         style=\u0022font-size:12.0;fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;\u0022\n-         d=\u0022M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z \u0022\n-         transform=\u0022scale(1.1) rotate(180) translate(1,0)\u0022 /\u003E\n-    \u003C/marker\u003E\n-    \u003Cmarker\n-       inkscape:stockid=\u0022Arrow2Lstart\u0022\n-       orient=\u0022auto\u0022\n-       refY=\u00220.0\u0022\n-       refX=\u00220.0\u0022\n-       id=\u0022Arrow2Lstart\u0022\n-       style=\u0022overflow:visible\u0022\u003E\n-      \u003Cpath\n-         id=\u0022path4394\u0022\n-         style=\u0022font-size:12.0;fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round\u0022\n-         d=\u0022M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z \u0022\n-         transform=\u0022scale(1.1) translate(1,0)\u0022 /\u003E\n-    \u003C/marker\u003E\n-    \u003Cmarker\n-       inkscape:stockid=\u0022Arrow1Lstart\u0022\n-       orient=\u0022auto\u0022\n-       refY=\u00220.0\u0022\n-       refX=\u00220.0\u0022\n-       id=\u0022Arrow1Lstart\u0022\n-       style=\u0022overflow:visible\u0022\u003E\n-      \u003Cpath\n-         id=\u0022path4376\u0022\n-         d=\u0022M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \u0022\n-         style=\u0022fill-rule:evenodd;stroke:#000000;stroke-width:1.0pt;marker-start:none\u0022\n-         transform=\u0022scale(0.8) translate(12.5,0)\u0022 /\u003E\n-    \u003C/marker\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect5673-8\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m -1.9996646,0.50189386 6,0\u0022\n-       bendpath2=\u0022m 4.0003354,0.50189386 c 2.7527172,5.17204484 2.6836582,10.16772914 0,15.00000014\u0022\n-       bendpath3=\u0022m -1.9996646,15.501894 6,0\u0022\n-       bendpath4=\u0022m -1.9996646,0.50189386 c 2.7860161,5.22111244 2.5636809,10.20346714 0,15.00000014\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022\n-       bendpath4-nodetypes=\u0022cc\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect5673-7\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m -11,0.5 6.0000002,0\u0022\n-       bendpath2=\u0022m -4.9999998,0.5 c 2.7527168,5.1720447 2.6836578,10.167729 0,15\u0022\n-       bendpath3=\u0022m -11,15.5 6.0000002,0\u0022\n-       bendpath4=\u0022m -11,0.5 c 2.7860161,5.2211123 2.5636809,10.203467 0,15\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022\n-       bendpath4-nodetypes=\u0022cc\u0022 /\u003E\n-    \u003Cinkscape:path-effect\n-       effect=\u0022envelope\u0022\n-       id=\u0022path-effect5673-7-1\u0022\n-       is_visible=\u0022true\u0022\n-       yy=\u0022false\u0022\n-       xx=\u0022true\u0022\n-       bendpath1=\u0022m 3.8034148,0.59873227 6,0\u0022\n-       bendpath2=\u0022m 9.8034148,0.59873227 c 2.7527172,5.17204473 2.6836582,10.16772873 0,14.99999973\u0022\n-       bendpath3=\u0022m 3.8034148,15.598732 6,0\u0022\n-       bendpath4=\u0022m 3.8034148,0.59873227 c 2.7860159,5.22111233 2.5636807,10.20346673 0,14.99999973\u0022\n-       bendpath2-nodetypes=\u0022cc\u0022\n-       bendpath4-nodetypes=\u0022cc\u0022 /\u003E\n-    \u003ClinearGradient\n-       inkscape:collect=\u0022always\u0022\n-       xlink:href=\u0022#linearGradient5756\u0022\n-       id=\u0022linearGradient5762\u0022\n-       x1=\u002212\u0022\n-       y1=\u002211.5\u0022\n-       x2=\u00227.5\u0022\n-       y2=\u00226\u0022\n-       gradientUnits=\u0022userSpaceOnUse\u0022\n-       gradientTransform=\u0022matrix(-1.030301,0,0,1.030301,16.242408,-0.242408)\u0022 /\u003E\n-    \u003ClinearGradient\n-       inkscape:collect=\u0022always\u0022\n-       xlink:href=\u0022#linearGradient5756\u0022\n-       id=\u0022linearGradient3798\u0022\n-       x1=\u00224\u0022\n-       y1=\u002214\u0022\n-       x2=\u00229\u0022\n-       y2=\u00228.5\u0022\n-       gradientUnits=\u0022userSpaceOnUse\u0022 /\u003E\n-    \u003ClinearGradient\n-       inkscape:collect=\u0022always\u0022\n-       xlink:href=\u0022#linearGradient4548\u0022\n-       id=\u0022linearGradient4546\u0022\n-       x1=\u002217\u0022\n-       y1=\u00221043.4717\u0022\n-       x2=\u002217\u0022\n-       y2=\u00221040.5363\u0022\n-       gradientUnits=\u0022userSpaceOnUse\u0022\n-       gradientTransform=\u0022matrix(0.5297937,0,0,0.42583335,-0.44892098,605.26716)\u0022 /\u003E\n-    \u003ClinearGradient\n-       id=\u0022linearGradient4548\u0022\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#000000;stop-opacity:1;\u0022\n-         offset=\u00220\u0022\n-         id=\u0022stop4550\u0022 /\u003E\n-      \u003Cstop\n-         id=\u0022stop4552\u0022\n-         offset=\u00220.4999913\u0022\n-         style=\u0022stop-color:#ffffff;stop-opacity:1;\u0022 /\u003E\n-      \u003Cstop\n-         style=\u0022stop-color:#000000;stop-opacity:1;\u0022\n-         offset=\u00221\u0022\n-         id=\u0022stop4554\u0022 /\u003E\n-    \u003C/linearGradient\u003E\n-  \u003C/defs\u003E\n-  \u003Csodipodi:namedview\n-     id=\u0022base\u0022\n-     pagecolor=\u0022#ffffff\u0022\n-     bordercolor=\u0022#666666\u0022\n-     borderopacity=\u00221.0\u0022\n-     inkscape:pageopacity=\u00220.0\u0022\n-     inkscape:pageshadow=\u00222\u0022\n-     inkscape:zoom=\u002232\u0022\n-     inkscape:cx=\u00228.3183485\u0022\n-     inkscape:cy=\u002212.957031\u0022\n-     inkscape:current-layer=\u0022text3853\u0022\n-     showgrid=\u0022true\u0022\n-     inkscape:grid-bbox=\u0022true\u0022\n-     inkscape:document-units=\u0022px\u0022\n-     inkscape:window-width=\u00221247\u0022\n-     inkscape:window-height=\u00221547\u0022\n-     inkscape:window-x=\u00221311\u0022\n-     inkscape:window-y=\u002224\u0022\n-     inkscape:window-maximized=\u00220\u0022\u003E\n-    \u003Cinkscape:grid\n-       type=\u0022xygrid\u0022\n-       id=\u0022grid5567\u0022\n-       empspacing=\u00224\u0022\n-       visible=\u0022true\u0022\n-       enabled=\u0022true\u0022\n-       snapvisiblegridlinesonly=\u0022true\u0022\n-       spacingx=\u00220.25px\u0022\n-       spacingy=\u00220.25px\u0022 /\u003E\n-    \u003Cinkscape:grid\n-       type=\u0022xygrid\u0022\n-       id=\u0022grid5569\u0022\n-       empspacing=\u00228\u0022\n-       visible=\u0022true\u0022\n-       enabled=\u0022true\u0022\n-       snapvisiblegridlinesonly=\u0022true\u0022\n-       color=\u0022#ff0000\u0022\n-       opacity=\u00220.1254902\u0022 /\u003E\n-  \u003C/sodipodi:namedview\u003E\n-  \u003Cmetadata\n-     id=\u0022metadata3856\u0022\u003E\n-    \u003Crdf:RDF\u003E\n-      \u003Ccc:Work\n-         rdf:about=\u0022\u0022\u003E\n-        \u003Cdc:format\u003Eimage/svg\u002Bxml\u003C/dc:format\u003E\n-        \u003Cdc:type\n-           rdf:resource=\u0022http://purl.org/dc/dcmitype/StillImage\u0022 /\u003E\n-        \u003Cdc:title\u003E\u003C/dc:title\u003E\n-      \u003C/cc:Work\u003E\n-    \u003C/rdf:RDF\u003E\n-  \u003C/metadata\u003E\n-  \u003Cg\n-     id=\u0022layer1\u0022\n-     inkscape:label=\u0022Layer 1\u0022\n-     inkscape:groupmode=\u0022layer\u0022\u003E\n-    \u003Cg\n-       style=\u0022font-size:21.55789566px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#3f3f3f;fill-opacity:1;stroke:none;font-family:Sans;-inkscape-font-specification:Sans Bold\u0022\n-       id=\u0022text3853\u0022\u003E\n-      \u003Cpath\n-         sodipodi:type=\u0022arc\u0022\n-         style=\u0022fill:#ffffff;fill-opacity:1;stroke:#656565;stroke-width:2.28571438999999987;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none\u0022\n-         id=\u0022path3879\u0022\n-         sodipodi:cx=\u00228\u0022\n-         sodipodi:cy=\u00228\u0022\n-         sodipodi:rx=\u00228\u0022\n-         sodipodi:ry=\u00228\u0022\n-         d=\u0022M 16,8 A 8,8 0 1 1 0,8 8,8 0 1 1 16,8 z\u0022\n-         transform=\u0022matrix(0.875,0,0,0.875,1,1)\u0022 /\u003E\n-      \u003Cpath\n-         style=\u0022fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:square;stroke-linejoin:miter;stroke-opacity:1\u0022\n-         d=\u0022m 7.5,4.5 0,4 4,0\u0022\n-         id=\u0022path3881\u0022\n-         inkscape:connector-curvature=\u00220\u0022\n-         sodipodi:nodetypes=\u0022ccc\u0022 /\u003E\n-    \u003C/g\u003E\n-  \u003C/g\u003E\n-  \u003Cg\n-     inkscape:groupmode=\u0022layer\u0022\n-     id=\u0022layer2\u0022\n-     inkscape:label=\u0022Layer\u0022 /\u003E\n-\u003C/svg\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "783d7d9f9523f4383bc8f1102adf0f9d23096396",
    "RawMessage": "Add types to timer.py (#1260)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex 01353b9..873b8df 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -1760,7 \u002B1760,7 @@ class Node:\n     def create_timer(\n         self,\n         timer_period_sec: float,\n-        callback: Callable[[TimerInfo], None],\n\u002B        callback: Union[Callable[[], None], Callable[[TimerInfo], None], None],\n         callback_group: Optional[CallbackGroup] = None,\n         clock: Optional[Clock] = None,\n         autostart: bool = True,\ndiff --git rclpy/rclpy/timer.py rclpy/rclpy/timer.py\nindex 236dcfb..7e1b1fe 100644\n--- rclpy/rclpy/timer.py\n\u002B\u002B\u002B rclpy/rclpy/timer.py\n@@ -17,17 \u002B17,52 @@ import threading\n from types import TracebackType\n from typing import Callable\n from typing import Optional\n\u002Bfrom typing import Protocol\n from typing import Type\n\u002Bfrom typing import Union\n \n from rclpy.callback_groups import CallbackGroup\n-from rclpy.clock import Clock, ClockType\n\u002Bfrom rclpy.clock import Clock\n\u002Bfrom rclpy.clock_type import ClockType\n from rclpy.context import Context\n\u002Bfrom rclpy.destroyable import DestroyableType\n from rclpy.exceptions import InvalidHandle, ROSInterruptException\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.time import Time\n from rclpy.utilities import get_default_context\n \n \n\u002Bclass TimerHandle(DestroyableType, Protocol):\n\u002B    \u0022\u0022\u0022Type alias of _rclpy.Timer.\u0022\u0022\u0022\n\u002B\n\u002B    def reset_timer(self) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def is_timer_ready(self) -\u003E bool:\n\u002B        ...\n\u002B\n\u002B    def call_timer(self) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def change_timer_period(self, period_nsec: int) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def time_until_next_call(self) -\u003E Optional[int]:\n\u002B        ...\n\u002B\n\u002B    def time_since_last_call(self) -\u003E int:\n\u002B        ...\n\u002B\n\u002B    def get_timer_period(self) -\u003E int:\n\u002B        ...\n\u002B\n\u002B    def cancel_timer(self) -\u003E None:\n\u002B        ...\n\u002B\n\u002B    def is_timer_canceled(self) -\u003E bool:\n\u002B        ...\n\u002B\n\u002B\n class TimerInfo:\n     \u0022\u0022\u0022\n     Represents a timer call information.\n@@ -64,7 \u002B99,7 @@ class Timer:\n \n     def __init__(\n         self,\n-        callback: Callable,\n\u002B        callback: Union[Callable[[], None], Callable[[TimerInfo], None], None],\n         callback_group: CallbackGroup,\n         timer_period_ns: int,\n         clock: Clock,\n@@ -94,8 \u002B129,10 @@ class Timer:\n         \u0022\u0022\u0022\n         self._context = get_default_context() if context is None else context\n         self._clock = clock\n\u002B        if self._context.handle is None:\n\u002B            raise RuntimeError(\u0027Context must be initialized before create a TimerHandle.\u0027)\n         with self._clock.handle, self._context.handle:\n-            self.__timer = _rclpy.Timer(\n\u002B            self.__timer: TimerHandle = _rclpy.Timer(\n                 self._clock.handle, self._context.handle, timer_period_ns, autostart)\n         self.timer_period_ns = timer_period_ns\n         self.callback = callback\n@@ -104,10 \u002B141,10 @@ class Timer:\n         self._executor_event = False\n \n     @property\n-    def handle(self):\n\u002B    def handle(self) -\u003E TimerHandle:\n         return self.__timer\n \n-    def destroy(self):\n\u002B    def destroy(self) -\u003E None:\n         \u0022\u0022\u0022\n         Destroy a container for a ROS timer.\n \n@@ -117,44 \u002B154,44 @@ class Timer:\n         self.__timer.destroy_when_not_in_use()\n \n     @property\n-    def clock(self):\n\u002B    def clock(self) -\u003E Clock:\n         return self._clock\n \n     @property\n-    def timer_period_ns(self):\n\u002B    def timer_period_ns(self) -\u003E int:\n         with self.__timer:\n             val = self.__timer.get_timer_period()\n         self.__timer_period_ns = val\n         return val\n \n     @timer_period_ns.setter\n-    def timer_period_ns(self, value):\n\u002B    def timer_period_ns(self, value: int) -\u003E None:\n         val = int(value)\n         with self.__timer:\n             self.__timer.change_timer_period(val)\n         self.__timer_period_ns = val\n \n-    def is_ready(self):\n\u002B    def is_ready(self) -\u003E bool:\n         with self.__timer:\n             return self.__timer.is_timer_ready()\n \n-    def is_canceled(self):\n\u002B    def is_canceled(self) -\u003E bool:\n         with self.__timer:\n             return self.__timer.is_timer_canceled()\n \n-    def cancel(self):\n\u002B    def cancel(self) -\u003E None:\n         with self.__timer:\n             self.__timer.cancel_timer()\n \n-    def reset(self):\n\u002B    def reset(self) -\u003E None:\n         with self.__timer:\n             self.__timer.reset_timer()\n \n-    def time_since_last_call(self):\n\u002B    def time_since_last_call(self) -\u003E int:\n         with self.__timer:\n             return self.__timer.time_since_last_call()\n \n-    def time_until_next_call(self):\n\u002B    def time_until_next_call(self) -\u003E Optional[int]:\n         with self.__timer:\n             return self.__timer.time_until_next_call()\n \n@@ -173,7 \u002B210,7 @@ class Timer:\n class Rate:\n     \u0022\u0022\u0022A utility for sleeping at a fixed rate.\u0022\u0022\u0022\n \n-    def __init__(self, timer: Timer, *, context):\n\u002B    def __init__(self, timer: Timer, *, context: Context):\n         \u0022\u0022\u0022\n         Create a Rate.\n \n@@ -196,11 \u002B233,11 @@ class Rate:\n         # Set event when ROS is shutdown\n         context.on_shutdown(self._on_shutdown)\n \n-    def _on_shutdown(self):\n\u002B    def _on_shutdown(self) -\u003E None:\n         self._is_shutdown = True\n         self.destroy()\n \n-    def destroy(self):\n\u002B    def destroy(self) -\u003E None:\n         \u0022\u0022\u0022\n         Destroy a container for a ROS rate.\n \n@@ -210,7 \u002B247,7 @@ class Rate:\n         self._is_destroyed = True\n         self._event.set()\n \n-    def _presleep(self):\n\u002B    def _presleep(self) -\u003E None:\n         if self._is_shutdown:\n             raise ROSInterruptException()\n         if self._is_destroyed:\n@@ -221,7 \u002B258,7 @@ class Rate:\n         with self._lock:\n             self._num_sleepers \u002B= 1\n \n-    def _postsleep(self):\n\u002B    def _postsleep(self) -\u003E None:\n         with self._lock:\n             self._num_sleepers -= 1\n             if self._num_sleepers == 0:\n@@ -230,7 \u002B267,7 @@ class Rate:\n             self.destroy()\n             raise ROSInterruptException()\n \n-    def sleep(self):\n\u002B    def sleep(self) -\u003E None:\n         \u0022\u0022\u0022\n         Block until timer triggers.\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "6dbeb86b3a92eaa563285e2ebd55487576945122",
    "RawMessage": "Client:call generates TimeoutError exception when it is timed out. (#1271)",
    "Changes": "diff --git rclpy/rclpy/client.py rclpy/rclpy/client.py\nindex cba396a..67aa2fb 100644\n--- rclpy/rclpy/client.py\n\u002B\u002B\u002B rclpy/rclpy/client.py\n@@ -85,10 \u002B85,11 @@ class Client(Generic[SrvRequestT, SrvResponseT, SrvEventT]):\n \n         :param request: The service request.\n         :param timeout_sec: Seconds to wait. If \u0060\u0060None\u0060\u0060, then wait forever.\n-        :return: The service response, or None if timed out.\n\u002B        :return: The service response.\n         :raises: TypeError if the type of the passed request isn\u0027t an instance\n           of the Request type of the provided service when the client was\n           constructed.\n\u002B        :raises: TimeoutError if the response is not available within the timeout.\n         \u0022\u0022\u0022\n         if not isinstance(request, self.srv_type.Request):\n             raise TypeError()\n@@ -109,6 \u002B110,7 @@ class Client(Generic[SrvRequestT, SrvResponseT, SrvEventT]):\n             if not event.wait(timeout_sec):\n                 # Timed out. remove_pending_request() to free resources\n                 self.remove_pending_request(future)\n\u002B                raise TimeoutError()\n \n         exception = future.exception()\n         if exception is not None:\ndiff --git rclpy/test/test_client.py rclpy/test/test_client.py\nindex a0cf51c..c770f61 100644\n--- rclpy/test/test_client.py\n\u002B\u002B\u002B rclpy/test/test_client.py\n@@ -213,6 \u002B213,8 @@ class TestClient(unittest.TestCase):\n             executor_thread = threading.Thread(\n                 target=TestClient._spin_rclpy_node, args=(self.node, executor))\n             executor_thread.start()\n\u002B            # make sure thread has started to avoid exception via join()\n\u002B            self.assertTrue(executor_thread.is_alive())\n             result = cli.call(GetParameters.Request(), 0.5)\n             self.assertTrue(result is not None)\n             executor.shutdown()\n@@ -234,11 \u002B236,13 @@ class TestClient(unittest.TestCase):\n             executor_thread = threading.Thread(\n                 target=TestClient._spin_rclpy_node, args=(self.node, executor))\n             executor_thread.start()\n-            result = cli.call(GetParameters.Request(), 0.5)\n-            self.assertTrue(result is None)\n\u002B            # make sure thread has started to avoid exception via join()\n\u002B            self.assertTrue(executor_thread.is_alive())\n\u002B            with self.assertRaises(TimeoutError):\n\u002B                cli.call(GetParameters.Request(), 0.5)\n\u002B        finally:\n             executor.shutdown()\n             executor_thread.join()\n-        finally:\n             self.node.destroy_client(cli)\n             self.node.destroy_service(srv)\n \n@@ -253,6 \u002B257,8 @@ class TestClient(unittest.TestCase):\n                 executor_thread = threading.Thread(\n                     target=TestClient._spin_rclpy_node, args=(self.node, executor))\n                 executor_thread.start()\n\u002B                # make sure thread has started to avoid exception via join()\n\u002B                self.assertTrue(executor_thread.is_alive())\n                 result = cli.call(GetParameters.Request(), 0.5)\n                 self.assertTrue(result is not None)\n                 executor.shutdown()\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "6dd3a0377bbacd07fa6ed3c9e70c6de70931b45f",
    "RawMessage": "use regex for wildcard matching (#1839)",
    "Changes": "diff --git rclcpp/include/rclcpp/parameter_map.hpp rclcpp/include/rclcpp/parameter_map.hpp\nindex 9cfcdaaa..303eac4a 100644\n--- rclcpp/include/rclcpp/parameter_map.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/parameter_map.hpp\n@@ -35,11 \u002B35,13 @@ using ParameterMap = std::unordered_map\u003Cstd::string, std::vector\u003CParameter\u003E\u003E;\n \n /// Convert parameters from rcl_yaml_param_parser into C\u002B\u002B class instances.\n /// \\param[in] c_params C structures containing parameters for multiple nodes.\n\u002B/// \\param[in] node_fqn a Fully Qualified Name of node, default value is nullptr.\n\u002B///   If it\u0027s not nullptr, return the relative node parameters belonging to this node_fqn.\n /// \\returns a map where the keys are fully qualified node names and values a list of parameters.\n /// \\throws InvalidParametersException if the \u0060rcl_params_t\u0060 is inconsistent or invalid.\n RCLCPP_PUBLIC\n ParameterMap\n-parameter_map_from(const rcl_params_t * const c_params);\n\u002Bparameter_map_from(const rcl_params_t * const c_params, const char * node_fqn = nullptr);\n \n /// Convert parameter value from rcl_yaml_param_parser into a C\u002B\u002B class instance.\n /// \\param[in] c_value C structure containing a value of a parameter.\ndiff --git rclcpp/src/rclcpp/detail/resolve_parameter_overrides.cpp rclcpp/src/rclcpp/detail/resolve_parameter_overrides.cpp\nindex a62121b3..3959e648 100644\n--- rclcpp/src/rclcpp/detail/resolve_parameter_overrides.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/detail/resolve_parameter_overrides.cpp\n@@ -51,18 \u002B51,13 @@ rclcpp::detail::resolve_parameter_overrides(\n         [params]() {\n           rcl_yaml_node_struct_fini(params);\n         });\n-      rclcpp::ParameterMap initial_map = rclcpp::parameter_map_from(params);\n\u002B      rclcpp::ParameterMap initial_map = rclcpp::parameter_map_from(params, node_fqn.c_str());\n \n-      // Enforce wildcard matching precedence\n-      // TODO(cottsay) implement further wildcard matching\n-      const std::array\u003Cstd::string, 2\u003E node_matching_names{\u0022/**\u0022, node_fqn};\n-      for (const auto \u0026 node_name : node_matching_names) {\n-        if (initial_map.count(node_name) \u003E 0) {\n-          // Combine parameter yaml files, overwriting values in older ones\n-          for (const rclcpp::Parameter \u0026 param : initial_map.at(node_name)) {\n-            result[param.get_name()] =\n-              rclcpp::ParameterValue(param.get_value_message());\n-          }\n\u002B      if (initial_map.count(node_fqn) \u003E 0) {\n\u002B        // Combine parameter yaml files, overwriting values in older ones\n\u002B        for (const rclcpp::Parameter \u0026 param : initial_map.at(node_fqn)) {\n\u002B          result[param.get_name()] =\n\u002B            rclcpp::ParameterValue(param.get_value_message());\n         }\n       }\n     }\ndiff --git rclcpp/src/rclcpp/parameter_map.cpp rclcpp/src/rclcpp/parameter_map.cpp\nindex e5e3da01..8f7bc065 100644\n--- rclcpp/src/rclcpp/parameter_map.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_map.cpp\n@@ -13,8 \u002B13,10 @@\n // limitations under the License.\n \n #include \u003Cstring\u003E\n\u002B#include \u003Cregex\u003E\n #include \u003Cvector\u003E\n \n\u002B#include \u0022rcpputils/find_and_replace.hpp\u0022\n #include \u0022rclcpp/parameter_map.hpp\u0022\n \n using rclcpp::exceptions::InvalidParametersException;\n@@ -23,7 \u002B25,7 @@ using rclcpp::ParameterMap;\n using rclcpp::ParameterValue;\n \n ParameterMap\n-rclcpp::parameter_map_from(const rcl_params_t * const c_params)\n\u002Brclcpp::parameter_map_from(const rcl_params_t * const c_params, const char * node_fqn)\n {\n   if (NULL == c_params) {\n     throw InvalidParametersException(\u0022parameters struct is NULL\u0022);\n@@ -49,6 \u002B51,17 @@ rclcpp::parameter_map_from(const rcl_params_t * const c_params)\n       node_name = c_node_name;\n     }\n \n\u002B    if (node_fqn) {\n\u002B      // Update the regular expression [\u0022/*\u0022 -\u003E \u0022(/\\\\w\u002B)\u0022 and \u0022/**\u0022 -\u003E \u0022(/\\\\w\u002B)*\u0022]\n\u002B      std::string regex = rcpputils::find_and_replace(node_name, \u0022/*\u0022, \u0022(/\\\\w\u002B)\u0022);\n\u002B      if (!std::regex_match(node_fqn, std::regex(regex))) {\n\u002B        // No need to parse the items because the user just care about node_fqn\n\u002B        continue;\n\u002B      }\n\u002B\n\u002B      node_name = node_fqn;\n\u002B    }\n\u002B\n     const rcl_node_params_t * const c_params_node = \u0026(c_params-\u003Eparams[n]);\n \n     std::vector\u003CParameter\u003E \u0026 params_node = parameters[node_name];\n@@ -65,6 \u002B78,7 @@ rclcpp::parameter_map_from(const rcl_params_t * const c_params)\n       params_node.emplace_back(c_param_name, parameter_value_from(c_param_value));\n     }\n   }\n\u002B\n   return parameters;\n }\n \ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\nindex 31b755b4..97e3a318 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\n@@ -31,6 \u002B31,8 @@\n #include \u0022../../mocking_utils/patch.hpp\u0022\n #include \u0022../../utils/rclcpp_gtest_macros.hpp\u0022\n \n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B\n class TestNodeParameters : public ::testing::Test\n {\n public:\n@@ -47,6 \u002B49,7 @@ public:\n       dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n       node-\u003Eget_node_parameters_interface().get());\n     ASSERT_NE(nullptr, node_parameters);\n\u002B    test_resources_path /= \u0022test_node_parameters\u0022;\n   }\n \n   void TearDown()\n@@ -57,6 \u002B60,8 @@ public:\n protected:\n   std::shared_ptr\u003Crclcpp::Node\u003E node;\n   rclcpp::node_interfaces::NodeParameters * node_parameters;\n\u002B\n\u002B  rcpputils::fs::path test_resources_path{TEST_RESOURCES_DIRECTORY};\n };\n \n TEST_F(TestNodeParameters, construct_destruct_rcl_errors) {\n@@ -199,3 \u002B204,130 @@ TEST_F(TestNodeParameters, add_remove_parameters_callback) {\n     node_parameters-\u003Eremove_on_set_parameters_callback(handle.get()),\n     std::runtime_error(\u0022Callback doesn\u0027t exist\u0022));\n }\n\u002B\n\u002BTEST_F(TestNodeParameters, wildcard_with_namespace)\n\u002B{\n\u002B  rclcpp::NodeOptions opts;\n\u002B  opts.arguments(\n\u002B  {\n\u002B    \u0022--ros-args\u0022,\n\u002B    \u0022--params-file\u0022, (test_resources_path / \u0022wildcards.yaml\u0022).string()\n\u002B  });\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022, opts);\n\u002B\n\u002B  auto * node_parameters =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B    node-\u003Eget_node_parameters_interface().get());\n\u002B  ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B  const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B  EXPECT_EQ(7u, parameter_overrides.size());\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022full_wild\u0022).get\u003Cstd::string\u003E(), \u0022full_wild\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022namespace_wild\u0022).get\u003Cstd::string\u003E(), \u0022namespace_wild\u0022);\n\u002B  EXPECT_EQ(\n\u002B    parameter_overrides.at(\u0022namespace_wild_another\u0022).get\u003Cstd::string\u003E(),\n\u002B    \u0022namespace_wild_another\u0022);\n\u002B  EXPECT_EQ(\n\u002B    parameter_overrides.at(\u0022namespace_wild_one_star\u0022).get\u003Cstd::string\u003E(),\n\u002B    \u0022namespace_wild_one_star\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022node_wild_in_ns\u0022).get\u003Cstd::string\u003E(), \u0022node_wild_in_ns\u0022);\n\u002B  EXPECT_EQ(\n\u002B    parameter_overrides.at(\u0022node_wild_in_ns_another\u0022).get\u003Cstd::string\u003E(),\n\u002B    \u0022node_wild_in_ns_another\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022explicit_in_ns\u0022).get\u003Cstd::string\u003E(), \u0022explicit_in_ns\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.count(\u0022should_not_appear\u0022), 0u);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeParameters, wildcard_no_namespace)\n\u002B{\n\u002B  rclcpp::NodeOptions opts;\n\u002B  opts.arguments(\n\u002B  {\n\u002B    \u0022--ros-args\u0022,\n\u002B    \u0022--params-file\u0022, (test_resources_path / \u0022wildcards.yaml\u0022).string()\n\u002B  });\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, opts);\n\u002B\n\u002B  auto * node_parameters =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B    node-\u003Eget_node_parameters_interface().get());\n\u002B  ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B  const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B  EXPECT_EQ(5u, parameter_overrides.size());\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022full_wild\u0022).get\u003Cstd::string\u003E(), \u0022full_wild\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022namespace_wild\u0022).get\u003Cstd::string\u003E(), \u0022namespace_wild\u0022);\n\u002B  EXPECT_EQ(\n\u002B    parameter_overrides.at(\u0022namespace_wild_another\u0022).get\u003Cstd::string\u003E(),\n\u002B    \u0022namespace_wild_another\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022node_wild_no_ns\u0022).get\u003Cstd::string\u003E(), \u0022node_wild_no_ns\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022explicit_no_ns\u0022).get\u003Cstd::string\u003E(), \u0022explicit_no_ns\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.count(\u0022should_not_appear\u0022), 0u);\n\u002B  // \u0022/*\u0022 match exactly one token, not expect to get \u0060namespace_wild_one_star\u0060\n\u002B  EXPECT_EQ(parameter_overrides.count(\u0022namespace_wild_one_star\u0022), 0u);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeParameters, params_by_order)\n\u002B{\n\u002B  rclcpp::NodeOptions opts;\n\u002B  opts.arguments(\n\u002B  {\n\u002B    \u0022--ros-args\u0022,\n\u002B    \u0022--params-file\u0022, (test_resources_path / \u0022params_by_order.yaml\u0022).string()\n\u002B  });\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022, opts);\n\u002B\n\u002B  auto * node_parameters =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B    node-\u003Eget_node_parameters_interface().get());\n\u002B  ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B  const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B  EXPECT_EQ(3u, parameter_overrides.size());\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022a_value\u0022).get\u003Cstd::string\u003E(), \u0022last_one_win\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022foo\u0022).get\u003Cstd::string\u003E(), \u0022foo\u0022);\n\u002B  EXPECT_EQ(parameter_overrides.at(\u0022bar\u0022).get\u003Cstd::string\u003E(), \u0022bar\u0022);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeParameters, complicated_wildcards)\n\u002B{\n\u002B  rclcpp::NodeOptions opts;\n\u002B  opts.arguments(\n\u002B  {\n\u002B    \u0022--ros-args\u0022,\n\u002B    \u0022--params-file\u0022, (test_resources_path / \u0022complicated_wildcards.yaml\u0022).string()\n\u002B  });\n\u002B\n\u002B  {\n\u002B    // regex matched: /**/foo/*/bar\n\u002B    std::shared_ptr\u003Crclcpp::Node\u003E node =\n\u002B      std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022/a/b/c/foo/d/bar\u0022, opts);\n\u002B\n\u002B    auto * node_parameters =\n\u002B      dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B      node-\u003Eget_node_parameters_interface().get());\n\u002B    ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B    const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B    EXPECT_EQ(2u, parameter_overrides.size());\n\u002B    EXPECT_EQ(parameter_overrides.at(\u0022foo\u0022).get\u003Cstd::string\u003E(), \u0022foo\u0022);\n\u002B    EXPECT_EQ(parameter_overrides.at(\u0022bar\u0022).get\u003Cstd::string\u003E(), \u0022bar\u0022);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    // regex not matched: /**/foo/*/bar\n\u002B    std::shared_ptr\u003Crclcpp::Node\u003E node =\n\u002B      std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022/a/b/c/foo/bar\u0022, opts);\n\u002B\n\u002B    auto * node_parameters =\n\u002B      dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B      node-\u003Eget_node_parameters_interface().get());\n\u002B    ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B    const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B    EXPECT_EQ(0u, parameter_overrides.size());\n\u002B  }\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_parameter_map.cpp rclcpp/test/rclcpp/test_parameter_map.cpp\nindex 3f54e4c8..0158b7c7 100644\n--- rclcpp/test/rclcpp/test_parameter_map.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_map.cpp\n@@ -19,6 \u002B19,7 @@\n \n #include \u003Ccstdio\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cunordered_map\u003E\n #include \u003Cvector\u003E\n \n #include \u0022rclcpp/parameter_map.hpp\u0022\n@@ -353,3 \u002B354,132 @@ TEST(Test_parameter_map_from, string_array_param_value)\n   c_params-\u003Eparams[0].parameter_values[0].string_array_value = NULL;\n   rcl_yaml_node_struct_fini(c_params);\n }\n\u002B\n\u002BTEST(Test_parameter_map_from, one_node_one_param_by_node_fqn)\n\u002B{\n\u002B  rcl_params_t * c_params = make_params({\u0022foo\u0022});\n\u002B  make_node_params(c_params, 0, {\u0022string_param\u0022});\n\u002B\n\u002B  std::string hello_world = \u0022hello world\u0022;\n\u002B  char * c_hello_world = new char[hello_world.length() \u002B 1];\n\u002B  std::snprintf(c_hello_world, hello_world.size() \u002B 1, \u0022%s\u0022, hello_world.c_str());\n\u002B  c_params-\u003Eparams[0].parameter_values[0].string_value = c_hello_world;\n\u002B\n\u002B  rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, \u0022/foo\u0022);\n\u002B  const std::vector\u003Crclcpp::Parameter\u003E \u0026 params = map.at(\u0022/foo\u0022);\n\u002B  EXPECT_STREQ(\u0022string_param\u0022, params.at(0).get_name().c_str());\n\u002B  EXPECT_STREQ(hello_world.c_str(), params.at(0).get_value\u003Cstd::string\u003E().c_str());\n\u002B\n\u002B  c_params-\u003Eparams[0].parameter_values[0].string_value = NULL;\n\u002B  delete[] c_hello_world;\n\u002B  rcl_yaml_node_struct_fini(c_params);\n\u002B}\n\u002B\n\u002BTEST(Test_parameter_map_from, multi_nodes_same_param_name_by_node_fqn)\n\u002B{\n\u002B  std::vector\u003Cstd::string\u003E node_names_keys = {\n\u002B    \u0022/**\u0022,              // index: 0\n\u002B    \u0022/*\u0022,               // index: 1\n\u002B    \u0022/**/node\u0022,         // index: 2\n\u002B    \u0022/*/node\u0022,          // index: 3\n\u002B    \u0022/ns/node\u0022          // index: 4\n\u002B  };\n\u002B\n\u002B  rcl_params_t * c_params = make_params(node_names_keys);\n\u002B\n\u002B  std::vector\u003Cchar *\u003E param_values;\n\u002B  for (size_t i = 0; i \u003C node_names_keys.size(); \u002B\u002Bi) {\n\u002B    make_node_params(c_params, i, {\u0022string_param\u0022});\n\u002B    std::string hello_world = \u0022hello world\u0022 \u002B std::to_string(i);\n\u002B    char * c_hello_world = new char[hello_world.length() \u002B 1];\n\u002B    std::snprintf(c_hello_world, hello_world.size() \u002B 1, \u0022%s\u0022, hello_world.c_str());\n\u002B    c_params-\u003Eparams[i].parameter_values[0].string_value = c_hello_world;\n\u002B    param_values.push_back(c_hello_world);\n\u002B  }\n\u002B\n\u002B  std::unordered_map\u003Cstd::string, std::vector\u003Csize_t\u003E\u003E node_fqn_expected = {\n\u002B    {\u0022/ns/foo/another_node\u0022, {0}},\n\u002B    {\u0022/another\u0022, {0, 1}},\n\u002B    {\u0022/node\u0022, {0, 1, 2}},\n\u002B    {\u0022/another_ns/node\u0022, {0, 2, 3}},\n\u002B    {\u0022/ns/node\u0022, {0, 2, 3, 4}},\n\u002B  };\n\u002B\n\u002B  for (auto \u0026 kv : node_fqn_expected) {\n\u002B    rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, kv.first.c_str());\n\u002B    const std::vector\u003Crclcpp::Parameter\u003E \u0026 params = map.at(kv.first);\n\u002B\n\u002B    EXPECT_EQ(kv.second.size(), params.size());\n\u002B    for (size_t i = 0; i \u003C params.size(); \u002B\u002Bi) {\n\u002B      std::string param_value = \u0022hello world\u0022 \u002B std::to_string(kv.second[i]);\n\u002B      EXPECT_STREQ(\u0022string_param\u0022, params.at(i).get_name().c_str());\n\u002B      EXPECT_STREQ(param_value.c_str(), params.at(i).get_value\u003Cstd::string\u003E().c_str());\n\u002B    }\n\u002B  }\n\u002B\n\u002B  for (size_t i = 0; i \u003C node_names_keys.size(); \u002B\u002Bi) {\n\u002B    c_params-\u003Eparams[i].parameter_values[0].string_value = NULL;\n\u002B  }\n\u002B  for (auto c_hello_world : param_values) {\n\u002B    delete[] c_hello_world;\n\u002B  }\n\u002B  rcl_yaml_node_struct_fini(c_params);\n\u002B}\n\u002B\n\u002BTEST(Test_parameter_map_from, multi_nodes_diff_param_name_by_node_fqn)\n\u002B{\n\u002B  std::vector\u003Cstd::string\u003E node_names_keys = {\n\u002B    \u0022/**\u0022,              // index: 0\n\u002B    \u0022/*\u0022,               // index: 1\n\u002B    \u0022/**/node\u0022,         // index: 2\n\u002B    \u0022/*/node\u0022,          // index: 3\n\u002B    \u0022/ns/**\u0022,           // index: 4\n\u002B    \u0022/ns/*\u0022,            // index: 5\n\u002B    \u0022/ns/**/node\u0022,      // index: 6\n\u002B    \u0022/ns/*/node\u0022,       // index: 7\n\u002B    \u0022/ns/**/a/*/node\u0022,  // index: 8\n\u002B    \u0022/ns/node\u0022          // index: 9\n\u002B  };\n\u002B\n\u002B  rcl_params_t * c_params = make_params(node_names_keys);\n\u002B\n\u002B  for (size_t i = 0; i \u003C node_names_keys.size(); \u002B\u002Bi) {\n\u002B    std::string param_name = \u0022string_param\u0022 \u002B std::to_string(i);\n\u002B    make_node_params(c_params, i, {param_name});\n\u002B  }\n\u002B\n\u002B  std::string hello_world = \u0022hello world\u0022;\n\u002B  char * c_hello_world = new char[hello_world.length() \u002B 1];\n\u002B  std::snprintf(c_hello_world, hello_world.size() \u002B 1, \u0022%s\u0022, hello_world.c_str());\n\u002B\n\u002B  for (size_t i = 0; i \u003C node_names_keys.size(); \u002B\u002Bi) {\n\u002B    c_params-\u003Eparams[i].parameter_values[0].string_value = c_hello_world;\n\u002B  }\n\u002B\n\u002B  std::unordered_map\u003Cstd::string, std::vector\u003Csize_t\u003E\u003E node_fqn_expected = {\n\u002B    {\u0022/ns/node\u0022, {0, 2, 3, 4, 5, 6, 9}},\n\u002B    {\u0022/node\u0022, {0, 1, 2}},\n\u002B    {\u0022/ns/foo/node\u0022, {0, 2, 4, 6, 7}},\n\u002B    {\u0022/ns/foo/a/node\u0022, {0, 2, 4, 6}},\n\u002B    {\u0022/ns/foo/a/bar/node\u0022, {0, 2, 4, 6, 8}},\n\u002B    {\u0022/ns/a/bar/node\u0022, {0, 2, 4, 6, 8}},\n\u002B    {\u0022/ns/foo/zoo/a/bar/node\u0022, {0, 2, 4, 6, 8}},\n\u002B  };\n\u002B\n\u002B  for (auto \u0026 kv : node_fqn_expected) {\n\u002B    rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, kv.first.c_str());\n\u002B    const std::vector\u003Crclcpp::Parameter\u003E \u0026 params = map.at(kv.first);\n\u002B    EXPECT_EQ(kv.second.size(), params.size());\n\u002B    for (size_t i = 0; i \u003C params.size(); \u002B\u002Bi) {\n\u002B      std::string param_name = \u0022string_param\u0022 \u002B std::to_string(kv.second[i]);\n\u002B      EXPECT_STREQ(param_name.c_str(), params.at(i).get_name().c_str());\n\u002B      EXPECT_STREQ(hello_world.c_str(), params.at(i).get_value\u003Cstd::string\u003E().c_str());\n\u002B    }\n\u002B  }\n\u002B\n\u002B  for (size_t i = 0; i \u003C node_names_keys.size(); \u002B\u002Bi) {\n\u002B    c_params-\u003Eparams[i].parameter_values[0].string_value = NULL;\n\u002B  }\n\u002B  delete[] c_hello_world;\n\u002B  rcl_yaml_node_struct_fini(c_params);\n\u002B}\ndiff --git rclcpp/test/resources/test_node_parameters/complicated_wildcards.yaml rclcpp/test/resources/test_node_parameters/complicated_wildcards.yaml\nnew file mode 100644\nindex 00000000..53da4091\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/resources/test_node_parameters/complicated_wildcards.yaml\n@@ -0,0 \u002B1,5 @@\n\u002B/**/foo/*/bar:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      foo: \u0022foo\u0022\n\u002B      bar: \u0022bar\u0022\ndiff --git rclcpp/test/resources/test_node_parameters/params_by_order.yaml rclcpp/test/resources/test_node_parameters/params_by_order.yaml\nnew file mode 100644\nindex 00000000..680d96be\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/resources/test_node_parameters/params_by_order.yaml\n@@ -0,0 \u002B1,16 @@\n\u002B/**:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      a_value: \u0022first\u0022\n\u002B      foo: \u0022foo\u0022\n\u002B\n\u002B/ns:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      a_value: \u0022second\u0022\n\u002B      bar: \u0022bar\u0022\n\u002B\n\u002B/*:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      a_value: \u0022last_one_win\u0022\ndiff --git rclcpp/test/resources/test_node_parameters/wildcards.yaml rclcpp/test/resources/test_node_parameters/wildcards.yaml\nnew file mode 100644\nindex 00000000..b89b0d8c\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/resources/test_node_parameters/wildcards.yaml\n@@ -0,0 \u002B1,57 @@\n\u002B/**:\n\u002B  ros__parameters:\n\u002B    full_wild: \u0022full_wild\u0022\n\u002B\n\u002B/**:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      namespace_wild: \u0022namespace_wild\u0022\n\u002B\n\u002B/**/node2:\n\u002B  ros__parameters:\n\u002B    namespace_wild_another: \u0022namespace_wild_another\u0022\n\u002B\n\u002B/*:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      namespace_wild_one_star: \u0022namespace_wild_one_star\u0022\n\u002B\n\u002Bns:\n\u002B  \u0022*\u0022:\n\u002B    ros__parameters:\n\u002B      node_wild_in_ns: \u0022node_wild_in_ns\u0022\n\u002B\n\u002B/ns/*:\n\u002B  ros__parameters:\n\u002B    node_wild_in_ns_another: \u0022node_wild_in_ns_another\u0022\n\u002B\n\u002Bns:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      explicit_in_ns: \u0022explicit_in_ns\u0022\n\u002B\n\u002B\u0022*\u0022:\n\u002B  ros__parameters:\n\u002B    node_wild_no_ns: \u0022node_wild_no_ns\u0022\n\u002B\n\u002Bnode2:\n\u002B  ros__parameters:\n\u002B    explicit_no_ns: \u0022explicit_no_ns\u0022\n\u002B\n\u002Bns:\n\u002B  nodeX:\n\u002B    ros__parameters:\n\u002B      should_not_appear: \u0022incorrect_node_name\u0022\n\u002B\n\u002B/**/nodeX:\n\u002B  ros__parameters:\n\u002B    should_not_appear: \u0022incorrect_node_name\u0022\n\u002B\n\u002BnsX:\n\u002B  node2:\n\u002B    ros__parameters:\n\u002B      should_not_appear: \u0022incorrect_namespace\u0022\n\u002B\n\u002B/nsX/*:\n\u002B  ros__parameters:\n\u002B    should_not_appear: \u0022incorrect_namespace\u0022\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rmw",
    "SHA": "b3dbdadda0ae585602327342e23f72ae14a44f66",
    "RawMessage": "Added rmw_security_common (#388)",
    "Changes": "diff --git rmw_security_common/CMakeLists.txt rmw_security_common/CMakeLists.txt\nnew file mode 100644\nindex 0000000..28c049e\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/CMakeLists.txt\n@@ -0,0 \u002B1,77 @@\n\u002Bcmake_minimum_required(VERSION 3.14)\n\u002B\n\u002Bproject(rmw_security_common)\n\u002B\n\u002B# Default to C99\n\u002Bif(NOT CMAKE_C_STANDARD)\n\u002B  set(CMAKE_C_STANDARD 99)\n\u002Bendif()\n\u002B\n\u002B\n\u002B# Default to C\u002B\u002B17\n\u002Bif(NOT CMAKE_CXX_STANDARD)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\u002Bendif()\n\u002B\n\u002Bif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n\u002B  add_compile_options(-Wall -Wextra -Wpedantic)\n\u002Bendif()\n\u002B\n\u002Bfind_package(ament_cmake REQUIRED)\n\u002Bfind_package(rcutils REQUIRED)\n\u002Bfind_package(rmw REQUIRED)\n\u002B\n\u002Bament_add_default_options()\n\u002Bament_export_dependencies(rcutils)\n\u002B\n\u002Badd_library(${PROJECT_NAME}_library\n\u002B  src/security.cpp)\n\u002B\n\u002Bset_target_properties(${PROJECT_NAME}_library\n\u002B  PROPERTIES OUTPUT_NAME ${PROJECT_NAME})\n\u002Btarget_link_libraries(${PROJECT_NAME}_library PUBLIC\n\u002B  rcutils::rcutils\n\u002B  rmw::rmw)\n\u002Btarget_include_directories(${PROJECT_NAME}_library\n\u002B  PUBLIC\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\u0022)\n\u002B\n\u002B# Causes the visibility macros to use dllexport rather than dllimport,\n\u002B# which is appropriate when building the dll but not consuming it.\n\u002Btarget_compile_definitions(${PROJECT_NAME}_library\n\u002B  PRIVATE \u0022RMW_SECURITY_COMMON_BUILDING_LIBRARY\u0022)\n\u002B\n\u002Binstall(\n\u002B  TARGETS ${PROJECT_NAME}_library EXPORT ${PROJECT_NAME}_library\n\u002B  ARCHIVE DESTINATION lib\n\u002B  LIBRARY DESTINATION lib\n\u002B  RUNTIME DESTINATION bin\n\u002B)\n\u002B\n\u002B# Export old-style CMake variables\n\u002Bament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\n\u002Bament_export_libraries(${PROJECT_NAME}_library)\n\u002B\n\u002B# Export modern CMake targets\n\u002Bament_export_targets(${PROJECT_NAME}_library)\n\u002B\n\u002Binstall(\n\u002B  DIRECTORY include/\n\u002B  DESTINATION include/${PROJECT_NAME})\n\u002B\n\u002Bif(BUILD_TESTING)\n\u002B  find_package(ament_lint_auto REQUIRED)\n\u002B  find_package(ament_cmake_gmock REQUIRED)\n\u002B  ament_lint_auto_find_test_dependencies()\n\u002B\n\u002B  ament_add_gmock(test_security test/test_security.cpp)\n\u002B  if(TARGET test_security)\n\u002B    target_link_libraries(test_security\n\u002B      ${PROJECT_NAME}_library\n\u002B      rcutils::rcutils)\n\u002B  endif()\n\u002Bendif()\n\u002B\n\u002Bament_package()\ndiff --git rmw_security_common/include/rmw_security_common/security.hpp rmw_security_common/include/rmw_security_common/security.hpp\nnew file mode 100644\nindex 0000000..afc2985\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/include/rmw_security_common/security.hpp\n@@ -0,0 \u002B1,101 @@\n\u002B// Copyright 2025 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RMW_SECURITY_COMMON__SECURITY_HPP_\n\u002B#define RMW_SECURITY_COMMON__SECURITY_HPP_\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cunordered_map\u003E\n\u002B\n\u002B#include \u0022rcutils/types/string_map.h\u0022\n\u002B#include \u0022rmw/types.h\u0022\n\u002B#include \u0022rmw_security_common/visibility_control.h\u0022\n\u002B\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B/// Get the set of security files in a security enclave.\n\u002B/**\n\u002B * This function will look through the passed in \u0027secure root\u0027\n\u002B * for a set of required filenames that must be in the enclave.\n\u002B * If any of the required filenames are missing, the \u0027result\u0027\n\u002B * will be empty and the function will return false.\n\u002B * If all of the required filenames are present, then this function\n\u002B * will fill in the \u0027result\u0027 map with a key-value pair of\n\u002B * friendy name -\u003E filename.  If the prefix is not empty, then\n\u002B * the prefix will be applied to the filename.\n\u002B *\n\u002B * The friendly names that this function will currently fill in are:\n\u002B *   IDENTITY_CA\n\u002B *   CERTIFICATE\n\u002B *   PRIVATE_KEY\n\u002B *   PERMISSIONS_CA\n\u002B *   GOVERNANCE\n\u002B *   PERMISSIONS\n\u002B *\n\u002B * \\param[in]  prefix An optional prefix to apply to the filenames when storing them.\n\u002B * \\param[in]  secure_root The path to the security enclave to look at.\n\u002B * \\param[out] result The map where the friendly name -\u003E filename pairs are stored.\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any argument are invalid, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 an unexpected error occurs.\n\u002B */\n\u002BRMW_SECURITY_COMMON_PUBLIC\n\u002Brmw_ret_t get_security_files(\n\u002B  const char * prefix,\n\u002B  const char * secure_root,\n\u002B  rcutils_string_map_t * result);\n\u002B\n\u002B/// Get the set of security files in a security enclave.\n\u002B/**\n\u002B * This function will look through the passed in \u0027secure root\u0027\n\u002B * for a set of required filenames that must be in the enclave.\n\u002B * If any of the required filenames are missing, the \u0027result\u0027\n\u002B * will be empty and the function will return false.\n\u002B * If all of the required filenames are present, then this function\n\u002B * will fill in the \u0027result\u0027 map with a key-value pair of\n\u002B * friendy name -\u003E filename.  If the prefix is not empty, then\n\u002B * the prefix will be applied to the filename.\n\u002B *\n\u002B * The friendly names that this function will currently fill in are:\n\u002B *   IDENTITY_CA\n\u002B *   CERTIFICATE\n\u002B *   PRIVATE_KEY\n\u002B *   PERMISSIONS_CA\n\u002B *   GOVERNANCE\n\u002B *   PERMISSIONS\n\u002B *\n\u002B * \\param[in]  supports_pkcs11 Whether the RMW has support for PKCS#11 URIs.\n\u002B * \\param[in]  prefix An optional prefix to apply to the filenames when storing them.\n\u002B * \\param[in]  secure_root The path to the security enclave to look at.\n\u002B * \\param[out] result The map where the friendly name -\u003E filename pairs are stored.\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if any argument are invalid, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 an unexpected error occurs.\n\u002B */\n\u002BRMW_SECURITY_COMMON_PUBLIC\n\u002Brmw_ret_t get_security_files_support_pkcs(\n\u002B  bool supports_pkcs11,\n\u002B  const char * prefix,\n\u002B  const char * secure_root,\n\u002B  rcutils_string_map_t * result);\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // RMW_SECURITY_COMMON__SECURITY_HPP_\ndiff --git rmw_security_common/include/rmw_security_common/visibility_control.h rmw_security_common/include/rmw_security_common/visibility_control.h\nnew file mode 100644\nindex 0000000..f4c2f26\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/include/rmw_security_common/visibility_control.h\n@@ -0,0 \u002B1,58 @@\n\u002B// Copyright 2025 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_\n\u002B#define RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_\n\u002B\n\u002B#ifdef __cplusplus\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#endif\n\u002B\n\u002B// This logic was borrowed (then namespaced) from the examples on the gcc wiki:\n\u002B//     https://gcc.gnu.org/wiki/Visibility\n\u002B\n\u002B#if defined _WIN32 || defined __CYGWIN__\n\u002B  #ifdef __GNUC__\n\u002B    #define RMW_SECURITY_COMMON_EXPORT __attribute__ ((dllexport))\n\u002B    #define RMW_SECURITY_COMMON_IMPORT __attribute__ ((dllimport))\n\u002B  #else\n\u002B    #define RMW_SECURITY_COMMON_EXPORT __declspec(dllexport)\n\u002B    #define RMW_SECURITY_COMMON_IMPORT __declspec(dllimport)\n\u002B  #endif\n\u002B  #ifdef RMW_SECURITY_COMMON_BUILDING_LIBRARY\n\u002B    #define RMW_SECURITY_COMMON_PUBLIC RMW_SECURITY_COMMON_EXPORT\n\u002B  #else\n\u002B    #define RMW_SECURITY_COMMON_PUBLIC RMW_SECURITY_COMMON_IMPORT\n\u002B  #endif\n\u002B  #define RMW_SECURITY_COMMON_PUBLIC_TYPE RMW_SECURITY_COMMON_PUBLIC\n\u002B  #define RMW_SECURITY_COMMON_LOCAL\n\u002B#else\n\u002B  #define RMW_SECURITY_COMMON_EXPORT __attribute__ ((visibility(\u0022default\u0022)))\n\u002B  #define RMW_SECURITY_COMMON_IMPORT\n\u002B  #if __GNUC__ \u003E= 4\n\u002B    #define RMW_SECURITY_COMMON_PUBLIC __attribute__ ((visibility(\u0022default\u0022)))\n\u002B    #define RMW_SECURITY_COMMON_LOCAL  __attribute__ ((visibility(\u0022hidden\u0022)))\n\u002B  #else\n\u002B    #define RMW_SECURITY_COMMON_PUBLIC\n\u002B    #define RMW_SECURITY_COMMON_LOCAL\n\u002B  #endif\n\u002B  #define RMW_SECURITY_COMMON_PUBLIC_TYPE\n\u002B#endif\n\u002B\n\u002B#ifdef __cplusplus\n\u002B}\n\u002B#endif\n\u002B\n\u002B#endif  // RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_\ndiff --git rmw_security_common/package.xml rmw_security_common/package.xml\nnew file mode 100644\nindex 0000000..aa1be41\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/package.xml\n@@ -0,0 \u002B1,26 @@\n\u002B\u003C?xml version=\u00221.0\u0022?\u003E\n\u002B\u003C?xml-model href=\u0022http://download.ros.org/schema/package_format3.xsd\u0022 schematypens=\u0022http://www.w3.org/2001/XMLSchema\u0022?\u003E\n\u002B\u003Cpackage format=\u00223\u0022\u003E\n\u002B  \u003Cname\u003Ermw_security_common\u003C/name\u003E\n\u002B  \u003Cversion\u003E7.5.1\u003C/version\u003E\n\u002B  \u003Cdescription\u003EDefine a common rmw secutiry utils\u003C/description\u003E\n\u002B\n\u002B  \u003Cmaintainer email=\u0022alejandro@openrobotics.org\u0022\u003EAlejandro Hernandez Cordero\u003C/maintainer\u003E\n\u002B\n\u002B  \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B\n\u002B  \u003Cauthor email=\u0022alejandro@openrobotics.org\u0022\u003EAlejandro Hernandez Cordero\u003C/author\u003E\n\u002B\n\u002B  \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n\u002B\n\u002B  \u003Cdepend\u003Ercutils\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Ermw\u003C/depend\u003E\n\u002B\n\u002B  \u003Ctest_depend\u003Eament_cmake_gmock\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n\u002B\n\u002B  \u003Cexport\u003E\n\u002B    \u003Cbuild_type\u003Eament_cmake\u003C/build_type\u003E\n\u002B  \u003C/export\u003E\n\u002B\u003C/package\u003E\ndiff --git rmw_security_common/src/security.cpp rmw_security_common/src/security.cpp\nnew file mode 100644\nindex 0000000..b0e2e40\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/src/security.cpp\n@@ -0,0 \u002B1,175 @@\n\u002B// Copyright 2025 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cfilesystem\u003E\n\u002B#include \u003Cfstream\u003E\n\u002B#include \u003Cfunctional\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n\u002B#include \u003Cunordered_map\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B#include \u0022rmw/types.h\u0022\n\u002B\n\u002B#include \u0022rmw_security_common/security.hpp\u0022\n\u002B\n\u002B// Processor for security attributes with FILE URI\n\u002Bstatic bool process_file_uri_security_file(\n\u002B  bool /*supports_pkcs11*/,\n\u002B  const std::string \u0026 prefix,\n\u002B  const std::filesystem::path \u0026 full_path,\n\u002B  std::string \u0026 result)\n\u002B{\n\u002B  if (!std::filesystem::is_regular_file(full_path)) {\n\u002B    return false;\n\u002B  }\n\u002B  result = prefix \u002B full_path.generic_string();\n\u002B  return true;\n\u002B}\n\u002B\n\u002B// Processor for security attributes with PKCS#11 URI\n\u002Bstatic bool process_pkcs_uri_security_file(\n\u002B  bool supports_pkcs11,\n\u002B  const std::string \u0026 /*prefix*/,\n\u002B  const std::filesystem::path \u0026 full_path,\n\u002B  std::string \u0026 result)\n\u002B{\n\u002B  if (!supports_pkcs11) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  const std::string p11_prefix(\u0022pkcs11:\u0022);\n\u002B\n\u002B  std::ifstream ifs(full_path);\n\u002B  if (!ifs.is_open()) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  if (!(ifs \u003E\u003E result)) {\n\u002B    return false;\n\u002B  }\n\u002B  if (result.find(p11_prefix) != 0) {\n\u002B    return false;\n\u002B  }\n\u002B\n\u002B  return true;\n\u002B}\n\u002B\n\u002Brmw_ret_t get_security_files(\n\u002B  const char * prefix,\n\u002B  const char * secure_root,\n\u002B  rcutils_string_map_t * result)\n\u002B{\n\u002B  return get_security_files_support_pkcs(false, prefix, secure_root, result);\n\u002B}\n\u002B\n\u002Brmw_ret_t get_security_files_support_pkcs(\n\u002B  bool supports_pkcs11,\n\u002B  const char * prefix,\n\u002B  const char * secure_root,\n\u002B  rcutils_string_map_t * result)\n\u002B{\n\u002B  // check arguments that could be null\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(prefix, RMW_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(secure_root, RMW_RET_INVALID_ARGUMENT);\n\u002B  RCUTILS_CHECK_ARGUMENT_FOR_NULL(result, RMW_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  std::string prefix_std(prefix);\n\u002B  std::string secure_root_std(secure_root);\n\u002B\n\u002B  using std::placeholders::_1;\n\u002B  using std::placeholders::_2;\n\u002B  using std::placeholders::_3;\n\u002B  using std::placeholders::_4;\n\u002B  using security_file_processor =\n\u002B    std::function\u003Cbool (bool, const std::string \u0026, const std::filesystem::path \u0026, std::string \u0026)\u003E;\n\u002B  using processor_vector =\n\u002B    std::vector\u003Cstd::pair\u003Cstd::string, security_file_processor\u003E\u003E;\n\u002B\n\u002B  // Key: the security attribute\n\u002B  // Value: ordered sequence of pairs. Each pair contains one possible file name\n\u002B  //        for the attribute and the corresponding processor method\n\u002B  // Pairs are ordered by priority: the first one matching is used.\n\u002B  const std::unordered_map\u003Cstd::string, processor_vector\u003E required_files{\n\u002B    {\u0022IDENTITY_CA\u0022, {\n\u002B        {\u0022identity_ca.cert.p11\u0022, std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n\u002B        {\u0022identity_ca.cert.pem\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B    {\u0022CERTIFICATE\u0022, {\n\u002B        {\u0022cert.p11\u0022, std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n\u002B        {\u0022cert.pem\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B    {\u0022PRIVATE_KEY\u0022, {\n\u002B        {\u0022key.p11\u0022, std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n\u002B        {\u0022key.pem\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B    {\u0022PERMISSIONS_CA\u0022, {\n\u002B        {\u0022permissions_ca.cert.p11\u0022, std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n\u002B        {\u0022permissions_ca.cert.pem\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B    {\u0022GOVERNANCE\u0022, {\n\u002B        {\u0022governance.p7s\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B    {\u0022PERMISSIONS\u0022, {\n\u002B        {\u0022permissions.p7s\u0022, std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n\u002B  };\n\u002B\n\u002B  const std::unordered_map\u003Cstd::string, std::string\u003E optional_files{\n\u002B    {\u0022CRL\u0022, \u0022crl.pem\u0022},\n\u002B  };\n\u002B\n\u002B  std::unordered_map\u003Cstd::string, std::string\u003E result_std;\n\u002B\n\u002B  for (const std::pair\u003Cconst std::string,\n\u002B    std::vector\u003Cstd::pair\u003Cstd::string, security_file_processor\u003E\u003E\u003E \u0026 el : required_files)\n\u002B  {\n\u002B    std::string attribute_value;\n\u002B    bool processed = false;\n\u002B    for (auto \u0026 proc : el.second) {\n\u002B      std::filesystem::path full_path(secure_root_std);\n\u002B      full_path /= proc.first;\n\u002B      if (proc.second(supports_pkcs11, prefix_std, full_path, attribute_value)) {\n\u002B        processed = true;\n\u002B        break;\n\u002B      }\n\u002B    }\n\u002B    if (!processed) {\n\u002B      result_std.clear();\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B    result_std[el.first] = attribute_value;\n\u002B  }\n\u002B\n\u002B  for (const std::pair\u003Cconst std::string, std::string\u003E \u0026 el : optional_files) {\n\u002B    std::filesystem::path full_path(secure_root_std);\n\u002B    full_path /= el.second;\n\u002B    if (std::filesystem::is_regular_file(full_path)) {\n\u002B      result_std[el.first] = prefix_std \u002B full_path.generic_string();\n\u002B    }\n\u002B  }\n\u002B\n\u002B  rmw_ret_t ret;\n\u002B  ret = rcutils_string_map_reserve(result, result_std.size());\n\u002B\n\u002B  if (ret != RMW_RET_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to reserve memory for the string map\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  for (const auto \u0026 [key, value] : result_std) {\n\u002B    ret = rcutils_string_map_set(result, key.c_str(), value.c_str());\n\u002B    if (ret != RMW_RET_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to insert value in the string map\u0022);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return RMW_RET_OK;\n\u002B}\ndiff --git rmw_security_common/test/test_security.cpp rmw_security_common/test/test_security.cpp\nnew file mode 100644\nindex 0000000..16126be\n--- /dev/null\n\u002B\u002B\u002B rmw_security_common/test/test_security.cpp\n@@ -0,0 \u002B1,479 @@\n\u002B// Copyright 2025 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Carray\u003E\n\u002B#include \u003Ccstddef\u003E\n\u002B#include \u003Cfilesystem\u003E\n\u002B#include \u003Cfstream\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cunordered_map\u003E\n\u002B\n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rmw_security_common/security.hpp\u0022\n\u002B\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B\n\u002B// Utility to write test content on required files\n\u002Btemplate\u003Csize_t N\u003E\n\u002Bstatic void write_test_content(const std::array\u003Cstd::string, N\u003E \u0026 required_files)\n\u002B{\n\u002B  for (const std::string \u0026 filename : required_files) {\n\u002B    std::filesystem::path full_path = std::filesystem::path(\u0022./test_folder\u0022) / filename;\n\u002B    std::ofstream output_buffer{full_path.generic_string()};\n\u002B    output_buffer \u003C\u003C \u0022test\u0022;\n\u002B    ASSERT_TRUE(std::filesystem::exists(full_path));\n\u002B  }\n\u002B}\n\u002B\n\u002B// Utility to write pkcs11 content on required files\n\u002Btemplate\u003Csize_t N\u003E\n\u002Bstatic void write_test_pkcs11_content(const std::array\u003Cstd::string, N\u003E \u0026 pkcs11_files)\n\u002B{\n\u002B  for (const std::string \u0026 filename : pkcs11_files) {\n\u002B    std::filesystem::path full_path = std::filesystem::path(\u0022./test_folder\u0022) / filename;\n\u002B    std::ofstream output_buffer{full_path.generic_string()};\n\u002B    output_buffer \u003C\u003C \u0022pkcs11://\u0022 \u003C\u003C filename;\n\u002B    ASSERT_TRUE(std::filesystem::exists(full_path));\n\u002B  }\n\u002B}\n\u002B\n\u002Bclass test_security : public ::testing::TestWithParam\u003Cbool\u003E {};\n\u002B\n\u002BTEST_P(test_security, files_exist_no_prefix)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 6\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, files_exist_with_prefix)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 6\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, file_missing)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 5\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_ERROR,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  size_t capacity = 0;\n\u002B  ret = rcutils_string_map_get_capacity(\u0026security_files, \u0026capacity);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(capacity, 0UL);\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, optional_file_exist)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 7\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022, \u0022crl.pem\u0022,\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    rcutils_string_map_get(\u0026security_files, \u0022CRL\u0022),\n\u002B    std::filesystem::path(\u0022./test_folder/crl.pem\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, wrong_pkcs11_file_ignored)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 10\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022,\n\u002B    \u0022identity_ca.cert.p11\u0022, \u0022cert.p11\u0022, \u0022key.p11\u0022,\n\u002B    \u0022permissions_ca.cert.p11\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, pkcs11_support_check)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 6\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  std::array\u003Cstd::string, 4\u003E pkcs11_files = {\n\u002B    \u0022identity_ca.cert.p11\u0022, \u0022cert.p11\u0022, \u0022key.p11\u0022,\n\u002B    \u0022permissions_ca.cert.p11\u0022\n\u002B  };\n\u002B  write_test_pkcs11_content(pkcs11_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  if (GetParam()) {\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B      \u0022pkcs11://identity_ca.cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B      \u0022pkcs11://cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B      \u0022pkcs11://key.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B      \u0022pkcs11://permissions_ca.cert.p11\u0022);\n\u002B  } else {\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  }\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, only_pkcs11_present)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 2\u003E required_files = {\n\u002B    \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  std::array\u003Cstd::string, 4\u003E pkcs11_files = {\n\u002B    \u0022identity_ca.cert.p11\u0022, \u0022cert.p11\u0022, \u0022key.p11\u0022,\n\u002B    \u0022permissions_ca.cert.p11\u0022\n\u002B  };\n\u002B  write_test_pkcs11_content(pkcs11_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  if (GetParam()) {\n\u002B    ASSERT_EQ(RMW_RET_OK,\n\u002B      get_security_files_support_pkcs(\n\u002B        GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B      \u0022pkcs11://identity_ca.cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B      \u0022pkcs11://cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B      \u0022pkcs11://key.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B      \u0022pkcs11://permissions_ca.cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B      std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B  } else {\n\u002B    ASSERT_EQ(RMW_RET_ERROR,\n\u002B      get_security_files_support_pkcs(\n\u002B        GetParam(), \u0022\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B    size_t capacity = 0;\n\u002B    ret = rcutils_string_map_get_capacity(\u0026security_files, \u0026capacity);\n\u002B    ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B    ASSERT_EQ(capacity, 0UL);\n\u002B  }\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_P(test_security, pkcs11_prefix_ignored)\n\u002B{\n\u002B  std::filesystem::path dir = std::filesystem::path(\u0022./test_folder\u0022);\n\u002B  std::filesystem::remove_all(dir);\n\u002B  EXPECT_TRUE(std::filesystem::create_directories(dir));\n\u002B  EXPECT_TRUE(std::filesystem::exists(dir));\n\u002B  EXPECT_TRUE(std::filesystem::is_directory(dir));\n\u002B\n\u002B  std::array\u003Cstd::string, 6\u003E required_files = {\n\u002B    \u0022identity_ca.cert.pem\u0022, \u0022cert.pem\u0022, \u0022key.pem\u0022,\n\u002B    \u0022permissions_ca.cert.pem\u0022, \u0022governance.p7s\u0022, \u0022permissions.p7s\u0022\n\u002B  };\n\u002B  write_test_content(required_files);\n\u002B\n\u002B  std::array\u003Cstd::string, 4\u003E pkcs11_files = {\n\u002B    \u0022identity_ca.cert.p11\u0022, \u0022cert.p11\u0022, \u0022key.p11\u0022,\n\u002B    \u0022permissions_ca.cert.p11\u0022\n\u002B  };\n\u002B  write_test_pkcs11_content(pkcs11_files);\n\u002B\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B\n\u002B  ASSERT_EQ(RMW_RET_OK,\n\u002B    get_security_files_support_pkcs(\n\u002B      GetParam(), \u0022file://\u0022, dir.generic_string().c_str(), \u0026security_files));\n\u002B\n\u002B  if (GetParam()) {\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B      \u0022pkcs11://identity_ca.cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B      \u0022pkcs11://cert.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B      \u0022pkcs11://key.p11\u0022);\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B      \u0022pkcs11://permissions_ca.cert.p11\u0022);\n\u002B  } else {\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)),\n\u002B      \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/identity_ca.cert.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)),\n\u002B      \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/cert.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)),\n\u002B      \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/key.pem\u0022).generic_string());\n\u002B    EXPECT_EQ(\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)),\n\u002B      \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/permissions_ca.cert.pem\u0022).generic_string());\n\u002B  }\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)),\n\u002B    \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/governance.p7s\u0022).generic_string());\n\u002B  EXPECT_EQ(\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)),\n\u002B    \u0022file://\u0022 \u002B std::filesystem::path(\u0022./test_folder/permissions.p7s\u0022).generic_string());\n\u002B\n\u002B  ret = rcutils_string_map_fini(\u0026security_files);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BINSTANTIATE_TEST_SUITE_P(\n\u002B  test_security,\n\u002B  test_security,\n\u002B  ::testing::Values(false, true),\n\u002B  [](const testing::TestParamInfo\u003Cbool\u003E \u0026 info) {\n\u002B    return info.param ? \u0022with_pkcs11_support\u0022 : \u0022with_no_pkcs11_support\u0022;\n\u002B  });\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "e46f124c2ab9af6889242b791dff84568ef27651",
    "RawMessage": "Restrict overmatching MACH ifdef to only trigger on OSX and Mach (#386)",
    "Changes": "diff --git src/time_unix.c src/time_unix.c\nindex d0363e9..fc7ddcd 100644\n--- src/time_unix.c\n\u002B\u002B\u002B src/time_unix.c\n@@ -23,10 \u002B23,10 @@ extern \u0022C\u0022\n \n #include \u0022rcutils/time.h\u0022\n \n-#if defined(__MACH__)\n\u002B#if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n #include \u003Cmach/clock.h\u003E\n #include \u003Cmach/mach.h\u003E\n-#endif  // defined(__MACH__)\n\u002B#endif  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n #include \u003Cmath.h\u003E\n \n #if defined(__ZEPHYR__)\n@@ -40,13 \u002B40,13 @@ extern \u0022C\u0022\n #include \u0022rcutils/allocator.h\u0022\n #include \u0022rcutils/error_handling.h\u0022\n \n-#if !defined(__MACH__)  // Assume clock_get_time is available on OS X.\n\u002B#if !defined(__MACH__) \u0026\u0026 !defined(__APPLE__)   // Assume clock_get_time is available on OS X.\n // This id an appropriate check for clock_gettime() according to:\n //   http://man7.org/linux/man-pages/man2/clock_gettime.2.html\n # if !defined(_POSIX_TIMERS) || !_POSIX_TIMERS\n #  error no monotonic clock function available\n # endif  // !defined(_POSIX_TIMERS) || !_POSIX_TIMERS\n-#endif  // !defined(__MACH__)\n\u002B#endif  // !defined(__MACH__) \u0026\u0026 !defined(__APPLE__)\n \n #define __WOULD_BE_NEGATIVE(seconds, subseconds) (seconds \u003C 0 || (subseconds \u003C 0 \u0026\u0026 seconds == 0))\n \n@@ -55,15 \u002B55,15 @@ rcutils_system_time_now(rcutils_time_point_value_t * now)\n {\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(now, RCUTILS_RET_INVALID_ARGUMENT);\n   struct timespec timespec_now;\n-#if defined(__MACH__)\n\u002B#if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   // On macOS, use clock_gettime(CLOCK_REALTIME), which matches\n   // the clang implementation\n   // (https://github.com/llvm/llvm-project/blob/baebe12ad0d6f514cd33e418d6504075d3e79c0a/libcxx/src/chrono.cpp)\n   clock_gettime(CLOCK_REALTIME, \u0026timespec_now);\n-#else  // defined(__MACH__)\n\u002B#else  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   // Otherwise use clock_gettime.\n   clock_gettime(CLOCK_REALTIME, \u0026timespec_now);\n-#endif  // defined(__MACH__)\n\u002B#endif  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   if (__WOULD_BE_NEGATIVE(timespec_now.tv_sec, timespec_now.tv_nsec)) {\n     RCUTILS_SET_ERROR_MSG(\u0022unexpected negative time\u0022);\n     return RCUTILS_RET_ERROR;\n@@ -78,15 \u002B78,15 @@ rcutils_steady_time_now(rcutils_time_point_value_t * now)\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(now, RCUTILS_RET_INVALID_ARGUMENT);\n   // If clock_gettime is available or on OS X, use a timespec.\n   struct timespec timespec_now;\n-#if defined(__MACH__)\n\u002B#if defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   // On macOS, use clock_gettime(CLOCK_MONOTONIC_RAW), which matches\n   // the clang implementation\n   // (https://github.com/llvm/llvm-project/blob/baebe12ad0d6f514cd33e418d6504075d3e79c0a/libcxx/src/chrono.cpp)\n   clock_gettime(CLOCK_MONOTONIC_RAW, \u0026timespec_now);\n-#else  // defined(__MACH__)\n\u002B#else  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   // Otherwise use clock_gettime.\n   clock_gettime(CLOCK_MONOTONIC, \u0026timespec_now);\n-#endif  // defined(__MACH__)\n\u002B#endif  // defined(__MACH__) \u0026\u0026 defined(__APPLE__)\n   if (__WOULD_BE_NEGATIVE(timespec_now.tv_sec, timespec_now.tv_nsec)) {\n     RCUTILS_SET_ERROR_MSG(\u0022unexpected negative time\u0022);\n     return RCUTILS_RET_ERROR;\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "3fa62f4f8fa9b3cc624879e9c085ad19aa9c1977",
    "RawMessage": "Update maintainers (#254)",
    "Changes": "diff --git rmw_cyclonedds_cpp/package.xml rmw_cyclonedds_cpp/package.xml\nindex 20791cc..7f960f8 100644\n--- rmw_cyclonedds_cpp/package.xml\n\u002B\u002B\u002B rmw_cyclonedds_cpp/package.xml\n@@ -5,6 \u002B5,7 @@\n   \u003Cversion\u003E0.18.3\u003C/version\u003E\n   \u003Cdescription\u003EImplement the ROS middleware interface using Eclipse CycloneDDS in C\u002B\u002B.\u003C/description\u003E\n   \u003Cmaintainer email=\u0022erik.boasson@adlinktech.com\u0022\u003EErik Boasson\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022ivanpauno@ekumenlabs.com\u0022\u003EIvan Paunovic\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake_ros\u003C/buildtool_depend\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl_logging",
    "SHA": "220ba6fc20496c902804f7589455477dfd21705c",
    "RawMessage": "ament_export_dependencies any package with targets we linked against (#89)",
    "Changes": "diff --git rcl_logging_spdlog/CMakeLists.txt rcl_logging_spdlog/CMakeLists.txt\nindex 896c995..611d016 100644\n--- rcl_logging_spdlog/CMakeLists.txt\n\u002B\u002B\u002B rcl_logging_spdlog/CMakeLists.txt\n@@ -65,8 \u002B65,11 @@ if(BUILD_TESTING)\n   endif()\n endif()\n \n-# Export rcl_logging_interface to give downstream packages access to it\u0027s headers\n ament_export_dependencies(rcl_logging_interface)\n\u002Bament_export_dependencies(rcpputils)\n\u002Bament_export_dependencies(rcutils)\n\u002Bament_export_dependencies(spdlog_vendor)\n\u002Bament_export_dependencies(spdlog)\n ament_export_libraries(${PROJECT_NAME})\n ament_export_targets(${PROJECT_NAME})\n ament_package()\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "1bbb03302a0eb36955e7ecc19189b9f6bbadcd6f",
    "RawMessage": "Add in a fix for older compilers. (#2075)",
    "Changes": "diff --git rclcpp/include/rclcpp/node_interfaces/node_interfaces.hpp rclcpp/include/rclcpp/node_interfaces/node_interfaces.hpp\nindex 2f40380c..97959145 100644\n--- rclcpp/include/rclcpp/node_interfaces/node_interfaces.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_interfaces/node_interfaces.hpp\n@@ -147,12 \u002B147,6 @@ public:\n   : NodeInterfacesSupportsT(node)\n   {}\n \n-  /// NodeT::SharedPtr Constructor\n-  template\u003Ctypename NodeT\u003E\n-  NodeInterfaces(std::shared_ptr\u003CNodeT\u003E node)  // NOLINT(runtime/explicit)\n-  : NodeInterfaces(node ? *node : throw std::invalid_argument(\u0022given node pointer is nullptr\u0022))\n-  {}\n-\n   explicit NodeInterfaces(std::shared_ptr\u003CInterfaceTs\u003E... args)\n   : NodeInterfacesSupportsT(args ...)\n   {}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_interfaces.cpp rclcpp/test/rclcpp/node_interfaces/test_node_interfaces.cpp\nindex 96596dea..ebb91c47 100644\n--- rclcpp/test/rclcpp/node_interfaces/test_node_interfaces.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_interfaces.cpp\n@@ -44,7 \u002B44,7 @@ TEST_F(TestNodeInterfaces, node_interfaces_nominal) {\n     using rclcpp::node_interfaces::NodeInterfaces;\n     using rclcpp::node_interfaces::NodeBaseInterface;\n     using rclcpp::node_interfaces::NodeGraphInterface;\n-    auto node_interfaces = NodeInterfaces\u003CNodeBaseInterface, NodeGraphInterface\u003E(node);\n\u002B    auto node_interfaces = NodeInterfaces\u003CNodeBaseInterface, NodeGraphInterface\u003E(*node);\n   }\n \n   // Implicit conversion of rclcpp::Node into function that uses NodeInterfaces of base.\n@@ -55,7 \u002B55,7 @@ TEST_F(TestNodeInterfaces, node_interfaces_nominal) {\n         auto base_interface = ni.get\u003CNodeBaseInterface\u003E();\n       };\n \n-    some_func(node);\n\u002B    some_func(*node);\n   }\n \n   // Implicit narrowing of NodeInterfaces into a new interface NodeInterfaces with fewer interfaces.\n@@ -67,7 \u002B67,7 @@ TEST_F(TestNodeInterfaces, node_interfaces_nominal) {\n         auto base_interface = ni_with_one.get\u003CNodeBaseInterface\u003E();\n       };\n \n-    NodeInterfaces\u003CNodeBaseInterface, NodeGraphInterface\u003E ni_with_two(node);\n\u002B    NodeInterfaces\u003CNodeBaseInterface, NodeGraphInterface\u003E ni_with_two(*node);\n \n     some_func(ni_with_two);\n   }\n@@ -102,7 \u002B102,7 @@ TEST_F(TestNodeInterfaces, node_interfaces_standard_interfaces) {\n     rclcpp::node_interfaces::NodeWaitablesInterface,\n     rclcpp::node_interfaces::NodeParametersInterface,\n     rclcpp::node_interfaces::NodeTimeSourceInterface\n-    \u003E(node);\n\u002B    \u003E(*node);\n }\n \n /*\n@@ -134,7 \u002B134,7 @@ TEST_F(TestNodeInterfaces, ni_init) {\n     NodeWaitablesInterface,\n     NodeParametersInterface,\n     NodeTimeSourceInterface\n-    \u003E(node);\n\u002B    \u003E(*node);\n \n   {\n     auto base = ni.get\u003CNodeBaseInterface\u003E();\n@@ -198,7 \u002B198,7 @@ TEST_F(TestNodeInterfaces, ni_all_init) {\n   using rclcpp::node_interfaces::NodeParametersInterface;\n   using rclcpp::node_interfaces::NodeTimeSourceInterface;\n \n-  auto ni = rclcpp::node_interfaces::NodeInterfaces\u003CALL_RCLCPP_NODE_INTERFACES\u003E(node);\n\u002B  auto ni = rclcpp::node_interfaces::NodeInterfaces\u003CALL_RCLCPP_NODE_INTERFACES\u003E(*node);\n \n   {\n     auto base = ni.get\u003CNodeBaseInterface\u003E();\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "0176872b10ff502ae34fa3eef5e900145f18b0b3",
    "RawMessage": "Update subscription API documentation (#256)",
    "Changes": "diff --git rmw/include/rmw/rmw.h rmw/include/rmw/rmw.h\nindex 6fa1f6e..d57809d 100644\n--- rmw/include/rmw/rmw.h\n\u002B\u002B\u002B rmw/include/rmw/rmw.h\n@@ -637,14 \u002B637,38 @@ rmw_ret_t\n rmw_fini_subscription_allocation(\n   rmw_subscription_allocation_t * allocation);\n \n-/// Create and return an rmw subscription.\n\u002B/// Create a subscription and return a handle to that subscription.\n /**\n- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n\u002B * This function can fail, and therefore return \u0060NULL\u0060, if:\n\u002B *   - node is not a valid non-null handle for this rmw implementation,\n\u002B *     as returned by \u0060rmw_create_node()\u0060\n\u002B *   - type_support is a not valid non-null message type support, as returned by\n\u002B *     \u0060ROSIDL_GET_MSG_TYPE_SUPPORT()\u0060\n\u002B *   - topic_name is not a valid non-null topic name, according to\n\u002B *     \u0060rmw_validate_full_topic_name()\u0060 if ROS namespace conventions apply\n\u002B *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n\u002B *   - subscription_options is not a valid non-null option set, such as the one\n\u002B *     returned by \u0060rmw_get_default_subscription_options()\u0060\n\u002B *   - memory allocation fails during subscription creation\n\u002B *   - an unspecified error occurs\n  *\n- * The argument \u0060subscription_options\u0060 must not be nullptr.\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Yes\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n  *\n- * \\param[in] subscription_options options for configuring the subscription\n\u002B * \\param[in] node Handle to node with which to register this subscription\n\u002B * \\param[in] type_support Type support for the messages to be subscribed to\n\u002B * \\param[in] topic_name Name of the topic to subscribe to, often a fully qualified\n\u002B *   topic name unless \u0060qos_profile\u0060 is configured to avoid ROS namespace conventions\n\u002B *   i.e. to create a native topic subscription\n\u002B * \\param[in] qos_profile QoS policies for this subscription\n\u002B * \\param[in] subscription_options Options for configuring this subscription\n\u002B * \\return rmw subscription handle, or \u0060NULL\u0060 if there was an error\n  */\n RMW_PUBLIC\n RMW_WARN_UNUSED\n@@ -656,6 \u002B680,35 @@ rmw_create_subscription(\n   const rmw_qos_profile_t * qos_policies,\n   const rmw_subscription_options_t * subscription_options);\n \n\u002B/// Finalize a given subscription handle, reclaim the resources, and deallocate the subscription\n\u002B/// handle.\n\u002B/**\n\u002B * This function will return early if a logical error, namely \u0060RMW_RET_INVALID_ARGUMENT\u0060\n\u002B * or \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060, ensues, leaving the given subscription handle\n\u002B * unchanged.\n\u002B * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n\u002B * the subscription handle, and return \u0060RMW_RET_ERROR\u0060. Usage of a deallocated subscription\n\u002B * handle is undefined behavior.\n\u002B *\n\u002B * \\pre Given node must be the one the subscription was registered with.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | No\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n\u002B *\n\u002B * \\param[in] node Handle to node with which the given subscription is registered\n\u002B * \\param[in] subscription Handle to subscription to be finalized\n\u002B * \\return \u0060RMW_RET_OK\u0060 if successful, or\n\u002B * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if node or subscription is \u0060NULL\u0060, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if node or subscription\n\u002B *   implementation identifier does not match, or\n\u002B * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n\u002B */\n RMW_PUBLIC\n RMW_WARN_UNUSED\n rmw_ret_t\n@@ -696,6 \u002B749,8 @@ rmw_subscription_count_matched_publishers(\n  * \\param[out] qos the actual qos settings\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if either argument is null, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if subscription\n\u002B *   implementation identifier does not match, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "e33105057cf64477d598ff79e9a2a226abd73f38",
    "RawMessage": "Document design decisions that were made for statically typed parameters (#1568)",
    "Changes": "diff --git rclcpp/doc/notes_on_statically_typed_parameters.md rclcpp/doc/notes_on_statically_typed_parameters.md\nnew file mode 100644\nindex 00000000..b96866c6\n--- /dev/null\n\u002B\u002B\u002B rclcpp/doc/notes_on_statically_typed_parameters.md\n@@ -0,0 \u002B1,141 @@\n\u002B# Notes on statically typed parameters\n\u002B\n\u002B## Introduction\n\u002B\n\u002BUntil ROS 2 Foxy, all parameters could change type anytime, except if the user installed a parameter callback to reject a change.\n\u002BThis could generate confusing errors, for example:\n\u002B\n\u002B\u0060\u0060\u0060\n\u002B$ ros2 run demo_nodes_py listener \u0026\n\u002B$ ros2 param set /listener use_sim_time not_a_boolean\n\u002B[ERROR] [1614712713.233733147] [listener]: use_sim_time parameter set to something besides a bool\n\u002BSet parameter successful\n\u002B$ ros2 param get /listener use_sim_time\n\u002BString value is: not_a_boolean\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BFor most use cases, having static parameter types is enough.\n\u002BThis article documents some of the decisions that were made when implementing static parameter types enforcement in:\n\u002B\n\u002B* https://github.com/ros2/rclcpp/pull/1522\n\u002B* https://github.com/ros2/rclpy/pull/683\n\u002B\n\u002B## Allowing dynamically typed parameters\n\u002B\n\u002BThere might be some scenarios where dynamic typing is desired, so a \u0060dynamic_typing\u0060 field was added to the [parameter descriptor](https://github.com/ros2/rcl_interfaces/blob/09b5ed93a733adb9deddc47f9a4a8c6e9f584667/rcl_interfaces/msg/ParameterDescriptor.msg#L25).\n\u002BIt defaults to \u0060false\u0060.\n\u002B\n\u002BFor example:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Brcl_interfaces::msg::ParameterDescriptor descriptor;\n\u002Bdescriptor.dynamic_typing = true;\n\u002B\n\u002Bnode-\u003Edeclare_parameter(\u0022dynamically_typed_parameter\u0022, rclcpp::ParameterValue{}, descriptor);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B\u0060\u0060\u0060py\n\u002Brcl_interfaces.msg.ParameterDescriptor descriptor;\n\u002Bdescriptor.dynamic_typing = True;\n\u002B\n\u002Bnode.declare_parameter(\u0022dynamically_typed_parameter\u0022, None, descriptor);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B## How is the parameter type specified?\n\u002B\n\u002BThe parameter type will be inferred from the default value provided when declaring it.\n\u002B\n\u002B## Statically typed parameters when allowing undeclared parameters\n\u002B\n\u002BWhen undeclared parameters are allowed and a parameter is set without a previous declaration, the parameter will be dynamically typed.\n\u002BThis is consistent with other allowed behaviors when undeclared parameters are allowed, e.g. trying to get an undeclared parameter returns \u0022NOT_SET\u0022.\n\u002BParameter declarations will remain special and dynamic or static typing will be used based on the parameter descriptor (default to static).\n\u002B\n\u002B## Declaring a parameter without a default value\n\u002B\n\u002BThere might be cases were a default value does not make sense and the user must always provide an override.\n\u002BIn those cases, the parameter type can be specified explicitly:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002B// method signature\n\u002Btemplate\u003Ctypename T\u003E\n\u002BNode::declare_parameter\u003CT\u003E(std::string name, rcl_interfaces::msg::ParameterDescriptor = rcl_interfaces::msg::ParameterDescriptor{});\n\u002B// or alternatively\n\u002BNode::declare_parameter(std::string name, rclcpp::ParameterType type, rcl_interfaces::msg::ParameterDescriptor = rcl_interfaces::msg::ParameterDescriptor{});\n\u002B\n\u002B// examples\n\u002Bnode-\u003Edeclare_parameter\u003Cint64_t\u003E(\u0022my_integer_parameter\u0022);  // declare an integer parameter\n\u002Bnode-\u003Edeclare_parameter(\u0022another_integer_parameter\u0022, rclcpp::ParameterType::PARAMETER_INTEGER);  // another way to do the same\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B\u0060\u0060\u0060py\n\u002B# method signature\n\u002BNode.declare_parameter(name: str, param_type: rclpy.Parameter.Type, descriptor: rcl_interfaces.msg.ParameterDescriptor = rcl_interfaces.msg.ParameterDescriptor())\n\u002B\n\u002B# example\n\u002Bnode.declare_parameter(\u0027my_integer_parameter\u0027, rclpy.Parameter.Type.INTEGER);  # declare an integer parameter\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BIf the parameter may be unused, but when used requires a parameter override, then you could conditionally declare it:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bauto mode = node-\u003Edeclare_parameter(\u0022mode\u0022, \u0022modeA\u0022);  // \u0022mode\u0022 parameter is an string\n\u002Bif (mode == \u0022modeB\u0022) {\n\u002B    node-\u003Edeclare_parameter\u003Cint64_t\u003E(\u0022param_needed_when_mode_b\u0022);  // when \u0022modeB\u0022, the user must provide \u0022param_needed_when_mode_b\u0022\n\u002B}\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B## Other migration notes\n\u002B\n\u002BDeclaring a parameter with only a name is deprecated:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bnode-\u003Edeclare_parameter(\u0022my_param\u0022);  // this generates a build warning\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B\u0060\u0060\u0060py\n\u002Bnode.declare_parameter(\u0022my_param\u0022);  # this generates a python user warning\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BBefore, you could initialize a parameter with the \u0022NOT SET\u0022 value (in cpp \u0060rclcpp::ParameterValue{}\u0060, in python \u0060None\u0060).\n\u002BNow this will throw an exception in both cases:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bnode-\u003Edeclare_parameter(\u0022my_param\u0022, rclcpp::ParameterValue{});  // not valid, will throw exception\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B\u0060\u0060\u0060py\n\u002Bnode.declare_parameter(\u0022my_param\u0022, None);  # not valid, will raise error\n\u002B\u0060\u0060\u0060\n\u002B\n\u002B## Possible improvements\n\u002B\n\u002B### Easier way to declare dynamically typed parameters\n\u002B\n\u002BDeclaring a dynamically typed parameter in \u0060rclcpp\u0060 could be considered to be a bit verbose:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Brcl_interfaces::msg::ParameterDescriptor descriptor;\n\u002Bdescriptor.dynamic_typing = true;\n\u002B\n\u002Bnode-\u003Edeclare_parameter(name, rclcpp::ParameterValue{}, descriptor);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Bthe following ways could be supported to make it simpler:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bnode-\u003Edeclare_parameter(name, rclcpp::PARAMETER_DYNAMIC);\n\u002Bnode-\u003Edeclare_parameter(name, default_value, rclcpp::PARAMETER_DYNAMIC);\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Bor alternatively:\n\u002B\n\u002B\u0060\u0060\u0060cpp\n\u002Bnode-\u003Edeclare_parameter(name, default_value, rclcpp::ParameterDescriptor{}.dynamic_typing());\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BFor \u0060rclpy\u0060, there\u0027s already a short way to do it:\n\u002B\n\u002B\u0060\u0060\u0060py\n\u002Bnode.declare_parameter(name, default_value, rclpy.ParameterDescriptor(dynamic_typing=true));\n\u002B\u0060\u0060\u0060\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "48d8f65a227c9a3a34c644a7adebf193000442d0",
    "RawMessage": "Fix error message in rmw_init_options_copy() (#380)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 31e97f4..485eee5 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -746,7 \u002B746,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_init_options_copy(const rmw_init_options_t * src, rmw_i\n   RMW_CHECK_ARGUMENT_FOR_NULL(src, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(dst, RMW_RET_INVALID_ARGUMENT);\n   if (NULL == src-\u003Eimplementation_identifier) {\n-    RMW_SET_ERROR_MSG(\u0022expected initialized dst\u0022);\n\u002B    RMW_SET_ERROR_MSG(\u0022expected initialized src\u0022);\n     return RMW_RET_INVALID_ARGUMENT;\n   }\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "91bc312190e61c8915b0152e5c927c987fc22d6c",
    "RawMessage": "fix a case that not throw ParameterUninitializedException (#2036)",
    "Changes": "diff --git rclcpp/include/rclcpp/node.hpp rclcpp/include/rclcpp/node.hpp\nindex e514137b..7ecb67e9 100644\n--- rclcpp/include/rclcpp/node.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node.hpp\n@@ -740,17 \u002B740,21 @@ public:\n   /**\n    * If the parameter has not been declared, then this method may throw the\n    * rclcpp::exceptions::ParameterNotDeclaredException exception.\n\u002B   * If the parameter has not been initialized, then this method may throw the\n\u002B   * rclcpp::exceptions::ParameterUninitializedException exception.\n    *\n    * If undeclared parameters are allowed, see the node option\n    * rclcpp::NodeOptions::allow_undeclared_parameters, then this method will\n-   * not throw an exception, and instead return a default initialized\n-   * rclcpp::Parameter, which has a type of\n\u002B   * not throw the rclcpp::exceptions::ParameterNotDeclaredException exception,\n\u002B   * and instead return a default initialized rclcpp::Parameter, which has a type of\n    * rclcpp::ParameterType::PARAMETER_NOT_SET.\n    *\n    * \\param[in] name The name of the parameter to get.\n    * \\return The requested parameter inside of a rclcpp parameter object.\n    * \\throws rclcpp::exceptions::ParameterNotDeclaredException if the parameter\n    *   has not been declared and undeclared parameters are not allowed.\n\u002B   * \\throws rclcpp::exceptions::ParameterUninitializedException if the parameter\n\u002B   *   has not been initialized.\n    */\n   RCLCPP_PUBLIC\n   rclcpp::Parameter\n@@ -834,12 \u002B838,12 @@ public:\n \n   /// Return the parameters by the given parameter names.\n   /**\n-   * Like get_parameters(), this method may throw the\n\u002B   * Like get_parameter(const std::string \u0026), this method may throw the\n    * rclcpp::exceptions::ParameterNotDeclaredException exception if the\n    * requested parameter has not been declared and undeclared parameters are\n-   * not allowed.\n\u002B   * not allowed, and may throw the rclcpp::exceptions::ParameterUninitializedException exception.\n    *\n-   * Also like get_parameters(), if undeclared parameters are allowed and the\n\u002B   * Also like get_parameter(const std::string \u0026), if undeclared parameters are allowed and the\n    * parameter has not been declared, then the corresponding rclcpp::Parameter\n    * will be default initialized and therefore have the type\n    * rclcpp::ParameterType::PARAMETER_NOT_SET.\n@@ -849,6 \u002B853,8 @@ public:\n    * \\throws rclcpp::exceptions::ParameterNotDeclaredException if any of the\n    *   parameters have not been declared and undeclared parameters are not\n    *   allowed.\n\u002B   * \\throws rclcpp::exceptions::ParameterUninitializedException if any of the\n\u002B   *   parameters have not been initialized.\n    */\n   RCLCPP_PUBLIC\n   std::vector\u003Crclcpp::Parameter\u003E\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\nindex c17eb887..9dafcba3 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_parameters.cpp\n@@ -904,22 \u002B904,12 @@ NodeParameters::set_parameters_atomically(const std::vector\u003Crclcpp::Parameter\u003E \u0026\n std::vector\u003Crclcpp::Parameter\u003E\n NodeParameters::get_parameters(const std::vector\u003Cstd::string\u003E \u0026 names) const\n {\n-  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(mutex_);\n   std::vector\u003Crclcpp::Parameter\u003E results;\n   results.reserve(names.size());\n \n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E lock(mutex_);\n   for (auto \u0026 name : names) {\n-    auto found_parameter = parameters_.find(name);\n-    if (found_parameter != parameters_.cend()) {\n-      // found\n-      results.emplace_back(name, found_parameter-\u003Esecond.value);\n-    } else if (this-\u003Eallow_undeclared_) {\n-      // not found, but undeclared allowed\n-      results.emplace_back(name, rclcpp::ParameterValue());\n-    } else {\n-      // not found, and undeclared are not allowed\n-      throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n-    }\n\u002B    results.emplace_back(this-\u003Eget_parameter(name));\n   }\n   return results;\n }\n@@ -930,18 \u002B920,18 @@ NodeParameters::get_parameter(const std::string \u0026 name) const\n   std::lock_guard\u003Cstd::recursive_mutex\u003E lock(mutex_);\n \n   auto param_iter = parameters_.find(name);\n-  if (\n-    parameters_.end() != param_iter \u0026\u0026\n-    (param_iter-\u003Esecond.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n-    param_iter-\u003Esecond.descriptor.dynamic_typing))\n-  {\n-    return rclcpp::Parameter{name, param_iter-\u003Esecond.value};\n\u002B  if (parameters_.end() != param_iter) {\n\u002B    if (\n\u002B      param_iter-\u003Esecond.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n\u002B      param_iter-\u003Esecond.descriptor.dynamic_typing)\n\u002B    {\n\u002B      return rclcpp::Parameter{name, param_iter-\u003Esecond.value};\n\u002B    }\n\u002B    throw rclcpp::exceptions::ParameterUninitializedException(name);\n   } else if (this-\u003Eallow_undeclared_) {\n-    return rclcpp::Parameter{};\n-  } else if (parameters_.end() == param_iter) {\n-    throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n\u002B    return rclcpp::Parameter{name};\n   } else {\n-    throw rclcpp::exceptions::ParameterUninitializedException(name);\n\u002B    throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n   }\n }\n \ndiff --git rclcpp/src/rclcpp/parameter_service.cpp rclcpp/src/rclcpp/parameter_service.cpp\nindex 501ac399..09237983 100644\n--- rclcpp/src/rclcpp/parameter_service.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/parameter_service.cpp\n@@ -48,6 \u002B48,8 @@ ParameterService::ParameterService(\n         }\n       } catch (const rclcpp::exceptions::ParameterNotDeclaredException \u0026 ex) {\n         RCLCPP_DEBUG(rclcpp::get_logger(\u0022rclcpp\u0022), \u0022Failed to get parameters: %s\u0022, ex.what());\n\u002B      } catch (const rclcpp::exceptions::ParameterUninitializedException \u0026 ex) {\n\u002B        RCLCPP_DEBUG(rclcpp::get_logger(\u0022rclcpp\u0022), \u0022Failed to get parameters: %s\u0022, ex.what());\n       }\n     },\n     qos_profile, nullptr);\ndiff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex c40811a4..19c87b36 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -3346,6 \u002B3346,9 @@ TEST_F(TestNode, static_and_dynamic_typing) {\n     EXPECT_THROW(\n       node-\u003Eget_parameter(\u0022integer_override_not_given\u0022),\n       rclcpp::exceptions::ParameterUninitializedException);\n\u002B    EXPECT_THROW(\n\u002B      node-\u003Eget_parameters({\u0022integer_override_not_given\u0022}),\n\u002B      rclcpp::exceptions::ParameterUninitializedException);\n   }\n   {\n     auto param = node-\u003Edeclare_parameter(\u0022integer_set_after_declare\u0022, rclcpp::PARAMETER_INTEGER);\n@@ -3367,3 \u002B3370,34 @@ TEST_F(TestNode, static_and_dynamic_typing) {\n       rclcpp::exceptions::InvalidParameterTypeException);\n   }\n }\n\u002B\n\u002BTEST_F(TestNode, parameter_uninitialized_exception_even_if_allow_undeclared) {\n\u002B  rclcpp::NodeOptions no;\n\u002B  no.allow_undeclared_parameters(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022, no);\n\u002B  {\n\u002B    const std::string param_name = \u0022integer_override_not_given\u0022;\n\u002B    auto param_value = node-\u003Edeclare_parameter(param_name, rclcpp::PARAMETER_INTEGER);\n\u002B    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param_value.get_type());\n\u002B    // Throws if not set before access\n\u002B    EXPECT_THROW(\n\u002B      node-\u003Eget_parameter(param_name),\n\u002B      rclcpp::exceptions::ParameterUninitializedException);\n\u002B    EXPECT_THROW(\n\u002B      node-\u003Eget_parameters({param_name}),\n\u002B      rclcpp::exceptions::ParameterUninitializedException);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestNode, get_parameter_with_node_allow_undeclared) {\n\u002B  rclcpp::NodeOptions no;\n\u002B  no.allow_undeclared_parameters(true);\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022, no);\n\u002B  {\n\u002B    const std::string param_name = \u0022allow_undeclared_param\u0022;\n\u002B    auto param = node-\u003Eget_parameter(param_name);\n\u002B    EXPECT_EQ(param_name, param.get_name());\n\u002B    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n\u002B    EXPECT_EQ(rclcpp::ParameterValue{}, param.get_parameter_value());\n\u002B  }\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_parameter_client.cpp rclcpp/test/rclcpp/test_parameter_client.cpp\nindex 64ef2d90..2ce414d3 100644\n--- rclcpp/test/rclcpp/test_parameter_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_parameter_client.cpp\n@@ -440,6 \u002B440,7 @@ TEST_F(TestParameterClient, sync_parameter_get_parameter_types_allow_undeclared)\n TEST_F(TestParameterClient, sync_parameter_get_parameters) {\n   node-\u003Edeclare_parameter(\u0022foo\u0022, 4);\n   node-\u003Edeclare_parameter(\u0022bar\u0022, \u0022this is bar\u0022);\n\u002B  node-\u003Edeclare_parameter(\u0022baz\u0022, rclcpp::PARAMETER_INTEGER);\n   auto synchronous_client = std::make_shared\u003Crclcpp::SyncParametersClient\u003E(node);\n \n   {\n@@ -448,6 \u002B449,14 @@ TEST_F(TestParameterClient, sync_parameter_get_parameters) {\n     ASSERT_EQ(0u, parameters.size());\n   }\n \n\u002B  {\n\u002B    // not throw ParameterUninitializedException while getting parameter from service\n\u002B    // even if the parameter is not initialized in the node\n\u002B    std::vector\u003Cstd::string\u003E names{\u0022baz\u0022};\n\u002B    std::vector\u003Crclcpp::Parameter\u003E parameters = synchronous_client-\u003Eget_parameters(names, 10s);\n\u002B    ASSERT_EQ(0u, parameters.size());\n\u002B  }\n\u002B\n   {\n     std::vector\u003Cstd::string\u003E names{\u0022none\u0022, \u0022foo\u0022, \u0022bar\u0022};\n     std::vector\u003Crclcpp::Parameter\u003E parameters = synchronous_client-\u003Eget_parameters(names, 10s);\n@@ -487,6 \u002B496,7 @@ TEST_F(TestParameterClient, sync_parameter_get_parameters) {\n TEST_F(TestParameterClient, sync_parameter_get_parameters_allow_undeclared) {\n   node_with_option-\u003Edeclare_parameter(\u0022foo\u0022, 4);\n   node_with_option-\u003Edeclare_parameter(\u0022bar\u0022, \u0022this is bar\u0022);\n\u002B  node_with_option-\u003Edeclare_parameter(\u0022baz\u0022, rclcpp::PARAMETER_INTEGER);\n   auto synchronous_client = std::make_shared\u003Crclcpp::SyncParametersClient\u003E(node_with_option);\n \n   {\n@@ -495,6 \u002B505,14 @@ TEST_F(TestParameterClient, sync_parameter_get_parameters_allow_undeclared) {\n     ASSERT_EQ(1u, parameters.size());\n   }\n \n\u002B  {\n\u002B    // not throw ParameterUninitializedException while getting parameter from service\n\u002B    // even if the parameter is not initialized in the node\n\u002B    std::vector\u003Cstd::string\u003E names{\u0022baz\u0022};\n\u002B    std::vector\u003Crclcpp::Parameter\u003E parameters = synchronous_client-\u003Eget_parameters(names, 10s);\n\u002B    ASSERT_EQ(0u, parameters.size());\n\u002B  }\n\u002B\n   {\n     std::vector\u003Cstd::string\u003E names{\u0022none\u0022, \u0022foo\u0022, \u0022bar\u0022};\n     std::vector\u003Crclcpp::Parameter\u003E parameters = synchronous_client-\u003Eget_parameters(names, 10s);\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "ad4813f819e09d05096515045f1688989fb00b81",
    "RawMessage": "Add RVIZ_COMMON_PUBLIC macro to ToolManager (#1323)",
    "Changes": "diff --git rviz_common/include/rviz_common/tool_manager.hpp rviz_common/include/rviz_common/tool_manager.hpp\nindex 7431cea8..7293b1dd 100644\n--- rviz_common/include/rviz_common/tool_manager.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/tool_manager.hpp\n@@ -42,6 \u002B42,7 @@\n \n #include \u0022rviz_common/factory/pluginlib_factory.hpp\u0022\n #include \u0022rviz_common/tool.hpp\u0022\n\u002B#include \u0022rviz_common/visibility_control.hpp\u0022\n \n class QKeyEvent;\n \n@@ -55,7 \u002B56,7 @@ class PropertyTreeModel;\n \n }  // namespace properties\n \n-class ToolManager : public QObject\n\u002Bclass RVIZ_COMMON_PUBLIC ToolManager : public QObject\n {\n   Q_OBJECT\n \n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclc",
    "SHA": "64ee9e1ad02d5b3d87310cc143b69ce8440859b7",
    "RawMessage": "Quality Declaration Statement for Rolling (master branch) (#74)",
    "Changes": "diff --git CONTRIBUTING.md CONTRIBUTING.md\nindex 6f63de9..678e50c 100644\n--- CONTRIBUTING.md\n\u002B\u002B\u002B CONTRIBUTING.md\n@@ -1,6 \u002B1,14 @@\n-Any contribution that you make to this repository will\n-be under the Apache 2 License, as dictated by that\n-[license](http://www.apache.org/licenses/LICENSE-2.0.html):\n\u002B# Contribution Guidelines\n\u002B\n\u002BThe present document provides a set of guidelines to which contributors must adhere.\n\u002B\n\u002B- [Contribution Guidelines](#contribution-guidelines)\n\u002B  - [Contributions Licensing](#contributions-licensing)\n\u002B  - [Developer Certificate of Origin](#developer-certificate-of-origin)\n\u002B\n\u002B## Contributions Licensing\n\u002B\n\u002BAny contribution that you make to this repository will be under the Apache 2 License, as dictated by that [license](http://www.apache.org/licenses/LICENSE-2.0.html):\n \n ~~~\n 5. Submission of Contributions. Unless You explicitly state otherwise,\n@@ -11,3 \u002B19,7 @@ be under the Apache 2 License, as dictated by that\n    the terms of any separate license agreement you may have executed\n    with Licensor regarding such Contributions.\n ~~~\n\u002B\n\u002B## Developer Certificate of Origin\n\u002B\n\u002BContributors must sign-off each commit by adding a \u0060Signed-off-by: ...\u0060 line to commit messages to certify that they have the right to submit the code they are contributing to the project according to the [Developer Certificate of Origin (DCO) Version 1.1](https://developercertificate.org/).\ndiff --git README.md README.md\nindex 0f71c4c..ae8f134 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -9,6 \u002B9,8 @@ In detail, this repository contains three packages:\n \n Technical information on the interfaces and the usage of these packages is given in the README.md files in the corresponding subfolders.\n \n\u002BThe quality declarations for the packages are avaiable in QUALITY_DECLARATION.md files in the corresponding subfolders.\n\u002B\n ## Purpose of the project\n \n The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262).\n@@ -65,3 \u002B67,8 @@ Bloom release status of all packages in repository [github.com/ros2/rclc/](https\n | [rclc_lifecycle](https://github.com/ros2/rclc/tree/master/rclc_lifecycle) | Dashing |  [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary)](https://build.ros2.org/job/Dbin_uB64__rclc_lifecycle__ubuntu_bionic_amd64__binary/)  | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary)](https://build.ros2.org/job/Dbin_ubv8_uBv8__rclc_lifecycle__ubuntu_bionic_arm64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary)](https://build.ros2.org/job/Dbin_ubhf_uBhf__rclc_lifecycle__ubuntu_bionic_armhf__binary/) |\n | | Foxy | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Fbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Fbin_ubv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n | | Rolling | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary)](https://build.ros2.org/job/Rbin_uF64__rclc_lifecycle__ubuntu_focal_amd64__binary/) | [![Build Status](https://build.ros2.org/buildStatus/icon?job=Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary)](https://build.ros2.org/job/Rbin_ufv8_uFv8__rclc_lifecycle__ubuntu_focal_arm64__binary/) | |\n\u002B\n\u002B## Code coverage\n\u002BThe code coverage is tested with every commit, pull request. Results are available at [codecov](https://app.codecov.io/gh/ros2/rclc/branch/master/).\n\u002B\n\u002B[![codecov](https://codecov.io/gh/ros2/rclc/branch/master/graph/badge.svg?token=QzyykDh4zF)](https://codecov.io/gh/ros2/rclc)\ndiff --git codecov.yml codecov.yml\nnew file mode 100644\nindex 0000000..338b8bc\n--- /dev/null\n\u002B\u002B\u002B codecov.yml\n@@ -0,0 \u002B1,4 @@\n\u002Bignore:\n\u002B  - \u0022rclc_examples\u0022\n\u002B  - \u0022rclc/test\u0022\n\u002B  - \u0022rclc_lifecycle/test\u0022\ndiff --git rclc/QUALITY_DECLARATION.md rclc/QUALITY_DECLARATION.md\nnew file mode 100644\nindex 0000000..d190e31\n--- /dev/null\n\u002B\u002B\u002B rclc/QUALITY_DECLARATION.md\n@@ -0,0 \u002B1,210 @@\n\u002BThis document is a declaration of software quality for the \u0060rclc\u0060 package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B# \u0060rclc\u0060 Quality Declaration\n\u002B\n\u002BThe package \u0060rclc\u0060 claims to be in the **Quality Level 2** category when it is used with a **Quality Level 2** middleware.\n\u002B\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B## Version Policy [1]\n\u002B\n\u002B### Version Scheme [1.i]\n\u002B\n\u002B\u0060rclc\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n\u002B\n\u002B### Version Stability [1.ii]\n\u002B\n\u002B\u0060rclc\u0060 is at a stable version, i.e. \u0060\u003E= 1.0.0\u0060.\n\u002BThe current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n\u002B\n\u002B### Public API Declaration [1.iii]\n\u002B\n\u002BAll symbols in the installed headers are considered part of the public API.\n\u002B\n\u002BAll installed headers are in the [\u0060include\u0060](./include/rclc) directory of the package, headers in any other folders are not installed and considered private.\n\u002B\n\u002B### API Stability Policy [1.iv]\n\u002B\n\u002B\u0060rclc\u0060 will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n\u002B\n\u002B### ABI Stability Policy [1.v]\n\u002B\n\u002B\u0060rclc\u0060 contains C code and therefore must be concerned with ABI stability and will maintain ABI stability within a ROS distribution. Because an ABI-break is considered as major version change, there will be no major releases once the ROS distribution is released.\n\u002B\n\u002B### API and ABI Stability Within a Released ROS Distribution [1.vi]\n\u002B\n\u002B\u0060rclc\u0060 will not break API nor ABI within a released ROS distribution, i.e. no major releases once the ROS distribution is released. \n\u002B\n\u002B## Change Control Process [2]\n\u002B\n\u002BThe stability of \u0060rclc\u0060 is ensured through reviews, CI and tests.\n\u002BThe change control process can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002BAll changes to \u0060rclc\u0060 occur through pull requests that are required to pass all CI tests.\n\u002BIn case of failure, only maintainers can merge the pull request, and only when there is enough evidence that the failure is unrelated to the change.\n\u002BAdditionally, all pull requests must have at least one positive review from another contributor that did not author the pull request.\n\u002B\n\u002B### Change Requests [2.i]\n\u002B\n\u002BAll changes will occur through a pull request.\n\u002B\n\u002B### Contributor Origin [2.ii]\n\u002B\n\u002BThis package uses [Developer Certificate of Origin (DCO)](https://developercertificate.org/) as its confirmation of contributor origin policy since version 1.0.0. More information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002B### Peer Review Policy [2.iii]\n\u002B\n\u002BAll pull requests will be peer-reviewed by at least one other contributor who did not author the pull request. Approval is required before merging.\n\u002B\n\u002B### Continuous Integration [2.iv]\n\u002B\n\u002BAll pull requests must pass CI to be considered for merging, unless maintainers consider that there is enough evidence that the failure is unrelated to the changes.\n\u002BCI testing is automatically triggered by incoming pull requests.\n\u002BCurrent results can be seen [../README.md](../README.md).\n\u002B\n\u002B###  Documentation Policy [2.v]\n\u002B\n\u002BAll pull requests must resolve related documentation changes before merging.\n\u002B\n\u002B## Documentation [3]\n\u002B\n\u002B### Feature Documentation [3.i]\n\u002B\n\u002B\u0060rclc\u0060 features are documented in the package [README.md](README.md) and in the header files. \n\u002B\n\u002B### Public API Documentation [3.ii]\n\u002B\n\u002B\u0060rclc\u0060 has embedded API documentation.\n\u002B\n\u002B### License [3.iii]\n\u002B\n\u002BThe license for \u0060rclc\u0060 is Apache 2.0, and a summary can be found in each source file.\n\u002BA full copy of the license can be found [here](../LICENSE).\n\u002B\n\u002B### Copyright Statements [3.iv]\n\u002B\n\u002BThe copyright holders each provide a statement of copyright in each source code file in \u0060rclc\u0060.\n\u002B\n\u002B## Testing [4]\n\u002B\n\u002B### Feature Testing [4.i]\n\u002B\n\u002B\u0060rclc\u0060 provides tests which simulate typical usage, and they are located in the [\u0060test\u0060 directory](test).\n\u002BNew features are required to have tests before being added as stated in [CONTRIBUTING](CONTRIBUTING.md).\n\u002BCurrent results can be seen [../README.md](../README.md).\n\u002B\n\u002BMost features in \u0060rclc\u0060 have corresponding tests which simulate typical usage, and they are located in the [\u0060test\u0060](./test) directory.\n\u002BNew features are required to have tests before being added.\n\u002B\n\u002B### Public API Testing [4.ii]\n\u002B\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n\u002B\n\u002B### Coverage [4.iii]\n\u002B\n\u002BThe coverage report is available in the [../README.md](../README.md).\n\u002B\n\u002B\u0060rclc\u0060 checks the coverage of every commit. Last coverage assessment can be seen in [Codecov](https://app.codecov.io/gh/ros2/rclc/commits).\n\u002B\n\u002B### Coverage [4.iv]\n\u002B\n\u002BPerformance tests for \u0060rclc\u0060 have not been implemented.\n\u002B\n\u002B### Linters and Static Analysis [4.v]\n\u002B\n\u002B\u0060rclc\u0060 code style is enforced using [uncrustify](https://github.com/uncrustify/uncrustify).\n\u002BAmong the CI tests, there are tests that ensure that every pull request is compliant with the code style.\n\u002BThe latest CI results can be seen [../README.md](../README.md).\n\u002B\n\u002B\u0060rclc\u0060 uses and passes all the standard linters and static analysis tools for a C99 package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n\u002B\n\u002BResults of the latest linter tests can be found in the [../README.md](../README.md)\n\u002B\n\u002B## Dependencies [5]\n\u002B\n\u002BBelow are evaluations of each of \u0060rclc\u0060\u0027s run-time and build-time dependencies that have been determined to influence the quality.\n\u002B\n\u002BIt has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n\u002BIt also has several test dependencies, which do not affect the resulting quality of the package, because they are only used to build and run the test code.\n\u002B\n\u002B### Direct Runtime ROS Dependencies [5.i]\n\u002B\n\u002B#### \u0060rcl\u0060\n\u002B\n\u002BThe \u0060rcl\u0060 package provides the API of the common library to support implementation of language specific ROS Client Libraries.\n\u002B\n\u002BIt is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl/blob/master/rcl/QUALITY_DECLARATION.md).\n\u002B\n\u002B#### \u0060rcutils\u0060\n\u002B\n\u002BThe \u0060rcutils\u0060 package provides an API which contains common utilities and data structures needed when programming in C.\n\u002B\n\u002BIt is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n\u002B\n\u002B#### \u0060rosidl_generator_c\u0060\n\u002B\n\u002BThe \u0060rosidl_generator_c\u0060 package is a core-ros package and provides an API that generates message types for C programming language.\n\u002B\n\u002BThe quality statement for this repository is not available.\n\u002B\n\u002B### Optional Direct Runtime ROS Dependencies [5.ii]\n\u002B\n\u002B\u0060rclc\u0060 has no optional Direct Runtime ROS dependencies that need to be considered for this declaration.\n\u002B\n\u002B### Direct Runtime non-ROS Dependency [5.iii]\n\u002B\n\u002B\u0060rclc\u0060 has no Direct Runtime non-ROS dependencies that need to be considered for this declaration.\n\u002B\n\u002B## Platform Support [6]\n\u002B\n\u002B\u0060rclc\u0060 supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers) for Galactic Release (i.e.: Linux amd64, Linux arm64 and Windows 10), and tests each change against all of them.\n\u002B\n\u002B## Security [7]\n\u002B\n\u002B### Vulnerability Disclosure Policy [7.i]\n\u002B\n\u002BThis package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n\u002B\n\u002B# Current status Summary\n\u002B\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the \u0060rclc\u0060 package.\n\u002B\n\u002B|Number| Requirement| Current state |\n\u002B|--|--|--|\n\u002B|1| **Version policy** |---|\n\u002B|1.i|Version Policy available | \u0393\u00A3\u00F4 |\n\u002B|1.ii|Stable version |\u0393\u00A3\u00F4|\n\u002B|1.iii|Declared public API|\u0393\u00A3\u00F4|\n\u002B|1.iv|API stability policy|\u0393\u00A3\u00F4|\n\u002B|1.v|ABI stability policy|\u0393\u00A3\u00F4|\n\u002B|1.vi|API/ABI stable within ros distribution|\u0393\u00A3\u00F4|\n\u002B|2| **Change control process** |---|\n\u002B|2.i| All changes occur on change request | \u0393\u00A3\u00F4|\n\u002B|2.ii| Contributor origin (DCO, CLA, etc) | \u0393\u00A3\u00F4|\n\u002B|2.iii| Peer review policy | \u0393\u00A3\u00F4 |\n\u002B|2.iv| CI policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|2.v| Documentation policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|3| **Documentation** | --- |\n\u002B|3.i| Per feature documentation | \u0393\u00A3\u00F4 |\n\u002B|3.ii| Per public API item documentation | \u0393\u00A3\u00F4 |\n\u002B|3.iii| Declared License(s) | \u0393\u00A3\u00F4 |\n\u002B|3.iv| Copyright in source files| \u0393\u00A3\u00F4 |\n\u002B|3.v.a| Quality declaration linked to README | \u0393\u00A3\u00F4 |\n\u002B|3.v.b| Centralized declaration available for peer review |\u0393\u00A3\u00F4|\n\u002B|4| Testing | --- |\n\u002B|4.i| Feature items tests | \u0393\u00A3\u00F4 |\n\u002B|4.ii| Public API tests | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Using coverage | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Coverage policy | \u0393\u00A3\u00F4 |\n\u002B|4.iv.a| Performance tests (if applicable) | x |\n\u002B|4.iv.b| Performance tests policy| x |\n\u002B|4.v.a| Code style enforcement (linters)| \u0393\u00A3\u00F4 |\n\u002B|4.v.b| Use of static analysis tools | \u0393\u00A3\u00F4 |\n\u002B|5| Dependencies | --- |\n\u002B|5.i| Must not have ROS lower level dependencies | \u0393\u00A3\u00F4 |\n\u002B|5.ii| Optional ROS lower level dependencies| \u0393\u00A3\u00F4 |\n\u002B|5.iii| Justifies quality use of non-ROS dependencies |\u0393\u00A3\u00F4|\n\u002B|6| Platform support | --- |\n\u002B|6.i| Support targets Tier1 ROS platforms| \u0393\u00A3\u00F4 |\n\u002B|7| Security | --- |\n\u002B|7.i| Vulnerability Disclosure Policy | \u0393\u00A3\u00F4 |\ndiff --git rclc/README.md rclc/README.md\nindex a9cb3e6..994e132 100644\n--- rclc/README.md\n\u002B\u002B\u002B rclc/README.md\n@@ -40,6 \u002B40,8 @@ The RCLC-Executor provides an API register subscriptions and timers as well as r\n As described in [CB2019](#CB2019), it is difficult to reason about end-to-end latencies because of the complex semantics of the rclcpp Executor.\n Therefore, the RCLC Executor comes with a number of features, which provides mechanisms for deterministic and real-time execution.\n \n\u002BThe quality declaration is available in [QUALITY_DECLARATION.md](QUALITY_DECLARATION.md).\n\u002B\n ## RCLC-Executor\n Here we introduce the rclc Executor, which is a ROS 2 Executor implemented based on  and for the rcl API, for applications written in the C language.\n Often embedded applications require real-time to guarantee end-to-end latencies and need deterministic runtime behavior to correctly replay test data.\ndiff --git rclc_lifecycle/QUALITY_DECLARATION.md rclc_lifecycle/QUALITY_DECLARATION.md\nnew file mode 100644\nindex 0000000..4ee5dca\n--- /dev/null\n\u002B\u002B\u002B rclc_lifecycle/QUALITY_DECLARATION.md\n@@ -0,0 \u002B1,214 @@\n\u002BThis document is a declaration of software quality for the \u0060rclc_lifecycle\u0060 package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B# \u0060rclc_lifecycle\u0060 Quality Declaration\n\u002B\n\u002BThe package \u0060rclc_lifecycle\u0060 claims to be in the **Quality Level 2** category when it is used with a **Quality Level 2** middleware.\n\u002B\n\u002BBelow are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n\u002B\n\u002B## Version Policy [1]\n\u002B\n\u002B### Version Scheme [1.i]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 uses \u0060semver\u0060 according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n\u002B\n\u002B### Version Stability [1.ii]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 is at a stable version, i.e. \u0060\u003E= 1.0.0\u0060.\n\u002BThe current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n\u002B\n\u002B### Public API Declaration [1.iii]\n\u002B\n\u002BAll symbols in the installed headers are considered part of the public API.\n\u002B\n\u002BAll installed headers are in the [\u0060include\u0060](./include/rclc_lifecycle) directory of the package, headers in any other folders are not installed and considered private.\n\u002B\n\u002B### API Stability Policy [1.iv]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n\u002B\n\u002B### ABI Stability Policy [1.v]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 contains C code and therefore must be concerned with ABI stability and will maintain ABI stability within a ROS distribution. Because an ABI-break is considered as major version change, there will be no major releases once the ROS distribution is released.\n\u002B\n\u002B### API and ABI Stability Within a Released ROS Distribution [1.vi]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 will not break API nor ABI within a released ROS distribution, i.e. no major releases once the ROS distribution is released. \n\u002B\n\u002B## Change Control Process [2]\n\u002B\n\u002BThe stability of \u0060rclc_lifecycle\u0060 is ensured through reviews, CI and tests.\n\u002BThe change control process can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002BAll changes to \u0060rclc_lifecycle\u0060 occur through pull requests that are required to pass all CI tests.\n\u002BIn case of failure, only maintainers can merge the pull request, and only when there is enough evidence that the failure is unrelated to the change.\n\u002BAdditionally, all pull requests must have at least one positive review from another contributor that did not author the pull request.\n\u002B\n\u002B### Change Requests [2.i]\n\u002B\n\u002BAll changes will occur through a pull request.\n\u002B\n\u002B### Contributor Origin [2.ii]\n\u002B\n\u002BThis package uses [Developer Certificate of Origin (DCO)](https://developercertificate.org/) as its confirmation of contributor origin policy since version 1.0.0. More information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n\u002B\n\u002B### Peer Review Policy [2.iii]\n\u002B\n\u002BAll pull requests will be peer-reviewed by at least one other contributor who did not author the pull request. Approval is required before merging.\n\u002B\n\u002B### Continuous Integration [2.iv]\n\u002B\n\u002BAll pull requests must pass CI to be considered for merging, unless maintainers consider that there is enough evidence that the failure is unrelated to the changes.\n\u002BCI testing is automatically triggered by incoming pull requests.\n\u002BCurrent results can be seen [../README.md](../README.md).\n\u002B\n\u002B###  Documentation Policy [2.v]\n\u002B\n\u002BAll pull requests must resolve related documentation changes before merging.\n\u002B\n\u002B## Documentation [3]\n\u002B\n\u002B### Feature Documentation [3.i]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 features are documented in the package [README.md](README.md) and in the header files. \n\u002B\n\u002B### Public API Documentation [3.ii]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 has embedded API documentation.\n\u002B\n\u002BNew additions to the public API require documentation before being added.\n\u002B\n\u002B### License [3.iii]\n\u002B\n\u002BThe license for \u0060rclc_lifecycle\u0060 is Apache 2.0, and a summary can be found in each source file.\n\u002BA full copy of the license can be found [here](../LICENSE).\n\u002B\n\u002B### Copyright Statements [3.iv]\n\u002B\n\u002BThe copyright holders each provide a statement of copyright in each source code file in \u0060rclc_lifecycle\u0060.\n\u002B\n\u002B## Testing [4]\n\u002B\n\u002B### Feature Testing [4.i]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 provides tests which simulate typical usage, and they are located in the [\u0060test\u0060 directory](test).\n\u002BNew features are required to have tests before being added as stated in [CONTRIBUTING](CONTRIBUTING.md).\n\u002BCurrent results can be seen [../README.md](../README.md).\n\u002B\n\u002BMost features in \u0060rclc_lifecycle\u0060 have corresponding tests which simulate typical usage, and they are located in the [\u0060test\u0060](./test) directory.\n\u002BNew features are required to have tests before being added.\n\u002B\n\u002B### Public API Testing [4.ii]\n\u002B\n\u002BEach part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n\u002B\n\u002B### Coverage [4.iii]\n\u002B\n\u002BThe coverage report is available in the [../README.md](../README.md).\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 checks the coverage of every commit. Last coverage assessment can be seen in [Codecov](https://app.codecov.io/gh/ros2/rclc_lifecycle/commits).\n\u002B\n\u002B### Coverage [4.iv]\n\u002B\n\u002BPerformance tests for \u0060rclc_lifecycle\u0060 have not been implemented.\n\u002B\n\u002B### Linters and Static Analysis [4.v]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 code style is enforced using [uncrustify](https://github.com/uncrustify/uncrustify).\n\u002BAmong the CI tests, there are tests that ensure that every pull request is compliant with the code style.\n\u002BThe latest CI results can be seen [../README.md](../README.md).\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 uses and passes all the standard linters and static analysis tools for a C99 package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n\u002B\n\u002BResults of the latest linter tests can be found in the [../README.md](../README.md)\n\u002B\n\u002B## Dependencies [5]\n\u002B\n\u002BBelow are evaluations of each of \u0060rclc_lifecycle\u0060\u0027s run-time and build-time dependencies that have been determined to influence the quality.\n\u002B\n\u002BIt has several \u0022buildtool\u0022 dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n\u002BIt also has several test dependencies, which do not affect the resulting quality of the package, because they are only used to build and run the test code.\n\u002B\n\u002B### Direct Runtime ROS Dependencies [5.i]\n\u002B\n\u002B#### \u0060rclc\u0060\n\u002B\n\u002BThe \u0060rcl\u0060 package provides the API of the C programming language based on rcl.\n\u002B\n\u002BIt is **Quality Level 2**, see its [Quality Declaration document](https://github.com/ros2/rclc/blob/master/rclc/QUALITY_DECLARATION.md).\n\u002B\n\u002B#### \u0060rcl_lifecycle\u0060\n\u002B\n\u002BThe \u0060rcl_lifecycle\u0060 package provides functionality for ROS 2 lifecycle nodes in C.\n\u002B\n\u002BIt is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl/blob/master/rcl_lifecycle/QUALITY_DECLARATION.md).\n\u002B\n\u002B#### \u0060lifecycle_msgs\u0060\n\u002B\n\u002BThe \u0060lifecycle_msgs\u0060 contains message and service definitions for managing lifecycle nodes. These messages and services form a standardized interface for transitioning these managed nodes through a known state-machine.\n\u002B\n\u002BIt is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl_interfaces/blob/master/lifecycle_msgs/QUALITY_DECLARATION.md).\n\u002B\n\u002B\n\u002B\n\u002B### Optional Direct Runtime ROS Dependencies [5.ii]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 has no optional Direct Runtime ROS dependencies that need to be considered for this declaration.\n\u002B\n\u002B### Direct Runtime non-ROS Dependency [5.iii]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 has no Direct Runtime non-ROS dependencies that need to be considered for this declaration.\n\u002B\n\u002B## Platform Support [6]\n\u002B\n\u002B\u0060rclc_lifecycle\u0060 supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers) for Galactic Release (i.e.: Linux amd64, Linux arm64 and Windows 10), and tests each change against all of them.\n\u002B\n\u002B## Security [7]\n\u002B\n\u002B### Vulnerability Disclosure Policy [7.i]\n\u002B\n\u002BThis package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n\u002B\n\u002B# Current status Summary\n\u002B\n\u002BThe chart below compares the requirements in the REP-2004 with the current state of the \u0060rclc_lifecycle\u0060 package.\n\u002B\n\u002B|Number| Requirement| Current state |\n\u002B|--|--|--|\n\u002B|1| **Version policy** |---|\n\u002B|1.i|Version Policy available | \u0393\u00A3\u00F4 |\n\u002B|1.ii|Stable version |\u0393\u00A3\u00F4|\n\u002B|1.iii|Declared public API|\u0393\u00A3\u00F4|\n\u002B|1.iv|API stability policy|\u0393\u00A3\u00F4|\n\u002B|1.v|ABI stability policy|\u0393\u00A3\u00F4|\n\u002B|1.vi|API/ABI stable within ros distribution|\u0393\u00A3\u00F4|\n\u002B|2| **Change control process** |---|\n\u002B|2.i| All changes occur on change request | \u0393\u00A3\u00F4|\n\u002B|2.ii| Contributor origin (DCO, CLA, etc) | \u0393\u00A3\u00F4|\n\u002B|2.iii| Peer review policy | \u0393\u00A3\u00F4 |\n\u002B|2.iv| CI policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|2.v| Documentation policy for change requests | \u0393\u00A3\u00F4 |\n\u002B|3| **Documentation** | --- |\n\u002B|3.i| Per feature documentation | \u0393\u00A3\u00F4 |\n\u002B|3.ii| Per public API item documentation | \u0393\u00A3\u00F4 |\n\u002B|3.iii| Declared License(s) | \u0393\u00A3\u00F4 |\n\u002B|3.iv| Copyright in source files| \u0393\u00A3\u00F4 |\n\u002B|3.v.a| Quality declaration linked to README | \u0393\u00A3\u00F4 |\n\u002B|3.v.b| Centralized declaration available for peer review |\u0393\u00A3\u00F4|\n\u002B|4| Testing | --- |\n\u002B|4.i| Feature items tests | \u0393\u00A3\u00F4 |\n\u002B|4.ii| Public API tests | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Using coverage | \u0393\u00A3\u00F4 |\n\u002B|4.iii.a| Coverage policy | \u0393\u00A3\u00F4 |\n\u002B|4.iv.a| Performance tests (if applicable) | x |\n\u002B|4.iv.b| Performance tests policy| x |\n\u002B|4.v.a| Code style enforcement (linters)| \u0393\u00A3\u00F4 |\n\u002B|4.v.b| Use of static analysis tools | \u0393\u00A3\u00F4 |\n\u002B|5| Dependencies | --- |\n\u002B|5.i| Must not have ROS lower level dependencies | \u0393\u00A3\u00F4 |\n\u002B|5.ii| Optional ROS lower level dependencies| \u0393\u00A3\u00F4 |\n\u002B|5.iii| Justifies quality use of non-ROS dependencies |\u0393\u00A3\u00F4|\n\u002B|6| Platform support | --- |\n\u002B|6.i| Support targets Tier1 ROS platforms| \u0393\u00A3\u00F4 |\n\u002B|7| Security | --- |\n\u002B|7.i| Vulnerability Disclosure Policy | \u0393\u00A3\u00F4 |\ndiff --git rclc_lifecycle/README.md rclc_lifecycle/README.md\nindex 03f8b08..d665d26 100644\n--- rclc_lifecycle/README.md\n\u002B\u002B\u002B rclc_lifecycle/README.md\n@@ -4,6 \u002B4,7 @@\n \n The rclc_lifecycle package is a [ROS 2](http://www.ros2.org/) package and provides convenience functions to bundle a ROS Client Library (RCL) node with the ROS 2 Node Lifecycle state machine in the C programming language, similar to the [rclcpp Lifecycle Node](https://github.com/ros2/rclcpp/blob/master/rclcpp_lifecycle/include/rclcpp_lifecycle/lifecycle_node.hpp) for C\u002B\u002B.\n \n\u002BThe quality declaration is available in [QUALITY_DECLARATION.md](QUALITY_DECLARATION.md).\n ## API\n \n The API of the RCLC Lifecycle Node can be divided in several phases: Initialization, Running and Clean-Up.\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "2f0e1ef39da47d6bf37b99acd76fd660565f6304",
    "RawMessage": "Add tracepoint for publish/subscribe serialized message (#485)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 5dd8bb5..7f47a2d 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1989,9 \u002B1989,13 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n     serialized_message, \u0022serialized message handle is null\u0022,\n     return RMW_RET_INVALID_ARGUMENT);\n   auto pub = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n\u002B  const dds_time_t tstamp = dds_time();\n\u002B  TRACETOOLS_TRACEPOINT(rmw_publish, (const void *)publisher, serialized_message, tstamp);\n \n   struct ddsi_serdata * d = serdata_rmw_from_serialized_message(\n     pub-\u003Esertype, serialized_message-\u003Ebuffer, serialized_message-\u003Ebuffer_length);\n\u002B  d-\u003Etimestamp.v = tstamp;\n\u002B  d-\u003Estatusinfo = 0;\n \n #ifdef DDS_HAS_SHM\n   // publishing a serialized message when SHM is available\n@@ -2005,7 \u002B2009,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n   }\n #endif\n \n-  const bool ok = (dds_writecdr(pub-\u003Eenth, d) \u003E= 0);\n\u002B  const bool ok = (dds_forwardcdr(pub-\u003Eenth, d) \u003E= 0);\n   return ok ? RMW_RET_OK : RMW_RET_ERROR;\n }\n \n@@ -3458,6 \u002B3462,12 @@ static rmw_ret_t rmw_take_ser_int(\n           serialized_message-\u003Ebuffer_length = size;\n           ddsi_serdata_unref(d);\n           *taken = true;\n\u002B          TRACETOOLS_TRACEPOINT(\n\u002B            rmw_take,\n\u002B            static_cast\u003Cconst void *\u003E(subscription),\n\u002B            static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B            (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B            *taken);\n           return RMW_RET_OK;\n         } else if (iox_header-\u003Eshm_data_state == IOX_CHUNK_CONTAINS_RAW_DATA) {\n           if (rmw_serialize(d-\u003Eiox_chunk, \u0026sub-\u003Etype_supports, serialized_message) != RMW_RET_OK) {\n@@ -3468,6 \u002B3478,12 @@ static rmw_ret_t rmw_take_ser_int(\n           }\n           ddsi_serdata_unref(d);\n           *taken = true;\n\u002B          TRACETOOLS_TRACEPOINT(\n\u002B            rmw_take,\n\u002B            static_cast\u003Cconst void *\u003E(subscription),\n\u002B            static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B            (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B            *taken);\n           return RMW_RET_OK;\n         } else {\n           RMW_SET_ERROR_MSG(\u0022The recieved sample over SHM is not initialized\u0022);\n@@ -3489,12 \u002B3505,24 @@ static rmw_ret_t rmw_take_ser_int(\n         serialized_message-\u003Ebuffer_length = size;\n         ddsi_serdata_unref(d);\n         *taken = true;\n\u002B        TRACETOOLS_TRACEPOINT(\n\u002B          rmw_take,\n\u002B          static_cast\u003Cconst void *\u003E(subscription),\n\u002B          static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B          (message_info ? message_info-\u003Esource_timestamp : 0LL),\n\u002B          *taken);\n         return RMW_RET_OK;\n       }\n     }\n     ddsi_serdata_unref(d);\n   }\n   *taken = false;\n\u002B  TRACETOOLS_TRACEPOINT(\n\u002B    rmw_take,\n\u002B    static_cast\u003Cconst void *\u003E(subscription),\n\u002B    static_cast\u003Cconst void *\u003E(serialized_message),\n\u002B    0LL,\n\u002B    *taken);\n   return RMW_RET_OK;\n }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "f8606f03d900bbd2387f51178ae5bdf5c5d7b443",
    "RawMessage": "Update Service and Action Protocols (#1409)",
    "Changes": "diff --git rclpy/rclpy/__init__.py rclpy/rclpy/__init__.py\nindex 177be47..da51444 100644\n--- rclpy/rclpy/__init__.py\n\u002B\u002B\u002B rclpy/rclpy/__init__.py\n@@ -219,7 \u002B219,7 @@ def create_node(\n     namespace: Optional[str] = None,\n     use_global_arguments: bool = True,\n     enable_rosout: bool = True,\n-    rosout_qos_profile: Optional[Union[QoSProfile, int]] = qos_profile_rosout_default,\n\u002B    rosout_qos_profile: Union[QoSProfile, int] = qos_profile_rosout_default,\n     start_parameter_services: bool = True,\n     parameter_overrides: Optional[List[Parameter[Any]]] = None,\n     allow_undeclared_parameters: bool = False,\ndiff --git rclpy/rclpy/action/client.py rclpy/rclpy/action/client.py\nindex d8709ee..2b0f593 100644\n--- rclpy/rclpy/action/client.py\n\u002B\u002B\u002B rclpy/rclpy/action/client.py\n@@ -166,7 \u002B166,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n     def __init__(\n         self,\n         node: \u0027Node\u0027,\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n\u002B        action_type: Type[Action],\n         action_name: str,\n         *,\n         callback_group: \u0027Optional[CallbackGroup]\u0027 = None,\n@@ -202,16 \u002B202,17 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT],\n         self._action_type = action_type\n         self._action_name = action_name\n         with node.handle:\n-            self._client_handle = _rclpy.ActionClient(\n-                node.handle,\n-                action_type,\n-                action_name,\n-                goal_service_qos_profile.get_c_qos_profile(),\n-                result_service_qos_profile.get_c_qos_profile(),\n-                cancel_service_qos_profile.get_c_qos_profile(),\n-                feedback_sub_qos_profile.get_c_qos_profile(),\n-                status_sub_qos_profile.get_c_qos_profile()\n-            )\n\u002B            self._client_handle: \u0027_rclpy.ActionClient[GoalT, ResultT, FeedbackT]\u0027 =  \\\n\u002B                _rclpy.ActionClient(\n\u002B                    node.handle,\n\u002B                    action_type,\n\u002B                    action_name,\n\u002B                    goal_service_qos_profile.get_c_qos_profile(),\n\u002B                    result_service_qos_profile.get_c_qos_profile(),\n\u002B                    cancel_service_qos_profile.get_c_qos_profile(),\n\u002B                    feedback_sub_qos_profile.get_c_qos_profile(),\n\u002B                    status_sub_qos_profile.get_c_qos_profile()\n\u002B                )\n \n         self._is_ready = False\n \ndiff --git rclpy/rclpy/action/server.py rclpy/rclpy/action/server.py\nindex 98f38de..9a538f9 100644\n--- rclpy/rclpy/action/server.py\n\u002B\u002B\u002B rclpy/rclpy/action/server.py\n@@ -35,12 \u002B35,11 @@ from rclpy.type_support import (Action, check_for_type_support, FeedbackMessage,\n                                 GetResultServiceRequest, GetResultServiceResponse, GoalT, ResultT,\n                                 SendGoalServiceRequest)\n from rclpy.waitable import NumberOfEntities, Waitable\n\u002Bfrom typing_extensions import TypeAlias\n from unique_identifier_msgs.msg import UUID\n \n \n if TYPE_CHECKING:\n-    from typing_extensions import TypeAlias\n-\n     from rclpy.callback_groups import CallbackGroup\n     from rclpy.node import Node\n \n@@ -54,7 \u002B53,7 @@ if TYPE_CHECKING:\n         result: Tuple[\u0027_rclpy.rmw_request_id_t\u0027, GetResultServiceRequest]\n         expired: Tuple[GoalInfo, ...]\n else:\n-    ServerGoalHandleDict: \u0027TypeAlias\u0027 = Dict[str, object]\n\u002B    ServerGoalHandleDict: TypeAlias = Dict[str, object]\n \n \n # Re-export exception defined in _rclpy C extension.\n@@ -75,7 \u002B74,7 @@ class CancelResponse(Enum):\n     ACCEPT = 2\n \n \n-GoalEvent = _rclpy.GoalEvent\n\u002BGoalEvent: TypeAlias = _rclpy.GoalEvent\n \n \n class ServerGoalHandle(Generic[GoalT, ResultT, FeedbackT]):\n@@ -229,7 \u002B228,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n     def __init__(\n         self,\n         node: \u0027Node\u0027,\n-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n\u002B        action_type: Type[Action],\n         action_name: str,\n         execute_callback: Callable[[ServerGoalHandle[GoalT, ResultT, FeedbackT]], ResultT],\n         *,\n@@ -288,18 \u002B287,19 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n         self._node = node\n         self._action_type = action_type\n         with node.handle, node.get_clock().handle:\n-            self._handle = _rclpy.ActionServer(\n-                node.handle,\n-                node.get_clock().handle,\n-                action_type,\n-                action_name,\n-                goal_service_qos_profile.get_c_qos_profile(),\n-                result_service_qos_profile.get_c_qos_profile(),\n-                cancel_service_qos_profile.get_c_qos_profile(),\n-                feedback_pub_qos_profile.get_c_qos_profile(),\n-                status_pub_qos_profile.get_c_qos_profile(),\n-                result_timeout,\n-            )\n\u002B            self._handle: \u0027_rclpy.ActionServer[GoalT, ResultT, FeedbackT]\u0027 = \\\n\u002B                _rclpy.ActionServer(\n\u002B                    node.handle,\n\u002B                    node.get_clock().handle,\n\u002B                    action_type,\n\u002B                    action_name,\n\u002B                    goal_service_qos_profile.get_c_qos_profile(),\n\u002B                    result_service_qos_profile.get_c_qos_profile(),\n\u002B                    cancel_service_qos_profile.get_c_qos_profile(),\n\u002B                    feedback_pub_qos_profile.get_c_qos_profile(),\n\u002B                    status_pub_qos_profile.get_c_qos_profile(),\n\u002B                    result_timeout,\n\u002B                )\n \n         # key: UUID in bytes, value: GoalHandle\n         self._goal_handles: Dict[bytes, ServerGoalHandle[GoalT, ResultT, FeedbackT]] = {}\n@@ -504,7 \u002B504,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Waitable[\u0027ServerGoalHandl\n             self._logger.warning(\u0027Failed to send result response (the client may have gone away)\u0027)\n \n     @property\n-    def action_type(self) -\u003E Type[Action[GoalT, ResultT, FeedbackT]]:\n\u002B    def action_type(self) -\u003E Type[Action]:\n         return self._action_type\n \n     # Start Waitable API\ndiff --git rclpy/rclpy/client.py rclpy/rclpy/client.py\nindex 879e823..1dc8a5c 100644\n--- rclpy/rclpy/client.py\n\u002B\u002B\u002B rclpy/rclpy/client.py\n@@ -41,7 \u002B41,7 @@ class Client(Generic[SrvRequestT, SrvResponseT]):\n         self,\n         context: Context,\n         client_impl: \u0027_rclpy.Client[SrvRequestT, SrvResponseT]\u0027,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv],\n         srv_name: str,\n         qos_profile: QoSProfile,\n         callback_group: CallbackGroup\ndiff --git rclpy/rclpy/impl/_rclpy_pybind11.pyi rclpy/rclpy/impl/_rclpy_pybind11.pyi\nindex 360ffc2..d182114 100644\n--- rclpy/rclpy/impl/_rclpy_pybind11.pyi\n\u002B\u002B\u002B rclpy/rclpy/impl/_rclpy_pybind11.pyi\n@@ -104,7 \u002B104,7 @@ class Destroyable:\n \n class Client(Destroyable, Generic[SrvRequestT, SrvResponseT]):\n \n-    def __init__(self, node: Node, srv_type: type[Srv[SrvRequestT, SrvResponseT]],\n\u002B    def __init__(self, node: Node, srv_type: type[Srv],\n                  srv_name: str, pyqos_profile: rmw_qos_profile_t) -\u003E None: ...\n \n     @property\n@@ -137,7 \u002B137,7 @@ class Client(Destroyable, Generic[SrvRequestT, SrvResponseT]):\n \n class Service(Destroyable, Generic[SrvRequestT, SrvResponseT]):\n \n-    def __init__(self, node: Node, pysrv_type: type[Srv[SrvRequestT, SrvResponseT]],\n\u002B    def __init__(self, node: Node, pysrv_type: type[Srv],\n                  name: str, pyqos_profile: rmw_qos_profile_t) -\u003E None: ...\n \n     @property\n@@ -480,7 \u002B480,7 @@ class Node(Destroyable):\n \n     def __init__(self, node_name: str, namespace_: str, context: Context,\n                  pycli_args: list[str] | None, use_global_arguments: bool,\n-                 enable_rosout: bool) -\u003E None: ...\n\u002B                 enable: bool, rosout_qos_profile: rmw_qos_profile_t) -\u003E None: ...\n \n     @property\n     def pointer(self) -\u003E int:\n@@ -707,7 \u002B707,7 @@ class ActionClient(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n     def __init__(\n             self,\n             node: Node,\n-            pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n\u002B            pyaction_type: type[Action],\n             action_name: str,\n             goal_service_qos: rmw_qos_profile_t,\n             result_service_qos: rmw_qos_profile_t,\n@@ -777,7 \u002B777,7 @@ class ActionServer(Generic[GoalT, ResultT, FeedbackT], Destroyable):\n         self,\n         node: Node,\n         rclpy_clock: Clock,\n-        pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n\u002B        pyaction_type: type[Action],\n         action_name: str,\n         goal_service_qos: rmw_qos_profile_t,\n         result_service_qos: rmw_qos_profile_t,\ndiff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex a484519..917d172 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -139,7 \u002B139,7 @@ class Node:\n         namespace: Optional[str] = None,\n         use_global_arguments: bool = True,\n         enable_rosout: bool = True,\n-        rosout_qos_profile: Optional[Union[QoSProfile, int]] = qos_profile_rosout_default,\n\u002B        rosout_qos_profile: Union[QoSProfile, int] = qos_profile_rosout_default,\n         start_parameter_services: bool = True,\n         parameter_overrides: Optional[List[Parameter[Any]]] = None,\n         allow_undeclared_parameters: bool = False,\n@@ -1746,7 \u002B1746,7 @@ class Node:\n \n     def create_client(\n         self,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv],\n         srv_name: str,\n         *,\n         qos_profile: QoSProfile = qos_profile_services_default,\n@@ -1767,7 \u002B1767,7 @@ class Node:\n         failed = False\n         try:\n             with self.handle:\n-                client_impl = _rclpy.Client(\n\u002B                client_impl: \u0027_rclpy.Client[SrvRequestT, SrvResponseT]\u0027 = _rclpy.Client(\n                     self.handle,\n                     srv_type,\n                     srv_name,\n@@ -1777,7 \u002B1777,7 @@ class Node:\n         if failed:\n             self._validate_topic_or_service_name(srv_name, is_service=True)\n \n-        client = Client(\n\u002B        client: Client[SrvRequestT, SrvResponseT] = Client(\n             self.context,\n             client_impl, srv_type, srv_name, qos_profile,\n             callback_group)\n@@ -1788,7 \u002B1788,7 @@ class Node:\n \n     def create_service(\n         self,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv],\n         srv_name: str,\n         callback: Callable[[SrvRequestT, SrvResponseT], SrvResponseT],\n         *,\n@@ -1812,7 \u002B1812,7 @@ class Node:\n         failed = False\n         try:\n             with self.handle:\n-                service_impl = _rclpy.Service(\n\u002B                service_impl: \u0027_rclpy.Service[SrvRequestT, SrvResponseT]\u0027 = _rclpy.Service(\n                     self.handle,\n                     srv_type,\n                     srv_name,\ndiff --git rclpy/rclpy/parameter_client.py rclpy/rclpy/parameter_client.py\nindex fa3655b..ad4da3a 100644\n--- rclpy/rclpy/parameter_client.py\n\u002B\u002B\u002B rclpy/rclpy/parameter_client.py\n@@ -24,6 \u002B24,7 @@ from rcl_interfaces.srv import ListParameters\n from rcl_interfaces.srv import SetParameters\n from rcl_interfaces.srv import SetParametersAtomically\n from rclpy.callback_groups import CallbackGroup\n\u002Bfrom rclpy.client import Client\n from rclpy.event_handler import SubscriptionEventCallbacks\n from rclpy.node import Node\n from rclpy.parameter import Parameter as Parameter\n@@ -77,27 \u002B78,36 @@ class AsyncParameterClient:\n         \u0022\u0022\u0022\n         self.remote_node_name = remote_node_name\n         self.node = node\n-        self._get_parameter_client = self.node.create_client(\n\u002B        self._get_parameter_client: Client[GetParameters.Request,\n\u002B                                           GetParameters.Response] = self.node.create_client(\n             GetParameters, f\u0027{remote_node_name}/get_parameters\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n-        self._list_parameter_client = self.node.create_client(\n\u002B        self._list_parameter_client: Client[ListParameters.Request,\n\u002B                                            ListParameters.Response] = self.node.create_client(\n             ListParameters, f\u0027{remote_node_name}/list_parameters\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n-        self._set_parameter_client = self.node.create_client(\n\u002B        self._set_parameter_client: Client[SetParameters.Request,\n\u002B                                           SetParameters.Response] = self.node.create_client(\n             SetParameters, f\u0027{remote_node_name}/set_parameters\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n-        self._get_parameter_types_client = self.node.create_client(\n\u002B        self._get_parameter_types_client: Client[GetParameterTypes.Request,\n\u002B                                                 GetParameterTypes.Response] = \\\n\u002B            self.node.create_client(\n             GetParameterTypes, f\u0027{remote_node_name}/get_parameter_types\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n-        self._describe_parameters_client = self.node.create_client(\n\u002B        self._describe_parameters_client: Client[DescribeParameters.Request,\n\u002B                                                 DescribeParameters.Response] = \\\n\u002B            self.node.create_client(\n             DescribeParameters, f\u0027{remote_node_name}/describe_parameters\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n-        self._set_parameters_atomically_client = self.node.create_client(\n\u002B        self._set_parameters_atomically_client: Client[SetParametersAtomically.Request,\n\u002B                                                       SetParametersAtomically.Response] = \\\n\u002B            self.node.create_client(\n             SetParametersAtomically, f\u0027{remote_node_name}/set_parameters_atomically\u0027,\n             qos_profile=qos_profile, callback_group=callback_group\n         )\n@@ -137,7 \u002B147,7 @@ class AsyncParameterClient:\n         self,\n         prefixes: Optional[List[str]] = None,\n         depth: Optional[int] = None,\n-        callback: Optional[Callable[[ListParameters.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[ListParameters.Response]], None]] = None\n     ) -\u003E Future[ListParameters.Response]:\n         \u0022\u0022\u0022\n         List all parameters with given prefixes.\n@@ -158,7 \u002B168,7 @@ class AsyncParameterClient:\n         return future\n \n     def get_parameters(self, names: List[str],\n-                       callback: Optional[Callable[[GetParameters.Response], None]] = None\n\u002B                       callback: Optional[Callable[[Future[GetParameters.Response]], None]] = None\n                        ) -\u003E Future[GetParameters.Response]:\n         \u0022\u0022\u0022\n         Get parameters given names.\n@@ -177,7 \u002B187,7 @@ class AsyncParameterClient:\n     def set_parameters(\n         self,\n         parameters: Sequence[Union[Parameter[Any], ParameterMsg]],\n-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None\n     ) -\u003E Future[SetParameters.Response]:\n         \u0022\u0022\u0022\n         Set parameters given a list of parameters.\n@@ -203,7 \u002B213,7 @@ class AsyncParameterClient:\n     def describe_parameters(\n         self,\n         names: List[str],\n-        callback: Optional[Callable[[DescribeParameters.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[DescribeParameters.Response]], None]] = None\n     ) -\u003E Future[DescribeParameters.Response]:\n         \u0022\u0022\u0022\n         Describe parameters given names.\n@@ -225,7 \u002B235,7 @@ class AsyncParameterClient:\n     def get_parameter_types(\n         self,\n         names: List[str],\n-        callback: Optional[Callable[[GetParameterTypes.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[GetParameterTypes.Response]], None]] = None\n     ) -\u003E Future[GetParameterTypes.Response]:\n         \u0022\u0022\u0022\n         Get parameter types given names.\n@@ -249,7 \u002B259,7 @@ class AsyncParameterClient:\n     def set_parameters_atomically(\n         self,\n         parameters: Sequence[Union[Parameter[Any], ParameterMsg]],\n-        callback: Optional[Callable[[SetParametersAtomically.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[SetParametersAtomically.Response]], None]] = None\n     ) -\u003E Future[SetParametersAtomically.Response]:\n         \u0022\u0022\u0022\n         Set parameters atomically.\n@@ -274,7 \u002B284,7 @@ class AsyncParameterClient:\n \n     def delete_parameters(\n         self, names: List[str],\n-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None\n     ) -\u003E Future[SetParameters.Response]:\n         \u0022\u0022\u0022\n         Unset parameters with given names.\n@@ -299,7 \u002B309,7 @@ class AsyncParameterClient:\n         self,\n         parameter_file: str,\n         use_wildcard: bool = False,\n-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n\u002B        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None\n     ) -\u003E Future[SetParameters.Response]:\n         \u0022\u0022\u0022\n         Load parameters from a yaml file.\n@@ -321,15 \u002B331,15 @@ class AsyncParameterClient:\n         self,\n         parameter_file: str,\n         use_wildcard: bool = False,\n-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n-    ) -\u003E Future[SetParameters.Response]:\n\u002B        callback: Optional[Callable[[Future[SetParametersAtomically.Response]], None]] = None\n\u002B    ) -\u003E Future[SetParametersAtomically.Response]:\n         \u0022\u0022\u0022\n         Load parameters from a yaml file atomically.\n \n         Wrapper around \u0060rclpy.parameter.parameter_dict_from_yaml_file\u0060.\n \n         The result after the returned future is complete\n-        will be of type \u0060\u0060rcl_interfaces.srv.SetParameters.Response\u0060\u0060.\n\u002B        will be of type \u0060\u0060rcl_interfaces.srv.SetParametersAtomically.Response\u0060\u0060.\n \n         :param parameter_file: Path to the parameter file.\n         :param use_wildcard: Whether to use wildcard expansion.\ndiff --git rclpy/rclpy/parameter_event_handler.py rclpy/rclpy/parameter_event_handler.py\nindex 22a39d6..ec1e6a7 100644\n--- rclpy/rclpy/parameter_event_handler.py\n\u002B\u002B\u002B rclpy/rclpy/parameter_event_handler.py\n@@ -15,14 \u002B15,14 @@\n from collections import defaultdict\n from itertools import chain\n from multiprocessing import Lock\n-from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple\n\u002Bfrom typing import Callable, Dict, Iterable, List, Optional, Tuple\n \n \n\u002Bfrom rcl_interfaces.msg import Parameter as ParameterMsg\n from rcl_interfaces.msg import ParameterEvent\n from rclpy.callback_groups import CallbackGroup\n from rclpy.event_handler import SubscriptionEventCallbacks\n from rclpy.node import Node\n-from rclpy.parameter import Parameter\n from rclpy.qos import qos_profile_parameter_events\n from rclpy.qos import QoSProfile\n from rclpy.qos_overriding_options import QoSOverridingOptions\n@@ -33,7 \u002B33,7 @@ class ParameterCallbackHandle:\n         self,\n         parameter_name: str,\n         node_name: str,\n-        callback: Callable[[Parameter[Any]], None],\n\u002B        callback: Callable[[ParameterMsg], None],\n     ) -\u003E None:\n         self.parameter_name = parameter_name\n         self.node_name = node_name\n@@ -97,7 \u002B97,7 @@ class ParameterEventHandler:\n             self,\n             parameter_name: str,\n             node_name: str,\n-            callback: Callable[[Parameter[Any]], None],\n\u002B            callback: Callable[[ParameterMsg], None],\n         ) -\u003E ParameterCallbackHandle:\n             \u0022\u0022\u0022\n             Add new parameter callback.\n@@ -258,7 \u002B258,7 @@ class ParameterEventHandler:\n         event: ParameterEvent,\n         parameter_name: str,\n         node_name: str,\n-    ) -\u003E Optional[Parameter[Any]]:\n\u002B    ) -\u003E Optional[ParameterMsg]:\n         \u0022\u0022\u0022\n         Get specified parameter value from ParameterEvent message.\n \n@@ -277,7 \u002B277,7 @@ class ParameterEventHandler:\n         return None\n \n     @staticmethod\n-    def get_parameters_from_event(event: ParameterEvent) -\u003E Iterable[Parameter[Any]]:\n\u002B    def get_parameters_from_event(event: ParameterEvent) -\u003E Iterable[ParameterMsg]:\n         \u0022\u0022\u0022\n         Get all parameters from a ParameterEvent message.\n \n@@ -290,7 \u002B290,7 @@ class ParameterEventHandler:\n         self,\n         parameter_name: str,\n         node_name: str,\n-        callback: Callable[[Parameter[Any]], None],\n\u002B        callback: Callable[[ParameterMsg], None],\n     ) -\u003E ParameterCallbackHandle:\n         \u0022\u0022\u0022\n         Add new parameter callback.\ndiff --git rclpy/rclpy/service.py rclpy/rclpy/service.py\nindex 14662dc..a311510 100644\n--- rclpy/rclpy/service.py\n\u002B\u002B\u002B rclpy/rclpy/service.py\n@@ -37,7 \u002B37,7 @@ class Service(Generic[SrvRequestT, SrvResponseT]):\n     def __init__(\n         self,\n         service_impl: \u0027_rclpy.Service[SrvRequestT, SrvResponseT]\u0027,\n-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n\u002B        srv_type: Type[Srv],\n         srv_name: str,\n         callback: Callable[[SrvRequestT, SrvResponseT], SrvResponseT],\n         callback_group: CallbackGroup,\ndiff --git rclpy/rclpy/type_support.py rclpy/rclpy/type_support.py\nindex 5848472..db9af14 100644\n--- rclpy/rclpy/type_support.py\n\u002B\u002B\u002B rclpy/rclpy/type_support.py\n@@ -12,14 \u002B12,11 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-from typing import Any, ClassVar, Iterable, Optional, Protocol, Type, TypeVar, Union\n\u002Bfrom typing import Any, ClassVar, Optional, Protocol, Type, TypeVar, Union\n \n-\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal\n from builtin_interfaces.msg import Time\n from rclpy.exceptions import NoTypeSupportImportedException\n-from service_msgs.msg._service_event_info import ServiceEventInfo\n\u002Bfrom service_msgs.msg import ServiceEventInfo\n from typing_extensions import TypeAlias\n from unique_identifier_msgs.msg import UUID\n \n@@ -65,18 \u002B62,17 @@ SrvRequestT = TypeVar(\u0027SrvRequestT\u0027, bound=Msg)\n SrvResponseT = TypeVar(\u0027SrvResponseT\u0027, bound=Msg)\n \n \n-class EventMessage(Msg, Protocol[SrvRequestT, SrvResponseT]):\n\u002Bclass EventMessage(Msg, Protocol):\n     info: ServiceEventInfo\n-    request: Iterable[SrvRequestT]\n-    response: Iterable[SrvResponseT]\n \n \n-class Srv(Protocol[SrvRequestT, SrvResponseT], metaclass=CommonMsgSrvMetaClass):\n\u002Bclass Srv(Protocol, metaclass=CommonMsgSrvMetaClass):\n     \u0022\u0022\u0022Generic Service Type Alias.\u0022\u0022\u0022\n \n-    Request: Type[SrvRequestT]\n-    Response: Type[SrvResponseT]\n-    Event: Type[EventMessage[SrvRequestT, SrvResponseT]]\n\u002B    pass\n\u002B    # Request: ClassVar[Type[Any]]\n\u002B    # Response: ClassVar[Type[Any]]\n\u002B    # Event: ClassVar[Type[Any]]\n \n \n GoalT = TypeVar(\u0027GoalT\u0027, bound=Msg)\n@@ -94,7 \u002B90,7 @@ class SendGoalServiceResponse(Msg, Protocol):\n     stamp: Time\n \n \n-SendGoalService: TypeAlias = Srv[SendGoalServiceRequest[GoalT], SendGoalServiceResponse]\n\u002BSendGoalService: TypeAlias = Srv\n \n \n class GetResultServiceRequest(Msg, Protocol):\n@@ -106,7 \u002B102,7 @@ class GetResultServiceResponse(Msg, Protocol[ResultT]):\n     result: ResultT\n \n \n-GetResultService: TypeAlias = Srv[GetResultServiceRequest, GetResultServiceResponse[ResultT]]\n\u002BGetResultService: TypeAlias = Srv\n \n \n class FeedbackMessage(Msg, Protocol[FeedbackT]):\n@@ -114,33 \u002B110,27 @@ class FeedbackMessage(Msg, Protocol[FeedbackT]):\n     feedback: FeedbackT\n \n \n-class Impl(Protocol[GoalT, ResultT, FeedbackT]):\n-\n-    SendGoalService: Type[SendGoalService[GoalT]]\n-    GetResultService: Type[GetResultService[ResultT]]\n-    FeedbackMessage: Type[FeedbackMessage[FeedbackT]]\n-    CancelGoalService: ClassVar[Type[CancelGoal]]\n-    GoalStatusMessage: ClassVar[Type[GoalStatusArray]]\n-\n\u002Bclass Action(Protocol, metaclass=CommonMsgSrvMetaClass):\n\u002B    pass\n\u002B    # Goal: ClassVar[Type[Any]]\n\u002B    # Result: ClassVar[Type[Any]]\n\u002B    # Feedback: ClassVar[Type[Any]]\n \n-class Action(Protocol[GoalT,\n-                      ResultT,\n-                      FeedbackT],\n-             metaclass=CommonMsgSrvMetaClass):\n-    Goal: Type[GoalT]\n-    Result: Type[ResultT]\n-    Feedback: Type[FeedbackT]\n\u002B    # class Impl(Protocol):\n \n-    Impl: Type[Impl[GoalT, ResultT, FeedbackT]]\n\u002B    #     SendGoalService: ClassVar[Type[Any]]\n\u002B    #     GetResultService: ClassVar[Type[Any]]\n\u002B    #     FeedbackMessage: ClassVar[Type[Any]]\n\u002B    #     CancelGoalService: ClassVar[Type[CancelGoal]]\n\u002B    #     GoalStatusMessage: ClassVar[Type[GoalStatusArray]]\n \n \n # Can be used if https://github.com/python/typing/issues/548 ever gets approved.\n-SrvT = TypeVar(\u0027SrvT\u0027, bound=Srv[Any, Any])\n-ActionT = TypeVar(\u0027ActionT\u0027, bound=Action[Any, Any, Any])\n\u002BSrvT = TypeVar(\u0027SrvT\u0027, bound=Srv)\n\u002BActionT = TypeVar(\u0027ActionT\u0027, bound=Action)\n \n \n-def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv[Any, Any],\n-                                                       Action[Any, Any, Any]]]) -\u003E None:\n\u002Bdef check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv, Action]]) -\u003E None:\n     try:\n         ts = msg_or_srv_type._TYPE_SUPPORT\n     except AttributeError as e:\n@@ -172,7 \u002B162,7 @@ def check_is_valid_msg_type(msg_type: Type[Msg]) -\u003E None:\n         ) from None\n \n \n-def check_is_valid_srv_type(srv_type: Type[Srv[Any, Any]]) -\u003E None:\n\u002Bdef check_is_valid_srv_type(srv_type: Type[Srv]) -\u003E None:\n     check_for_type_support(srv_type)\n     try:\n         assert None not in (\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "9baef10662cd057d00ce9af1b8563812facde367",
    "RawMessage": "add content-filtered-topic interfaces (#181)",
    "Changes": "diff --git rmw_implementation/src/functions.cpp rmw_implementation/src/functions.cpp\nindex 19989e7..892eb40 100644\n--- rmw_implementation/src/functions.cpp\n\u002B\u002B\u002B rmw_implementation/src/functions.cpp\n@@ -415,6 \u002B415,19 @@ RMW_INTERFACE_FN(\n   rmw_ret_t, RMW_RET_ERROR,\n   3, ARG_TYPES(rmw_event_t *, const rmw_subscription_t *, rmw_event_type_t))\n \n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_subscription_set_content_filter,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  2, ARG_TYPES(\n\u002B    rmw_subscription_t *, const rmw_subscription_content_filter_options_t *))\n\u002B\n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_subscription_get_content_filter,\n\u002B  rmw_ret_t, RMW_RET_ERROR,\n\u002B  3, ARG_TYPES(\n\u002B    const rmw_subscription_t *, rcutils_allocator_t *,\n\u002B    rmw_subscription_content_filter_options_t *))\n\u002B\n RMW_INTERFACE_FN(\n   rmw_take,\n   rmw_ret_t, RMW_RET_ERROR,\n@@ -769,6 \u002B782,8 @@ void prefetch_symbols(void)\n   GET_SYMBOL(rmw_subscription_count_matched_publishers)\n   GET_SYMBOL(rmw_subscription_get_actual_qos)\n   GET_SYMBOL(rmw_subscription_event_init)\n\u002B  GET_SYMBOL(rmw_subscription_set_content_filter)\n\u002B  GET_SYMBOL(rmw_subscription_get_content_filter)\n   GET_SYMBOL(rmw_take)\n   GET_SYMBOL(rmw_take_with_info)\n   GET_SYMBOL(rmw_take_serialized_message)\n@@ -880,6 \u002B895,8 @@ unload_library()\n   symbol_rmw_subscription_count_matched_publishers = nullptr;\n   symbol_rmw_subscription_get_actual_qos = nullptr;\n   symbol_rmw_subscription_event_init = nullptr;\n\u002B  symbol_rmw_subscription_set_content_filter = nullptr;\n\u002B  symbol_rmw_subscription_get_content_filter = nullptr;\n   symbol_rmw_take = nullptr;\n   symbol_rmw_take_sequence = nullptr;\n   symbol_rmw_take_with_info = nullptr;\ndiff --git test_rmw_implementation/test/test_subscription.cpp test_rmw_implementation/test/test_subscription.cpp\nindex 0b13d7d..38e54db 100644\n--- test_rmw_implementation/test/test_subscription.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_subscription.cpp\n@@ -14,6 \u002B14,9 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Cthread\u003E\n\u002B\n #include \u0022osrf_testing_tools_cpp/memory_tools/gtest_quickstart.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n \n@@ -22,6 \u002B25,7 @@\n \n #include \u0022rmw/rmw.h\u0022\n #include \u0022rmw/error_handling.h\u0022\n\u002B#include \u0022rmw/subscription_content_filter_options.h\u0022\n \n #include \u0022test_msgs/msg/basic_types.h\u0022\n #include \u0022test_msgs/msg/strings.h\u0022\n@@ -870,6 \u002B874,145 @@ TEST_F(\n     RMW_RET_OK, rmw_serialized_message_fini(\u0026serialized_message)) \u003C\u003C rmw_get_error_string().str;\n }\n \n\u002BTEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), no_content_filter_get) {\n\u002B  rmw_subscription_content_filter_options_t options;\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B  rmw_ret_t ret = rmw_subscription_get_content_filter(sub, \u0026allocator, \u0026options);\n\u002B  EXPECT_NE(RMW_RET_OK, ret);\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), no_content_filter_set) {\n\u002B  rmw_ret_t ret;\n\u002B  bool taken = false;\n\u002B\n\u002B  // Create publisher\n\u002B  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n\u002B  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, \u0026qos_profile, \u0026pub_options);\n\u002B  ASSERT_NE(nullptr, pub) \u003C\u003C rmw_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) \u003C\u003C rmw_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  size_t subscription_count = 0u;\n\u002B  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n\u002B    ret = rmw_publisher_count_matched_subscriptions(pub, \u0026subscription_count);\n\u002B    if (RMW_RET_OK == ret \u0026\u0026 1u == subscription_count) {  // Early return on failure.\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // Publish message with float (3.14159) from publisher to subscription\n\u002B  test_msgs__msg__BasicTypes original_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026original_message));\n\u002B  original_message.float32_value = 3.14159f;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    test_msgs__msg__BasicTypes__fini(\u0026original_message);\n\u002B  });\n\u002B\n\u002B  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n\u002B  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n\u002B\n\u002B  ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  // expect to get message because no content filter set\n\u002B  {\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    test_msgs__msg__BasicTypes output_message{};\n\u002B    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B    });\n\u002B\n\u002B    ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B    // whatever the cft is supported or not\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    EXPECT_TRUE(taken);\n\u002B    EXPECT_EQ(original_message, output_message);\n\u002B  }\n\u002B\n\u002B  // set content filter with 3.14\n\u002B  rmw_subscription_content_filter_options_t options =\n\u002B    rmw_get_zero_initialized_content_filter_options();\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B      \u0022float32_value=3.14\u0022,\n\u002B      0,\n\u002B      nullptr,\n\u002B      \u0026allocator,\n\u002B      \u0026options));\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B  });\n\u002B\n\u002B  ret = rmw_subscription_set_content_filter(sub, \u0026options);\n\u002B  if (ret != RMW_RET_UNSUPPORTED) {\n\u002B    ASSERT_EQ(RMW_RET_OK, ret);\n\u002B    // waiting to allow for filter propagation\n\u002B    std::this_thread::sleep_for(std::chrono::seconds(1));\n\u002B    ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_TIMEOUT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    // content filter subscription with 3.14 that is not equal with 3.14159\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes output_message{};\n\u002B      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B      {\n\u002B        test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B      });\n\u002B\n\u002B      ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B      EXPECT_FALSE(taken);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n class CLASSNAME (TestSubscriptionUseLoan, RMW_IMPLEMENTATION)\n   : public CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION)\n {\n@@ -1041,3 \u002B1184,546 @@ bool operator==(const rmw_message_info_t \u0026 m1, const rmw_message_info_t \u0026 m2)\n          m1.received_timestamp == m2.received_timestamp \u0026\u0026\n          m1.from_intra_process == m2.from_intra_process;\n }\n\u002B\n\u002Bclass CLASSNAME (TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION)\n\u002B  : public CLASSNAME(TestSubscription, RMW_IMPLEMENTATION)\n\u002B{\n\u002Bprotected:\n\u002B  using Base = CLASSNAME(TestSubscription, RMW_IMPLEMENTATION);\n\u002B\n\u002B  void SetUp() override\n\u002B  {\n\u002B    Base::SetUp();\n\u002B    // Tighten QoS policies to force mismatch.\n\u002B    qos_profile.reliability = RMW_QOS_POLICY_RELIABILITY_RELIABLE;\n\u002B    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n\u002B\n\u002B    // Create subscription with content filter\n\u002B    auto allocator = rcutils_get_default_allocator();\n\u002B\n\u002B    rmw_subscription_content_filter_options_t * content_filter_options =\n\u002B      static_cast\u003Crmw_subscription_content_filter_options_t *\u003E(\n\u002B      allocator.allocate(\n\u002B        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      allocator.deallocate(content_filter_options, allocator.state);\n\u002B    });\n\u002B    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B        filter_expression,\n\u002B        expression_parameters_count,\n\u002B        expression_parameters,\n\u002B        \u0026allocator,\n\u002B        content_filter_options));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK,\n\u002B        rmw_subscription_content_filter_options_fini(content_filter_options, \u0026allocator));\n\u002B    });\n\u002B    options.content_filter_options = content_filter_options;\n\u002B\n\u002B    sub = rmw_create_subscription(node, ts, topic_name, \u0026qos_profile, \u0026options);\n\u002B    ASSERT_NE(nullptr, sub) \u003C\u003C rmw_get_error_string().str;\n\u002B  }\n\u002B\n\u002B  void TearDown() override\n\u002B  {\n\u002B    rmw_ret_t ret = rmw_destroy_subscription(node, sub);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    Base::TearDown();\n\u002B  }\n\u002B\n\u002B  rmw_subscription_t * sub{nullptr};\n\u002B  const char * const topic_name = \u0022/test\u0022;\n\u002B  const rosidl_message_type_support_t * ts{\n\u002B    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n\u002B  rmw_qos_profile_t qos_profile{rmw_qos_profile_default};\n\u002B  const char * filter_expression = \u0022float32_value=%0\u0022;\n\u002B  enum { expression_parameters_count = 1 };\n\u002B  const char * expression_parameters[expression_parameters_count] = {\n\u002B    \u00223.14159\u0022\n\u002B  };\n\u002B  const char * expression_parameters_2[expression_parameters_count] = {\n\u002B    \u00223.14\u0022\n\u002B  };\n\u002B};\n\u002B\n\u002BTEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), get_content_filter) {\n\u002B  rmw_subscription_content_filter_options_t options;\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B  rmw_ret_t ret = rmw_subscription_get_content_filter(sub, \u0026allocator, \u0026options);\n\u002B  if (sub-\u003Eis_cft_enabled) {\n\u002B    EXPECT_EQ(RMW_RET_OK, ret);\n\u002B    EXPECT_STREQ(options.filter_expression, filter_expression);\n\u002B    ASSERT_EQ(expression_parameters_count, options.expression_parameters.size);\n\u002B    for (size_t i = 0; i \u003C options.expression_parameters.size; \u002B\u002Bi) {\n\u002B      EXPECT_STREQ(\n\u002B        options.expression_parameters.data[i],\n\u002B        expression_parameters[i]);\n\u002B    }\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B  } else {\n\u002B    EXPECT_EQ(RMW_RET_UNSUPPORTED, ret);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), set_content_filter) {\n\u002B  rmw_subscription_content_filter_options_t options =\n\u002B    rmw_get_zero_initialized_content_filter_options();\n\u002B  auto allocator = rcutils_get_default_allocator();\n\u002B  EXPECT_EQ(\n\u002B    RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B      filter_expression,\n\u002B      expression_parameters_count,\n\u002B      expression_parameters_2,\n\u002B      \u0026allocator,\n\u002B      \u0026options));\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B  });\n\u002B\n\u002B  bool is_cft_enabled = sub-\u003Eis_cft_enabled;\n\u002B  rmw_ret_t ret = rmw_subscription_set_content_filter(sub, \u0026options);\n\u002B  if (is_cft_enabled) {\n\u002B    EXPECT_EQ(RMW_RET_OK, ret);\n\u002B  } else {\n\u002B    EXPECT_EQ(RMW_RET_UNSUPPORTED, ret);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_get_begin) {\n\u002B  rmw_ret_t ret;\n\u002B  bool taken = false;\n\u002B\n\u002B  // Create publisher\n\u002B  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n\u002B  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, \u0026qos_profile, \u0026pub_options);\n\u002B  ASSERT_NE(nullptr, pub) \u003C\u003C rmw_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) \u003C\u003C rmw_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  bool is_cft_enabled = sub-\u003Eis_cft_enabled;\n\u002B\n\u002B  size_t subscription_count = 0u;\n\u002B  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n\u002B    ret = rmw_publisher_count_matched_subscriptions(pub, \u0026subscription_count);\n\u002B    if (RMW_RET_OK == ret \u0026\u0026 1u == subscription_count) {  // Early return on failure.\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // Publish message with float (3.14159) from publisher to subscription\n\u002B  test_msgs__msg__BasicTypes original_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026original_message));\n\u002B  original_message.float32_value = 3.14159f;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    test_msgs__msg__BasicTypes__fini(\u0026original_message);\n\u002B  });\n\u002B\n\u002B  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n\u002B  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n\u002B\n\u002B  ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  // expect to get message because content filter is 3.14159\n\u002B  {\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    test_msgs__msg__BasicTypes output_message{};\n\u002B    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B    });\n\u002B\n\u002B    ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B    // whatever the cft is supported or not\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    EXPECT_TRUE(taken);\n\u002B    EXPECT_EQ(original_message, output_message);\n\u002B  }\n\u002B\n\u002B  // set content filter with 3.14\n\u002B  if (is_cft_enabled) {\n\u002B    rmw_subscription_content_filter_options_t options =\n\u002B      rmw_get_zero_initialized_content_filter_options();\n\u002B    auto allocator = rcutils_get_default_allocator();\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B        filter_expression,\n\u002B        expression_parameters_count,\n\u002B        expression_parameters_2,\n\u002B        \u0026allocator,\n\u002B        \u0026options));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK,\n\u002B        rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B    });\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_set_content_filter(sub, \u0026options));\n\u002B    // waiting to allow for filter propagation\n\u002B    std::this_thread::sleep_for(std::chrono::seconds(1));\n\u002B\n\u002B    ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_TIMEOUT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    // content filter subscription with 3.14 that is not equal with 3.14159\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes output_message{};\n\u002B      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B      {\n\u002B        test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B      });\n\u002B\n\u002B      ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B      EXPECT_FALSE(taken);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_get_later) {\n\u002B  rmw_ret_t ret;\n\u002B  bool taken = false;\n\u002B\n\u002B  // Create publisher\n\u002B  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n\u002B  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, \u0026qos_profile, \u0026pub_options);\n\u002B  ASSERT_NE(nullptr, pub) \u003C\u003C rmw_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) \u003C\u003C rmw_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  bool is_cft_enabled = sub-\u003Eis_cft_enabled;\n\u002B\n\u002B  size_t subscription_count = 0u;\n\u002B  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n\u002B    ret = rmw_publisher_count_matched_subscriptions(pub, \u0026subscription_count);\n\u002B    if (RMW_RET_OK == ret \u0026\u0026 1u == subscription_count) {  // Early return on failure.\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // Publish message with float (3.14) from publisher to subscription\n\u002B  test_msgs__msg__BasicTypes original_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026original_message));\n\u002B  original_message.float32_value = 3.14f;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    test_msgs__msg__BasicTypes__fini(\u0026original_message);\n\u002B  });\n\u002B\n\u002B  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n\u002B  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n\u002B\n\u002B  ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  {\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B\n\u002B    // if cft is supported, not to expect to get the message because content filter is 3.14159\n\u002B    if (is_cft_enabled) {\n\u002B      EXPECT_EQ(RMW_RET_TIMEOUT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B      ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n\u002B    } else {\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B      ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B    }\n\u002B\n\u002B    test_msgs__msg__BasicTypes output_message{};\n\u002B    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B    });\n\u002B\n\u002B    ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    if (is_cft_enabled) {\n\u002B      EXPECT_FALSE(taken);\n\u002B    } else {\n\u002B      EXPECT_TRUE(taken);\n\u002B      EXPECT_EQ(original_message, output_message);\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // set content filter with 3.14\n\u002B  if (is_cft_enabled) {\n\u002B    rmw_subscription_content_filter_options_t options =\n\u002B      rmw_get_zero_initialized_content_filter_options();\n\u002B    auto allocator = rcutils_get_default_allocator();\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B        filter_expression,\n\u002B        expression_parameters_count,\n\u002B        expression_parameters_2,\n\u002B        \u0026allocator,\n\u002B        \u0026options));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK,\n\u002B        rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B    });\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_set_content_filter(sub, \u0026options));\n\u002B    // waiting to allow for filter propagation\n\u002B    std::this_thread::sleep_for(std::chrono::seconds(1));\n\u002B\n\u002B    ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {5, 0};  // 5000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    // content filter subscription with 3.14 that is equal with 3.14\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes output_message{};\n\u002B      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B      {\n\u002B        test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B      });\n\u002B\n\u002B      ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B      EXPECT_TRUE(taken);\n\u002B      EXPECT_EQ(original_message, output_message);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_reset) {\n\u002B  rmw_ret_t ret;\n\u002B  bool taken = false;\n\u002B\n\u002B  // Create publisher\n\u002B  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n\u002B  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, \u0026qos_profile, \u0026pub_options);\n\u002B  ASSERT_NE(nullptr, pub) \u003C\u003C rmw_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) \u003C\u003C rmw_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  bool is_cft_enabled = sub-\u003Eis_cft_enabled;\n\u002B\n\u002B  size_t subscription_count = 0u;\n\u002B  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n\u002B    ret = rmw_publisher_count_matched_subscriptions(pub, \u0026subscription_count);\n\u002B    if (RMW_RET_OK == ret \u0026\u0026 1u == subscription_count) {  // Early return on failure.\n\u002B      break;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // Publish message with float (3.14) from publisher to subscription\n\u002B  test_msgs__msg__BasicTypes original_message{};\n\u002B  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026original_message));\n\u002B  original_message.float32_value = 3.14f;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    test_msgs__msg__BasicTypes__fini(\u0026original_message);\n\u002B  });\n\u002B\n\u002B  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n\u002B  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n\u002B\n\u002B  ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B  EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B  {\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {1, 0};  // 1000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B\n\u002B    // if cft is supported, not to expect to get the message because content filter is 3.14159\n\u002B    if (is_cft_enabled) {\n\u002B      EXPECT_EQ(RMW_RET_TIMEOUT, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B      ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n\u002B    } else {\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B      ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B    }\n\u002B\n\u002B    test_msgs__msg__BasicTypes output_message{};\n\u002B    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B    });\n\u002B\n\u002B    ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    if (is_cft_enabled) {\n\u002B      EXPECT_FALSE(taken);\n\u002B    } else {\n\u002B      EXPECT_TRUE(taken);\n\u002B      EXPECT_EQ(original_message, output_message);\n\u002B    }\n\u002B  }\n\u002B\n\u002B  // set content filter with empty(\u0022\u0022)\n\u002B  if (is_cft_enabled) {\n\u002B    rmw_subscription_content_filter_options_t options =\n\u002B      rmw_get_zero_initialized_content_filter_options();\n\u002B    auto allocator = rcutils_get_default_allocator();\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n\u002B        \u0022\u0022,\n\u002B        0,\n\u002B        nullptr,\n\u002B        \u0026allocator,\n\u002B        \u0026options));\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK,\n\u002B        rmw_subscription_content_filter_options_fini(\u0026options, \u0026allocator));\n\u002B    });\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RMW_RET_OK,\n\u002B      rmw_subscription_set_content_filter(sub, \u0026options));\n\u002B    // waiting to allow for filter propagation\n\u002B    std::this_thread::sleep_for(std::chrono::seconds(1));\n\u002B\n\u002B    ret = rmw_publish(pub, \u0026original_message, null_allocation_p);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B    rmw_subscriptions_t subscriptions;\n\u002B    void * subscriptions_storage[1];\n\u002B    subscriptions_storage[0] = sub-\u003Edata;\n\u002B    subscriptions.subscribers = subscriptions_storage;\n\u002B    subscriptions.subscriber_count = 1;\n\u002B\n\u002B    rmw_wait_set_t * wait_set = rmw_create_wait_set(\u0026context, 1);\n\u002B    ASSERT_NE(nullptr, wait_set) \u003C\u003C rmw_get_error_string().str;\n\u002B    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B    {\n\u002B      EXPECT_EQ(\n\u002B        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) \u003C\u003C rmw_get_error_string().str;\n\u002B    });\n\u002B    rmw_time_t timeout = {5, 0};  // 5000ms\n\u002B    ret = rmw_wait(\u0026subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, \u0026timeout);\n\u002B    EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n\u002B\n\u002B    // content filter subscription is reset\n\u002B    {\n\u002B      test_msgs__msg__BasicTypes output_message{};\n\u002B      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(\u0026output_message));\n\u002B      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B      {\n\u002B        test_msgs__msg__BasicTypes__fini(\u0026output_message);\n\u002B      });\n\u002B\n\u002B      ret = rmw_take(sub, \u0026output_message, \u0026taken, null_allocation_s);\n\u002B      EXPECT_EQ(RMW_RET_OK, ret) \u003C\u003C rmw_get_error_string().str;\n\u002B\n\u002B      EXPECT_TRUE(taken);\n\u002B      EXPECT_EQ(original_message, output_message);\n\u002B    }\n\u002B  }\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_python",
    "SHA": "1e57ddf1047e57327743840976c2c86f8e534bf8",
    "RawMessage": "sorting after conversion",
    "Changes": "diff --git rosidl_generator_py/rosidl_generator_py/generate_py_impl.py rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\nindex dfa2d94..f217c70 100644\n--- rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n\u002B\u002B\u002B rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n@@ -121,9 \u002B121,13 @@ def generate_py(generator_arguments_file, typesupport_impls):\n \n     for subfolder in modules.keys():\n         with open(os.path.join(args[\u0027output_dir\u0027], subfolder, \u0027__init__.py\u0027), \u0027w\u0027) as f:\n-            for idl_stem in sorted(modules[subfolder]):\n-                module_name = \u0027_\u0027 \u002B \\\n\u002B            module_names = {}\n\u002B            for idl_stem in modules[subfolder]:\n\u002B                module_names[idl_stem] = \u0027_\u0027 \u002B \\\n                     convert_camel_case_to_lower_case_underscore(idl_stem)\n\u002B            # sorting after lower case conversion to get true order\n\u002B            for module_name, idl_stem in \\\n\u002B                sorted((value, key) for (key,value) in module_names.items()):\n                 f.write(\n                     f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n                     f\u0027{idl_stem}  # noqa: F401\\n\u0027)\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "geometry2",
    "SHA": "9e94db43b2e3d232b5083cc4374317c0b76fee30",
    "RawMessage": "Export a tf2_geometry_msgs::tf2_geometry_msgs target (#496)",
    "Changes": "diff --git tf2_geometry_msgs/CMakeLists.txt tf2_geometry_msgs/CMakeLists.txt\nindex 3d126027..d8451e33 100644\n--- tf2_geometry_msgs/CMakeLists.txt\n\u002B\u002B\u002B tf2_geometry_msgs/CMakeLists.txt\n@@ -9,14 \u002B9,10 @@ if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)\n endif()\n \n-find_package(ament_cmake_auto REQUIRED)\n-set(required_dependencies\n-  \u0022geometry_msgs\u0022\n-  \u0022orocos_kdl\u0022\n-  \u0022tf2\u0022\n-  \u0022tf2_ros\u0022\n-)\n-ament_auto_find_build_dependencies(REQUIRED ${required_dependencies})\n\u002Bfind_package(geometry_msgs REQUIRED)\n\u002Bfind_package(orocos_kdl REQUIRED)\n\u002Bfind_package(tf2 REQUIRED)\n\u002Bfind_package(tf2_ros REQUIRED)\n \n # TODO(ros2/geometry2#110) Port python once PyKDL becomes usable in ROS 2\n # ament_python_install_package(${PROJECT_NAME}\n@@ -27,6 \u002B23,16 @@ ament_auto_find_build_dependencies(REQUIRED ${required_dependencies})\n #    DESTINATION lib/${PROJECT_NAME}\n # )\n \n\u002Badd_library(${PROJECT_NAME} INTERFACE)\n\u002Btarget_include_directories(${PROJECT_NAME} INTERFACE\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include\u003E\u0022)\n\u002Btarget_link_libraries(${PROJECT_NAME} INTERFACE\n\u002B  ${geometry_msgs_TARGETS}\n\u002B  orocos-kdl\n\u002B  tf2::tf2\n\u002B  tf2_ros::tf2_ros)\n\u002B\n if(BUILD_TESTING)\n   find_package(ament_lint_auto REQUIRED)\n \n@@ -42,27 \u002B48,23 @@ if(BUILD_TESTING)\n \n   ament_add_gtest(test_tf2_geometry_msgs test/test_tf2_geometry_msgs.cpp)\n   if(TARGET test_tf2_geometry_msgs)\n-    target_include_directories(test_tf2_geometry_msgs PUBLIC include)\n-    ament_target_dependencies(test_tf2_geometry_msgs\n-      \u0022geometry_msgs\u0022\n-      \u0022orocos_kdl\u0022\n-      \u0022rclcpp\u0022\n-      \u0022tf2\u0022\n-      \u0022tf2_ros\u0022\n\u002B    target_link_libraries(test_tf2_geometry_msgs\n\u002B      ${PROJECT_NAME}\n\u002B      rclcpp::rclcpp\n\u002B      # Used, but not linked to test ${PROJECT_NAME}\u0027s exports:\n\u002B      #   tf2_ros::tf2_ros\n     )\n   endif()\n endif()\n \n-add_library(${PROJECT_NAME} INTERFACE)\n-target_include_directories(${PROJECT_NAME} INTERFACE $\u003CINSTALL_INTERFACE:include\u003E)\n-ament_target_dependencies(${PROJECT_NAME} INTERFACE ${required_dependencies})\n-\n-install(\n-  TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}\n-  INCLUDES DESTINATION include\n-)\n\u002Binstall(TARGETS ${PROJECT_NAME} EXPORT export_${PROJECT_NAME})\n\u002Binstall(DIRECTORY include/ DESTINATION include)\n \n-ament_export_targets(${PROJECT_NAME})\n-ament_export_dependencies(${required_dependencies})\n\u002Bament_export_targets(export_${PROJECT_NAME})\n\u002Bament_export_dependencies(\n\u002B  \u0022geometry_msgs\u0022\n\u002B  \u0022orocos_kdl\u0022\n\u002B  \u0022tf2\u0022\n\u002B  \u0022tf2_ros\u0022)\n \n-ament_auto_package()\n\u002Bament_package()\ndiff --git tf2_geometry_msgs/package.xml tf2_geometry_msgs/package.xml\nindex 22dfd6d7..5bfdbbb3 100644\n--- tf2_geometry_msgs/package.xml\n\u002B\u002B\u002B tf2_geometry_msgs/package.xml\n@@ -11,7 \u002B11,7 @@\n   \u003Cauthor email=\u0022tfoote@osrfoundation.org\u0022\u003ETully Foote\u003C/author\u003E\n   \u003Cauthor\u003EWim Meeussen\u003C/author\u003E\n \n-  \u003Cbuildtool_depend\u003Eament_cmake_auto\u003C/buildtool_depend\u003E\n\u002B  \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Egeometry_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Eorocos_kdl\u003C/depend\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "08c6f2372d7c6f161ca240a06659f32ffac5dd3a",
    "RawMessage": "Use RCUTILS_UNUSED macro instead of \u0060static_cast\u003Cvoid\u003E\u0060",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex acd0cdd..188a62e 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -1244,10 \u002B1244,10 @@ rmw_take_dynamic_message(\n   bool * taken,\n   rmw_subscription_allocation_t * allocation)\n {\n-  static_cast\u003Cvoid\u003E(subscription);\n-  static_cast\u003Cvoid\u003E(dynamic_message);\n-  static_cast\u003Cvoid\u003E(taken);\n-  static_cast\u003Cvoid\u003E(allocation);\n\u002B  RCUTILS_UNUSED(subscription);\n\u002B  RCUTILS_UNUSED(dynamic_message);\n\u002B  RCUTILS_UNUSED(taken);\n\u002B  RCUTILS_UNUSED(allocation);\n \n   RMW_SET_ERROR_MSG(\u0022rmw_take_dynamic_message: unimplemented\u0022);\n   return RMW_RET_UNSUPPORTED;\n@@ -1261,11 \u002B1261,11 @@ rmw_take_dynamic_message_with_info(\n   rmw_message_info_t * message_info,\n   rmw_subscription_allocation_t * allocation)\n {\n-  static_cast\u003Cvoid\u003E(subscription);\n-  static_cast\u003Cvoid\u003E(dynamic_message);\n-  static_cast\u003Cvoid\u003E(taken);\n-  static_cast\u003Cvoid\u003E(message_info);\n-  static_cast\u003Cvoid\u003E(allocation);\n\u002B  RCUTILS_UNUSED(subscription);\n\u002B  RCUTILS_UNUSED(dynamic_message);\n\u002B  RCUTILS_UNUSED(taken);\n\u002B  RCUTILS_UNUSED(message_info);\n\u002B  RCUTILS_UNUSED(allocation);\n \n   RMW_SET_ERROR_MSG(\u0022rmw_take_dynamic_message_with_info: unimplemented\u0022);\n   return RMW_RET_UNSUPPORTED;\n@@ -1277,9 \u002B1277,9 @@ rmw_serialization_support_init(\n   rcutils_allocator_t * allocator,\n   rosidl_dynamic_typesupport_serialization_support_t * serialization_support)\n {\n-  static_cast\u003Cvoid\u003E(serialization_lib_name);\n-  static_cast\u003Cvoid\u003E(allocator);\n-  static_cast\u003Cvoid\u003E(serialization_support);\n\u002B  RCUTILS_UNUSED(serialization_lib_name);\n\u002B  RCUTILS_UNUSED(allocator);\n\u002B  RCUTILS_UNUSED(serialization_support);\n \n   RMW_SET_ERROR_MSG(\u0022rmw_serialization_support_init: unimplemented\u0022);\n   return RMW_RET_UNSUPPORTED;\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "5af95c7095fa87466ef0a2e3000bec8956374dab",
    "RawMessage": "Ensure compliant matched pub/sub count API. (#424)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/rmw_publisher.cpp rmw_fastrtps_cpp/src/rmw_publisher.cpp\nindex 2c3b606..4f5fc61 100644\n--- rmw_fastrtps_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_publisher.cpp\n@@ -123,6 \u002B123,14 @@ rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_count_matched_subscriptions(\n     publisher, subscription_count);\n }\ndiff --git rmw_fastrtps_cpp/src/rmw_subscription.cpp rmw_fastrtps_cpp/src/rmw_subscription.cpp\nindex 712f6f9..a27f326 100644\n--- rmw_fastrtps_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_subscription.cpp\n@@ -119,6 \u002B119,14 @@ rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_count_matched_publishers(\n     subscription, publisher_count);\n }\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\nindex 52ce147..baaedcb 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_publisher.cpp\n@@ -127,6 \u002B127,14 @@ rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher,\n\u002B    publisher-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_publisher_count_matched_subscriptions(\n     publisher, subscription_count);\n }\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\nindex fad3f4b..00873ce 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_subscription.cpp\n@@ -122,6 \u002B122,14 @@ rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription,\n\u002B    subscription-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n   return rmw_fastrtps_shared_cpp::__rmw_subscription_count_matched_publishers(\n     subscription, publisher_count);\n }\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\nindex afa4b2e..fb8cd2a 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_publisher.cpp\n@@ -87,13 \u002B87,9 @@ __rmw_publisher_count_matched_subscriptions(\n   const rmw_publisher_t * publisher,\n   size_t * subscription_count)\n {\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n-\n   auto info = static_cast\u003CCustomPublisherInfo *\u003E(publisher-\u003Edata);\n-  if (info != nullptr) {\n-    *subscription_count = info-\u003Elistener_-\u003EsubscriptionCount();\n-  }\n\u002B\n\u002B  *subscription_count = info-\u003Elistener_-\u003EsubscriptionCount();\n \n   return RMW_RET_OK;\n }\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\nindex 95c4252..4ce18ac 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_subscription.cpp\n@@ -85,13 \u002B85,10 @@ __rmw_subscription_count_matched_publishers(\n   const rmw_subscription_t * subscription,\n   size_t * publisher_count)\n {\n-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n-\n   auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n-  if (info != nullptr) {\n-    *publisher_count = info-\u003Elistener_-\u003EpublisherCount();\n-  }\n\u002B\n\u002B  *publisher_count = info-\u003Elistener_-\u003EpublisherCount();\n\u002B\n   return RMW_RET_OK;\n }\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "b674565f4ccfe141ca4c9778ba77fc2aa155c7da",
    "RawMessage": "Force C\u002B\u002B17 support on. (#1076)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 305ac85..b01509c 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -5,6 \u002B5,7 @@ project(rclpy)\n # Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n   set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n # Default to C11\n if(NOT CMAKE_C_STANDARD)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "ad389c6e750cddc317bb0230d38094d92deb2910",
    "RawMessage": "Avoid causing infinite loop when message is empty (#935)",
    "Changes": "diff --git rclpy/test/test_client.py rclpy/test/test_client.py\nindex 6846a0e..6903fc7 100644\n--- rclpy/test/test_client.py\n\u002B\u002B\u002B rclpy/test/test_client.py\n@@ -102,8 \u002B102,7 @@ class TestClient(unittest.TestCase):\n         try:\n             self.assertTrue(cli.wait_for_service(timeout_sec=20))\n             cli.call_async(GetParameters.Request())\n-            cycle_count = 0\n-            while cycle_count \u003C 5:\n\u002B            for i in range(5):\n                 with srv.handle:\n                     result = srv.handle.service_take_request(srv.srv_type.Request)\n                 if result is not None:\n@@ -112,7 \u002B111,7 @@ class TestClient(unittest.TestCase):\n                     self.assertNotEqual(0, header.source_timestamp)\n                     return\n                 else:\n-                    time.sleep(0.1)\n\u002B                    time.sleep(0.2)\n             self.fail(\u0027Did not get a request in time\u0027)\n         finally:\n             self.node.destroy_client(cli)\ndiff --git rclpy/test/test_node.py rclpy/test/test_node.py\nindex 81db243..65d09e9 100644\n--- rclpy/test/test_node.py\n\u002B\u002B\u002B rclpy/test/test_node.py\n@@ -157,8 \u002B157,7 @@ class TestNodeAllowUndeclaredParameters(unittest.TestCase):\n             1)\n         basic_types_msg = BasicTypes()\n         basic_types_pub.publish(basic_types_msg)\n-        cycle_count = 0\n-        while cycle_count \u003C 5:\n\u002B        for i in range(5):\n             with sub.handle:\n                 result = sub.handle.take_message(sub.msg_type, False)\n             if result is not None:\n@@ -166,7 \u002B165,7 @@ class TestNodeAllowUndeclaredParameters(unittest.TestCase):\n                 self.assertNotEqual(0, info[\u0027source_timestamp\u0027])\n                 return\n             else:\n-                time.sleep(0.1)\n\u002B                time.sleep(0.2)\n \n     def test_create_client(self):\n         self.node.create_client(GetParameters, \u0027get/parameters\u0027)\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "44419a00b0800861982a4e465756f74659b7e5f0",
    "RawMessage": "Add tests for RMW QoS to DDS attribute conversion. (#449)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/test/CMakeLists.txt rmw_fastrtps_shared_cpp/test/CMakeLists.txt\nindex 3db9b12..12054b5 100644\n--- rmw_fastrtps_shared_cpp/test/CMakeLists.txt\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/test/CMakeLists.txt\n@@ -7,6 \u002B7,11 @@ if(TARGET test_dds_attributes_to_rmw_qos)\n     target_link_libraries(test_dds_attributes_to_rmw_qos ${PROJECT_NAME})\n endif()\n \n\u002Bament_add_gtest(test_rmw_qos_to_dds_attributes test_rmw_qos_to_dds_attributes.cpp)\n\u002Bif(TARGET test_rmw_qos_to_dds_attributes)\n\u002B  target_link_libraries(test_rmw_qos_to_dds_attributes ${PROJECT_NAME})\n\u002Bendif()\n\u002B\n ament_add_gmock(test_security_logging test_security_logging.cpp)\n if(TARGET test_security_logging)\n     ament_target_dependencies(test_security_logging)\ndiff --git rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp\nnew file mode 100644\nindex 0000000..c0428a8\n--- /dev/null\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/test/test_rmw_qos_to_dds_attributes.cpp\n@@ -0,0 \u002B1,171 @@\n\u002B// Copyright 2017 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Ctuple\u003E\n\u002B\n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022fastrtps/attributes/PublisherAttributes.h\u0022\n\u002B#include \u0022fastrtps/attributes/SubscriberAttributes.h\u0022\n\u002B\n\u002B#include \u0022rmw_fastrtps_shared_cpp/qos.hpp\u0022\n\u002B\n\u002B#include \u0022rmw/error_handling.h\u0022\n\u002B\n\u002B\n\u002Busing eprosima::fastrtps::SubscriberAttributes;\n\u002B\n\u002Bclass GetDataReaderQoSTest : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n\u002B  SubscriberAttributes subscriber_attributes_{};\n\u002B};\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, test_unknown_history_policy_conversion_fails) {\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_reliability_policy_conversion_fails) {\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_durability_policy_conversion_fails) {\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, unknown_liveliness_policy_conversion_fails) {\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataReaderQoSTest, nominal_conversion) {\n\u002B  qos_profile_.depth = 10u;\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n\u002B  qos_profile_.lifespan.sec = 0u;\n\u002B  qos_profile_.lifespan.nsec = 500000000u;\n\u002B  qos_profile_.deadline.sec = 0u;\n\u002B  qos_profile_.deadline.nsec = 100000000u;\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  qos_profile_.liveliness_lease_duration.sec = 10u;\n\u002B  qos_profile_.liveliness_lease_duration.nsec = 0u;\n\u002B\n\u002B  EXPECT_TRUE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n\u002B    subscriber_attributes_.qos.m_reliability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n\u002B    subscriber_attributes_.qos.m_durability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n\u002B    subscriber_attributes_.qos.m_liveliness.kind);\n\u002B  EXPECT_EQ(0, subscriber_attributes_.qos.m_lifespan.duration.seconds);\n\u002B  EXPECT_EQ(500000000u, subscriber_attributes_.qos.m_lifespan.duration.nanosec);\n\u002B  EXPECT_EQ(0, subscriber_attributes_.qos.m_deadline.period.seconds);\n\u002B  EXPECT_EQ(100000000u, subscriber_attributes_.qos.m_deadline.period.nanosec);\n\u002B  EXPECT_EQ(10, subscriber_attributes_.qos.m_liveliness.lease_duration.seconds);\n\u002B  EXPECT_EQ(0u, subscriber_attributes_.qos.m_liveliness.lease_duration.nanosec);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n\u002B    subscriber_attributes_.topic.historyQos.kind);\n\u002B  EXPECT_EQ(10, subscriber_attributes_.topic.historyQos.depth);\n\u002B}\n\u002B\n\u002Busing eprosima::fastrtps::PublisherAttributes;\n\u002B\n\u002Bclass GetDataWriterQoSTest : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n\u002B  PublisherAttributes publisher_attributes_{};\n\u002B};\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, test_unknown_history_policy_conversion_fails) {\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_reliability_policy_conversion_fails) {\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_durability_policy_conversion_fails) {\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, unknown_liveliness_policy_conversion_fails) {\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n\u002B  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B  EXPECT_TRUE(rmw_error_is_set());\n\u002B  rmw_reset_error();\n\u002B}\n\u002B\n\u002BTEST_F(GetDataWriterQoSTest, nominal_conversion) {\n\u002B  qos_profile_.depth = 10u;\n\u002B  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n\u002B  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n\u002B  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n\u002B  qos_profile_.lifespan.sec = 0u;\n\u002B  qos_profile_.lifespan.nsec = 500000000u;\n\u002B  qos_profile_.deadline.sec = 0u;\n\u002B  qos_profile_.deadline.nsec = 100000000u;\n\u002B  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n\u002B  qos_profile_.liveliness_lease_duration.sec = 10u;\n\u002B  qos_profile_.liveliness_lease_duration.nsec = 0u;\n\u002B\n\u002B  EXPECT_TRUE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n\u002B    publisher_attributes_.qos.m_reliability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n\u002B    publisher_attributes_.qos.m_durability.kind);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n\u002B    publisher_attributes_.qos.m_liveliness.kind);\n\u002B  EXPECT_EQ(0, publisher_attributes_.qos.m_lifespan.duration.seconds);\n\u002B  EXPECT_EQ(500000000u, publisher_attributes_.qos.m_lifespan.duration.nanosec);\n\u002B  EXPECT_EQ(0, publisher_attributes_.qos.m_deadline.period.seconds);\n\u002B  EXPECT_EQ(100000000u, publisher_attributes_.qos.m_deadline.period.nanosec);\n\u002B  EXPECT_EQ(10, publisher_attributes_.qos.m_liveliness.lease_duration.seconds);\n\u002B  EXPECT_EQ(0u, publisher_attributes_.qos.m_liveliness.lease_duration.nanosec);\n\u002B  EXPECT_EQ(\n\u002B    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n\u002B    publisher_attributes_.topic.historyQos.kind);\n\u002B  EXPECT_EQ(10, publisher_attributes_.topic.historyQos.depth);\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "3c604d41031136ba7bb4531d44c6506a182a76d4",
    "RawMessage": "Add rmw count clients services impl (#93)",
    "Changes": "diff --git rmw_connextdds/src/rmw_api_impl_ndds.cpp rmw_connextdds/src/rmw_api_impl_ndds.cpp\nindex 76b9f8a..e44df00 100644\n--- rmw_connextdds/src/rmw_api_impl_ndds.cpp\n\u002B\u002B\u002B rmw_connextdds/src/rmw_api_impl_ndds.cpp\n@@ -218,6 \u002B218,25 @@ rmw_count_subscribers(\n }\n \n \n\u002Brmw_ret_t\n\u002Brmw_count_clients(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  return rmw_api_connextdds_count_clients(node, service_name, count);\n\u002B}\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_count_services(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  return rmw_api_connextdds_count_services(node, service_name, count);\n\u002B}\n\u002B\n\u002B\n rmw_ret_t\n rmw_get_subscriber_names_and_types_by_node(\n   const rmw_node_t * node,\ndiff --git rmw_connextdds_common/include/rmw_connextdds/rmw_api_impl.hpp rmw_connextdds_common/include/rmw_connextdds/rmw_api_impl.hpp\nindex 69be351..804b565 100644\n--- rmw_connextdds_common/include/rmw_connextdds/rmw_api_impl.hpp\n\u002B\u002B\u002B rmw_connextdds_common/include/rmw_connextdds/rmw_api_impl.hpp\n@@ -150,6 \u002B150,20 @@ rmw_api_connextdds_count_subscribers(\n   const char * topic_name,\n   size_t * count);\n \n\u002BRMW_CONNEXTDDS_PUBLIC\n\u002Brmw_ret_t\n\u002Brmw_api_connextdds_count_clients(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count);\n\u002B\n\u002BRMW_CONNEXTDDS_PUBLIC\n\u002Brmw_ret_t\n\u002Brmw_api_connextdds_count_services(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count);\n\u002B\n RMW_CONNEXTDDS_PUBLIC\n rmw_ret_t\n rmw_api_connextdds_get_subscriber_names_and_types_by_node(\ndiff --git rmw_connextdds_common/src/common/rmw_info.cpp rmw_connextdds_common/src/common/rmw_info.cpp\nindex de6829d..cabdcad 100644\n--- rmw_connextdds_common/src/common/rmw_info.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_info.cpp\n@@ -294,6 \u002B294,80 @@ rmw_api_connextdds_count_subscribers(\n }\n \n \n\u002Brmw_ret_t\n\u002Brmw_api_connextdds_count_clients(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node,\n\u002B    node-\u003Eimplementation_identifier,\n\u002B    RMW_CONNEXTDDS_ID,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  int validation_result = RMW_TOPIC_VALID;\n\u002B  rmw_ret_t ret =\n\u002B    rmw_validate_full_topic_name(service_name, \u0026validation_result, nullptr);\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    return ret;\n\u002B  }\n\u002B  if (RMW_TOPIC_VALID != validation_result) {\n\u002B    const char * reason =\n\u002B      rmw_full_topic_name_validation_result_string(validation_result);\n\u002B    RMW_CONNEXT_LOG_ERROR_A_SET(\u0022invalid service name: %s\u0022, reason)\n\u002B    return RMW_RET_INVALID_ARGUMENT;\n\u002B  }\n\u002B\n\u002B  auto common_context = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  const std::string mangled_rp_service_name =\n\u002B    rmw_connextdds_create_topic_name(\n\u002B    ROS_SERVICE_RESPONSE_PREFIX, service_name, \u0022Reply\u0022, false);\n\u002B  return common_context-\u003Egraph_cache.get_reader_count(\n\u002B    mangled_rp_service_name, count);\n\u002B}\n\u002B\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_api_connextdds_count_services(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node,\n\u002B    node-\u003Eimplementation_identifier,\n\u002B    RMW_CONNEXTDDS_ID,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  int validation_result = RMW_TOPIC_VALID;\n\u002B  rmw_ret_t ret =\n\u002B    rmw_validate_full_topic_name(service_name, \u0026validation_result, nullptr);\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    return ret;\n\u002B  }\n\u002B  if (RMW_TOPIC_VALID != validation_result) {\n\u002B    const char * reason =\n\u002B      rmw_full_topic_name_validation_result_string(validation_result);\n\u002B    RMW_CONNEXT_LOG_ERROR_A_SET(\u0022invalid service name: %s\u0022, reason)\n\u002B    return RMW_RET_INVALID_ARGUMENT;\n\u002B  }\n\u002B\n\u002B  auto common_context = \u0026node-\u003Econtext-\u003Eimpl-\u003Ecommon;\n\u002B  const std::string mangled_rp_service_name =\n\u002B    rmw_connextdds_create_topic_name(\n\u002B    ROS_SERVICE_RESPONSE_PREFIX, service_name, \u0022Reply\u0022, false);\n\u002B  return common_context-\u003Egraph_cache.get_writer_count(\n\u002B    mangled_rp_service_name, count);\n\u002B}\n\u002B\n\u002B\n using GetNamesAndTypesByNodeFunction = rmw_ret_t (*)(\n   rmw_dds_common::Context *,\n   const std::string \u0026,\ndiff --git rmw_connextddsmicro/src/rmw_api_impl_rtime.cpp rmw_connextddsmicro/src/rmw_api_impl_rtime.cpp\nindex 08f8e89..3aaf5e9 100644\n--- rmw_connextddsmicro/src/rmw_api_impl_rtime.cpp\n\u002B\u002B\u002B rmw_connextddsmicro/src/rmw_api_impl_rtime.cpp\n@@ -219,6 \u002B219,26 @@ rmw_count_subscribers(\n }\n \n \n\u002Brmw_ret_t\n\u002Brmw_count_clients(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  return rmw_api_connextdds_count_clients(node, service_name, count);\n\u002B}\n\u002B\n\u002B\n\u002Brmw_ret_t\n\u002Brmw_count_services(\n\u002B  const rmw_node_t * node,\n\u002B  const char * service_name,\n\u002B  size_t * count)\n\u002B{\n\u002B  return rmw_api_connextdds_count_services(node, service_name, count);\n\u002B}\n\u002B\n\u002B\n rmw_ret_t\n rmw_get_subscriber_names_and_types_by_node(\n   const rmw_node_t * node,\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "5204835dec4979dc0bb272d72d37cde03a849404",
    "RawMessage": "Check for message_info on take where appropriate. (#245)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 3704b7f..32cb8f6 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -2524,9 \u002B2524,6 @@ static rmw_ret_t rmw_take_int(\n   RMW_CHECK_ARGUMENT_FOR_NULL(\n     subscription, RMW_RET_INVALID_ARGUMENT);\n \n-  RMW_CHECK_ARGUMENT_FOR_NULL(\n-    message_info, RMW_RET_INVALID_ARGUMENT);\n-\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n     subscription handle,\n     subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n@@ -2724,6 \u002B2721,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_take_with_info(\n   rmw_subscription_allocation_t * allocation)\n {\n   static_cast\u003Cvoid\u003E(allocation);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(message_info, RMW_RET_INVALID_ARGUMENT);\n   return rmw_take_int(subscription, ros_message, taken, message_info);\n }\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "geometry2",
    "SHA": "60e5060ae04f8f347c92246c5b7f95b4819d9797",
    "RawMessage": "Replace NULL with nullptr.",
    "Changes": "diff --git tf2/include/tf2/buffer_core.h tf2/include/tf2/buffer_core.h\nindex 0515cf0d..b2f1e491 100644\n--- tf2/include/tf2/buffer_core.h\n\u002B\u002B\u002B tf2/include/tf2/buffer_core.h\n@@ -161,13 \u002B161,13 @@ public:\n    * \\param target_frame The frame into which to transform\n    * \\param source_frame The frame from which to transform\n    * \\param time The time at which to transform\n-   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not NULL\n\u002B   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr\n    * \\return True if the transform is possible, false otherwise\n    */\n   TF2_PUBLIC\n   bool canTransform(\n     const std::string \u0026 target_frame, const std::string \u0026 source_frame,\n-    const TimePoint \u0026 time, std::string * error_msg = NULL) const override;\n\u002B    const TimePoint \u0026 time, std::string * error_msg = nullptr) const override;\n \n   /** \\brief Test if a transform is possible\n    * \\param target_frame The frame into which to transform\n@@ -175,14 \u002B175,14 @@ public:\n    * \\param source_frame The frame from which to transform\n    * \\param source_time The time from which to transform\n    * \\param fixed_frame The frame in which to treat the transform as constant in time\n-   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not NULL\n\u002B   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr\n    * \\return True if the transform is possible, false otherwise\n    */\n   TF2_PUBLIC\n   bool canTransform(\n     const std::string \u0026 target_frame, const TimePoint \u0026 target_time,\n     const std::string \u0026 source_frame, const TimePoint \u0026 source_time,\n-    const std::string \u0026 fixed_frame, std::string * error_msg = NULL) const override;\n\u002B    const std::string \u0026 fixed_frame, std::string * error_msg = nullptr) const override;\n \n   /** \\brief Get all frames that exist in the system.\n    */\n@@ -382,7 \u002B382,7 @@ private:\n     * \\param function_name_arg string to print out in the message,\n     *   the current function and argument name being validated\n     * \\param frame_id name of the tf frame to validate\n-    * \\param[out] error_msg if non-NULL, fill with produced error messaging.\n\u002B    * \\param[out] error_msg if non-nullptr, fill with produced error messaging.\n     *   Otherwise messages are logged as warning.\n     * \\return The CompactFrameID of the frame or 0 if not found.\n     */\n@@ -423,7 \u002B423,7 @@ private:\n     CompactFrameID target_frame, CompactFrameID source_frame,\n     TimePoint \u0026 time, std::string * error_string) const;\n \n-  /**@brief Traverse the transform tree. If frame_chain is not NULL, store the traversed frame tree in vector frame_chain.\n\u002B  /**@brief Traverse the transform tree. If frame_chain is not nullptr, store the traversed frame tree in vector frame_chain.\n    * */\n   template\u003Ctypename F\u003E\n   tf2::TF2Error walkToTopParent(\ndiff --git tf2/include/tf2/buffer_core_interface.h tf2/include/tf2/buffer_core_interface.h\nindex 3dd7cae4..f68512a6 100644\n--- tf2/include/tf2/buffer_core_interface.h\n\u002B\u002B\u002B tf2/include/tf2/buffer_core_interface.h\n@@ -98,7 \u002B98,7 @@ public:\n    * \\param source_frame The frame from which to transform.\n    * \\param time The time at which to transform.\n    * \\param error_msg A pointer to a string which will be filled with why the transform failed.\n-   *   Ignored if NULL.\n\u002B   *   Ignored if nullptr.\n    * \\return true if the transform is possible, false otherwise.\n    */\n   TF2_PUBLIC\n@@ -117,7 \u002B117,7 @@ public:\n    * \\param source_time The time from which to transform.\n    * \\param fixed_frame The frame in which to treat the transform as constant in time.\n    * \\param error_msg A pointer to a string which will be filled with why the transform failed.\n-   *   Ignored if NULL.\n\u002B   *   Ignored if nullptr.\n    * \\return true if the transform is possible, false otherwise.\n    */\n   TF2_PUBLIC\ndiff --git tf2/src/buffer_core.cpp tf2/src/buffer_core.cpp\nindex cd93b2d1..a84468ae 100644\n--- tf2/src/buffer_core.cpp\n\u002B\u002B\u002B tf2/src/buffer_core.cpp\n@@ -339,7 \u002B339,7 @@ bool BufferCore::setTransformImpl(\n     std::unique_lock\u003Cstd::mutex\u003E lock(frame_mutex_);\n     CompactFrameID frame_number = lookupOrInsertFrameNumber(stripped_child_frame_id);\n     TimeCacheInterfacePtr frame = getFrame(frame_number);\n-    if (frame == NULL) {\n\u002B    if (frame == nullptr) {\n       frame = allocateFrame(frame_number, is_static);\n     } else {\n       // Overwrite TimeCacheInterface type with a current input\n@@ -944,7 \u002B944,7 @@ std::string BufferCore::allFramesAsStringNoLock() const\n   // regular transforms\n   for (size_t counter = 1; counter \u003C frames_.size(); counter\u002B\u002B) {\n     TimeCacheInterfacePtr frame_ptr = getFrame(static_cast\u003CCompactFrameID\u003E(counter));\n-    if (frame_ptr == NULL) {\n\u002B    if (frame_ptr == nullptr) {\n       continue;\n     }\n     CompactFrameID frame_id_num;\n@@ -1308,7 \u002B1308,7 @@ bool BufferCore::_getParent(\n     return false;\n   }\n \n-  CompactFrameID parent_id = frame-\u003EgetParent(time, NULL);\n\u002B  CompactFrameID parent_id = frame-\u003EgetParent(time, nullptr);\n   if (parent_id == 0) {\n     return false;\n   }\ndiff --git tf2/src/time.cpp tf2/src/time.cpp\nindex 3b1bbc3f..44acb8e0 100644\n--- tf2/src/time.cpp\n\u002B\u002B\u002B tf2/src/time.cpp\n@@ -42,7 \u002B42,7 @@ std::string tf2::displayTimePoint(const tf2::TimePoint \u0026 stamp)\n \n   // Determine how many bytes to allocate for the string. If successful, buff_size does not count\n   // null terminating character. http://www.cplusplus.com/reference/cstdio/snprintf/\n-  int buff_size = rcutils_snprintf(NULL, 0, format_str, current_time);\n\u002B  int buff_size = rcutils_snprintf(nullptr, 0, format_str, current_time);\n   if (buff_size \u003C 0) {\n     char errmsg[200];\n     rcutils_strerror(errmsg, sizeof(errmsg));\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "bed714f5c95c06885098989b4107421dc0b60b2a",
    "RawMessage": "Avoid exception in Node constructor when use override for \u0027use_sim_time\u0027 (#896)",
    "Changes": "diff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex e5ac738..983c4c4 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -207,11 \u002B207,7 @@ class Node:\n             self._parameter_overrides.update({p.name: p for p in parameter_overrides})\n \n         # Clock that has support for ROS time.\n-        # Note: parameter overrides and parameter event publisher need to be ready at this point\n-        # to be able to declare \u0027use_sim_time\u0027 if it was not declared yet.\n         self._clock = ROSClock()\n-        self._time_source = TimeSource(node=self)\n-        self._time_source.attach_clock(self._clock)\n \n         if automatically_declare_parameters_from_overrides:\n             self.declare_parameters(\n@@ -222,6 \u002B218,12 @@ class Node:\n                 ignore_override=True,\n             )\n \n\u002B        # Init a time source.\n\u002B        # Note: parameter overrides and parameter event publisher need to be ready at this point\n\u002B        # to be able to declare \u0027use_sim_time\u0027 if it was not declared yet.\n\u002B        self._time_source = TimeSource(node=self)\n\u002B        self._time_source.attach_clock(self._clock)\n\u002B\n         if start_parameter_services:\n             self._parameter_service = ParameterService(self)\n \ndiff --git rclpy/test/test_create_node.py rclpy/test/test_create_node.py\nindex 3ec3c55..5440208 100644\n--- rclpy/test/test_create_node.py\n\u002B\u002B\u002B rclpy/test/test_create_node.py\n@@ -18,6 \u002B18,7 @@ import rclpy\n \n from rclpy.exceptions import InvalidNamespaceException\n from rclpy.exceptions import InvalidNodeNameException\n\u002Bfrom rclpy.parameter import Parameter\n \n \n class TestCreateNode(unittest.TestCase):\n@@ -71,6 \u002B72,16 @@ class TestCreateNode(unittest.TestCase):\n         with self.assertRaisesRegex(InvalidNamespaceException, \u0027must not contain characters\u0027):\n             rclpy.create_node(node_name, namespace=namespace, context=self.context)\n \n\u002B    def test_create_node_with_parameter_overrides(self):\n\u002B        node_name = \u0027create_node_with_parameter_overrides_test\u0027\n\u002B        rclpy.create_node(\n\u002B            node_name, context=self.context,\n\u002B            automatically_declare_parameters_from_overrides=True,\n\u002B            parameter_overrides=[\n\u002B                Parameter(\u0027use_sim_time\u0027, Parameter.Type.BOOL, True)\n\u002B            ]\n\u002B        ).destroy_node()\n\u002B\n \n if __name__ == \u0027__main__\u0027:\n     unittest.main()\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "e103b8d37ed14216b495b75c72dda82cb7f98c6f",
    "RawMessage": "fix(ClientGoalHandle): Made mutex recursive to prevent deadlocks (#2267)",
    "Changes": "diff --git rclcpp_action/include/rclcpp_action/client_goal_handle.hpp rclcpp_action/include/rclcpp_action/client_goal_handle.hpp\nindex dd3a4067..73987ec8 100644\n--- rclcpp_action/include/rclcpp_action/client_goal_handle.hpp\n\u002B\u002B\u002B rclcpp_action/include/rclcpp_action/client_goal_handle.hpp\n@@ -163,7 \u002B163,7 @@ private:\n   ResultCallback result_callback_{nullptr};\n   int8_t status_{GoalStatus::STATUS_ACCEPTED};\n \n-  std::mutex handle_mutex_;\n\u002B  std::recursive_mutex handle_mutex_;\n };\n }  // namespace rclcpp_action\n \ndiff --git rclcpp_action/include/rclcpp_action/client_goal_handle_impl.hpp rclcpp_action/include/rclcpp_action/client_goal_handle_impl.hpp\nindex 0c25e524..d12b4fc5 100644\n--- rclcpp_action/include/rclcpp_action/client_goal_handle_impl.hpp\n\u002B\u002B\u002B rclcpp_action/include/rclcpp_action/client_goal_handle_impl.hpp\n@@ -59,7 \u002B59,7 @@ template\u003Ctypename ActionT\u003E\n std::shared_future\u003Ctypename ClientGoalHandle\u003CActionT\u003E::WrappedResult\u003E\n ClientGoalHandle\u003CActionT\u003E::async_get_result()\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   if (!is_result_aware_) {\n     throw exceptions::UnawareGoalHandleError();\n   }\n@@ -70,7 \u002B70,7 @@ template\u003Ctypename ActionT\u003E\n void\n ClientGoalHandle\u003CActionT\u003E::set_result(const WrappedResult \u0026 wrapped_result)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   status_ = static_cast\u003Cint8_t\u003E(wrapped_result.code);\n   result_promise_.set_value(wrapped_result);\n   if (result_callback_) {\n@@ -82,7 \u002B82,7 @@ template\u003Ctypename ActionT\u003E\n void\n ClientGoalHandle\u003CActionT\u003E::set_feedback_callback(FeedbackCallback callback)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   feedback_callback_ = callback;\n }\n \n@@ -90,7 \u002B90,7 @@ template\u003Ctypename ActionT\u003E\n void\n ClientGoalHandle\u003CActionT\u003E::set_result_callback(ResultCallback callback)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   result_callback_ = callback;\n }\n \n@@ -98,7 \u002B98,7 @@ template\u003Ctypename ActionT\u003E\n int8_t\n ClientGoalHandle\u003CActionT\u003E::get_status()\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   return status_;\n }\n \n@@ -106,7 \u002B106,7 @@ template\u003Ctypename ActionT\u003E\n void\n ClientGoalHandle\u003CActionT\u003E::set_status(int8_t status)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   status_ = status;\n }\n \n@@ -114,7 \u002B114,7 @@ template\u003Ctypename ActionT\u003E\n bool\n ClientGoalHandle\u003CActionT\u003E::is_feedback_aware()\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   return feedback_callback_ != nullptr;\n }\n \n@@ -122,7 \u002B122,7 @@ template\u003Ctypename ActionT\u003E\n bool\n ClientGoalHandle\u003CActionT\u003E::is_result_aware()\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   return is_result_aware_;\n }\n \n@@ -130,7 \u002B130,7 @@ template\u003Ctypename ActionT\u003E\n bool\n ClientGoalHandle\u003CActionT\u003E::set_result_awareness(bool awareness)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   bool previous = is_result_aware_;\n   is_result_aware_ = awareness;\n   return previous;\n@@ -140,7 \u002B140,7 @@ template\u003Ctypename ActionT\u003E\n void\n ClientGoalHandle\u003CActionT\u003E::invalidate(const exceptions::UnawareGoalHandleError \u0026 ex)\n {\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   // Guard against multiple calls\n   if (is_invalidated()) {\n     return;\n@@ -168,7 \u002B168,7 @@ ClientGoalHandle\u003CActionT\u003E::call_feedback_callback(\n     RCLCPP_ERROR(rclcpp::get_logger(\u0022rclcpp_action\u0022), \u0022Sent feedback to wrong goal handle.\u0022);\n     return;\n   }\n-  std::lock_guard\u003Cstd::mutex\u003E guard(handle_mutex_);\n\u002B  std::lock_guard\u003Cstd::recursive_mutex\u003E guard(handle_mutex_);\n   if (nullptr == feedback_callback_) {\n     // Normal, some feedback messages may arrive after the goal result.\n     RCLCPP_DEBUG(rclcpp::get_logger(\u0022rclcpp_action\u0022), \u0022Received feedback but goal ignores it.\u0022);\ndiff --git rclcpp_action/test/test_client.cpp rclcpp_action/test/test_client.cpp\nindex b94a82d5..b180c3f8 100644\n--- rclcpp_action/test/test_client.cpp\n\u002B\u002B\u002B rclcpp_action/test/test_client.cpp\n@@ -852,6 \u002B852,86 @@ TEST_F(TestClientAgainstServer, async_cancel_some_goals_with_callback)\n   EXPECT_EQ(rclcpp_action::GoalStatus::STATUS_CANCELED, goal_handle0-\u003Eget_status());\n }\n \n\u002BTEST_F(TestClientAgainstServer, deadlock_in_callbacks)\n\u002B{\n\u002B  std::atomic\u003Cbool\u003E feedback_callback_called = false;\n\u002B  std::atomic\u003Cbool\u003E response_callback_called = false;\n\u002B  std::atomic\u003Cbool\u003E result_callback_called = false;\n\u002B  std::atomic\u003Cbool\u003E no_deadlock = false;\n\u002B\n\u002B  std::thread tr = std::thread(\n\u002B    [\u0026]() {\n\u002B      auto action_client = rclcpp_action::create_client\u003CActionType\u003E(client_node, action_name);\n\u002B      ASSERT_TRUE(action_client-\u003Ewait_for_action_server(WAIT_FOR_SERVER_TIMEOUT));\n\u002B\n\u002B      ActionGoal goal;\n\u002B\n\u002B      using GoalHandle = rclcpp_action::ClientGoalHandle\u003CActionType\u003E;\n\u002B      rclcpp_action::Client\u003CActionType\u003E::SendGoalOptions ops;\n\u002B      ops.feedback_callback =\n\u002B      [\u0026feedback_callback_called](const GoalHandle::SharedPtr handle,\n\u002B      ActionType::Feedback::ConstSharedPtr) {\n\u002B        // call functions on the handle that acquire the lock\n\u002B        handle-\u003Eget_status();\n\u002B        handle-\u003Eis_feedback_aware();\n\u002B        handle-\u003Eis_result_aware();\n\u002B\n\u002B        feedback_callback_called = true;\n\u002B      };\n\u002B      ops.goal_response_callback = [\u0026response_callback_called](\n\u002B        const GoalHandle::SharedPtr \u0026 handle) {\n\u002B        // call functions on the handle that acquire the lock\n\u002B        handle-\u003Eget_status();\n\u002B        handle-\u003Eis_feedback_aware();\n\u002B        handle-\u003Eis_result_aware();\n\u002B\n\u002B        response_callback_called = true;\n\u002B      };\n\u002B      ops.result_callback = [\u0026result_callback_called](\n\u002B        const GoalHandle::WrappedResult \u0026) {\n\u002B        result_callback_called = true;\n\u002B      };\n\u002B\n\u002B      goal.order = 6;\n\u002B      auto future_goal_handle = action_client-\u003Easync_send_goal(goal, ops);\n\u002B      dual_spin_until_future_complete(future_goal_handle);\n\u002B      auto goal_handle = future_goal_handle.get();\n\u002B\n\u002B      ASSERT_TRUE(goal_handle);\n\u002B\n\u002B      ASSERT_EQ(RCL_RET_OK, rcl_set_ros_time_override(clock.get_clock_handle(), RCL_S_TO_NS(2)));\n\u002B\n\u002B      auto result_future = action_client-\u003Easync_get_result(goal_handle);\n\u002B      dual_spin_until_future_complete(result_future);\n\u002B\n\u002B      EXPECT_TRUE(result_future.valid());\n\u002B      auto result = result_future.get();\n\u002B\n\u002B      no_deadlock = true;\n\u002B    });\n\u002B\n\u002B  auto start_time = std::chrono::system_clock::now();\n\u002B\n\u002B  while (std::chrono::system_clock::now() - start_time \u003C std::chrono::milliseconds(2000) \u0026\u0026\n\u002B    !no_deadlock)\n\u002B  {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\u002B  }\n\u002B\n\u002B  if (no_deadlock) {\n\u002B    tr.join();\n\u002B  } else {\n\u002B    // In case of a failure, the thread is assumed to be in a deadlock.\n\u002B    // We detach the thread so we don\u0027t block further tests.\n\u002B    tr.detach();\n\u002B  }\n\u002B\n\u002B  EXPECT_TRUE(no_deadlock);\n\u002B  EXPECT_TRUE(response_callback_called);\n\u002B  EXPECT_TRUE(result_callback_called);\n\u002B  EXPECT_TRUE(feedback_callback_called);\n\u002B}\n\u002B\n TEST_F(TestClientAgainstServer, send_rcl_errors)\n {\n   auto action_client = rclcpp_action::create_client\u003CActionType\u003E(client_node, action_name);\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl_logging",
    "SHA": "72f3e6a13c964c70c0d9e1c370273f929f74d7fc",
    "RawMessage": "Fix include order for cpplint (#84)",
    "Changes": "diff --git rcl_logging_interface/test/test_get_logging_directory.cpp rcl_logging_interface/test/test_get_logging_directory.cpp\nindex ea58092..971b020 100644\n--- rcl_logging_interface/test/test_get_logging_directory.cpp\n\u002B\u002B\u002B rcl_logging_interface/test/test_get_logging_directory.cpp\n@@ -12,16 \u002B12,17 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcpputils/env.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-\n #include \u003Ciostream\u003E\n #include \u003Cstring\u003E\n \n #include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcpputils/env.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B\n #include \u0022rcl_logging_interface/rcl_logging_interface.h\u0022\n \n // This is a helper class that resets an environment\ndiff --git rcl_logging_spdlog/src/rcl_logging_spdlog.cpp rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\nindex 5eccab3..2295b5f 100644\n--- rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\n\u002B\u002B\u002B rcl_logging_spdlog/src/rcl_logging_spdlog.cpp\n@@ -12,13 \u002B12,6 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/logging.h\u003E\n-#include \u003Crcutils/process.h\u003E\n-#include \u003Crcutils/snprintf.h\u003E\n-#include \u003Crcutils/time.h\u003E\n-\n #include \u003Ccerrno\u003E\n #include \u003Ccinttypes\u003E\n #include \u003Cmemory\u003E\n@@ -26,6 \u002B19,13 @@\n #include \u003Cstring\u003E\n #include \u003Cutility\u003E\n \n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/logging.h\u0022\n\u002B#include \u0022rcutils/process.h\u0022\n\u002B#include \u0022rcutils/snprintf.h\u0022\n\u002B#include \u0022rcutils/time.h\u0022\n\u002B\n #include \u0022spdlog/spdlog.h\u0022\n #include \u0022spdlog/sinks/basic_file_sink.h\u0022\n \ndiff --git rcl_logging_spdlog/test/fixtures.hpp rcl_logging_spdlog/test/fixtures.hpp\nindex ecdc627..85697f9 100644\n--- rcl_logging_spdlog/test/fixtures.hpp\n\u002B\u002B\u002B rcl_logging_spdlog/test/fixtures.hpp\n@@ -15,13 \u002B15,6 @@\n #ifndef FIXTURES_HPP_\n #define FIXTURES_HPP_\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-#include \u003Crcutils/process.h\u003E\n-#include \u003Crcutils/types/string_array.h\u003E\n-\n #include \u003Climits.h\u003E\n #ifdef _WIN32\n # include \u003Cwindows.h\u003E  // MAX_PATH\n@@ -30,6 \u002B23,13 @@\n \n #include \u0022gtest/gtest.h\u0022\n \n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B#include \u0022rcutils/process.h\u0022\n\u002B#include \u0022rcutils/types/string_array.h\u0022\n\u002B\n #ifdef _WIN32\n #define popen _popen\n #define pclose _pclose\ndiff --git rcl_logging_spdlog/test/test_logging_interface.cpp rcl_logging_spdlog/test/test_logging_interface.cpp\nindex 8f97458..17be297 100644\n--- rcl_logging_spdlog/test/test_logging_interface.cpp\n\u002B\u002B\u002B rcl_logging_spdlog/test/test_logging_interface.cpp\n@@ -12,20 \u002B12,21 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Crcpputils/filesystem_helper.hpp\u003E\n-#include \u003Crcpputils/env.hpp\u003E\n-#include \u003Crcutils/allocator.h\u003E\n-#include \u003Crcutils/env.h\u003E\n-#include \u003Crcutils/error_handling.h\u003E\n-#include \u003Crcutils/logging.h\u003E\n-#include \u003Crcutils/testing/fault_injection.h\u003E\n-\n #include \u003Climits.h\u003E\n #include \u003Cfstream\u003E\n #include \u003Cstring\u003E\n \n-#include \u0022fixtures.hpp\u0022\n #include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/filesystem_helper.hpp\u0022\n\u002B#include \u0022rcpputils/env.hpp\u0022\n\u002B#include \u0022rcutils/allocator.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n\u002B#include \u0022rcutils/error_handling.h\u0022\n\u002B#include \u0022rcutils/logging.h\u0022\n\u002B#include \u0022rcutils/testing/fault_injection.h\u0022\n\u002B\n\u002B#include \u0022fixtures.hpp\u0022\n #include \u0022rcl_logging_interface/rcl_logging_interface.h\u0022\n \n const int logger_levels[] =\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_python",
    "SHA": "122b738f3b490280c217440e0bc2f5904f10fe3b",
    "RawMessage": "Service introspection (#178)",
    "Changes": "diff --git rosidl_generator_py/resource/_idl_support.c.em rosidl_generator_py/resource/_idl_support.c.em\nindex abb7536..d46c022 100644\n--- rosidl_generator_py/resource/_idl_support.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_idl_support.c.em\n@@ -50,6 \u002B50,13 @@ TEMPLATE(\n     package_name=package_name, interface_path=interface_path,\n     message=service.response_message, include_directives=include_directives)\n }@\n\u002B\n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=service.event_message, include_directives=include_directives)\n\u002B}@\n @[end for]@\n @\n @#######################################################################\n@@ -97,6 \u002B104,14 @@ TEMPLATE(\n     include_directives=include_directives)\n }@\n \n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=action.send_goal_service.event_message,\n\u002B    include_directives=include_directives)\n\u002B}@\n\u002B\n @{\n TEMPLATE(\n     \u0027_msg_support.c.em\u0027,\n@@ -113,6 \u002B128,14 @@ TEMPLATE(\n     include_directives=include_directives)\n }@\n \n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_support.c.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=action.get_result_service.event_message,\n\u002B    include_directives=include_directives)\n\u002B}@\n\u002B\n @{\n TEMPLATE(\n     \u0027_msg_support.c.em\u0027,\ndiff --git rosidl_generator_py/resource/_msg.py.em rosidl_generator_py/resource/_msg.py.em\nindex b2cc43d..a5b9cab 100644\n--- rosidl_generator_py/resource/_msg.py.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_msg.py.em\n@@ -13,6 \u002B13,9 @@ from rosidl_parser.definition import AbstractWString\n from rosidl_parser.definition import ACTION_FEEDBACK_SUFFIX\n from rosidl_parser.definition import ACTION_GOAL_SUFFIX\n from rosidl_parser.definition import ACTION_RESULT_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_EVENT_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX\n from rosidl_parser.definition import Array\n from rosidl_parser.definition import BasicType\n from rosidl_parser.definition import BOOLEAN_TYPE\n@@ -129,6 \u002B132,11 @@ for member in message.structure.members:\n     if isinstance(type_, AbstractNestedType):\n         type_ = type_.value_type\n     if isinstance(type_, NamespacedType):\n\u002B        if (\n\u002B            type_.name.endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX) or\n\u002B            type_.name.endswith(SERVICE_REQUEST_MESSAGE_SUFFIX)\n\u002B        ):\n\u002B            continue\n         if (\n             type_.name.endswith(ACTION_GOAL_SUFFIX) or\n             type_.name.endswith(ACTION_RESULT_SUFFIX) or\ndiff --git rosidl_generator_py/resource/_msg_support.c.em rosidl_generator_py/resource/_msg_support.c.em\nindex efa53a1..1afdafb 100644\n--- rosidl_generator_py/resource/_msg_support.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_msg_support.c.em\n@@ -11,6 \u002B11,8 @@ from rosidl_parser.definition import Array\n from rosidl_parser.definition import BasicType\n from rosidl_parser.definition import EMPTY_STRUCTURE_REQUIRED_MEMBER_NAME\n from rosidl_parser.definition import NamespacedType\n\u002Bfrom rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX\n\u002Bfrom rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX\n \n \n def primitive_msg_type_to_c(type_):\n@@ -119,7 \u002B121,10 @@ if isinstance(member.type, AbstractNestedType) and isinstance(member.type.value_\n nested_header = \u0027/\u0027.join(type_[:-1] \u002B (\u0027detail\u0027, convert_camel_case_to_lower_case_underscore(type_[-1]),))\n nested_header \u002B= \u0027__functions.h\u0027\n }@\n-@[    if nested_header in include_directives]@\n\u002B@[    if type_[-1].endswith(SERVICE_REQUEST_MESSAGE_SUFFIX) or type_[-1].endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX)]\n\u002B@# Service request/response messages are included in the srv__struct\n\u002B@[continue]\n\u002B@[    elif nested_header in include_directives]@\n // already included above\n // @\n @[    else]@\ndiff --git rosidl_generator_py/resource/_srv.py.em rosidl_generator_py/resource/_srv.py.em\nindex ccd6d90..24d4548 100644\n--- rosidl_generator_py/resource/_srv.py.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_srv.py.em\n@@ -13,6 \u002B13,10 @@ TEMPLATE(\n     \u0027_msg.py.em\u0027,\n     package_name=package_name, interface_path=interface_path,\n     message=service.response_message, import_statements=import_statements)\n\u002BTEMPLATE(\n\u002B    \u0027_msg.py.em\u0027,\n\u002B    package_name=package_name, interface_path=interface_path,\n\u002B    message=service.event_message, import_statements=import_statements)\n }@\n \n \n@@ -42,11 \u002B46,14 @@ class Metaclass_@(service.namespaced_type.name)(type):\n                 @(module_name).Metaclass_@(service.request_message.structure.namespaced_type.name).__import_type_support__()\n             if @(module_name).Metaclass_@(service.response_message.structure.namespaced_type.name)._TYPE_SUPPORT is None:\n                 @(module_name).Metaclass_@(service.response_message.structure.namespaced_type.name).__import_type_support__()\n\u002B            if @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name)._TYPE_SUPPORT is None:\n\u002B                @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name).__import_type_support__()\n \n \n class @(service.namespaced_type.name)(metaclass=Metaclass_@(service.namespaced_type.name)):\n     from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.request_message.structure.namespaced_type.name) as Request\n     from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.response_message.structure.namespaced_type.name) as Response\n\u002B    from @(\u0027.\u0027.join(service.namespaced_type.namespaces)).@(module_name) import @(service.event_message.structure.namespaced_type.name) as Event\n \n     def __init__(self):\n         raise NotImplementedError(\u0027Service classes can not be instantiated\u0027)\ndiff --git rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\nindex e5ab4f1..353b01f 100644\n--- rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\n\u002B\u002B\u002B rosidl_generator_py/resource/_srv_pkg_typesupport_entry_point.c.em\n@@ -16,6 \u002B16,15 @@ TEMPLATE(\n     include_directives=include_directives,\n     register_functions=register_functions)\n }@\n\u002B\n\u002B@{\n\u002BTEMPLATE(\n\u002B    \u0027_msg_pkg_typesupport_entry_point.c.em\u0027,\n\u002B    package_name=package_name, idl_type=idl_type,\n\u002B    message=service.event_message, typesupport_impl=typesupport_impl,\n\u002B    include_directives=include_directives,\n\u002B    register_functions=register_functions)\n\u002B}@\n @\n @{\n from rosidl_pycommon import convert_camel_case_to_lower_case_underscore\ndiff --git rosidl_generator_py/rosidl_generator_py/generate_py_impl.py rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\nindex 87a9f27..0cbaaa1 100644\n--- rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n\u002B\u002B\u002B rosidl_generator_py/rosidl_generator_py/generate_py_impl.py\n@@ -131,6 \u002B131,35 @@ def generate_py(generator_arguments_file, typesupport_impls):\n                 f.write(\n                     f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n                     f\u0027{idl_stem}  # noqa: F401\\n\u0027)\n\u002B                if subfolder == \u0027srv\u0027:\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_Response  # noqa: F401\\n\u0027)\n\u002B                elif subfolder == \u0027action\u0027:\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_GetResult_Response  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Event  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Request  # noqa: F401\\n\u0027)\n\u002B                    f.write(\n\u002B                        f\u0027from {package_name}.{subfolder}.{module_name} import \u0027\n\u002B                        f\u0027{idl_stem}_SendGoal_Response  # noqa: F401\\n\u0027)\n \n     # expand templates per available typesupport implementation\n     template_dir = args[\u0027template_dir\u0027]\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "58580e86610f46867af8c4cabb56b86ad6ca2794",
    "RawMessage": "Add RCUTILS_NO_FAULT_INJECTION() macro. (#295)",
    "Changes": "diff --git include/rcutils/testing/fault_injection.h include/rcutils/testing/fault_injection.h\nindex 3455832..d397fd7 100644\n--- include/rcutils/testing/fault_injection.h\n\u002B\u002B\u002B include/rcutils/testing/fault_injection.h\n@@ -167,6 \u002B167,38 @@ _rcutils_fault_injection_maybe_fail(void);\n     rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL); \\\n   } while (0)\n \n\u002B/**\n\u002B * \\def RCUTILS_NO_FAULT_INJECTION\n\u002B *\n\u002B * A convenience macro built around rcutils_fault_injection_set_count() to pause fault\n\u002B * injection during \u0060code\u0060 execution.\n\u002B * This macro is intended to be used within RCUTILS_FAULT_INJECTION_TEST() blocks.\n\u002B *\n\u002B * \u0060code\u0060 is executed within a do-while loop and therefore any variables declared within are in\n\u002B * their own scope block.\n\u002B *\n\u002B * Here\u0027s a simple example:\n\u002B *  RCUTILS_FAULT_INJECTION_TEST({\n\u002B *    rcl_ret_t ret = rcl_init(argc, argv, options, context);\n\u002B *    if (RCL_RET_OK == ret)\n\u002B *    {\n\u002B *      RCUTILS_NO_FAULT_INJECTION({\n\u002B *        ret = rcl_shutdown(context);\n\u002B *      });\n\u002B *    }\n\u002B * });\n\u002B *\n\u002B * In this example, on successful rcl_init(), rcl_shutdown() is called while ensuring that\n\u002B * it will not fail due to fault injection.\n\u002B */\n\u002B#define RCUTILS_NO_FAULT_INJECTION(code) \\\n\u002B  do { \\\n\u002B    int64_t no_fault_injection_count = rcutils_fault_injection_get_count(); \\\n\u002B    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL); \\\n\u002B    code; \\\n\u002B    rcutils_fault_injection_set_count(no_fault_injection_count); \\\n\u002B  } while (0)\n\u002B\n #ifdef __cplusplus\n }\n #endif\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "f085598ca4b9482beabcc250fa93bdcab31b5f27",
    "RawMessage": "Added rmw_event_type_is_supported (#250)",
    "Changes": "diff --git rmw_implementation/src/functions.cpp rmw_implementation/src/functions.cpp\nindex dceb680..fc6e677 100644\n--- rmw_implementation/src/functions.cpp\n\u002B\u002B\u002B rmw_implementation/src/functions.cpp\n@@ -757,6 \u002B757,12 @@ RMW_INTERFACE_FN(\n   1, ARG_TYPES(\n     rmw_feature_t))\n \n\u002BRMW_INTERFACE_FN(\n\u002B  rmw_event_type_is_supported,\n\u002B  bool, RMW_EVENT_INVALID,\n\u002B  1, ARG_TYPES(\n\u002B    rmw_event_type_t))\n\u002B\n RMW_INTERFACE_FN(\n   rmw_take_dynamic_message,\n   rmw_ret_t, RMW_RET_ERROR,\n@@ -841,6 \u002B847,7 @@ void prefetch_symbols(void)\n   GET_SYMBOL(rmw_take_request)\n   GET_SYMBOL(rmw_send_response)\n   GET_SYMBOL(rmw_take_event)\n\u002B  GET_SYMBOL(rmw_event_type_is_supported)\n   GET_SYMBOL(rmw_create_guard_condition)\n   GET_SYMBOL(rmw_destroy_guard_condition)\n   GET_SYMBOL(rmw_trigger_guard_condition)\n@@ -999,6 \u002B1006,7 @@ unload_library()\n   symbol_rmw_client_set_on_new_response_callback = nullptr;\n   symbol_rmw_event_set_callback = nullptr;\n   symbol_rmw_feature_supported = nullptr;\n\u002B  symbol_rmw_event_type_is_supported = nullptr;\n   symbol_rmw_take_dynamic_message = nullptr;\n   symbol_rmw_take_dynamic_message_with_info = nullptr;\n   symbol_rmw_serialization_support_init = nullptr;\ndiff --git test_rmw_implementation/test/test_wait_set.cpp test_rmw_implementation/test/test_wait_set.cpp\nindex f2e7145..6c4bef4 100644\n--- test_rmw_implementation/test/test_wait_set.cpp\n\u002B\u002B\u002B test_rmw_implementation/test/test_wait_set.cpp\n@@ -120,9 \u002B120,7 @@ protected:\n     client = rmw_create_client(node, service_ts, service_name, \u0026rmw_qos_profile_default);\n     ASSERT_NE(nullptr, client) \u003C\u003C rmw_get_error_string().str;\n     rmw_ret_t ret = RMW_RET_OK;\n-    // rmw_zenoh does not support RMW_EVENT_LIVELINESS_CHANGED.\n-    // TODO(Yadunund): Rely on API suggested in https://github.com/ros2/rmw/issues/394 instead.\n-    if (std::string(rmw_get_implementation_identifier()).find(\u0022rmw_zenoh_cpp\u0022) == 0) {\n\u002B    if (!rmw_event_type_is_supported(RMW_EVENT_LIVELINESS_CHANGED)) {\n       ret = rmw_subscription_event_init(\u0026event, sub, RMW_EVENT_PUBLICATION_MATCHED);\n     } else {\n       ret = rmw_subscription_event_init(\u0026event, sub, RMW_EVENT_LIVELINESS_CHANGED);\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "78f5e14cdabeb047ab39829caef7a4872f3179ff",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#1382)",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\ndeleted file mode 100644\nindex 2885eb4..0000000\n--- .github/workflows/mirror-rolling-to-master.yaml\n\u002B\u002B\u002B /dev/null\n@@ -1,13 \u002B0,0 @@\n-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\ndiff --git CODEOWNERS CODEOWNERS\ndeleted file mode 100644\nindex afdb79e..0000000\n--- CODEOWNERS\n\u002B\u002B\u002B /dev/null\n@@ -1,2 \u002B0,0 @@\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz @adityapande-1995\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "ecf89588454478c8c75a87f30b90378742518d8c",
    "RawMessage": "Include type hash in topic endpoint info (#1104)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 88d17d8..a6e2be9 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -203,6 \u002B203,7 @@ if(BUILD_TESTING)\n       test/test_topic_or_service_is_hidden.py\n       test/test_topic_endpoint_info.py\n       test/test_type_support.py\n\u002B      test/test_type_hash.py\n       test/test_utilities.py\n       test/test_validate_full_topic_name.py\n       test/test_validate_namespace.py\ndiff --git rclpy/rclpy/topic_endpoint_info.py rclpy/rclpy/topic_endpoint_info.py\nindex 9fc41f7..110080a 100644\n--- rclpy/rclpy/topic_endpoint_info.py\n\u002B\u002B\u002B rclpy/rclpy/topic_endpoint_info.py\n@@ -15,6 \u002B15,7 @@\n from enum import IntEnum\n \n from rclpy.qos import QoSHistoryPolicy, QoSPresetProfiles, QoSProfile\n\u002Bfrom rclpy.type_hash import TypeHash\n \n \n class TopicEndpointTypeEnum(IntEnum):\n@@ -36,6 \u002B37,7 @@ class TopicEndpointInfo:\n         \u0027_node_name\u0027,\n         \u0027_node_namespace\u0027,\n         \u0027_topic_type\u0027,\n\u002B        \u0027_topic_type_hash\u0027,\n         \u0027_endpoint_type\u0027,\n         \u0027_endpoint_gid\u0027,\n         \u0027_qos_profile\u0027\n@@ -48,6 \u002B50,7 @@ class TopicEndpointInfo:\n         self.node_name = kwargs.get(\u0027node_name\u0027, \u0027\u0027)\n         self.node_namespace = kwargs.get(\u0027node_namespace\u0027, \u0027\u0027)\n         self.topic_type = kwargs.get(\u0027topic_type\u0027, \u0027\u0027)\n\u002B        self.topic_type_hash = kwargs.get(\u0027topic_type_hash\u0027, TypeHash())\n         self.endpoint_type = kwargs.get(\u0027endpoint_type\u0027, TopicEndpointTypeEnum.INVALID)\n         self.endpoint_gid = kwargs.get(\u0027endpoint_gid\u0027, [])\n         self.qos_profile = kwargs.get(\u0027qos_profile\u0027, QoSPresetProfiles.UNKNOWN.value)\n@@ -97,6 \u002B100,25 @@ class TopicEndpointInfo:\n         assert isinstance(value, str)\n         self._topic_type = value\n \n\u002B    @property\n\u002B    def topic_type_hash(self):\n\u002B        \u0022\u0022\u0022\n\u002B        Get field \u0027topic_type_hash\u0027.\n\u002B\n\u002B        :returns: topic_type_hash attribute\n\u002B        :rtype: TypeHash\n\u002B        \u0022\u0022\u0022\n\u002B        return self._topic_type_hash\n\u002B\n\u002B    @topic_type_hash.setter\n\u002B    def topic_type_hash(self, value):\n\u002B        if isinstance(value, TypeHash):\n\u002B            self._topic_type_hash = value\n\u002B        elif isinstance(value, dict):\n\u002B            self._topic_type_hash = TypeHash(**value)\n\u002B        else:\n\u002B            assert False\n\u002B\n     @property\n     def endpoint_type(self):\n         \u0022\u0022\u0022\n@@ -167,7 \u002B189,7 @@ class TopicEndpointInfo:\n             f\u0027Node name: {self.node_name}\u0027,\n             f\u0027Node namespace: {self.node_namespace}\u0027,\n             f\u0027Topic type: {self.topic_type}\u0027,\n-            \u0027Topic type hash: UNKNOWN\u0027,\n\u002B            f\u0027Topic type hash: {self.topic_type_hash}\u0027,\n             f\u0027Endpoint type: {self.endpoint_type.name}\u0027,\n             f\u0027GID: {gid}\u0027,\n             \u0027QoS profile:\u0027,\ndiff --git rclpy/rclpy/type_hash.py rclpy/rclpy/type_hash.py\nnew file mode 100644\nindex 0000000..f2f3ea4\n--- /dev/null\n\u002B\u002B\u002B rclpy/rclpy/type_hash.py\n@@ -0,0 \u002B1,74 @@\n\u002B# Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002B\n\u002Bclass TypeHash:\n\u002B    \u0022\u0022\u0022Type hash.\u0022\u0022\u0022\n\u002B\n\u002B    _TYPE_HASH_SIZE = 32\n\u002B\n\u002B    __slots__ = [\n\u002B        \u0027_version\u0027,\n\u002B        \u0027_value\u0027,\n\u002B    ]\n\u002B\n\u002B    def __init__(self, **kwargs):\n\u002B        assert all(\u0027_\u0027 \u002B key in self.__slots__ for key in kwargs.keys()), \\\n\u002B            \u0027Invalid arguments passed to constructor: %r\u0027 % kwargs.keys()\n\u002B\n\u002B        self.version = kwargs.get(\u0027version\u0027, -1)\n\u002B        self.value = kwargs.get(\u0027value\u0027, bytes(self._TYPE_HASH_SIZE))\n\u002B\n\u002B    @property\n\u002B    def version(self):\n\u002B        \u0022\u0022\u0022\n\u002B        Get field \u0027version\u0027.\n\u002B\n\u002B        :returns: version attribute\n\u002B        :rtype: int\n\u002B        \u0022\u0022\u0022\n\u002B        return self._version\n\u002B\n\u002B    @version.setter\n\u002B    def version(self, value):\n\u002B        assert isinstance(value, int)\n\u002B        self._version = value\n\u002B\n\u002B    @property\n\u002B    def value(self):\n\u002B        \u0022\u0022\u0022\n\u002B        Get field \u0027value\u0027.\n\u002B\n\u002B        :returns: value attribute\n\u002B        :rtype: bytes\n\u002B        \u0022\u0022\u0022\n\u002B        return self._value\n\u002B\n\u002B    @value.setter\n\u002B    def value(self, value):\n\u002B        assert isinstance(value, bytes)\n\u002B        self._value = value\n\u002B\n\u002B    def __eq__(self, other):\n\u002B        if not isinstance(other, TypeHash):\n\u002B            return False\n\u002B        return all(\n\u002B            self.__getattribute__(slot) == other.__getattribute__(slot)\n\u002B            for slot in self.__slots__)\n\u002B\n\u002B    def __str__(self):\n\u002B        if self._version \u003C= 0 or len(self._value) != self._TYPE_HASH_SIZE:\n\u002B            return \u0027INVALID\u0027\n\u002B\n\u002B        return f\u0027RIHS{self._version:02}_{self._value.hex()}\u0027\ndiff --git rclpy/src/rclpy/utils.cpp rclpy/src/rclpy/utils.cpp\nindex 82b8d2b..684b067 100644\n--- rclpy/src/rclpy/utils.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.cpp\n@@ -306,6 \u002B306,8 @@ _convert_to_py_topic_endpoint_info(const rmw_topic_endpoint_info_t * topic_endpo\n   py_endpoint_info_dict[\u0022node_name\u0022] = py::str(topic_endpoint_info-\u003Enode_name);\n   py_endpoint_info_dict[\u0022node_namespace\u0022] = py::str(topic_endpoint_info-\u003Enode_namespace);\n   py_endpoint_info_dict[\u0022topic_type\u0022] = py::str(topic_endpoint_info-\u003Etopic_type);\n\u002B  py_endpoint_info_dict[\u0022topic_type_hash\u0022] =\n\u002B    convert_to_type_hash_dict(\u0026topic_endpoint_info-\u003Etopic_type_hash);\n   py_endpoint_info_dict[\u0022endpoint_type\u0022] =\n     py::int_(static_cast\u003Cint\u003E(topic_endpoint_info-\u003Eendpoint_type));\n   py_endpoint_info_dict[\u0022endpoint_gid\u0022] = py_endpoint_gid;\n@@ -363,4 \u002B365,18 @@ convert_to_qos_dict(const rmw_qos_profile_t * qos_profile)\n \n   return pyqos_kwargs;\n }\n\u002B\n\u002Bpy::dict\n\u002Bconvert_to_type_hash_dict(const rosidl_type_hash_t * type_hash)\n\u002B{\n\u002B  // Create dictionary and populate arguments with type hash object\n\u002B  py::dict type_hash_kwargs;\n\u002B\n\u002B  type_hash_kwargs[\u0022version\u0022] = py::int_(type_hash-\u003Eversion);\n\u002B  type_hash_kwargs[\u0022value\u0022] = py::bytes(\n\u002B    reinterpret_cast\u003Cconst char *\u003E(type_hash-\u003Evalue),\n\u002B    ROSIDL_TYPE_HASH_SIZE);\n\u002B\n\u002B  return type_hash_kwargs;\n\u002B}\n }  // namespace rclpy\ndiff --git rclpy/src/rclpy/utils.hpp rclpy/src/rclpy/utils.hpp\nindex 4080242..3ab5833 100644\n--- rclpy/src/rclpy/utils.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.hpp\n@@ -149,6 \u002B149,14 @@ convert_to_py_topic_endpoint_info_list(const rmw_topic_endpoint_info_array_t * i\n  */\n py::dict\n convert_to_qos_dict(const rmw_qos_profile_t * qos_profile);\n\u002B\n\u002B/// Convert a C rosidl_type_hash_t into a Python dictionary.\n\u002B/**\n\u002B * \\param[in] type_hash Pointer to a rosidl_type_hash_t to convert\n\u002B * \\return Python dictionary\n\u002B */\n\u002Bpy::dict\n\u002Bconvert_to_type_hash_dict(const rosidl_type_hash_t * type_hash);\n }  // namespace rclpy\n \n #endif  // RCLPY__UTILS_HPP_\ndiff --git rclpy/test/test_topic_endpoint_info.py rclpy/test/test_topic_endpoint_info.py\nindex 1881d52..f27ba02 100644\n--- rclpy/test/test_topic_endpoint_info.py\n\u002B\u002B\u002B rclpy/test/test_topic_endpoint_info.py\n@@ -93,7 \u002B93,7 @@ class TestQosProfile(unittest.TestCase):\n         expected_info_str = \u0027Node name: \\n\u0027 \\\n             \u0027Node namespace: \\n\u0027 \\\n             \u0027Topic type: \\n\u0027 \\\n-            \u0027Topic type hash: UNKNOWN\\n\u0027 \\\n\u002B            \u0027Topic type hash: INVALID\\n\u0027 \\\n             \u0027Endpoint type: INVALID\\n\u0027 \\\n             \u0027GID: \\n\u0027 \\\n             \u0027QoS profile:\\n\u0027 \\\ndiff --git rclpy/test/test_type_hash.py rclpy/test/test_type_hash.py\nnew file mode 100644\nindex 0000000..3903307\n--- /dev/null\n\u002B\u002B\u002B rclpy/test/test_type_hash.py\n@@ -0,0 \u002B1,44 @@\n\u002B# Copyright 2023 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport unittest\n\u002B\n\u002Bfrom rclpy.type_hash import TypeHash\n\u002B\n\u002B# From std_msgs/msg/String.json\n\u002BSTD_MSGS_STRING_TYPE_HASH_DICT = {\n\u002B    \u0027version\u0027: 1,\n\u002B    \u0027value\u0027: b\u0027\\xdf\\x66\\x8c\\x74\\x04\\x82\\xbb\\xd4\\x8f\\xb3\\x9d\\x76\\xa7\\x0d\\xfd\\x4b\u0027\n\u002B             b\u0027\\xd5\\x9d\\xb1\\x28\\x80\\x21\\x74\\x35\\x03\\x25\\x9e\\x94\\x8f\\x6b\\x1a\\x18\u0027,\n\u002B}\n\u002BSTD_MSGS_STRING_TYPE_HASH_STR = \u0027RIHS01_\u0027 \\\n\u002B                                \u0027df668c740482bbd48fb39d76a70dfd4bd59db1288021743503259e948f6b1a18\u0027\n\u002B\n\u002B\n\u002Bclass TestTypeHash(unittest.TestCase):\n\u002B\n\u002B    def test_dict_constructor(self):\n\u002B        type_hash = TypeHash(**STD_MSGS_STRING_TYPE_HASH_DICT)\n\u002B        self.assertEqual(STD_MSGS_STRING_TYPE_HASH_DICT[\u0027version\u0027], type_hash.version)\n\u002B        self.assertEqual(STD_MSGS_STRING_TYPE_HASH_DICT[\u0027value\u0027], type_hash.value)\n\u002B\n\u002B    def test_print_valid(self):\n\u002B        actual_str = str(TypeHash(**STD_MSGS_STRING_TYPE_HASH_DICT))\n\u002B        expected_str = STD_MSGS_STRING_TYPE_HASH_STR\n\u002B        self.assertEqual(expected_str, actual_str)\n\u002B\n\u002B    def test_print_invalid(self):\n\u002B        actual_str = str(TypeHash())\n\u002B        expected_str = \u0027INVALID\u0027\n\u002B        self.assertEqual(expected_str, actual_str)\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw",
    "SHA": "bb044d59df89fac9fed8706aa58a8d7092fa31a2",
    "RawMessage": "Add a note about asynchronicity of discovery. (#352)",
    "Changes": "diff --git rmw/include/rmw/get_topic_endpoint_info.h rmw/include/rmw/get_topic_endpoint_info.h\nindex 210fad8..8e873b8 100644\n--- rmw/include/rmw/get_topic_endpoint_info.h\n\u002B\u002B\u002B rmw/include/rmw/get_topic_endpoint_info.h\n@@ -31,6 \u002B31,9 @@ extern \u0022C\u0022\n  * the associated topic type, the publisher\u0027s gid, and the publisher QoS profile.\n  * Names of non-existent topics are allowed, in which case an empty array will be returned.\n  *\n\u002B * Depending on the RMW in use, discovery may be asynchronous.  Therefore, creating a publisher\n\u002B * and then calling this API may not show the newly created publisher immediately.\n\u002B *\n  * \\par QoS that are correctly read\n  * The QoS profiles returned might have some invalid fields.\n  * The rmw implementation must set the invalid fields to \u0060RMW_QOS_POLICY_*_UNKNOWN\u0060.\n@@ -113,6 \u002B116,9 @@ rmw_get_publishers_info_by_topic(\n  * the associated topic type, the subscription\u0027s gid, and the subscription QoS profile.\n  * Names of non-existent topics are allowed, in which case an empty array will be returned.\n  *\n\u002B * Depending on the RMW in use, discovery may be asynchronous.  Therefore, creating a subscription\n\u002B * and then calling this API may not show the newly created subscription immediately.\n\u002B *\n  * \\par QoS that are correctly read\n  * Not all QoS may be read correctly, \\sa rmw_get_publishers_info_by_topic() for more details.\n  *\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "e938f92933a6919b8f277b17e5cd7deb18d75da1",
    "RawMessage": "typo fix. (#768)",
    "Changes": "diff --git rclpy/rclpy/qos.py rclpy/rclpy/qos.py\nindex c4dc790..aa2e3ce 100644\n--- rclpy/rclpy/qos.py\n\u002B\u002B\u002B rclpy/rclpy/qos.py\n@@ -485,7 \u002B485,7 @@ def qos_check_compatible(publisher_qos: QoSProfile, subscription_qos: QoSProfile\n \n     If any policies have value \u0022system default\u0022 or \u0022unknown\u0022 then it is possible that\n     compatibility cannot be determined.\n-    In this case, the value QoSCompatility.WARNING is set as part of\n\u002B    In this case, the value QoSCompatibility.WARNING is set as part of\n     the returned structure.\n     \u0022\u0022\u0022\n     result = _rclpy.rclpy_qos_check_compatible(\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "f066e1d5cc8869f71c786cc5b9ab879f20ab9bd5",
    "RawMessage": "Fix bad conditional in rmw_serialize(). (#217)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 23bcd5e..1465eb6 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -1383,13 \u002B1383,13 @@ extern \u0022C\u0022 rmw_ret_t rmw_serialize(\n   const rosidl_message_type_support_t * type_support,\n   rmw_serialized_message_t * serialized_message)\n {\n-  rmw_ret_t ret;\n   try {\n     auto writer = rmw_cyclonedds_cpp::make_cdr_writer(\n       rmw_cyclonedds_cpp::make_message_value_type(type_support));\n \n     auto size = writer-\u003Eget_serialized_size(ros_message);\n-    if ((ret = rmw_serialized_message_resize(serialized_message, size) != RMW_RET_OK)) {\n\u002B    rmw_ret_t ret = rmw_serialized_message_resize(serialized_message, size);\n\u002B    if (RMW_RET_OK != ret) {\n       RMW_SET_ERROR_MSG(\u0022rmw_serialize: failed to allocate space for message\u0022);\n       return ret;\n     }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "820654cafbaf6662289c8c2e87e1124262666522",
    "RawMessage": "Improve documentation on building API documentation (#565)",
    "Changes": "diff --git README.md README.md\nindex 503cd09..b9f25ef 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -6,6 \u002B6,8 @@ ROS Client Library for the Python language.\n \n Documentation can be built for \u0060rclpy\u0060 using [Sphinx](http://www.sphinx-doc.org/en/master/), or accessed [online](http://docs.ros2.org/latest/api/rclpy/index.html)\n \n\u002BFor building documentation, you need an installation of ROS 2.\n\u002B\n #### Install dependencies\n \n     sudo apt install python3-sphinx python3-pip\n@@ -13,5 \u002B15,20 @@ Documentation can be built for \u0060rclpy\u0060 using [Sphinx](http://www.sphinx-doc.org/\n \n #### Build\n \n-    cd rclpy/docs\n\u002BSource your ROS 2 installation, for example:\n\u002B\n\u002B    . /opt/ros/foxy/setup.bash\n\u002B\n\u002BBuild code:\n\u002B\n\u002B    mkdir -p rclpy_ws/src\n\u002B    cd rclpy_ws/src\n\u002B    git clone https://github.com/ros2/rclpy.git\n\u002B    cd ..\n\u002B    colcon build --symlink-install\n\u002B\n\u002BSource workspace and build docs:\n\u002B\n\u002B    source install/setup.bash\n\u002B    cd src/rclpy/rclpy/docs\n     make html\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "873a3d5cd03a66d9fe74fcea6f37a04a90333897",
    "RawMessage": "fix race in test_lifecycle_service_client (#1204)",
    "Changes": "diff --git rclcpp_lifecycle/test/test_lifecycle_service_client.cpp rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\nindex 76978d05..cc930eb0 100644\n--- rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/test/test_lifecycle_service_client.cpp\n@@ -20,6 \u002B20,7 @@\n #include \u003Cgtest/gtest.h\u003E\n #include \u003Cchrono\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cmutex\u003E\n #include \u003Cstring\u003E\n #include \u003Cthread\u003E\n #include \u003Cvector\u003E\n@@ -217,21 \u002B218,31 @@ private:\n \n   void TearDown() override\n   {\n-    rclcpp::shutdown();\n\u002B    {\n\u002B      std::lock_guard\u003Cstd::mutex\u003E guard(shutdown_mutex_);\n\u002B      rclcpp::shutdown();\n\u002B    }\n     spinner_.join();\n   }\n \n   void spin()\n   {\n-    while (rclcpp::ok()) {\n-      rclcpp::spin_some(lifecycle_node_-\u003Eget_node_base_interface());\n-      rclcpp::spin_some(lifecycle_client_);\n\u002B    while (true) {\n\u002B      {\n\u002B        std::lock_guard\u003Cstd::mutex\u003E guard(shutdown_mutex_);\n\u002B        if (!rclcpp::ok()) {\n\u002B          break;\n\u002B        }\n\u002B        rclcpp::spin_some(lifecycle_node_-\u003Eget_node_base_interface());\n\u002B        rclcpp::spin_some(lifecycle_client_);\n\u002B      }\n       std::this_thread::sleep_for(std::chrono::milliseconds(10));\n     }\n   }\n \n   std::shared_ptr\u003CEmptyLifecycleNode\u003E lifecycle_node_;\n   std::shared_ptr\u003CLifecycleServiceClient\u003E lifecycle_client_;\n\u002B  std::mutex shutdown_mutex_;\n   std::thread spinner_;\n };\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "aa3a65d3ffe51e9600dc346a8b99840365f8e07f",
    "RawMessage": "Namespace tracetools C\u002B\u002B functions (#1608)",
    "Changes": "diff --git rclcpp/include/rclcpp/any_service_callback.hpp rclcpp/include/rclcpp/any_service_callback.hpp\nindex 86d42086..78c3ed00 100644\n--- rclcpp/include/rclcpp/any_service_callback.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/any_service_callback.hpp\n@@ -107,12 \u002B107,12 @@ public:\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(shared_ptr_callback_));\n\u002B        tracetools::get_symbol(shared_ptr_callback_));\n     } else if (shared_ptr_with_request_header_callback_) {\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(shared_ptr_with_request_header_callback_));\n\u002B        tracetools::get_symbol(shared_ptr_with_request_header_callback_));\n     }\n #endif  // TRACETOOLS_DISABLED\n   }\ndiff --git rclcpp/include/rclcpp/any_subscription_callback.hpp rclcpp/include/rclcpp/any_subscription_callback.hpp\nindex 5a708435..9a31ecff 100644\n--- rclcpp/include/rclcpp/any_subscription_callback.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/any_subscription_callback.hpp\n@@ -243,22 \u002B243,22 @@ public:\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(shared_ptr_callback_));\n\u002B        tracetools::get_symbol(shared_ptr_callback_));\n     } else if (shared_ptr_with_info_callback_) {\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(shared_ptr_with_info_callback_));\n\u002B        tracetools::get_symbol(shared_ptr_with_info_callback_));\n     } else if (unique_ptr_callback_) {\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(unique_ptr_callback_));\n\u002B        tracetools::get_symbol(unique_ptr_callback_));\n     } else if (unique_ptr_with_info_callback_) {\n       TRACEPOINT(\n         rclcpp_callback_register,\n         static_cast\u003Cconst void *\u003E(this),\n-        get_symbol(unique_ptr_with_info_callback_));\n\u002B        tracetools::get_symbol(unique_ptr_with_info_callback_));\n     }\n #endif  // TRACETOOLS_DISABLED\n   }\ndiff --git rclcpp/include/rclcpp/timer.hpp rclcpp/include/rclcpp/timer.hpp\nindex a2662f4a..cc8e5c6c 100644\n--- rclcpp/include/rclcpp/timer.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/timer.hpp\n@@ -181,7 \u002B181,7 @@ public:\n     TRACEPOINT(\n       rclcpp_callback_register,\n       static_cast\u003Cconst void *\u003E(\u0026callback_),\n-      get_symbol(callback_));\n\u002B      tracetools::get_symbol(callback_));\n   }\n \n   /// Default destructor.\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "1992071d27111fdc7b108c485cd6f5a7b0019587",
    "RawMessage": "Allow to create a subscription with a callback that also receives the message info (#922)",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex dbaba88..25ade89 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -327,24 \u002B327,28 @@ class Executor:\n     def _take_timer(self, tmr):\n         with tmr.handle:\n             tmr.handle.call_timer()\n\u002B        return ()\n \n-    async def _execute_timer(self, tmr, _):\n\u002B    async def _execute_timer(self, tmr):\n         await await_or_execute(tmr.callback)\n \n     def _take_subscription(self, sub):\n         with sub.handle:\n             msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n             if msg_info is not None:\n-                return msg_info[0]\n-        return None\n\u002B                if sub._callback_type is Subscription.CallbackType.MessageOnly:\n\u002B                    return (msg_info[0], )\n\u002B                else:\n\u002B                    return msg_info\n\u002B        return ()\n \n-    async def _execute_subscription(self, sub, msg):\n-        if msg:\n-            await await_or_execute(sub.callback, msg)\n\u002B    async def _execute_subscription(self, sub, *args):\n\u002B        if args:\n\u002B            await await_or_execute(sub.callback, *args)\n \n     def _take_client(self, client):\n         with client.handle:\n-            return client.handle.take_response(client.srv_type.Response)\n\u002B            return (client.handle.take_response(client.srv_type.Response), )\n \n     async def _execute_client(self, client, seq_and_response):\n         header, response = seq_and_response\n@@ -362,7 \u002B366,7 @@ class Executor:\n     def _take_service(self, srv):\n         with srv.handle:\n             request_and_header = srv.handle.service_take_request(srv.srv_type.Request)\n-        return request_and_header\n\u002B        return (request_and_header, )\n \n     async def _execute_service(self, srv, request_and_header):\n         if request_and_header is None:\n@@ -374,8 \u002B378,9 @@ class Executor:\n \n     def _take_guard_condition(self, gc):\n         gc._executor_triggered = False\n\u002B        return ()\n \n-    async def _execute_guard_condition(self, gc, _):\n\u002B    async def _execute_guard_condition(self, gc):\n         await await_or_execute(gc.callback)\n \n     async def _execute_waitable(self, waitable, data):\n@@ -415,7 \u002B420,7 @@ class Executor:\n                 gc.trigger()\n \n                 try:\n-                    await call_coroutine(entity, arg)\n\u002B                    await call_coroutine(entity, *arg)\n                 finally:\n                     entity.callback_group.ending_execution(entity)\n                     # Signal that work has been done so the next callback in a mutually exclusive\n@@ -609,7 \u002B614,7 @@ class Executor:\n                         # Only check waitables that were added to the wait set\n                         if wt in waitables and wt.is_ready(wait_set):\n                             handler = self._make_handler(\n-                                wt, node, lambda e: e.take_data(), self._execute_waitable)\n\u002B                                wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n                             yielded_work = True\n                             yield handler, wt, node\n \ndiff --git rclpy/rclpy/subscription.py rclpy/rclpy/subscription.py\nindex ed16d5e..9683bb0 100644\n--- rclpy/rclpy/subscription.py\n\u002B\u002B\u002B rclpy/rclpy/subscription.py\n@@ -12,6 \u002B12,8 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n\u002Bfrom enum import Enum\n\u002Bimport inspect\n from typing import Callable\n from typing import TypeVar\n \n@@ -28,6 \u002B30,10 @@ MsgType = TypeVar(\u0027MsgType\u0027)\n \n class Subscription:\n \n\u002B    class CallbackType(Enum):\n\u002B        MessageOnly = 0\n\u002B        WithMessageInfo = 1\n\u002B\n     def __init__(\n          self,\n          subscription_impl: _rclpy.Subscription,\n@@ -83,3 \u002B89,26 @@ class Subscription:\n     def topic_name(self):\n         with self.handle:\n             return self.__subscription.get_topic_name()\n\u002B\n\u002B    @property\n\u002B    def callback(self):\n\u002B        return self._callback\n\u002B\n\u002B    @callback.setter\n\u002B    def callback(self, value):\n\u002B        self._callback = value\n\u002B        self._callback_type = Subscription.CallbackType.MessageOnly\n\u002B        try:\n\u002B            inspect.signature(value).bind(object())\n\u002B            return\n\u002B        except TypeError:\n\u002B            pass\n\u002B        try:\n\u002B            inspect.signature(value).bind(object(), object())\n\u002B            self._callback_type = Subscription.CallbackType.WithMessageInfo\n\u002B            return\n\u002B        except TypeError:\n\u002B            pass\n\u002B        raise RuntimeError(\n\u002B            \u0027Subscription.__init__(): callback should be either be callable with one argument\u0027\n\u002B            \u0027(to get only the message) or two (to get message and message info)\u0027)\ndiff --git rclpy/src/rclpy/subscription.cpp rclpy/src/rclpy/subscription.cpp\nindex 5465570..9590c86 100644\n--- rclpy/src/rclpy/subscription.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/subscription.cpp\n@@ -131,11 \u002B131,20 @@ Subscription::take_message(py::object pymsg_type, bool raw)\n \n     pytaken_msg = convert_to_py(taken_msg.get(), pymsg_type);\n   }\n-\n\u002B  py::object pub_seq_number = py::none();\n\u002B  if (message_info.publication_sequence_number != RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED) {\n\u002B    pub_seq_number = py::int_(message_info.publication_sequence_number);\n\u002B  }\n\u002B  py::object rec_seq_number = py::none();\n\u002B  if (message_info.reception_sequence_number != RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED) {\n\u002B    rec_seq_number = py::int_(message_info.reception_sequence_number);\n\u002B  }\n   return py::make_tuple(\n     pytaken_msg, py::dict(\n       \u0022source_timestamp\u0022_a = message_info.source_timestamp,\n-      \u0022received_timestamp\u0022_a = message_info.received_timestamp));\n\u002B      \u0022received_timestamp\u0022_a = message_info.received_timestamp,\n\u002B      \u0022publication_sequence_number\u0022_a = pub_seq_number,\n\u002B      \u0022reception_sequence_number\u0022_a = rec_seq_number));\n }\n \n const char *\ndiff --git rclpy/test/test_subscription.py rclpy/test/test_subscription.py\nindex e6942e6..43eb448 100644\n--- rclpy/test/test_subscription.py\n\u002B\u002B\u002B rclpy/test/test_subscription.py\n@@ -16,6 \u002B16,7 @@ import pytest\n \n import rclpy\n from rclpy.node import Node\n\u002Bfrom rclpy.subscription import Subscription\n \n from test_msgs.msg import Empty\n \n@@ -66,3 \u002B67,25 @@ def test_get_subscription_topic_name_after_remapping(topic_name, namespace, cli_\n         qos_profile=10,\n     )\n     assert sub.topic_name == expected\n\u002B\n\u002B\n\u002Bdef test_subscription_callback_type():\n\u002B    node = Node(\u0027test_node\u0027, namespace=\u0027test_subscription/test_subscription_callback_type\u0027)\n\u002B    sub = node.create_subscription(\n\u002B        msg_type=Empty,\n\u002B        topic=\u0027test_subscription/test_subscription_callback_type/topic\u0027,\n\u002B        qos_profile=10,\n\u002B        callback=lambda _: None)\n\u002B    assert sub._callback_type == Subscription.CallbackType.MessageOnly\n\u002B    sub = node.create_subscription(\n\u002B        msg_type=Empty,\n\u002B        topic=\u0027test_subscription/test_subscription_callback_type/topic\u0027,\n\u002B        qos_profile=10,\n\u002B        callback=lambda _, _2: None)\n\u002B    assert sub._callback_type == Subscription.CallbackType.WithMessageInfo\n\u002B    with pytest.raises(RuntimeError):\n\u002B        node.create_subscription(\n\u002B            msg_type=Empty,\n\u002B            topic=\u0027test_subscription/test_subscription_callback_type/topic\u0027,\n\u002B            qos_profile=10,\n\u002B            callback=lambda _, _2, _3: None)\n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "45fd4e638201e3413c7cd1008d15509026ff8867",
    "RawMessage": "Reenable stamped eigen tests (#429)",
    "Changes": "diff --git tf2_eigen/CMakeLists.txt tf2_eigen/CMakeLists.txt\nindex 2bd4852e..5dbd59ad 100644\n--- tf2_eigen/CMakeLists.txt\n\u002B\u002B\u002B tf2_eigen/CMakeLists.txt\n@@ -49,5 \u002B49,6 @@ ament_export_include_directories(include)\n ament_export_dependencies(\n   eigen3_cmake_module\n   Eigen3\n\u002B  tf2\n   tf2_ros)\n ament_package()\ndiff --git tf2_eigen/test/tf2_eigen-test.cpp tf2_eigen/test/tf2_eigen-test.cpp\nindex 561793c4..8a8a1112 100644\n--- tf2_eigen/test/tf2_eigen-test.cpp\n\u002B\u002B\u002B tf2_eigen/test/tf2_eigen-test.cpp\n@@ -35,29 \u002B35,37 @@\n #endif\n \n #include \u003Cgtest/gtest.h\u003E\n\u002B#include \u003Cgeometry_msgs/msg/point.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/point_stamped.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/pose.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/pose_stamped.hpp\u003E\n\u002B#include \u003Cgeometry_msgs/msg/transform_stamped.hpp\u003E\n #include \u003Crclcpp/clock.hpp\u003E\n #include \u003Ctf2/convert.h\u003E\n\u002B#include \u003Ctf2/transform_datatypes.h\u003E\n #include \u003Ctf2_eigen/tf2_eigen.hpp\u003E\n #include \u003Ctf2_ros/buffer.h\u003E\n #include \u003Ctf2_ros/transform_listener.h\u003E\n \n\u002B#include \u003CEigen/Geometry\u003E\n\u002B\n #include \u003Ccmath\u003E\n #include \u003Cmemory\u003E\n \n-// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented\n-// TEST(TfEigen, ConvertVector3dStamped)\n-// {\n-//   const tf2::Stamped\u003CEigen::Vector3d\u003E v(Eigen::Vector3d(1,2,3),\n-//     tf2::TimePoint(std::chrono::seconds(5)), \u0022test\u0022);\n\u002BTEST(TfEigen, ConvertVector3dStamped)\n\u002B{\n\u002B  const tf2::Stamped\u003CEigen::Vector3d\u003E v(Eigen::Vector3d(1, 2, 3), tf2::TimePoint(\n\u002B      std::chrono::seconds(5)), \u0022test\u0022);\n \n-//   tf2::Stamped\u003CEigen::Vector3d\u003E v1;\n-//   geometry_msgs::msg::PointStamped p1;\n-//   tf2::convert(v, p1);\n-//   tf2::convert(p1, v1);\n\u002B  tf2::Stamped\u003CEigen::Vector3d\u003E v1;\n\u002B  geometry_msgs::msg::PointStamped p1;\n\u002B  tf2::convert(v, p1);\n\u002B  tf2::convert(p1, v1);\n \n-//   EXPECT_EQ(v, v1);\n-// }\n\u002B  EXPECT_EQ(v, v1);\n\u002B}\n \n\u002B// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented\n // TEST(TfEigen, ConvertVector3d)\n // {\n //   const Eigen::Vector3d v(1,2,3);\n@@ -70,24 \u002B78,25 @@\n //   EXPECT_EQ(v, v1);\n // }\n \n-// TEST(TfEigen, ConvertAffine3dStamped)\n-// {\n-//   const Eigen::Affine3d v_nonstamped(\n-//     Eigen::Translation3d(1,2,3) * Eigen::AngleAxis\u003Cdouble\u003E(1, Eigen::Vector3d::UnitX()));\n-//   const tf2::Stamped\u003CEigen::Affine3d\u003E v(\n-//     v_nonstamped, tf2::TimePoint(std::chrono::seconds(42)), \u0022test_frame\u0022);\n-\n-//   tf2::Stamped\u003CEigen::Affine3d\u003E v1;\n-//   geometry_msgs::msg::PoseStamped p1;\n-//   tf2::convert(v, p1);\n-//   tf2::convert(p1, v1);\n-\n-//   EXPECT_EQ(v.translation(), v1.translation());\n-//   EXPECT_EQ(v.rotation(), v1.rotation());\n-//   EXPECT_EQ(v.frame_id_, v1.frame_id_);\n-//   EXPECT_EQ(v.stamp_, v1.stamp_);\n-// }\n\u002BTEST(TfEigen, ConvertAffine3dStamped)\n\u002B{\n\u002B  const Eigen::Affine3d v_nonstamped(Eigen::Translation3d(1, 2, 3) * Eigen::AngleAxis\u003Cdouble\u003E(\n\u002B      1, Eigen::Vector3d::UnitX()));\n\u002B  const tf2::Stamped\u003CEigen::Affine3d\u003E v(v_nonstamped, tf2::TimePoint(\n\u002B      std::chrono::seconds(42)), \u0022test_frame\u0022);\n\u002B\n\u002B  tf2::Stamped\u003CEigen::Affine3d\u003E v1;\n\u002B  geometry_msgs::msg::PoseStamped p1;\n\u002B  tf2::convert(v, p1);\n\u002B  tf2::convert(p1, v1);\n\u002B\n\u002B  EXPECT_EQ(v.translation(), v1.translation());\n\u002B  EXPECT_EQ(v.rotation(), v1.rotation());\n\u002B  EXPECT_EQ(v.frame_id_, v1.frame_id_);\n\u002B  EXPECT_EQ(v.stamp_, v1.stamp_);\n\u002B}\n \n\u002B// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented\n // TEST(TfEigen, ConvertAffine3d)\n // {\n //   const Eigen::Affine3d v(\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "86fa36a450ddf8164dfd4ca44060039ff87778fd",
    "RawMessage": "Update README.md (#119)",
    "Changes": "diff --git rosgraph_msgs/README.md rosgraph_msgs/README.md\nindex 2ee6acb..a911f75 100644\n--- rosgraph_msgs/README.md\n\u002B\u002B\u002B rosgraph_msgs/README.md\n@@ -9,4 \u002B9,4 @@ For more information about ROS 2 interfaces, see [index.ros2.org](https://index.\n * [Clock](msg/Clock.msg): Communicates the current ROS time.\n \n ## Quality Declaration\n-This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n\u002BThis package claims to be in the **Quality Level 1** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n",
    "IsBackported": false
  },
  {
    "Repository": "launch_ros",
    "SHA": "ed45ebbde5ec1e5a32e9cb753bfdade6ce5127c9",
    "RawMessage": "Move pytest entrypoints to own module (#278)",
    "Changes": "diff --git launch_testing_ros/launch_testing_ros/pytest/hooks.py launch_testing_ros/launch_testing_ros/pytest/hooks.py\nindex 7233268..6d402e4 100644\n--- launch_testing_ros/launch_testing_ros/pytest/hooks.py\n\u002B\u002B\u002B launch_testing_ros/launch_testing_ros/pytest/hooks.py\n@@ -33,16 \u002B33,3 @@ class LaunchROSTestModule(LaunchTestModule):\n \n     def makeitem(self, *args, **kwargs):\n         return LaunchROSTestItem.from_parent(*args, **kwargs)\n-\n-\n-def pytest_launch_collect_makemodule(path, parent, entrypoint):\n-    marks = getattr(entrypoint, \u0027pytestmark\u0027, [])\n-    if marks and any(m.name == \u0027rostest\u0027 for m in marks):\n-        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n-\n-\n-def pytest_configure(config):\n-    config.addinivalue_line(\n-        \u0027markers\u0027,\n-        \u0027rostest: mark a generate_test_description function as a ROS launch test entrypoint\u0027\n-    )\ndiff --git launch_testing_ros/launch_testing_ros_pytest_entrypoint.py launch_testing_ros/launch_testing_ros_pytest_entrypoint.py\nnew file mode 100644\nindex 0000000..c8de53a\n--- /dev/null\n\u002B\u002B\u002B launch_testing_ros/launch_testing_ros_pytest_entrypoint.py\n@@ -0,0 \u002B1,32 @@\n\u002B# Copyright 2019 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002B# Only import standard python modules here\n\u002B# This module intentionally delays imports as late as possible to avoid\n\u002B# importing downstream modules in upstream packages when built with a merged\n\u002B# workspace.\n\u002B\n\u002B\n\u002Bdef pytest_launch_collect_makemodule(path, parent, entrypoint):\n\u002B    marks = getattr(entrypoint, \u0027pytestmark\u0027, [])\n\u002B    if marks and any(m.name == \u0027rostest\u0027 for m in marks):\n\u002B        from launch_testing_ros.pytest.hooks import LaunchROSTestModule\n\u002B        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n\u002B\n\u002B\n\u002Bdef pytest_configure(config):\n\u002B    config.addinivalue_line(\n\u002B        \u0027markers\u0027,\n\u002B        \u0027rostest: mark a generate_test_description function as a ROS launch test entrypoint\u0027\n\u002B    )\ndiff --git launch_testing_ros/setup.py launch_testing_ros/setup.py\nindex 756411a..3864aee 100644\n--- launch_testing_ros/setup.py\n\u002B\u002B\u002B launch_testing_ros/setup.py\n@@ -7,13 \u002B7,14 @@ setup(\n     name=\u0027launch_testing_ros\u0027,\n     version=\u00270.15.0\u0027,\n     packages=find_packages(exclude=[\u0027test\u0027]),\n\u002B    py_modules=[\u0027launch_testing_ros_pytest_entrypoint\u0027],\n     data_files=[\n         (\u0027share/ament_index/resource_index/packages\u0027, [\u0027resource/launch_testing_ros\u0027]),\n         (\u0027share/launch_testing_ros\u0027, [\u0027package.xml\u0027]),\n         (\u0027share/launch_testing_ros/examples\u0027, glob.glob(\u0027test/examples/[!_]*.*\u0027)),\n     ],\n     entry_points={\n-        \u0027pytest11\u0027: [\u0027launch_ros = launch_testing_ros.pytest.hooks\u0027],\n\u002B        \u0027pytest11\u0027: [\u0027launch_ros = launch_testing_ros_pytest_entrypoint\u0027],\n     },\n     install_requires=[\u0027setuptools\u0027],\n     zip_safe=True,\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl_interfaces",
    "SHA": "4959b5d670af83fd4389693c1e532c1d9ae3db24",
    "RawMessage": "Add missing build_export_depend on rosidl_core_runtime (#165)",
    "Changes": "diff --git action_msgs/package.xml action_msgs/package.xml\nindex eff88c2..65f0036 100644\n--- action_msgs/package.xml\n\u002B\u002B\u002B action_msgs/package.xml\n@@ -17,6 \u002B17,8 @@\n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n   \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n\u002B  \u003Cbuild_export_depend\u003Erosidl_core_runtime\u003C/build_export_depend\u003E\n\u002B\n   \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n   \u003Cdepend\u003Eservice_msgs\u003C/depend\u003E\n   \u003Cdepend\u003Eunique_identifier_msgs\u003C/depend\u003E\ndiff --git builtin_interfaces/package.xml builtin_interfaces/package.xml\nindex 8fa0f17..97ba448 100644\n--- builtin_interfaces/package.xml\n\u002B\u002B\u002B builtin_interfaces/package.xml\n@@ -14,9 \u002B14,10 @@\n   \u003Cauthor email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/author\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n-\n   \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n\u002B  \u003Cbuild_export_depend\u003Erosidl_core_runtime\u003C/build_export_depend\u003E\n\u002B\n   \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\n \n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\ndiff --git service_msgs/package.xml service_msgs/package.xml\nindex eceb8e7..581c497 100644\n--- service_msgs/package.xml\n\u002B\u002B\u002B service_msgs/package.xml\n@@ -14,6 \u002B14,8 @@\n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n   \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n\u002B  \u003Cbuild_export_depend\u003Erosidl_core_runtime\u003C/build_export_depend\u003E\n\u002B\n   \u003Cdepend\u003Ebuiltin_interfaces\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\ndiff --git type_description_interfaces/package.xml type_description_interfaces/package.xml\nindex dc133f8..a2d17a5 100644\n--- type_description_interfaces/package.xml\n\u002B\u002B\u002B type_description_interfaces/package.xml\n@@ -10,9 \u002B10,10 @@\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n-\n   \u003Cbuildtool_depend\u003Erosidl_core_generators\u003C/buildtool_depend\u003E\n \n\u002B  \u003Cbuild_export_depend\u003Erosidl_core_runtime\u003C/build_export_depend\u003E\n\u002B\n   \u003Cdepend\u003Eservice_msgs\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Erosidl_core_runtime\u003C/exec_depend\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "1b522035780abf6568070c4a3dca9efc3ca49d45",
    "RawMessage": "use only True to avoid confusion in autodoc config",
    "Changes": "diff --git rclpy/docs/source/conf.py rclpy/docs/source/conf.py\nindex b852a7c..90554a0 100644\n--- rclpy/docs/source/conf.py\n\u002B\u002B\u002B rclpy/docs/source/conf.py\n@@ -197,6 \u002B197,6 @@ epub_exclude_files = [\u0027search.html\u0027]\n autoclass_content = \u0027both\u0027\n \n autodoc_default_options = {\n-    \u0027members\u0027: None,\n-    \u0027undoc-members\u0027: True,\n\u002B    \u0027members\u0027: True,  # document members\n\u002B    \u0027undoc-members\u0027: True,  # also document members without documentation\n }\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "860a9e0e4dc0a7f39ed6f4dc2547da1e7b82d27c",
    "RawMessage": "Unit tests for node interfaces (#1202)",
    "Changes": "diff --git rclcpp/test/CMakeLists.txt rclcpp/test/CMakeLists.txt\nindex 46fe7c15..974b3c7c 100644\n--- rclcpp/test/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/CMakeLists.txt\n@@ -136,6 \u002B136,52 @@ ament_add_gtest(test_node_interfaces__get_node_interfaces\n if(TARGET test_node_interfaces__get_node_interfaces)\n   target_link_libraries(test_node_interfaces__get_node_interfaces ${PROJECT_NAME})\n endif()\n\u002Bament_add_gtest(test_node_interfaces__node_base\n\u002B  rclcpp/node_interfaces/test_node_base.cpp)\n\u002Bif(TARGET test_node_interfaces__node_base)\n\u002B  target_link_libraries(test_node_interfaces__node_base ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_clock\n\u002B  rclcpp/node_interfaces/test_node_clock.cpp)\n\u002Bif(TARGET test_node_interfaces__node_clock)\n\u002B  target_link_libraries(test_node_interfaces__node_clock ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_graph\n\u002B  rclcpp/node_interfaces/test_node_graph.cpp)\n\u002Bif(TARGET test_node_interfaces__node_graph)\n\u002B  ament_target_dependencies(\n\u002B    test_node_interfaces__node_graph\n\u002B    \u0022test_msgs\u0022)\n\u002B  target_link_libraries(test_node_interfaces__node_graph ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_parameters\n\u002B  rclcpp/node_interfaces/test_node_parameters.cpp)\n\u002Bif(TARGET test_node_interfaces__node_parameters)\n\u002B  target_link_libraries(test_node_interfaces__node_parameters ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_services\n\u002B  rclcpp/node_interfaces/test_node_services.cpp)\n\u002Bif(TARGET test_node_interfaces__node_services)\n\u002B  target_link_libraries(test_node_interfaces__node_services ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_timers\n\u002B  rclcpp/node_interfaces/test_node_timers.cpp)\n\u002Bif(TARGET test_node_interfaces__node_timers)\n\u002B  target_link_libraries(test_node_interfaces__node_timers ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_topics\n\u002B  rclcpp/node_interfaces/test_node_topics.cpp)\n\u002Bif(TARGET test_node_interfaces__node_topics)\n\u002B  ament_target_dependencies(\n\u002B    test_node_interfaces__node_topics\n\u002B    \u0022test_msgs\u0022)\n\u002B  target_link_libraries(test_node_interfaces__node_topics ${PROJECT_NAME})\n\u002Bendif()\n\u002Bament_add_gtest(test_node_interfaces__node_waitables\n\u002B  rclcpp/node_interfaces/test_node_waitables.cpp)\n\u002Bif(TARGET test_node_interfaces__node_waitables)\n\u002B  target_link_libraries(test_node_interfaces__node_waitables ${PROJECT_NAME})\n\u002Bendif()\n \n # TODO(wjwwood): reenable these build failure tests when I can get Jenkins to ignore their output\n # rclcpp_add_build_failure_test(build_failure__get_node_topics_interface_const_ref_rclcpp_node\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_base.cpp rclcpp/test/rclcpp/node_interfaces/test_node_base.cpp\nnew file mode 100644\nindex 00000000..cfe42d78\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_base.cpp\n@@ -0,0 \u002B1,60 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_base.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002Bclass TestNodeBase : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeBase, construct_from_node)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_base =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeBase *\u003E(node-\u003Eget_node_base_interface().get());\n\u002B  ASSERT_NE(nullptr, node_base);\n\u002B\n\u002B  EXPECT_STREQ(\u0022node\u0022, node_base-\u003Eget_name());\n\u002B  EXPECT_STREQ(\u0022/ns\u0022, node_base-\u003Eget_namespace());\n\u002B\n\u002B  EXPECT_STREQ(\u0022/ns/node\u0022, node_base-\u003Eget_fully_qualified_name());\n\u002B  EXPECT_NE(nullptr, node_base-\u003Eget_context());\n\u002B  EXPECT_NE(nullptr, node_base-\u003Eget_rcl_node_handle());\n\u002B  EXPECT_NE(nullptr, node_base-\u003Eget_shared_rcl_node_handle());\n\u002B\n\u002B  const auto * const_node_base = node_base;\n\u002B  EXPECT_NE(nullptr, const_node_base-\u003Eget_rcl_node_handle());\n\u002B  EXPECT_NE(nullptr, const_node_base-\u003Eget_shared_rcl_node_handle());\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_clock.cpp rclcpp/test/rclcpp/node_interfaces/test_node_clock.cpp\nnew file mode 100644\nindex 00000000..dec171b6\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_clock.cpp\n@@ -0,0 \u002B1,49 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022rclcpp/node_interfaces/node_clock.hpp\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B\n\u002Bclass TestNodeClock : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeClock, construct_from_node)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_clock =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeClock *\u003E(node-\u003Eget_node_clock_interface().get());\n\u002B  ASSERT_NE(nullptr, node_clock);\n\u002B  EXPECT_NE(nullptr, node_clock-\u003Eget_clock());\n\u002B\n\u002B  const auto * const_node_clock = node_clock;\n\u002B  EXPECT_NE(nullptr, const_node_clock-\u003Eget_clock());\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp\nnew file mode 100644\nindex 00000000..db69207f\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_graph.cpp\n@@ -0,0 \u002B1,186 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_base.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_graph.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B\n\u002Bclass TestNodeGraph : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeGraph, construct_from_node)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  auto topic_names_and_types = node_graph-\u003Eget_topic_names_and_types(false);\n\u002B  EXPECT_LT(0u, topic_names_and_types.size());\n\u002B\n\u002B  auto service_names_and_types = node_graph-\u003Eget_service_names_and_types();\n\u002B  EXPECT_LT(0u, service_names_and_types.size());\n\u002B\n\u002B  auto names = node_graph-\u003Eget_node_names();\n\u002B  EXPECT_EQ(1u, names.size());\n\u002B\n\u002B  auto names_and_namespaces = node_graph-\u003Eget_node_names_and_namespaces();\n\u002B  EXPECT_EQ(1u, names_and_namespaces.size());\n\u002B\n\u002B  EXPECT_EQ(0u, node_graph-\u003Ecount_publishers(\u0022not_a_topic\u0022));\n\u002B  EXPECT_EQ(0u, node_graph-\u003Ecount_subscribers(\u0022not_a_topic\u0022));\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, get_topic_names_and_types)\n\u002B{\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B  auto topic_names_and_types = node_graph-\u003Eget_topic_names_and_types();\n\u002B  EXPECT_LT(0u, topic_names_and_types.size());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, get_service_names_and_types)\n\u002B{\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B  auto service_names_and_types = node_graph-\u003Eget_service_names_and_types();\n\u002B  EXPECT_LT(0u, service_names_and_types.size());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, get_service_names_and_types_by_node)\n\u002B{\n\u002B  auto node1 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node1\u0022, \u0022ns\u0022);\n\u002B  auto node2 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node1-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  EXPECT_THROW(\n\u002B    node_graph-\u003Eget_service_names_and_types_by_node(\u0022not_a_node\u0022, \u0022not_absolute_namespace\u0022),\n\u002B    std::runtime_error);\n\u002B  auto service_names_and_types1 = node_graph-\u003Eget_service_names_and_types_by_node(\u0022node1\u0022, \u0022/ns\u0022);\n\u002B  auto service_names_and_types2 = node_graph-\u003Eget_service_names_and_types_by_node(\u0022node2\u0022, \u0022/ns\u0022);\n\u002B  EXPECT_EQ(service_names_and_types1.size(), service_names_and_types2.size());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, get_node_names_and_namespaces)\n\u002B{\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  auto names_and_namespaces = node_graph-\u003Eget_node_names_and_namespaces();\n\u002B  EXPECT_EQ(1u, names_and_namespaces.size());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, notify_shutdown)\n\u002B{\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  EXPECT_NO_THROW(node_graph-\u003Enotify_shutdown());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, wait_for_graph_change)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  EXPECT_NO_THROW(node_graph-\u003Enotify_graph_change());\n\u002B  EXPECT_THROW(\n\u002B    node_graph-\u003Ewait_for_graph_change(nullptr, std::chrono::milliseconds(1)),\n\u002B    rclcpp::exceptions::InvalidEventError);\n\u002B\n\u002B  auto event = std::make_shared\u003Crclcpp::Event\u003E();\n\u002B  EXPECT_THROW(\n\u002B    node_graph-\u003Ewait_for_graph_change(event, std::chrono::milliseconds(0)),\n\u002B    rclcpp::exceptions::EventNotRegisteredError);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeGraph, get_info_by_topic)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  const rclcpp::QoS publisher_qos(1);\n\u002B  auto publisher = node-\u003Ecreate_publisher\u003Ctest_msgs::msg::Empty\u003E(\u0022topic\u0022, publisher_qos);\n\u002B  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n\u002B\n\u002B  const rclcpp::QoS subscriber_qos(10);\n\u002B  auto subscription =\n\u002B    node-\u003Ecreate_subscription\u003Ctest_msgs::msg::Empty\u003E(\n\u002B    \u0022topic\u0022, subscriber_qos, std::move(callback));\n\u002B\n\u002B  const auto * node_graph =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeGraph *\u003E(node-\u003Eget_node_graph_interface().get());\n\u002B  ASSERT_NE(nullptr, node_graph);\n\u002B\n\u002B  auto publishers = node_graph-\u003Eget_publishers_info_by_topic(\u0022topic\u0022, false);\n\u002B  ASSERT_EQ(1u, publishers.size());\n\u002B\n\u002B  auto publisher_endpoint_info = publishers[0];\n\u002B  const auto const_publisher_endpoint_info = publisher_endpoint_info;\n\u002B  EXPECT_STREQ(\u0022node\u0022, publisher_endpoint_info.node_name().c_str());\n\u002B  EXPECT_STREQ(\u0022node\u0022, const_publisher_endpoint_info.node_name().c_str());\n\u002B  EXPECT_STREQ(\u0022/ns\u0022, publisher_endpoint_info.node_namespace().c_str());\n\u002B  EXPECT_STREQ(\u0022/ns\u0022, const_publisher_endpoint_info.node_namespace().c_str());\n\u002B  EXPECT_STREQ(\u0022test_msgs/msg/Empty\u0022, publisher_endpoint_info.topic_type().c_str());\n\u002B  EXPECT_STREQ(\u0022test_msgs/msg/Empty\u0022, const_publisher_endpoint_info.topic_type().c_str());\n\u002B  EXPECT_EQ(rclcpp::EndpointType::Publisher, publisher_endpoint_info.endpoint_type());\n\u002B  EXPECT_EQ(rclcpp::EndpointType::Publisher, const_publisher_endpoint_info.endpoint_type());\n\u002B\n\u002B  rclcpp::QoS actual_qos = publisher_endpoint_info.qos_profile();\n\u002B  EXPECT_EQ(0u, actual_qos.get_rmw_qos_profile().depth);\n\u002B\n\u002B  rclcpp::QoS const_actual_qos = const_publisher_endpoint_info.qos_profile();\n\u002B  EXPECT_EQ(0u, const_actual_qos.get_rmw_qos_profile().depth);\n\u002B\n\u002B  auto endpoint_gid = publisher_endpoint_info.endpoint_gid();\n\u002B  auto const_endpoint_gid = const_publisher_endpoint_info.endpoint_gid();\n\u002B  bool endpoint_gid_is_all_zeros = true;\n\u002B  for (size_t i = 0; i \u003C RMW_GID_STORAGE_SIZE; \u002B\u002Bi) {\n\u002B    endpoint_gid_is_all_zeros \u0026= (endpoint_gid[i] == 0);\n\u002B    EXPECT_EQ(endpoint_gid[i], const_endpoint_gid[i]);\n\u002B  }\n\u002B  EXPECT_FALSE(endpoint_gid_is_all_zeros);\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\nnew file mode 100644\nindex 00000000..68a7546c\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_parameters.cpp\n@@ -0,0 \u002B1,89 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B/**\n\u002B * NodeParameters is a complicated interface with lots of code, but it is tested elsewhere\n\u002B * very thoroughly. This currently just includes unittests for the currently uncovered\n\u002B * functionality.\n\u002B */\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Calgorithm\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_parameters.hpp\u0022\n\u002B\n\u002Bclass TestNodeParameters : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeParameters, list_parameters)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_parameters =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B    node-\u003Eget_node_parameters_interface().get());\n\u002B  ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B  std::vector\u003Cstd::string\u003E prefixes;\n\u002B  const auto list_result = node_parameters-\u003Elist_parameters(prefixes, 1u);\n\u002B\n\u002B  // Currently the only default parameter is \u0027use_sim_time\u0027, but that may change.\n\u002B  size_t number_of_parameters = list_result.names.size();\n\u002B  EXPECT_GE(1u, number_of_parameters);\n\u002B\n\u002B  const std::string parameter_name = \u0022new_parameter\u0022;\n\u002B  const rclcpp::ParameterValue value(true);\n\u002B  const rcl_interfaces::msg::ParameterDescriptor descriptor;\n\u002B  const auto added_parameter_value =\n\u002B    node_parameters-\u003Edeclare_parameter(parameter_name, value, descriptor, false);\n\u002B  EXPECT_EQ(value.get\u003Cbool\u003E(), added_parameter_value.get\u003Cbool\u003E());\n\u002B\n\u002B  auto list_result2 = node_parameters-\u003Elist_parameters(prefixes, 1u);\n\u002B  EXPECT_EQ(number_of_parameters \u002B 1u, list_result2.names.size());\n\u002B\n\u002B  EXPECT_NE(\n\u002B    std::find(list_result2.names.begin(), list_result2.names.end(), parameter_name),\n\u002B    list_result2.names.end());\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeParameters, parameter_overrides)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto * node_parameters =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeParameters *\u003E(\n\u002B    node-\u003Eget_node_parameters_interface().get());\n\u002B  ASSERT_NE(nullptr, node_parameters);\n\u002B\n\u002B  const auto \u0026 parameter_overrides = node_parameters-\u003Eget_parameter_overrides();\n\u002B  EXPECT_EQ(0u, parameter_overrides.size());\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_services.cpp rclcpp/test/rclcpp/node_interfaces/test_node_services.cpp\nnew file mode 100644\nindex 00000000..893340d3\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_services.cpp\n@@ -0,0 \u002B1,111 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_services.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002Bclass TestService : public rclcpp::ServiceBase\n\u002B{\n\u002Bpublic:\n\u002B  explicit TestService(rclcpp::Node * node)\n\u002B  : rclcpp::ServiceBase(node-\u003Eget_node_base_interface()-\u003Eget_shared_rcl_node_handle()) {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E create_request() override {return nullptr;}\n\u002B  std::shared_ptr\u003Crmw_request_id_t\u003E create_request_header() override {return nullptr;}\n\u002B  void handle_request(std::shared_ptr\u003Crmw_request_id_t\u003E, std::shared_ptr\u003Cvoid\u003E) override {}\n\u002B};\n\u002B\n\u002Bclass TestClient : public rclcpp::ClientBase\n\u002B{\n\u002Bpublic:\n\u002B  explicit TestClient(rclcpp::Node * node)\n\u002B  : rclcpp::ClientBase(node-\u003Eget_node_base_interface().get(), node-\u003Eget_node_graph_interface()) {}\n\u002B\n\u002B  std::shared_ptr\u003Cvoid\u003E create_response() override {return nullptr;}\n\u002B  std::shared_ptr\u003Crmw_request_id_t\u003E create_request_header() override {return nullptr;}\n\u002B  void handle_response(\n\u002B    std::shared_ptr\u003Crmw_request_id_t\u003E, std::shared_ptr\u003Cvoid\u003E) override {}\n\u002B};\n\u002B\n\u002Bclass TestNodeService : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeService, add_service)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_services =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeServices *\u003E(\n\u002B    node-\u003Eget_node_services_interface().get());\n\u002B  ASSERT_NE(nullptr, node_services);\n\u002B\n\u002B  auto service = std::make_shared\u003CTestService\u003E(node.get());\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_NO_THROW(\n\u002B    node_services-\u003Eadd_service(service, callback_group));\n\u002B\n\u002B  // Check that adding a service from node to a callback group of different_node throws exception.\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E different_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group_in_different_node =\n\u002B    different_node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_THROW(\n\u002B    node_services-\u003Eadd_service(service, callback_group_in_different_node),\n\u002B    std::runtime_error);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeService, add_client)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_services =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeServices *\u003E(\n\u002B    node-\u003Eget_node_services_interface().get());\n\u002B  ASSERT_NE(nullptr, node_services);\n\u002B\n\u002B  auto client = std::make_shared\u003CTestClient\u003E(node.get());\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_NO_THROW(node_services-\u003Eadd_client(client, callback_group));\n\u002B\n\u002B  // Check that adding a client from node to a callback group of different_node throws exception.\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E different_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group_in_different_node =\n\u002B    different_node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_THROW(\n\u002B    node_services-\u003Eadd_client(client, callback_group_in_different_node),\n\u002B    std::runtime_error);\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp\nnew file mode 100644\nindex 00000000..af340d29\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_timers.cpp\n@@ -0,0 \u002B1,71 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_timers.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002Bclass TestTimer : public rclcpp::TimerBase\n\u002B{\n\u002Bpublic:\n\u002B  explicit TestTimer(rclcpp::Node * node)\n\u002B  : TimerBase(node-\u003Eget_clock(), std::chrono::nanoseconds(1),\n\u002B      node-\u003Eget_node_base_interface()-\u003Eget_context()) {}\n\u002B\n\u002B  void execute_callback() override {}\n\u002B  bool is_steady() override {return false;}\n\u002B};\n\u002B\n\u002Bclass TestNodeTimers : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeTimers, add_timer)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto node_timers =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeTimers *\u003E(node-\u003Eget_node_timers_interface().get());\n\u002B  ASSERT_NE(nullptr, node_timers);\n\u002B  auto timer = std::make_shared\u003CTestTimer\u003E(node.get());\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_NO_THROW(node_timers-\u003Eadd_timer(timer, callback_group));\n\u002B\n\u002B  // Check that adding timer from node to callback group in different_node throws exception.\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E different_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group_in_different_node =\n\u002B    different_node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_THROW(\n\u002B    node_timers-\u003Eadd_timer(timer, callback_group_in_different_node),\n\u002B    std::runtime_error);\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_topics.cpp rclcpp/test/rclcpp/node_interfaces/test_node_topics.cpp\nnew file mode 100644\nindex 00000000..86b4e72e\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_topics.cpp\n@@ -0,0 \u002B1,129 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Ctype_traits\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_topics.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B\n\u002Bnamespace\n\u002B{\n\u002B\n\u002Bconst rosidl_message_type_support_t EmptyTypeSupport()\n\u002B{\n\u002B  return *rosidl_typesupport_cpp::get_message_type_support_handle\u003Ctest_msgs::msg::Empty\u003E();\n\u002B}\n\u002B\n\u002Bconst rcl_publisher_options_t PublisherOptions()\n\u002B{\n\u002B  return rclcpp::PublisherOptionsWithAllocator\u003Cstd::allocator\u003Cvoid\u003E\u003E().template\n\u002B         to_rcl_publisher_options\u003Ctest_msgs::msg::Empty\u003E(rclcpp::QoS(10));\n\u002B}\n\u002B\n\u002Bconst rcl_subscription_options_t SubscriptionOptions()\n\u002B{\n\u002B  return rclcpp::SubscriptionOptionsWithAllocator\u003Cstd::allocator\u003Cvoid\u003E\u003E().template\n\u002B         to_rcl_subscription_options\u003Ctest_msgs::msg::Empty\u003E(rclcpp::QoS(10));\n\u002B}\n\u002B\n\u002B}  // namespace\n\u002B\n\u002Bclass TestPublisher : public rclcpp::PublisherBase\n\u002B{\n\u002Bpublic:\n\u002B  explicit TestPublisher(rclcpp::Node * node)\n\u002B  : rclcpp::PublisherBase(\n\u002B      node-\u003Eget_node_base_interface().get(), \u0022topic\u0022, EmptyTypeSupport(), PublisherOptions()) {}\n\u002B};\n\u002B\n\u002Bclass TestSubscription : public rclcpp::SubscriptionBase\n\u002B{\n\u002Bpublic:\n\u002B  explicit TestSubscription(rclcpp::Node * node)\n\u002B  : rclcpp::SubscriptionBase(\n\u002B      node-\u003Eget_node_base_interface().get(), EmptyTypeSupport(), \u0022topic\u0022, SubscriptionOptions()) {}\n\u002B  std::shared_ptr\u003Cvoid\u003E create_message() override {return nullptr;}\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::SerializedMessage\u003E\n\u002B  create_serialized_message() override {return nullptr;}\n\u002B\n\u002B  void handle_message(std::shared_ptr\u003Cvoid\u003E \u0026, const rclcpp::MessageInfo \u0026) override {}\n\u002B  void handle_loaned_message(void *, const rclcpp::MessageInfo \u0026) override {}\n\u002B  void return_message(std::shared_ptr\u003Cvoid\u003E \u0026) override {}\n\u002B  void return_serialized_message(std::shared_ptr\u003Crclcpp::SerializedMessage\u003E \u0026) override {}\n\u002B};\n\u002B\n\u002Bclass TestNodeTopics : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeTopics, add_publisher)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n\u002B  // the proper type is being tested and covered.\n\u002B  auto * node_topics =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeTopics *\u003E(node-\u003Eget_node_topics_interface().get());\n\u002B  ASSERT_NE(nullptr, node_topics);\n\u002B  auto publisher = std::make_shared\u003CTestPublisher\u003E(node.get());\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_NO_THROW(node_topics-\u003Eadd_publisher(publisher, callback_group));\n\u002B\n\u002B  // Check that adding publisher from node to a callback group in different_node throws exception.\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E different_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group_in_different_node =\n\u002B    different_node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_THROW(\n\u002B    node_topics-\u003Eadd_publisher(publisher, callback_group_in_different_node),\n\u002B    std::runtime_error);\n\u002B}\n\u002B\n\u002BTEST_F(TestNodeTopics, add_subscription)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  auto * node_topics =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeTopics *\u003E(node-\u003Eget_node_topics_interface().get());\n\u002B  ASSERT_NE(nullptr, node_topics);\n\u002B  auto subscription = std::make_shared\u003CTestSubscription\u003E(node.get());\n\u002B  auto callback_group = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_NO_THROW(node_topics-\u003Eadd_subscription(subscription, callback_group));\n\u002B\n\u002B  // Check that adding subscription from node to callback group in different_node throws exception.\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E different_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group_in_different_node =\n\u002B    different_node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  EXPECT_THROW(\n\u002B    node_topics-\u003Eadd_subscription(subscription, callback_group_in_different_node),\n\u002B    std::runtime_error);\n\u002B}\ndiff --git rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp\nnew file mode 100644\nindex 00000000..19cc63fe\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/node_interfaces/test_node_waitables.cpp\n@@ -0,0 \u002B1,68 @@\n\u002B// Copyright 2020 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rcl/node_options.h\u0022\n\u002B#include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_waitables.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002Bclass TestWaitable : public rclcpp::Waitable\n\u002B{\n\u002Bpublic:\n\u002B  bool add_to_wait_set(rcl_wait_set_t *) override {return false;}\n\u002B  bool is_ready(rcl_wait_set_t *) override {return false;}\n\u002B  void execute() override {}\n\u002B};\n\u002B\n\u002Bclass TestNodeWaitables : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestNodeWaitables, add_remove_waitable)\n\u002B{\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto * node_waitables =\n\u002B    dynamic_cast\u003Crclcpp::node_interfaces::NodeWaitables *\u003E(\n\u002B    node-\u003Eget_node_waitables_interface().get());\n\u002B  ASSERT_NE(nullptr, node_waitables);\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node2 = std::make_shared\u003Crclcpp::Node\u003E(\u0022node2\u0022, \u0022ns\u0022);\n\u002B\n\u002B  auto callback_group1 = node-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  auto callback_group2 = node2-\u003Ecreate_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B  auto waitable = std::make_shared\u003CTestWaitable\u003E();\n\u002B  EXPECT_NO_THROW(\n\u002B    node_waitables-\u003Eadd_waitable(waitable, callback_group1));\n\u002B  EXPECT_THROW(\n\u002B    node_waitables-\u003Eadd_waitable(waitable, callback_group2),\n\u002B    std::runtime_error);\n\u002B  EXPECT_NO_THROW(node_waitables-\u003Eremove_waitable(waitable, callback_group1));\n\u002B  EXPECT_NO_THROW(node_waitables-\u003Eremove_waitable(waitable, callback_group2));\n\u002B}\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "42397ad880e15a9b11ec3be419ff50b95afb8959",
    "RawMessage": "Set the default number of threads of the MultiThreadedExecutor to 2 (#1031)",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex f8889bd..6006230 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -15,7 \u002B15,7 @@\n from concurrent.futures import ThreadPoolExecutor\n from contextlib import ExitStack\n import inspect\n-import multiprocessing\n\u002Bimport os\n from threading import Condition\n from threading import Lock\n from threading import RLock\n@@ -32,6 \u002B32,7 @@ from typing import TYPE_CHECKING\n from typing import TypeVar\n from typing import Union\n \n\u002Bimport warnings\n \n from rclpy.client import Client\n from rclpy.clock import Clock\n@@ -731,19 \u002B732,29 @@ class MultiThreadedExecutor(Executor):\n     \u0022\u0022\u0022\n     Runs callbacks in a pool of threads.\n \n-    :param num_threads: number of worker threads in the pool. If \u0060\u0060None\u0060\u0060, the number of threads\n-        will use :func:\u0060multiprocessing.cpu_count\u0060. If that\u0027s not implemented the number of threads\n-        defaults to 1.\n\u002B    :param num_threads: number of worker threads in the pool.\n\u002B        If \u0060\u0060None\u0060\u0060, the number of threads will be automatically set by querying the underlying OS\n\u002B        for the CPU affinity of the process space.\n\u002B        If the OS doesn\u0027t provide this information, defaults to 2.\n     :param context: The context associated with the executor.\n     \u0022\u0022\u0022\n \n     def __init__(self, num_threads: int = None, *, context: Context = None) -\u003E None:\n         super().__init__(context=context)\n         if num_threads is None:\n-            try:\n-                num_threads = multiprocessing.cpu_count()\n-            except NotImplementedError:\n-                num_threads = 1\n\u002B            # On Linux, it will try to use the number of CPU this process has access to.\n\u002B            # Other platforms, os.sched_getaffinity() doesn\u0027t exist so we use the number of CPUs.\n\u002B            if hasattr(os, \u0027sched_getaffinity\u0027):\n\u002B                num_threads = len(os.sched_getaffinity(0))\n\u002B            else:\n\u002B                num_threads = os.cpu_count()\n\u002B            # The calls above may still return None if they aren\u0027t supported\n\u002B            if num_threads is None:\n\u002B                num_threads = 2\n\u002B        if num_threads == 1:\n\u002B            warnings.warn(\n\u002B                \u0027MultiThreadedExecutor is used with a single thread.\\n\u0027\n\u002B                \u0027Use the SingleThreadedExecutor instead.\u0027)\n         self._executor = ThreadPoolExecutor(num_threads)\n \n     def _spin_once_impl(\ndiff --git rclpy/test/test_executor.py rclpy/test/test_executor.py\nindex c0c3cc8..d8a7ec0 100644\n--- rclpy/test/test_executor.py\n\u002B\u002B\u002B rclpy/test/test_executor.py\n@@ -13,9 \u002B13,11 @@\n # limitations under the License.\n \n import asyncio\n\u002Bimport os\n import threading\n import time\n import unittest\n\u002Bimport warnings\n \n import rclpy\n from rclpy.executors import MultiThreadedExecutor\n@@ -128,6 \u002B130,32 @@ class TestExecutor(unittest.TestCase):\n \n         assert not got_callback\n \n\u002B    def test_multi_threaded_executor_num_threads(self):\n\u002B        self.assertIsNotNone(self.node.handle)\n\u002B\n\u002B        # check default behavior, either platform configuration or defaults to 2\n\u002B        executor = MultiThreadedExecutor(context=self.context)\n\u002B        if hasattr(os, \u0027sched_getaffinity\u0027):\n\u002B            platform_threads = len(os.sched_getaffinity(0))\n\u002B        else:\n\u002B            platform_threads = os.cpu_count()\n\u002B        self.assertEqual(platform_threads, executor._executor._max_workers)\n\u002B        executor.shutdown()\n\u002B\n\u002B        # check specified thread number w/o warning\n\u002B        executor = MultiThreadedExecutor(num_threads=3, context=self.context)\n\u002B        self.assertEqual(3, executor._executor._max_workers)\n\u002B        executor.shutdown()\n\u002B\n\u002B        # check specified thread number = 1, expecting UserWarning\n\u002B        with warnings.catch_warnings(record=True) as w:\n\u002B            warnings.simplefilter(\u0027always\u0027, category=UserWarning)\n\u002B            executor = MultiThreadedExecutor(num_threads=1, context=self.context)\n\u002B            self.assertEqual(1, executor._executor._max_workers)\n\u002B            executor.shutdown()\n\u002B            assert len(w) == 1\n\u002B            assert issubclass(w[0].category, UserWarning)\n\u002B\n     def test_multi_threaded_executor_executes(self):\n         self.assertIsNotNone(self.node.handle)\n         executor = MultiThreadedExecutor(context=self.context)\n",
    "IsBackported": false
  },
  {
    "Repository": "rcpputils",
    "SHA": "be1b683a20695ec31f4a9c9437a5a6cdbbb3e018",
    "RawMessage": "Improve \u0060rcppmath\u0060 Doxygen documentation (#138)",
    "Changes": "diff --git include/rcppmath/clamp.hpp include/rcppmath/clamp.hpp\nindex a25067c..48cb5f9 100644\n--- include/rcppmath/clamp.hpp\n\u002B\u002B\u002B include/rcppmath/clamp.hpp\n@@ -13,7 \u002B13,7 @@\n // limitations under the License.\n \n /*! \\file clamp.hpp\n- * \\brief Restrict a value between two bounds\n\u002B *  \\brief Restrict a value between two bounds.\n  */\n \n #ifndef RCPPMATH__CLAMP_HPP_\n@@ -23,18 \u002B23,19 @@\n \n namespace rcppmath\n {\n-/// If v compares less than lo, returns lo; otherwise if hi compares less\n-//  than v, returns hi; otherwise returns v. Uses operator\u003C to compare the values\n /**\n- * \\param[in] v the value to clamp\n- * \\param[in] lo the lower boundary\n- * \\param[in] hi the higher boundary\n\u002B * If v compares less than lo, returns lo; otherwise if hi compares less\n\u002B * than v, returns hi; otherwise returns v. Uses operator\u003C to compare the values.\n\u002B *\n\u002B * \\param[in] v The value to clamp.\n\u002B * \\param[in] lo The lower boundary.\n\u002B * \\param[in] hi The higher boundary.\n  * \\return Reference to lo if v is less than lo, reference to hi if hi is less than v, otherwise\n  * reference to v.\n- * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp\n\u002B * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp.\n  * \\warning Capturing the result of clamp by reference if one of the parameters is rvalue produces\n- *  a dangling reference if that parameter is returned\n- **/\n\u002B *  a dangling reference if that parameter is returned.\n\u002B */\n template\u003Cclass T\u003E\n constexpr const T \u0026 clamp(const T \u0026 v, const T \u0026 lo, const T \u0026 hi)\n {\n@@ -42,11 \u002B43,18 @@ constexpr const T \u0026 clamp(const T \u0026 v, const T \u0026 lo, const T \u0026 hi)\n   return (v \u003C lo) ? lo : (hi \u003C v) ? hi : v;\n }\n \n-/// Like the function above, but uses comp to compare the values.\n /**\n\u002B * Performs clamping with a provided Comparison object (comp).\n\u002B *\n\u002B * \\param[in] v The value to clamp.\n\u002B * \\param[in] lo The lower boundary.\n\u002B * \\param[in] hi The higher boundary.\n  * \\param[in] comp Comparison object that returns true if the first argument is\n- * less than the second\n- **/\n\u002B * less than the second.\n\u002B * \\return Reference to lo if v is less than lo, reference to hi if hi is less than v, otherwise\n\u002B * reference to v.\n\u002B * \\sa rcppmath::clamp(const T\u0026, const T\u0026, const T\u0026)\n\u002B */\n template\u003Cclass T, class Compare\u003E\n constexpr const T \u0026 clamp(const T \u0026 v, const T \u0026 lo, const T \u0026 hi, Compare comp)\n {\ndiff --git include/rcppmath/rolling_mean_accumulator.hpp include/rcppmath/rolling_mean_accumulator.hpp\nindex 89a057f..2a4d83e 100644\n--- include/rcppmath/rolling_mean_accumulator.hpp\n\u002B\u002B\u002B include/rcppmath/rolling_mean_accumulator.hpp\n@@ -26,21 \u002B26,31 @@ namespace rcppmath\n {\n \n /**\n- * \\brief Simplification of boost::accumulators::accumulator_set\u003Cdouble,\n- *  bacc::stats\u003Cbacc::tag::rolling_mean\u003E\u003E to avoid dragging boost dependencies\n\u002B * \\brief Computes the mean of the last accumulated elements.\n  *\n- * Computes the mean of the last accumulated elements\n\u002B * This is a simplified version of boost\u0027s rolling mean accumulator,\n\u002B * written to avoid dragging in boost dependencies.\n  */\n template\u003Ctypename T\u003E\n class RollingMeanAccumulator\n {\n public:\n\u002B  /**\n\u002B   * Constructs the rolling mean accumulator with a specified window size.\n\u002B   *\n\u002B   * \\param[in] rolling_window_size The unsigned integral length of the accumulator\u0027s window length.\n\u002B   */\n   explicit RollingMeanAccumulator(size_t rolling_window_size)\n   : buffer_(rolling_window_size, 0.0), next_insert_(0),\n     sum_(0.0), buffer_filled_(false)\n   {\n   }\n \n\u002B  /**\n\u002B   * Collects the provided value in the accumulator\u0027s buffer.\n\u002B   *\n\u002B   * \\param[in] val The value to accumulate.\n\u002B   */\n   void accumulate(T val)\n   {\n     sum_ -= buffer_[next_insert_];\n@@ -51,6 \u002B61,11 @@ public:\n     next_insert_ = next_insert_ % buffer_.size();\n   }\n \n\u002B  /**\n\u002B   * Calculates the rolling mean accumulated insofar.\n\u002B   *\n\u002B   * \\return Rolling mean of the accumulated values.\n\u002B   */\n   T getRollingMean() const\n   {\n     size_t valid_data_count = buffer_filled_ * buffer_.size() \u002B !buffer_filled_ * next_insert_;\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "c366e531fafcf662cadfcef5d4966d974171b74c",
    "RawMessage": "Fixes pointed out by the clang analyzer. (#2339)",
    "Changes": "diff --git rclcpp/include/rclcpp/logger.hpp rclcpp/include/rclcpp/logger.hpp\nindex 77f7f8d6..3b8e8a16 100644\n--- rclcpp/include/rclcpp/logger.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/logger.hpp\n@@ -126,9 \u002B126,6 @@ private:\n   std::shared_ptr\u003Cstd::pair\u003Cstd::string, std::string\u003E\u003E logger_sublogger_pairname_ = nullptr;\n \n public:\n-  RCLCPP_PUBLIC\n-  Logger(const Logger \u0026) = default;\n-\n   /// Get the name of this logger.\n   /**\n    * \\return the full name of the logger including any prefixes, or\ndiff --git rclcpp/src/rclcpp/context.cpp rclcpp/src/rclcpp/context.cpp\nindex 35a11730..75c451a8 100644\n--- rclcpp/src/rclcpp/context.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/context.cpp\n@@ -462,7 \u002B462,7 @@ template\u003CContext::ShutdownType shutdown_type\u003E\n std::vector\u003Crclcpp::Context::ShutdownCallback\u003E\n Context::get_shutdown_callback() const\n {\n-  const auto get_callback_vector = [this](auto \u0026 mutex, auto \u0026 callback_set) {\n\u002B  const auto get_callback_vector = [](auto \u0026 mutex, auto \u0026 callback_set) {\n       const std::lock_guard\u003Cstd::mutex\u003E lock(mutex);\n       std::vector\u003Crclcpp::Context::ShutdownCallback\u003E callbacks;\n       for (auto \u0026 callback : callback_set) {\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex fbd410bc..653f06fb 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -644,6 \u002B644,7 @@ TYPED_TEST(TestExecutors, testRaceConditionAddNode)\n             break;\n           }\n           total \u002B= k * (i \u002B 42);\n\u002B          (void)total;\n         }\n       });\n   }\ndiff --git rclcpp/test/rclcpp/test_intra_process_manager.cpp rclcpp/test/rclcpp/test_intra_process_manager.cpp\nindex 83cf586e..da863f3e 100644\n--- rclcpp/test/rclcpp/test_intra_process_manager.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_intra_process_manager.cpp\n@@ -289,7 \u002B289,7 @@ public:\n   }\n \n   bool\n-  use_take_shared_method() const\n\u002B  use_take_shared_method() const override\n   {\n     return take_shared_method;\n   }\n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "4b8ef7b3e0dcfe77e67707d30d67ec94e1597f68",
    "RawMessage": "Data structures interfaces for multi-threaded executor (#355)",
    "Changes": "diff --git rclc/include/rclc/executor.h rclc/include/rclc/executor.h\nindex 398a36e..39cb94e 100644\n--- rclc/include/rclc/executor.h\n\u002B\u002B\u002B rclc/include/rclc/executor.h\n@@ -50,15 \u002B50,29 @@ typedef enum\n   LET\n } rclc_executor_semantics_t;\n \n\u002Btypedef enum\n\u002B{\n\u002B  NONE,\n\u002B  SINGLE_THREADED,\n\u002B  MULTI_THREADED,\n\u002B  NON_POSIX,\n\u002B} rclc_executor_type_t;\n\u002B\n /// Type definition for trigger function. With the parameters:\n /// - array of executor_handles\n /// - size of array\n /// - application specific struct used in the trigger function\n typedef bool (* rclc_executor_trigger_t)(rclc_executor_handle_t *, unsigned int, void *);\n \n\u002B/// function pointer specification\n\u002Btypedef struct rclc_executor_t_s rclc_executor_t;\n\u002Btypedef rcl_ret_t (* rclc_executor_func_t)(rclc_executor_t *);\n\u002B\n /// Container for RCLC-Executor\n-typedef struct\n\u002Bstruct rclc_executor_t_s\n {\n\u002B  /// Type of Executor\n\u002B  rclc_executor_type_t type;\n   /// Context (to get information if ROS is up-and-running)\n   rcl_context_t * context;\n   /// Container for dynamic array for DDS-handles\n@@ -83,7 \u002B97,9 @@ typedef struct\n   void * trigger_object;\n   /// data communication semantics\n   rclc_executor_semantics_t data_comm_semantics;\n-} rclc_executor_t;\n\u002B  /// pointer to custom executor data structure\n\u002B  void * custom;\n\u002B};\n \n /**\n  *  Return a rclc_executor_t struct with pointer members initialized to \u0060NULL\u0060\ndiff --git rclc/include/rclc/executor_handle.h rclc/include/rclc/executor_handle.h\nindex 444a4ff..844b046 100644\n--- rclc/include/rclc/executor_handle.h\n\u002B\u002B\u002B rclc/include/rclc/executor_handle.h\n@@ -165,6 \u002B165,8 @@ typedef struct\n   /// Interval variable. Flag, which is true, if new data is available from DDS queue\n   /// (is set after calling rcl_take)\n   bool data_available;\n\u002B  /// pointer to custom handle\n\u002B  void * custom;\n } rclc_executor_handle_t;\n \n /// Information about total number of subscriptions, guard_conditions, timers, subscription etc.\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "d488535f366f9f59d3f72f6e15d1b5258c7d63c6",
    "RawMessage": "[service] Don\u0027t use a weak_ptr to avoid leaking (#1668)",
    "Changes": "diff --git rclcpp/include/rclcpp/service.hpp rclcpp/include/rclcpp/service.hpp\nindex 079be09b..ae442964 100644\n--- rclcpp/include/rclcpp/service.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/service.hpp\n@@ -177,25 \u002B177,16 @@ public:\n     using rosidl_typesupport_cpp::get_service_type_support_handle;\n     auto service_type_support_handle = get_service_type_support_handle\u003CServiceT\u003E();\n \n-    std::weak_ptr\u003Crcl_node_t\u003E weak_node_handle(node_handle_);\n     // rcl does the static memory allocation here\n     service_handle_ = std::shared_ptr\u003Crcl_service_t\u003E(\n-      new rcl_service_t, [weak_node_handle, service_name](rcl_service_t * service)\n\u002B      new rcl_service_t, [handle = node_handle_, service_name](rcl_service_t * service)\n       {\n-        auto handle = weak_node_handle.lock();\n-        if (handle) {\n-          if (rcl_service_fini(service, handle.get()) != RCL_RET_OK) {\n-            RCLCPP_ERROR(\n-              rclcpp::get_node_logger(handle.get()).get_child(\u0022rclcpp\u0022),\n-              \u0022Error in destruction of rcl service handle: %s\u0022,\n-              rcl_get_error_string().str);\n-            rcl_reset_error();\n-          }\n-        } else {\n-          RCLCPP_ERROR_STREAM(\n-            rclcpp::get_logger(\u0022rclcpp\u0022),\n-            \u0022Error in destruction of rcl service handle \u0022 \u003C\u003C service_name \u003C\u003C\n-              \u0022: the Node Handle was destructed too early. You will leak memory\u0022);\n\u002B        if (rcl_service_fini(service, handle.get()) != RCL_RET_OK) {\n\u002B          RCLCPP_ERROR(\n\u002B            rclcpp::get_node_logger(handle.get()).get_child(\u0022rclcpp\u0022),\n\u002B            \u0022Error in destruction of rcl service handle: %s\u0022,\n\u002B            rcl_get_error_string().str);\n\u002B          rcl_reset_error();\n         }\n         delete service;\n       });\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "96a733a63cc850125d6982bcccbdcf47bfc80ce3",
    "RawMessage": "Add API for checking QoS profile compatibility (#708)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 4d2f5b2..5f67c26 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -176,6 \u002B176,7 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/names.cpp\n   src/rclpy/node.cpp\n   src/rclpy/publisher.cpp\n\u002B  src/rclpy/qos.cpp\n   src/rclpy/qos_events.cpp\n   src/rclpy/serialization.cpp\n   src/rclpy/service.cpp\ndiff --git rclpy/rclpy/qos.py rclpy/rclpy/qos.py\nindex e0a2265..6f5dff6 100644\n--- rclpy/rclpy/qos.py\n\u002B\u002B\u002B rclpy/rclpy/qos.py\n@@ -471,3 \u002B471,29 @@ class QoSPresetProfiles(Enum):\n     def get_from_short_key(cls, name):\n         \u0022\u0022\u0022Retrieve a policy type from a short name, case-insensitive.\u0022\u0022\u0022\n         return cls[name.upper()].value\n\u002B\n\u002B\n\u002BQoSCompatibility = _rclpy.QoSCompatibility\n\u002B\n\u002B\n\u002Bdef qos_check_compatible(publisher_qos: QoSProfile, subscription_qos: QoSProfile):\n\u002B    \u0022\u0022\u0022\n\u002B    Check if two QoS profiles are compatible.\n\u002B\n\u002B    Two QoS profiles are compatible if a publisher and subscription\n\u002B    using the QoS policies can communicate with each other.\n\u002B\n\u002B    If any policies have value \u0022system default\u0022 or \u0022unknown\u0022 then it is possible that\n\u002B    compatibility cannot be determined.\n\u002B    In this case, the value QoSCompatility.WARNING is set as part of\n\u002B    the returned structure.\n\u002B    \u0022\u0022\u0022\n\u002B    result = _rclpy.rclpy_qos_check_compatible(\n\u002B        publisher_qos.get_c_qos_profile(),\n\u002B        subscription_qos.get_c_qos_profile()\n\u002B    )\n\u002B    compatibility = QoSCompatibility(\n\u002B        result.compatibility\n\u002B    )\n\u002B    reason = result.reason\n\u002B    return compatibility, reason\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex b2c2a3b..2c9fac2 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -26,6 \u002B26,7 @@\n #include \u0022names.hpp\u0022\n #include \u0022node.hpp\u0022\n #include \u0022publisher.hpp\u0022\n\u002B#include \u0022qos.hpp\u0022\n #include \u0022qos_events.hpp\u0022\n #include \u0022rclpy_common/exceptions.hpp\u0022\n #include \u0022serialization.hpp\u0022\n@@ -74,6 \u002B75,18 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n   .value(\u0022RCL_PUBLISHER_LIVELINESS_LOST\u0022, RCL_PUBLISHER_LIVELINESS_LOST)\n   .value(\u0022RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS\u0022, RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS);\n \n\u002B  py::enum_\u003Crmw_qos_compatibility_type_t\u003E(m, \u0022QoSCompatibility\u0022)\n\u002B  .value(\u0022OK\u0022, RMW_QOS_COMPATIBILITY_OK)\n\u002B  .value(\u0022WARNING\u0022, RMW_QOS_COMPATIBILITY_WARNING)\n\u002B  .value(\u0022ERROR\u0022, RMW_QOS_COMPATIBILITY_ERROR);\n\u002B\n\u002B  py::class_\u003Crclpy::QoSCheckCompatibleResult\u003E(\n\u002B    m, \u0022QoSCheckCompatibleResult\u0022,\n\u002B    \u0022Result type for checking QoS compatibility with result\u0022)\n\u002B  .def(py::init\u003C\u003E())\n\u002B  .def_readonly(\u0022compatibility\u0022, \u0026rclpy::QoSCheckCompatibleResult::compatibility)\n\u002B  .def_readonly(\u0022reason\u0022, \u0026rclpy::QoSCheckCompatibleResult::reason);\n\u002B\n   py::register_exception\u003Crclpy::RCUtilsError\u003E(m, \u0022RCUtilsError\u0022, PyExc_RuntimeError);\n   py::register_exception\u003Crclpy::RMWError\u003E(m, \u0022RMWError\u0022, PyExc_RuntimeError);\n   auto rclerror = py::register_exception\u003Crclpy::RCLError\u003E(m, \u0022RCLError\u0022, PyExc_RuntimeError);\n@@ -163,6 \u002B176,10 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n     \u0022rclpy_service_info_get_received_timestamp\u0022, \u0026rclpy::service_info_get_received_timestamp,\n     \u0022Retrieve received timestamp from service_info\u0022);\n \n\u002B  m.def(\n\u002B    \u0022rclpy_qos_check_compatible\u0022, \u0026rclpy::qos_check_compatible,\n\u002B    \u0022Check if two QoS profiles are compatible.\u0022);\n\u002B\n   m.def(\n     \u0022rclpy_create_guard_condition\u0022, \u0026rclpy::guard_condition_create,\n     \u0022Create a general purpose guard condition\u0022);\ndiff --git rclpy/src/rclpy/qos.cpp rclpy/src/rclpy/qos.cpp\nnew file mode 100644\nindex 0000000..68bf56a\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/qos.cpp\n@@ -0,0 \u002B1,61 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B// Include pybind11 before rclpy_common/handle.h includes Python.h\n\u002B\n\u002B#include \u003Crmw/error_handling.h\u003E\n\u002B#include \u003Crmw/incompatible_qos_events_statuses.h\u003E\n\u002B#include \u003Crmw/qos_profiles.h\u003E\n\u002B#include \u003Crmw/types.h\u003E\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u0022qos.hpp\u0022\n\u002B#include \u0022rclpy_common/exceptions.hpp\u0022\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B\n\u002BQoSCheckCompatibleResult\n\u002Bqos_check_compatible(\n\u002B  const py::capsule \u0026 publisher_qos_profile,\n\u002B  const py::capsule \u0026 subscription_qos_profile\n\u002B)\n\u002B{\n\u002B  if (0 != strcmp(\u0022rmw_qos_profile_t\u0022, publisher_qos_profile.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rmw_qos_profile_t\u0022);\n\u002B  }\n\u002B  auto publisher_qos_profile_ = static_cast\u003Crmw_qos_profile_t *\u003E(publisher_qos_profile);\n\u002B\n\u002B  if (0 != strcmp(\u0022rmw_qos_profile_t\u0022, subscription_qos_profile.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rmw_qos_profile_t\u0022);\n\u002B  }\n\u002B  auto subscription_qos_profile_ = static_cast\u003Crmw_qos_profile_t *\u003E(subscription_qos_profile);\n\u002B\n\u002B  QoSCheckCompatibleResult result;\n\u002B  rmw_ret_t ret = rmw_qos_profile_check_compatible(\n\u002B    *publisher_qos_profile_,\n\u002B    *subscription_qos_profile_,\n\u002B    \u0026result.compatibility,\n\u002B    result.reason,\n\u002B    sizeof(QoSCheckCompatibleResult::reason));\n\u002B\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    throw RMWError(\u0022failed to check if qos profiles are compatible\u0022);\n\u002B  }\n\u002B\n\u002B  return result;\n\u002B}\n\u002B\n\u002B}  // namespace rclpy\ndiff --git rclpy/src/rclpy/qos.hpp rclpy/src/rclpy/qos.hpp\nnew file mode 100644\nindex 0000000..eda47e6\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/qos.hpp\n@@ -0,0 \u002B1,73 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLPY__QOS_HPP_\n\u002B#define RCLPY__QOS_HPP_\n\u002B\n\u002B#include \u003Crmw/qos_profiles.h\u003E\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B\n\u002B/// Result type for checking QoS compatibility\n\u002B/**\n\u002B * \\see rclpy::qos_check_compatible()\n\u002B */\n\u002Bstruct QoSCheckCompatibleResult\n\u002B{\n\u002B  /// Compatibility result.\n\u002B  rmw_qos_compatibility_type_t compatibility;\n\u002B\n\u002B  /// Reason for a (possible) incompatibility.\n\u002B  /**\n\u002B   * Set if compatiblity is RMW_QOS_COMPATIBILITY_WARNING or RMW_QOS_COMPATIBILITY_ERROR.\n\u002B   * Not set if the QoS profiles are compatible.\n\u002B   */\n\u002B  char reason[2048];\n\u002B};\n\u002B\n\u002B/// Check if two QoS profiles are compatible.\n\u002B/**\n\u002B * Two QoS profiles are compatible if a publisher and subcription\n\u002B * using the QoS policies can communicate with each other.\n\u002B *\n\u002B * If any policies have value \u0022system default\u0022 or \u0022unknown\u0022 then it is possible that\n\u002B * compatiblity cannot be determined.\n\u002B * In this case, the value RMW_QOS_COMPATIBILITY_WARNING is set as part of\n\u002B * the returned structure.\n\u002B *\n\u002B * \\param[in] publisher_qos_profile: The QoS profile for a publisher.\n\u002B * \\param[in] subscription_qos_profile: The QoS profile for a subscription.\n\u002B * \\return Struct with compatiblity set to RMW_QOS_COMPATIBILITY_OK if the QoS profiles are\n\u002B *   compatible, or\n\u002B * \\return Struct with compatibility set to RMW_QOS_COMPATIBILITY_WARNING if there is a chance\n\u002B *   the QoS profiles are not compatible, or\n\u002B * \\return Struct with compatibility set to RMW_QOS_COMPATIBILITY_ERROR if the QoS profiles are\n\u002B *   not compatible.\n\u002B * \\throws RMWError if an unexpected error occurs.\n\u002B */\n\u002BQoSCheckCompatibleResult\n\u002Bqos_check_compatible(\n\u002B  const py::capsule \u0026 publisher_qos_profile,\n\u002B  const py::capsule \u0026 subscription_qos_profile\n\u002B);\n\u002B\n\u002B}  // namespace rclpy\n\u002B\n\u002B#endif  // RCLPY__QOS_HPP_\ndiff --git rclpy/test/test_qos.py rclpy/test/test_qos.py\nindex fa7b82f..ef694c8 100644\n--- rclpy/test/test_qos.py\n\u002B\u002B\u002B rclpy/test/test_qos.py\n@@ -17,7 \u002B17,9 @@ import unittest\n from rclpy.duration import Duration\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import InvalidQoSProfileException\n\u002Bfrom rclpy.qos import qos_check_compatible\n from rclpy.qos import qos_profile_system_default\n\u002Bfrom rclpy.qos import QoSCompatibility\n from rclpy.qos import QoSDurabilityPolicy\n from rclpy.qos import QoSHistoryPolicy\n from rclpy.qos import QoSLivelinessPolicy\n@@ -124,3 \u002B126,65 @@ class TestQosProfile(unittest.TestCase):\n         assert (\n             QoSPresetProfiles.SYSTEM_DEFAULT.value ==\n             QoSPresetProfiles.get_from_short_key(\u0027system_default\u0027))\n\u002B\n\u002B\n\u002Bclass TestCheckQosCompatibility(unittest.TestCase):\n\u002B\n\u002B    def test_compatible(self):\n\u002B        qos = QoSProfile(\n\u002B            depth=1,\n\u002B            reliability=QoSReliabilityPolicy.RELIABLE,\n\u002B            durability=QoSDurabilityPolicy.VOLATILE,\n\u002B            lifespan=Duration(seconds=1),\n\u002B            deadline=Duration(seconds=1),\n\u002B            liveliness=QoSLivelinessPolicy.AUTOMATIC,\n\u002B            liveliness_lease_duration=Duration(seconds=1),\n\u002B        )\n\u002B        compatibility, reason = qos_check_compatible(\n\u002B            qos, qos\n\u002B        )\n\u002B\n\u002B        assert compatibility == QoSCompatibility.OK\n\u002B        assert reason == \u0027\u0027\n\u002B\n\u002B    def test_incompatible(self):\n\u002B        \u0022\u0022\u0022\n\u002B        This test is assuming a DDS implementation.\n\u002B\n\u002B        It\u0027s possible that a \u0022best effort\u0022 publisher and \u0022reliable\u0022\n\u002B        subscription is a valid match in a non-DDS implementation.\n\u002B        \u0022\u0022\u0022\n\u002B        pub_qos = QoSProfile(\n\u002B            depth=1,\n\u002B            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n\u002B        )\n\u002B        sub_qos = QoSProfile(\n\u002B            depth=1,\n\u002B            reliability=QoSReliabilityPolicy.RELIABLE,\n\u002B        )\n\u002B\n\u002B        compatibility, reason = qos_check_compatible(\n\u002B            pub_qos, sub_qos\n\u002B        )\n\u002B\n\u002B        assert compatibility == QoSCompatibility.ERROR\n\u002B        assert reason != \u0027\u0027\n\u002B\n\u002B    def test_warn_of_possible_incompatibility(self):\n\u002B        \u0022\u0022\u0022\n\u002B        This test is assuming a DDS implementation.\n\u002B\n\u002B        It\u0027s possible that a \u0022best effort\u0022 publisher and \u0022reliable\u0022\n\u002B        subscription is a valid match in a non-DDS implementation.\n\u002B        \u0022\u0022\u0022\n\u002B        pub_qos = QoSPresetProfiles.SYSTEM_DEFAULT.value\n\u002B        sub_qos = QoSProfile(\n\u002B            depth=1,\n\u002B            reliability=QoSReliabilityPolicy.RELIABLE,\n\u002B        )\n\u002B        compatibility, reason = qos_check_compatible(\n\u002B            pub_qos, sub_qos\n\u002B        )\n\u002B\n\u002B        assert compatibility == QoSCompatibility.WARNING\n\u002B        assert reason != \u0027\u0027\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "c749682ca675be90d81d6f5c6bc58680f46dca5d",
    "RawMessage": "Complete subscription API test coverage (#734)",
    "Changes": "diff --git rcl/package.xml rcl/package.xml\nindex a28382a..62396c7 100644\n--- rcl/package.xml\n\u002B\u002B\u002B rcl/package.xml\n@@ -25,14 \u002B25,14 @@\n   \u003Ctest_depend\u003Eament_cmake_gtest\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_auto\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_lint_common\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Emimick_vendor\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Ercpputils\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Ermw\u003C/test_depend\u003E\n-  \u003Ctest_depend\u003Ermw_implementation_cmake\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Elaunch\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Elaunch_testing\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Elaunch_testing_ament_cmake\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Emimick_vendor\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eosrf_testing_tools_cpp\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Ercpputils\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Ermw\u003C/test_depend\u003E\n\u002B  \u003Ctest_depend\u003Ermw_implementation_cmake\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Etest_msgs\u003C/test_depend\u003E\n \n   \u003Cgroup_depend\u003Ercl_logging_packages\u003C/group_depend\u003E\ndiff --git rcl/test/CMakeLists.txt rcl/test/CMakeLists.txt\nindex c177d2e..fcc4eaf 100644\n--- rcl/test/CMakeLists.txt\n\u002B\u002B\u002B rcl/test/CMakeLists.txt\n@@ -1,6 \u002B1,7 @@\n find_package(ament_cmake_gtest REQUIRED)\n find_package(launch_testing_ament_cmake REQUIRED)\n \n\u002Bfind_package(mimick_vendor REQUIRED)\n find_package(test_msgs REQUIRED)\n \n find_package(mimick_vendor REQUIRED)\n@@ -225,7 \u002B226,7 @@ function(test_target_function)\n     SRCS rcl/test_subscription.cpp rcl/wait_for_entity_helpers.cpp\n     ENV ${rmw_implementation_env_var}\n     APPEND_LIBRARY_DIRS ${extra_lib_dirs}\n-    LIBRARIES ${PROJECT_NAME}\n\u002B    LIBRARIES ${PROJECT_NAME} mimick\n     AMENT_DEPENDENCIES ${rmw_implementation} \u0022osrf_testing_tools_cpp\u0022 \u0022test_msgs\u0022\n   )\n   if(rmw_implementation STREQUAL \u0022rmw_fastrtps_cpp\u0022 OR\ndiff --git rcl/test/mocking_utils/patch.hpp rcl/test/mocking_utils/patch.hpp\nindex 544dec2..d170c7f 100644\n--- rcl/test/mocking_utils/patch.hpp\n\u002B\u002B\u002B rcl/test/mocking_utils/patch.hpp\n@@ -219,11 \u002B219,8 @@ public:\n    * \\return a mocking_utils::Patch instance.\n    */\n   explicit Patch(const std::string \u0026 target, std::function\u003CReturnT(ArgTs...)\u003E proxy)\n-  : proxy_(proxy)\n\u002B  : target_(target), proxy_(proxy)\n   {\n-    auto MMK_MANGLE(mock_type, create) =\n-      PatchTraits\u003CID, ReturnT(ArgTs...)\u003E::MMK_MANGLE(mock_type, create);\n-    mock_ = mmk_mock(target.c_str(), mock_type);\n   }\n \n   // Copy construction and assignment are disabled.\n@@ -255,18 \u002B252,14 @@ public:\n   /// Inject a @p replacement for the patched function.\n   Patch \u0026 then_call(std::function\u003CReturnT(ArgTs...)\u003E replacement) \u0026\n   {\n-    auto type_erased_trampoline =\n-      reinterpret_cast\u003Cmmk_fn\u003E(prepare_trampoline\u003CID\u003E(replacement));\n-    mmk_when(proxy_(any\u003CArgTs\u003E()...), .then_call = type_erased_trampoline);\n\u002B    replace_with(replacement);\n     return *this;\n   }\n \n   /// Inject a @p replacement for the patched function.\n   Patch \u0026\u0026 then_call(std::function\u003CReturnT(ArgTs...)\u003E replacement) \u0026\u0026\n   {\n-    auto type_erased_trampoline =\n-      reinterpret_cast\u003Cmmk_fn\u003E(prepare_trampoline\u003CID\u003E(replacement));\n-    mmk_when(proxy_(any\u003CArgTs\u003E()...), .then_call = type_erased_trampoline);\n\u002B    replace_with(replacement);\n     return std::move(*this);\n   }\n \n@@ -276,7 \u002B269,21 @@ private:\n   template\u003Ctypename T\u003E\n   T any() {return mmk_any(T);}\n \n-  mock_type mock_;\n\u002B  void replace_with(std::function\u003CReturnT(ArgTs...)\u003E replacement)\n\u002B  {\n\u002B    if (mock_) {\n\u002B      throw std::logic_error(\u0022Cannot configure patch more than once\u0022);\n\u002B    }\n\u002B    auto type_erased_trampoline =\n\u002B      reinterpret_cast\u003Cmmk_fn\u003E(prepare_trampoline\u003CID\u003E(replacement));\n\u002B    auto MMK_MANGLE(mock_type, create) =\n\u002B      PatchTraits\u003CID, ReturnT(ArgTs...)\u003E::MMK_MANGLE(mock_type, create);\n\u002B    mock_ = mmk_mock(target_.c_str(), mock_type);\n\u002B    mmk_when(proxy_(any\u003CArgTs\u003E()...), .then_call = type_erased_trampoline);\n\u002B  }\n\u002B\n\u002B  mock_type mock_{nullptr};\n\u002B  std::string target_;\n   std::function\u003CReturnT(ArgTs...)\u003E proxy_;\n };\n \n@@ -332,15 \u002B339,29 @@ auto make_patch(const std::string \u0026 target, std::function\u003CSignatureT\u003E proxy)\n #define MOCKING_UTILS_PATCH_TARGET(scope, function) \\\n   (std::string(RCUTILS_STRINGIFY(function)) \u002B \u0022@\u0022 \u002B (scope))\n \n-/// Patch a \u0060function\u0060 with a used-provided \u0060replacement\u0060 in a given \u0060scope\u0060.\n-#define patch(scope, function, replacement) \\\n\u002B/// Prepare a mocking_utils::Patch for patching a \u0060function\u0060 in a given \u0060scope\u0060\n\u002B/// but defer applying any changes.\n\u002B#define prepare_patch(scope, function) \\\n   make_patch\u003C__COUNTER__, decltype(function)\u003E( \\\n     MOCKING_UTILS_PATCH_TARGET(scope, function), MOCKING_UTILS_PATCH_PROXY(function) \\\n-  ).then_call(replacement)\n\u002B  )\n \n-/// Patch a function with a function that only returns a value\n-#define patch_and_return(scope, function, return_value) \\\n-  patch(scope, function, [\u0026](auto \u0026\u0026 ...) {return return_value;})\n\u002B/// Patch a \u0060function\u0060 with a used-provided \u0060replacement\u0060 in a given \u0060scope\u0060.\n\u002B#define patch(scope, function, replacement) \\\n\u002B  prepare_patch(scope, function).then_call(replacement)\n\u002B\n\u002B/// Patch a \u0060function\u0060 to always yield a given \u0060return_code\u0060 in a given \u0060scope\u0060.\n\u002B#define patch_and_return(scope, function, return_code) \\\n\u002B  patch(scope, function, [\u0026](auto \u0026\u0026 ...) {return return_code;})\n\u002B\n\u002B/// Patch a \u0060function\u0060 to execute normally but always yield a given \u0060return_code\u0060\n\u002B/// in a given \u0060scope\u0060.\n\u002B#define inject_on_return(scope, function, return_code) \\\n\u002B  patch( \\\n\u002B    scope, function, ([\u0026, base = function](auto \u0026\u0026 ... __args) { \\\n\u002B      static_cast\u003Cvoid\u003E(base(std::forward\u003Cdecltype(__args)\u003E(__args)...)); \\\n\u002B      return return_code; \\\n\u002B    }))\n \n }  // namespace mocking_utils\n \ndiff --git rcl/test/rcl/test_subscription.cpp rcl/test/rcl/test_subscription.cpp\nindex 2dcbd44..1e5b8c7 100644\n--- rcl/test/rcl/test_subscription.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_subscription.cpp\n@@ -20,6 \u002B20,8 @@\n \n #include \u0022rcl/subscription.h\u0022\n #include \u0022rcl/rcl.h\u0022\n\u002B#include \u0022rmw/rmw.h\u0022\n\u002B#include \u0022rmw/validate_full_topic_name.h\u0022\n \n #include \u0022test_msgs/msg/basic_types.h\u0022\n #include \u0022test_msgs/msg/strings.h\u0022\n@@ -30,6 \u002B32,7 @@\n #include \u0022wait_for_entity_helpers.hpp\u0022\n \n #include \u0022./allocator_testing_utils.h\u0022\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n \n #ifdef RMW_IMPLEMENTATION\n # define CLASSNAME_(NAME, SUFFIX) NAME ## __ ## SUFFIX\n@@ -61,7 \u002B64,7 @@ public:\n     }\n     this-\u003Enode_ptr = new rcl_node_t;\n     *this-\u003Enode_ptr = rcl_get_zero_initialized_node();\n-    const char * name = \u0022test_subscription_node\u0022;\n\u002B    constexpr char name[] = \u0022test_subscription_node\u0022;\n     rcl_node_options_t node_options = rcl_node_get_default_options();\n     ret = rcl_node_init(this-\u003Enode_ptr, name, \u0022\u0022, this-\u003Econtext_ptr, \u0026node_options);\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -122,8 \u002B125,8 @@ TEST_F(\n \n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n-  const char * topic = \u0022chatter\u0022;\n-  const char * expected_topic = \u0022/chatter\u0022;\n\u002B  constexpr char topic[] = \u0022chatter\u0022;\n\u002B  constexpr char expected_topic[] = \u0022/chatter\u0022;\n \n   rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n   rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n@@ -143,22 \u002B146,33 @@ TEST_F(\n   rcl_reset_error();\n }\n \n\u002B// Define dummy comparison operators for rcutils_allocator_t type\n\u002B// to use with the Mimick mocking library\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, ==)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, !=)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, \u003C)\n\u002BMOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, \u003E)\n\u002B\n // Bad arguments for init and fini\n TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription_bad_init) {\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n-  const char * topic = \u0022/chatter\u0022;\n\u002B  constexpr char topic[] = \u0022/chatter\u0022;\n   rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n   rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n   rcl_node_t invalid_node = rcl_get_zero_initialized_node();\n \n   ASSERT_FALSE(rcl_node_is_valid_except_context(\u0026invalid_node));\n\u002B  rcl_reset_error();\n\u002B\n   EXPECT_EQ(nullptr, rcl_node_get_rmw_handle(\u0026invalid_node));\n\u002B  rcl_reset_error();\n \n   EXPECT_EQ(\n     RCL_RET_NODE_INVALID,\n     rcl_subscription_init(\u0026subscription, nullptr, ts, topic, \u0026subscription_options));\n   rcl_reset_error();\n\u002B\n   EXPECT_EQ(\n     RCL_RET_NODE_INVALID,\n     rcl_subscription_init(\u0026subscription, \u0026invalid_node, ts, topic, \u0026subscription_options));\n@@ -173,9 \u002B187,57 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   EXPECT_EQ(RCL_RET_TOPIC_NAME_INVALID, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n \n-  rcl_subscription_options_t bad_subscription_options = rcl_subscription_get_default_options();\n-  bad_subscription_options.allocator = get_failing_allocator();\n-  ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026bad_subscription_options);\n\u002B  {\n\u002B    rcutils_ret_t rcutils_string_map_init_returns = RCUTILS_RET_BAD_ALLOC;\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rcutils_string_map_init, rcutils_string_map_init_returns);\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_BAD_ALLOC, ret);\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rcutils_string_map_init_returns = RCUTILS_RET_ERROR;\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  {\n\u002B    auto mock =\n\u002B      mocking_utils::inject_on_return(\u0022lib:rcl\u0022, rcutils_string_map_fini, RCUTILS_RET_ERROR);\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  {\n\u002B    rmw_ret_t rmw_validate_full_topic_name_returns = RMW_RET_OK;\n\u002B    auto mock = mocking_utils::patch(\n\u002B      \u0022lib:rcl\u0022, rmw_validate_full_topic_name,\n\u002B      [\u0026](auto, int * result, auto) {\n\u002B        *result = RMW_TOPIC_INVALID_TOO_LONG;\n\u002B        return rmw_validate_full_topic_name_returns;\n\u002B      });\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_TOPIC_NAME_INVALID, ret);\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rmw_validate_full_topic_name_returns = RMW_RET_ERROR;\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  {\n\u002B    auto mock =\n\u002B      mocking_utils::patch_and_return(\u0022lib:rcl\u0022, rmw_create_subscription, nullptr);\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B  {\n\u002B    auto mock =\n\u002B      mocking_utils::patch_and_return(\u0022lib:rcl\u0022, rmw_subscription_get_actual_qos, RMW_RET_ERROR);\n\u002B    ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, ret);\n\u002B    rcl_reset_error();\n\u002B  }\n \n   ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -184,13 \u002B246,20 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   EXPECT_EQ(RCL_RET_ALREADY_INIT, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n \n\u002B  EXPECT_EQ(RCL_RET_SUBSCRIPTION_INVALID, rcl_subscription_fini(nullptr, this-\u003Enode_ptr));\n\u002B  rcl_reset_error();\n   EXPECT_EQ(RCL_RET_NODE_INVALID, rcl_subscription_fini(\u0026subscription, nullptr));\n   rcl_reset_error();\n   EXPECT_EQ(RCL_RET_NODE_INVALID, rcl_subscription_fini(\u0026subscription, \u0026invalid_node));\n   rcl_reset_error();\n \n-  ret = rcl_subscription_fini(\u0026subscription, this-\u003Enode_ptr);\n-  EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  auto mock =\n\u002B    mocking_utils::inject_on_return(\u0022lib:rcl\u0022, rmw_destroy_subscription, RMW_RET_ERROR);\n\u002B  EXPECT_EQ(RCL_RET_ERROR, rcl_subscription_fini(\u0026subscription, this-\u003Enode_ptr));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  // Make sure finalization completed anyways.\n\u002B  ASSERT_EQ(NULL, subscription.impl);\n }\n \n /* Basic nominal test of a subscription\n@@ -200,7 \u002B269,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n-  const char * topic = \u0022/chatter\u0022;\n\u002B  constexpr char topic[] = \u0022/chatter\u0022;\n   rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n   ret = rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic, \u0026publisher_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -273,7 \u002B342,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n-  const char * topic = \u0022rcl_test_subscription_nominal_string_chatter\u0022;\n\u002B  constexpr char topic[] = \u0022rcl_test_subscription_nominal_string_chatter\u0022;\n   rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n   ret = rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic, \u0026publisher_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -292,7 \u002B361,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n     EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   });\n   ASSERT_TRUE(wait_for_established_subscription(\u0026publisher, 10, 100));\n-  const char * test_string = \u0022testing\u0022;\n\u002B  constexpr char test_string[] = \u0022testing\u0022;\n   {\n     test_msgs__msg__Strings msg;\n     test_msgs__msg__Strings__init(\u0026msg);\n@@ -325,7 \u002B394,7 @@ TEST_F(\n   rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n-  const char * topic = \u0022rcl_test_subscription_nominal_string_sequence_chatter\u0022;\n\u002B  constexpr char topic[] = \u0022rcl_test_subscription_nominal_string_sequence_chatter\u0022;\n   rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n   ret = rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic, \u0026publisher_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -344,7 \u002B413,7 @@ TEST_F(\n     EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   });\n   ASSERT_TRUE(wait_for_established_subscription(\u0026publisher, 10, 100));\n-  const char * test_string = \u0022testing\u0022;\n\u002B  constexpr char test_string[] = \u0022testing\u0022;\n   {\n     test_msgs__msg__Strings msg;\n     test_msgs__msg__Strings__init(\u0026msg);\n@@ -470,7 \u002B539,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   rcutils_allocator_t allocator = rcl_get_default_allocator();\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n-  const char * topic = \u0022/chatterSer\u0022;\n\u002B  constexpr char topic[] = \u0022/chatterSer\u0022;\n   rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n   ret = rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic, \u0026publisher_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -485,7 \u002B554,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   ASSERT_EQ(\n     RCL_RET_OK, rmw_serialized_message_init(\n       \u0026serialized_msg, initial_capacity_ser, \u0026allocator)) \u003C\u003C rcl_get_error_string().str;\n-  const char * test_string = \u0022testing\u0022;\n\u002B  constexpr char test_string[] = \u0022testing\u0022;\n   test_msgs__msg__Strings msg;\n   test_msgs__msg__Strings__init(\u0026msg);\n   ASSERT_TRUE(rosidl_runtime_c__String__assign(\u0026msg.string_value, test_string));\n@@ -535,7 \u002B604,7 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n-  const char * topic = \u0022rcl_loan\u0022;\n\u002B  constexpr char topic[] = \u0022rcl_loan\u0022;\n   rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n   ret = rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic, \u0026publisher_options);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n@@ -565,36 \u002B634,190 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   }\n   ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 100));\n   {\n-    test_msgs__msg__Strings msg;\n-    test_msgs__msg__Strings * msg_loaned;\n-    test_msgs__msg__Strings__init(\u0026msg);\n-    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-    {\n-      test_msgs__msg__Strings__fini(\u0026msg);\n-    });\n-\n-    // Only if rmw supports the functionality\n-    if (rcl_subscription_can_loan_messages(\u0026subscription)) {\n-      ret = rcl_take_loaned_message(\n-        \u0026subscription, reinterpret_cast\u003Cvoid **\u003E(\u0026msg_loaned), nullptr, nullptr);\n-      ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n-      ASSERT_EQ(\n-        std::string(test_string),\n-        std::string(msg_loaned-\u003Estring_value.data, msg_loaned-\u003Estring_value.size));\n-    } else {\n-      ret = rcl_take(\u0026subscription, \u0026msg, nullptr, nullptr);\n-      ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n-      ASSERT_EQ(\n-        std::string(test_string), std::string(msg.string_value.data, msg.string_value.size));\n\u002B    auto patch_take =\n\u002B      mocking_utils::prepare_patch(\u0022lib:rcl\u0022, rmw_take_loaned_message_with_info);\n\u002B    auto patch_return =\n\u002B      mocking_utils::prepare_patch(\u0022lib:rcl\u0022, rmw_return_loaned_message_from_subscription);\n\u002B\n\u002B    if (!rcl_subscription_can_loan_messages(\u0026subscription)) {\n\u002B      // If rcl (and ultimately rmw) does not support message loaning,\n\u002B      // mock it so that a unit test can still be constructed.\n\u002B      patch_take.then_call(\n\u002B        [](auto sub, void ** loaned_message, auto taken, auto msg_info, auto allocation) {\n\u002B          auto msg = new(std::nothrow) test_msgs__msg__Strings{};\n\u002B          if (!msg) {\n\u002B            return RMW_RET_BAD_ALLOC;\n\u002B          }\n\u002B          test_msgs__msg__Strings__init(msg);\n\u002B          *loaned_message = static_cast\u003Cvoid *\u003E(msg);\n\u002B          rmw_ret_t ret = rmw_take_with_info(sub, *loaned_message, taken, msg_info, allocation);\n\u002B          if (RMW_RET_OK != ret) {\n\u002B            delete msg;\n\u002B          }\n\u002B          return ret;\n\u002B        });\n\u002B      patch_return.then_call(\n\u002B        [](auto, void * loaned_message) {\n\u002B          auto msg = reinterpret_cast\u003Ctest_msgs__msg__Strings *\u003E(loaned_message);\n\u002B          test_msgs__msg__Strings__fini(msg);\n\u002B          delete msg;\n\u002B\n\u002B          return RMW_RET_OK;\n\u002B        });\n     }\n\u002B\n\u002B    test_msgs__msg__Strings * msg_loaned = nullptr;\n\u002B    ret = rcl_take_loaned_message(\n\u002B      \u0026subscription, reinterpret_cast\u003Cvoid **\u003E(\u0026msg_loaned), nullptr, nullptr);\n\u002B    ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B    EXPECT_EQ(\n\u002B      std::string(test_string),\n\u002B      std::string(msg_loaned-\u003Estring_value.data, msg_loaned-\u003Estring_value.size));\n\u002B    ret = rcl_return_loaned_message_from_subscription(\u0026subscription, msg_loaned);\n\u002B    EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  }\n\u002B}\n\u002B\n\u002B/* Test for all failure modes in subscription take with loaned messages function.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_bad_take_loaned_message) {\n\u002B  constexpr char topic[] = \u0022rcl_loan\u0022;\n\u002B  const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n\u002B  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n\u002B\n\u002B  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n\u002B  rmw_ret_t ret = rcl_subscription_init(\n\u002B    \u0026subscription, this-\u003Enode_ptr, ts, topic,\n\u002B    \u0026subscription_options);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B  test_msgs__msg__Strings * loaned_message = nullptr;\n\u002B  void ** type_erased_loaned_message_pointer = reinterpret_cast\u003Cvoid **\u003E(\u0026loaned_message);\n\u002B  rmw_message_info_t * message_info = nullptr;  // is a valid argument\n\u002B  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_SUBSCRIPTION_INVALID, rcl_take_loaned_message(\n\u002B      nullptr, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT,\n\u002B    rcl_take_loaned_message(\u0026subscription, nullptr, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  test_msgs__msg__Strings dummy_message;\n\u002B  loaned_message = \u0026dummy_message;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT, rcl_take_loaned_message(\n\u002B      \u0026subscription, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B  loaned_message = nullptr;\n\u002B\n\u002B  {\n\u002B    rmw_ret_t rmw_take_loaned_message_with_info_returns = RMW_RET_OK;\n\u002B    auto mock = mocking_utils::patch(\n\u002B      \u0022lib:rcl\u0022, rmw_take_loaned_message_with_info,\n\u002B      [\u0026](auto, auto, bool * taken, auto \u0026\u0026 ...) {\n\u002B        *taken = false;\n\u002B        return rmw_take_loaned_message_with_info_returns;\n\u002B      });\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_SUBSCRIPTION_TAKE_FAILED, rcl_take_loaned_message(\n\u002B        \u0026subscription, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rmw_take_loaned_message_with_info_returns = RMW_RET_BAD_ALLOC;\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_BAD_ALLOC, rcl_take_loaned_message(\n\u002B        \u0026subscription, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rmw_take_loaned_message_with_info_returns = RMW_RET_UNSUPPORTED;\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_UNSUPPORTED, rcl_take_loaned_message(\n\u002B        \u0026subscription, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rmw_take_loaned_message_with_info_returns = RMW_RET_ERROR;\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_ERROR, rcl_take_loaned_message(\n\u002B        \u0026subscription, type_erased_loaned_message_pointer, message_info, allocation));\n\u002B    rcl_reset_error();\n   }\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_OK,\n\u002B    rcl_subscription_fini(\u0026subscription, this-\u003Enode_ptr)) \u003C\u003C rcl_get_error_string().str;\n\u002B}\n\u002B\n\u002B/* Test for all failure modes in subscription return loaned messages function.\n\u002B */\n\u002BTEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_bad_return_loaned_message) {\n\u002B  constexpr char topic[] = \u0022rcl_loan\u0022;\n\u002B  const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n\u002B  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n\u002B  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n\u002B  test_msgs__msg__Strings dummy_message;\n\u002B  test_msgs__msg__Strings__init(\u0026dummy_message);\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    test_msgs__msg__Strings__fini(\u0026dummy_message);\n\u002B  });\n\u002B  void * loaned_message = \u0026dummy_message;\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_SUBSCRIPTION_INVALID,\n\u002B    rcl_return_loaned_message_from_subscription(nullptr, loaned_message));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_SUBSCRIPTION_INVALID,\n\u002B    rcl_return_loaned_message_from_subscription(\u0026subscription, loaned_message));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_ret_t ret = rcl_subscription_init(\n\u002B    \u0026subscription, this-\u003Enode_ptr, ts, topic,\n\u002B    \u0026subscription_options);\n\u002B  ASSERT_EQ(RMW_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT, rcl_return_loaned_message_from_subscription(\u0026subscription, nullptr));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  {\n\u002B    rmw_ret_t rmw_return_loaned_message_from_subscription_returns = RMW_RET_OK;\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rmw_return_loaned_message_from_subscription,\n\u002B      rmw_return_loaned_message_from_subscription_returns);\n\u002B\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_OK, rcl_return_loaned_message_from_subscription(\u0026subscription, loaned_message)) \u003C\u003C\n\u002B      rcl_get_error_string().str;\n\u002B\n\u002B    rmw_return_loaned_message_from_subscription_returns = RMW_RET_UNSUPPORTED;\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_UNSUPPORTED, rcl_return_loaned_message_from_subscription(\n\u002B        \u0026subscription,\n\u002B        loaned_message));\n\u002B    rcl_reset_error();\n\u002B\n\u002B    rmw_return_loaned_message_from_subscription_returns = RMW_RET_ERROR;\n\u002B    EXPECT_EQ(\n\u002B      RCL_RET_ERROR, rcl_return_loaned_message_from_subscription(\u0026subscription, loaned_message));\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_OK,\n\u002B    rcl_subscription_fini(\u0026subscription, this-\u003Enode_ptr)) \u003C\u003C rcl_get_error_string().str;\n }\n \n TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_get_options) {\n   rcl_ret_t ret;\n   const rosidl_message_type_support_t * ts =\n     ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n-  const char * topic = \u0022test_get_options\u0022;\n\u002B  constexpr char topic[] = \u0022test_get_options\u0022;\n   rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n   rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n   ret = rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n@@ -629,9 \u002B852,27 @@ TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscrip\n     RCL_RET_SUBSCRIPTION_INVALID, rcl_take(\u0026subscription_zero_init, \u0026msg, \u0026message_info, nullptr));\n   rcl_reset_error();\n \n\u002B  rmw_ret_t rmw_take_with_info_returns = RMW_RET_OK;\n\u002B  auto mock = mocking_utils::patch(\n\u002B    \u0022lib:rcl\u0022, rmw_take_with_info,\n\u002B    [\u0026](auto, auto, bool * taken, auto...) {\n\u002B      *taken = false;\n\u002B      return rmw_take_with_info_returns;\n\u002B    });\n\u002B\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_TAKE_FAILED, rcl_take(\u0026subscription, \u0026msg, \u0026message_info, nullptr));\n   rcl_reset_error();\n\u002B\n\u002B  rmw_take_with_info_returns = RMW_RET_BAD_ALLOC;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_BAD_ALLOC, rcl_take(\u0026subscription, \u0026msg, \u0026message_info, nullptr));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_take_with_info_returns = RMW_RET_ERROR;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_ERROR, rcl_take(\u0026subscription, \u0026msg, \u0026message_info, nullptr));\n\u002B  rcl_reset_error();\n }\n \n /* bad take_serialized\n@@ -640,23 \u002B881,53 @@ TEST_F(\n   CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION),\n   test_subscription_bad_take_serialized) {\n   rcl_serialized_message_t serialized_msg = rmw_get_zero_initialized_serialized_message();\n-  size_t initial_capacity_ser = 0u;\n\u002B  size_t initial_serialization_capacity = 0u;\n   ASSERT_EQ(\n     RCL_RET_OK, rmw_serialized_message_init(\n-      \u0026serialized_msg, initial_capacity_ser, \u0026allocator)) \u003C\u003C rcl_get_error_string().str;\n\u002B      \u0026serialized_msg, initial_serialization_capacity, \u0026allocator)) \u003C\u003C\n\u002B    rcl_get_error_string().str;\n \n\u002B  rmw_message_info_t * message_info = nullptr;  // is a valid argument\n\u002B  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_take_serialized_message(nullptr, \u0026serialized_msg, nullptr, nullptr));\n\u002B    rcl_take_serialized_message(nullptr, \u0026serialized_msg, message_info, allocation));\n   rcl_reset_error();\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_take_serialized_message(\u0026subscription_zero_init, \u0026serialized_msg, nullptr, nullptr));\n\u002B    rcl_take_serialized_message(\n\u002B      \u0026subscription_zero_init, \u0026serialized_msg,\n\u002B      message_info, allocation));\n   rcl_reset_error();\n \n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT,\n\u002B    rcl_take_serialized_message(\u0026subscription, nullptr, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_ret_t rmw_take_serialized_message_with_info_returns = RMW_RET_OK;\n\u002B  auto mock = mocking_utils::patch(\n\u002B    \u0022lib:rcl\u0022, rmw_take_serialized_message_with_info,\n\u002B    [\u0026](auto, auto, bool * taken, auto...) {\n\u002B      *taken = false;\n\u002B      return rmw_take_serialized_message_with_info_returns;\n\u002B    });\n\u002B\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_TAKE_FAILED,\n-    rcl_take_serialized_message(\u0026subscription, \u0026serialized_msg, nullptr, nullptr));\n\u002B    rcl_take_serialized_message(\u0026subscription, \u0026serialized_msg, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_take_serialized_message_with_info_returns = RMW_RET_BAD_ALLOC;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_BAD_ALLOC,\n\u002B    rcl_take_serialized_message(\u0026subscription, \u0026serialized_msg, message_info, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_take_serialized_message_with_info_returns = RMW_RET_ERROR;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_ERROR,\n\u002B    rcl_take_serialized_message(\u0026subscription, \u0026serialized_msg, message_info, allocation));\n   rcl_reset_error();\n }\n \n@@ -686,43 \u002B957,92 @@ TEST_F(\n   {\n     EXPECT_EQ(RMW_RET_OK, rmw_message_info_sequence_fini(\u0026message_infos));\n   });\n\u002B  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument\n \n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_take_sequence(nullptr, seq_size, \u0026messages, \u0026message_infos, nullptr));\n\u002B    rcl_take_sequence(nullptr, seq_size, \u0026messages, \u0026message_infos, allocation));\n   rcl_reset_error();\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_take_sequence(\u0026subscription_zero_init, seq_size, \u0026messages, \u0026message_infos, nullptr));\n\u002B    rcl_take_sequence(\u0026subscription_zero_init, seq_size, \u0026messages, \u0026message_infos, allocation));\n   rcl_reset_error();\n \n   EXPECT_EQ(\n     RCL_RET_INVALID_ARGUMENT,\n-    rcl_take_sequence(\u0026subscription, seq_size \u002B 1, \u0026messages, \u0026message_infos, nullptr));\n\u002B    rcl_take_sequence(\u0026subscription, seq_size \u002B 1, \u0026messages, \u0026message_infos, allocation));\n   rcl_reset_error();\n   EXPECT_EQ(\n     RCL_RET_INVALID_ARGUMENT,\n-    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos_short, nullptr));\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos_short, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT,\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, nullptr, \u0026message_infos, allocation));\n   rcl_reset_error();\n \n-  // This test fails for rmw_cyclonedds_cpp function rmw_take_sequence\n-  // Tracked here: https://github.com/ros2/rmw_cyclonedds/issues/193\n-  /*\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_INVALID_ARGUMENT,\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, nullptr, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_ret_t rmw_take_sequence_returns = RMW_RET_OK;\n\u002B  auto mock = mocking_utils::patch(\n\u002B    \u0022lib:rcl\u0022, rmw_take_sequence,\n\u002B    [\u0026](auto, auto, auto, auto, size_t * taken, auto) {\n\u002B      *taken = 0u;\n\u002B      return rmw_take_sequence_returns;\n\u002B    });\n\u002B\n   EXPECT_EQ(\n     RCL_RET_SUBSCRIPTION_TAKE_FAILED,\n-    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos, nullptr));\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_take_sequence_returns = RMW_RET_BAD_ALLOC;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_BAD_ALLOC,\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos, allocation));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  rmw_take_sequence_returns = RMW_RET_ERROR;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_ERROR,\n\u002B    rcl_take_sequence(\u0026subscription, seq_size, \u0026messages, \u0026message_infos, allocation));\n   rcl_reset_error();\n-  */\n }\n \n-/* Using bad arguments subscription methods\n\u002B/* Test for all failure modes in subscription get_publisher_count function.\n  */\n-TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscription_bad_argument) {\n-  size_t pub_count = 0;\n\u002BTEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_bad_get_publisher_count) {\n\u002B  size_t publisher_count = 0;\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_SUBSCRIPTION_INVALID,\n\u002B    rcl_subscription_get_publisher_count(nullptr, \u0026publisher_count));\n\u002B  rcl_reset_error();\n\u002B\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_SUBSCRIPTION_INVALID,\n\u002B    rcl_subscription_get_publisher_count(\u0026subscription_zero_init, \u0026publisher_count));\n\u002B  rcl_reset_error();\n \n   EXPECT_EQ(\n-    RCL_RET_SUBSCRIPTION_INVALID, rcl_subscription_get_publisher_count(nullptr, \u0026pub_count));\n\u002B    RCL_RET_INVALID_ARGUMENT,\n\u002B    rcl_subscription_get_publisher_count(\u0026subscription, nullptr));\n   rcl_reset_error();\n\u002B\n\u002B  auto mock = mocking_utils::patch_and_return(\n\u002B    \u0022lib:rcl\u0022, rmw_subscription_count_matched_publishers, RMW_RET_ERROR);\n\u002B  EXPECT_EQ(\n\u002B    RCL_RET_ERROR,\n\u002B    rcl_subscription_get_publisher_count(\u0026subscription, \u0026publisher_count));\n\u002B  rcl_reset_error();\n\u002B}\n\u002B\n\u002B/* Using bad arguments subscription methods\n\u002B */\n\u002BTEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscription_bad_argument) {\n   EXPECT_EQ(NULL, rcl_subscription_get_actual_qos(nullptr));\n   rcl_reset_error();\n   EXPECT_FALSE(rcl_subscription_can_loan_messages(nullptr));\n@@ -734,10 \u002B1054,6 @@ TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscrip\n   EXPECT_EQ(NULL, rcl_subscription_get_options(nullptr));\n   rcl_reset_error();\n \n-  EXPECT_EQ(\n-    RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_subscription_get_publisher_count(\u0026subscription_zero_init, \u0026pub_count));\n-  rcl_reset_error();\n   EXPECT_EQ(NULL, rcl_subscription_get_actual_qos(\u0026subscription_zero_init));\n   rcl_reset_error();\n   EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription_zero_init));\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "272b79f615322e5e848c68880c2031ec481d656e",
    "RawMessage": "Apply loop to take sequence",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex 0efb2fd..8aaa3ee 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -841,6 \u002B841,12 @@ rmw_take_sequence(\n     return RMW_RET_INVALID_ARGUMENT;\n   }\n \n\u002B  *taken = 0;\n\u002B\n\u002B  // Reset length of output sequences\n\u002B  message_sequence-\u003Esize = 0;\n\u002B  message_info_sequence-\u003Esize = 0;\n\u002B\n   GurumddsSubscriberInfo * info = static_cast\u003CGurumddsSubscriberInfo *\u003E(subscription-\u003Edata);\n   RCUTILS_CHECK_FOR_NULL_WITH_MSG(info, \u0022custom subscriber info is null\u0022, return RMW_RET_ERROR);\n \n@@ -868,97 \u002B874,89 @@ rmw_take_sequence(\n     return RMW_RET_ERROR;\n   }\n \n-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      RMW_GURUMDDS_ID, \u0022No data on topic %s\u0022, subscription-\u003Etopic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  while (*taken \u003C count) {\n\u002B    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n\u002B      topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n\u002B      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n \n-  RCUTILS_LOG_DEBUG_NAMED(\n-    RMW_GURUMDDS_ID, \u0022Received data on topic %s\u0022, subscription-\u003Etopic_name);\n\u002B    if (ret == dds_RETCODE_NO_DATA) {\n\u002B      RCUTILS_LOG_DEBUG_NAMED(\n\u002B        RMW_GURUMDDS_ID, \u0022No data on topic %s\u0022, subscription-\u003Etopic_name);\n\u002B      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n\u002B      break;\n\u002B    }\n \n-  for (uint32_t i = 0; i \u003C dds_SampleInfoSeq_length(sample_infos); i\u002B\u002B) {\n-    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n\u002B    if (ret != dds_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022failed to take data\u0022);\n\u002B      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n\u002B      dds_DataSeq_delete(data_values);\n\u002B      dds_SampleInfoSeq_delete(sample_infos);\n\u002B      dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B      return RMW_RET_ERROR;\n\u002B    }\n \n-    if (sample_info-\u003Evalid_data) {\n-      void * sample = dds_DataSeq_get(data_values, i);\n-      if (sample == nullptr) {\n-        RMW_SET_ERROR_MSG(\u0022failed to get message\u0022);\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n-        return RMW_RET_ERROR;\n-      }\n-      uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);\n-      bool result = deserialize_cdr_to_ros(\n-        info-\u003Erosidl_message_typesupport-\u003Edata,\n-        info-\u003Erosidl_message_typesupport-\u003Etypesupport_identifier,\n-        message_sequence-\u003Edata[*taken],\n-        sample,\n-        static_cast\u003Csize_t\u003E(sample_size)\n-      );\n-      if (!result) {\n-        RMW_SET_ERROR_MSG(\u0022failed to deserialize message\u0022);\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n-        return RMW_RET_ERROR;\n-      }\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      RMW_GURUMDDS_ID, \u0022Received data on topic %s\u0022, subscription-\u003Etopic_name);\n\u002B\n\u002B    for (uint32_t i = 0; i \u003C dds_SampleInfoSeq_length(sample_infos); i\u002B\u002B) {\n\u002B      dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n\u002B\n\u002B      if (sample_info-\u003Evalid_data) {\n\u002B        void * sample = dds_DataSeq_get(data_values, i);\n\u002B        if (sample == nullptr) {\n\u002B          RMW_SET_ERROR_MSG(\u0022failed to get message\u0022);\n\u002B          dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n\u002B          dds_DataSeq_delete(data_values);\n\u002B          dds_SampleInfoSeq_delete(sample_infos);\n\u002B          dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B          return RMW_RET_ERROR;\n\u002B        }\n\u002B        uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);\n\u002B        bool result = deserialize_cdr_to_ros(\n\u002B          info-\u003Erosidl_message_typesupport-\u003Edata,\n\u002B          info-\u003Erosidl_message_typesupport-\u003Etypesupport_identifier,\n\u002B          message_sequence-\u003Edata[*taken],\n\u002B          sample,\n\u002B          static_cast\u003Csize_t\u003E(sample_size)\n\u002B        );\n\u002B        if (!result) {\n\u002B          RMW_SET_ERROR_MSG(\u0022failed to deserialize message\u0022);\n\u002B          dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n\u002B          dds_DataSeq_delete(data_values);\n\u002B          dds_SampleInfoSeq_delete(sample_infos);\n\u002B          dds_UnsignedLongSeq_delete(sample_sizes);\n\u002B          return RMW_RET_ERROR;\n\u002B        }\n \n-      int64_t sequence_number = 0;\n-      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n-      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B        auto message_info = \u0026(message_info_sequence-\u003Edata[*taken]);\n \n-      auto message_info = \u0026(message_info_sequence-\u003Edata[*taken]);\n\u002B        message_info-\u003Esource_timestamp =\n\u002B          sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B          sample_info-\u003Esource_timestamp.nanosec;\n\u002B        // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n\u002B        message_info-\u003Ereceived_timestamp = 0;\n\u002B        rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n\u002B        sender_gid-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n\u002B        memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n \n-      message_info-\u003Esource_timestamp =\n-        sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n-        sample_info-\u003Esource_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-      message_info-\u003Ereceived_timestamp = 0;\n-      message_info-\u003Epublication_sequence_number = sequence_number;\n-      message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n-      rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n-      sender_gid-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n-      memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n-      dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info-\u003Epublication_handle, sender_gid-\u003Edata);\n-      if (ret != dds_RETCODE_OK) {\n-        if (ret == dds_RETCODE_ERROR) {\n-          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \u0022Failed to get publication handle\u0022);\n\u002B        dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n\u002B          topic_reader, sample_info-\u003Epublication_handle, sender_gid-\u003Edata);\n\u002B        if (ret != dds_RETCODE_OK) {\n\u002B          if (ret == dds_RETCODE_ERROR) {\n\u002B            RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \u0022Failed to get publication handle\u0022);\n\u002B          }\n\u002B          memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n         }\n-        memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n-      }\n \n-      (*taken)\u002B\u002B;\n\u002B        (*taken)\u002B\u002B;\n\u002B      }\n     }\n\u002B    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n   }\n \n   message_sequence-\u003Esize = *taken;\n   message_info_sequence-\u003Esize = *taken;\n \n-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n   dds_DataSeq_delete(data_values);\n   dds_SampleInfoSeq_delete(sample_infos);\n   dds_UnsignedLongSeq_delete(sample_sizes);\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "d97669b8b9d68e7d511bf38bdad907fc7ee4e9a0",
    "RawMessage": "Creates PublisherHandle and updates publisher.py (#1310)",
    "Changes": "diff --git rclpy/rclpy/event_handler.py rclpy/rclpy/event_handler.py\nindex caad8f5..9bcd111 100644\n--- rclpy/rclpy/event_handler.py\n\u002B\u002B\u002B rclpy/rclpy/event_handler.py\n@@ -137,7 \u002B137,7 @@ class EventHandler(Waitable):\n         \u0022\u0022\u0022Mark event as not-in-use to allow destruction after waiting on it.\u0022\u0022\u0022\n         self.__event.__exit__(t, v, tb)\n \n-    def destroy(self):\n\u002B    def destroy(self) -\u003E None:\n         self.__event.destroy_when_not_in_use()\n \n \ndiff --git rclpy/rclpy/node.py rclpy/rclpy/node.py\nindex d4b128f..66c669e 100644\n--- rclpy/rclpy/node.py\n\u002B\u002B\u002B rclpy/rclpy/node.py\n@@ -113,6 \u002B113,10 @@ SrvTypeResponse = TypeVar(\u0027SrvTypeResponse\u0027)\n NodeNameNonExistentError = _rclpy.NodeNameNonExistentError\n \n \n\u002Bclass NodeHandle:\n\u002B    pass\n\u002B\n\u002B\n class Node:\n     \u0022\u0022\u0022\n     A Node in the ROS graph.\n@@ -1534,7 \u002B1538,7 @@ class Node:\n         callback_group: Optional[CallbackGroup] = None,\n         event_callbacks: Optional[PublisherEventCallbacks] = None,\n         qos_overriding_options: Optional[QoSOverridingOptions] = None,\n-        publisher_class: Type[Publisher] = Publisher,\n\u002B        publisher_class: Type[Publisher[MsgT]] = Publisher[MsgT],\n     ) -\u003E Publisher[MsgT]:\n         \u0022\u0022\u0022\n         Create a new publisher.\ndiff --git rclpy/rclpy/publisher.py rclpy/rclpy/publisher.py\nindex 998e555..7a47ab5 100644\n--- rclpy/rclpy/publisher.py\n\u002B\u002B\u002B rclpy/rclpy/publisher.py\n@@ -13,10 \u002B13,11 @@\n # limitations under the License.\n \n from types import TracebackType\n-from typing import Generic, List, Optional, Type, TypeVar, Union\n\u002Bfrom typing import Generic, List, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union\n \n from rclpy.callback_groups import CallbackGroup\n-from rclpy.duration import Duration\n\u002Bfrom rclpy.destroyable import DestroyableType\n\u002Bfrom rclpy.duration import Duration, DurationType\n from rclpy.event_handler import EventHandler, PublisherEventCallbacks\n from rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\n from rclpy.qos import QoSProfile\n@@ -25,12 \u002B26,43 @@ from rclpy.type_support import MsgT\n # Left to support Legacy TypeVars.\n MsgType = TypeVar(\u0027MsgType\u0027)\n \n\u002Bif TYPE_CHECKING:\n\u002B    from rclpy.node import NodeHandle\n\u002B\n\u002B\n\u002Bclass PublisherHandle(DestroyableType, Protocol[MsgT]):\n\u002B\n\u002B    def __init__(self, arg0: \u0027NodeHandle\u0027, arg1: Type[MsgT], arg2: str, arg3: object) -\u003E None:\n\u002B        \u0022\u0022\u0022Create PublisherHandle.\u0022\u0022\u0022\n\u002B\n\u002B    @property\n\u002B    def pointer(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Get the address of the entity as an integer.\u0022\u0022\u0022\n\u002B\n\u002B    def get_logger_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Get the name of the logger associated with the node of the publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def get_subscription_count(self) -\u003E int:\n\u002B        \u0022\u0022\u0022Count subscribers from a publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def get_topic_name(self) -\u003E str:\n\u002B        \u0022\u0022\u0022Retrieve the topic name from a Publisher.\u0022\u0022\u0022\n\u002B\n\u002B    def publish(self, arg0: MsgT) -\u003E None:\n\u002B        \u0022\u0022\u0022Publish a message.\u0022\u0022\u0022\n\u002B\n\u002B    def publish_raw(self, arg0: bytes) -\u003E None:\n\u002B        \u0022\u0022\u0022Publish a serialized message.\u0022\u0022\u0022\n\u002B\n\u002B    def wait_for_all_acked(self, arg0: DurationType) -\u003E bool:\n\u002B        \u0022\u0022\u0022Wait until all published message data is acknowledged.\u0022\u0022\u0022\n\u002B\n \n class Publisher(Generic[MsgT]):\n \n     def __init__(\n         self,\n-        publisher_impl: _rclpy.Publisher,\n\u002B        publisher_impl: PublisherHandle[MsgT],\n         msg_type: Type[MsgT],\n         topic: str,\n         qos_profile: QoSProfile,\n@@ -86,10 \u002B118,10 @@ class Publisher(Generic[MsgT]):\n             return self.__publisher.get_topic_name()\n \n     @property\n-    def handle(self):\n\u002B    def handle(self) -\u003E PublisherHandle[MsgT]:\n         return self.__publisher\n \n-    def destroy(self):\n\u002B    def destroy(self) -\u003E None:\n         \u0022\u0022\u0022\n         Destroy a container for a ROS publisher.\n \n@@ -130,7 \u002B162,7 @@ class Publisher(Generic[MsgT]):\n         with self.handle:\n             return self.__publisher.wait_for_all_acked(timeout._duration_handle)\n \n-    def __enter__(self) -\u003E \u0027Publisher\u0027:\n\u002B    def __enter__(self) -\u003E \u0027Publisher[MsgT]\u0027:\n         return self\n \n     def __exit__(\ndiff --git rclpy/rclpy/type_support.py rclpy/rclpy/type_support.py\nindex f13ad84..33ef95d 100644\n--- rclpy/rclpy/type_support.py\n\u002B\u002B\u002B rclpy/rclpy/type_support.py\n@@ -52,7 \u002B52,7 @@ class Msg(Protocol, metaclass=MsgMetaClass):\n     pass\n \n \n-MsgT = TypeVar(\u0027MsgT\u0027, bound=Msg)\n\u002BMsgT = TypeVar(\u0027MsgT\u0027, bound=Msg, contravariant=True)\n \n SrvRequestT = TypeVar(\u0027SrvRequestT\u0027, bound=Msg)\n SrvResponseT = TypeVar(\u0027SrvResponseT\u0027, bound=Msg)\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "9f99c8f5bb77b5064b9837d5bbcd29ca6058266f",
    "RawMessage": "Rename logging internal structures to use our new convention.",
    "Changes": "diff --git src/logging.c src/logging.c\nindex f23eeba..581663c 100644\n--- src/logging.c\n\u002B\u002B\u002B src/logging.c\n@@ -579,27 \u002B579,27 @@ void rcutils_log_internal(\n   va_end(args);\n }\n \n-typedef struct logging_input\n\u002Btypedef struct logging_input_s\n {\n   const char * name;\n   const rcutils_log_location_t * location;\n   const char * msg;\n   int severity;\n   rcutils_time_point_value_t timestamp;\n-} logging_input;\n\u002B} logging_input_t;\n \n typedef const char * (* token_handler)(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output);\n \n-typedef struct token_map_entry\n\u002Btypedef struct token_map_entry_s\n {\n   const char * token;\n   token_handler handler;\n-} token_map_entry;\n\u002B} token_map_entry_t;\n \n static const char * expand_time(\n-  const logging_input * logging_input, rcutils_char_array_t * logging_output,\n\u002B  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,\n   rcutils_ret_t (* time_func)(const rcutils_time_point_value_t *, char *, size_t))\n {\n   // Temporary, local storage for integer/float conversion to string\n@@ -613,21 \u002B613,21 @@ static const char * expand_time(\n }\n \n static const char * expand_time_as_seconds(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   return expand_time(logging_input, logging_output, rcutils_time_point_value_as_seconds_string);\n }\n \n static const char * expand_time_as_nanoseconds(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   return expand_time(logging_input, logging_output, rcutils_time_point_value_as_nanoseconds_string);\n }\n \n static const char * expand_line_number(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   // Allow 9 digits for the expansion of the line number (otherwise, truncate).\n@@ -653,7 \u002B653,7 @@ static const char * expand_line_number(\n }\n \n static const char * expand_severity(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   const char * severity_string = g_rcutils_log_severity_names[logging_input-\u003Eseverity];\n@@ -661,7 \u002B661,7 @@ static const char * expand_severity(\n }\n \n static const char * expand_name(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   if (NULL != logging_input-\u003Ename) {\n@@ -671,7 \u002B671,7 @@ static const char * expand_name(\n }\n \n static const char * expand_message(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   OK_OR_RETURN_NULL(rcutils_char_array_strcat(logging_output, logging_input-\u003Emsg));\n@@ -679,7 \u002B679,7 @@ static const char * expand_message(\n }\n \n static const char * expand_function_name(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   if (logging_input-\u003Elocation) {\n@@ -689,7 \u002B689,7 @@ static const char * expand_function_name(\n }\n \n static const char * expand_file_name(\n-  const logging_input * logging_input,\n\u002B  const logging_input_t * logging_input,\n   rcutils_char_array_t * logging_output)\n {\n   if (logging_input-\u003Elocation) {\n@@ -698,7 \u002B698,7 @@ static const char * expand_file_name(\n   return logging_output-\u003Ebuffer;\n }\n \n-static const token_map_entry tokens[] = {\n\u002Bstatic const token_map_entry_t tokens[] = {\n   {.token = \u0022severity\u0022, .handler = expand_severity},\n   {.token = \u0022name\u0022, .handler = expand_name},\n   {.token = \u0022message\u0022, .handler = expand_message},\n@@ -733,7 \u002B733,7 @@ rcutils_ret_t rcutils_logging_format_message(\n   const char * str = g_rcutils_logging_output_format_string;\n   size_t size = strlen(g_rcutils_logging_output_format_string);\n \n-  const logging_input logging_input = {\n\u002B  const logging_input_t logging_input = {\n     .location = location,\n     .severity = severity,\n     .name = name,\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_python",
    "SHA": "ddb5ee807d4b598b3cdf84a67ca80bc313b52257",
    "RawMessage": ":man_farmer: Fix NaN values bound numpy windows version (#182)",
    "Changes": "diff --git rosidl_generator_py/test/test_interfaces.py rosidl_generator_py/test/test_interfaces.py\nindex 0a294f6..d20dded 100644\n--- rosidl_generator_py/test/test_interfaces.py\n\u002B\u002B\u002B rosidl_generator_py/test/test_interfaces.py\n@@ -505,11 \u002B505,16 @@ def test_arrays():\n     # NaN\n     arr_of_float32_with_nan = numpy.array([-1.33, math.nan, 1.33], dtype=numpy.float32)\n     setattr(msg, \u0027float32_values\u0027, arr_of_float32_with_nan)\n-    assert numpy.array_equal(arr_of_float32_with_nan, msg.float32_values, equal_nan=True)\n\u002B    arr_with_nan = numpy.isnan(arr_of_float32_with_nan)\n\u002B    assert numpy.shape(arr_of_float32_with_nan) == numpy.shape(msg.float32_values) and (\n\u002B        numpy.asarray(arr_of_float32_with_nan[~arr_with_nan] ==\n\u002B                      msg.float32_values[~arr_with_nan]).all())\n     arr_of_float64_with_nan = numpy.array([-1.66, math.nan, 1.66], dtype=numpy.float64)\n     setattr(msg, \u0027float64_values\u0027, arr_of_float64_with_nan)\n-    assert numpy.array_equal(arr_of_float64_with_nan, msg.float64_values, equal_nan=True)\n-\n\u002B    arr_with_nan = numpy.isnan(arr_of_float64_with_nan)\n\u002B    assert numpy.shape(arr_of_float64_with_nan) == numpy.shape(msg.float64_values) and (\n\u002B        numpy.asarray(arr_of_float64_with_nan[~arr_with_nan] ==\n\u002B                      msg.float64_values[~arr_with_nan]).all())\n     # Inf\n     arr_of_float32_with_inf = numpy.array([-math.inf, 5.5, math.inf], dtype=numpy.float32)\n     setattr(msg, \u0027float32_values\u0027, arr_of_float32_with_inf)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "e2ba3ba6889189f46c2de23a2754e87c5d7007bb",
    "RawMessage": "Fixes from review/CI.",
    "Changes": "diff --git rclpy/test/test_rate.py rclpy/test/test_rate.py\nindex f0c83bc..9f2b854 100644\n--- rclpy/test/test_rate.py\n\u002B\u002B\u002B rclpy/test/test_rate.py\n@@ -17,6 \u002B17,7 @@ import time\n \n import pytest\n import rclpy\n\u002Bfrom rclpy.exceptions import ROSInterruptException\n from rclpy.executors import SingleThreadedExecutor\n \n # Hz\n@@ -129,7 \u002B130,7 @@ def test_shutdown_wakes_rate():\n \n     rate = node.create_rate(0.0000001)\n \n-    _thread = threading.Thread(target=sleep_check_exception, args=rate, daemon=True)\n\u002B    _thread = threading.Thread(target=sleep_check_exception, args=(rate,), daemon=True)\n     _thread.start()\n     executor.shutdown()\n     node.destroy_node()\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "8a02e3934c74b6c3355d24af76d1f035ce15573f",
    "RawMessage": "Use message_info in SubscriptionTopicStatistics instead of typed message (#2337)",
    "Changes": "diff --git rclcpp/include/rclcpp/create_subscription.hpp rclcpp/include/rclcpp/create_subscription.hpp\nindex 5b84930f..016c966b 100644\n--- rclcpp/include/rclcpp/create_subscription.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/create_subscription.hpp\n@@ -50,8 \u002B50,8 @@ template\u003C\n   typename SubscriptionT,\n   typename MessageMemoryStrategyT,\n   typename NodeParametersT,\n-  typename NodeTopicsT,\n-  typename ROSMessageType = typename SubscriptionT::ROSMessageType\u003E\n\u002B  typename NodeTopicsT\n\u002B\u003E\n typename std::shared_ptr\u003CSubscriptionT\u003E\n create_subscription(\n   NodeParametersT \u0026 node_parameters,\n@@ -70,7 \u002B70,7 @@ create_subscription(\n   using rclcpp::node_interfaces::get_node_topics_interface;\n   auto node_topics_interface = get_node_topics_interface(node_topics);\n \n-  std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003CROSMessageType\u003E\u003E\n\u002B  std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003E\n   subscription_topic_stats = nullptr;\n \n   if (rclcpp::detail::resolve_enable_topic_statistics(\n@@ -80,8 \u002B80,7 @@ create_subscription(\n     if (options.topic_stats_options.publish_period \u003C= std::chrono::milliseconds(0)) {\n       throw std::invalid_argument(\n               \u0022topic_stats_options.publish_period must be greater than 0, specified value of \u0022 \u002B\n-              std::to_string(options.topic_stats_options.publish_period.count()) \u002B\n-              \u0022 ms\u0022);\n\u002B              std::to_string(options.topic_stats_options.publish_period.count()) \u002B \u0022 ms\u0022);\n     }\n \n     std::shared_ptr\u003CPublisher\u003Cstatistics_msgs::msg::MetricsMessage\u003E\u003E\n@@ -91,12 \u002B90,12 @@ create_subscription(\n       options.topic_stats_options.publish_topic,\n       qos);\n \n-    subscription_topic_stats = std::make_shared\u003C\n-      rclcpp::topic_statistics::SubscriptionTopicStatistics\u003CROSMessageType\u003E\n-      \u003E(node_topics_interface-\u003Eget_node_base_interface()-\u003Eget_name(), publisher);\n\u002B    subscription_topic_stats =\n\u002B      std::make_shared\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003E(\n\u002B      node_topics_interface-\u003Eget_node_base_interface()-\u003Eget_name(), publisher);\n \n     std::weak_ptr\u003C\n-      rclcpp::topic_statistics::SubscriptionTopicStatistics\u003CROSMessageType\u003E\n\u002B      rclcpp::topic_statistics::SubscriptionTopicStatistics\n     \u003E weak_subscription_topic_stats(subscription_topic_stats);\n     auto sub_call_back = [weak_subscription_topic_stats]() {\n         auto subscription_topic_stats = weak_subscription_topic_stats.lock();\ndiff --git rclcpp/include/rclcpp/subscription.hpp rclcpp/include/rclcpp/subscription.hpp\nindex b0857fb1..8e1aac2a 100644\n--- rclcpp/include/rclcpp/subscription.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription.hpp\n@@ -104,7 \u002B104,7 @@ public:\n \n private:\n   using SubscriptionTopicStatisticsSharedPtr =\n-    std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003CROSMessageType\u003E\u003E;\n\u002B    std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003E;\n \n public:\n   RCLCPP_SMART_PTR_DEFINITIONS(Subscription)\n@@ -316,7 \u002B316,7 @@ public:\n     if (subscription_topic_statistics_) {\n       const auto nanos = std::chrono::time_point_cast\u003Cstd::chrono::nanoseconds\u003E(now);\n       const auto time = rclcpp::Time(nanos.time_since_epoch().count());\n-      subscription_topic_statistics_-\u003Ehandle_message(*typed_message, time);\n\u002B      subscription_topic_statistics_-\u003Ehandle_message(message_info.get_rmw_message_info(), time);\n     }\n   }\n \n@@ -357,7 \u002B357,7 @@ public:\n     if (subscription_topic_statistics_) {\n       const auto nanos = std::chrono::time_point_cast\u003Cstd::chrono::nanoseconds\u003E(now);\n       const auto time = rclcpp::Time(nanos.time_since_epoch().count());\n-      subscription_topic_statistics_-\u003Ehandle_message(*typed_message, time);\n\u002B      subscription_topic_statistics_-\u003Ehandle_message(message_info.get_rmw_message_info(), time);\n     }\n   }\n \ndiff --git rclcpp/include/rclcpp/subscription_factory.hpp rclcpp/include/rclcpp/subscription_factory.hpp\nindex a1727eab..0e9d9fef 100644\n--- rclcpp/include/rclcpp/subscription_factory.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription_factory.hpp\n@@ -75,15 \u002B75,14 @@ template\u003C\n   typename CallbackT,\n   typename AllocatorT,\n   typename SubscriptionT = rclcpp::Subscription\u003CMessageT, AllocatorT\u003E,\n-  typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType,\n-  typename ROSMessageType = typename SubscriptionT::ROSMessageType\n\u002B  typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType\n \u003E\n SubscriptionFactory\n create_subscription_factory(\n   CallbackT \u0026\u0026 callback,\n   const rclcpp::SubscriptionOptionsWithAllocator\u003CAllocatorT\u003E \u0026 options,\n   typename MessageMemoryStrategyT::SharedPtr msg_mem_strat,\n-  std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003CROSMessageType\u003E\u003E\n\u002B  std::shared_ptr\u003Crclcpp::topic_statistics::SubscriptionTopicStatistics\u003E\n   subscription_topic_stats = nullptr\n )\n {\ndiff --git rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\nindex 4b922140..781e2c86 100644\n--- rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/topic_statistics/subscription_topic_statistics.hpp\n@@ -48,21 \u002B48,12 @@ using libstatistics_collector::moving_average_statistics::StatisticData;\n /**\n  * Class used to collect, measure, and publish topic statistics data. Current statistics\n  * supported for subscribers are received message age and received message period.\n- *\n- * \\tparam CallbackMessageT the subscribed message type\n- */\n-template\u003Ctypename CallbackMessageT\u003E\n\u002B  */\n class SubscriptionTopicStatistics\n {\n-  using TopicStatsCollector =\n-    libstatistics_collector::topic_statistics_collector::TopicStatisticsCollector\u003C\n-    CallbackMessageT\u003E;\n-  using ReceivedMessageAge =\n-    libstatistics_collector::topic_statistics_collector::ReceivedMessageAgeCollector\u003C\n-    CallbackMessageT\u003E;\n-  using ReceivedMessagePeriod =\n-    libstatistics_collector::topic_statistics_collector::ReceivedMessagePeriodCollector\u003C\n-    CallbackMessageT\u003E;\n\u002B  using TopicStatsCollector = libstatistics_collector::TopicStatisticsCollector;\n\u002B  using ReceivedMessageAge = libstatistics_collector::ReceivedMessageAgeCollector;\n\u002B  using ReceivedMessagePeriod = libstatistics_collector::ReceivedMessagePeriodCollector;\n \n public:\n   /// Construct a SubscriptionTopicStatistics object.\n@@ -101,16 \u002B92,16 @@ public:\n   /**\n    * This method acquires a lock to prevent race conditions to collectors list.\n    *\n-   * \\param received_message the message received by the subscription\n\u002B   * \\param message_info the message info corresponding to the received message\n    * \\param now_nanoseconds current time in nanoseconds\n    */\n   virtual void handle_message(\n-    const CallbackMessageT \u0026 received_message,\n\u002B    const rmw_message_info_t \u0026 message_info,\n     const rclcpp::Time now_nanoseconds) const\n   {\n     std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n     for (const auto \u0026 collector : subscriber_statistics_collectors_) {\n-      collector-\u003EOnMessageReceived(received_message, now_nanoseconds.nanoseconds());\n\u002B      collector-\u003EOnMessageReceived(message_info, now_nanoseconds.nanoseconds());\n     }\n   }\n \ndiff --git rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\nindex ce6887c6..91662722 100644\n--- rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/topic_statistics/test_subscription_topic_statistics.cpp\n@@ -14,7 \u002B14,6 @@\n \n #include \u003Cgtest/gtest.h\u003E\n \n-#include \u003Catomic\u003E\n #include \u003Cchrono\u003E\n #include \u003Ciostream\u003E\n #include \u003Cmemory\u003E\n@@ -22,12 \u002B21,12 @@\n #include \u003Cset\u003E\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n #include \u003Cvector\u003E\n \n #include \u0022libstatistics_collector/moving_average_statistics/types.hpp\u0022\n \n #include \u0022rclcpp/create_publisher.hpp\u0022\n-#include \u0022rclcpp/msg/message_with_header.hpp\u0022\n #include \u0022rclcpp/node.hpp\u0022\n #include \u0022rclcpp/qos.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n@@ -36,10 \u002B35,10 @@\n #include \u0022rclcpp/topic_statistics/subscription_topic_statistics.hpp\u0022\n \n #include \u0022statistics_msgs/msg/metrics_message.hpp\u0022\n-#include \u0022statistics_msgs/msg/statistic_data_point.hpp\u0022\n #include \u0022statistics_msgs/msg/statistic_data_type.hpp\u0022\n \n #include \u0022test_msgs/msg/empty.hpp\u0022\n\u002B#include \u0022test_msgs/msg/strings.hpp\u0022\n \n #include \u0022test_topic_stats_utils.hpp\u0022\n \n@@ -67,7 \u002B66,6 @@ constexpr const std::chrono::seconds kUnstableMessageAgeWindowDuration{\n constexpr const std::chrono::seconds kUnstableMessageAgeOffset{std::chrono::seconds{1}};\n }  // namespace\n \n-using rclcpp::msg::MessageWithHeader;\n using test_msgs::msg::Empty;\n using rclcpp::topic_statistics::SubscriptionTopicStatistics;\n using statistics_msgs::msg::MetricsMessage;\n@@ -76,114 \u002B74,73 @@ using statistics_msgs::msg::StatisticDataType;\n using libstatistics_collector::moving_average_statistics::StatisticData;\n \n /**\n- * Wrapper class to test and expose parts of the SubscriptionTopicStatistics\u003CT\u003E class.\n- * \\tparam CallbackMessageT\n\u002B * Wrapper class to test and expose parts of the SubscriptionTopicStatistics class.\n  */\n-template\u003Ctypename CallbackMessageT\u003E\n-class TestSubscriptionTopicStatistics : public SubscriptionTopicStatistics\u003CCallbackMessageT\u003E\n\u002Bclass TestSubscriptionTopicStatistics : public SubscriptionTopicStatistics\n {\n public:\n   TestSubscriptionTopicStatistics(\n     const std::string \u0026 node_name,\n     rclcpp::Publisher\u003Cstatistics_msgs::msg::MetricsMessage\u003E::SharedPtr publisher)\n-  : SubscriptionTopicStatistics\u003CCallbackMessageT\u003E(node_name, publisher)\n\u002B  : SubscriptionTopicStatistics(node_name, std::move(publisher))\n   {\n   }\n \n-  virtual ~TestSubscriptionTopicStatistics() = default;\n\u002B  ~TestSubscriptionTopicStatistics() override = default;\n \n   /// Exposed for testing\n-  std::vector\u003CStatisticData\u003E get_current_collector_data() const\n-  {\n-    return SubscriptionTopicStatistics\u003CCallbackMessageT\u003E::get_current_collector_data();\n-  }\n\u002B  using SubscriptionTopicStatistics::get_current_collector_data;\n };\n \n /**\n- * Empty publisher node: used to publish empty messages\n\u002B * PublisherNode wrapper: used to create publisher node\n  */\n-class EmptyPublisher : public rclcpp::Node\n\u002Btemplate\u003Ctypename MessageT\u003E\n\u002Bclass PublisherNode : public rclcpp::Node\n {\n public:\n-  EmptyPublisher(\n\u002B  PublisherNode(\n     const std::string \u0026 name, const std::string \u0026 topic,\n     const std::chrono::milliseconds \u0026 publish_period = std::chrono::milliseconds{100})\n   : Node(name)\n   {\n-    publisher_ = create_publisher\u003CEmpty\u003E(topic, 10);\n\u002B    publisher_ = create_publisher\u003CMessageT\u003E(topic, 10);\n     publish_timer_ = this-\u003Ecreate_wall_timer(\n       publish_period, [this]() {\n         this-\u003Epublish_message();\n       });\n   }\n \n-  virtual ~EmptyPublisher() = default;\n\u002B  ~PublisherNode() override = default;\n \n private:\n   void publish_message()\n   {\n-    auto msg = Empty{};\n\u002B    auto msg = MessageT{};\n     publisher_-\u003Epublish(msg);\n   }\n \n-  rclcpp::Publisher\u003CEmpty\u003E::SharedPtr publisher_;\n\u002B  typename rclcpp::Publisher\u003CMessageT\u003E::SharedPtr publisher_;\n   rclcpp::TimerBase::SharedPtr publish_timer_;\n };\n \n /**\n- * MessageWithHeader publisher node: used to publish MessageWithHeader with \u0060header\u0060 value set\n- */\n-class MessageWithHeaderPublisher : public rclcpp::Node\n-{\n-public:\n-  MessageWithHeaderPublisher(\n-    const std::string \u0026 name, const std::string \u0026 topic,\n-    const std::chrono::milliseconds \u0026 publish_period = std::chrono::milliseconds{100})\n-  : Node(name)\n-  {\n-    publisher_ = create_publisher\u003CMessageWithHeader\u003E(topic, 10);\n-    publish_timer_ = this-\u003Ecreate_wall_timer(\n-      publish_period, [this]() {\n-        this-\u003Epublish_message();\n-      });\n-    uniform_dist_ = std::uniform_int_distribution\u003Cuint32_t\u003E{1000000, 100000000};\n-  }\n-\n-  virtual ~MessageWithHeaderPublisher() = default;\n-\n-private:\n-  void publish_message()\n-  {\n-    std::random_device rd;\n-    std::mt19937 gen{rd()};\n-    uint32_t d = uniform_dist_(gen);\n-    auto msg = MessageWithHeader{};\n-    // Subtract ~1 second (add some noise for a non-zero standard deviation)\n-    // so the received message age calculation is always \u003E 0\n-    msg.header.stamp = this-\u003Enow() - rclcpp::Duration{1, d};\n-    publisher_-\u003Epublish(msg);\n-  }\n-\n-  rclcpp::Publisher\u003CMessageWithHeader\u003E::SharedPtr publisher_;\n-  rclcpp::TimerBase::SharedPtr publish_timer_;\n-  std::uniform_int_distribution\u003Cuint32_t\u003E uniform_dist_;\n-};\n-\n-/**\n- * TransitionMessageStamp publisher node : used to publish MessageWithHeader with \u0060header\u0060 value set\n\u002B * TransitionMessageStamp publisher emulator node : used to emulate publishing messages by\n\u002B * directly calling rclcpp::Subscription::handle_message(msg_shared_ptr, message_info).\n  * The message age results change during the test.\n  */\n-\n-class TransitionMessageStampPublisher : public rclcpp::Node\n\u002Btemplate\u003Ctypename MessageT\u003E\n\u002Bclass TransitionMessageStampPublisherEmulator : public rclcpp::Node\n {\n public:\n-  TransitionMessageStampPublisher(\n-    const std::string \u0026 name, const std::string \u0026 topic,\n\u002B  TransitionMessageStampPublisherEmulator(\n\u002B    const std::string \u0026 name,\n     const std::chrono::seconds transition_duration, const std::chrono::seconds message_age_offset,\n\u002B    typename rclcpp::Subscription\u003CMessageT\u003E::SharedPtr subscription,\n     const std::chrono::milliseconds \u0026 publish_period = std::chrono::milliseconds{100})\n-  : Node(name), transition_duration_(transition_duration), message_age_offset_(message_age_offset)\n\u002B  : Node(name), transition_duration_(transition_duration), message_age_offset_(message_age_offset),\n\u002B    subscription_(std::move(subscription))\n   {\n-    publisher_ = create_publisher\u003CMessageWithHeader\u003E(topic, 10);\n     publish_timer_ = this-\u003Ecreate_wall_timer(publish_period, [this]() {this-\u003Epublish_message();});\n     start_time_ = this-\u003Enow();\n   }\n@@ -191,84 \u002B148,66 @@ public:\n private:\n   void publish_message()\n   {\n-    auto msg = MessageWithHeader{};\n\u002B    std::shared_ptr\u003Cvoid\u003E msg_shared_ptr = std::make_shared\u003CMessageT\u003E();\n\u002B    rmw_message_info_t rmw_message_info = rmw_get_zero_initialized_message_info();\n\u002B\n     auto now = this-\u003Enow();\n     auto elapsed_time = now - start_time_;\n     if (elapsed_time \u003C transition_duration_) {\n       // Apply only to the topic statistics in the first half\n       // Subtract offset so message_age is always \u003E= offset.\n-      msg.header.stamp = now - message_age_offset_;\n\u002B      rmw_message_info.source_timestamp = (now - message_age_offset_).nanoseconds();\n     } else {\n-      msg.header.stamp = now;\n\u002B      rmw_message_info.source_timestamp = now.nanoseconds();\n     }\n-    publisher_-\u003Epublish(msg);\n\u002B    rclcpp::MessageInfo message_info{rmw_message_info};\n\u002B    subscription_-\u003Ehandle_message(msg_shared_ptr, message_info);\n   }\n \n   std::chrono::seconds transition_duration_;\n   std::chrono::seconds message_age_offset_;\n\u002B  typename rclcpp::Subscription\u003CMessageT\u003E::SharedPtr subscription_;\n   rclcpp::Time start_time_;\n-\n-  rclcpp::Publisher\u003CMessageWithHeader\u003E::SharedPtr publisher_;\n   rclcpp::TimerBase::SharedPtr publish_timer_;\n };\n \n /**\n- * Empty subscriber node: used to create subscriber topic statistics requirements\n\u002B * Message subscriber node: used to create subscriber with enabled topic statistics collectors\n\u002B *\n  */\n-class EmptySubscriber : public rclcpp::Node\n\u002Btemplate\u003Ctypename MessageT\u003E\n\u002Bclass SubscriberWithTopicStatistics : public rclcpp::Node\n {\n public:\n-  EmptySubscriber(const std::string \u0026 name, const std::string \u0026 topic)\n\u002B  SubscriberWithTopicStatistics(\n\u002B    const std::string \u0026 name, const std::string \u0026 topic,\n\u002B    std::chrono::milliseconds publish_period = defaultStatisticsPublishPeriod)\n   : Node(name)\n   {\n-    // manually enable topic statistics via options\n\u002B    // Manually enable topic statistics via options\n     auto options = rclcpp::SubscriptionOptions();\n     options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n\u002B    options.topic_stats_options.publish_period = publish_period;\n \n-    auto callback = [](Empty::UniquePtr msg) {\n\u002B    auto callback = [](typename MessageT::UniquePtr msg) {\n         (void) msg;\n       };\n-    subscription_ = create_subscription\u003CEmpty,\n-        std::function\u003Cvoid(Empty::UniquePtr)\u003E\u003E(\n\u002B    subscription_ = create_subscription\u003CMessageT,\n\u002B        std::function\u003Cvoid(typename MessageT::UniquePtr)\u003E\u003E(\n       topic,\n       rclcpp::QoS(rclcpp::KeepAll()),\n       callback,\n       options);\n   }\n-  virtual ~EmptySubscriber() = default;\n-\n-private:\n-  rclcpp::Subscription\u003CEmpty\u003E::SharedPtr subscription_;\n-};\n\u002B  ~SubscriberWithTopicStatistics() override = default;\n \n-/**\n- * MessageWithHeader subscriber node: used to create subscriber topic statistics requirements\n- */\n-class MessageWithHeaderSubscriber : public rclcpp::Node\n-{\n-public:\n-  MessageWithHeaderSubscriber(const std::string \u0026 name, const std::string \u0026 topic)\n-  : Node(name)\n\u002B  typename rclcpp::Subscription\u003CMessageT\u003E::SharedPtr get_subscription()\n   {\n-    // manually enable topic statistics via options\n-    auto options = rclcpp::SubscriptionOptions();\n-    options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n-    options.topic_stats_options.publish_period = defaultStatisticsPublishPeriod;\n-\n-    auto callback = [](MessageWithHeader::UniquePtr msg) {\n-        (void) msg;\n-      };\n-    subscription_ = create_subscription\u003CMessageWithHeader,\n-        std::function\u003Cvoid(MessageWithHeader::UniquePtr)\u003E\u003E(\n-      topic,\n-      rclcpp::QoS(rclcpp::KeepAll()),\n-      callback,\n-      options);\n\u002B    return subscription_;\n   }\n-  virtual ~MessageWithHeaderSubscriber() = default;\n \n private:\n-  rclcpp::Subscription\u003CMessageWithHeader\u003E::SharedPtr subscription_;\n\u002B  typename rclcpp::Subscription\u003CMessageT\u003E::SharedPtr subscription_;\n };\n \n /**\n@@ -277,43 \u002B216,17 @@ private:\n class TestSubscriptionTopicStatisticsFixture : public ::testing::Test\n {\n protected:\n-  void SetUp()\n\u002B  void SetUp() override\n   {\n     rclcpp::init(0 /* argc */, nullptr /* argv */);\n   }\n \n-  void TearDown()\n\u002B  void TearDown() override\n   {\n     rclcpp::shutdown();\n   }\n };\n \n-/**\n- * Check if a received statistics message is empty (no data was observed)\n- * \\param message_to_check\n- */\n-void check_if_statistics_message_is_empty(const MetricsMessage \u0026 message_to_check)\n-{\n-  for (const auto \u0026 stats_point : message_to_check.statistics) {\n-    const auto type = stats_point.data_type;\n-    switch (type) {\n-      case StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT:\n-        EXPECT_EQ(0, stats_point.data) \u003C\u003C \u0022unexpected sample count\u0022 \u003C\u003C stats_point.data;\n-        break;\n-      case StatisticDataType::STATISTICS_DATA_TYPE_AVERAGE:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_MINIMUM:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_MAXIMUM:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_STDDEV:\n-        EXPECT_TRUE(std::isnan(stats_point.data)) \u003C\u003C \u0022unexpected value\u0022 \u003C\u003C stats_point.data \u003C\u003C\n-          \u0022 for type:\u0022 \u003C\u003C type;\n-        break;\n-      default:\n-        FAIL() \u003C\u003C \u0022received unknown statistics type: \u0022 \u003C\u003C std::dec \u003C\u003C\n-          static_cast\u003Cunsigned int\u003E(type);\n-    }\n-  }\n-}\n-\n /**\n  * Check if a received statistics message observed data and contains some calculation\n  * \\param message_to_check\n@@ -348,28 \u002B261,13 @@ void check_if_statistic_message_is_populated(const MetricsMessage \u0026 message_to_c\n /**\n  * Test an invalid argument is thrown for a bad input publish period.\n  */\n-TEST(TestSubscriptionTopicStatistics, test_invalid_publish_period)\n\u002BTEST_F(TestSubscriptionTopicStatisticsFixture, test_invalid_publish_period)\n {\n-  rclcpp::init(0 /* argc */, nullptr /* argv */);\n-\n-  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_period_node\u0022);\n-\n-  auto options = rclcpp::SubscriptionOptions();\n-  options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n-  options.topic_stats_options.publish_period = std::chrono::milliseconds(0);\n-\n-  auto callback = [](Empty::UniquePtr msg) {\n-      (void) msg;\n-    };\n-\n   ASSERT_THROW(\n-    (node-\u003Ecreate_subscription\u003CEmpty, std::function\u003Cvoid(Empty::UniquePtr)\u003E\u003E(\n-      \u0022should_throw_invalid_arg\u0022,\n-      rclcpp::QoS(rclcpp::KeepAll()),\n-      callback,\n-      options)), std::invalid_argument);\n-\n-  rclcpp::shutdown();\n\u002B    SubscriberWithTopicStatistics\u003CEmpty\u003E(\n\u002B      \u0022test_period_node\u0022, \u0022should_throw_invalid_arg\u0022, std::chrono::milliseconds(0)\n\u002B    ),\n\u002B    std::invalid_argument);\n }\n \n /**\n@@ -378,7 \u002B276,7 @@ TEST(TestSubscriptionTopicStatistics, test_invalid_publish_period)\n  */\n TEST_F(TestSubscriptionTopicStatisticsFixture, test_manual_construction)\n {\n-  auto empty_subscriber = std::make_shared\u003CEmptySubscriber\u003E(\n\u002B  auto empty_subscriber = std::make_shared\u003CSubscriberWithTopicStatistics\u003CEmpty\u003E\u003E(\n     kTestSubNodeName,\n     kTestSubStatsEmptyTopic);\n \n@@ -389,7 \u002B287,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_manual_construction)\n     10);\n \n   // Construct a separate instance\n-  auto sub_topic_stats = std::make_unique\u003CTestSubscriptionTopicStatistics\u003CEmpty\u003E\u003E(\n\u002B  auto sub_topic_stats = std::make_unique\u003CTestSubscriptionTopicStatistics\u003E(\n     empty_subscriber-\u003Eget_name(),\n     topic_stats_publisher);\n \n@@ -410,7 \u002B308,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_manual_construction)\n TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no_header)\n {\n   // Create an empty publisher\n-  auto empty_publisher = std::make_shared\u003CEmptyPublisher\u003E(\n\u002B  auto empty_publisher = std::make_shared\u003CPublisherNode\u003CEmpty\u003E\u003E(\n     kTestPubNodeName,\n     kTestSubStatsEmptyTopic);\n   // empty_subscriber has a topic statistics instance as part of its subscription\n@@ -422,7 \u002B320,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n     \u0022/statistics\u0022,\n     kNumExpectedMessages);\n \n-  auto empty_subscriber = std::make_shared\u003CEmptySubscriber\u003E(\n\u002B  auto empty_subscriber = std::make_shared\u003CSubscriberWithTopicStatistics\u003CEmpty\u003E\u003E(\n     kTestSubNodeName,\n     kTestSubStatsEmptyTopic);\n \n@@ -432,74 \u002B330,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_no\n   ex.add_node(empty_subscriber);\n \n   // Spin and get future\n-  ex.spin_until_future_complete(\n-    statistics_listener-\u003EGetFuture(),\n-    kTestTimeout);\n-\n-  // Compare message counts, sample count should be the same as published and received count\n-  EXPECT_EQ(kNumExpectedMessages, statistics_listener-\u003EGetNumberOfMessagesReceived());\n-\n-  // Check the received message total count\n-  const auto received_messages = statistics_listener-\u003EGetReceivedMessages();\n-  EXPECT_EQ(kNumExpectedMessages, received_messages.size());\n-\n-  // check the type of statistics that were received and their counts\n-  uint64_t message_age_count{0};\n-  uint64_t message_period_count{0};\n-\n-  std::set\u003Cstd::string\u003E received_metrics;\n-  for (const auto \u0026 msg : received_messages) {\n-    if (msg.metrics_source == \u0022message_age\u0022) {\n-      message_age_count\u002B\u002B;\n-    }\n-    if (msg.metrics_source == \u0022message_period\u0022) {\n-      message_period_count\u002B\u002B;\n-    }\n-  }\n-  EXPECT_EQ(kNumExpectedMessageAgeMessages, message_age_count);\n-  EXPECT_EQ(kNumExpectedMessagePeriodMessages, message_period_count);\n-\n-  // Check the collected statistics for message period.\n-  // Message age statistics will not be calculated because Empty messages\n-  // don\u0027t have a \u0060header\u0060 with timestamp. This means that we expect to receive a \u0060message_age\u0060\n-  // and \u0060message_period\u0060 message for each empty message published.\n-  for (const auto \u0026 msg : received_messages) {\n-    if (msg.metrics_source == kMessageAgeSourceLabel) {\n-      check_if_statistics_message_is_empty(msg);\n-    } else if (msg.metrics_source == kMessagePeriodSourceLabel) {\n-      check_if_statistic_message_is_populated(msg);\n-    }\n-  }\n-}\n-\n-TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_with_header)\n-{\n-  // Create a MessageWithHeader publisher\n-  auto msg_with_header_publisher = std::make_shared\u003CMessageWithHeaderPublisher\u003E(\n-    kTestPubNodeName,\n-    kTestSubStatsTopic);\n-  // empty_subscriber has a topic statistics instance as part of its subscription\n-  // this will listen to and generate statistics for the empty message\n-\n-  // Create a listener for topic statistics messages\n-  auto statistics_listener = std::make_shared\u003Crclcpp::topic_statistics::MetricsMessageSubscriber\u003E(\n-    \u0022test_receive_stats_for_message_with_header\u0022,\n-    \u0022/statistics\u0022,\n-    kNumExpectedMessages);\n-\n-  auto msg_with_header_subscriber = std::make_shared\u003CMessageWithHeaderSubscriber\u003E(\n-    kTestSubNodeName,\n-    kTestSubStatsTopic);\n-\n-  rclcpp::executors::SingleThreadedExecutor ex;\n-  ex.add_node(msg_with_header_publisher);\n-  ex.add_node(statistics_listener);\n-  ex.add_node(msg_with_header_subscriber);\n-\n-  // Spin and get future\n-  ex.spin_until_future_complete(\n-    statistics_listener-\u003EGetFuture(),\n-    kTestTimeout);\n\u002B  ex.spin_until_future_complete(statistics_listener-\u003EGetFuture(), kTestTimeout);\n \n   // Compare message counts, sample count should be the same as published and received count\n   EXPECT_EQ(kNumExpectedMessages, statistics_listener-\u003EGetNumberOfMessagesReceived());\n@@ -524,6 \u002B355,7 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n   EXPECT_EQ(kNumExpectedMessageAgeMessages, message_age_count);\n   EXPECT_EQ(kNumExpectedMessagePeriodMessages, message_period_count);\n \n\u002B  // Check the collected statistics for message period.\n   for (const auto \u0026 msg : received_messages) {\n     check_if_statistic_message_is_populated(msg);\n   }\n@@ -531,23 \u002B363,27 @@ TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_wi\n \n TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_include_window_reset)\n {\n-  // Create a MessageWithHeader publisher\n-  auto msg_with_header_publisher = std::make_shared\u003CTransitionMessageStampPublisher\u003E(\n-    kTestPubNodeName, kTestSubStatsTopic, kUnstableMessageAgeWindowDuration,\n-    kUnstableMessageAgeOffset);\n-\n-  // msg_with_header_subscriber has a topic statistics instance as part of its\n\u002B  // msg_subscriber_with_topic_statistics has a topic statistics instance as part of its\n   // subscription this will listen to and generate statistics\n-  auto msg_with_header_subscriber =\n-    std::make_shared\u003CMessageWithHeaderSubscriber\u003E(kTestSubNodeName, kTestSubStatsTopic);\n\u002B  auto msg_subscriber_with_topic_statistics =\n\u002B    std::make_shared\u003CSubscriberWithTopicStatistics\u003Ctest_msgs::msg::Strings\u003E\u003E(\n\u002B    kTestSubNodeName,\n\u002B    kTestSubStatsTopic);\n\u002B\n\u002B  // Create a message publisher\n\u002B  auto msg_publisher =\n\u002B    std::make_shared\u003CTransitionMessageStampPublisherEmulator\u003Ctest_msgs::msg::Strings\u003E\u003E(\n\u002B    kTestPubNodeName, kUnstableMessageAgeWindowDuration,\n\u002B    kUnstableMessageAgeOffset, msg_subscriber_with_topic_statistics-\u003Eget_subscription());\n\u002B\n   // Create a listener for topic statistics messages\n   auto statistics_listener = std::make_shared\u003Crclcpp::topic_statistics::MetricsMessageSubscriber\u003E(\n     \u0022test_receive_stats_include_window_reset\u0022, \u0022/statistics\u0022, kNumExpectedMessages);\n \n   rclcpp::executors::SingleThreadedExecutor ex;\n-  ex.add_node(msg_with_header_publisher);\n\u002B  ex.add_node(msg_publisher);\n   ex.add_node(statistics_listener);\n-  ex.add_node(msg_with_header_subscriber);\n\u002B  ex.add_node(msg_subscriber_with_topic_statistics);\n \n   // Spin and get future\n   ex.spin_until_future_complete(statistics_listener-\u003EGetFuture(), kTestTimeout);\n",
    "IsBackported": false
  },
  {
    "Repository": "launch_ros",
    "SHA": "f557023899b9e712cb0974a1e507ccae1db33a02",
    "RawMessage": "Move previous maintainer to \u003Cauthor\u003E",
    "Changes": "diff --git launch_ros/package.xml launch_ros/package.xml\nindex 255c044..9888594 100644\n--- launch_ros/package.xml\n\u002B\u002B\u002B launch_ros/package.xml\n@@ -9,6 \u002B9,7 @@\n   \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B  \u003Cauthor email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Cdepend\u003Eament_index_python\u003C/depend\u003E\n   \u003Cdepend\u003Elaunch\u003C/depend\u003E\ndiff --git ros2launch/package.xml ros2launch/package.xml\nindex 33fba12..e908a49 100644\n--- ros2launch/package.xml\n\u002B\u002B\u002B ros2launch/package.xml\n@@ -11,6 \u002B11,7 @@\n   \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B  \u003Cauthor email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Cdepend\u003Eament_index_python\u003C/depend\u003E\n   \u003Cdepend\u003Elaunch\u003C/depend\u003E\ndiff --git test_launch_ros/package.xml test_launch_ros/package.xml\nindex 81e17c2..28a220d 100644\n--- test_launch_ros/package.xml\n\u002B\u002B\u002B test_launch_ros/package.xml\n@@ -9,6 \u002B9,7 @@\n   \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n   \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n\u002B  \u003Cauthor email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Ctest_depend\u003Eament_copyright\u003C/test_depend\u003E\n   \u003Ctest_depend\u003Eament_flake8\u003C/test_depend\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "49f2b1fdf635b7c9a605b9fd826d6c22417773bc",
    "RawMessage": "Convert wait_set functions to pybind11 (#706)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 34c5cac..031e9ab 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -181,6 \u002B181,7 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/subscription.cpp\n   src/rclpy/time_point.cpp\n   src/rclpy/timer.cpp\n\u002B  src/rclpy/wait_set.cpp\n )\n target_include_directories(_rclpy_pybind11 PRIVATE\n   src/rclpy/\ndiff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex d7b3351..05d6812 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -60,17 \u002B60,6 @@ if TYPE_CHECKING:\n     from rclpy.node import Node  # noqa: F401\n \n \n-class _WaitSet:\n-    \u0022\u0022\u0022Make sure the wait set gets destroyed when a generator exits.\u0022\u0022\u0022\n-\n-    def __enter__(self):\n-        self.wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n-        return self.wait_set\n-\n-    def __exit__(self, t, v, tb):\n-        _rclpy.rclpy_destroy_wait_set(self.wait_set)\n-\n-\n class _WorkTracker:\n     \u0022\u0022\u0022Track the amount of work that is in progress.\u0022\u0022\u0022\n \n@@ -521,7 \u002B510,8 @@ class Executor:\n                 entity_count \u002B= waitable.get_num_entities()\n \n             # Construct a wait set\n-            with _WaitSet() as wait_set, ExitStack() as context_stack:\n\u002B            wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n\u002B            with ExitStack() as context_stack:\n                 sub_capsules = []\n                 for sub in subscriptions:\n                     try:\ndiff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 6211dcb..21fe13f 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -1597,434 \u002B1597,6 @@ rclpy_get_rmw_implementation_identifier(PyObject * Py_UNUSED(self), PyObject * P\n \n   return pyrmw_implementation_identifier;\n }\n-\n-/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n-static PyObject *\n-rclpy_get_zero_initialized_wait_set(PyObject * Py_UNUSED(self), PyObject * Py_UNUSED(args))\n-{\n-  rcl_wait_set_t * wait_set = PyMem_Malloc(sizeof(rcl_wait_set_t));\n-  if (!wait_set) {\n-    PyErr_Format(PyExc_MemoryError, \u0022Failed to allocate memory for wait set\u0022);\n-    return NULL;\n-  }\n-  *wait_set = rcl_get_zero_initialized_wait_set();\n-  PyObject * pywait_set = PyCapsule_New(wait_set, \u0022rcl_wait_set_t\u0022, NULL);\n-\n-  return pywait_set;\n-}\n-\n-/// Initialize a wait set\n-/**\n- * Raises RuntimeError if the wait set could not be initialized\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] node_name string name of the node to be created\n- * \\param[in] number_of_subscriptions int\n- * \\param[in] number_of_guard_conditions int\n- * \\param[in] number_of_timers int\n- * \\param[in] number_of_clients int\n- * \\param[in] number_of_services int\n- * \\return None\n- */\n-static PyObject *\n-rclpy_wait_set_init(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-  unsigned PY_LONG_LONG number_of_subscriptions;\n-  unsigned PY_LONG_LONG number_of_guard_conditions;\n-  unsigned PY_LONG_LONG number_of_timers;\n-  unsigned PY_LONG_LONG number_of_clients;\n-  unsigned PY_LONG_LONG number_of_services;\n-  unsigned PY_LONG_LONG number_of_events;\n-  PyObject * pycontext;\n-\n-  if (!PyArg_ParseTuple(\n-      args, \u0022OKKKKKKO\u0022, \u0026pywait_set, \u0026number_of_subscriptions,\n-      \u0026number_of_guard_conditions, \u0026number_of_timers,\n-      \u0026number_of_clients, \u0026number_of_services, \u0026number_of_events, \u0026pycontext))\n-  {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  rcl_context_t * context = rclpy_handle_get_pointer_from_capsule(pycontext, \u0022rcl_context_t\u0022);\n-  if (!context) {\n-    return NULL;\n-  }\n-\n-  rcl_ret_t ret = rcl_wait_set_init(\n-    wait_set,\n-    number_of_subscriptions,\n-    number_of_guard_conditions,\n-    number_of_timers,\n-    number_of_clients,\n-    number_of_services,\n-    number_of_events,\n-    context,\n-    rcl_get_default_allocator());\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to initialize wait set: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_NONE;\n-}\n-\n-/// Clear all the pointers in the wait set\n-/**\n- * Raises RuntimeError if any rcl error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return NULL\n- */\n-static PyObject *\n-rclpy_wait_set_clear_entities(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pywait_set)) {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError, \u0022Failed to clear wait set: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_TRUE;\n-}\n-\n-/// Add an entity to the wait set structure\n-/**\n- * Raises RuntimeError if the entity type is unknown or any rcl error occurrs\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyentity Capsule pointing to the entity to add\n- * \\return Index in waitset entity was added at\n- */\n-static PyObject *\n-rclpy_wait_set_add_entity(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  PyObject * pyentity;\n-  size_t index;\n-\n-  if (!PyArg_ParseTuple(args, \u0022zOO\u0022, \u0026entity_type, \u0026pywait_set, \u0026pyentity)) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret;\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  if (0 == strcmp(entity_type, \u0022subscription\u0022)) {\n-    rclpy_subscription_t * sub =\n-      rclpy_handle_get_pointer_from_capsule(pyentity, \u0022rclpy_subscription_t\u0022);\n-    if (!sub) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_subscription(wait_set, \u0026(sub-\u003Esubscription), \u0026index);\n-  } else if (0 == strcmp(entity_type, \u0022client\u0022)) {\n-    rclpy_client_t * client = rclpy_handle_get_pointer_from_capsule(pyentity, \u0022rclpy_client_t\u0022);\n-    if (!client) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_client(wait_set, \u0026(client-\u003Eclient), \u0026index);\n-  } else if (0 == strcmp(entity_type, \u0022service\u0022)) {\n-    rclpy_service_t * srv = rclpy_handle_get_pointer_from_capsule(pyentity, \u0022rclpy_service_t\u0022);\n-    if (!srv) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_service(wait_set, \u0026(srv-\u003Eservice), \u0026index);\n-  } else if (0 == strcmp(entity_type, \u0022timer\u0022)) {\n-    rcl_timer_t * timer = rclpy_handle_get_pointer_from_capsule(pyentity, \u0022rcl_timer_t\u0022);\n-    if (!timer) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_timer(wait_set, timer, \u0026index);\n-  } else if (0 == strcmp(entity_type, \u0022guard_condition\u0022)) {\n-    rcl_guard_condition_t * guard_condition = rclpy_handle_get_pointer_from_capsule(\n-      pyentity, \u0022rcl_guard_condition_t\u0022);\n-    if (!guard_condition) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, \u0026index);\n-  } else if (0 == strcmp(entity_type, \u0022event\u0022)) {\n-    rcl_event_t * event = rclpy_handle_get_pointer_from_capsule(pyentity, \u0022rcl_event_t\u0022);\n-    ret = rcl_wait_set_add_event(wait_set, event, \u0026index);\n-  } else {\n-    PyErr_Format(\n-      PyExc_RuntimeError, \u0022\u0027%s\u0027 is not a known entity\u0022, entity_type);\n-    return NULL;\n-  }\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to add \u0027%s\u0027 to wait set: %s\u0022, entity_type, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  return PyLong_FromSize_t(index);\n-}\n-\n-/// Check if an entity in the wait set is ready by its index\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError if the entity type is unknown\n- * Raises IndexError if the given index is beyond the number of entities in the set\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyindex location in the wait set of the entity to check\n- * \\return True if the entity at the index in the wait set is not NULL\n- */\n-static PyObject *\n-rclpy_wait_set_is_ready(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  PyObject * pyindex;\n-  size_t index;\n-\n-  if (!PyArg_ParseTuple(args, \u0022zOO\u0022, \u0026entity_type, \u0026pywait_set, \u0026pyindex)) {\n-    return NULL;\n-  }\n-\n-  index = PyLong_AsSize_t(pyindex);\n-  if (PyErr_Occurred()) {\n-    // Error already set\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  void ** entities = NULL;\n-  size_t num_entities = 0;\n-  if (0 == strcmp(entity_type, \u0022subscription\u0022)) {\n-    entities = (void *)wait_set-\u003Esubscriptions;\n-    num_entities = wait_set-\u003Esize_of_subscriptions;\n-  } else if (0 == strcmp(entity_type, \u0022client\u0022)) {\n-    entities = (void *)wait_set-\u003Eclients;\n-    num_entities = wait_set-\u003Esize_of_clients;\n-  } else if (0 == strcmp(entity_type, \u0022service\u0022)) {\n-    entities = (void *)wait_set-\u003Eservices;\n-    num_entities = wait_set-\u003Esize_of_services;\n-  } else if (0 == strcmp(entity_type, \u0022timer\u0022)) {\n-    entities = (void *)wait_set-\u003Etimers;\n-    num_entities = wait_set-\u003Esize_of_timers;\n-  } else if (0 == strcmp(entity_type, \u0022guard_condition\u0022)) {\n-    entities = (void *)wait_set-\u003Eguard_conditions;\n-    num_entities = wait_set-\u003Esize_of_guard_conditions;\n-  } else if (0 == strcmp(entity_type, \u0022event\u0022)) {\n-    entities = (void *)wait_set-\u003Eevents;\n-    num_entities = wait_set-\u003Esize_of_events;\n-  } else {\n-    PyErr_Format(\n-      PyExc_RuntimeError, \u0022\u0027%s\u0027 is not a known entity\u0022, entity_type);\n-    return NULL;\n-  }\n-\n-  if (!entities) {\n-    PyErr_Format(PyExc_RuntimeError, \u0022Wait set \u0027%s\u0027 isn\u0027t allocated\u0022, entity_type);\n-    return NULL;\n-  }\n-  if (index \u003E= num_entities) {\n-    PyErr_Format(PyExc_IndexError, \u0022%s index too big %zu \u003E= %zu\u0022, entity_type, index, num_entities);\n-    return NULL;\n-  }\n-  if (NULL != entities[index]) {\n-    Py_RETURN_TRUE;\n-  }\n-  Py_RETURN_FALSE;\n-}\n-\n-/// Destroy the wait set structure\n-/**\n- * Raises RuntimeError if the wait set could not be destroyed\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return None\n- */\n-static PyObject *\n-rclpy_destroy_wait_set(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-\n-  if (!PyArg_ParseTuple(args, \u0022O\u0022, \u0026pywait_set)) {\n-    return NULL;\n-  }\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError, \u0022Failed to fini wait set: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-\n-  PyMem_Free(wait_set);\n-\n-  if (PyCapsule_SetPointer(pywait_set, Py_None)) {\n-    // exception set by PyCapsule_SetPointer\n-    return NULL;\n-  }\n-\n-  Py_RETURN_NONE;\n-}\n-\n-#define GET_LIST_READY_ENTITIES(ENTITY_TYPE) \\\n-  size_t idx; \\\n-  size_t idx_max; \\\n-  idx_max = wait_set-\u003Esize_of_ ## ENTITY_TYPE ## s; \\\n-  const rcl_ ## ENTITY_TYPE ## _t ** struct_ptr = wait_set-\u003EENTITY_TYPE ## s; \\\n-  for (idx = 0; idx \u003C idx_max; idx \u002B\u002B) { \\\n-    if (struct_ptr[idx]) { \\\n-      PyObject * obj = PyLong_FromVoidPtr((void *) struct_ptr[idx]); \\\n-      if (obj) { \\\n-        int rc = PyList_Append(entity_ready_list, obj); \\\n-        Py_DECREF(obj); \\\n-        if (rc != 0) { \\\n-          Py_DECREF(entity_ready_list); \\\n-          return NULL; \\\n-        } \\\n-      } else { \\\n-        Py_DECREF(entity_ready_list); \\\n-        return NULL; \\\n-      } \\\n-    } \\\n-  } \\\n-  return entity_ready_list;\n-/// Get list of non-null entities in wait set\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if the entity type is not known\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return List of wait set entities pointers ready for take\n- */\n-static PyObject *\n-rclpy_get_ready_entities(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  if (!PyArg_ParseTuple(args, \u0022zO\u0022, \u0026entity_type, \u0026pywait_set)) {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  PyObject * entity_ready_list = PyList_New(0);\n-  if (0 == strcmp(entity_type, \u0022subscription\u0022)) {\n-    GET_LIST_READY_ENTITIES(subscription)\n-  } else if (0 == strcmp(entity_type, \u0022client\u0022)) {\n-    GET_LIST_READY_ENTITIES(client)\n-  } else if (0 == strcmp(entity_type, \u0022service\u0022)) {\n-    GET_LIST_READY_ENTITIES(service)\n-  } else if (0 == strcmp(entity_type, \u0022timer\u0022)) {\n-    GET_LIST_READY_ENTITIES(timer)\n-  } else if (0 == strcmp(entity_type, \u0022guard_condition\u0022)) {\n-    GET_LIST_READY_ENTITIES(guard_condition)\n-  }\n-  Py_DECREF(entity_ready_list);\n-  PyErr_Format(\n-    PyExc_RuntimeError, \u0022\u0027%s\u0027 is not a known entity\u0022, entity_type);\n-  return NULL;\n-}\n-\n-/// Wait until timeout is reached or event happened\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if there was an error while waiting\n- *\n- * This function will wait for an event to happen or for the timeout to expire.\n- * A negative timeout means wait forever, a timeout of 0 means no wait\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n- * \\return NULL\n- */\n-static PyObject *\n-rclpy_wait(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-  PY_LONG_LONG timeout = -1;\n-\n-  if (!PyArg_ParseTuple(args, \u0022O|K\u0022, \u0026pywait_set, \u0026timeout)) {\n-    return NULL;\n-  }\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \u0022rcl_wait_set_t\u0022);\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret;\n-\n-  // Could be a long wait, release the GIL\n-  Py_BEGIN_ALLOW_THREADS;\n-  ret = rcl_wait(wait_set, timeout);\n-  Py_END_ALLOW_THREADS;\n-\n-  if (ret != RCL_RET_OK \u0026\u0026 ret != RCL_RET_TIMEOUT) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError, \u0022Failed to wait on wait set: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_NONE;\n-}\n-\n /// Take a raw message from a given subscription (internal- for rclpy_take with raw=True)\n /**\n  * \\param[in] module_state the module state for the _rclpy module\n@@ -3695,46 \u002B3267,6 @@ static PyMethodDef rclpy_methods[] = {\n     \u0022Create an Event.\u0022\n   },\n \n-  {\n-    \u0022rclpy_get_zero_initialized_wait_set\u0022, rclpy_get_zero_initialized_wait_set, METH_NOARGS,\n-    \u0022rclpy_get_zero_initialized_wait_set.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_wait_set_init\u0022, rclpy_wait_set_init, METH_VARARGS,\n-    \u0022rclpy_wait_set_init.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_wait_set_clear_entities\u0022, rclpy_wait_set_clear_entities, METH_VARARGS,\n-    \u0022rclpy_wait_set_clear_entities.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_wait_set_add_entity\u0022, rclpy_wait_set_add_entity, METH_VARARGS,\n-    \u0022rclpy_wait_set_add_entity.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_wait_set_is_ready\u0022, rclpy_wait_set_is_ready, METH_VARARGS,\n-    \u0022rclpy_wait_set_is_ready.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_destroy_wait_set\u0022, rclpy_destroy_wait_set, METH_VARARGS,\n-    \u0022rclpy_destroy_wait_set.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_get_ready_entities\u0022, rclpy_get_ready_entities, METH_VARARGS,\n-    \u0022List non null entities in wait set.\u0022\n-  },\n-\n-  {\n-    \u0022rclpy_wait\u0022, rclpy_wait, METH_VARARGS,\n-    \u0022rclpy_wait.\u0022\n-  },\n-\n   {\n     \u0022rclpy_take\u0022, rclpy_take, METH_VARARGS,\n     \u0022rclpy_take.\u0022\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex 9108777..27aeb93 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -25,6 \u002B25,7 @@\n #include \u0022subscription.hpp\u0022\n #include \u0022time_point.hpp\u0022\n #include \u0022timer.hpp\u0022\n\u002B#include \u0022wait_set.hpp\u0022\n \n namespace py = pybind11;\n \n@@ -195,4 \u002B196,26 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n   m.def(\n     \u0022rclpy_remove_clock_callback\u0022, \u0026rclpy::remove_jump_callback,\n     \u0022Remove a time jump callback from a clock.\u0022);\n\u002B\n\u002B  m.def(\n\u002B    \u0022rclpy_get_zero_initialized_wait_set\u0022, \u0026rclpy::get_zero_initialized_wait_set,\n\u002B    \u0022rclpy_get_zero_initialized_wait_set.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_wait_set_init\u0022, \u0026rclpy::wait_set_init,\n\u002B    \u0022rclpy_wait_set_init.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_wait_set_clear_entities\u0022, \u0026rclpy::wait_set_clear_entities,\n\u002B    \u0022rclpy_wait_set_clear_entities.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_wait_set_add_entity\u0022, \u0026rclpy::wait_set_add_entity,\n\u002B    \u0022rclpy_wait_set_add_entity.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_wait_set_is_ready\u0022, \u0026rclpy::wait_set_is_ready,\n\u002B    \u0022rclpy_wait_set_is_ready.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_get_ready_entities\u0022, \u0026rclpy::get_ready_entities,\n\u002B    \u0022List non null entities in wait set.\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_wait\u0022, \u0026rclpy::wait,\n\u002B    \u0022rclpy_wait.\u0022);\n }\ndiff --git rclpy/src/rclpy/wait_set.cpp rclpy/src/rclpy/wait_set.cpp\nnew file mode 100644\nindex 0000000..09bcd0a\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/wait_set.cpp\n@@ -0,0 \u002B1,298 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B// Include pybind11 before rclpy_common/handle.h includes Python.h\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcl/rcl.h\u003E\n\u002B#include \u003Crcl/types.h\u003E\n\u002B\n\u002B#include \u003Ccstring\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002Bextern \u0022C\u0022\n\u002B{\n\u002B#include \u0022rclpy_common/common.h\u0022\n\u002B}\n\u002B#include \u0022rclpy_common/handle.h\u0022\n\u002B\n\u002B#include \u0022rclpy_common/exceptions.hpp\u0022\n\u002B#include \u0022wait_set.hpp\u0022\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B/// Destructor for a wait set\n\u002Bvoid\n\u002B_rclpy_destroy_wait_set(PyObject * pycapsule)\n\u002B{\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(PyCapsule_GetPointer(pycapsule, \u0022rcl_wait_set_t\u0022));\n\u002B\n\u002B  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    // Warning should use line number of the current stack frame\n\u002B    int stack_level = 1;\n\u002B    PyErr_WarnFormat(\n\u002B      PyExc_RuntimeWarning, stack_level,\n\u002B      \u0022Failed to fini wait set: %s\u0022, rcl_get_error_string().str);\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  PyMem_Free(wait_set);\n\u002B}\n\u002B\n\u002Bpy::capsule\n\u002Bget_zero_initialized_wait_set()\n\u002B{\n\u002B  auto deleter = [](rcl_wait_set_t * ptr) {PyMem_FREE(ptr);};\n\u002B  auto wait_set = std::unique_ptr\u003Crcl_wait_set_t, decltype(deleter)\u003E(\n\u002B    static_cast\u003Crcl_wait_set_t *\u003E(PyMem_Malloc(sizeof(rcl_wait_set_t))),\n\u002B    deleter);\n\u002B  if (!wait_set) {\n\u002B    throw std::bad_alloc();\n\u002B  }\n\u002B\n\u002B  *wait_set = rcl_get_zero_initialized_wait_set();\n\u002B  return py::capsule(wait_set.release(), \u0022rcl_wait_set_t\u0022, _rclpy_destroy_wait_set);\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bwait_set_init(\n\u002B  py::capsule pywait_set,\n\u002B  size_t number_of_subscriptions,\n\u002B  size_t number_of_guard_conditions,\n\u002B  size_t number_of_timers,\n\u002B  size_t number_of_clients,\n\u002B  size_t number_of_services,\n\u002B  size_t number_of_events,\n\u002B  py::capsule pycontext)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  auto context = static_cast\u003Crcl_context_t *\u003E(\n\u002B    rclpy_handle_get_pointer_from_capsule(pycontext.ptr(), \u0022rcl_context_t\u0022));\n\u002B  if (!context) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  rcl_ret_t ret = rcl_wait_set_init(\n\u002B    wait_set,\n\u002B    number_of_subscriptions,\n\u002B    number_of_guard_conditions,\n\u002B    number_of_timers,\n\u002B    number_of_clients,\n\u002B    number_of_services,\n\u002B    number_of_events,\n\u002B    context,\n\u002B    rcl_get_default_allocator());\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    throw RCLError(\u0022failed to initialize wait set\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bwait_set_clear_entities(py::capsule pywait_set)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    throw RCLError(\u0022failed to clear wait set\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bsize_t\n\u002Bwait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py::capsule pyentity)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  rcl_ret_t ret = RCL_RET_ERROR;\n\u002B  size_t index;\n\u002B\n\u002B  if (\u0022subscription\u0022 == entity_type) {\n\u002B    auto sub = static_cast\u003Crclpy_subscription_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rclpy_subscription_t\u0022));\n\u002B    if (!sub) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_subscription(wait_set, \u0026(sub-\u003Esubscription), \u0026index);\n\u002B  } else if (\u0022client\u0022 == entity_type) {\n\u002B    auto client = static_cast\u003Crclpy_client_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rclpy_client_t\u0022));\n\u002B    if (!client) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_client(wait_set, \u0026(client-\u003Eclient), \u0026index);\n\u002B  } else if (\u0022service\u0022 == entity_type) {\n\u002B    auto srv = static_cast\u003Crclpy_service_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rclpy_service_t\u0022));\n\u002B    if (!srv) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_service(wait_set, \u0026(srv-\u003Eservice), \u0026index);\n\u002B  } else if (\u0022timer\u0022 == entity_type) {\n\u002B    auto timer = static_cast\u003Crcl_timer_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rcl_timer_t\u0022));\n\u002B    if (!timer) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_timer(wait_set, timer, \u0026index);\n\u002B  } else if (\u0022guard_condition\u0022 == entity_type) {\n\u002B    auto guard_condition = static_cast\u003Crcl_guard_condition_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rcl_guard_condition_t\u0022));\n\u002B    if (!guard_condition) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, \u0026index);\n\u002B  } else if (\u0022event\u0022 == entity_type) {\n\u002B    auto event = static_cast\u003Crcl_event_t *\u003E(\n\u002B      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \u0022rcl_event_t\u0022));\n\u002B    if (!event) {\n\u002B      throw py::error_already_set();\n\u002B    }\n\u002B    ret = rcl_wait_set_add_event(wait_set, event, \u0026index);\n\u002B  } else {\n\u002B    std::string error_text{\u0022\u0027\u0022};\n\u002B    error_text \u002B= entity_type;\n\u002B    error_text \u002B= \u0022\u0027 is not a known entity\u0022;\n\u002B    throw std::runtime_error(error_text);\n\u002B  }\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    std::string error_text{\u0022failed to add\u0027\u0022};\n\u002B    error_text \u002B= entity_type;\n\u002B    error_text \u002B= \u0022\u0027 to waitset\u0022;\n\u002B    throw RCLError(error_text);\n\u002B  }\n\u002B  return index;\n\u002B}\n\u002B\n\u002Bbool\n\u002Bwait_set_is_ready(const std::string \u0026 entity_type, py::capsule pywait_set, size_t index)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  const void ** entities = NULL;\n\u002B  size_t num_entities = 0;\n\u002B  if (\u0022subscription\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Esubscriptions);\n\u002B    num_entities = wait_set-\u003Esize_of_subscriptions;\n\u002B  } else if (\u0022client\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eclients);\n\u002B    num_entities = wait_set-\u003Esize_of_clients;\n\u002B  } else if (\u0022service\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eservices);\n\u002B    num_entities = wait_set-\u003Esize_of_services;\n\u002B  } else if (\u0022timer\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Etimers);\n\u002B    num_entities = wait_set-\u003Esize_of_timers;\n\u002B  } else if (\u0022guard_condition\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eguard_conditions);\n\u002B    num_entities = wait_set-\u003Esize_of_guard_conditions;\n\u002B  } else if (\u0022event\u0022 == entity_type) {\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eevents);\n\u002B    num_entities = wait_set-\u003Esize_of_events;\n\u002B  } else {\n\u002B    std::string error_text{\u0022\u0027\u0022};\n\u002B    error_text \u002B= entity_type;\n\u002B    error_text \u002B= \u0022\u0027 is not a known entity\u0022;\n\u002B    throw std::runtime_error(error_text);\n\u002B  }\n\u002B\n\u002B  if (!entities) {\n\u002B    std::string error_text{\u0022wait set \u0027\u0022};\n\u002B    error_text \u002B= entity_type;\n\u002B    error_text \u002B= \u0022\u0027 isn\u0027t allocated\u0022;\n\u002B    throw std::runtime_error(error_text);\n\u002B  }\n\u002B  if (index \u003E= num_entities) {\n\u002B    throw std::out_of_range(\u0022wait set index too big\u0022);\n\u002B  }\n\u002B  return nullptr != entities[index];\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename EntityArray\u003E\n\u002Bpy::list\n\u002B_get_ready_entities(const EntityArray ** entities, const size_t num_entities)\n\u002B{\n\u002B  py::list entity_list;\n\u002B  for (size_t i = 0; i \u003C num_entities; \u002B\u002Bi) {\n\u002B    auto address = reinterpret_cast\u003Csize_t\u003E(entities[i]);\n\u002B    if (address) {\n\u002B      entity_list.append(address);\n\u002B    }\n\u002B  }\n\u002B  return entity_list;\n\u002B}\n\u002B\n\u002Bpy::list\n\u002Bget_ready_entities(const std::string \u0026 entity_type, py::capsule pywait_set)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  if (\u0022subscription\u0022 == entity_type) {\n\u002B    return _get_ready_entities(wait_set-\u003Esubscriptions, wait_set-\u003Esize_of_subscriptions);\n\u002B  } else if (\u0022client\u0022 == entity_type) {\n\u002B    return _get_ready_entities(wait_set-\u003Eclients, wait_set-\u003Esize_of_clients);\n\u002B  } else if (\u0022service\u0022 == entity_type) {\n\u002B    return _get_ready_entities(wait_set-\u003Eservices, wait_set-\u003Esize_of_services);\n\u002B  } else if (\u0022timer\u0022 == entity_type) {\n\u002B    return _get_ready_entities(wait_set-\u003Etimers, wait_set-\u003Esize_of_timers);\n\u002B  } else if (\u0022guard_condition\u0022 == entity_type) {\n\u002B    return _get_ready_entities(wait_set-\u003Eguard_conditions, wait_set-\u003Esize_of_guard_conditions);\n\u002B  }\n\u002B\n\u002B  std::string error_text{\u0022\u0027\u0022};\n\u002B  error_text \u002B= entity_type;\n\u002B  error_text \u002B= \u0022\u0027 is not a known entity\u0022;\n\u002B  throw std::runtime_error(error_text);\n\u002B}\n\u002B\n\u002Bvoid\n\u002Bwait(py::capsule pywait_set, int64_t timeout)\n\u002B{\n\u002B  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n\u002B    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n\u002B  }\n\u002B  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B\n\u002B  rcl_ret_t ret;\n\u002B\n\u002B  // Could be a long wait, release the GIL\n\u002B  {\n\u002B    py::gil_scoped_release gil_release;\n\u002B    ret = rcl_wait(wait_set, timeout);\n\u002B  }\n\u002B\n\u002B  if (ret != RCL_RET_OK \u0026\u0026 ret != RCL_RET_TIMEOUT) {\n\u002B    throw RCLError(\u0022failed to wait on wait set\u0022);\n\u002B  }\n\u002B}\n\u002B}  // namespace rclpy\ndiff --git rclpy/src/rclpy/wait_set.hpp rclpy/src/rclpy/wait_set.hpp\nnew file mode 100644\nindex 0000000..eae3f22\n--- /dev/null\n\u002B\u002B\u002B rclpy/src/rclpy/wait_set.hpp\n@@ -0,0 \u002B1,116 @@\n\u002B// Copyright 2021 Open Source Robotics Foundation, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLPY__WAIT_SET_HPP_\n\u002B#define RCLPY__WAIT_SET_HPP_\n\u002B\n\u002B#include \u003Cpybind11/pybind11.h\u003E\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002Bnamespace py = pybind11;\n\u002B\n\u002Bnamespace rclpy\n\u002B{\n\u002B/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n\u002Bpy::capsule\n\u002Bget_zero_initialized_wait_set();\n\u002B\n\u002B/// Initialize a wait set\n\u002B/**\n\u002B * Raises RCLError if the wait set could not be initialized\n\u002B *\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B * \\param[in] node_name string name of the node to be created\n\u002B * \\param[in] number_of_subscriptions int\n\u002B * \\param[in] number_of_guard_conditions int\n\u002B * \\param[in] number_of_timers int\n\u002B * \\param[in] number_of_clients int\n\u002B * \\param[in] number_of_services int\n\u002B * \\param[in] pycontext Capsule pointing to an rcl_context_t\n\u002B */\n\u002Bvoid\n\u002Bwait_set_init(\n\u002B  py::capsule pywait_set,\n\u002B  size_t number_of_subscriptions,\n\u002B  size_t number_of_guard_conditions,\n\u002B  size_t number_of_timers,\n\u002B  size_t number_of_clients,\n\u002B  size_t number_of_services,\n\u002B  size_t number_of_events,\n\u002B  py::capsule pycontext);\n\u002B\n\u002B/// Clear all the pointers in the wait set\n\u002B/**\n\u002B * Raises RCLError if any rcl error occurs\n\u002B *\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B */\n\u002Bvoid\n\u002Bwait_set_clear_entities(py::capsule pywait_set);\n\u002B\n\u002B/// Add an entity to the wait set structure\n\u002B/**\n\u002B * Raises RuntimeError if the entity type is unknown\n\u002B * Raises RCLError if any lower level error occurs\n\u002B *\n\u002B * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B * \\param[in] pyentity Capsule pointing to the entity to add\n\u002B * \\return Index in waitset entity was added at\n\u002B */\n\u002Bsize_t\n\u002Bwait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py::capsule pyentity);\n\u002B\n\u002B/// Check if an entity in the wait set is ready by its index\n\u002B/**\n\u002B * This must be called after waiting on the wait set.\n\u002B * Raises RuntimeError if the entity type is unknown\n\u002B * Raises IndexError if the given index is beyond the number of entities in the set\n\u002B *\n\u002B * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B * \\param[in] index location in the wait set of the entity to check\n\u002B * \\return True if the entity at the index in the wait set is not NULL\n\u002B */\n\u002Bbool\n\u002Bwait_set_is_ready(const std::string \u0026 entity_type, py::capsule pywait_set, size_t index);\n\u002B\n\u002B/// Get list of non-null entities in wait set\n\u002B/**\n\u002B * Raises ValueError if pywait_set is not a wait set capsule\n\u002B * Raises RuntimeError if the entity type is not known\n\u002B *\n\u002B * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B * \\return List of wait set entities pointers ready for take\n\u002B */\n\u002Bpy::list\n\u002Bget_ready_entities(const std::string \u0026 entity_type, py::capsule pywait_set);\n\u002B\n\u002B/// Wait until timeout is reached or event happened\n\u002B/**\n\u002B * Raises ValueError if pywait_set is not a wait set capsule\n\u002B * Raises RCLError if there was an error while waiting\n\u002B *\n\u002B * This function will wait for an event to happen or for the timeout to expire.\n\u002B * A negative timeout means wait forever, a timeout of 0 means no wait\n\u002B * \\param[in] pywait_set Capsule pointing to the wait set structure\n\u002B * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n\u002B */\n\u002Bvoid\n\u002Bwait(py::capsule pywait_set, int64_t timeout);\n\u002B}  // namespace rclpy\n\u002B\n\u002B#endif  // RCLPY__WAIT_SET_HPP_\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "83ac5b0c38c65b05a80f74f4a8a11665f3506735",
    "RawMessage": "introduce ROS_DISABLE_LOAN_MSG to disable can_loan_messages. (#949)",
    "Changes": "diff --git rcl/include/rcl/node.h rcl/include/rcl/node.h\nindex fafaa04..b9b8643 100644\n--- rcl/include/rcl/node.h\n\u002B\u002B\u002B rcl/include/rcl/node.h\n@@ -33,6 \u002B33,8 @@ extern \u0022C\u0022\n #include \u0022rcl/types.h\u0022\n #include \u0022rcl/visibility_control.h\u0022\n \n\u002Bextern const char * const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR;\n\u002B\n typedef struct rcl_node_impl_s rcl_node_impl_t;\n \n /// Structure which encapsulates a ROS Node.\n@@ -533,6 \u002B535,20 @@ rcl_node_resolve_name(\n   bool only_expand,\n   char ** output_name);\n \n\u002B/// Check if loaned message is disabled, according to the environment variable.\n\u002B/**\n\u002B * If the \u0060ROS_DISABLE_LOANED_MESSAGES\u0060 environment variable is set to \u00221\u0022,\n\u002B * \u0060disable_loaned_message\u0060 will be set to true.\n\u002B *\n\u002B * \\param[out] disable_loaned_message Must not be NULL.\n\u002B * \\return #RCL_RET_INVALID_ARGUMENT if an argument is not valid, or\n\u002B * \\return #RCL_RET_ERROR if an unexpected error happened, or\n\u002B * \\return #RCL_RET_OK.\n\u002B */\n\u002BRCL_PUBLIC\n\u002Brcl_ret_t\n\u002Brcl_get_disable_loaned_message(bool * disable_loaned_message);\n\u002B\n #ifdef __cplusplus\n }\n #endif\ndiff --git rcl/src/rcl/node.c rcl/src/rcl/node.c\nindex a0aa51d..4afc40f 100644\n--- rcl/src/rcl/node.c\n\u002B\u002B\u002B rcl/src/rcl/node.c\n@@ -34,6 \u002B34,7 @@ extern \u0022C\u0022\n #include \u0022rcl/remap.h\u0022\n #include \u0022rcl/security.h\u0022\n \n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/filesystem.h\u0022\n #include \u0022rcutils/find.h\u0022\n #include \u0022rcutils/format_string.h\u0022\n@@ -52,6 \u002B53,8 @@ extern \u0022C\u0022\n \n #include \u0022./context_impl.h\u0022\n \n\u002Bconst char * const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR = \u0022ROS_DISABLE_LOANED_MESSAGES\u0022;\n\u002B\n struct rcl_node_impl_s\n {\n   rcl_node_options_t options;\n@@ -514,6 \u002B517,25 @@ rcl_node_get_logger_name(const rcl_node_t * node)\n   return node-\u003Eimpl-\u003Elogger_name;\n }\n \n\u002Brcl_ret_t\n\u002Brcl_get_disable_loaned_message(bool * disable_loaned_message)\n\u002B{\n\u002B  const char * env_val = NULL;\n\u002B  const char * env_error_str = NULL;\n\u002B\n\u002B  RCL_CHECK_ARGUMENT_FOR_NULL(disable_loaned_message, RCL_RET_INVALID_ARGUMENT);\n\u002B\n\u002B  env_error_str = rcutils_get_env(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR, \u0026env_val);\n\u002B  if (NULL != env_error_str) {\n\u002B    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n\u002B      \u0022Error getting env var: \u0027\u0022 RCUTILS_STRINGIFY(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR) \u0022\u0027: %s\\n\u0022,\n\u002B      env_error_str);\n\u002B    return RCL_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  *disable_loaned_message = (strcmp(env_val, \u00221\u0022) == 0);\n\u002B  return RCL_RET_OK;\n\u002B}\n #ifdef __cplusplus\n }\n #endif\ndiff --git rcl/src/rcl/publisher.c rcl/src/rcl/publisher.c\nindex a3a9747..47582da 100644\n--- rcl/src/rcl/publisher.c\n\u002B\u002B\u002B rcl/src/rcl/publisher.c\n@@ -440,6 \u002B440,13 @@ rcl_publisher_can_loan_messages(const rcl_publisher_t * publisher)\n   if (!rcl_publisher_is_valid(publisher)) {\n     return false;  // error message already set\n   }\n\u002B\n\u002B  bool disable_loaned_message = false;\n\u002B  rcl_ret_t ret = rcl_get_disable_loaned_message(\u0026disable_loaned_message);\n\u002B  if (ret == RCL_RET_OK \u0026\u0026 disable_loaned_message) {\n\u002B    return false;\n\u002B  }\n\u002B\n   return publisher-\u003Eimpl-\u003Ermw_handle-\u003Ecan_loan_messages;\n }\n \ndiff --git rcl/src/rcl/subscription.c rcl/src/rcl/subscription.c\nindex fcea1e7..d92fe21 100644\n--- rcl/src/rcl/subscription.c\n\u002B\u002B\u002B rcl/src/rcl/subscription.c\n@@ -435,6 \u002B435,13 @@ rcl_subscription_can_loan_messages(const rcl_subscription_t * subscription)\n   if (!rcl_subscription_is_valid(subscription)) {\n     return false;  // error message already set\n   }\n\u002B\n\u002B  bool disable_loaned_message = false;\n\u002B  rcl_ret_t ret = rcl_get_disable_loaned_message(\u0026disable_loaned_message);\n\u002B  if (ret == RCL_RET_OK \u0026\u0026 disable_loaned_message) {\n\u002B    return false;\n\u002B  }\n\u002B\n   return subscription-\u003Eimpl-\u003Ermw_handle-\u003Ecan_loan_messages;\n }\n \ndiff --git rcl/test/rcl/test_node.cpp rcl/test/rcl/test_node.cpp\nindex c215761..716fb5f 100644\n--- rcl/test/rcl/test_node.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_node.cpp\n@@ -27,6 \u002B27,7 @@\n #include \u0022./failing_allocator_functions.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/memory_tools/memory_tools.hpp\u0022\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rcutils/testing/fault_injection.h\u0022\n #include \u0022rcl/error_handling.h\u0022\n #include \u0022rcl/logging.h\u0022\n@@ -997,3 \u002B998,48 @@ TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_node_resolve_nam\n   EXPECT_STREQ(\u0022/ns/relative_ns/foo\u0022, final_name);\n   default_allocator.deallocate(final_name, default_allocator.state);\n }\n\u002B\n\u002B/* Tests special case node_options\n\u002B */\n\u002BTEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_get_disable_loaned_message) {\n\u002B  {\n\u002B    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_get_disable_loaned_message(nullptr));\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    bool disable_loaned_message = false;\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rcl\u0022, rcutils_get_env, \u0022internal error\u0022);\n\u002B    EXPECT_EQ(RCL_RET_ERROR, rcl_get_disable_loaned_message(\u0026disable_loaned_message));\n\u002B    rcl_reset_error();\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00220\u0022));\n\u002B    bool disable_loaned_message = true;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(\u0026disable_loaned_message));\n\u002B    EXPECT_FALSE(disable_loaned_message);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00221\u0022));\n\u002B    bool disable_loaned_message = false;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(\u0026disable_loaned_message));\n\u002B    EXPECT_TRUE(disable_loaned_message);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00222\u0022));\n\u002B    bool disable_loaned_message = true;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(\u0026disable_loaned_message));\n\u002B    EXPECT_FALSE(disable_loaned_message);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u002211\u0022));\n\u002B    bool disable_loaned_message = true;\n\u002B    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(\u0026disable_loaned_message));\n\u002B    EXPECT_FALSE(disable_loaned_message);\n\u002B  }\n\u002B}\ndiff --git rcl/test/rcl/test_publisher.cpp rcl/test/rcl/test_publisher.cpp\nindex 9c853cc..c77e784 100644\n--- rcl/test/rcl/test_publisher.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_publisher.cpp\n@@ -24,6 \u002B24,8 @@\n #include \u0022mimick/mimick.h\u0022\n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n #include \u0022rcl/error_handling.h\u0022\n\u002B#include \u0022rcl/node.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022rmw/validate_full_topic_name.h\u0022\n #include \u0022rmw/validate_node_name.h\u0022\n \n@@ -370,6 \u002B372,42 @@ TEST_F(CLASSNAME(TestPublisherFixture, RMW_IMPLEMENTATION), test_publisher_loan)\n   }\n }\n \n\u002BTEST_F(CLASSNAME(TestPublisherFixture, RMW_IMPLEMENTATION), test_publisher_loan_disable) {\n\u002B  rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n\u002B  const rosidl_message_type_support_t * ts =\n\u002B    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n\u002B  constexpr char topic_name[] = \u0022pod_msg\u0022;\n\u002B  rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n\u002B  rcl_ret_t ret =\n\u002B    rcl_publisher_init(\u0026publisher, this-\u003Enode_ptr, ts, topic_name, \u0026publisher_options);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    rcl_ret_t ret = rcl_publisher_fini(\u0026publisher, this-\u003Enode_ptr);\n\u002B    EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  if (rcl_publisher_can_loan_messages(\u0026publisher)) {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00220\u0022));\n\u002B    EXPECT_TRUE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00221\u0022));\n\u002B    EXPECT_FALSE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00222\u0022));\n\u002B    EXPECT_TRUE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u0022Unexpected\u0022));\n\u002B    EXPECT_TRUE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B  } else {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00220\u0022));\n\u002B    EXPECT_FALSE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00221\u0022));\n\u002B    EXPECT_FALSE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00222\u0022));\n\u002B    EXPECT_FALSE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u0022Unexpected\u0022));\n\u002B    EXPECT_FALSE(rcl_publisher_can_loan_messages(\u0026publisher));\n\u002B  }\n\u002B}\n\u002B\n TEST_F(CLASSNAME(TestPublisherFixture, RMW_IMPLEMENTATION), test_invalid_publisher) {\n   rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n   const rosidl_message_type_support_t * ts =\ndiff --git rcl/test/rcl/test_subscription.cpp rcl/test/rcl/test_subscription.cpp\nindex adedd7b..6a6aa81 100644\n--- rcl/test/rcl/test_subscription.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_subscription.cpp\n@@ -30,6 \u002B30,8 @@\n \n #include \u0022osrf_testing_tools_cpp/scope_exit.hpp\u0022\n #include \u0022rcl/error_handling.h\u0022\n\u002B#include \u0022rcl/node.h\u0022\n\u002B#include \u0022rcutils/env.h\u0022\n #include \u0022wait_for_entity_helpers.hpp\u0022\n \n #include \u0022./allocator_testing_utils.h\u0022\n@@ -712,6 \u002B714,42 @@ TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription\n   }\n }\n \n\u002BTEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription_loan_disable) {\n\u002B  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n\u002B  const rosidl_message_type_support_t * ts =\n\u002B    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n\u002B  constexpr char topic[] = \u0022pod_msg\u0022;\n\u002B  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n\u002B  rcl_ret_t ret =\n\u002B    rcl_subscription_init(\u0026subscription, this-\u003Enode_ptr, ts, topic, \u0026subscription_options);\n\u002B  ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n\u002B  {\n\u002B    rcl_ret_t ret = rcl_subscription_fini(\u0026subscription, this-\u003Enode_ptr);\n\u002B    EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n\u002B  });\n\u002B\n\u002B  if (rcl_subscription_can_loan_messages(\u0026subscription)) {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00220\u0022));\n\u002B    EXPECT_TRUE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00221\u0022));\n\u002B    EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00222\u0022));\n\u002B    EXPECT_TRUE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u0022Unexpected\u0022));\n\u002B    EXPECT_TRUE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B  } else {\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00220\u0022));\n\u002B    EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00221\u0022));\n\u002B    EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u00222\u0022));\n\u002B    EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B    ASSERT_TRUE(rcutils_set_env(\u0022ROS_DISABLE_LOANED_MESSAGES\u0022, \u0022Unexpected\u0022));\n\u002B    EXPECT_FALSE(rcl_subscription_can_loan_messages(\u0026subscription));\n\u002B  }\n\u002B}\n\u002B\n /* Test for all failure modes in subscription take with loaned messages function.\n  */\n TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_bad_take_loaned_message) {\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "b7f56c074926a0fbfbf397131498538aad65e411",
    "RawMessage": "Fix type signature of Client.wait_for_service (#1128)",
    "Changes": "diff --git rclpy/rclpy/client.py rclpy/rclpy/client.py\nindex d46256b..05f1318 100644\n--- rclpy/rclpy/client.py\n\u002B\u002B\u002B rclpy/rclpy/client.py\n@@ -15,6 \u002B15,7 @@\n import threading\n import time\n from typing import Dict\n\u002Bfrom typing import Optional\n from typing import TypeVar\n \n from rclpy.callback_groups import CallbackGroup\n@@ -161,7 \u002B162,7 @@ class Client:\n         with self.handle:\n             return self.__client.service_server_is_available()\n \n-    def wait_for_service(self, timeout_sec: float = None) -\u003E bool:\n\u002B    def wait_for_service(self, timeout_sec: Optional[float] = None) -\u003E bool:\n         \u0022\u0022\u0022\n         Wait for a service server to become ready.\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "643de6d741e125f7f4c8a5851977b08d1813b4e7",
    "RawMessage": "Mark benchmark _ as unused. (#71)",
    "Changes": "diff --git rmw_dds_common/test/benchmark/benchmark_graph_cache.cpp rmw_dds_common/test/benchmark/benchmark_graph_cache.cpp\nindex df02824..349bb7a 100644\n--- rmw_dds_common/test/benchmark/benchmark_graph_cache.cpp\n\u002B\u002B\u002B rmw_dds_common/test/benchmark/benchmark_graph_cache.cpp\n@@ -17,6 \u002B17,8 @@\n \n #include \u0022performance_test_fixture/performance_test_fixture.hpp\u0022\n \n\u002B#include \u0022rcutils/macros.h\u0022\n\u002B\n #include \u0022rmw/qos_profiles.h\u0022\n \n #include \u0022rmw_dds_common/gid_utils.hpp\u0022\n@@ -235,6 \u002B237,7 @@ BENCHMARK_F(PerformanceTest, add_remove_participant_benchmark)(benchmark::State\n   GraphCache graph_cache;\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     add_participants(graph_cache, {\u0022participant1\u0022});\n     remove_participants(graph_cache, {\u0022participant1\u0022});\n   }\n@@ -247,6 \u002B250,7 @@ BENCHMARK_F(PerformanceTest, add_remove_participant_and_node_benchmark)(benchmar\n   reset_heap_counters();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     add_participants(graph_cache, {\u0022participant1\u0022});\n     add_nodes(graph_cache, {{\u0022participant1\u0022, \u0022ns1\u0022, \u0022node\u0022}});\n     remove_nodes(graph_cache, {{\u0022participant1\u0022, \u0022ns1\u0022, \u0022node\u0022}});\n@@ -260,6 \u002B264,7 @@ BENCHMARK_F(TestGraphCache, get_writers_info_by_topic_benchmark)(benchmark::Stat\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_ret_t ret = graph_cache.get_writers_info_by_topic(\n       \u0022topic1\u0022,\n       identity_demangle,\n@@ -281,6 \u002B286,7 @@ BENCHMARK_F(TestGraphCache, get_readers_info_by_topic_benchmark)(benchmark::Stat\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_ret_t ret = graph_cache.get_readers_info_by_topic(\n       \u0022topic1\u0022,\n       identity_demangle,\n@@ -301,6 \u002B307,7 @@ BENCHMARK_F(TestGraphCache, get_names_and_types_benchmark)(benchmark::State \u0026 st\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_names_and_types_t names_and_types = rmw_get_zero_initialized_names_and_types();\n     rmw_ret_t ret = graph_cache.get_names_and_types(\n       identity_demangle,\n@@ -322,6 \u002B329,7 @@ BENCHMARK_F(TestGraphCache, get_reader_names_and_types_by_node)(benchmark::State\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_names_and_types_t names_and_types = rmw_get_zero_initialized_names_and_types();\n     rmw_ret_t ret = graph_cache.get_reader_names_and_types_by_node(\n       \u0022node1\u0022,\n@@ -345,6 \u002B353,7 @@ BENCHMARK_F(TestGraphCache, get_writer_names_and_types_by_node)(benchmark::State\n   rcutils_allocator_t allocator = rcutils_get_default_allocator();\n \n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_names_and_types_t names_and_types = rmw_get_zero_initialized_names_and_types();\n     rmw_ret_t ret = graph_cache.get_writer_names_and_types_by_node(\n       \u0022node1\u0022,\n@@ -367,6 \u002B376,7 @@ BENCHMARK_F(TestGraphCache, get_reader_count_benchmark)(benchmark::State \u0026 st)\n {\n   size_t count;\n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_ret_t ret = graph_cache.get_reader_count(\u0022reader1\u0022, \u0026count);\n     if (ret != RMW_RET_OK) {\n       st.SkipWithError(\u0022get_reader_count failed\u0022);\n@@ -378,6 \u002B388,7 @@ BENCHMARK_F(TestGraphCache, get_writer_count_benchmark)(benchmark::State \u0026 st)\n {\n   size_t count;\n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     rmw_ret_t ret = graph_cache.get_writer_count(\u0022writer1\u0022, \u0026count);\n     if (ret != RMW_RET_OK) {\n       st.SkipWithError(\u0022get_reader_count failed\u0022);\n@@ -388,6 \u002B399,7 @@ BENCHMARK_F(TestGraphCache, get_writer_count_benchmark)(benchmark::State \u0026 st)\n BENCHMARK_F(TestGraphCache, associate_entities_benchmark)(benchmark::State \u0026 st)\n {\n   for (auto _ : st) {\n\u002B    RCUTILS_UNUSED(_);\n     // Associate entities\n     associate_entities(\n       graph_cache,\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "b007204fd83828c11f80bf4712d237bfb2431f6e",
    "RawMessage": "Rule of five: implement move operators (#2425)",
    "Changes": "diff --git rclcpp/include/rclcpp/time.hpp rclcpp/include/rclcpp/time.hpp\nindex 15e063d1..a931f3ac 100644\n--- rclcpp/include/rclcpp/time.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/time.hpp\n@@ -57,6 \u002B57,10 @@ public:\n   RCLCPP_PUBLIC\n   Time(const Time \u0026 rhs);\n \n\u002B  /// Move constructor\n\u002B  RCLCPP_PUBLIC\n\u002B  Time(Time \u0026\u0026 rhs) noexcept;\n\u002B\n   /// Time constructor\n   /**\n    * \\param time_msg builtin_interfaces time message to copy\n@@ -84,6 \u002B88,7 @@ public:\n   operator builtin_interfaces::msg::Time() const;\n \n   /**\n\u002B   * Copy assignment operator\n    * \\throws std::runtime_error if seconds are negative\n    */\n   RCLCPP_PUBLIC\n@@ -100,6 \u002B105,13 @@ public:\n   Time \u0026\n   operator=(const builtin_interfaces::msg::Time \u0026 time_msg);\n \n\u002B  /**\n\u002B   * Move assignment operator\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  Time \u0026\n\u002B  operator=(Time \u0026\u0026 rhs) noexcept;\n\u002B\n   /**\n    * \\throws std::runtime_error if the time sources are different\n    */\ndiff --git rclcpp/src/rclcpp/time.cpp rclcpp/src/rclcpp/time.cpp\nindex a0be1413..97865151 100644\n--- rclcpp/src/rclcpp/time.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time.cpp\n@@ -65,6 \u002B65,8 @@ Time::Time(int64_t nanoseconds, rcl_clock_type_t clock_type)\n \n Time::Time(const Time \u0026 rhs) = default;\n \n\u002BTime::Time(Time \u0026\u0026 rhs) noexcept = default;\n\u002B\n Time::Time(\n   const builtin_interfaces::msg::Time \u0026 time_msg,\n   rcl_clock_type_t clock_type)\n@@ -84,9 \u002B86,7 @@ Time::Time(const rcl_time_point_t \u0026 time_point)\n   // noop\n }\n \n-Time::~Time()\n-{\n-}\n\u002BTime::~Time() = default;\n \n Time::operator builtin_interfaces::msg::Time() const\n {\n@@ -103,6 \u002B103,9 @@ Time::operator=(const builtin_interfaces::msg::Time \u0026 time_msg)\n   return *this;\n }\n \n\u002BTime \u0026\n\u002BTime::operator=(Time \u0026\u0026 rhs) noexcept = default;\n\u002B\n bool\n Time::operator==(const rclcpp::Time \u0026 rhs) const\n {\n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "7b1ae94142adbc0b9f26c5c2eed4163da384ab0e",
    "RawMessage": "Add pytest.ini so local tests don\u0027t display warning (#276)",
    "Changes": "diff --git examples_tf2_py/pytest.ini examples_tf2_py/pytest.ini\nnew file mode 100644\nindex 00000000..fe55d2ed\n--- /dev/null\n\u002B\u002B\u002B examples_tf2_py/pytest.ini\n@@ -0,0 \u002B1,2 @@\n\u002B[pytest]\n\u002Bjunit_family=xunit2\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "95552e4dde407ccfbc20cdc6349f55f77d61f1e6",
    "RawMessage": "fixed MovableText::getWorldTransforms transform (#1118)",
    "Changes": "diff --git rviz_rendering/src/rviz_rendering/objects/movable_text.cpp rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\nindex 23e99d44..f6a0eaed 100644\n--- rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/objects/movable_text.cpp\n@@ -517,8 \u002B517,7 @@ void MovableText::getWorldTransforms(Ogre::Matrix4 * xform) const\n \n     mCamera-\u003EgetDerivedOrientation().ToRotationMatrix(rot3x3);\n \n-    Ogre::Vector3 parent_position = mParentNode-\u003E_getDerivedPosition() \u002B\n-      Ogre::Vector3::UNIT_Y * global_translation_;\n\u002B    Ogre::Vector3 parent_position = mParentNode-\u003E_getDerivedPosition() \u002B global_translation_;\n     parent_position \u002B= rot3x3 * local_translation_;\n \n     scale3x3[0][0] = mParentNode-\u003E_getDerivedScale().x / 2;\n",
    "IsBackported": false
  },
  {
    "Repository": "launch_ros",
    "SHA": "58564825f62730926f3609be5001e7a1cd145a23",
    "RawMessage": "Switch to use rclpy.init context manager. (#402)",
    "Changes": "diff --git launch_testing_ros/test/examples/listener.py launch_testing_ros/test/examples/listener.py\nindex 8605c1c..0bff1ed 100644\n--- launch_testing_ros/test/examples/listener.py\n\u002B\u002B\u002B launch_testing_ros/test/examples/listener.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n \n from std_msgs.msg import String\n@@ -31,16 \u002B32,12 @@ class Listener(Node):\n \n \n def main(args=None):\n-    rclpy.init(args=args)\n-\n-    node = Listener()\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init(args=args):\n\u002B            node = Listener()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()\n \n \n if __name__ == \u0027__main__\u0027:\ndiff --git launch_testing_ros/test/examples/parameter_blackboard.py launch_testing_ros/test/examples/parameter_blackboard.py\nindex e3354c7..0856334 100644\n--- launch_testing_ros/test/examples/parameter_blackboard.py\n\u002B\u002B\u002B launch_testing_ros/test/examples/parameter_blackboard.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n \n \n@@ -24,17 \u002B25,12 @@ class TestNode(Node):\n \n \n def main(args=None):\n-    rclpy.init(args=args)\n-\n-    node = TestNode()\n-\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init(args=args):\n\u002B            node = TestNode()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()\n \n \n if __name__ == \u0027__main__\u0027:\ndiff --git launch_testing_ros/test/examples/talker.py launch_testing_ros/test/examples/talker.py\nindex fc9f27f..a914672 100644\n--- launch_testing_ros/test/examples/talker.py\n\u002B\u002B\u002B launch_testing_ros/test/examples/talker.py\n@@ -13,6 \u002B13,7 @@\n # limitations under the License.\n \n import rclpy\n\u002Bfrom rclpy.executors import ExternalShutdownException\n from rclpy.node import Node\n \n from std_msgs.msg import String\n@@ -35,17 \u002B36,12 @@ class Talker(Node):\n \n \n def main(args=None):\n-    rclpy.init(args=args)\n-\n-    node = Talker()\n-\n     try:\n-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n\u002B        with rclpy.init(args=args):\n\u002B            node = Talker()\n\u002B            rclpy.spin(node)\n\u002B    except (KeyboardInterrupt, ExternalShutdownException):\n         pass\n-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()\n \n \n if __name__ == \u0027__main__\u0027:\ndiff --git test_launch_ros/test/test_launch_ros/actions/test_ros_timer.py test_launch_ros/test/test_launch_ros/actions/test_ros_timer.py\nindex b1f6dc9..7f1c37e 100644\n--- test_launch_ros/test/test_launch_ros/actions/test_ros_timer.py\n\u002B\u002B\u002B test_launch_ros/test/test_launch_ros/actions/test_ros_timer.py\n@@ -151,10 \u002B151,9 @@ def test_shutdown_preempts_timers():\n \n @pytest.fixture\n def rclpy_node():\n-    rclpy.init()\n-    node = rclpy.create_node(\u0027test_ros_timer_action_node\u0027)\n-    yield node\n-    rclpy.shutdown()\n\u002B    with rclpy.init():\n\u002B        node = rclpy.create_node(\u0027test_ros_timer_action_node\u0027)\n\u002B        yield node\n \n \n def test_timer_uses_sim_time(rclpy_node):\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "77c4fb3f2f035d09181d1faa4ce612a5190d1ba7",
    "RawMessage": "Convert WaitSet to use C\u002B\u002B Classes (#769)",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex c721428..9595924 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -507,7 \u002B507,7 @@ class Executor:\n                 len(subscriptions), len(guards), len(timers), len(clients), len(services))\n \n             # Construct a wait set\n-            wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n\u002B            wait_set = None\n             with ExitStack() as context_stack:\n                 sub_handles = []\n                 for sub in subscriptions:\n@@ -556,8 \u002B556,7 @@ class Executor:\n                         pass\n \n                 context_capsule = context_stack.enter_context(self._context.handle)\n-                _rclpy.rclpy_wait_set_init(\n-                    wait_set,\n\u002B                wait_set = _rclpy.WaitSet(\n                     entity_count.num_subscriptions,\n                     entity_count.num_guard_conditions,\n                     entity_count.num_timers,\n@@ -566,33 \u002B565,33 @@ class Executor:\n                     entity_count.num_events,\n                     context_capsule)\n \n-                _rclpy.rclpy_wait_set_clear_entities(wait_set)\n\u002B                wait_set.clear_entities()\n                 for sub_handle in sub_handles:\n-                    _rclpy.rclpy_wait_set_add_subscription(wait_set, sub_handle)\n\u002B                    wait_set.add_subscription(sub_handle)\n                 for cli_handle in client_handles:\n-                    _rclpy.rclpy_wait_set_add_client(wait_set, cli_handle)\n\u002B                    wait_set.add_client(cli_handle)\n                 for srv_capsule in service_handles:\n-                    _rclpy.rclpy_wait_set_add_service(wait_set, srv_capsule)\n\u002B                    wait_set.add_service(srv_capsule)\n                 for tmr_handle in timer_handles:\n-                    _rclpy.rclpy_wait_set_add_timer(wait_set, tmr_handle)\n\u002B                    wait_set.add_timer(tmr_handle)\n                 for gc_capsule in guard_capsules:\n-                    _rclpy.rclpy_wait_set_add_entity(\u0027guard_condition\u0027, wait_set, gc_capsule)\n\u002B                    wait_set.add_entity(\u0027guard_condition\u0027, gc_capsule)\n                 for waitable in waitables:\n                     waitable.add_to_wait_set(wait_set)\n \n                 # Wait for something to become ready\n-                _rclpy.rclpy_wait(wait_set, timeout_nsec)\n\u002B                wait_set.wait(timeout_nsec)\n                 if self._is_shutdown:\n                     raise ShutdownException()\n                 if not self._context.ok():\n                     raise ExternalShutdownException()\n \n                 # get ready entities\n-                subs_ready = _rclpy.rclpy_get_ready_entities(\u0027subscription\u0027, wait_set)\n-                guards_ready = _rclpy.rclpy_get_ready_entities(\u0027guard_condition\u0027, wait_set)\n-                timers_ready = _rclpy.rclpy_get_ready_entities(\u0027timer\u0027, wait_set)\n-                clients_ready = _rclpy.rclpy_get_ready_entities(\u0027client\u0027, wait_set)\n-                services_ready = _rclpy.rclpy_get_ready_entities(\u0027service\u0027, wait_set)\n\u002B                subs_ready = wait_set.get_ready_entities(\u0027subscription\u0027)\n\u002B                guards_ready = wait_set.get_ready_entities(\u0027guard_condition\u0027)\n\u002B                timers_ready = wait_set.get_ready_entities(\u0027timer\u0027)\n\u002B                clients_ready = wait_set.get_ready_entities(\u0027client\u0027)\n\u002B                services_ready = wait_set.get_ready_entities(\u0027service\u0027)\n \n                 # Mark all guards as triggered before yielding since they\u0027re auto-taken\n                 for gc in guards:\ndiff --git rclpy/rclpy/qos_event.py rclpy/rclpy/qos_event.py\nindex a7b878c..4969816 100644\n--- rclpy/rclpy/qos_event.py\n\u002B\u002B\u002B rclpy/rclpy/qos_event.py\n@@ -87,7 \u002B87,7 @@ class QoSEventHandler(Waitable):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n         if self._event_index is None:\n             return False\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027event\u0027, wait_set, self._event_index):\n\u002B        if wait_set.is_ready(\u0027event\u0027, self._event_index):\n             self._ready_to_take_data = True\n         return self._ready_to_take_data\n \n@@ -112,7 \u002B112,7 @@ class QoSEventHandler(Waitable):\n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entites to wait set.\u0022\u0022\u0022\n         with self.__event:\n-            self._event_index = _rclpy.rclpy_wait_set_add_event(wait_set, self.__event)\n\u002B            self._event_index = wait_set.add_event(self.__event)\n \n     def __enter__(self):\n         \u0022\u0022\u0022Mark event as in-use to prevent destruction while waiting on it.\u0022\u0022\u0022\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex 478fe44..1f0ad40 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -151,43 \u002B151,7 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n   rclpy::define_subscription(m);\n   rclpy::define_time_point(m);\n   rclpy::define_clock(m);\n-\n-  m.def(\n-    \u0022rclpy_get_zero_initialized_wait_set\u0022, \u0026rclpy::get_zero_initialized_wait_set,\n-    \u0022rclpy_get_zero_initialized_wait_set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_init\u0022, \u0026rclpy::wait_set_init,\n-    \u0022rclpy_wait_set_init.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_clear_entities\u0022, \u0026rclpy::wait_set_clear_entities,\n-    \u0022rclpy_wait_set_clear_entities.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_entity\u0022, \u0026rclpy::wait_set_add_entity,\n-    \u0022rclpy_wait_set_add_entity.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_client\u0022, \u0026rclpy::wait_set_add_client,\n-    \u0022Add a client to the wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_service\u0022, \u0026rclpy::wait_set_add_service,\n-    \u0022Add a service to the wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_subscription\u0022, \u0026rclpy::wait_set_add_subscription,\n-    \u0022Add a subscription to the wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_timer\u0022, \u0026rclpy::wait_set_add_timer,\n-    \u0022Add a timer to the wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_add_event\u0022, \u0026rclpy::wait_set_add_event,\n-    \u0022Add an event to the wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait_set_is_ready\u0022, \u0026rclpy::wait_set_is_ready,\n-    \u0022rclpy_wait_set_is_ready.\u0022);\n-  m.def(\n-    \u0022rclpy_get_ready_entities\u0022, \u0026rclpy::get_ready_entities,\n-    \u0022List non null entities in wait set.\u0022);\n-  m.def(\n-    \u0022rclpy_wait\u0022, \u0026rclpy::wait,\n-    \u0022rclpy_wait.\u0022);\n\u002B  rclpy::define_waitset(m);\n \n   m.def(\n     \u0022rclpy_expand_topic_name\u0022, \u0026rclpy::expand_topic_name,\ndiff --git rclpy/src/rclpy/action_client.cpp rclpy/src/rclpy/action_client.cpp\nindex 68f78d4..3fa78cc 100644\n--- rclpy/src/rclpy/action_client.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_client.cpp\n@@ -234,12 \u002B234,10 @@ ActionClient::is_action_server_available()\n }\n \n void\n-ActionClient::add_to_waitset(py::capsule pywait_set)\n\u002BActionClient::add_to_waitset(WaitSet \u0026 wait_set)\n {\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   rcl_ret_t ret = rcl_action_wait_set_add_action_client(\n-    wait_set, rcl_action_client_.get(), NULL, NULL);\n\u002B    wait_set.rcl_ptr(), rcl_action_client_.get(), NULL, NULL);\n   if (RCL_RET_OK != ret) {\n     std::string error_text{\u0022Failed to add \u0027rcl_action_client_t\u0027 to wait set\u0022};\n     throw rclpy::RCLError(error_text);\n@@ -247,17 \u002B245,15 @@ ActionClient::add_to_waitset(py::capsule pywait_set)\n }\n \n py::tuple\n-ActionClient::is_ready(py::capsule pywait_set)\n\u002BActionClient::is_ready(WaitSet \u0026 wait_set)\n {\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   bool is_feedback_ready = false;\n   bool is_status_ready = false;\n   bool is_goal_response_ready = false;\n   bool is_cancel_response_ready = false;\n   bool is_result_response_ready = false;\n   rcl_ret_t ret = rcl_action_client_wait_set_get_entities_ready(\n-    wait_set,\n\u002B    wait_set.rcl_ptr(),\n     rcl_action_client_.get(),\n     \u0026is_feedback_ready,\n     \u0026is_status_ready,\ndiff --git rclpy/src/rclpy/action_client.hpp rclpy/src/rclpy/action_client.hpp\nindex 7ce5965..360e923 100644\n--- rclpy/src/rclpy/action_client.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_client.hpp\n@@ -23,6 \u002B23,7 @@\n \n #include \u0022destroyable.hpp\u0022\n #include \u0022handle.hpp\u0022\n\u002B#include \u0022wait_set.hpp\u0022\n \n namespace py = pybind11;\n \n@@ -194,7 \u002B195,7 @@ public:\n    * This must be called after waiting on the wait set.\n    * Raises RuntimeError on failure.\n    *\n-   * \\param[in] pywait_set Capsule pointing to the wait set structure.\n\u002B   * \\param[in] wait_set Capsule pointing to the wait set structure.\n    * \\return A tuple of booleans representing the sub-entities ready:\n    *       (is_feedback_ready,\n    *        is_status_ready,\n@@ -203,15 \u002B204,15 @@ public:\n    *        is_result_response_ready)\n    */\n   py::tuple\n-  is_ready(py::capsule pywait_set);\n\u002B  is_ready(WaitSet \u0026 wait_set);\n \n   /// Add an action entitiy to a wait set.\n   /**\n    * Raises RuntimeError on failure.\n-   * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n\u002B   * \\param[in] wait_set Capsule pointer to an rcl_wait_set_t.\n    */\n   void\n-  add_to_waitset(py::capsule pywait_set);\n\u002B  add_to_waitset(WaitSet \u0026 wait_set);\n \n   /// Get rcl_client_t pointer\n   rcl_action_client_t *\ndiff --git rclpy/src/rclpy/action_server.cpp rclpy/src/rclpy/action_server.cpp\nindex 5bc7919..f899ef0 100644\n--- rclpy/src/rclpy/action_server.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.cpp\n@@ -248,15 \u002B248,14 @@ ActionServer::get_num_entities()\n }\n \n py::tuple\n-ActionServer::is_ready(py::capsule pywait_set)\n\u002BActionServer::is_ready(WaitSet \u0026 wait_set)\n {\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n   bool is_goal_request_ready = false;\n   bool is_cancel_request_ready = false;\n   bool is_result_request_ready = false;\n   bool is_goal_expired = false;\n   rcl_ret_t ret = rcl_action_server_wait_set_get_entities_ready(\n-    wait_set,\n\u002B    wait_set.rcl_ptr(),\n     rcl_action_server_.get(),\n     \u0026is_goal_request_ready,\n     \u0026is_cancel_request_ready,\n@@ -276,10 \u002B275,10 @@ ActionServer::is_ready(py::capsule pywait_set)\n }\n \n void\n-ActionServer::add_to_waitset(py::capsule pywait_set)\n\u002BActionServer::add_to_waitset(WaitSet \u0026 wait_set)\n {\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-  rcl_ret_t ret = rcl_action_wait_set_add_action_server(wait_set, rcl_action_server_.get(), NULL);\n\u002B  rcl_ret_t ret = rcl_action_wait_set_add_action_server(\n\u002B    wait_set.rcl_ptr(), rcl_action_server_.get(), NULL);\n   if (RCL_RET_OK != ret) {\n     throw rclpy::RCLError(\u0022Failed to add \u0027rcl_action_server_t\u0027 to wait set\u0022);\n   }\ndiff --git rclpy/src/rclpy/action_server.hpp rclpy/src/rclpy/action_server.hpp\nindex f5008a9..c58279f 100644\n--- rclpy/src/rclpy/action_server.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/action_server.hpp\n@@ -24,6 \u002B24,7 @@\n #include \u0022clock.hpp\u0022\n #include \u0022destroyable.hpp\u0022\n #include \u0022handle.hpp\u0022\n\u002B#include \u0022wait_set.hpp\u0022\n \n namespace py = pybind11;\n \n@@ -220,7 \u002B221,7 @@ public:\n    *        is_goal_expired)\n    */\n   py::tuple\n-  is_ready(py::capsule pywait_set);\n\u002B  is_ready(WaitSet \u0026 wait_set);\n \n   /// Add an action entitiy to a wait set.\n   /**\n@@ -230,7 \u002B231,7 @@ public:\n    * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n    */\n   void\n-  add_to_waitset(py::capsule pywait_set);\n\u002B  add_to_waitset(WaitSet \u0026 wait_set);\n \n   /// Get rcl_client_t pointer\n   rcl_action_server_t *\ndiff --git rclpy/src/rclpy/wait_set.cpp rclpy/src/rclpy/wait_set.cpp\nindex 0bf3a58..2738564 100644\n--- rclpy/src/rclpy/wait_set.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/wait_set.cpp\n@@ -32,43 \u002B32,28 @@\n \n namespace rclpy\n {\n-/// Destructor for a wait set\n-void\n-_rclpy_destroy_wait_set(PyObject * pycapsule)\n-{\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(PyCapsule_GetPointer(pycapsule, \u0022rcl_wait_set_t\u0022));\n-\n-  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    // Warning should use line number of the current stack frame\n-    int stack_level = 1;\n-    PyErr_WarnFormat(\n-      PyExc_RuntimeWarning, stack_level,\n-      \u0022Failed to fini wait set: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-  }\n-\n-  PyMem_Free(wait_set);\n-}\n-\n-py::capsule\n-get_zero_initialized_wait_set()\n\u002BWaitSet::WaitSet()\n {\n-  auto deleter = [](rcl_wait_set_t * ptr) {PyMem_FREE(ptr);};\n-  auto wait_set = std::unique_ptr\u003Crcl_wait_set_t, decltype(deleter)\u003E(\n-    static_cast\u003Crcl_wait_set_t *\u003E(PyMem_Malloc(sizeof(rcl_wait_set_t))),\n-    deleter);\n-  if (!wait_set) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *wait_set = rcl_get_zero_initialized_wait_set();\n-  return py::capsule(wait_set.release(), \u0022rcl_wait_set_t\u0022, _rclpy_destroy_wait_set);\n\u002B  // Create a client\n\u002B  rcl_wait_set_ = std::shared_ptr\u003Crcl_wait_set_t\u003E(\n\u002B    new rcl_wait_set_t,\n\u002B    [](rcl_wait_set_t * waitset)\n\u002B    {\n\u002B      rcl_ret_t ret = rcl_wait_set_fini(waitset);\n\u002B      if (RCL_RET_OK != ret) {\n\u002B        // Warning should use line number of the current stack frame\n\u002B        int stack_level = 1;\n\u002B        PyErr_WarnFormat(\n\u002B          PyExc_RuntimeWarning, stack_level, \u0022Failed to fini wait set: %s\u0022,\n\u002B          rcl_get_error_string().str);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B      delete waitset;\n\u002B    });\n\u002B  *rcl_wait_set_ = rcl_get_zero_initialized_wait_set();\n }\n \n-void\n-wait_set_init(\n-  py::capsule pywait_set,\n\u002BWaitSet::WaitSet(\n   size_t number_of_subscriptions,\n   size_t number_of_guard_conditions,\n   size_t number_of_timers,\n@@ -77,10 \u002B62,23 @@ wait_set_init(\n   size_t number_of_events,\n   py::capsule pycontext)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B  // Create a client\n\u002B  rcl_wait_set_ = std::shared_ptr\u003Crcl_wait_set_t\u003E(\n\u002B    new rcl_wait_set_t,\n\u002B    [](rcl_wait_set_t * waitset)\n\u002B    {\n\u002B      rcl_ret_t ret = rcl_wait_set_fini(waitset);\n\u002B      if (RCL_RET_OK != ret) {\n\u002B        // Warning should use line number of the current stack frame\n\u002B        int stack_level = 1;\n\u002B        PyErr_WarnFormat(\n\u002B          PyExc_RuntimeWarning, stack_level, \u0022Failed to fini wait set: %s\u0022,\n\u002B          rcl_get_error_string().str);\n\u002B        rcl_reset_error();\n\u002B      }\n\u002B      delete waitset;\n\u002B    });\n\u002B  *rcl_wait_set_ = rcl_get_zero_initialized_wait_set();\n \n   auto context = static_cast\u003Crcl_context_t *\u003E(\n     rclpy_handle_get_pointer_from_capsule(pycontext.ptr(), \u0022rcl_context_t\u0022));\n@@ -89,7 \u002B87,7 @@ wait_set_init(\n   }\n \n   rcl_ret_t ret = rcl_wait_set_init(\n-    wait_set,\n\u002B    rcl_wait_set_.get(),\n     number_of_subscriptions,\n     number_of_guard_conditions,\n     number_of_timers,\n@@ -98,33 \u002B96,29 @@ wait_set_init(\n     number_of_events,\n     context,\n     rcl_get_default_allocator());\n-  if (ret != RCL_RET_OK) {\n\u002B  if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to initialize wait set\u0022);\n   }\n }\n \n void\n-wait_set_clear_entities(py::capsule pywait_set)\n\u002BWaitSet::destroy()\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n\u002B  rcl_wait_set_.reset();\n\u002B}\n \n-  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n\u002Bvoid\n\u002BWaitSet::clear_entities()\n\u002B{\n\u002B  rcl_ret_t ret = rcl_wait_set_clear(rcl_wait_set_.get());\n   if (ret != RCL_RET_OK) {\n     throw RCLError(\u0022failed to clear wait set\u0022);\n   }\n }\n \n size_t\n-wait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py::capsule pyentity)\n\u002BWaitSet::add_entity(const std::string \u0026 entity_type, py::capsule pyentity)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   rcl_ret_t ret = RCL_RET_ERROR;\n   size_t index;\n \n@@ -134,7 \u002B128,7 @@ wait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py:\n     if (!guard_condition) {\n       throw py::error_already_set();\n     }\n-    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, \u0026index);\n\u002B    ret = rcl_wait_set_add_guard_condition(rcl_wait_set_.get(), guard_condition, \u0026index);\n   } else {\n     std::string error_text{\u0022\u0027\u0022};\n     error_text \u002B= entity_type;\n@@ -151,15 \u002B145,10 @@ wait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py:\n }\n \n size_t\n-wait_set_add_service(const py::capsule pywait_set, const Service \u0026 service)\n\u002BWaitSet::add_service(const Service \u0026 service)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   size_t index;\n-  rcl_ret_t ret = rcl_wait_set_add_service(wait_set, service.rcl_ptr(), \u0026index);\n\u002B  rcl_ret_t ret = rcl_wait_set_add_service(rcl_wait_set_.get(), service.rcl_ptr(), \u0026index);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to add service to wait set\u0022);\n   }\n@@ -167,15 \u002B156,11 @@ wait_set_add_service(const py::capsule pywait_set, const Service \u0026 service)\n }\n \n size_t\n-wait_set_add_subscription(const py::capsule pywait_set, const Subscription \u0026 subscription)\n\u002BWaitSet::add_subscription(const Subscription \u0026 subscription)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   size_t index;\n-  rcl_ret_t ret = rcl_wait_set_add_subscription(wait_set, subscription.rcl_ptr(), \u0026index);\n\u002B  rcl_ret_t ret = rcl_wait_set_add_subscription(\n\u002B    rcl_wait_set_.get(), subscription.rcl_ptr(), \u0026index);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to add subscription to wait set\u0022);\n   }\n@@ -183,15 \u002B168,10 @@ wait_set_add_subscription(const py::capsule pywait_set, const Subscription \u0026 sub\n }\n \n size_t\n-wait_set_add_timer(const py::capsule pywait_set, const Timer \u0026 timer)\n\u002BWaitSet::add_timer(const Timer \u0026 timer)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   size_t index;\n-  rcl_ret_t ret = rcl_wait_set_add_timer(wait_set, timer.rcl_ptr(), \u0026index);\n\u002B  rcl_ret_t ret = rcl_wait_set_add_timer(rcl_wait_set_.get(), timer.rcl_ptr(), \u0026index);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to add client to wait set\u0022);\n   }\n@@ -199,15 \u002B179,10 @@ wait_set_add_timer(const py::capsule pywait_set, const Timer \u0026 timer)\n }\n \n size_t\n-wait_set_add_client(const py::capsule pywait_set, const Client \u0026 client)\n\u002BWaitSet::add_client(const Client \u0026 client)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   size_t index;\n-  rcl_ret_t ret = rcl_wait_set_add_client(wait_set, client.rcl_ptr(), \u0026index);\n\u002B  rcl_ret_t ret = rcl_wait_set_add_client(rcl_wait_set_.get(), client.rcl_ptr(), \u0026index);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to add client to wait set\u0022);\n   }\n@@ -215,15 \u002B190,10 @@ wait_set_add_client(const py::capsule pywait_set, const Client \u0026 client)\n }\n \n size_t\n-wait_set_add_event(const py::capsule pywait_set, const QoSEvent \u0026 event)\n\u002BWaitSet::add_event(const QoSEvent \u0026 event)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   size_t index;\n-  rcl_ret_t ret = rcl_wait_set_add_event(wait_set, event.rcl_ptr(), \u0026index);\n\u002B  rcl_ret_t ret = rcl_wait_set_add_event(rcl_wait_set_.get(), event.rcl_ptr(), \u0026index);\n   if (RCL_RET_OK != ret) {\n     throw RCLError(\u0022failed to add event to wait set\u0022);\n   }\n@@ -231,33 \u002B201,28 @@ wait_set_add_event(const py::capsule pywait_set, const QoSEvent \u0026 event)\n }\n \n bool\n-wait_set_is_ready(const std::string \u0026 entity_type, py::capsule pywait_set, size_t index)\n\u002BWaitSet::is_ready(const std::string \u0026 entity_type, size_t index)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   const void ** entities = NULL;\n   size_t num_entities = 0;\n   if (\u0022subscription\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Esubscriptions);\n-    num_entities = wait_set-\u003Esize_of_subscriptions;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Esubscriptions);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_subscriptions;\n   } else if (\u0022client\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eclients);\n-    num_entities = wait_set-\u003Esize_of_clients;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Eclients);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_clients;\n   } else if (\u0022service\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eservices);\n-    num_entities = wait_set-\u003Esize_of_services;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Eservices);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_services;\n   } else if (\u0022timer\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Etimers);\n-    num_entities = wait_set-\u003Esize_of_timers;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Etimers);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_timers;\n   } else if (\u0022guard_condition\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eguard_conditions);\n-    num_entities = wait_set-\u003Esize_of_guard_conditions;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Eguard_conditions);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_guard_conditions;\n   } else if (\u0022event\u0022 == entity_type) {\n-    entities = reinterpret_cast\u003Cconst void **\u003E(wait_set-\u003Eevents);\n-    num_entities = wait_set-\u003Esize_of_events;\n\u002B    entities = reinterpret_cast\u003Cconst void **\u003E(rcl_wait_set_-\u003Eevents);\n\u002B    num_entities = rcl_wait_set_-\u003Esize_of_events;\n   } else {\n     std::string error_text{\u0022\u0027\u0022};\n     error_text \u002B= entity_type;\n@@ -292,23 \u002B257,23 @@ _get_ready_entities(const EntityArray ** entities, const size_t num_entities)\n }\n \n py::list\n-get_ready_entities(const std::string \u0026 entity_type, py::capsule pywait_set)\n\u002BWaitSet::get_ready_entities(const std::string \u0026 entity_type)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   if (\u0022subscription\u0022 == entity_type) {\n-    return _get_ready_entities(wait_set-\u003Esubscriptions, wait_set-\u003Esize_of_subscriptions);\n\u002B    return _get_ready_entities(\n\u002B      rcl_wait_set_-\u003Esubscriptions, rcl_wait_set_-\u003Esize_of_subscriptions);\n   } else if (\u0022client\u0022 == entity_type) {\n-    return _get_ready_entities(wait_set-\u003Eclients, wait_set-\u003Esize_of_clients);\n\u002B    return _get_ready_entities(\n\u002B      rcl_wait_set_-\u003Eclients, rcl_wait_set_-\u003Esize_of_clients);\n   } else if (\u0022service\u0022 == entity_type) {\n-    return _get_ready_entities(wait_set-\u003Eservices, wait_set-\u003Esize_of_services);\n\u002B    return _get_ready_entities(\n\u002B      rcl_wait_set_-\u003Eservices, rcl_wait_set_-\u003Esize_of_services);\n   } else if (\u0022timer\u0022 == entity_type) {\n-    return _get_ready_entities(wait_set-\u003Etimers, wait_set-\u003Esize_of_timers);\n\u002B    return _get_ready_entities(\n\u002B      rcl_wait_set_-\u003Etimers, rcl_wait_set_-\u003Esize_of_timers);\n   } else if (\u0022guard_condition\u0022 == entity_type) {\n-    return _get_ready_entities(wait_set-\u003Eguard_conditions, wait_set-\u003Esize_of_guard_conditions);\n\u002B    return _get_ready_entities(\n\u002B      rcl_wait_set_-\u003Eguard_conditions, rcl_wait_set_-\u003Esize_of_guard_conditions);\n   }\n \n   std::string error_text{\u0022\u0027\u0022};\n@@ -318,23 \u002B283,60 @@ get_ready_entities(const std::string \u0026 entity_type, py::capsule pywait_set)\n }\n \n void\n-wait(py::capsule pywait_set, int64_t timeout)\n\u002BWaitSet::wait(int64_t timeout)\n {\n-  if (0 != std::strcmp(\u0022rcl_wait_set_t\u0022, pywait_set.name())) {\n-    throw py::value_error(\u0022capsule is not an rcl_wait_set_t\u0022);\n-  }\n-  auto wait_set = static_cast\u003Crcl_wait_set_t *\u003E(pywait_set);\n-\n   rcl_ret_t ret;\n \n   // Could be a long wait, release the GIL\n   {\n     py::gil_scoped_release gil_release;\n-    ret = rcl_wait(wait_set, timeout);\n\u002B    ret = rcl_wait(rcl_wait_set_.get(), timeout);\n   }\n \n-  if (ret != RCL_RET_OK \u0026\u0026 ret != RCL_RET_TIMEOUT) {\n\u002B  if (RCL_RET_OK != ret \u0026\u0026 RCL_RET_TIMEOUT != ret) {\n     throw RCLError(\u0022failed to wait on wait set\u0022);\n   }\n }\n\u002B\n\u002Bvoid define_waitset(py::object module)\n\u002B{\n\u002B  py::class_\u003CWaitSet, Destroyable, std::shared_ptr\u003CWaitSet\u003E\u003E(module, \u0022WaitSet\u0022)\n\u002B  .def(py::init\u003Csize_t, size_t, size_t, size_t, size_t, size_t, py::capsule\u003E())\n\u002B  .def(py::init\u003C\u003E())\n\u002B  .def_property_readonly(\n\u002B    \u0022pointer\u0022, [](const WaitSet \u0026 waitset) {\n\u002B      return reinterpret_cast\u003Csize_t\u003E(waitset.rcl_ptr());\n\u002B    },\n\u002B    \u0022Get the address of the entity as an integer\u0022)\n\u002B  .def(\n\u002B    \u0022clear_entities\u0022, \u0026WaitSet::clear_entities,\n\u002B    \u0022Clear all the pointers in the wait set\u0022)\n\u002B  .def(\n\u002B    \u0022add_entity\u0022, \u0026WaitSet::add_entity,\n\u002B    \u0022Add an entity to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022add_service\u0022, \u0026WaitSet::add_service,\n\u002B    \u0022Add a service to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022add_subscription\u0022, \u0026WaitSet::add_subscription,\n\u002B    \u0022Add a subcription to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022add_client\u0022, \u0026WaitSet::add_client,\n\u002B    \u0022Add a client to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022add_timer\u0022, \u0026WaitSet::add_timer,\n\u002B    \u0022Add a timer to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022add_event\u0022, \u0026WaitSet::add_event,\n\u002B    \u0022Add an event to the wait set structure\u0022)\n\u002B  .def(\n\u002B    \u0022is_ready\u0022, \u0026WaitSet::is_ready,\n\u002B    \u0022Check if an entity in the wait set is ready by its index\u0022)\n\u002B  .def(\n\u002B    \u0022get_ready_entities\u0022, \u0026WaitSet::get_ready_entities,\n\u002B    \u0022Get list of entities ready by entity type\u0022)\n\u002B  .def(\n\u002B    \u0022wait\u0022, \u0026WaitSet::wait,\n\u002B    \u0022Wait until timeout is reached or event happened\u0022);\n\u002B}\n }  // namespace rclpy\ndiff --git rclpy/src/rclpy/wait_set.hpp rclpy/src/rclpy/wait_set.hpp\nindex 5cd1b5f..bf59239 100644\n--- rclpy/src/rclpy/wait_set.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/wait_set.hpp\n@@ -21,6 \u002B21,7 @@\n #include \u003Cstring\u003E\n \n #include \u0022client.hpp\u0022\n\u002B#include \u0022destroyable.hpp\u0022\n #include \u0022qos_event.hpp\u0022\n #include \u0022service.hpp\u0022\n #include \u0022subscription.hpp\u0022\n@@ -30,149 \u002B31,151 @@ namespace py = pybind11;\n \n namespace rclpy\n {\n-/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n-py::capsule\n-get_zero_initialized_wait_set();\n-\n-/// Initialize a wait set\n-/**\n- * Raises RCLError if the wait set could not be initialized\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] node_name string name of the node to be created\n- * \\param[in] number_of_subscriptions int\n- * \\param[in] number_of_guard_conditions int\n- * \\param[in] number_of_timers int\n- * \\param[in] number_of_clients int\n- * \\param[in] number_of_services int\n- * \\param[in] pycontext Capsule pointing to an rcl_context_t\n- */\n-void\n-wait_set_init(\n-  py::capsule pywait_set,\n-  size_t number_of_subscriptions,\n-  size_t number_of_guard_conditions,\n-  size_t number_of_timers,\n-  size_t number_of_clients,\n-  size_t number_of_services,\n-  size_t number_of_events,\n-  py::capsule pycontext);\n-\n-/// Clear all the pointers in the wait set\n-/**\n- * Raises RCLError if any rcl error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- */\n-void\n-wait_set_clear_entities(py::capsule pywait_set);\n-\n-/// Add an entity to the wait set structure\n-/**\n- * Raises RuntimeError if the entity type is unknown\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyentity Capsule pointing to the entity to add\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_entity(const std::string \u0026 entity_type, py::capsule pywait_set, py::capsule pyentity);\n-\n-/// Add a service to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] service a service to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_service(const py::capsule pywait_set, const Service \u0026 service);\n-\n-/// Add a subcription to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] service a service to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_subscription(const py::capsule pywait_set, const Subscription \u0026 subscription);\n-\n-/// Add a client to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] client a client to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_client(const py::capsule pywait_set, const Client \u0026 client);\n-\n-/// Add a timer to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timer a timer to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_timer(const py::capsule pywait_set, const Timer \u0026 timer);\n-\n-/// Add an event to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] event a QoSEvent to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_event(const py::capsule pywait_set, const QoSEvent \u0026 event);\n-\n-/// Check if an entity in the wait set is ready by its index\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError if the entity type is unknown\n- * Raises IndexError if the given index is beyond the number of entities in the set\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] index location in the wait set of the entity to check\n- * \\return True if the entity at the index in the wait set is not NULL\n- */\n-bool\n-wait_set_is_ready(const std::string \u0026 entity_type, py::capsule pywait_set, size_t index);\n-\n-/// Get list of non-null entities in wait set\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if the entity type is not known\n- *\n- * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return List of wait set entities pointers ready for take\n- */\n-py::list\n-get_ready_entities(const std::string \u0026 entity_type, py::capsule pywait_set);\n-\n-/// Wait until timeout is reached or event happened\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RCLError if there was an error while waiting\n- *\n- * This function will wait for an event to happen or for the timeout to expire.\n- * A negative timeout means wait forever, a timeout of 0 means no wait\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n- */\n-void\n-wait(py::capsule pywait_set, int64_t timeout);\n\u002Bclass WaitSet : public Destroyable, public std::enable_shared_from_this\u003CWaitSet\u003E\n\u002B{\n\u002Bpublic:\n\u002B  /// Initialize a wait set\n\u002B  WaitSet();\n\u002B\n\u002B  /// Initialize a wait set\n\u002B  /**\n\u002B   * Raises RCLError if the wait set could not be initialized\n\u002B   *\n\u002B   * \\param[in] node_name string name of the node to be created\n\u002B   * \\param[in] number_of_subscriptions a positive number or zero\n\u002B   * \\param[in] number_of_guard_conditions int\n\u002B   * \\param[in] number_of_timers int\n\u002B   * \\param[in] number_of_clients int\n\u002B   * \\param[in] number_of_services int\n\u002B   * \\param[in] pycontext Capsule pointing to an rcl_context_t\n\u002B   */\n\u002B  WaitSet(\n\u002B    size_t number_of_subscriptions,\n\u002B    size_t number_of_guard_conditions,\n\u002B    size_t number_of_timers,\n\u002B    size_t number_of_clients,\n\u002B    size_t number_of_services,\n\u002B    size_t number_of_events,\n\u002B    py::capsule pycontext);\n\u002B\n\u002B  /// Clear all the pointers in the wait set\n\u002B  /**\n\u002B   * Raises RCLError if any rcl error occurs\n\u002B   */\n\u002B  void\n\u002B  clear_entities();\n\u002B\n\u002B  /// Add an entity to the wait set structure\n\u002B  /**\n\u002B   * Raises RuntimeError if the entity type is unknown\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B   * \\param[in] pyentity Capsule pointing to the entity to add\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_entity(const std::string \u0026 entity_type, py::capsule pyentity);\n\u002B\n\u002B  /// Add a service to the wait set structure\n\u002B  /**\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] service a service to add to the wait set\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_service(const Service \u0026 service);\n\u002B\n\u002B  /// Add a subcription to the wait set structure\n\u002B  /**\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] service a service to add to the wait set\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_subscription(const Subscription \u0026 subscription);\n\u002B\n\u002B  /// Add a client to the wait set structure\n\u002B  /**\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] client a client to add to the wait set\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_client(const Client \u0026 client);\n\u002B\n\u002B  /// Add a timer to the wait set structure\n\u002B  /**\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] timer a timer to add to the wait set\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_timer(const Timer \u0026 timer);\n\u002B\n\u002B  /// Add an event to the wait set structure\n\u002B  /**\n\u002B   * Raises RCLError if any lower level error occurs\n\u002B   *\n\u002B   * \\param[in] event a QoSEvent to add to the wait set\n\u002B   * \\return Index in waitset entity was added at\n\u002B   */\n\u002B  size_t\n\u002B  add_event(const QoSEvent \u0026 event);\n\u002B\n\u002B  /// Check if an entity in the wait set is ready by its index\n\u002B  /**\n\u002B   * This must be called after waiting on the wait set.\n\u002B   * Raises RuntimeError if the entity type is unknown\n\u002B   * Raises IndexError if the given index is beyond the number of entities in the set\n\u002B   *\n\u002B   * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B   * \\param[in] index location in the wait set of the entity to check\n\u002B   * \\return True if the entity at the index in the wait set is not NULL\n\u002B   */\n\u002B  bool\n\u002B  is_ready(const std::string \u0026 entity_type, size_t index);\n\u002B\n\u002B  /// Get list of entities ready by entity type\n\u002B  /**\n\u002B   * Raises RuntimeError if the entity type is not known\n\u002B   *\n\u002B   * \\param[in] entity_type string defining the entity [\u0022subscription, client, service\u0022]\n\u002B   * \\return List of wait set entities pointers ready for take\n\u002B   */\n\u002B  py::list\n\u002B  get_ready_entities(const std::string \u0026 entity_type);\n\u002B\n\u002B  /// Wait until timeout is reached or event happened\n\u002B  /**\n\u002B   * Raises RCLError if there was an error while waiting\n\u002B   *\n\u002B   * This function will wait for an event to happen or for the timeout to expire.\n\u002B   * A negative timeout means wait forever, a timeout of 0 means no wait\n\u002B   * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n\u002B   */\n\u002B  void\n\u002B  wait(int64_t timeout);\n\u002B\n\u002B  /// Get rcl_client_t pointer\n\u002B  rcl_wait_set_t * rcl_ptr() const\n\u002B  {\n\u002B    return rcl_wait_set_.get();\n\u002B  }\n\u002B\n\u002B  /// Force an early destruction of this object\n\u002B  void destroy() override;\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003Crcl_wait_set_t\u003E rcl_wait_set_;\n\u002B};\n\u002B\n\u002B/// Define a pybind11 wrapper for an rclpy::Service\n\u002Bvoid define_waitset(py::object module);\n }  // namespace rclpy\n \n #endif  // RCLPY__WAIT_SET_HPP_\ndiff --git rclpy/test/test_qos_event.py rclpy/test/test_qos_event.py\nindex 8435f14..34a8104 100644\n--- rclpy/test/test_qos_event.py\n\u002B\u002B\u002B rclpy/test/test_qos_event.py\n@@ -237,41 \u002B237,40 @@ class TestQoSEvent(unittest.TestCase):\n         # Go through the exposed apis and ensure that things don\u0027t explode when called\n         # Make no assumptions about being able to actually receive the events\n         publisher = self.node.create_publisher(EmptyMsg, self.topic_name, 10)\n-        wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n         with self.context.handle as context_handle:\n-            _rclpy.rclpy_wait_set_init(wait_set, 0, 0, 0, 0, 0, 3, context_handle)\n\u002B            wait_set = _rclpy.WaitSet(0, 0, 0, 0, 0, 3, context_handle)\n \n         deadline_event_handle = self._create_event_handle(\n             publisher, QoSPublisherEventType.RCL_PUBLISHER_OFFERED_DEADLINE_MISSED)\n         with deadline_event_handle:\n-            deadline_event_index = _rclpy.rclpy_wait_set_add_event(wait_set, deadline_event_handle)\n\u002B            deadline_event_index = wait_set.add_event(deadline_event_handle)\n         self.assertIsNotNone(deadline_event_index)\n \n         liveliness_event_handle = self._create_event_handle(\n             publisher, QoSPublisherEventType.RCL_PUBLISHER_LIVELINESS_LOST)\n         with liveliness_event_handle:\n-            liveliness_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, liveliness_event_handle)\n\u002B            liveliness_event_index = wait_set.add_event(\n\u002B                    liveliness_event_handle)\n         self.assertIsNotNone(liveliness_event_index)\n \n         try:\n             incompatible_qos_event_handle = self._create_event_handle(\n                 publisher, QoSPublisherEventType.RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS)\n             with incompatible_qos_event_handle:\n-                incompatible_qos_event_index = _rclpy.rclpy_wait_set_add_event(\n-                        wait_set, incompatible_qos_event_handle)\n\u002B                incompatible_qos_event_index = wait_set.add_event(\n\u002B                        incompatible_qos_event_handle)\n             self.assertIsNotNone(incompatible_qos_event_index)\n         except UnsupportedEventTypeError:\n             self.assertTrue(self.is_fastrtps)\n \n         # We live in our own namespace and have created no other participants, so\n         # there can\u0027t be any of these events.\n-        _rclpy.rclpy_wait(wait_set, 0)\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\u0027event\u0027, wait_set, deadline_event_index))\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\u0027event\u0027, wait_set, liveliness_event_index))\n\u002B        wait_set.wait(0)\n\u002B        self.assertFalse(wait_set.is_ready(\u0027event\u0027, deadline_event_index))\n\u002B        self.assertFalse(wait_set.is_ready(\u0027event\u0027, liveliness_event_index))\n         if not self.is_fastrtps:\n-            self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\n-                \u0027event\u0027, wait_set, incompatible_qos_event_index))\n\u002B            self.assertFalse(wait_set.is_ready(\n\u002B                \u0027event\u0027, incompatible_qos_event_index))\n \n         # Calling take data even though not ready should provide me an empty initialized message\n         # Tests data conversion utilities in C side\n@@ -310,42 \u002B309,39 @@ class TestQoSEvent(unittest.TestCase):\n         # Go through the exposed apis and ensure that things don\u0027t explode when called\n         # Make no assumptions about being able to actually receive the events\n         subscription = self.node.create_subscription(EmptyMsg, self.topic_name, Mock(), 10)\n-        wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n         with self.context.handle as context_handle:\n-            _rclpy.rclpy_wait_set_init(wait_set, 0, 0, 0, 0, 0, 3, context_handle)\n\u002B            wait_set = _rclpy.WaitSet(0, 0, 0, 0, 0, 3, context_handle)\n \n         deadline_event_handle = self._create_event_handle(\n             subscription, QoSSubscriptionEventType.RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED)\n         with deadline_event_handle:\n-            deadline_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, deadline_event_handle)\n\u002B            deadline_event_index = wait_set.add_event(deadline_event_handle)\n         self.assertIsNotNone(deadline_event_index)\n \n         liveliness_event_handle = self._create_event_handle(\n             subscription, QoSSubscriptionEventType.RCL_SUBSCRIPTION_LIVELINESS_CHANGED)\n         with liveliness_event_handle:\n-            liveliness_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, liveliness_event_handle)\n\u002B            liveliness_event_index = wait_set.add_event(liveliness_event_handle)\n         self.assertIsNotNone(liveliness_event_index)\n \n         try:\n             incompatible_qos_event_handle = self._create_event_handle(\n                 subscription, QoSSubscriptionEventType.RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS)\n             with incompatible_qos_event_handle:\n-                incompatible_qos_event_index = _rclpy.rclpy_wait_set_add_event(\n-                        wait_set, incompatible_qos_event_handle)\n\u002B                incompatible_qos_event_index = wait_set.add_event(\n\u002B                        incompatible_qos_event_handle)\n             self.assertIsNotNone(incompatible_qos_event_index)\n         except UnsupportedEventTypeError:\n             self.assertTrue(self.is_fastrtps)\n \n         # We live in our own namespace and have created no other participants, so\n         # there can\u0027t be any of these events.\n-        _rclpy.rclpy_wait(wait_set, 0)\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\u0027event\u0027, wait_set, deadline_event_index))\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\u0027event\u0027, wait_set, liveliness_event_index))\n\u002B        wait_set.wait(0)\n\u002B        self.assertFalse(wait_set.is_ready(\u0027event\u0027, deadline_event_index))\n\u002B        self.assertFalse(wait_set.is_ready(\u0027event\u0027, liveliness_event_index))\n         if not self.is_fastrtps:\n-            self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\n-                \u0027event\u0027, wait_set, incompatible_qos_event_index))\n\u002B            self.assertFalse(wait_set.is_ready(\n\u002B                \u0027event\u0027, incompatible_qos_event_index))\n \n         # Calling take data even though not ready should provide me an empty initialized message\n         # Tests data conversion utilities in C side\ndiff --git rclpy/test/test_waitable.py rclpy/test/test_waitable.py\nindex 135d36d..18603fd 100644\n--- rclpy/test/test_waitable.py\n\u002B\u002B\u002B rclpy/test/test_waitable.py\n@@ -52,7 \u002B52,7 @@ class ClientWaitable(Waitable):\n \n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027client\u0027, wait_set, self.client_index):\n\u002B        if wait_set.is_ready(\u0027client\u0027, self.client_index):\n             self.client_is_ready = True\n         return self.client_is_ready\n \n@@ -76,7 \u002B76,7 @@ class ClientWaitable(Waitable):\n \n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n-        self.client_index = _rclpy.rclpy_wait_set_add_client(wait_set, self.client)\n\u002B        self.client_index = wait_set.add_client(self.client)\n \n \n class ServerWaitable(Waitable):\n@@ -95,7 \u002B95,7 @@ class ServerWaitable(Waitable):\n \n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027service\u0027, wait_set, self.server_index):\n\u002B        if wait_set.is_ready(\u0027service\u0027, self.server_index):\n             self.server_is_ready = True\n         return self.server_is_ready\n \n@@ -119,7 \u002B119,7 @@ class ServerWaitable(Waitable):\n \n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n-        self.server_index = _rclpy.rclpy_wait_set_add_service(wait_set, self.server)\n\u002B        self.server_index = wait_set.add_service(self.server)\n \n \n class TimerWaitable(Waitable):\n@@ -140,7 \u002B140,7 @@ class TimerWaitable(Waitable):\n \n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027timer\u0027, wait_set, self.timer_index):\n\u002B        if wait_set.is_ready(\u0027timer\u0027, self.timer_index):\n             self.timer_is_ready = True\n         return self.timer_is_ready\n \n@@ -165,7 \u002B165,7 @@ class TimerWaitable(Waitable):\n \n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n-        self.timer_index = _rclpy.rclpy_wait_set_add_timer(wait_set, self.timer)\n\u002B        self.timer_index = wait_set.add_timer(self.timer)\n \n \n class SubscriptionWaitable(Waitable):\n@@ -184,7 \u002B184,7 @@ class SubscriptionWaitable(Waitable):\n \n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027subscription\u0027, wait_set, self.subscription_index):\n\u002B        if wait_set.is_ready(\u0027subscription\u0027, self.subscription_index):\n             self.subscription_is_ready = True\n         return self.subscription_is_ready\n \n@@ -210,8 \u002B210,8 @@ class SubscriptionWaitable(Waitable):\n \n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n-        self.subscription_index = _rclpy.rclpy_wait_set_add_subscription(\n-            wait_set, self.subscription)\n\u002B        self.subscription_index = wait_set.add_subscription(\n\u002B            self.subscription)\n \n \n class GuardConditionWaitable(Waitable):\n@@ -229,7 \u002B229,7 @@ class GuardConditionWaitable(Waitable):\n \n     def is_ready(self, wait_set):\n         \u0022\u0022\u0022Return True if entities are ready in the wait set.\u0022\u0022\u0022\n-        if _rclpy.rclpy_wait_set_is_ready(\u0027guard_condition\u0027, wait_set, self.guard_condition_index):\n\u002B        if wait_set.is_ready(\u0027guard_condition\u0027, self.guard_condition_index):\n             self.guard_is_ready = True\n         return self.guard_is_ready\n \n@@ -253,8 \u002B253,8 @@ class GuardConditionWaitable(Waitable):\n \n     def add_to_wait_set(self, wait_set):\n         \u0022\u0022\u0022Add entities to wait set.\u0022\u0022\u0022\n-        self.guard_condition_index = _rclpy.rclpy_wait_set_add_entity(\n-            \u0027guard_condition\u0027, wait_set, self.guard_condition)\n\u002B        self.guard_condition_index = wait_set.add_entity(\n\u002B            \u0027guard_condition\u0027, self.guard_condition)\n \n \n class MutuallyExclusiveWaitable(Waitable):\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "721976a825360b260c2b8adc0e6a905a6ee508a9",
    "RawMessage": "Support extended signature for \u0060message_type_support_callbacks_t::max_serialized_size()\u0060 from \u0060rosidl_typesupport_fastrtps_cpp\u0060 (#14)",
    "Changes": "diff --git rmw_connextdds_common/src/common/rmw_type_support.cpp rmw_connextdds_common/src/common/rmw_type_support.cpp\nindex 04b0a94..9209dc6 100644\n--- rmw_connextdds_common/src/common/rmw_type_support.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/common/rmw_type_support.cpp\n@@ -678,8 \u002B678,15 @@ void RMW_Connext_MessageTypeSupport::type_info(\n      but assumes full_bounded == true by default */\n   bool full_bounded = true;\n \n\u002B#ifdef ROSIDL_TYPESUPPORT_FASTRTPS_HAS_PLAIN_TYPES\n\u002B  char bounds_info;\n\u002B  serialized_size_max =\n\u002B    static_cast\u003Cuint32_t\u003E(callbacks-\u003Emax_serialized_size(bounds_info));\n\u002B  full_bounded = 0 != (bounds_info \u0026 ROSIDL_TYPESUPPORT_FASTRTPS_BOUNDED_TYPE);\n\u002B#else\n   serialized_size_max =\n     static_cast\u003Cuint32_t\u003E(callbacks-\u003Emax_serialized_size(full_bounded));\n\u002B#endif\n \n   unbounded = !full_bounded;\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rcpputils",
    "SHA": "197357760a89762e1c704681123d1bd425b8f2b1",
    "RawMessage": "Make sure that an existing path is a directory for create_directories (#98)",
    "Changes": "diff --git include/rcpputils/filesystem_helper.hpp include/rcpputils/filesystem_helper.hpp\nindex 507fdba..93fa580 100644\n--- include/rcpputils/filesystem_helper.hpp\n\u002B\u002B\u002B include/rcpputils/filesystem_helper.hpp\n@@ -511,7 \u002B511,7 @@ inline bool create_directories(const path \u0026 p)\n #endif\n     }\n   }\n-  return status == 0;\n\u002B  return status == 0 \u0026\u0026 p_built.is_directory();\n }\n \n /**\ndiff --git test/test_filesystem_helper.cpp test/test_filesystem_helper.cpp\nindex 11952d6..a83047f 100644\n--- test/test_filesystem_helper.cpp\n\u002B\u002B\u002B test/test_filesystem_helper.cpp\n@@ -286,6 \u002B286,7 @@ TEST(TestFilesystemHelper, filesystem_manipulation)\n   EXPECT_TRUE(rcpputils::fs::exists(file));\n   EXPECT_TRUE(rcpputils::fs::is_regular_file(file));\n   EXPECT_FALSE(rcpputils::fs::is_directory(file));\n\u002B  EXPECT_FALSE(rcpputils::fs::create_directories(file));\n   EXPECT_GE(rcpputils::fs::file_size(file), expected_file_size);\n   EXPECT_THROW(rcpputils::fs::file_size(dir), std::system_error) \u003C\u003C\n     \u0022file_size is only applicable for files!\u0022;\n@@ -352,6 \u002B353,9 @@ TEST(TestFilesystemHelper, filesystem_manipulation)\n     ASSERT_FALSE(rcpputils::fs::exists(file));\n   }\n   ASSERT_FALSE(rcpputils::fs::exists(dir));\n\u002B\n\u002B  // Empty path/directory cannot be created\n\u002B  EXPECT_FALSE(rcpputils::fs::create_directories(rcpputils::fs::path(\u0022\u0022)));\n }\n \n TEST(TestFilesystemHelper, remove_extension)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "148d295416dba3814162465392e56116195c2304",
    "RawMessage": "Add more tests for the static single threaded executor.",
    "Changes": "diff --git rclcpp/test/CMakeLists.txt rclcpp/test/CMakeLists.txt\nindex d30be3c5..922eb5a0 100644\n--- rclcpp/test/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/CMakeLists.txt\n@@ -542,7 \u002B542,9 @@ endif()\n ament_add_gtest(test_static_single_threaded_executor rclcpp/executors/test_static_single_threaded_executor.cpp\n   APPEND_LIBRARY_DIRS \u0022${append_library_dirs}\u0022)\n if(TARGET test_static_single_threaded_executor)\n-  target_link_libraries(test_static_single_threaded_executor ${PROJECT_NAME})\n\u002B  ament_target_dependencies(test_static_single_threaded_executor\n\u002B    \u0022test_msgs\u0022)\n\u002B  target_link_libraries(test_static_single_threaded_executor ${PROJECT_NAME} mimick)\n endif()\n \n ament_add_gtest(test_multi_threaded_executor rclcpp/executors/test_multi_threaded_executor.cpp\ndiff --git rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\nindex 7c63f64e..cd47396f 100644\n--- rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_static_single_threaded_executor.cpp\n@@ -15,13 \u002B15,20 @@\n #include \u003Cgtest/gtest.h\u003E\n \n #include \u003Cchrono\u003E\n\u002B#include \u003Cfuture\u003E\n #include \u003Cmemory\u003E\n\u002B#include \u003Cstdexcept\u003E\n \n #include \u0022rclcpp/exceptions.hpp\u0022\n #include \u0022rclcpp/node.hpp\u0022\n #include \u0022rclcpp/rclcpp.hpp\u0022\n #include \u0022rclcpp/executors.hpp\u0022\n \n\u002B#include \u0022test_msgs/srv/empty.hpp\u0022\n\u002B\n\u002B#include \u0022../../mocking_utils/patch.hpp\u0022\n\u002B#include \u0022../../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n using namespace std::chrono_literals;\n \n class TestStaticSingleThreadedExecutor : public ::testing::Test\n@@ -47,3 \u002B54,99 @@ TEST_F(TestStaticSingleThreadedExecutor, check_unimplemented) {\n   EXPECT_THROW(executor.spin_all(0ns), rclcpp::exceptions::UnimplementedError);\n   EXPECT_THROW(executor.spin_once(0ns), rclcpp::exceptions::UnimplementedError);\n }\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, add_callback_group_trigger_guard_failed) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_trigger_guard_condition, RCL_RET_ERROR);\n\u002B    RCLCPP_EXPECT_THROW_EQ(\n\u002B      executor.add_callback_group(cb_group, node-\u003Eget_node_base_interface(), true),\n\u002B      std::runtime_error(\u0022error not set\u0022));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, add_node_trigger_guard_failed) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_trigger_guard_condition, RCL_RET_ERROR);\n\u002B    RCLCPP_EXPECT_THROW_EQ(\n\u002B      executor.add_node(node),\n\u002B      std::runtime_error(\u0022error not set\u0022));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, remove_callback_group_trigger_guard_failed) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  rclcpp::CallbackGroup::SharedPtr cb_group = node-\u003Ecreate_callback_group(\n\u002B    rclcpp::CallbackGroupType::MutuallyExclusive);\n\u002B\n\u002B  executor.add_callback_group(cb_group, node-\u003Eget_node_base_interface(), true);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_trigger_guard_condition, RCL_RET_ERROR);\n\u002B    RCLCPP_EXPECT_THROW_EQ(\n\u002B      executor.remove_callback_group(cb_group, true),\n\u002B      std::runtime_error(\u0022error not set\u0022));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, remove_node_failed) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_trigger_guard_condition, RCL_RET_ERROR);\n\u002B    RCLCPP_EXPECT_THROW_EQ(\n\u002B      executor.remove_node(node, true),\n\u002B      std::runtime_error(\u0022Node needs to be associated with this executor.\u0022));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, remove_node_trigger_guard_failed) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  executor.add_node(node);\n\u002B\n\u002B  {\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_trigger_guard_condition, RCL_RET_ERROR);\n\u002B    RCLCPP_EXPECT_THROW_EQ(\n\u002B      executor.remove_node(node, true),\n\u002B      std::runtime_error(\u0022error not set\u0022));\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestStaticSingleThreadedExecutor, execute_service) {\n\u002B  rclcpp::executors::StaticSingleThreadedExecutor executor;\n\u002B  auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n\u002B  executor.add_node(node);\n\u002B\n\u002B  auto service =\n\u002B    node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n\u002B    \u0022service\u0022,\n\u002B    [](\n\u002B      const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B      test_msgs::srv::Empty::Response::SharedPtr) {});\n\u002B  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022service\u0022);\n\u002B\n\u002B  std::promise\u003Cvoid\u003E promise;\n\u002B  std::future\u003Cvoid\u003E future = promise.get_future();\n\u002B  EXPECT_EQ(\n\u002B    rclcpp::FutureReturnCode::TIMEOUT,\n\u002B    executor.spin_until_future_complete(future, std::chrono::milliseconds(1)));\n\u002B\n\u002B  executor.remove_node(node);\n\u002B  executor.spin_until_future_complete(future, std::chrono::milliseconds(1));\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "24d9f0c425b8a621daf4131c0bdd8cd9c175063d",
    "RawMessage": "Use the correct type for BufferClient timeout_padding. (#498)",
    "Changes": "diff --git tf2_ros_py/test/test_buffer_client.py tf2_ros_py/test/test_buffer_client.py\nindex e83b02c6..3b1447dc 100644\n--- tf2_ros_py/test/test_buffer_client.py\n\u002B\u002B\u002B tf2_ros_py/test/test_buffer_client.py\n@@ -127,7 \u002B127,7 @@ class TestBufferClient(unittest.TestCase):\n \n     def test_lookup_transform_true(self):\n         buffer_client = BufferClient(\n-            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=0.0)\n\u002B            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))\n \n         result = buffer_client.lookup_transform(\n             \u0027foo\u0027, \u0027bar\u0027, rclpy.time.Time(), rclpy.duration.Duration(seconds=5.0))\n@@ -137,7 \u002B137,7 @@ class TestBufferClient(unittest.TestCase):\n \n     def test_lookup_transform_fail(self):\n         buffer_client = BufferClient(\n-            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=0.0)\n\u002B            self.node, \u0027lookup_transform\u0027, check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))\n \n         with self.assertRaises(LookupException) as ex:\n             result = buffer_client.lookup_transform(\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_python",
    "SHA": "e665ade741acdc52890b4e019d7018a48bfe39b7",
    "RawMessage": "Support available typesupport specification in CLI extension (#133)",
    "Changes": "diff --git rosidl_generator_py/CMakeLists.txt rosidl_generator_py/CMakeLists.txt\nindex 5f74d58..fb7fba5 100644\n--- rosidl_generator_py/CMakeLists.txt\n\u002B\u002B\u002B rosidl_generator_py/CMakeLists.txt\n@@ -76,11 \u002B76,11 @@ if(BUILD_TESTING)\n       APPEND_LIBRARY_DIRS \u0022${_append_library_dirs}\u0022\n       WORKING_DIRECTORY \u0022${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py\u0022\n     )\n-  endif()\n \n-  ament_add_pytest_test(test_cli_extension test/test_cli_extension.py\n-    PYTHON_EXECUTABLE \u0022${BUILDTYPE_PYTHON_EXECUTABLE}\u0022\n-  )\n\u002B    ament_add_pytest_test(test_cli_extension test/test_cli_extension.py\n\u002B      PYTHON_EXECUTABLE \u0022${BUILDTYPE_PYTHON_EXECUTABLE}\u0022\n\u002B    )\n\u002B  endif()\n endif()\n \n ament_package(\ndiff --git rosidl_generator_py/rosidl_generator_py/cli.py rosidl_generator_py/rosidl_generator_py/cli.py\nindex bec5483..b1d3762 100644\n--- rosidl_generator_py/rosidl_generator_py/cli.py\n\u002B\u002B\u002B rosidl_generator_py/rosidl_generator_py/cli.py\n@@ -26,6 \u002B26,14 @@ from rosidl_generator_py import generate_py\n \n class GeneratePython(GenerateCommandExtension):\n \n\u002B    def __init__(self, name, *, typesupport_implementations=None):\n\u002B        super().__init__(name)\n\u002B        if typesupport_implementations is None:\n\u002B            typesupport_implementations = [\u0027rosidl_typesupport_c\u0027]\n\u002B            typesupport_implementations.extend(\n\u002B                get_resources(\u0027rosidl_typesupport_c\u0027))\n\u002B        self.__typesupport_implementations = typesupport_implementations\n\u002B\n     def generate(\n         self,\n         package_name,\n@@ -55,10 \u002B63,6 @@ class GeneratePython(GenerateCommandExtension):\n             ))\n \n         # Generate code\n-        typesupport_implementations = [\u0027rosidl_typesupport_c\u0027]\n-        typesupport_implementations.extend(\n-            get_resources(\u0027rosidl_typesupport_c\u0027)\n-        )\n         with legacy_generator_arguments_file(\n             package_name=package_name,\n             interface_files=idl_interface_files,\n@@ -68,4 \u002B72,4 @@ class GeneratePython(GenerateCommandExtension):\n         ) as path_to_arguments_file:\n             return generate_py(\n                 path_to_arguments_file,\n-                typesupport_implementations)\n\u002B                self.__typesupport_implementations)\ndiff --git rosidl_generator_py/test/test_cli_extension.py rosidl_generator_py/test/test_cli_extension.py\nindex 1fe51b2..bcc5fbb 100644\n--- rosidl_generator_py/test/test_cli_extension.py\n\u002B\u002B\u002B rosidl_generator_py/test/test_cli_extension.py\n@@ -14,15 \u002B14,33 @@\n \n import pathlib\n \n\u002Bfrom ament_index_python import get_resources\n from rosidl_cli.command.generate.api import generate\n \n PACKAGE_DIR = str(pathlib.Path(__file__).parent.parent)\n \n \n-def test_cli_extension_for_smoke(tmp_path):\n-    generate(\n-        package_name=\u0027rosidl_generator_py\u0027,\n-        interface_files=[PACKAGE_DIR \u002B \u0027:msg/StringArrays.msg\u0027],\n-        types=[\u0027py\u0027],\n-        output_path=tmp_path\n-    )\n\u002Bdef test_cli_extension_for_smoke(tmp_path, capsys):\n\u002B    # NOTE(hidmic): pytest and empy do not play along,\n\u002B    # the latter expects some proxy will stay in sys.stdout\n\u002B    # and the former insists in overwriting it\n\u002B    interface_files = [PACKAGE_DIR \u002B \u0027:msg/StringArrays.msg\u0027]\n\u002B\n\u002B    with capsys.disabled():  # so do everything in one run\n\u002B        # Passing target typesupport implementations explictly\n\u002B        generate(\n\u002B            package_name=\u0027rosidl_typesupport_py\u0027,\n\u002B            interface_files=interface_files,\n\u002B            types=[\u0027py[typesupport_implementations:{}]\u0027.format(\n\u002B                list(get_resources(\u0027rosidl_typesupport_c\u0027))\n\u002B            )],\n\u002B            output_path=tmp_path / \u0027explicit_args\u0027\n\u002B        )\n\u002B\n\u002B        # Using default typesupport implementations\n\u002B        generate(\n\u002B            package_name=\u0027rosidl_typesupport_pu\u0027,\n\u002B            interface_files=interface_files,\n\u002B            types=[\u0027py\u0027],\n\u002B            output_path=tmp_path / \u0027defaults\u0027\n\u002B        )\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "9517aaca9e8cc4aa8fa0e34aa302d36f67073121",
    "RawMessage": "Remove CODEOWNERS and mirror-rolling-to-master workflow. (#523)",
    "Changes": "diff --git .github/workflows/mirror-rolling-to-master.yaml .github/workflows/mirror-rolling-to-master.yaml\ndeleted file mode 100644\nindex 2885eb4..0000000\n--- .github/workflows/mirror-rolling-to-master.yaml\n\u002B\u002B\u002B /dev/null\n@@ -1,13 \u002B0,0 @@\n-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master\ndiff --git CODEOWNERS CODEOWNERS\ndeleted file mode 100644\nindex 99b9e56..0000000\n--- CODEOWNERS\n\u002B\u002B\u002B /dev/null\n@@ -1,2 \u002B0,0 @@\n-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @eboasson @ivanpauno \n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "ba50353749e212a89750b592a0775a0eb96d7ce1",
    "RawMessage": "Update the LoanManager to do internal locking. (#552)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/rmw_take.cpp rmw_fastrtps_shared_cpp/src/rmw_take.cpp\nindex ac37033..4474712 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_take.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_take.cpp\n@@ -13,6 \u002B13,7 @@\n // limitations under the License.\n \n #include \u003Cmemory\u003E\n\u002B#include \u003Cutility\u003E\n \n #include \u0022rmw/allocators.h\u0022\n #include \u0022rmw/error_handling.h\u0022\n@@ -401,8 \u002B402,32 @@ struct LoanManager\n   {\n   }\n \n\u002B  void add_item(std::unique_ptr\u003CItem\u003E item)\n\u002B  {\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(mtx);\n\u002B    items.push_back(std::move(item));\n\u002B  }\n\u002B\n\u002B  std::unique_ptr\u003CItem\u003E erase_item(void * loaned_message)\n\u002B  {\n\u002B    std::unique_ptr\u003CItem\u003E ret{nullptr};\n\u002B\n\u002B    std::lock_guard\u003Cstd::mutex\u003E guard(mtx);\n\u002B    for (auto it = items.begin(); it != items.end(); \u002B\u002Bit) {\n\u002B      if (loaned_message == (*it)-\u003Edata_seq.buffer()[0]) {\n\u002B        ret = std::move(*it);\n\u002B        items.erase(it);\n\u002B        break;\n\u002B      }\n\u002B    }\n\u002B\n\u002B    return ret;\n\u002B  }\n\u002B\n\u002Bprivate:\n   std::mutex mtx;\n-  eprosima::fastrtps::ResourceLimitedVector\u003CItem\u003E items RCPPUTILS_TSA_GUARDED_BY(mtx);\n\u002B  using ItemVector = eprosima::fastrtps::ResourceLimitedVector\u003Cstd::unique_ptr\u003CItem\u003E\u003E;\n\u002B  ItemVector items RCPPUTILS_TSA_GUARDED_BY(mtx);\n };\n \n void\n@@ -440,13 \u002B465,8 @@ __rmw_take_loaned_message_internal(\n   RMW_CHECK_ARGUMENT_FOR_NULL(taken, RMW_RET_INVALID_ARGUMENT);\n \n   auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n-  auto loan_mgr = info-\u003Eloan_manager_;\n-  std::unique_lock\u003Cstd::mutex\u003E guard(loan_mgr-\u003Emtx);\n-  auto item = loan_mgr-\u003Eitems.emplace_back();\n-  if (nullptr == item) {\n-    RMW_SET_ERROR_MSG(\u0022Out of resources for loaned message info\u0022);\n-    return RMW_RET_ERROR;\n-  }\n\u002B\n\u002B  auto item = std::make_unique\u003Crmw_fastrtps_shared_cpp::LoanManager::Item\u003E();\n \n   while (ReturnCode_t::RETCODE_OK == info-\u003Edata_reader_-\u003Etake(item-\u003Edata_seq, item-\u003Einfo_seq, 1)) {\n     if (item-\u003Einfo_seq[0].valid_data) {\n@@ -456,6 \u002B476,9 @@ __rmw_take_loaned_message_internal(\n       *loaned_message = item-\u003Edata_seq.buffer()[0];\n       *taken = true;\n       info-\u003Elistener_-\u003Eupdate_has_data(info-\u003Edata_reader_);\n\u002B\n\u002B      info-\u003Eloan_manager_-\u003Eadd_item(std::move(item));\n\u002B\n       return RMW_RET_OK;\n     }\n \n@@ -464,7 \u002B487,6 @@ __rmw_take_loaned_message_internal(\n   }\n \n   // No data available, return loan information.\n-  loan_mgr-\u003Eitems.pop_back();\n   *taken = false;\n   info-\u003Elistener_-\u003Eupdate_has_data(info-\u003Edata_reader_);\n   return RMW_RET_OK;\n@@ -487,17 \u002B509,15 @@ __rmw_return_loaned_message_from_subscription(\n   RMW_CHECK_ARGUMENT_FOR_NULL(loaned_message, RMW_RET_INVALID_ARGUMENT);\n \n   auto info = static_cast\u003CCustomSubscriberInfo *\u003E(subscription-\u003Edata);\n-  auto loan_mgr = info-\u003Eloan_manager_;\n-  std::lock_guard\u003Cstd::mutex\u003E guard(loan_mgr-\u003Emtx);\n-  for (auto it = loan_mgr-\u003Eitems.begin(); it != loan_mgr-\u003Eitems.end(); \u002B\u002Bit) {\n-    if (loaned_message == it-\u003Edata_seq.buffer()[0]) {\n-      if (!info-\u003Edata_reader_-\u003Ereturn_loan(it-\u003Edata_seq, it-\u003Einfo_seq)) {\n-        RMW_SET_ERROR_MSG(\u0022Error returning loan\u0022);\n-        return RMW_RET_ERROR;\n-      }\n-      loan_mgr-\u003Eitems.erase(it);\n-      return RMW_RET_OK;\n\u002B  std::unique_ptr\u003Crmw_fastrtps_shared_cpp::LoanManager::Item\u003E item;\n\u002B  item = info-\u003Eloan_manager_-\u003Eerase_item(loaned_message);\n\u002B  if (item != nullptr) {\n\u002B    if (!info-\u003Edata_reader_-\u003Ereturn_loan(item-\u003Edata_seq, item-\u003Einfo_seq)) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Error returning loan\u0022);\n\u002B      return RMW_RET_ERROR;\n     }\n\u002B\n\u002B    return RMW_RET_OK;\n   }\n \n   RMW_SET_ERROR_MSG(\u0022Trying to return message not loaned by this subscription\u0022);\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "77ef0aa73268a95ae76311f44cd0a58d9febe297",
    "RawMessage": "Yield rcl_context_fini() error codes. (#763)",
    "Changes": "diff --git rcl/src/rcl/context.c rcl/src/rcl/context.c\nindex 3a8c6ee..0624f0f 100644\n--- rcl/src/rcl/context.c\n\u002B\u002B\u002B rcl/src/rcl/context.c\n@@ -21,6 \u002B21,7 @@ extern \u0022C\u0022\n \n #include \u003Cstdbool.h\u003E\n \n\u002B#include \u0022./common.h\u0022\n #include \u0022./context_impl.h\u0022\n #include \u0022rcutils/stdatomic_helper.h\u0022\n \n@@ -56,8 \u002B57,7 @@ rcl_context_fini(rcl_context_t * context)\n   }\n   RCL_CHECK_ALLOCATOR_WITH_MSG(\n     \u0026(context-\u003Eimpl-\u003Eallocator), \u0022invalid allocator\u0022, return RCL_RET_INVALID_ARGUMENT);\n-  __cleanup_context(context);\n-  return RCL_RET_OK;\n\u002B  return __cleanup_context(context);\n }\n \n // See \u0060rcl_shutdown()\u0060 for invalidation of the context.\n@@ -103,15 \u002B103,16 @@ rcl_context_get_rmw_context(rcl_context_t * context)\n   return \u0026(context-\u003Eimpl-\u003Ermw_context);\n }\n \n-void\n\u002Brcl_ret_t\n __cleanup_context(rcl_context_t * context)\n {\n\u002B  rcl_ret_t ret = RCL_RET_OK;\n   // reset the instance id to 0 to indicate \u0022invalid\u0022 (should already be 0, but this is defensive)\n   rcutils_atomic_store((atomic_uint_least64_t *)(\u0026context-\u003Einstance_id_storage), 0);\n \n   // clean up global_arguments if initialized\n   if (NULL != context-\u003Eglobal_arguments.impl) {\n-    rcl_ret_t ret = rcl_arguments_fini(\u0026(context-\u003Eglobal_arguments));\n\u002B    ret = rcl_arguments_fini(\u0026(context-\u003Eglobal_arguments));\n     if (RCL_RET_OK != ret) {\n       RCUTILS_SAFE_FWRITE_TO_STDERR(\n         \u0022[rcl|context.c:\u0022 RCUTILS_STRINGIFY(__LINE__)\n@@ -129,8 \u002B130,11 @@ __cleanup_context(rcl_context_t * context)\n \n     // finalize init options if valid\n     if (NULL != context-\u003Eimpl-\u003Einit_options.impl) {\n-      rcl_ret_t ret = rcl_init_options_fini(\u0026(context-\u003Eimpl-\u003Einit_options));\n-      if (RCL_RET_OK != ret) {\n\u002B      rcl_ret_t init_options_fini_ret = rcl_init_options_fini(\u0026(context-\u003Eimpl-\u003Einit_options));\n\u002B      if (RCL_RET_OK != init_options_fini_ret) {\n\u002B        if (RCL_RET_OK == ret) {\n\u002B          ret = init_options_fini_ret;\n\u002B        }\n         RCUTILS_SAFE_FWRITE_TO_STDERR(\n           \u0022[rcl|context.c:\u0022 RCUTILS_STRINGIFY(__LINE__)\n           \u0022] failed to finalize init options while cleaning up context, memory may be leaked: \u0022);\n@@ -142,8 \u002B146,11 @@ __cleanup_context(rcl_context_t * context)\n \n     // clean up rmw_context\n     if (NULL != context-\u003Eimpl-\u003Ermw_context.implementation_identifier) {\n-      rmw_ret_t rmw_ret = rmw_context_fini(\u0026(context-\u003Eimpl-\u003Ermw_context));\n-      if (RMW_RET_OK != rmw_ret) {\n\u002B      rmw_ret_t rmw_context_fini_ret = rmw_context_fini(\u0026(context-\u003Eimpl-\u003Ermw_context));\n\u002B      if (RMW_RET_OK != rmw_context_fini_ret) {\n\u002B        if (RCL_RET_OK == ret) {\n\u002B          ret = rcl_convert_rmw_ret_to_rcl_ret(rmw_context_fini_ret);\n\u002B        }\n         RCUTILS_SAFE_FWRITE_TO_STDERR(\n           \u0022[rcl|context.c:\u0022 RCUTILS_STRINGIFY(__LINE__)\n           \u0022] failed to finalize rmw context while cleaning up context, memory may be leaked: \u0022);\n@@ -168,6 \u002B175,8 @@ __cleanup_context(rcl_context_t * context)\n \n   // zero-initialize the context\n   *context = rcl_get_zero_initialized_context();\n\u002B\n\u002B  return ret;\n }\n \n #ifdef __cplusplus\ndiff --git rcl/src/rcl/context_impl.h rcl/src/rcl/context_impl.h\nindex 79741e3..08403c0 100644\n--- rcl/src/rcl/context_impl.h\n\u002B\u002B\u002B rcl/src/rcl/context_impl.h\n@@ -41,7 \u002B41,7 @@ typedef struct rcl_context_impl_t\n } rcl_context_impl_t;\n \n RCL_LOCAL\n-void\n\u002Brcl_ret_t\n __cleanup_context(rcl_context_t * context);\n \n #ifdef __cplusplus\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rcl",
    "SHA": "62871dd479062967584f1d7e0202abc36c8512cb",
    "RawMessage": "Remove AMENT_DEPENDENCIES from rcl_add_custom_gtest. (#1119)",
    "Changes": "diff --git rcl/test/cmake/rcl_add_custom_gtest.cmake rcl/test/cmake/rcl_add_custom_gtest.cmake\nindex 0ebe4bd..da24cd4 100644\n--- rcl/test/cmake/rcl_add_custom_gtest.cmake\n\u002B\u002B\u002B rcl/test/cmake/rcl_add_custom_gtest.cmake\n@@ -21,9 \u002B21,8 @@ set(rcl_add_custom_gtest_INCLUDED TRUE)\n # Custom macro for adding a gtest in rcl.\n #\n # It also takes some of the arguments of ament_add_gtest as well as\n-# INCLUDE_DIRS, LIBRARIES, and AMENT_DEPENDENCIES which are passed to\n-# target_include_directories(), target_link_libraries(), and\n-# ament_target_dependencies() respectively.\n\u002B# INCLUDE_DIRS and LIBRARIES which are passed to\n\u002B# target_include_directories() and target_link_libraries(), respectively.\n #\n # :param target: the target name which will also be used as the test name\n # :type target: string\n@@ -41,8 \u002B40,6 @@ set(rcl_add_custom_gtest_INCLUDED TRUE)\n # :type INCLUDE_DIRS: list of strings\n # :param LIBRARIES: list of libraries to link to the target\n # :type LIBRARIES: list of strings\n-# :param AMENT_DEPENDENCIES: list of depends to pass ament_target_dependencies\n-# :type AMENT_DEPENDENCIES: list of strings\n #\n # @public\n #\n@@ -50,7 \u002B47,7 @@ macro(rcl_add_custom_gtest target)\n   cmake_parse_arguments(_ARG\n     \u0022SKIP_TEST;TRACE\u0022\n     \u0022TIMEOUT\u0022\n-    \u0022SRCS;ENV;APPEND_ENV;APPEND_LIBRARY_DIRS;INCLUDE_DIRS;LIBRARIES;AMENT_DEPENDENCIES\u0022\n\u002B    \u0022SRCS;ENV;APPEND_ENV;APPEND_LIBRARY_DIRS;INCLUDE_DIRS;LIBRARIES\u0022\n     ${ARGN})\n   if(_ARG_UNPARSED_ARGUMENTS)\n     message(FATAL_ERROR \u0022rcl_add_custom_gtest() called with unused arguments: ${_ARG_UNPARSED_ARGUMENTS}\u0022)\n@@ -95,13 \u002B92,6 @@ macro(rcl_add_custom_gtest target)\n       endif()\n       target_link_libraries(${target} ${_ARG_LIBRARIES})\n     endif()\n-    # Add extra ament dependencies, if any.\n-    if(_ARG_AMENT_DEPENDENCIES)\n-      if(_ARG_TRACE)\n-        message(STATUS \u0022  rcl_add_custom_gtest() AMENT_DEPENDENCIES: ${_ARG_AMENT_DEPENDENCIES}\u0022)\n-      endif()\n-      ament_target_dependencies(${target} ${_ARG_AMENT_DEPENDENCIES})\n-    endif()\n     target_compile_definitions(${target}\n       PUBLIC \u0022RMW_IMPLEMENTATION=${rmw_implementation}\u0022)\n   endif()\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "f7185dc129c40388e66813c96f2ac5dbb73ffe00",
    "RawMessage": "Fixup Executor::spin_all() regression fix (#2517)",
    "Changes": "diff --git rclcpp/src/rclcpp/executor.cpp rclcpp/src/rclcpp/executor.cpp\nindex 42a4d274..95b0d7fc 100644\n--- rclcpp/src/rclcpp/executor.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/executor.cpp\n@@ -366,24 \u002B366,52 @@ Executor::spin_some_impl(std::chrono::nanoseconds max_duration, bool exhaustive)\n   }\n   RCPPUTILS_SCOPE_EXIT(this-\u003Espinning.store(false); );\n \n\u002B  // clear the wait result and wait for work without blocking to collect the work\n\u002B  // for the first time\n\u002B  // both spin_some and spin_all wait for work at the beginning\n\u002B  wait_result_.reset();\n\u002B  wait_for_work(std::chrono::milliseconds(0));\n\u002B  bool just_waited = true;\n\u002B\n\u002B  // The logic of this while loop is as follows:\n\u002B  //\n\u002B  // - while not shutdown, and spinning (not canceled), and not max duration reached...\n\u002B  // - try to get an executable item to execute, and execute it if available\n\u002B  // - otherwise, reset the wait result, and ...\n\u002B  // - if there was no work available just after waiting, break the loop unconditionally\n\u002B  //   - this is appropriate for both spin_some and spin_all which use this function\n\u002B  // - else if exhaustive = true, then wait for work again\n\u002B  //   - this is only used for spin_all and not spin_some\n\u002B  // - else break\n\u002B  //   - this only occurs with spin_some\n\u002B  //\n\u002B  // The logic of this loop is subtle and should be carefully changed if at all.\n\u002B  // See also:\n\u002B  //   https://github.com/ros2/rclcpp/issues/2508\n\u002B  //   https://github.com/ros2/rclcpp/pull/2517\n   while (rclcpp::ok(context_) \u0026\u0026 spinning.load() \u0026\u0026 max_duration_not_elapsed()) {\n-    if (!wait_result_.has_value()) {\n-      wait_for_work(std::chrono::milliseconds(0));\n-    }\n-\n     AnyExecutable any_exec;\n     if (get_next_ready_executable(any_exec)) {\n       execute_any_executable(any_exec);\n\u002B      just_waited = false;\n     } else {\n-      // If nothing is ready, reset the result to signal we are\n-      // ready to wait again\n\u002B      // if nothing is ready, reset the result to clear it\n       wait_result_.reset();\n-    }\n \n-    if (!wait_result_.has_value() \u0026\u0026 !exhaustive) {\n-      // In the case of spin some, then we can exit\n-      // In the case of spin all, then we will allow ourselves to wait again.\n-      break;\n\u002B      if (just_waited) {\n\u002B        // there was no work after just waiting, always exit in this case\n\u002B        // before the exhaustive condition can be checked\n\u002B        break;\n\u002B      }\n\u002B\n\u002B      if (exhaustive) {\n\u002B        // if exhaustive, wait for work again\n\u002B        // this only happens for spin_all; spin_some only waits at the start\n\u002B        wait_for_work(std::chrono::milliseconds(0));\n\u002B        just_waited = true;\n\u002B      } else {\n\u002B        break;\n\u002B      }\n     }\n   }\n }\ndiff --git rclcpp/test/rclcpp/executors/test_executors.cpp rclcpp/test/rclcpp/executors/test_executors.cpp\nindex 1a538eaa..a82b702d 100644\n--- rclcpp/test/rclcpp/executors/test_executors.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_executors.cpp\n@@ -357,6 \u002B357,7 @@ public:\n   bool\n   is_ready(const rcl_wait_set_t \u0026 wait_set) override\n   {\n\u002B    is_ready_count_\u002B\u002B;\n     for (size_t i = 0; i \u003C wait_set.size_of_guard_conditions; \u002B\u002Bi) {\n       auto rcl_guard_condition = wait_set.guard_conditions[i];\n       if (\u0026gc_.get_rcl_guard_condition() == rcl_guard_condition) {\n@@ -424,8 \u002B425,15 @@ public:\n     return count_;\n   }\n \n\u002B  size_t\n\u002B  get_is_ready_call_count() const\n\u002B  {\n\u002B    return is_ready_count_;\n\u002B  }\n\u002B\n private:\n   std::atomic\u003Csize_t\u003E trigger_count_ = 0;\n\u002B  std::atomic\u003Csize_t\u003E is_ready_count_ = 0;\n   std::atomic\u003Csize_t\u003E count_ = 0;\n   rclcpp::GuardCondition gc_;\n   std::function\u003Cvoid()\u003E on_execute_callback_ = nullptr;\n@@ -869,3 \u002B877,155 @@ TEST(TestExecutors, testSpinWithNonDefaultContext)\n \n   rclcpp::shutdown(non_default_context);\n }\n\u002B\n\u002Btemplate\u003Ctypename T\u003E\n\u002Bclass TestBusyWaiting : public ::testing::Test\n\u002B{\n\u002Bpublic:\n\u002B  void SetUp() override\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B\n\u002B    const auto test_info = ::testing::UnitTest::GetInstance()-\u003Ecurrent_test_info();\n\u002B    std::stringstream test_name;\n\u002B    test_name \u003C\u003C test_info-\u003Etest_case_name() \u003C\u003C \u0022_\u0022 \u003C\u003C test_info-\u003Ename();\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, test_name.str());\n\u002B    callback_group = node-\u003Ecreate_callback_group(\n\u002B      rclcpp::CallbackGroupType::MutuallyExclusive,\n\u002B      /* automatically_add_to_executor_with_node =*/ false);\n\u002B\n\u002B    auto waitable_interfaces = node-\u003Eget_node_waitables_interface();\n\u002B    waitable = std::make_shared\u003CTestWaitable\u003E();\n\u002B    waitable_interfaces-\u003Eadd_waitable(waitable, callback_group);\n\u002B\n\u002B    executor = std::make_shared\u003CT\u003E();\n\u002B    executor-\u003Eadd_callback_group(callback_group, node-\u003Eget_node_base_interface());\n\u002B  }\n\u002B\n\u002B  void TearDown() override\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void\n\u002B  set_up_and_trigger_waitable(std::function\u003Cvoid()\u003E extra_callback = nullptr)\n\u002B  {\n\u002B    this-\u003Ehas_executed = false;\n\u002B    this-\u003Ewaitable-\u003Eset_on_execute_callback([this, extra_callback]() {\n\u002B        if (!this-\u003Ehas_executed) {\n\u002B        // trigger once to see if the second trigger is handled or not\n\u002B        // this follow up trigger simulates new entities becoming ready while\n\u002B        // the executor is executing something else, e.g. subscription got data\n\u002B        // or a timer expired, etc.\n\u002B        // spin_some would not handle this second trigger, since it collects\n\u002B        // work only once, whereas spin_all should handle it since it\n\u002B        // collects work multiple times\n\u002B          this-\u003Ewaitable-\u003Etrigger();\n\u002B          this-\u003Ehas_executed = true;\n\u002B        }\n\u002B        if (nullptr != extra_callback) {\n\u002B          extra_callback();\n\u002B        }\n\u002B    });\n\u002B    this-\u003Ewaitable-\u003Etrigger();\n\u002B  }\n\u002B\n\u002B  void\n\u002B  check_for_busy_waits(std::chrono::steady_clock::time_point start_time)\n\u002B  {\n\u002B    // rough time based check, since the work to be done was very small it\n\u002B    // should be safe to check that we didn\u0027t use more than half the\n\u002B    // max duration, which itself is much larger than necessary\n\u002B    // however, it could still produce a false-positive\n\u002B    EXPECT_LT(\n\u002B      std::chrono::steady_clock::now() - start_time,\n\u002B      max_duration / 2)\n\u002B      \u003C\u003C \u0022executor took a long time to execute when it should have done \u0022\n\u002B      \u003C\u003C \u0022nothing and should not have blocked either, but this could be a \u0022\n\u002B      \u003C\u003C \u0022false negative if the computer is really slow\u0022;\n\u002B\n\u002B    // this check is making some assumptions about the implementation of the\n\u002B    // executors, but it should be safe to say that a busy wait may result in\n\u002B    // hundreds or thousands of calls to is_ready(), but \u0022normal\u0022 executor\n\u002B    // behavior should be within an order of magnitude of the number of\n\u002B    // times that the waitable was executed\n\u002B    ASSERT_LT(waitable-\u003Eget_is_ready_call_count(), 10u * this-\u003Ewaitable-\u003Eget_count());\n\u002B  }\n\u002B\n\u002B  static constexpr auto max_duration = 10s;\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B  rclcpp::CallbackGroup::SharedPtr callback_group;\n\u002B  std::shared_ptr\u003CTestWaitable\u003E waitable;\n\u002B  std::chrono::steady_clock::time_point start_time;\n\u002B  std::shared_ptr\u003CT\u003E executor;\n\u002B  bool has_executed;\n\u002B};\n\u002B\n\u002BTYPED_TEST_SUITE(TestBusyWaiting, ExecutorTypes, ExecutorTypeNames);\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin_all)\n\u002B{\n\u002B  this-\u003Eset_up_and_trigger_waitable();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  this-\u003Eexecutor-\u003Espin_all(this-\u003Emax_duration);\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the initial trigger, and the follow up from in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin_some)\n\u002B{\n\u002B  this-\u003Eset_up_and_trigger_waitable();\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  this-\u003Eexecutor-\u003Espin_some(this-\u003Emax_duration);\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the inital trigger, but not the follow up in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 1u);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestBusyWaiting, test_spin)\n\u002B{\n\u002B  std::condition_variable cv;\n\u002B  std::mutex cv_m;\n\u002B  bool first_check_passed = false;\n\u002B\n\u002B  this-\u003Eset_up_and_trigger_waitable([\u0026cv, \u0026cv_m, \u0026first_check_passed]() {\n\u002B      cv.notify_one();\n\u002B      if (!first_check_passed) {\n\u002B        std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B        cv.wait_for(lk, 1s, [\u0026]() {return first_check_passed;});\n\u002B      }\n\u002B  });\n\u002B\n\u002B  auto start_time = std::chrono::steady_clock::now();\n\u002B  std::thread t([this]() {\n\u002B      this-\u003Eexecutor-\u003Espin();\n\u002B    });\n\u002B\n\u002B  // wait until thread has started (first execute of waitable)\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B    cv.wait_for(lk, 10s);\n\u002B  }\n\u002B  EXPECT_GT(this-\u003Ewaitable-\u003Eget_count(), 0u);\n\u002B\n\u002B  first_check_passed = true;\n\u002B  cv.notify_one();\n\u002B\n\u002B  // wait until the executor has finished (second execute of waitable)\n\u002B  {\n\u002B    std::unique_lock\u003Cstd::mutex\u003E lk(cv_m);\n\u002B    cv.wait_for(lk, 10s);\n\u002B  }\n\u002B  EXPECT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B\n\u002B  this-\u003Eexecutor-\u003Ecancel();\n\u002B  t.join();\n\u002B\n\u002B  this-\u003Echeck_for_busy_waits(start_time);\n\u002B  // this should get the initial trigger, and the follow up from in the callback\n\u002B  ASSERT_EQ(this-\u003Ewaitable-\u003Eget_count(), 2u);\n\u002B}\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "d52133d49e77228e91dfc80831c938fb9d87ae75",
    "RawMessage": "to create a sublogger while getting child of Logger (#1084)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex b01509c..1b1c12f 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -188,6 \u002B188,7 @@ if(BUILD_TESTING)\n       test/test_qos_event.py\n       test/test_qos_overriding_options.py\n       test/test_rate.py\n\u002B      test/test_rosout_subscription.py\n       test/test_serialization.py\n       test/test_subscription.py\n       test/test_task.py\ndiff --git rclpy/rclpy/impl/rcutils_logger.py rclpy/rclpy/impl/rcutils_logger.py\nindex f94a44d..b8d999a 100644\n--- rclpy/rclpy/impl/rcutils_logger.py\n\u002B\u002B\u002B rclpy/rclpy/impl/rcutils_logger.py\n@@ -215,15 \u002B215,30 @@ class RcutilsLogger:\n \n     def __init__(self, name=\u0027\u0027):\n         self.name = name\n\u002B        self.logger_sublogger_namepair = None\n         self.contexts = {}\n \n\u002B    def __del__(self):\n\u002B        if self.logger_sublogger_namepair:\n\u002B            _rclpy.rclpy_logging_rosout_remove_sublogger(\n\u002B                self.logger_sublogger_namepair[0], self.logger_sublogger_namepair[1])\n\u002B            self.logger_sublogger_namepair = None\n\u002B\n     def get_child(self, name):\n         if not name:\n             raise ValueError(\u0027Child logger name must not be empty.\u0027)\n\u002B\n         if self.name:\n             # Prepend the name of this logger\n-            name = self.name \u002B \u0027.\u0027 \u002B name\n-        return RcutilsLogger(name=name)\n\u002B            _rclpy.rclpy_logging_rosout_add_sublogger(self.name, name)\n\u002B            fullname = self.name \u002B _rclpy.rclpy_logging_get_separator_string() \u002B name\n\u002B        else:\n\u002B            fullname = name\n\u002B\n\u002B        logger = RcutilsLogger(name=fullname)\n\u002B        if self.name:\n\u002B            logger.logger_sublogger_namepair = (self.name, name)\n\u002B        return logger\n \n     def set_level(self, level):\n         level = LoggingSeverity(level)\ndiff --git rclpy/src/rclpy/_rclpy_logging.cpp rclpy/src/rclpy/_rclpy_logging.cpp\nindex c510b0a..01e61c3 100644\n--- rclpy/src/rclpy/_rclpy_logging.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_logging.cpp\n@@ -21,10 \u002B21,12 @@ namespace py = pybind11;\n #include \u003Crcutils/logging.h\u003E\n \n #include \u003Crcl_logging_interface/rcl_logging_interface.h\u003E\n\u002B#include \u003Crcl/logging_rosout.h\u003E\n \n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n \n\u002B#include \u0022logging.hpp\u0022\n #include \u0022logging_api.hpp\u0022\n \n /// Initialize the logging system.\n@@ -172,6 \u002B174,30 @@ rclpy_logging_get_logging_directory()\n   return s_log_dir;\n }\n \n\u002B/// Add a subordinate logger based on a logger\n\u002Bvoid\n\u002Brclpy_logging_rosout_add_sublogger(const char * logger_name, const char * sublogger_name)\n\u002B{\n\u002B  rclpy::LoggingGuard scoped_logging_guard;\n\u002B  rcl_ret_t rcl_ret = rcl_logging_rosout_add_sublogger(logger_name, sublogger_name);\n\u002B  if (RCL_RET_OK != rcl_ret) {\n\u002B    rcutils_reset_error();\n\u002B    throw std::runtime_error(\u0022Failed to call rcl_logging_rosout_add_sublogger\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002B/// Remove a subordinate logger and cleans up allocated resources\n\u002Bvoid\n\u002Brclpy_logging_rosout_remove_sublogger(const char * logger_name, const char * sublogger_name)\n\u002B{\n\u002B  rclpy::LoggingGuard scoped_logging_guard;\n\u002B  rcl_ret_t rcl_ret = rcl_logging_rosout_remove_sublogger(logger_name, sublogger_name);\n\u002B\n\u002B  if (RCL_RET_OK != rcl_ret) {\n\u002B    rcutils_reset_error();\n\u002B  }\n\u002B}\n\u002B\n namespace rclpy\n {\n void\n@@ -185,6 \u002B211,7 @@ define_logging_api(py::module m)\n   .value(\u0022RCUTILS_LOG_SEVERITY_ERROR\u0022, RCUTILS_LOG_SEVERITY_ERROR)\n   .value(\u0022RCUTILS_LOG_SEVERITY_FATAL\u0022, RCUTILS_LOG_SEVERITY_FATAL);\n \n\u002B  m.def(\u0022rclpy_logging_get_separator_string\u0022, []() {return RCUTILS_LOGGING_SEPARATOR_STRING;});\n   m.def(\u0022rclpy_logging_initialize\u0022, \u0026rclpy_logging_initialize);\n   m.def(\u0022rclpy_logging_shutdown\u0022, \u0026rclpy_logging_shutdown);\n   m.def(\u0022rclpy_logging_set_logger_level\u0022, \u0026rclpy_logging_set_logger_level);\n@@ -193,5 \u002B220,7 @@ define_logging_api(py::module m)\n   m.def(\u0022rclpy_logging_rcutils_log\u0022, \u0026rclpy_logging_rcutils_log);\n   m.def(\u0022rclpy_logging_severity_level_from_string\u0022, \u0026rclpy_logging_severity_level_from_string);\n   m.def(\u0022rclpy_logging_get_logging_directory\u0022, \u0026rclpy_logging_get_logging_directory);\n\u002B  m.def(\u0022rclpy_logging_rosout_add_sublogger\u0022, \u0026rclpy_logging_rosout_add_sublogger);\n\u002B  m.def(\u0022rclpy_logging_rosout_remove_sublogger\u0022, \u0026rclpy_logging_rosout_remove_sublogger);\n }\n }  // namespace rclpy\ndiff --git rclpy/test/test_rosout_subscription.py rclpy/test/test_rosout_subscription.py\nnew file mode 100644\nindex 0000000..037938c\n--- /dev/null\n\u002B\u002B\u002B rclpy/test/test_rosout_subscription.py\n@@ -0,0 \u002B1,126 @@\n\u002B# Copyright 2023 Sony Group Corporation.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bimport unittest\n\u002B\n\u002Bfrom rcl_interfaces.msg import Log\n\u002Bimport rclpy\n\u002Bfrom rclpy.executors import SingleThreadedExecutor\n\u002Bfrom rclpy.task import Future\n\u002B\n\u002B\n\u002Bclass TestRosoutSubscription(unittest.TestCase):\n\u002B\n\u002B    @classmethod\n\u002B    def setUpClass(cls):\n\u002B        cls.context = rclpy.context.Context()\n\u002B        rclpy.init(context=cls.context)\n\u002B        cls.node = rclpy.create_node(\u0027test_rosout_subscription\u0027, context=cls.context)\n\u002B        cls.executor = SingleThreadedExecutor(context=cls.context)\n\u002B        cls.executor.add_node(cls.node)\n\u002B\n\u002B    @classmethod\n\u002B    def tearDownClass(cls):\n\u002B        cls.node.destroy_node()\n\u002B        rclpy.shutdown(context=cls.context)\n\u002B\n\u002B    def setUp(self):\n\u002B        # create subscriber of \u0027rosout\u0027 topic\n\u002B        self.sub = self.node.create_subscription(\n\u002B            Log,\n\u002B            \u0027/rosout\u0027,\n\u002B            self._rosout_subscription_callback,\n\u002B            1\n\u002B        )\n\u002B        self.fut = Future()\n\u002B        self.rosout_msg_name = None\n\u002B\n\u002B    def _rosout_subscription_callback(self, msg):\n\u002B        if msg.name == self.rosout_msg_name:\n\u002B            self.fut.set_result(None)\n\u002B\n\u002B    def test_parent_log(self):\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription\u0027\n\u002B        logger = self.node.get_logger()\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B    def test_child_log(self):\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription.child1\u0027\n\u002B        logger = self.node.get_logger()\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertFalse(self.fut.done())\n\u002B\n\u002B        logger = self.node.get_logger().get_child(\u0027child1\u0027)\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B        self.fut = Future()\n\u002B\n\u002B        logger = self.node.get_logger().get_child(\u0027child2\u0027)\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertFalse(self.fut.done())\n\u002B\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription.child2\u0027\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B    def test_child_hierarchy(self):\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription.child.grandchild\u0027\n\u002B        logger = self.node.get_logger().get_child(\u0027child\u0027).get_child(\u0027grandchild\u0027)\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B    def test_first_child_removed(self):\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription.child\u0027\n\u002B        logger = self.node.get_logger().get_child(\u0027child\u0027)\n\u002B        logger2 = self.node.get_logger().get_child(\u0027child\u0027)\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B        logger = None\n\u002B        logger2.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B    def test_logger_parameter(self):\n\u002B        self.rosout_msg_name = \u0027test_rosout_subscription.child\u0027\n\u002B        logger = self.node.get_logger().get_child(\u0027child\u0027)\n\u002B\n\u002B        def call_logger(logger):\n\u002B            logger1 = logger\n\u002B            logger1.info(\u0027test\u0027)\n\u002B        call_logger(logger)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B        logger.info(\u0027test\u0027)\n\u002B        self.executor.spin_until_future_complete(self.fut, 3)\n\u002B        self.assertTrue(self.fut.done())\n\u002B\n\u002B    def test_node_logger_not_exist(self):\n\u002B        node = rclpy.create_node(\u0027test_extra_node\u0027, context=self.context)\n\u002B        logger = node.get_logger()\n\u002B        node = None\n\u002B        with self.assertRaises(RuntimeError):\n\u002B            logger.get_child(\u0027child\u0027)\n\u002B\n\u002B\n\u002Bif __name__ == \u0027__main__\u0027:\n\u002B    unittest.main()\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "6bd8c0f9f3f8ee6f69e88e766ae3e15c60a68592",
    "RawMessage": "Bundle and ensure the exportation of rosidl generated targets (#73)",
    "Changes": "diff --git rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\nindex ea0726d..e546635 100644\n--- rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\n@@ -121,10 \u002B121,8 @@ set_target_properties(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n   PROPERTIES COMPILE_FLAGS \u0022${_target_compile_flags}\u0022)\n target_include_directories(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n   PUBLIC\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_c\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_c\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_c\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include\u003E\u0022\n )\n ament_target_dependencies(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n   \u0022fastcdr\u0022\n@@ -139,7 \u002B137,7 @@ foreach(_pkg_name ${rosidl_generate_interfaces_DEPENDENCY_PACKAGE_NAMES})\n   normalize_path(_srv_include_dir \u0022${_srv_include_dir}\u0022)\n   normalize_path(_action_include_dir \u0022${_action_include_dir}\u0022)\n   target_include_directories(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n-    PUBLIC\n\u002B    PRIVATE\n     \u0022${_msg_include_dir}\u0022\n     \u0022${_srv_include_dir}\u0022\n     \u0022${_action_include_dir}\u0022\n@@ -151,6 \u002B149,7 @@ foreach(_pkg_name ${rosidl_generate_interfaces_DEPENDENCY_PACKAGE_NAMES})\n endforeach()\n target_link_libraries(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n   ${rosidl_generate_interfaces_TARGET}__rosidl_generator_c\n\u002B  ${rosidl_generate_interfaces_TARGET}__rosidl_generator_cpp\n   ${rosidl_generate_interfaces_TARGET}__rosidl_typesupport_fastrtps_cpp)\n \n add_dependencies(\n@@ -179,12 \u002B178,13 @@ if(NOT rosidl_generate_interfaces_SKIP_INSTALL)\n \n   install(\n     TARGETS ${rosidl_generate_interfaces_TARGET}${_target_suffix}\n\u002B    EXPORT ${rosidl_generate_interfaces_TARGET}\n     ARCHIVE DESTINATION lib\n     LIBRARY DESTINATION lib\n     RUNTIME DESTINATION bin\n   )\n \n-  rosidl_export_typesupport_libraries(${_target_suffix}\n\u002B  rosidl_export_typesupport_targets(${_target_suffix}\n     ${rosidl_generate_interfaces_TARGET}${_target_suffix})\n endif()\n \ndiff --git rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\nindex 09a474e..11c8e54 100644\n--- rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\n@@ -134,8 \u002B134,8 @@ set_target_properties(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n # Include headers from other generators\n target_include_directories(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n   PUBLIC\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include\u003E\u0022\n )\n \n ament_target_dependencies(${rosidl_generate_interfaces_TARGET}${_target_suffix}\n@@ -182,12 \u002B182,13 @@ if(NOT rosidl_generate_interfaces_SKIP_INSTALL)\n \n   install(\n     TARGETS ${rosidl_generate_interfaces_TARGET}${_target_suffix}\n\u002B    EXPORT ${rosidl_generate_interfaces_TARGET}\n     ARCHIVE DESTINATION lib\n     LIBRARY DESTINATION lib\n     RUNTIME DESTINATION bin\n   )\n \n-  rosidl_export_typesupport_libraries(${_target_suffix}\n\u002B  rosidl_export_typesupport_targets(${_target_suffix}\n     ${rosidl_generate_interfaces_TARGET}${_target_suffix})\n endif()\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "b70680a084814f7deb11614f8e3833e27e9b75e1",
    "RawMessage": "Make rmw_fastrtps_dynamic_cpp export a modern CMake target (#814)",
    "Changes": "diff --git rmw_fastrtps_dynamic_cpp/CMakeLists.txt rmw_fastrtps_dynamic_cpp/CMakeLists.txt\nindex bc4af96..47f6cf0 100644\n--- rmw_fastrtps_dynamic_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/CMakeLists.txt\n@@ -46,8 \u002B46,6 @@ find_package(rosidl_runtime_c REQUIRED)\n find_package(rosidl_typesupport_introspection_c REQUIRED)\n find_package(rosidl_typesupport_introspection_cpp REQUIRED)\n \n-include_directories(include)\n-\n add_library(rmw_fastrtps_dynamic_cpp\n   src/client_service_common.cpp\n   src/get_client.cpp\n@@ -112,6 \u002B110,9 @@ target_link_libraries(rmw_fastrtps_dynamic_cpp PRIVATE\n   rmw_dds_common::rmw_dds_common_library\n   tracetools::tracetools\n )\n\u002Btarget_include_directories(rmw_fastrtps_dynamic_cpp PUBLIC\n\u002B  \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n\u002B  \u0022$\u003CINSTALL_INTERFACE:include/${PROJECT_NAME}\u003E\u0022)\n \n configure_rmw_library(rmw_fastrtps_dynamic_cpp)\n \n@@ -123,6 \u002B124,8 @@ target_compile_definitions(${PROJECT_NAME}\n # Export old-style CMake variables\n ament_export_include_directories(\u0022include/${PROJECT_NAME}\u0022)\n ament_export_libraries(rmw_fastrtps_dynamic_cpp)\n\u002B# Export a modern CMake target\n\u002Bament_export_targets(rmw_fastrtps_dynamic_cpp)\n \n ament_export_dependencies(\n   fastcdr\n@@ -175,7 \u002B178,7 @@ install(\n )\n \n install(\n-  TARGETS rmw_fastrtps_dynamic_cpp\n\u002B  TARGETS rmw_fastrtps_dynamic_cpp EXPORT rmw_fastrtps_dynamic_cpp\n   ARCHIVE DESTINATION lib\n   LIBRARY DESTINATION lib\n   RUNTIME DESTINATION bin\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "66b19448b0520b15a9e6c28483863b2a4351c2f6",
    "RawMessage": "Fix SharedFuture from async_send_request never becomes valid (#2044)",
    "Changes": "diff --git rclcpp/include/rclcpp/client.hpp rclcpp/include/rclcpp/client.hpp\nindex 04e0ce9a..b10e3e15 100644\n--- rclcpp/include/rclcpp/client.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/client.hpp\n@@ -792,16 \u002B792,14 @@ protected:\n   async_send_request_impl(const Request \u0026 request, CallbackInfoVariant value)\n   {\n     int64_t sequence_number;\n\u002B    std::lock_guard\u003Cstd::mutex\u003E lock(pending_requests_mutex_);\n     rcl_ret_t ret = rcl_send_request(get_client_handle().get(), \u0026request, \u0026sequence_number);\n     if (RCL_RET_OK != ret) {\n       rclcpp::exceptions::throw_from_rcl_error(ret, \u0022failed to send request\u0022);\n     }\n-    {\n-      std::lock_guard\u003Cstd::mutex\u003E lock(pending_requests_mutex_);\n-      pending_requests_.try_emplace(\n-        sequence_number,\n-        std::make_pair(std::chrono::system_clock::now(), std::move(value)));\n-    }\n\u002B    pending_requests_.try_emplace(\n\u002B      sequence_number,\n\u002B      std::make_pair(std::chrono::system_clock::now(), std::move(value)));\n     return sequence_number;\n   }\n \n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "3fb012e2e979475f5044ab0e0f9b91d336db5f46",
    "RawMessage": "do not throw exception if trying to dequeue an empty intra-process buffer (#2061)",
    "Changes": "diff --git rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\nindex c01240b4..245d417d 100644\n--- rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/buffers/ring_buffer_implementation.hpp\n@@ -86,8 \u002B86,7 @@ public:\n     std::lock_guard\u003Cstd::mutex\u003E lock(mutex_);\n \n     if (!has_data_()) {\n-      RCLCPP_ERROR(rclcpp::get_logger(\u0022rclcpp\u0022), \u0022Calling dequeue on empty intra-process buffer\u0022);\n-      throw std::runtime_error(\u0022Calling dequeue on empty intra-process buffer\u0022);\n\u002B      return BufferT();\n     }\n \n     auto request = std::move(ring_buffer_[read_index_]);\ndiff --git rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\nindex 803d9400..91ea91a7 100644\n--- rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/experimental/subscription_intra_process.hpp\n@@ -109,8 \u002B109,14 @@ public:\n \n     if (any_callback_.use_take_shared_method()) {\n       shared_msg = this-\u003Ebuffer_-\u003Econsume_shared();\n\u002B      if (!shared_msg) {\n\u002B        return nullptr;\n\u002B      }\n     } else {\n       unique_msg = this-\u003Ebuffer_-\u003Econsume_unique();\n\u002B      if (!unique_msg) {\n\u002B        return nullptr;\n\u002B      }\n     }\n     return std::static_pointer_cast\u003Cvoid\u003E(\n       std::make_shared\u003Cstd::pair\u003CConstMessageSharedPtr, MessageUniquePtr\u003E\u003E(\n@@ -138,7 \u002B144,7 @@ protected:\n   execute_impl(std::shared_ptr\u003Cvoid\u003E \u0026 data)\n   {\n     if (!data) {\n-      throw std::runtime_error(\u0022\u0027data\u0027 is empty\u0022);\n\u002B      return;\n     }\n \n     rmw_message_info_t msg_info;\n",
    "BackportedTo": "humble",
    "IsBackported": true
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "21184ac4e11587f42f6d24a8eee754aaa31ffe86",
    "RawMessage": "use rmw_security_common (#529)",
    "Changes": "diff --git rmw_cyclonedds_cpp/CMakeLists.txt rmw_cyclonedds_cpp/CMakeLists.txt\nindex cc98f39..e932cd6 100644\n--- rmw_cyclonedds_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_cyclonedds_cpp/CMakeLists.txt\n@@ -50,6 \u002B50,7 @@ endif()\n \n find_package(rmw REQUIRED)\n find_package(rmw_dds_common REQUIRED)\n\u002Bfind_package(rmw_security_common REQUIRED)\n find_package(rosidl_runtime_c REQUIRED)\n find_package(rosidl_typesupport_introspection_c REQUIRED)\n find_package(rosidl_typesupport_introspection_cpp REQUIRED)\n@@ -63,6 \u002B64,7 @@ ament_export_dependencies(rcpputils)\n ament_export_dependencies(rmw)\n ament_export_dependencies(rosidl_runtime_c)\n ament_export_dependencies(rmw_dds_common)\n\u002Bament_export_dependencies(rmw_security_common)\n ament_export_dependencies(rosidl_typesupport_introspection_c)\n ament_export_dependencies(rosidl_typesupport_introspection_cpp)\n ament_export_dependencies(tracetools)\n@@ -88,6 \u002B90,7 @@ target_link_libraries(rmw_cyclonedds_cpp PRIVATE\n   rcutils::rcutils\n   rcpputils::rcpputils\n   rmw_dds_common::rmw_dds_common_library\n\u002B  rmw_security_common::rmw_security_common_library\n   rosidl_typesupport_introspection_c::rosidl_typesupport_introspection_c\n   rosidl_typesupport_introspection_cpp::rosidl_typesupport_introspection_cpp\n   rosidl_runtime_c::rosidl_runtime_c\ndiff --git rmw_cyclonedds_cpp/package.xml rmw_cyclonedds_cpp/package.xml\nindex 54b4ea2..246c988 100644\n--- rmw_cyclonedds_cpp/package.xml\n\u002B\u002B\u002B rmw_cyclonedds_cpp/package.xml\n@@ -20,6 \u002B20,7 @@\n   \u003Cdepend\u003Ercpputils\u003C/depend\u003E\n   \u003Cdepend\u003Ermw\u003C/depend\u003E\n   \u003Cdepend\u003Ermw_dds_common\u003C/depend\u003E\n\u002B  \u003Cdepend\u003Ermw_security_common\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_runtime_c\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_typesupport_introspection_c\u003C/depend\u003E\n   \u003Cdepend\u003Erosidl_typesupport_introspection_cpp\u003C/depend\u003E\ndiff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex be49156..d3c066f 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -76,7 \u002B76,8 @@\n #include \u0022rmw_dds_common/graph_cache.hpp\u0022\n #include \u0022rmw_dds_common/msg/participant_entities_info.hpp\u0022\n #include \u0022rmw_dds_common/qos.hpp\u0022\n-#include \u0022rmw_dds_common/security.hpp\u0022\n\u002B\n\u002B#include \u0022rmw_security_common/security.hpp\u0022\n \n #include \u0022rosidl_runtime_c/type_hash.h\u0022\n \n@@ -1270,25 \u002B1271,48 @@ rmw_ret_t configure_qos_for_security(\n   const rmw_security_options_t * security_options)\n {\n #if RMW_SUPPORT_SECURITY\n-  std::unordered_map\u003Cstd::string, std::string\u003E security_files;\n\u002B  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n\u002B  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n\u002B  rcutils_ret_t ret = rcutils_string_map_init(\u0026security_files, 0, allocator);\n\u002B\n\u002B  if (ret != RMW_RET_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Failed to initialize string map for security\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n\u002B\n\u002B  auto scope_exit_ws = rcpputils::make_scope_exit(\n\u002B    [\u0026security_files]()\n\u002B    {\n\u002B      rcutils_ret_t ret = rcutils_string_map_fini(\u0026security_files);\n\u002B      if (ret != RMW_RET_OK) {\n\u002B        RMW_SET_ERROR_MSG(\u0022Failed to fini string map for security\u0022);\n\u002B      }\n\u002B    });\n\u002B\n   if (security_options-\u003Esecurity_root_path == nullptr) {\n     return RMW_RET_UNSUPPORTED;\n   }\n \n-  if (!rmw_dds_common::get_security_files(\n-      \u0022file:\u0022, security_options-\u003Esecurity_root_path, security_files))\n\u002B  if (get_security_files(\n\u002B      \u0022file:\u0022, security_options-\u003Esecurity_root_path, \u0026security_files) != RMW_RET_OK)\n   {\n     RCUTILS_LOG_INFO_NAMED(\n       \u0022rmw_cyclonedds_cpp\u0022, \u0022could not find all security files\u0022);\n     return RMW_RET_UNSUPPORTED;\n   }\n \n-  dds_qset_prop(qos, \u0022dds.sec.auth.identity_ca\u0022, security_files[\u0022IDENTITY_CA\u0022].c_str());\n-  dds_qset_prop(qos, \u0022dds.sec.auth.identity_certificate\u0022, security_files[\u0022CERTIFICATE\u0022].c_str());\n-  dds_qset_prop(qos, \u0022dds.sec.auth.private_key\u0022, security_files[\u0022PRIVATE_KEY\u0022].c_str());\n-  dds_qset_prop(qos, \u0022dds.sec.access.permissions_ca\u0022, security_files[\u0022PERMISSIONS_CA\u0022].c_str());\n-  dds_qset_prop(qos, \u0022dds.sec.access.governance\u0022, security_files[\u0022GOVERNANCE\u0022].c_str());\n-  dds_qset_prop(qos, \u0022dds.sec.access.permissions\u0022, security_files[\u0022PERMISSIONS\u0022].c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.auth.identity_ca\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022IDENTITY_CA\u0022)).c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.auth.identity_certificate\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022CERTIFICATE\u0022)).c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.auth.private_key\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PRIVATE_KEY\u0022)).c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.access.permissions_ca\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS_CA\u0022)).c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.access.governance\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022GOVERNANCE\u0022)).c_str());\n\u002B  dds_qset_prop(qos, \u0022dds.sec.access.permissions\u0022,\n\u002B    std::string(rcutils_string_map_get(\u0026security_files, \u0022PERMISSIONS\u0022)).c_str());\n \n   dds_qset_prop(qos, \u0022dds.sec.auth.library.path\u0022, \u0022dds_security_auth\u0022);\n   dds_qset_prop(qos, \u0022dds.sec.auth.library.init\u0022, \u0022init_authentication\u0022);\n@@ -1302,8 \u002B1326,10 @@ rmw_ret_t configure_qos_for_security(\n   dds_qset_prop(qos, \u0022dds.sec.access.library.init\u0022, \u0022init_access_control\u0022);\n   dds_qset_prop(qos, \u0022dds.sec.access.library.finalize\u0022, \u0022finalize_access_control\u0022);\n \n-  if (security_files.count(\u0022CRL\u0022) \u003E 0) {\n-    dds_qset_prop(qos, \u0022org.eclipse.cyclonedds.sec.auth.crl\u0022, security_files[\u0022CRL\u0022].c_str());\n\u002B  if (rcutils_string_map_key_exists(\u0026security_files, \u0022CRL\u0022)) {\n\u002B    dds_qset_prop(\n\u002B      qos, \u0022org.eclipse.cyclonedds.sec.auth.crl\u0022,\n\u002B      std::string(rcutils_string_map_get(\u0026security_files, \u0022CRL\u0022)).c_str());\n   }\n \n   return RMW_RET_OK;\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "6baa271142a8eb58f408be9fb2c6ac6c8d682a56",
    "RawMessage": "Shorten wait time for a subscription not being ready. (#1092)",
    "Changes": "diff --git rcl/test/rcl/test_subscription.cpp rcl/test/rcl/test_subscription.cpp\nindex 6d773e9..2cf0ddb 100644\n--- rcl/test/rcl/test_subscription.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_subscription.cpp\n@@ -984,9 \u002B984,9 @@ TEST_F(\n   }\n \n   if (is_cft_support) {\n-    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 100));\n   } else {\n-    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n     test_msgs__msg__Strings msg;\n     test_msgs__msg__Strings__init(\u0026msg);\n@@ -1011,7 \u002B1011,7 @@ TEST_F(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n   {\n     test_msgs__msg__Strings msg;\n@@ -1072,9 \u002B1072,9 @@ TEST_F(\n   }\n \n   if (is_cft_support) {\n-    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 100));\n   } else {\n-    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n     test_msgs__msg__Strings msg;\n     test_msgs__msg__Strings__init(\u0026msg);\n@@ -1099,7 \u002B1099,7 @@ TEST_F(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n   {\n     test_msgs__msg__Strings msg;\n@@ -1189,7 \u002B1189,7 @@ TEST_F(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n   {\n     test_msgs__msg__Strings msg;\n@@ -1261,7 \u002B1261,7 @@ TEST_F(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n   {\n     test_msgs__msg__BasicTypes msg;\n@@ -1323,9 \u002B1323,9 @@ TEST_F(\n   }\n \n   if (is_cft_support) {\n-    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_FALSE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 100));\n   } else {\n-    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B    ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n     test_msgs__msg__BasicTypes msg;\n     test_msgs__msg__BasicTypes__init(\u0026msg);\n@@ -1349,7 \u002B1349,7 @@ TEST_F(\n     ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   }\n \n-  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 10, 1000));\n\u002B  ASSERT_TRUE(wait_for_subscription_to_be_ready(\u0026subscription, context_ptr, 100, 100));\n \n   {\n     test_msgs__msg__BasicTypes msg;\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "ea2dbb3097f095dd24add190c242f3048a747c63",
    "RawMessage": "Rolling namespace in title (#1074)",
    "Changes": "diff --git rviz_common/include/rviz_common/visualization_frame.hpp rviz_common/include/rviz_common/visualization_frame.hpp\nindex 9405f50b..215c5291 100644\n--- rviz_common/include/rviz_common/visualization_frame.hpp\n\u002B\u002B\u002B rviz_common/include/rviz_common/visualization_frame.hpp\n@@ -126,6 \u002B126,19 @@ public:\n     ros_integration::RosNodeAbstractionIface::WeakPtr rviz_ros_node,\n     const QString \u0026 display_config_file = \u0022\u0022);\n \n\u002B  /// Set the display title format.\n\u002B  /**\n\u002B   * Sets the format of the window title.\n\u002B   * Three replacement tokens are supported:\n\u002B   *  - {NAMESPACE} - replace with the namespace this node is in\n\u002B   *  - {CONFIG_PATH} - replace with the path (but not the filename) of the configuration file in use.\n\u002B   *  - {CONFIG_FILENAME} - replace with the filename (but not the path) of the configuration file in use.\n\u002B   * The default is \u0022RViz[*]\u0022 if the default configuration file is in use,\n\u002B   * or \u0022{CONFIG_PATH}/{CONFIG_FILENAME}[*] - RViz\u0022 if a custom configuration file is in use.\n\u002B   */\n\u002B  void\n\u002B  setDisplayTitleFormat(const QString \u0026 title_format);\n\u002B\n   /// Return the visualization manager.\n   VisualizationManager *\n   getManager();\n@@ -444,6 \u002B457,7 @@ protected:\n \n   std::string config_dir_;\n   std::string persistent_settings_file_;\n\u002B  std::string display_title_format_;\n   std::string display_config_file_;\n   std::string default_display_config_file_;\n   std::string last_config_dir_;\ndiff --git rviz_common/src/rviz_common/visualization_frame.cpp rviz_common/src/rviz_common/visualization_frame.cpp\nindex 8a82f9a6..c3d55a6b 100644\n--- rviz_common/src/rviz_common/visualization_frame.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/visualization_frame.cpp\n@@ -32,6 \u002B32,7 @@\n #include \u0022rviz_common/visualization_frame.hpp\u0022\n \n #include \u003Cexception\u003E\n\u002B#include \u003Cfilesystem\u003E\n #include \u003Cfstream\u003E\n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n@@ -738,16 \u002B739,43 @@ void VisualizationFrame::setDisplayConfigModified()\n   }\n }\n \n\u002Bvoid VisualizationFrame::setDisplayTitleFormat(const QString \u0026 title_format)\n\u002B{\n\u002B  display_title_format_ = title_format.toStdString();\n\u002B}\n\u002B\n void VisualizationFrame::setDisplayConfigFile(const std::string \u0026 path)\n {\n   display_config_file_ = path;\n-\n   std::string title;\n-  if (path == default_display_config_file_) {\n-    title = \u0022RViz[*]\u0022;\n\u002B\n\u002B  if (display_title_format_.empty()) {\n\u002B    if (path == default_display_config_file_) {\n\u002B      title = \u0022RViz[*]\u0022;\n\u002B    } else {\n\u002B      title = QDir::toNativeSeparators(QString::fromStdString(path)).toStdString() \u002B \u0022[*] - RViz\u0022;\n\u002B    }\n   } else {\n-    title = QDir::toNativeSeparators(QString::fromStdString(path)).toStdString() \u002B \u0022[*] - RViz\u0022;\n\u002B    auto find_and_replace_token =\n\u002B      [](std::string \u0026 title, const std::string \u0026 token, const std::string \u0026 replacement)\n\u002B      {\n\u002B        std::size_t found = title.find(token);\n\u002B        if (found != std::string::npos) {\n\u002B          title.replace(found, token.length(), replacement);\n\u002B        }\n\u002B      };\n\u002B    title = display_title_format_;\n\u002B    std::filesystem::path full_filename(path.c_str());\n\u002B    find_and_replace_token(\n\u002B      title, \u0022{NAMESPACE}\u0022,\n\u002B      rviz_ros_node_.lock()-\u003Eget_raw_node()-\u003Eget_namespace());\n\u002B    find_and_replace_token(title, \u0022{CONFIG_PATH}\u0022, full_filename.parent_path().string());\n\u002B    find_and_replace_token(title, \u0022{CONFIG_FILENAME}\u0022, full_filename.filename().string());\n\u002B    if (title.find(\u0022[*]\u0022) == std::string::npos) {\n\u002B      title.append(\u0022[*]\u0022);\n\u002B    }\n   }\n\u002B\n   setWindowTitle(QString::fromStdString(title));\n }\n \ndiff --git rviz_common/src/rviz_common/visualizer_app.cpp rviz_common/src/rviz_common/visualizer_app.cpp\nindex 277bd706..d2e68258 100644\n--- rviz_common/src/rviz_common/visualizer_app.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/visualizer_app.cpp\n@@ -85,6 \u002B85,13 @@ bool VisualizerApp::init(int argc, char ** argv)\n   parser.setApplicationDescription(\u00223D visualization tool for ROS2\u0022);\n   parser.addHelpOption();\n \n\u002B  QCommandLineOption display_title_format_option(\n\u002B    QStringList() \u003C\u003C \u0022t\u0022 \u003C\u003C \u0022display-title-format\u0022,\n\u002B      \u0022A display title format like \u0022,\n\u002B      \u0022\\\u0022{NAMESPACE} - {CONFIG_PATH}/{CONFIG_FILENAME} - RViz2\\\u0022 \u0022,\n\u002B      \u0022display_title_format\u0022);\n\u002B  parser.addOption(display_title_format_option);\n\u002B\n   QCommandLineOption display_config_option(\n     QStringList() \u003C\u003C \u0022d\u0022 \u003C\u003C \u0022display-config\u0022,\n       \u0022A display config file (.rviz) to load\u0022,\n@@ -105,7 \u002B112,7 @@ bool VisualizerApp::init(int argc, char ** argv)\n       \u0022A custom splash-screen image to display\u0022, \u0022splash_path\u0022);\n   parser.addOption(splash_screen_option);\n \n-  QString display_config, fixed_frame, splash_path, help_path;\n\u002B  QString display_config, fixed_frame, splash_path, help_path, display_title_format;\n   bool enable_ogre_log;\n \n   if (app_) {parser.process(*app_);}\n@@ -123,6 \u002B130,10 @@ bool VisualizerApp::init(int argc, char ** argv)\n     splash_path = parser.value(splash_screen_option);\n   }\n \n\u002B  if (parser.isSet(display_title_format_option)) {\n\u002B    display_title_format = parser.value(display_title_format_option);\n\u002B  }\n\u002B\n   if (enable_ogre_log) {\n     rviz_rendering::OgreLogging::get()-\u003EuseLogFileAndStandardOut();\n     rviz_rendering::OgreLogging::get()-\u003EconfigureLogging();\n@@ -133,6 \u002B144,9 @@ bool VisualizerApp::init(int argc, char ** argv)\n   node_ = ros_client_abstraction_-\u003Einit(argc, argv, \u0022rviz\u0022, false /* anonymous_name */);\n \n   frame_ = new VisualizationFrame(node_);\n\u002B\n\u002B  frame_-\u003EsetDisplayTitleFormat(display_title_format);\n\u002B\n   frame_-\u003EsetApp(this-\u003Eapp_);\n \n   if (!help_path.isEmpty()) {\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "0c149d91495ff38ade55e8c41f105ca176f77b47",
    "RawMessage": "Do not block visualization manager updates when opening the display panel dialog (#795)",
    "Changes": "diff --git rviz_common/src/rviz_common/displays_panel.cpp rviz_common/src/rviz_common/displays_panel.cpp\nindex 71819ef9..9d0c5700 100644\n--- rviz_common/src/rviz_common/displays_panel.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/displays_panel.cpp\n@@ -131,14 \u002B131,12 @@ void DisplaysPanel::onNewDisplay()\n     \u0026datatype);\n   QApplication::restoreOverrideCursor();\n \n-  vis_manager_-\u003EstopUpdate();\n   if (dialog.exec() == QDialog::Accepted) {\n     Display * disp = vis_manager_-\u003EcreateDisplay(lookup_name, display_name, true);\n     if (!topic.isEmpty() \u0026\u0026 !datatype.isEmpty()) {\n       disp-\u003EsetTopic(topic, datatype);\n     }\n   }\n-  vis_manager_-\u003EstartUpdate();\n   activateWindow();  // Force keyboard focus back on main window.\n }\n \n@@ -178,7 \u002B176,6 @@ void DisplaysPanel::onDuplicateDisplay()\n     QItemSelection selection(first, last);\n     property_grid_-\u003EselectionModel()-\u003Eselect(selection, QItemSelectionModel::ClearAndSelect);\n   }\n-  vis_manager_-\u003EstartUpdate();\n   activateWindow();  // Force keyboard focus back on main window.\n }\n \ndiff --git rviz_common/src/rviz_common/visualization_frame.cpp rviz_common/src/rviz_common/visualization_frame.cpp\nindex fc03046f..f8b0c585 100644\n--- rviz_common/src/rviz_common/visualization_frame.cpp\n\u002B\u002B\u002B rviz_common/src/rviz_common/visualization_frame.cpp\n@@ -364,7 \u002B364,6 @@ void VisualizationFrame::initialize(\n   delete splash_;\n   splash_ = nullptr;\n \n-  manager_-\u003EstartUpdate();\n   initialized_ = true;\n   Q_EMIT statusUpdate(\u0022RViz is ready.\u0022);\n \n@@ -614,11 \u002B613,9 @@ void VisualizationFrame::openNewPanelDialog()\n     \u0026class_id,\n     \u0026display_name,\n     this);\n-  manager_-\u003EstopUpdate();\n   if (dialog-\u003Eexec() == QDialog::Accepted) {\n     addPanelByName(display_name, class_id);\n   }\n-  manager_-\u003EstartUpdate();\n }\n \n void VisualizationFrame::openNewToolDialog()\n@@ -633,11 \u002B630,9 @@ void VisualizationFrame::openNewToolDialog()\n     empty,\n     tool_man-\u003EgetToolClasses(),\n     \u0026class_id);\n-  manager_-\u003EstopUpdate();\n   if (dialog-\u003Eexec() == QDialog::Accepted) {\n     tool_man-\u003EaddTool(class_id);\n   }\n-  manager_-\u003EstartUpdate();\n   activateWindow();  // Force keyboard focus back on main window.\n }\n \n@@ -930,9 \u002B925,7 @@ bool VisualizationFrame::prepareToExit()\n     box.setInformativeText(QString::fromStdString(\u0022Save changes to \u0022 \u002B display_config_file_ \u002B \u0022?\u0022));\n     box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);\n     box.setDefaultButton(QMessageBox::Save);\n-    manager_-\u003EstopUpdate();\n     int result = box.exec();\n-    manager_-\u003EstartUpdate();\n     switch (result) {\n       case QMessageBox::Save:\n         if (saveDisplayConfig(QString::fromStdString(display_config_file_))) {\n@@ -969,12 \u002B962,10 @@ bool VisualizationFrame::prepareToExit()\n \n void VisualizationFrame::onOpen()\n {\n-  manager_-\u003EstopUpdate();\n   QString filename = QFileDialog::getOpenFileName(\n     this, \u0022Choose a file to open\u0022,\n     QString::fromStdString(last_config_dir_),\n     \u0022RViz config files (\u0022 CONFIG_EXTENSION_WILDCARD \u0022)\u0022);\n-  manager_-\u003EstartUpdate();\n \n   if (!filename.isEmpty()) {\n     if (!QFile(filename).exists()) {\n@@ -996,7 \u002B987,6 @@ void VisualizationFrame::onSave()\n   savePersistentSettings();\n \n   if (!saveDisplayConfig(QString::fromStdString(display_config_file_))) {\n-    manager_-\u003EstopUpdate();\n     QMessageBox box(this);\n     box.setWindowTitle(\u0022Failed to save.\u0022);\n     box.setText(getErrorMessage());\n@@ -1008,18 \u002B998,15 @@ void VisualizationFrame::onSave()\n     if (box.exec() == QMessageBox::Save) {\n       onSaveAs();\n     }\n-    manager_-\u003EstartUpdate();\n   }\n }\n \n void VisualizationFrame::onSaveAs()\n {\n-  manager_-\u003EstopUpdate();\n   QString q_filename = QFileDialog::getSaveFileName(\n     this, \u0022Choose a file to save to\u0022,\n     QString::fromStdString(last_config_dir_),\n     \u0022RViz config files (\u0022 CONFIG_EXTENSION_WILDCARD \u0022)\u0022);\n-  manager_-\u003EstartUpdate();\n \n   if (!q_filename.isEmpty()) {\n     if (!q_filename.endsWith(\u0022.\u0022 CONFIG_EXTENSION)) {\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "4ea28965a66d12ca815d353b1ad3e8cd33926d49",
    "RawMessage": "Add received_timestamp",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex 610c3ad..db36c2c 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -935,6 \u002B935,7 @@ rmw_take_response(\n         int32_t sn_high = 0;\n         uint32_t sn_low = 0;\n         int8_t client_guid[16] = {0};\n\u002B        dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n         bool res = deserialize_response_basic(\n           type_support-\u003Edata,\n           type_support-\u003Etypesupport_identifier,\n@@ -959,8 \u002B960,9 @@ rmw_take_response(\n           request_header-\u003Esource_timestamp =\n             sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sample_info-\u003Esource_timestamp.nanosec;\n-          // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-          request_header-\u003Ereceived_timestamp = 0;\n\u002B          request_header-\u003Ereceived_timestamp =\n\u002B            sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B            sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n           request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n           memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n \n@@ -1033,8 \u002B1035,9 @@ rmw_take_response(\n           request_header-\u003Esource_timestamp =\n             sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sample_info-\u003Esource_timestamp.nanosec;\n-          // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-          request_header-\u003Ereceived_timestamp = 0;\n\u002B          request_header-\u003Ereceived_timestamp =\n\u002B            sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B            sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n           request_header-\u003Erequest_id.sequence_number = sequence_number;\n           memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n \ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex d90b163..efc3e71 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -696,6 \u002B696,7 @@ rmw_take_request(\n       int32_t sn_high = 0;\n       uint32_t sn_low = 0;\n       int8_t client_guid[16] = {0};\n\u002B      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n \n       bool res = deserialize_request_basic(\n         type_support-\u003Edata,\n@@ -720,8 \u002B721,9 @@ rmw_take_request(\n       request_header-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-      request_header-\u003Ereceived_timestamp = 0;\n\u002B      request_header-\u003Ereceived_timestamp =\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n       request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n       memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n     }\n@@ -789,8 \u002B791,9 @@ rmw_take_request(\n       request_header-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-      request_header-\u003Ereceived_timestamp = 0;\n\u002B      request_header-\u003Ereceived_timestamp =\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n       request_header-\u003Erequest_id.sequence_number = sequence_number;\n       memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n     }\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex 9f91a61..5ad8b0b 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -422,8 \u002B422,9 @@ _take(\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-      message_info-\u003Ereceived_timestamp = 0;\n\u002B      message_info-\u003Ereceived_timestamp =\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n       message_info-\u003Epublication_sequence_number = sequence_number;\n       message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n@@ -557,8 \u002B558,9 @@ _take_serialized(\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-      message_info-\u003Ereceived_timestamp = 0;\n\u002B      message_info-\u003Ereceived_timestamp =\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B        sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n       message_info-\u003Epublication_sequence_number = sequence_number;\n       message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n@@ -986,12 \u002B988,14 @@ rmw_take_sequence(\n         }\n \n         auto message_info = \u0026(message_info_sequence-\u003Edata[*taken]);\n\u002B        dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n \n         message_info-\u003Esource_timestamp =\n           sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n           sample_info-\u003Esource_timestamp.nanosec;\n-        // TODO(clemjh): SampleInfo doesn\u0027t contain received_timestamp\n-        message_info-\u003Ereceived_timestamp = 0;\n\u002B        message_info-\u003Ereceived_timestamp =\n\u002B          sampleinfo_ex-\u003Ereceived_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n\u002B          sampleinfo_ex-\u003Ereceived_timestamp.nanosec;\n         rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n         sender_gid-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n         memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "2d7bd9f4cb0a19091b848b664972da2ce23e5cee",
    "RawMessage": "Wait for publisher and subscription to match (#1777)",
    "Changes": "diff --git rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\nindex 54c11bf1..7668fead 100644\n--- rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_subscription_with_type_adapter.cpp\n@@ -77,7 \u002B77,9 @@ class CLASSNAME (test_intra_process_within_one_node, RMW_IMPLEMENTATION) : publi\n public:\n   static void SetUpTestCase()\n   {\n-    rclcpp::init(0, nullptr);\n\u002B    if (!rclcpp::ok()) {\n\u002B      rclcpp::init(0, nullptr);\n\u002B    }\n   }\n \n   static void TearDownTestCase()\n@@ -128,6 \u002B130,20 @@ void wait_for_message_to_be_received(\n     executor.spin_once(g_sleep_per_loop);\n   }\n }\n\u002B\n\u002Bbool wait_for_match(\n\u002B  const std::shared_ptr\u003Crclcpp::SubscriptionBase\u003E sub,\n\u002B  const std::shared_ptr\u003Crclcpp::PublisherBase\u003E pub)\n\u002B{\n\u002B  int i = 0;\n\u002B  bool matched = false;\n\u002B  while (!matched \u0026\u0026 i \u003C g_max_loops) {\n\u002B    matched = sub-\u003Eget_publisher_count() \u003E 0 \u0026\u0026 pub-\u003Eget_subscription_count() \u003E 0;\n\u002B    std::this_thread::sleep_for(g_sleep_per_loop);\n\u002B  }\n\u002B  return matched;\n\u002B}\n\u002B\n /*\n  * Testing publisher creation signatures with a type adapter.\n  */\n@@ -175,6 \u002B191,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -191,6 \u002B208,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -206,6 \u002B224,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), (*msg).c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -222,6 \u002B241,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -237,6 \u002B257,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), (*msg).c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -253,6 \u002B274,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -268,6 \u002B290,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg.data.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -284,6 \u002B307,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -299,6 \u002B323,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg-\u003Edata.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -315,6 \u002B340,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -330,6 \u002B356,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg-\u003Edata.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -346,6 \u002B373,7 @@ TEST_F(\n           ASSERT_TRUE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -381,6 \u002B409,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -398,6 \u002B427,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -413,6 \u002B443,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), (*msg).c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -430,6 \u002B461,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -445,6 \u002B477,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), (*msg).c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -461,6 \u002B494,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -476,6 \u002B510,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg.data.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -492,6 \u002B527,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -507,6 \u002B543,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg-\u003Edata.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -523,6 \u002B560,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -538,6 \u002B576,7 @@ TEST_F(\n           ASSERT_STREQ(message_data.c_str(), msg-\u003Edata.c_str());\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n@@ -554,6 \u002B593,7 @@ TEST_F(\n           ASSERT_FALSE(message_info.get_rmw_message_info().from_intra_process);\n         };\n       auto sub = node-\u003Ecreate_subscription\u003CStringTypeAdapter\u003E(topic_name, 1, callback);\n\u002B      ASSERT_TRUE(wait_for_match(sub, pub));\n       pub-\u003Epublish(msg);\n       ASSERT_FALSE(is_received);\n       wait_for_message_to_be_received(is_received, node);\n",
    "IsBackported": false
  },
  {
    "Repository": "ros2cli",
    "SHA": "3803d777e5f744f8754c9601df359757527aef1b",
    "RawMessage": "Improve ros2 doctor on Windows (#631)",
    "Changes": "diff --git ros2doctor/ros2doctor/api/__init__.py ros2doctor/ros2doctor/api/__init__.py\nindex 90a73d5..f2bd30b 100644\n--- ros2doctor/ros2doctor/api/__init__.py\n\u002B\u002B\u002B ros2doctor/ros2doctor/api/__init__.py\n@@ -94,8 \u002B94,8 @@ def run_checks(*, include_warnings=False) -\u003E Tuple[Set[str], int, int]:\n     for check_entry_pt in importlib_metadata.entry_points().get(\u0027ros2doctor.checks\u0027, []):\n         try:\n             check_class = check_entry_pt.load()\n-        except ImportError:\n-            doctor_warn(f\u0027Check entry point {check_entry_pt.name} fails to load.\u0027)\n\u002B        except ImportError as e:\n\u002B            doctor_warn(f\u0027Check entry point {check_entry_pt.name} fails to load: {e}\u0027)\n             continue\n         try:\n             check_instance = check_class()\n@@ -124,8 \u002B124,8 @@ def generate_reports(*, categories=None) -\u003E List[Report]:\n     for report_entry_pt in importlib_metadata.entry_points().get(\u0027ros2doctor.report\u0027, []):\n         try:\n             report_class = report_entry_pt.load()\n-        except ImportError:\n-            doctor_warn(f\u0027Report entry point {report_entry_pt.name} fails to load.\u0027)\n\u002B        except ImportError as e:\n\u002B            doctor_warn(f\u0027Report entry point {report_entry_pt.name} fails to load: {e}\u0027)\n             continue\n         try:\n             report_instance = report_class()\ndiff --git ros2doctor/ros2doctor/api/network.py ros2doctor/ros2doctor/api/network.py\nindex 0d76c55..5ddf914 100644\n--- ros2doctor/ros2doctor/api/network.py\n\u002B\u002B\u002B ros2doctor/ros2doctor/api/network.py\n@@ -15,6 \u002B15,8 @@\n import os\n from typing import Tuple\n \n\u002Bimport ifcfg\n\u002B\n from ros2doctor.api import DoctorCheck\n from ros2doctor.api import DoctorReport\n from ros2doctor.api import Report\n@@ -22,13 \u002B24,6 @@ from ros2doctor.api import Result\n from ros2doctor.api.format import doctor_error\n from ros2doctor.api.format import doctor_warn\n \n-try:\n-    import ifcfg\n-except ImportError:  # check import error for windows and osx\n-    doctor_warn(\n-        \u0027Unable to import ifcfg. \u0027\n-        \u0027Use \u0060python3 -m pip install ifcfg\u0060 to install needed package.\u0027)\n-\n \n def _is_unix_like_platform() -\u003E bool:\n     \u0022\u0022\u0022Return True if conforms to UNIX/POSIX-style APIs.\u0022\u0022\u0022\n@@ -61,24 \u002B56,16 @@ class NetworkCheck(DoctorCheck):\n         \u0022\u0022\u0022Check network configuration.\u0022\u0022\u0022\n         result = Result()\n         # check ifcfg import for windows and osx users\n-        try:\n-            ifcfg_ifaces = ifcfg.interfaces()\n-        except NameError:\n-            doctor_error(\n-                \u0027\u0060ifcfg\u0060 module is not imported. \u0027\n-                \u0027Unable to run network check.\u0027)\n-            result.add_error()\n-            return result\n\u002B        ifcfg_ifaces = ifcfg.interfaces()\n \n         has_loopback, has_non_loopback, has_multicast = _check_network_config_helper(ifcfg_ifaces)\n         if not _is_unix_like_platform():\n             if not has_loopback and not has_non_loopback:\n                 # no flags found, otherwise one of them should be True.\n-                doctor_error(\n-                    \u0027No flags found. \u0027\n-                    \u0027Run \u0060ipconfig\u0060 on Windows or \u0027\n-                    \u0027install \u0060ifconfig\u0060 on Unix to check network interfaces.\u0027)\n-                result.add_error()\n\u002B                doctor_warn(\n\u002B                    \u0027Interface flags are not available on Windows. \u0027\n\u002B                    \u0027Run \u0060ipconfig\u0060 to see what interfaces are available.\u0027)\n\u002B                result.add_warning()\n                 return result\n         if not has_loopback:\n             doctor_error(\u0027No loopback IP address is found.\u0027)\n@@ -101,11 \u002B88,7 @@ class NetworkReport(DoctorReport):\n     def report(self):\n         \u0022\u0022\u0022Print system and ROS network information.\u0022\u0022\u0022\n         # check ifcfg import for windows and osx users\n-        try:\n-            ifcfg_ifaces = ifcfg.interfaces()\n-        except NameError:\n-            doctor_error(\u0027ifcfg is not imported. Unable to generate network report.\u0027)\n-            return Report(\u0027\u0027)\n\u002B        ifcfg_ifaces = ifcfg.interfaces()\n \n         network_report = Report(\u0027NETWORK CONFIGURATION\u0027)\n         for iface in ifcfg_ifaces.values():\ndiff --git ros2doctor/ros2doctor/api/package.py ros2doctor/ros2doctor/api/package.py\nindex ad097a0..1c633db 100644\n--- ros2doctor/ros2doctor/api/package.py\n\u002B\u002B\u002B ros2doctor/ros2doctor/api/package.py\n@@ -103,26 \u002B103,26 @@ def compare_versions(result: Result, local_packages: dict, distro_packages: dict\n         if not local_ver_str:\n             missing_local \u002B= \u0027 \u0027 \u002B name\n             local_ver_str = \u0027\u0027\n-        required_ver_str = distro_packages.get(name, \u0027\u0027)\n-        if not required_ver_str:\n\u002B        latest_ver_str = distro_packages.get(name, \u0027\u0027)\n\u002B        if not latest_ver_str:\n             missing_req \u002B= \u0027 \u0027 \u002B name\n         local_ver = version.parse(local_ver_str).base_version\n-        required_ver = version.parse(required_ver_str).base_version\n-        if local_ver \u003C required_ver:\n\u002B        latest_ver = version.parse(latest_ver_str).base_version\n\u002B        if local_ver \u003C latest_ver:\n             doctor_warn(\n                 f\u0027{name} has been updated to a new version.\u0027\n                 f\u0027 local: {local_ver} \u003C\u0027\n-                f\u0027 required: {required_ver}\u0027)\n\u002B                f\u0027 latest: {latest_ver}\u0027)\n             result.add_warning()\n     if missing_req:\n         if len(missing_req) \u003E 100:\n             doctor_warn(\n-                \u0027Cannot find required versions of packages: \u0027 \u002B\n\u002B                \u0027Cannot find the latest versions of packages: \u0027 \u002B\n                 textwrap.shorten(missing_req, width=100) \u002B\n                 \u0027 Use \u0060ros2 doctor --report\u0060 to see full list.\u0027)\n         else:\n             doctor_warn(\n-                \u0027Cannot find required versions of packages: \u0027 \u002B\n\u002B                \u0027Cannot find the latest versions of packages: \u0027 \u002B\n                 missing_req)\n     if missing_local:\n         if len(missing_local) \u003E 100:\n@@ -174,8 \u002B174,8 @@ class PackageReport(DoctorReport):\n         if not local_package_vers or not distro_package_vers:\n             return report\n         for name, local_ver_str in local_package_vers.items():\n-            required_ver_str = distro_package_vers.get(name, \u0027\u0027)\n\u002B            latest_ver_str = distro_package_vers.get(name, \u0027\u0027)\n             local_ver = version.parse(local_ver_str).base_version\n-            required_ver = version.parse(required_ver_str).base_version\n-            report.add_to_report(name, f\u0027required={required_ver}, local={local_ver}\u0027)\n\u002B            latest_ver = version.parse(latest_ver_str).base_version\n\u002B            report.add_to_report(name, f\u0027latest={latest_ver}, local={local_ver}\u0027)\n         return report\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclpy",
    "SHA": "2581e4aa8a7f0fa3ea4dc048a990424af7a090d4",
    "RawMessage": "Convert take API to pybind11 (#721)",
    "Changes": "diff --git rclpy/src/rclpy/_rclpy.c rclpy/src/rclpy/_rclpy.c\nindex 8372076..cde4b24 100644\n--- rclpy/src/rclpy/_rclpy.c\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy.c\n@@ -993,154 \u002B993,6 @@ rclpy_get_rmw_implementation_identifier(PyObject * Py_UNUSED(self), PyObject * P\n \n   return pyrmw_implementation_identifier;\n }\n-/// Take a raw message from a given subscription (internal- for rclpy_take with raw=True)\n-/**\n- * \\param[in] module_state the module state for the _rclpy module\n- * \\param[in] rcl subscription pointer pointing to the subscription to process the message\n- * \\param[in] message_info struct pointer, may be null. if non-null, will be filled with message info\n- * \\return Python byte array with the raw serialized message contents\n- */\n-static PyObject *\n-rclpy_take_raw_with_info(\n-  rclpy_module_state_t * module_state,\n-  rcl_subscription_t * subscription, rmw_message_info_t * message_info)\n-{\n-  if (!module_state) {\n-    PyErr_Format(PyExc_RuntimeError, \u0022rclpy_take_raw_with_info got NULL module state\u0022);\n-    return NULL;\n-  }\n-  // Create a serialized message object\n-  rcl_serialized_message_t msg = rmw_get_zero_initialized_serialized_message();\n-  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n-  rcl_ret_t ret = rmw_serialized_message_init(\u0026msg, 0u, \u0026allocator);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to initialize message: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    rmw_ret_t r_fini = rmw_serialized_message_fini(\u0026msg);\n-    if (r_fini != RMW_RET_OK) {\n-      PyErr_Format(module_state-\u003ERCLError, \u0022Failed to deallocate message buffer: %d\u0022, r_fini);\n-    }\n-    return NULL;\n-  }\n-\n-  ret = rcl_take_serialized_message(subscription, \u0026msg, message_info, NULL);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state-\u003ERCLError,\n-      \u0022Failed to take_serialized from a subscription: %s\u0022, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    rmw_ret_t r_fini = rmw_serialized_message_fini(\u0026msg);\n-    if (r_fini != RMW_RET_OK) {\n-      PyErr_Format(module_state-\u003ERCLError, \u0022Failed to deallocate message buffer: %d\u0022, r_fini);\n-    }\n-    return NULL;\n-  }\n-  PyObject * python_bytes = PyBytes_FromStringAndSize((char *)(msg.buffer), msg.buffer_length);\n-  rmw_ret_t r_fini = rmw_serialized_message_fini(\u0026msg);\n-  if (r_fini != RMW_RET_OK) {\n-    PyErr_Format(module_state-\u003ERCLError, \u0022Failed to deallocate message buffer: %d\u0022, r_fini);\n-    if (python_bytes) {\n-      Py_DECREF(python_bytes);\n-    }\n-    return NULL;\n-  }\n-  return python_bytes;\n-}\n-\n-static PyObject *\n-rclpy_message_info_to_dict(rmw_message_info_t * message_info)\n-{\n-  PyObject * dict = Py_BuildValue(\n-    \u0022{s:L,s:L}\u0022,\n-    \u0022source_timestamp\u0022, message_info-\u003Esource_timestamp,\n-    \u0022received_timestamp\u0022, message_info-\u003Ereceived_timestamp);\n-  if (dict == NULL) {\n-    PyErr_Format(PyExc_RuntimeError, \u0022Failed to create dictionary object for message info\u0022);\n-    return NULL;\n-  }\n-  return dict;\n-}\n-\n-/// Take a message and its message_info from a given subscription\n-/**\n- * \\param[in] pysubscription Capsule pointing to the subscription to process the message\n- * \\param[in] pymsg_type Instance of the message type to take\n- * \\return Tuple of (Python message with all fields populated with received message, message_info),\n- *         or None if there was no message to take.\n- */\n-static PyObject *\n-rclpy_take(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pysubscription;\n-  PyObject * pymsg_type;\n-  PyObject * pyraw;\n-  PyObject * pytaken_msg = NULL;\n-\n-  if (!PyArg_ParseTuple(args, \u0022OOO\u0022, \u0026pysubscription, \u0026pymsg_type, \u0026pyraw)) {\n-    return NULL;\n-  }\n-  if (!PyCapsule_CheckExact(pysubscription)) {\n-    PyErr_Format(PyExc_TypeError, \u0022Argument pysubscription is not a valid PyCapsule\u0022);\n-    return NULL;\n-  }\n-\n-  rclpy_subscription_t * sub =\n-    rclpy_handle_get_pointer_from_capsule(pysubscription, \u0022rclpy_subscription_t\u0022);\n-  if (!sub) {\n-    return NULL;\n-  }\n-\n-  rmw_message_info_t message_info;\n-  if (PyObject_IsTrue(pyraw) == 1) {  // raw=True\n-    pytaken_msg = rclpy_take_raw_with_info(module_state, \u0026(sub-\u003Esubscription), \u0026message_info);\n-  } else {\n-    destroy_ros_message_signature * destroy_ros_message = NULL;\n-    void * taken_msg = rclpy_create_from_py(pymsg_type, \u0026destroy_ros_message);\n-    if (!taken_msg) {\n-      return NULL;\n-    }\n-\n-    rcl_ret_t ret = rcl_take(\u0026(sub-\u003Esubscription), taken_msg, \u0026message_info, NULL);\n-\n-    if (ret != RCL_RET_OK \u0026\u0026 ret != RCL_RET_SUBSCRIPTION_TAKE_FAILED) {\n-      PyErr_Format(\n-        module_state-\u003ERCLError,\n-        \u0022Failed to take from a subscription: %s\u0022, rcl_get_error_string().str);\n-      rcl_reset_error();\n-      destroy_ros_message(taken_msg);\n-      return NULL;\n-    }\n-\n-    if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n-      Py_RETURN_NONE;\n-    }\n-\n-    pytaken_msg = rclpy_convert_to_py(taken_msg, pymsg_type);\n-    destroy_ros_message(taken_msg);\n-  }\n-  if (!pytaken_msg) {\n-    // the function has set the Python error\n-    return NULL;\n-  }\n-\n-  // make result tuple\n-  PyObject * mi_dict = rclpy_message_info_to_dict(\u0026message_info);\n-  if (mi_dict == NULL) {\n-    Py_DECREF(pytaken_msg);\n-    return NULL;\n-  }\n-  PyObject * tuple = PyTuple_Pack(2, pytaken_msg, mi_dict);\n-  Py_DECREF(pytaken_msg);\n-  Py_DECREF(mi_dict);\n-  return tuple;\n-}\n \n /// Request shutdown of the client library\n /**\n@@ -2021,11 \u002B1873,6 @@ static PyMethodDef rclpy_methods[] = {\n     \u0022Get subscriptions info for a topic.\u0022\n   },\n \n-  {\n-    \u0022rclpy_take\u0022, rclpy_take, METH_VARARGS,\n-    \u0022rclpy_take.\u0022\n-  },\n-\n   {\n     \u0022rclpy_shutdown\u0022, rclpy_shutdown, METH_VARARGS,\n     \u0022rclpy_shutdown.\u0022\ndiff --git rclpy/src/rclpy/_rclpy_pybind11.cpp rclpy/src/rclpy/_rclpy_pybind11.cpp\nindex 28fe8a7..9422e6a 100644\n--- rclpy/src/rclpy/_rclpy_pybind11.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/_rclpy_pybind11.cpp\n@@ -193,6 \u002B193,9 @@ PYBIND11_MODULE(_rclpy_pybind11, m) {\n   m.def(\n     \u0022rclpy_get_subscription_topic_name\u0022, \u0026rclpy::subscription_get_topic_name,\n     \u0022Get the topic name of a subscription\u0022);\n\u002B  m.def(\n\u002B    \u0022rclpy_take\u0022, \u0026rclpy::subscription_take_message,\n\u002B    \u0022Take a message and its metadata from a subscription\u0022);\n \n   m.def(\n     \u0022rclpy_create_time_point\u0022, \u0026rclpy::create_time_point,\ndiff --git rclpy/src/rclpy/serialization.cpp rclpy/src/rclpy/serialization.cpp\nindex 55fc68d..356e9e0 100644\n--- rclpy/src/rclpy/serialization.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/serialization.cpp\n@@ -33,32 \u002B33,27 @@\n \n namespace rclpy\n {\n-struct SerializedMessage\n\u002BSerializedMessage::SerializedMessage(rcutils_allocator_t allocator)\n {\n-  explicit SerializedMessage(rcutils_allocator_t allocator)\n-  {\n-    rcl_msg = rmw_get_zero_initialized_serialized_message();\n-    rcutils_ret_t rcutils_ret = rmw_serialized_message_init(\u0026rcl_msg, 0u, \u0026allocator);\n-    if (RCUTILS_RET_OK != rcutils_ret) {\n-      throw RCUtilsError(\u0022failed to initialize serialized message\u0022);\n-    }\n\u002B  rcl_msg = rmw_get_zero_initialized_serialized_message();\n\u002B  rcutils_ret_t rcutils_ret = rmw_serialized_message_init(\u0026rcl_msg, 0u, \u0026allocator);\n\u002B  if (RCUTILS_RET_OK != rcutils_ret) {\n\u002B    throw RCUtilsError(\u0022failed to initialize serialized message\u0022);\n   }\n\u002B}\n \n-  ~SerializedMessage()\n-  {\n-    rcutils_ret_t ret = rmw_serialized_message_fini(\u0026rcl_msg);\n-    if (RCUTILS_RET_OK != ret) {\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\n-        \u0022[rclpy|\u0022 RCUTILS_STRINGIFY(__FILE__) \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022]: \u0022\n-        \u0022failed to fini rcl_serialized_msg_t in destructor:\u0022);\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n-      rcutils_reset_error();\n-    }\n\u002BSerializedMessage::~SerializedMessage()\n\u002B{\n\u002B  rcutils_ret_t ret = rmw_serialized_message_fini(\u0026rcl_msg);\n\u002B  if (RCUTILS_RET_OK != ret) {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B      \u0022[rclpy|\u0022 RCUTILS_STRINGIFY(__FILE__) \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \u0022]: \u0022\n\u002B      \u0022failed to fini rcl_serialized_msg_t in destructor:\u0022);\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    rcutils_reset_error();\n   }\n-\n-  rcl_serialized_message_t rcl_msg;\n-};\n\u002B}\n \n py::bytes\n serialize(py::object pymsg, py::object pymsg_type)\ndiff --git rclpy/src/rclpy/serialization.hpp rclpy/src/rclpy/serialization.hpp\nindex e854c70..4181145 100644\n--- rclpy/src/rclpy/serialization.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/serialization.hpp\n@@ -17,10 \u002B17,23 @@\n \n #include \u003Cpybind11/pybind11.h\u003E\n \n\u002B#include \u003Crcl/types.h\u003E\n\u002B#include \u003Crcutils/allocator.h\u003E\n\u002B\n namespace py = pybind11;\n \n namespace rclpy\n {\n\u002B/// Helper struct to manage an rcl_serialized_message_t lifetime.\n\u002Bstruct SerializedMessage\n\u002B{\n\u002B  explicit SerializedMessage(rcutils_allocator_t allocator);\n\u002B\n\u002B  ~SerializedMessage();\n\u002B\n\u002B  rcl_serialized_message_t rcl_msg;\n\u002B};\n\u002B\n /// Serialize a ROS message\n /**\n  * Raises RCUtilsError on failure to initialize a serialized message\ndiff --git rclpy/src/rclpy/subscription.cpp rclpy/src/rclpy/subscription.cpp\nindex a387f45..98b81b5 100644\n--- rclpy/src/rclpy/subscription.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/subscription.cpp\n@@ -16,6 \u002B16,8 @@\n #include \u003Cpybind11/pybind11.h\u003E\n \n #include \u003Crcl/error_handling.h\u003E\n\u002B#include \u003Crcl/rcl.h\u003E\n\u002B#include \u003Crcl/types.h\u003E\n \n #include \u003Cmemory\u003E\n #include \u003Cstring\u003E\n@@ -25,7 \u002B27,11 @@\n \n #include \u0022rclpy_common/exceptions.hpp\u0022\n \n\u002B#include \u0022serialization.hpp\u0022\n #include \u0022subscription.hpp\u0022\n\u002B#include \u0022utils.hpp\u0022\n\u002B\n\u002Busing pybind11::literals::operator\u0022\u0022_a;\n \n namespace rclpy\n {\n@@ -122,6 \u002B128,59 @@ subscription_create(\n   return pysub;\n }\n \n\u002Bpy::object\n\u002Bsubscription_take_message(py::capsule pysubscription, py::object pymsg_type, bool raw)\n\u002B{\n\u002B  auto wrapper = static_cast\u003Crclpy_subscription_t *\u003E(\n\u002B    rclpy_handle_get_pointer_from_capsule(pysubscription.ptr(), \u0022rclpy_subscription_t\u0022));\n\u002B  if (!wrapper) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  py::object pytaken_msg;\n\u002B  rmw_message_info_t message_info;\n\u002B  if (raw) {\n\u002B    SerializedMessage taken{rcutils_get_default_allocator()};\n\u002B    rcl_ret_t ret = rcl_take_serialized_message(\n\u002B      \u0026(wrapper-\u003Esubscription), \u0026taken.rcl_msg, \u0026message_info, NULL);\n\u002B    if (RCL_RET_OK != ret) {\n\u002B      if (RCL_RET_BAD_ALLOC == ret) {\n\u002B        rcl_reset_error();\n\u002B        throw std::bad_alloc();\n\u002B      }\n\u002B      if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n\u002B        return py::none();\n\u002B      }\n\u002B      throw RCLError(\u0022failed to take raw message from subscription\u0022);\n\u002B    }\n\u002B    pytaken_msg = py::bytes(\n\u002B      reinterpret_cast\u003Cconst char *\u003E(taken.rcl_msg.buffer),\n\u002B      taken.rcl_msg.buffer_length);\n\u002B  } else {\n\u002B    auto taken_msg = create_from_py(pymsg_type);\n\u002B\n\u002B    rcl_ret_t ret = rcl_take(\n\u002B      \u0026(wrapper-\u003Esubscription), taken_msg.get(), \u0026message_info, NULL);\n\u002B    if (RCL_RET_OK != ret) {\n\u002B      if (RCL_RET_BAD_ALLOC == ret) {\n\u002B        rcl_reset_error();\n\u002B        throw std::bad_alloc();\n\u002B      }\n\u002B      if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n\u002B        return py::none();\n\u002B      }\n\u002B      throw RCLError(\u0022failed to take message from subscription\u0022);\n\u002B    }\n\u002B\n\u002B    pytaken_msg = convert_to_py(taken_msg.get(), pymsg_type);\n\u002B  }\n\u002B\n\u002B  return py::make_tuple(\n\u002B    pytaken_msg, py::dict(\n\u002B      \u0022source_timestamp\u0022_a = message_info.source_timestamp,\n\u002B      \u0022received_timestamp\u0022_a = message_info.received_timestamp));\n\u002B}\n\u002B\n py::object\n subscription_get_logger_name(py::capsule pysubscription)\n {\ndiff --git rclpy/src/rclpy/subscription.hpp rclpy/src/rclpy/subscription.hpp\nindex 54721ae..48a8b7d 100644\n--- rclpy/src/rclpy/subscription.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/subscription.hpp\n@@ -46,6 \u002B46,22 @@ subscription_create(\n   py::capsule pynode, py::object pymsg_type, std::string topic,\n   py::capsule pyqos_profile);\n \n\u002B/// Take a message and its metadata from a subscription\n\u002B/**\n\u002B * Raises ValueError if pysubscription is not subscription capsule\n\u002B * Raises MemoryError if there was error allocating memory\n\u002B * Raises RCLError if there was an error within rcl\n\u002B *\n\u002B * \\param[in] pysubscription Capsule pointing to the subscription.\n\u002B * \\param[in] pymsg_type Message type to be taken (i.e. a class).\n\u002B * \\param[in] raw If True, return the message without de-serializing it.\n\u002B * \\return Tuple of (message, metadata) or None if there was no message to take.\n\u002B *   Message is a \\p pymsg_type instance if \\p raw is True, otherwise a byte string.\n\u002B *   Metadata is a plain dictionary.\n\u002B */\n\u002Bpy::object\n\u002Bsubscription_take_message(py::capsule pysubscription, py::object pymsg_type, bool raw);\n\u002B\n /// Get the name of the logger associated with the node of the subscription.\n /**\n  * Raises ValueError if pysubscription is not a subscription capsule\ndiff --git rclpy/src/rclpy/utils.cpp rclpy/src/rclpy/utils.cpp\nindex 4097355..cf135e9 100644\n--- rclpy/src/rclpy/utils.cpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.cpp\n@@ -16,6 \u002B16,8 @@\n \n #include \u003Cpybind11/pybind11.h\u003E\n \n\u002B#include \u003Cmemory\u003E\n\u002B\n #include \u0022rcl/error_handling.h\u0022\n \n #include \u0022utils.hpp\u0022\n@@ -40,4 \u002B42,51 @@ convert_to_py_names_and_types(const rcl_names_and_types_t * names_and_types)\n   return py_names_and_types;\n }\n \n\u002Bstd::unique_ptr\u003Cvoid, destroy_ros_message_function *\u003E\n\u002Bcreate_from_py(py::object pymessage)\n\u002B{\n\u002B  typedef void * create_ros_message_function (void);\n\u002B\n\u002B  py::object pymetaclass = pymessage.attr(\u0022__class__\u0022);\n\u002B\n\u002B  py::object value = pymetaclass.attr(\u0022_CREATE_ROS_MESSAGE\u0022);\n\u002B  auto capsule_ptr = static_cast\u003Cvoid *\u003E(value.cast\u003Cpy::capsule\u003E());\n\u002B  auto create_ros_message =\n\u002B    reinterpret_cast\u003Ccreate_ros_message_function *\u003E(capsule_ptr);\n\u002B  if (!create_ros_message) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  value = pymetaclass.attr(\u0022_DESTROY_ROS_MESSAGE\u0022);\n\u002B  capsule_ptr = static_cast\u003Cvoid *\u003E(value.cast\u003Cpy::capsule\u003E());\n\u002B  auto destroy_ros_message =\n\u002B    reinterpret_cast\u003Cdestroy_ros_message_function *\u003E(capsule_ptr);\n\u002B  if (!destroy_ros_message) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B\n\u002B  void * message = create_ros_message();\n\u002B  if (!message) {\n\u002B    throw std::bad_alloc();\n\u002B  }\n\u002B  return std::unique_ptr\u003C\n\u002B    void, destroy_ros_message_function *\u003E(message, destroy_ros_message);\n\u002B}\n\u002B\n\u002Bpy::object\n\u002Bconvert_to_py(void * message, py::object pyclass)\n\u002B{\n\u002B  py::object pymetaclass = pyclass.attr(\u0022__class__\u0022);\n\u002B\n\u002B  auto capsule_ptr = static_cast\u003Cvoid *\u003E(\n\u002B    pymetaclass.attr(\u0022_CONVERT_TO_PY\u0022).cast\u003Cpy::capsule\u003E());\n\u002B\n\u002B  typedef PyObject * convert_to_py_function (void *);\n\u002B  auto convert = reinterpret_cast\u003Cconvert_to_py_function *\u003E(capsule_ptr);\n\u002B  if (!convert) {\n\u002B    throw py::error_already_set();\n\u002B  }\n\u002B  return py::reinterpret_steal\u003Cpy::object\u003E(convert(message));\n\u002B}\n\u002B\n }  // namespace rclpy\ndiff --git rclpy/src/rclpy/utils.hpp rclpy/src/rclpy/utils.hpp\nindex f03f795..4760292 100644\n--- rclpy/src/rclpy/utils.hpp\n\u002B\u002B\u002B rclpy/src/rclpy/utils.hpp\n@@ -19,11 \u002B19,15 @@\n \n #include \u003Crcl/graph.h\u003E  // rcl_names_and_types_t\n \n\u002B#include \u003Cmemory\u003E\n\u002B\n namespace py = pybind11;\n \n namespace rclpy\n {\n \n\u002Btypedef void destroy_ros_message_function (void *);\n\u002B\n /// Convert a C rcl_names_and_types_t into a Python list.\n /**\n  * \\param[in] names_and_types The names and types struct to convert.\n@@ -33,6 \u002B37,27 @@ namespace rclpy\n py::list\n convert_to_py_names_and_types(const rcl_names_and_types_t * topic_names_and_types);\n \n\u002B/// Create the equivalent ROS message C type instance for a given Python type.\n\u002B/**\n\u002B* Raises AttributeError if \\p pyclass is missing a required attribute.\n\u002B*\n\u002B* \\param[in] pyclass ROS message Python type to extract typesupport data from.\n\u002B* \\return a ROS message C type instance.\n\u002B*/\n\u002Bstd::unique_ptr\u003Cvoid, destroy_ros_message_function *\u003E\n\u002Bcreate_from_py(py::object pyclass);\n\u002B\n\u002B/// Convert a ROS message from a C type to a Python type.\n\u002B/**\n\u002B * Raises AttributeError if \\p pyclass is missing a required attribute.\n\u002B *\n\u002B * \\param[in] message ROS message C type instance to be converted.\n\u002B * \\param[in] pyclass ROS message Python type to convert to.\n\u002B * \\return an instance of \\p pyclass.\n\u002B */\n\u002Bpy::object\n\u002Bconvert_to_py(void * message, py::object pyclass);\n\u002B\n }  // namespace rclpy\n \n #endif  // RCLPY__UTILS_HPP_\n",
    "IsBackported": false
  },
  {
    "Repository": "common_interfaces",
    "SHA": "d2bff0d7553f90d230ac9e143eff07533c946a9b",
    "RawMessage": "Update common_interfaces to C\u002B\u002B17. (#215)",
    "Changes": "diff --git actionlib_msgs/CMakeLists.txt actionlib_msgs/CMakeLists.txt\nindex 8fa60ec..bff3035 100644\n--- actionlib_msgs/CMakeLists.txt\n\u002B\u002B\u002B actionlib_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(actionlib_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git diagnostic_msgs/CMakeLists.txt diagnostic_msgs/CMakeLists.txt\nindex 6de26ca..f8c8deb 100644\n--- diagnostic_msgs/CMakeLists.txt\n\u002B\u002B\u002B diagnostic_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(diagnostic_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git geometry_msgs/CMakeLists.txt geometry_msgs/CMakeLists.txt\nindex 678f678..df9a8d6 100644\n--- geometry_msgs/CMakeLists.txt\n\u002B\u002B\u002B geometry_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(geometry_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git nav_msgs/CMakeLists.txt nav_msgs/CMakeLists.txt\nindex 8706291..1533119 100644\n--- nav_msgs/CMakeLists.txt\n\u002B\u002B\u002B nav_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(nav_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git sensor_msgs/CMakeLists.txt sensor_msgs/CMakeLists.txt\nindex 8027c23..a7ba55e 100644\n--- sensor_msgs/CMakeLists.txt\n\u002B\u002B\u002B sensor_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(sensor_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git shape_msgs/CMakeLists.txt shape_msgs/CMakeLists.txt\nindex 109df73..a97892d 100644\n--- shape_msgs/CMakeLists.txt\n\u002B\u002B\u002B shape_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(shape_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git std_msgs/CMakeLists.txt std_msgs/CMakeLists.txt\nindex 354f1a9..9770ecf 100644\n--- std_msgs/CMakeLists.txt\n\u002B\u002B\u002B std_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(std_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git std_srvs/CMakeLists.txt std_srvs/CMakeLists.txt\nindex 17e76d2..0706146 100644\n--- std_srvs/CMakeLists.txt\n\u002B\u002B\u002B std_srvs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(std_srvs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git stereo_msgs/CMakeLists.txt stereo_msgs/CMakeLists.txt\nindex 99da8dc..4119887 100644\n--- stereo_msgs/CMakeLists.txt\n\u002B\u002B\u002B stereo_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(stereo_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git trajectory_msgs/CMakeLists.txt trajectory_msgs/CMakeLists.txt\nindex 48d48bc..f3edac2 100644\n--- trajectory_msgs/CMakeLists.txt\n\u002B\u002B\u002B trajectory_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(trajectory_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\ndiff --git visualization_msgs/CMakeLists.txt visualization_msgs/CMakeLists.txt\nindex 7a239b4..a6d456f 100644\n--- visualization_msgs/CMakeLists.txt\n\u002B\u002B\u002B visualization_msgs/CMakeLists.txt\n@@ -2,9 \u002B2,10 @@ cmake_minimum_required(VERSION 3.5)\n \n project(visualization_msgs)\n \n-# Default to C\u002B\u002B14\n\u002B# Default to C\u002B\u002B17\n if(NOT CMAKE_CXX_STANDARD)\n-  set(CMAKE_CXX_STANDARD 14)\n\u002B  set(CMAKE_CXX_STANDARD 17)\n\u002B  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n endif()\n if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n   add_compile_options(-Wall -Wextra -Wpedantic)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclc",
    "SHA": "688bd28a605c11dd25668233f72c45e64dc62f21",
    "RawMessage": "Add empty set_atomically parameter service (#354)",
    "Changes": "diff --git rclc_parameter/include/rclc_parameter/rclc_parameter.h rclc_parameter/include/rclc_parameter/rclc_parameter.h\nindex 1f4aa2b..fb89746 100644\n--- rclc_parameter/include/rclc_parameter/rclc_parameter.h\n\u002B\u002B\u002B rclc_parameter/include/rclc_parameter/rclc_parameter.h\n@@ -34,6 \u002B34,7 @@ extern \u0022C\u0022\n #include \u003Crcl_interfaces/msg/set_parameters_result.h\u003E\n #include \u003Crcl_interfaces/srv/list_parameters.h\u003E\n #include \u003Crcl_interfaces/srv/set_parameters.h\u003E\n\u002B#include \u003Crcl_interfaces/srv/set_parameters_atomically.h\u003E\n #include \u003Crcl_interfaces/srv/describe_parameters.h\u003E\n #include \u003Crcl_interfaces/msg/parameter_descriptor.h\u003E\n #include \u003Crosidl_runtime_c/string_functions.h\u003E\n@@ -53,6 \u002B54,10 @@ typedef struct rcl_interfaces__srv__SetParameters_Request SetParameters_Request;\n typedef struct rcl_interfaces__srv__SetParameters_Response SetParameters_Response;\n typedef struct rcl_interfaces__msg__SetParametersResult SetParameters_Result;\n \n\u002Btypedef struct rcl_interfaces__srv__SetParametersAtomically_Request SetParametersAtomically_Request;\n\u002Btypedef struct rcl_interfaces__srv__SetParametersAtomically_Response\n\u002B  SetParametersAtomically_Response;\n\u002B\n typedef struct rcl_interfaces__srv__DescribeParameters_Request DescribeParameters_Request;\n typedef struct rcl_interfaces__srv__DescribeParameters_Response DescribeParameters_Response;\n \n@@ -67,7 \u002B72,7 @@ typedef struct rcl_interfaces__msg__ParameterDescriptor__Sequence ParameterDescr\n typedef struct rcl_interfaces__msg__ParameterEvent ParameterEvent;\n \n // Number of RCLC executor handles required for a parameter server\n-#define RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES 5\n\u002B#define RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES 6\n #define RCLC_PARAMETER_MODIFICATION_REJECTED 4001\n #define RCLC_PARAMETER_TYPE_MISMATCH 4002\n #define RCLC_PARAMETER_UNSUPORTED_ON_LOW_MEM 4003\n@@ -124,6 \u002B129,7 @@ typedef struct rclc_parameter_server_t\n   rcl_service_t get_service;\n   rcl_service_t get_types_service;\n   rcl_service_t set_service;\n\u002B  rcl_service_t set_atomically_service;\n   rcl_service_t list_service;\n   rcl_service_t describe_service;\n   rcl_publisher_t event_publisher;\n@@ -137,6 \u002B143,9 @@ typedef struct rclc_parameter_server_t\n   SetParameters_Request set_request;\n   SetParameters_Response set_response;\n \n\u002B  SetParametersAtomically_Request set_atomically_request;\n\u002B  SetParametersAtomically_Response set_atomically_response;\n\u002B\n   ListParameters_Request list_request;\n   ListParameters_Response list_response;\n \ndiff --git rclc_parameter/src/rclc_parameter/parameter_server.c rclc_parameter/src/rclc_parameter/parameter_server.c\nindex b34ed00..5b14f24 100644\n--- rclc_parameter/src/rclc_parameter/parameter_server.c\n\u002B\u002B\u002B rclc_parameter/src/rclc_parameter/parameter_server.c\n@@ -327,6 \u002B327,19 @@ rclc_parameter_server_set_service_callback(\n   }\n }\n \n\u002Bvoid\n\u002Brclc_parameter_server_set_atomically_service_callback(\n\u002B  const void * req,\n\u002B  void * res,\n\u002B  void * parameter_server)\n\u002B{\n\u002B  (void) req;\n\u002B  (void) res;\n\u002B  (void) parameter_server;\n\u002B\n\u002B  return;\n\u002B}\n\u002B\n const rclc_parameter_options_t DEFAULT_PARAMETER_SERVER_OPTIONS = {\n   .notify_changed_over_dds = true,\n   .max_params = 4,\n@@ -430,6 \u002B443,26 @@ init_parameter_server_memory(\n       \u0026parameter_server-\u003Eset_response.results.data[i].reason);\n   }\n \n\u002B  // Init SetAtomically service msgs\n\u002B  mem_allocs_ok \u0026=\n\u002B    rcl_interfaces__srv__SetParametersAtomically_Request__init(\n\u002B    \u0026parameter_server-\u003Eset_atomically_request);\n\u002B  mem_allocs_ok \u0026=\n\u002B    rcl_interfaces__srv__SetParametersAtomically_Response__init(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response);\n\u002B  mem_allocs_ok \u0026= rcl_interfaces__msg__Parameter__Sequence__init(\n\u002B    \u0026parameter_server-\u003Eset_atomically_request.parameters,\n\u002B    options-\u003Emax_params);\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.size = 0;\n\u002B  mem_allocs_ok \u0026= rclc_parameter_descriptor_initialize_string(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response.result.reason);\n\u002B\n\u002B  // Set response result to unimplemented\n\u002B  rclc_parameter_set_string(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response.result.reason,\n\u002B    \u0022Unimplemented service\u0022);\n\u002B  parameter_server-\u003Eset_atomically_response.result.successful = false;\n\u002B\n   // Init Get types service msgs\n   mem_allocs_ok \u0026= rcl_interfaces__srv__GetParameterTypes_Request__init(\n     \u0026parameter_server-\u003Eget_types_request);\n@@ -651,6 \u002B684,28 @@ rcl_ret_t init_parameter_server_memory_low(\n     \u0026parameter_server-\u003Eset_response.results.data[0].reason,\n     RCLC_SET_ERROR_MAX_STRING_LENGTH);\n \n\u002B  // Init SetAtomically service msgs\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.data = allocator.zero_allocate(\n\u002B    1, sizeof(Parameter),\n\u002B    allocator.state);\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.size = 0;\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.capacity = 1;\n\u002B\n\u002B  ret |= rclc_parameter_initialize_empty_string(\n\u002B    \u0026parameter_server-\u003Eset_atomically_request.parameters.data[0].name,\n\u002B    RCLC_PARAMETER_MAX_STRING_LENGTH);\n\u002B\n\u002B  char * unimplemented_msg = \u0022Unimplemented service\u0022;\n\u002B  ret |= rclc_parameter_initialize_empty_string(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response.result.reason,\n\u002B    strlen(unimplemented_msg) \u002B 1);\n\u002B\n\u002B  // Set response result to unimplemented\n\u002B  rclc_parameter_set_string(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response.result.reason,\n\u002B    unimplemented_msg);\n\u002B  parameter_server-\u003Eset_atomically_response.result.successful = false;\n\u002B\n   // Get parameter types:\n   //    - Only one parameter type can be retrieved per request\n   parameter_server-\u003Eget_types_request.names.data =\n@@ -764,6 \u002B819,14 @@ rclc_parameter_server_init_with_option(\n     \u0026parameter_server-\u003Eset_service, node, \u0022/set_parameters\u0022,\n     set_ts);\n \n\u002B  const rosidl_service_type_support_t * set_atom_ts = ROSIDL_GET_SRV_TYPE_SUPPORT(\n\u002B    rcl_interfaces,\n\u002B    srv,\n\u002B    SetParametersAtomically);\n\u002B  ret |= rclc_parameter_server_init_service(\n\u002B    \u0026parameter_server-\u003Eset_atomically_service, node, \u0022/set_parameters_atomically\u0022,\n\u002B    set_atom_ts);\n\u002B\n   const rosidl_service_type_support_t * list_ts = ROSIDL_GET_SRV_TYPE_SUPPORT(\n     rcl_interfaces,\n     srv,\n@@ -840,6 \u002B903,19 @@ rclc_parameter_server_fini_memory_low(\n   parameter_server-\u003Eset_response.results.capacity = 0;\n   parameter_server-\u003Eset_response.results.size = 0;\n \n\u002B  // Set atomically request\n\u002B  allocator.deallocate(\n\u002B    parameter_server-\u003Eset_atomically_request.parameters.data[0].name.data,\n\u002B    allocator.state);\n\u002B  allocator.deallocate(parameter_server-\u003Eset_atomically_request.parameters.data, allocator.state);\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.capacity = 0;\n\u002B  parameter_server-\u003Eset_atomically_request.parameters.size = 0;\n\u002B\n\u002B  // Set atomically response\n\u002B  allocator.deallocate(\n\u002B    parameter_server-\u003Eset_atomically_response.result.reason.data,\n\u002B    allocator.state);\n\u002B\n   // List response\n   for (size_t i = 0; i \u003C parameter_server-\u003Elist_response.result.names.capacity; \u002B\u002Bi) {\n     parameter_server-\u003Elist_response.result.names.data[i].data = NULL;\n@@ -965,6 \u002B1041,20 @@ rclc_parameter_server_fini_memory(\n   rcl_interfaces__srv__SetParameters_Response__fini(\u0026parameter_server-\u003Eset_response);\n   rcl_interfaces__srv__SetParameters_Request__fini(\u0026parameter_server-\u003Eset_request);\n \n\u002B  // Finish set atomically msgs\n\u002B  for (size_t i = 0; i \u003C parameter_server-\u003Eset_atomically_request.parameters.capacity; \u002B\u002Bi) {\n\u002B    rosidl_runtime_c__String__fini(\n\u002B      \u0026parameter_server-\u003Eset_atomically_request.parameters.data[i].name);\n\u002B  }\n\u002B\n\u002B  rosidl_runtime_c__String__fini(\u0026parameter_server-\u003Eset_atomically_response.result.reason);\n\u002B  rcl_interfaces__msg__Parameter__Sequence__fini(\n\u002B    \u0026parameter_server-\u003Eset_atomically_request.parameters);\n\u002B  rcl_interfaces__srv__SetParametersAtomically_Response__fini(\n\u002B    \u0026parameter_server-\u003Eset_atomically_response);\n\u002B  rcl_interfaces__srv__SetParametersAtomically_Request__fini(\n\u002B    \u0026parameter_server-\u003Eset_atomically_request);\n\u002B\n   // Finish get msgs\n   for (size_t i = 0; i \u003C parameter_server-\u003Eget_request.names.capacity; \u002B\u002Bi) {\n     rosidl_runtime_c__String__fini(\u0026parameter_server-\u003Eget_request.names.data[i]);\n@@ -1025,6 \u002B1115,7 @@ rclc_parameter_server_fini(\n \n   ret |= rcl_service_fini(\u0026parameter_server-\u003Elist_service, node);\n   ret |= rcl_service_fini(\u0026parameter_server-\u003Eset_service, node);\n\u002B  ret |= rcl_service_fini(\u0026parameter_server-\u003Eset_atomically_service, node);\n   ret |= rcl_service_fini(\u0026parameter_server-\u003Eget_service, node);\n   ret |= rcl_service_fini(\u0026parameter_server-\u003Eget_types_service, node);\n   ret |= rcl_service_fini(\u0026parameter_server-\u003Edescribe_service, node);\n@@ -1085,6 \u002B1176,12 @@ rclc_executor_add_parameter_server_with_context(\n     rclc_parameter_server_set_service_callback,\n     parameter_server);\n \n\u002B  ret |= rclc_executor_add_service_with_context(\n\u002B    executor, \u0026parameter_server-\u003Eset_atomically_service,\n\u002B    \u0026parameter_server-\u003Eset_atomically_request, \u0026parameter_server-\u003Eset_atomically_response,\n\u002B    rclc_parameter_server_set_atomically_service_callback,\n\u002B    parameter_server);\n\u002B\n   ret |= rclc_executor_add_service_with_context(\n     executor, \u0026parameter_server-\u003Eget_service,\n     \u0026parameter_server-\u003Eget_request, \u0026parameter_server-\u003Eget_response,\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "fbe9254e5eb11000877f8332f634eb2f7d6d4c4e",
    "RawMessage": "Use official freetype github mirror instead of savannah (#1348)",
    "Changes": "diff --git rviz_ogre_vendor/CMakeLists.txt rviz_ogre_vendor/CMakeLists.txt\nindex b7cd36a2..6fdcfe0b 100644\n--- rviz_ogre_vendor/CMakeLists.txt\n\u002B\u002B\u002B rviz_ogre_vendor/CMakeLists.txt\n@@ -14,7 \u002B14,7 @@ if(WIN32)\n   endif()\n \n   ament_vendor(freetype_vendor\n-    VCS_URL https://git.savannah.gnu.org/git/freetype/freetype2.git\n\u002B    VCS_URL https://github.com/freetype/freetype.git\n     VCS_VERSION VER-2-13-2\n     CMAKE_ARGS\n       -DFT_DISABLE_ZLIB:BOOL=ON\n",
    "IsBackported": false
  },
  {
    "Repository": "rosidl_typesupport_fastrtps",
    "SHA": "152c360d6f241da75d5acb731d738c08bd419631",
    "RawMessage": "Use FindPython3 explicitly instead of PythonInterp implicitly (#78)",
    "Changes": "diff --git rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\nindex ea0726d..9d2cf27 100644\n--- rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/cmake/rosidl_typesupport_fastrtps_c_generate_interfaces.cmake\n@@ -67,9 \u002B67,12 @@ rosidl_write_generator_arguments(\n   TARGET_DEPENDENCIES ${target_dependencies}\n )\n \n\u002Bfind_package(Python3 REQUIRED COMPONENTS Interpreter)\n\u002B\n add_custom_command(\n   OUTPUT ${_generated_files}\n-  COMMAND ${PYTHON_EXECUTABLE} ${rosidl_typesupport_fastrtps_c_BIN}\n\u002B  COMMAND Python3::Interpreter\n\u002B  ARGS ${rosidl_typesupport_fastrtps_c_BIN}\n   --generator-arguments-file \u0022${generator_arguments_file}\u0022\n   DEPENDS ${target_dependencies}\n   COMMENT \u0022Generating C type support for eProsima Fast-RTPS\u0022\ndiff --git rosidl_typesupport_fastrtps_c/package.xml rosidl_typesupport_fastrtps_c/package.xml\nindex d2f6612..5a92799 100644\n--- rosidl_typesupport_fastrtps_c/package.xml\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_c/package.xml\n@@ -19,6 \u002B19,7 @@\n   \u003Cbuildtool_export_depend\u003Eament_cmake_ros\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Efastrtps_cmake_module\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Efastcdr\u003C/buildtool_export_depend\u003E\n\u002B  \u003Cbuildtool_export_depend\u003Epython3\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_cmake\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_parser\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_runtime_c\u003C/buildtool_export_depend\u003E\ndiff --git rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\nindex 09a474e..6b55082 100644\n--- rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/cmake/rosidl_typesupport_fastrtps_cpp_generate_interfaces.cmake\n@@ -77,10 \u002B77,13 @@ rosidl_write_generator_arguments(\n   TARGET_DEPENDENCIES ${target_dependencies}\n )\n \n\u002Bfind_package(Python3 REQUIRED COMPONENTS Interpreter)\n\u002B\n # Add a command that invokes generator at build time\n add_custom_command(\n   OUTPUT ${_generated_files}\n-  COMMAND ${PYTHON_EXECUTABLE} ${rosidl_typesupport_fastrtps_cpp_BIN}\n\u002B  COMMAND Python3::Interpreter\n\u002B  ARGS ${rosidl_typesupport_fastrtps_cpp_BIN}\n   --generator-arguments-file \u0022${generator_arguments_file}\u0022\n   DEPENDS ${target_dependencies}\n   COMMENT \u0022Generating C\u002B\u002B type support for eProsima Fast-RTPS\u0022\ndiff --git rosidl_typesupport_fastrtps_cpp/package.xml rosidl_typesupport_fastrtps_cpp/package.xml\nindex c35cb37..0af9782 100644\n--- rosidl_typesupport_fastrtps_cpp/package.xml\n\u002B\u002B\u002B rosidl_typesupport_fastrtps_cpp/package.xml\n@@ -19,6 \u002B19,7 @@\n   \u003Cbuildtool_export_depend\u003Eament_cmake_ros\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Efastrtps_cmake_module\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Efastcdr\u003C/buildtool_export_depend\u003E\n\u002B  \u003Cbuildtool_export_depend\u003Epython3\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_cmake\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_parser\u003C/buildtool_export_depend\u003E\n   \u003Cbuildtool_export_depend\u003Erosidl_runtime_c\u003C/buildtool_export_depend\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "2f0eed30896aa86409fde93f3dad0cad47f92b66",
    "RawMessage": "Use FindPython3 explicitly instead of FindPythonInterp implicitly (#345)",
    "Changes": "diff --git CMakeLists.txt CMakeLists.txt\nindex d01470a..a28d2da 100644\n--- CMakeLists.txt\n\u002B\u002B\u002B CMakeLists.txt\n@@ -1,4 \u002B1,4 @@\n-cmake_minimum_required(VERSION 3.5)\n\u002Bcmake_minimum_required(VERSION 3.12)\n \n project(rcutils)\n \n@@ -16,6 \u002B16,8 @@ include(CheckLibraryExists)\n find_package(ament_cmake_python REQUIRED)\n find_package(ament_cmake_ros REQUIRED)\n \n\u002Bfind_package(Python3 REQUIRED COMPONENTS Interpreter)\n\u002B\n ament_python_install_package(${PROJECT_NAME})\n \n if(UNIX AND NOT APPLE)\n@@ -102,7 \u002B104,7 @@ em.invoke( \\\n string(REPLACE \u0022;\u0022 \u0022$\u003CSEMICOLON\u003E\u0022 python_code \u0022${python_code}\u0022)\n add_custom_command(OUTPUT include/rcutils/logging_macros.h\n   COMMAND ${CMAKE_COMMAND} -E make_directory \u0022include/rcutils\u0022\n-  COMMAND ${PYTHON_EXECUTABLE} ARGS -c \u0022${python_code}\u0022\n\u002B  COMMAND Python3::Interpreter ARGS -c \u0022${python_code}\u0022\n   DEPENDS\n     \u0022${CMAKE_CURRENT_BINARY_DIR}/logging_macros.h.em.watch\u0022\n     \u0022${CMAKE_CURRENT_BINARY_DIR}/logging.py.watch\u0022\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "0e75d8767dd45f8d9c174e1ddb26dda02e1d403f",
    "RawMessage": "Make sure to catch the ROSInterruptException when calling rate.sleep.",
    "Changes": "diff --git rclpy/rclpy/timer.py rclpy/rclpy/timer.py\nindex a1a5867..0191712 100644\n--- rclpy/rclpy/timer.py\n\u002B\u002B\u002B rclpy/rclpy/timer.py\n@@ -131,6 \u002B131,7 @@ class Rate:\n                 self._event.clear()\n         if self._is_shutdown:\n             self.destroy()\n\u002B            raise ROSInterruptException()\n \n     def sleep(self):\n         \u0022\u0022\u0022\ndiff --git rclpy/test/test_rate.py rclpy/test/test_rate.py\nindex 97ff3d2..f0c83bc 100644\n--- rclpy/test/test_rate.py\n\u002B\u002B\u002B rclpy/test/test_rate.py\n@@ -111,6 \u002B111,15 @@ class TestRate:\n         self._thread.join()\n \n \n\u002Bdef sleep_check_exception(rate):\n\u002B    try:\n\u002B        rate.sleep()\n\u002B    except ROSInterruptException:\n\u002B        # rate.sleep() can raise ROSInterruptException if the context is\n\u002B        # shutdown while it is sleeping.  Just ignore it here.\n\u002B        pass\n\u002B\n\u002B\n def test_shutdown_wakes_rate():\n     context = rclpy.context.Context()\n     rclpy.init(context=context)\n@@ -120,7 \u002B129,7 @@ def test_shutdown_wakes_rate():\n \n     rate = node.create_rate(0.0000001)\n \n-    _thread = threading.Thread(target=rate.sleep, daemon=True)\n\u002B    _thread = threading.Thread(target=sleep_check_exception, args=rate, daemon=True)\n     _thread.start()\n     executor.shutdown()\n     node.destroy_node()\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "0dc0f5bb52f57b57b631974241319ea80dc67373",
    "RawMessage": "Suppress warnings when building with older Qt versions. (#562)",
    "Changes": "diff --git rviz_default_plugins/test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp rviz_default_plugins/test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\nindex 5b997b8d..599e8596 100644\n--- rviz_default_plugins/test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/view_controllers/view_controller_test_fixture.hpp\n@@ -98,10 \u002B98,10 @@ public:\n   rviz_common::ViewportMouseEvent generateMouseWheelEvent(int delta)\n   {\n     auto point = QPointF();\n\u002B#if (QT_VERSION \u003E= QT_VERSION_CHECK(5, 14, 0))\n     auto global_point = QPointF();\n     auto pixel_delta = QPoint();\n     auto angle_delta = QPoint(delta, 0);\n-#if (QT_VERSION \u003E= QT_VERSION_CHECK(5, 14, 0))\n     auto mouseEvent = new QWheelEvent(\n       point,\n       global_point,\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "9d0dec6270766f2249e27d17280071c68b4a06de",
    "RawMessage": "Always modify UserObjectQosPolicy regardless of override policy (#53)",
    "Changes": "diff --git rmw_connextdds_common/src/ndds/dds_api_ndds.cpp rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\nindex 1376b0f..546daea 100644\n--- rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\n\u002B\u002B\u002B rmw_connextdds_common/src/ndds/dds_api_ndds.cpp\n@@ -88,6 \u002B88,24 @@ rmw_connextdds_initialize_participant_qos_impl(\n   rmw_context_impl_t * const ctx,\n   DDS_DomainParticipantQos * const dp_qos)\n {\n\u002B#if RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP\n\u002B  // UserObjectQosPolicy is an internal, undocumented Connext policy used by the\n\u002B  // implementations of different language bindings to control the memory\n\u002B  // representations of various objects created by user applications. In this\n\u002B  // case, the settings match the requirements of the \u0022modern C\u002B\u002B\u0022 API, and they\n\u002B  // allow the DomainParticipant to be used directly by applications that want\n\u002B  // to create new entities in C\u002B\u002B11, even though the participant was created\n\u002B  // using the C API. If these settings are not specified, an application will\n\u002B  // receive a SIGSEGV when trying to create one of these entities.\n\u002B  //\n\u002B  // The customizations are always applied regardless of the QoS override policy\n\u002B  // because UserObjectQosPolicy cannot be modified from XML.\n\u002B  //\n\u002B  dp_qos-\u003Euser_object.flow_controller_user_object.size = sizeof(void *);\n\u002B  dp_qos-\u003Euser_object.topic_user_object.size = sizeof(void *);\n\u002B  dp_qos-\u003Euser_object.content_filtered_topic_user_object.size = sizeof(void *);\n\u002B#endif /* RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP */\n\u002B\n   switch (ctx-\u003Eparticipant_qos_override_policy) {\n     case rmw_context_impl_t::participant_qos_override_policy_t::All:\n     case rmw_context_impl_t::participant_qos_override_policy_t::Basic:\n@@ -208,20 \u002B226,6 @@ rmw_connextdds_initialize_participant_qos_impl(\n   }\n #endif /* RMW_CONNEXT_FAST_ENDPOINT_DISCOVERY */\n \n-#if RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP\n-  // UserObjectQosPolicy is an internal, undocumented Connext policy used by the\n-  // implementations of different language bindings to control the memory\n-  // representations of various objects created by user applications. In this\n-  // case, the settings match the requirements of the \u0022modern C\u002B\u002B\u0022 API, and they\n-  // allow the DomainParticipant to be used directly by applications that want\n-  // to create new entities in C\u002B\u002B11, even though the participant was created\n-  // using the C API. If these settings are not specified, an application will\n-  // receive a SIGSEGV when trying to create one of these entities.\n-  dp_qos-\u003Euser_object.flow_controller_user_object.size = sizeof(void *);\n-  dp_qos-\u003Euser_object.topic_user_object.size = sizeof(void *);\n-  dp_qos-\u003Euser_object.content_filtered_topic_user_object.size = sizeof(void *);\n-#endif /* RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP */\n-\n   return RMW_RET_OK;\n }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "common_interfaces",
    "SHA": "cc3da3b045c0b151a3aab46002396ee7fc6c8421",
    "RawMessage": "Use target qualifier for checking the cpp typesupport exists (#238)",
    "Changes": "diff --git sensor_msgs/CMakeLists.txt sensor_msgs/CMakeLists.txt\nindex a7ba55e..3c76755 100644\n--- sensor_msgs/CMakeLists.txt\n\u002B\u002B\u002B sensor_msgs/CMakeLists.txt\n@@ -64,7 \u002B64,7 @@ if(BUILD_TESTING)\n   ament_lint_auto_find_test_dependencies()\n endif()\n \n-if(cpp_typesupport_target)\n\u002Bif(TARGET \u0022${cpp_typesupport_target}\u0022)\n   add_library(${PROJECT_NAME}_library INTERFACE)\n   target_include_directories(${PROJECT_NAME}_library INTERFACE\n   \u0022$\u003CBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003E\u0022\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "8bf120b321fb7fe8aac7160159f8ee26b4cf95c7",
    "RawMessage": "test should check specified number of entities. (#935)",
    "Changes": "diff --git rcl/src/rcl/graph.c rcl/src/rcl/graph.c\nindex 6095cc3..5ba0a0a 100644\n--- rcl/src/rcl/graph.c\n\u002B\u002B\u002B rcl/src/rcl/graph.c\n@@ -481,7 \u002B481,7 @@ _rcl_wait_for_entities(\n   rcl_ret_t ret = RCL_RET_OK;\n   *success = false;\n \n-  // We can avoid waiting if there are already the expected number of publishers\n\u002B  // We can avoid waiting if there are already the expected number of entities\n   size_t count = 0u;\n   ret = count_entities_func(node, topic_name, \u0026count);\n   if (ret != RCL_RET_OK) {\ndiff --git rcl/test/rcl/test_graph.cpp rcl/test/rcl/test_graph.cpp\nindex dd21856..3410325 100644\n--- rcl/test/rcl/test_graph.cpp\n\u002B\u002B\u002B rcl/test/rcl/test_graph.cpp\n@@ -797,17 \u002B797,17 @@ TEST_F(\n }\n \n void\n-check_graph_state(\n\u002Bcheck_entity_count(\n   const rcl_node_t * node_ptr,\n   std::string \u0026 topic_name,\n   size_t expected_publisher_count,\n   size_t expected_subscriber_count,\n   bool expected_in_tnat,\n-  const std::chrono::nanoseconds \u0026 timeout)\n\u002B  std::chrono::seconds timeout)\n {\n   RCUTILS_LOG_DEBUG_NAMED(\n     ROS_PACKAGE_NAME,\n-    \u0022Expecting %zu publishers, %zu subscribers, and that the topic is%s in the graph.\u0022,\n\u002B    \u0022Expecting number of %zu publishers, %zu subscribers, and that the topic is%s in the graph.\u0022,\n     expected_publisher_count,\n     expected_subscriber_count,\n     expected_in_tnat ? \u0022\u0022 : \u0022 not\u0022\n@@ -816,25 \u002B816,30 @@ check_graph_state(\n   rcl_names_and_types_t tnat {};\n   rcl_ret_t ret;\n   rcl_allocator_t allocator = rcl_get_default_allocator();\n-\n-  // Wait for expected number of publishers\n-  bool success = false;\n-  ret = rcl_wait_for_publishers(\n-    node_ptr, \u0026allocator, topic_name.c_str(), expected_publisher_count, timeout.count(), \u0026success);\n-  ASSERT_EQ(ret, RCL_RET_OK);\n-  EXPECT_TRUE(success);\n-  // Wait for expected number of subscribers\n-  success = false;\n-  ret = rcl_wait_for_subscribers(\n-    node_ptr, \u0026allocator, topic_name.c_str(), expected_subscriber_count, timeout.count(), \u0026success);\n-  ASSERT_EQ(ret, RCL_RET_OK);\n-  EXPECT_TRUE(success);\n\u002B  size_t pub_count, sub_count;\n\u002B\n\u002B  // Check number of entities until timeout expires.\n\u002B  auto start_time = std::chrono::system_clock::now();\n\u002B  do {\n\u002B    ret = rcl_count_publishers(node_ptr, topic_name.c_str(), \u0026pub_count);\n\u002B    ASSERT_EQ(ret, RCL_RET_OK);\n\u002B    ret = rcl_count_subscribers(node_ptr, topic_name.c_str(), \u0026sub_count);\n\u002B    ASSERT_EQ(ret, RCL_RET_OK);\n\u002B    if ((expected_publisher_count == pub_count) \u0026\u0026\n\u002B      (expected_subscriber_count == sub_count))\n\u002B    {\n\u002B      break;\n\u002B    }\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B  } while (std::chrono::system_clock::now() - start_time \u003C timeout);\n\u002B  EXPECT_EQ(expected_publisher_count, pub_count);\n\u002B  EXPECT_EQ(expected_subscriber_count, sub_count);\n \n   tnat = rcl_get_zero_initialized_names_and_types();\n   ret = rcl_get_topic_names_and_types(node_ptr, \u0026allocator, false, \u0026tnat);\n   ASSERT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   is_in_tnat = false;\n-  for (size_t i = 0; RCL_RET_OK == ret \u0026\u0026 i \u003C tnat.names.size; \u002B\u002Bi) {\n\u002B  for (size_t i = 0; i \u003C tnat.names.size; \u002B\u002Bi) {\n     if (topic_name == std::string(tnat.names.data[i])) {\n       ASSERT_FALSE(is_in_tnat) \u003C\u003C \u0022duplicates in the tnat\u0022;  // Found it more than once!\n       is_in_tnat = true;\n@@ -1195,7 \u002B1200,7 @@ TEST_F(CLASSNAME(TestGraphFixture, RMW_IMPLEMENTATION), test_graph_query_functio\n   RCUTILS_LOG_DEBUG_NAMED(ROS_PACKAGE_NAME, \u0022Using topic name: %s\u0022, topic_name.c_str());\n   rcl_ret_t ret;\n   // First assert the \u0022topic_name\u0022 is not in use.\n-  check_graph_state(\n\u002B  check_entity_count(\n     this-\u003Enode_ptr,\n     topic_name,\n     0,    // expected publishers on topic\n@@ -1210,7 \u002B1215,7 @@ TEST_F(CLASSNAME(TestGraphFixture, RMW_IMPLEMENTATION), test_graph_query_functio\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n   // Check the graph.\n-  check_graph_state(\n\u002B  check_entity_count(\n     this-\u003Enode_ptr,\n     topic_name,\n     1,  // expected publishers on topic\n@@ -1224,7 \u002B1229,7 @@ TEST_F(CLASSNAME(TestGraphFixture, RMW_IMPLEMENTATION), test_graph_query_functio\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n   // Check the graph again.\n-  check_graph_state(\n\u002B  check_entity_count(\n     this-\u003Enode_ptr,\n     topic_name,\n     1,  // expected publishers on topic\n@@ -1236,7 \u002B1241,7 @@ TEST_F(CLASSNAME(TestGraphFixture, RMW_IMPLEMENTATION), test_graph_query_functio\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n   // Check the graph again.\n-  check_graph_state(\n\u002B  check_entity_count(\n     this-\u003Enode_ptr,\n     topic_name,\n     0,  // expected publishers on topic\n@@ -1248,7 \u002B1253,7 @@ TEST_F(CLASSNAME(TestGraphFixture, RMW_IMPLEMENTATION), test_graph_query_functio\n   EXPECT_EQ(RCL_RET_OK, ret) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n   // Check the graph again.\n-  check_graph_state(\n\u002B  check_entity_count(\n     this-\u003Enode_ptr,\n     topic_name,\n     0,  // expected publishers on topic\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "3c8d76c1a2e835c62262acea04d2287ef02e1bb8",
    "RawMessage": "Update maintainers (#607)",
    "Changes": "diff --git rviz2/package.xml rviz2/package.xml\nindex 06809c9a..b4d852c5 100644\n--- rviz2/package.xml\n\u002B\u002B\u002B rviz2/package.xml\n@@ -4,14 \u002B4,16 @@\n   \u003Cdescription\u003E\n     3D visualization tool for ROS.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022scott@openrobotics.org\u0022\u003EScott K Logan\u003C/maintainer\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E\n \n   \u003Cauthor\u003EDave Hershberger\u003C/author\u003E\n   \u003Cauthor\u003EDavid Gossow\u003C/author\u003E\n   \u003Cauthor\u003ED. Hood\u003C/author\u003E\n   \u003Cauthor\u003EJosh Faust\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022scott@openrobotics.org\u0022\u003EScott K Logan\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttps://github.com/ros2/rviz/blob/ros2/README.md\u003C/url\u003E\n   \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros2/rviz\u003C/url\u003E\ndiff --git rviz_assimp_vendor/package.xml rviz_assimp_vendor/package.xml\nindex 71bc7ee2..992d49a8 100644\n--- rviz_assimp_vendor/package.xml\n\u002B\u002B\u002B rviz_assimp_vendor/package.xml\n@@ -9,12 \u002B9,15 @@\n     Wrapper around assimp, providing nothing but a dependency on assimp, on some systems.\n     On others, it provides a fixed CMake module or even an ExternalProject build of assimp.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E  \u003C!-- the contents of this package are Apache 2.0 --\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E  \u003C!-- assimp is BSD (http://assimp.sourceforge.net/main_license.html) --\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttp://assimp.sourceforge.net/index.html\u003C/url\u003E\n \n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n\u002B\n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Eassimp\u003C/depend\u003E\ndiff --git rviz_common/package.xml rviz_common/package.xml\nindex cff84ba6..8d44a354 100644\n--- rviz_common/package.xml\n\u002B\u002B\u002B rviz_common/package.xml\n@@ -4,12 \u002B4,14 @@\n   \u003Cdescription\u003E\n     Common rviz API, used by rviz plugins and applications.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E\n \n   \u003Cauthor\u003EDave Hershberger\u003C/author\u003E\n   \u003Cauthor\u003EDavid Gossow\u003C/author\u003E\n   \u003Cauthor\u003EJosh Faust\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttps://github.com/ros2/rviz/blob/ros2/README.md\u003C/url\u003E\n   \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros2/rviz\u003C/url\u003E\ndiff --git rviz_default_plugins/package.xml rviz_default_plugins/package.xml\nindex 94d8a283..54551528 100644\n--- rviz_default_plugins/package.xml\n\u002B\u002B\u002B rviz_default_plugins/package.xml\n@@ -4,12 \u002B4,14 @@\n   \u003Cdescription\u003E\n     Several default plugins for rviz to cover the basic functionality.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E\n \n   \u003Cauthor\u003EDave Hershberger\u003C/author\u003E\n   \u003Cauthor\u003EDavid Gossow\u003C/author\u003E\n   \u003Cauthor\u003EJosh Faust\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttps://github.com/ros2/rviz/blob/ros2/README.md\u003C/url\u003E\n   \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros2/rviz\u003C/url\u003E\ndiff --git rviz_ogre_vendor/package.xml rviz_ogre_vendor/package.xml\nindex 77bdbbc0..9774ae5a 100644\n--- rviz_ogre_vendor/package.xml\n\u002B\u002B\u002B rviz_ogre_vendor/package.xml\n@@ -8,12 \u002B8,15 @@\n   \u003Cdescription\u003E\n     Wrapper around ogre3d, it provides a fixed CMake module and an ExternalProject build of ogre.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E  \u003C!-- the contents of this package are Apache 2.0 --\u003E\n   \u003Clicense\u003EMIT\u003C/license\u003E  \u003C!-- ogre is MIT (https://www.ogre3d.org/licensing) --\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttps://www.ogre3d.org/\u003C/url\u003E\n \n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n\u002B\n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n   \u003Cbuild_depend\u003Egit\u003C/build_depend\u003E\ndiff --git rviz_rendering/package.xml rviz_rendering/package.xml\nindex 4eef4a61..8cfda38b 100644\n--- rviz_rendering/package.xml\n\u002B\u002B\u002B rviz_rendering/package.xml\n@@ -4,12 \u002B4,14 @@\n   \u003Cdescription\u003E\n     Library which provides the 3D rendering functionality in rviz.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E\n \n   \u003Cauthor\u003EDave Hershberger\u003C/author\u003E\n   \u003Cauthor\u003EDavid Gossow\u003C/author\u003E\n   \u003Cauthor\u003EJosh Faust\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttps://github.com/ros2/rviz/blob/ros2/README.md\u003C/url\u003E\n   \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros2/rviz\u003C/url\u003E\ndiff --git rviz_rendering_tests/package.xml rviz_rendering_tests/package.xml\nindex c45e2e36..ff192386 100644\n--- rviz_rendering_tests/package.xml\n\u002B\u002B\u002B rviz_rendering_tests/package.xml\n@@ -4,12 \u002B4,15 @@\n     \u003Cdescription\u003E\n         Example plugin for RViz - documents and tests RViz plugin development\n     \u003C/description\u003E\n-    \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B    \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B    \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n     \u003Clicense\u003EBSD\u003C/license\u003E\n \n     \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros2/rviz\u003C/url\u003E\n     \u003Curl type=\u0022bugtracker\u0022\u003Ehttps://github.com/ros2/rviz/issues\u003C/url\u003E\n \n\u002B    \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n\u002B\n     \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n     \u003Cbuild_depend\u003Eqtbase5-dev\u003C/build_depend\u003E\ndiff --git rviz_visual_testing_framework/package.xml rviz_visual_testing_framework/package.xml\nindex 73a8ea03..ea13d7fe 100644\n--- rviz_visual_testing_framework/package.xml\n\u002B\u002B\u002B rviz_visual_testing_framework/package.xml\n@@ -4,10 \u002B4,12 @@\n   \u003Cdescription\u003E\n     3D testing framework for RViz.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022michael.jeronimo@openrobotics.org\u0022\u003EMichael Jeronimo\u003C/maintainer\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E\n \n   \u003Cauthor\u003EAlessandro Bottero\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022william@openrobotics.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n \n   \u003Curl type=\u0022website\u0022\u003Ehttp://ros.org/wiki/rviz2\u003C/url\u003E\n   \u003Curl type=\u0022repository\u0022\u003Ehttps://github.com/ros-visualization/rviz\u003C/url\u003E\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "301957515a0448de22def36559087b3338c76700",
    "RawMessage": "add node_waitables_ to copy constructor. (#1799)",
    "Changes": "diff --git rclcpp/src/rclcpp/node.cpp rclcpp/src/rclcpp/node.cpp\nindex 5d1f9a30..140fa5f9 100644\n--- rclcpp/src/rclcpp/node.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node.cpp\n@@ -237,6 \u002B237,8 @@ Node::Node(\n   node_services_(other.node_services_),\n   node_clock_(other.node_clock_),\n   node_parameters_(other.node_parameters_),\n\u002B  node_time_source_(other.node_time_source_),\n\u002B  node_waitables_(other.node_waitables_),\n   node_options_(other.node_options_),\n   sub_namespace_(extend_sub_namespace(other.get_sub_namespace(), sub_namespace)),\n   effective_namespace_(create_effective_namespace(other.get_namespace(), sub_namespace_))\ndiff --git rclcpp_action/test/test_server.cpp rclcpp_action/test/test_server.cpp\nindex 7030243c..4d33c4db 100644\n--- rclcpp_action/test/test_server.cpp\n\u002B\u002B\u002B rclcpp_action/test/test_server.cpp\n@@ -205,6 \u002B205,27 @@ TEST_F(TestServer, construction_and_destruction_wait_set_error)\n   }, rclcpp::exceptions::RCLError);\n }\n \n\u002BTEST_F(TestServer, construction_and_destruction_sub_node)\n\u002B{\n\u002B  auto parent_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022construct_node\u0022, \u0022/rclcpp_action/construct\u0022);\n\u002B  auto sub_node = parent_node-\u003Ecreate_sub_node(\u0022construct_sub_node\u0022);\n\u002B\n\u002B  ASSERT_NO_THROW(\n\u002B  {\n\u002B    using GoalHandle = rclcpp_action::ServerGoalHandle\u003CFibonacci\u003E;\n\u002B    auto as = rclcpp_action::create_server\u003CFibonacci\u003E(\n\u002B      sub_node, \u0022fibonacci\u0022,\n\u002B      [](const GoalUUID \u0026, std::shared_ptr\u003Cconst Fibonacci::Goal\u003E) {\n\u002B        return rclcpp_action::GoalResponse::REJECT;\n\u002B      },\n\u002B      [](std::shared_ptr\u003CGoalHandle\u003E) {\n\u002B        return rclcpp_action::CancelResponse::REJECT;\n\u002B      },\n\u002B      [](std::shared_ptr\u003CGoalHandle\u003E) {});\n\u002B    (void)as;\n\u002B  });\n\u002B}\n\u002B\n TEST_F(TestServer, handle_goal_called)\n {\n   auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022handle_goal_node\u0022, \u0022/rclcpp_action/handle_goal\u0022);\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rmw_connextdds",
    "SHA": "f46c39d7db6797a80a24631f2890ebd143bfe54e",
    "RawMessage": "Use Rolling in README\u0027s Quick Start",
    "Changes": "diff --git README.md README.md\nindex 78b25af..34638fc 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -24,10 \u002B24,11 @@ For any questions or feedback, feel free to reach out to robotics@rti.com.\n \n ## Quick Start\n \n-1. Load ROS into the shell environment, e.g. if you are using Foxy:\n\u002B1. Load ROS into the shell environment (Rolling if using the \u0060master\u0060 branch,\n\u002B   see [Support for different ROS 2 Releases](#support-for-different-ros-2-releases))\n \n     \u0060\u0060\u0060sh\n-    source /opt/ros/foxy/setup.bash\n\u002B    source /opt/ros/rolling/setup.bash\n     \u0060\u0060\u0060\n \n 2. Configure RTI Connext DDS Professional and/or RTI Connext DDS Micro on your\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "651588667285d251389d5241d3f542b5dfd9e859",
    "RawMessage": "Add functions for allocating and freeing memory for sample from Cyclone",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 7bbf976..58c3f90 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -124,6 \u002B124,12 @@ using namespace std::literals::chrono_literals;\n #define RET_ALLOC(var) RET_ALLOC_X(var, return RMW_RET_ERROR)\n #define RET_WRONG_IMPLID(var) RET_WRONG_IMPLID_X(var, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n #define RET_NULL_OR_EMPTYSTR(var) RET_NULL_OR_EMPTYSTR_X(var, return RMW_RET_ERROR)\n\u002B#define RET_EXPECTED(func, expected_ret, error_msg, code) do { \\\n\u002B    if ((expected_ret) != (func)) \\\n\u002B    { \\\n\u002B      RET_ERR_X(error_msg, code); \\\n\u002B    } \\\n\u002B} while (0)\n \n using rmw_dds_common::msg::ParticipantEntitiesInfo;\n \n@@ -1157,6 \u002B1163,62 @@ rmw_context_impl_t::fini()\n   return RMW_RET_OK;\n }\n \n\u002Btemplate\u003Ctypename entityT\u003E\n\u002Bstatic void * init_and_alloc_sample(\n\u002B  entityT \u0026 entity, const uint32_t sample_size, const bool alloc_on_heap = false)\n\u002B{\n\u002B  // initialise the data allocator\n\u002B  if (alloc_on_heap) {\n\u002B    RET_EXPECTED(\n\u002B      dds_data_allocator_init_heap(\u0026entity-\u003Edata_allocator),\n\u002B      DDS_RETCODE_OK,\n\u002B      \u0022Reader data allocator initialization failed for heap\u0022,\n\u002B      return nullptr);\n\u002B  } else {\n\u002B    RET_EXPECTED(\n\u002B      dds_data_allocator_init(entity-\u003Eenth, \u0026entity-\u003Edata_allocator),\n\u002B      DDS_RETCODE_OK,\n\u002B      \u0022Writer allocator initialisation failed\u0022,\n\u002B      return nullptr);\n\u002B  }\n\u002B  // allocate memory for message \u002B header\n\u002B  auto chunk_ptr = dds_data_allocator_alloc(\n\u002B    \u0026entity-\u003Edata_allocator,\n\u002B    DETERMINE_ICEORYX_CHUNK_SIZE(sample_size));\n\u002B  RMW_CHECK_FOR_NULL_WITH_MSG(\n\u002B    chunk_ptr,\n\u002B    \u0022Failed to get loan\u0022,\n\u002B    return nullptr);\n\u002B  auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n\u002B  ice_hdr-\u003Edata_size = sample_size;\n\u002B  auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n\u002B  // initialize the memory for message\n\u002B  rmw_cyclonedds_cpp::init_message(\u0026entity-\u003Etype_supports, ptr);\n\u002B  return ptr;\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename entityT\u003E\n\u002Bstatic rmw_ret_t fini_and_free_sample(entityT \u0026 entity, void * loaned_message)\n\u002B{\n\u002B  // fini the message\n\u002B  rmw_cyclonedds_cpp::fini_message(\u0026entity-\u003Etype_supports, loaned_message);\n\u002B  // free the message memory\n\u002B  RET_EXPECTED(\n\u002B    dds_data_allocator_free(\n\u002B      \u0026entity-\u003Edata_allocator,\n\u002B      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message)),\n\u002B    DDS_RETCODE_OK,\n\u002B    \u0022Failed to free the loaned message\u0022,\n\u002B    return RMW_RET_ERROR);\n\u002B  // fini the allocator\n\u002B  RET_EXPECTED(\n\u002B    dds_data_allocator_fini(\u0026entity-\u003Edata_allocator),\n\u002B    DDS_RETCODE_OK,\n\u002B    \u0022Failed to fini data allocator\u0022,\n\u002B    return RMW_RET_ERROR);\n\u002B  return RMW_RET_OK;\n\u002B}\n\u002B\n extern \u0022C\u0022 rmw_ret_t rmw_init(const rmw_init_options_t * options, rmw_context_t * context)\n {\n   rmw_ret_t ret;\n@@ -1590,24 \u002B1652,13 @@ extern \u0022C\u0022 rmw_ret_t rmw_publish_serialized_message(\n #ifdef DDS_HAS_SHM\n   // publishing a serialized message when SHM is ON\n   if (pub-\u003Eis_loaning_available) {\n-    dds_data_allocator_init(pub-\u003Eenth, \u0026pub-\u003Edata_allocator);\n-    auto sample_size = d-\u003Etype-\u003Eiox_size;\n-    auto chunk_ptr = dds_data_allocator_alloc(\n-      \u0026pub-\u003Edata_allocator,\n-      DETERMINE_ICEORYX_CHUNK_SIZE(sample_size));\n-    RMW_CHECK_FOR_NULL_WITH_MSG(\n-      chunk_ptr,\n-      \u0022Failed to get loan\u0022,\n-      return RMW_RET_ERROR);\n-    auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n-    ice_hdr-\u003Edata_size = sample_size;\n-    auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-    rmw_cyclonedds_cpp::init_message(\u0026pub-\u003Etype_supports, ptr);\n-    if (rmw_deserialize(serialized_message, \u0026pub-\u003Etype_supports, ptr) != RMW_RET_OK) {\n\u002B    auto sample_ptr = init_and_alloc_sample(pub, d-\u003Etype-\u003Eiox_size);\n\u002B    RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n\u002B    if (rmw_deserialize(serialized_message, \u0026pub-\u003Etype_supports, sample_ptr) != RMW_RET_OK) {\n       RMW_SET_ERROR_MSG(\u0022Failed to deserialize sample into laoned memory\u0022);\n       return RMW_RET_ERROR;\n     }\n-    d-\u003Eiox_chunk = ice_hdr;\n\u002B    d-\u003Eiox_chunk = SHIFT_BACK_TO_ICEORYX_HEADER(sample_ptr);\n   }\n #endif\n   const bool ok = (dds_writecdr(pub-\u003Eenth, d) \u003E= 0);\n@@ -2339,23 \u002B2390,9 @@ static rmw_ret_t borrow_loaned_message_int(\n \n   // if the publisher can loan\n   if (cdds_publisher-\u003Eis_loaning_available) {\n-    // initialize the data allocator\n-    dds_data_allocator_init(cdds_publisher-\u003Eenth, \u0026cdds_publisher-\u003Edata_allocator);\n-    // allocate memory for message \u002B header\n-    auto sample_size = cdds_publisher-\u003Esample_size;\n-    auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(sample_size);\n-    auto chunk_ptr = dds_data_allocator_alloc(\n-      \u0026cdds_publisher-\u003Edata_allocator, chunk_size);\n-    RMW_CHECK_FOR_NULL_WITH_MSG(\n-      chunk_ptr,\n-      \u0022Failed to get loan\u0022,\n-      return RMW_RET_ERROR);\n-    // initialize the memory for message\n-    auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n-    ice_hdr-\u003Edata_size = sample_size;\n-    auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-    rmw_cyclonedds_cpp::init_message(type_support, ptr);\n-    *ros_message = ptr;\n\u002B    auto sample_ptr = init_and_alloc_sample(cdds_publisher, cdds_publisher-\u003Esample_size);\n\u002B    RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n\u002B    *ros_message = sample_ptr;\n     return RMW_RET_OK;\n   } else {\n     RMW_SET_ERROR_MSG(\u0022Borrowing loan for a non fixed type is not allowed\u0022);\n@@ -2405,15 \u002B2442,7 @@ static rmw_ret_t return_loaned_message_from_publisher_int(\n \n   // if the publisher can loan\n   if (cdds_publisher-\u003Eis_loaning_available) {\n-    // fini message\n-    rmw_cyclonedds_cpp::fini_message(\u0026cdds_publisher-\u003Etype_supports, loaned_message);\n-    // free the message memory\n-    dds_data_allocator_free(\n-      \u0026cdds_publisher-\u003Edata_allocator,\n-      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n-    // fini data collector\n-    dds_data_allocator_fini(\u0026cdds_publisher-\u003Edata_allocator);\n-    return RMW_RET_OK;\n\u002B    return fini_and_free_sample(cdds_publisher, loaned_message);\n   } else {\n     RMW_SET_ERROR_MSG(\u0022returning loan for a non fixed type is not allowed\u0022);\n     return RMW_RET_ERROR;\n@@ -3106,21 \u002B3135,10 @@ static rmw_ret_t rmw_take_loan_int(\n           cdds_subscription-\u003Eenth, \u0026cdds_subscription-\u003Edata_allocator);\n         return RMW_RET_OK;\n       } else if (d-\u003Etype-\u003Eiox_size \u003E 0U) {\n-        // allocate on the heap\n-        dds_data_allocator_init_heap(\u0026cdds_subscription-\u003Edata_allocator);\n-        auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(d-\u003Etype-\u003Eiox_size);\n-        auto chunk_ptr = dds_data_allocator_alloc(\n-          \u0026cdds_subscription-\u003Edata_allocator, chunk_size);\n-        RMW_CHECK_FOR_NULL_WITH_MSG(\n-          chunk_ptr,\n-          \u0022Failed to allocate memory for the received sample\u0022,\n-          return RMW_RET_ERROR);\n-        auto ice_hdr = static_cast\u003Ciceoryx_header_t *\u003E(chunk_ptr);\n-        ice_hdr-\u003Edata_size = d-\u003Etype-\u003Eiox_size;\n-        auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-        rmw_cyclonedds_cpp::init_message(\u0026cdds_subscription-\u003Etype_supports, ptr);\n-        ddsi_serdata_to_sample(d, ptr, nullptr, nullptr);\n-        *loaned_message = ptr;\n\u002B        auto sample_ptr = init_and_alloc_sample(cdds_subscription, d-\u003Etype-\u003Eiox_size, true);\n\u002B        RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n\u002B        ddsi_serdata_to_sample(d, sample_ptr, nullptr, nullptr);\n\u002B        *loaned_message = sample_ptr;\n         *taken = true;\n         return RMW_RET_OK;\n       } else {\n@@ -3252,13 \u002B3270,10 @@ static rmw_ret_t return_loaned_message_from_subscription_int(\n \n   // if the subscription allow loaning\n   if (cdds_subscription-\u003Eis_loaning_available) {\n-    rmw_cyclonedds_cpp::fini_message(\u0026cdds_subscription-\u003Etype_supports, loaned_message);\n-    dds_data_allocator_free(\n-      \u0026cdds_subscription-\u003Edata_allocator,\n-      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n-    dds_data_allocator_fini(\u0026cdds_subscription-\u003Edata_allocator);\n\u002B    return fini_and_free_sample(cdds_subscription, loaned_message);\n   } else {\n     RMW_SET_ERROR_MSG(\u0022returning loan for a non fixed type is not allowed\u0022);\n\u002B    return RMW_RET_ERROR;\n   }\n   return RMW_RET_OK;\n }\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "3cddb4edab317758dc8a8cac94b90794641c7488",
    "RawMessage": "Fix returning invalid namespace if sub_namespace is empty (#1658)",
    "Changes": "diff --git rclcpp/src/rclcpp/node.cpp rclcpp/src/rclcpp/node.cpp\nindex c9ed1e3a..46f1af12 100644\n--- rclcpp/src/rclcpp/node.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node.cpp\n@@ -61,6 \u002B61,12 @@ extend_sub_namespace(const std::string \u0026 existing_sub_namespace, const std::stri\n             extension.c_str(),\n             \u0022a sub-namespace should not have a leading /\u0022,\n             0);\n\u002B  } else if (existing_sub_namespace.empty() \u0026\u0026 extension.empty()) {\n\u002B    throw rclcpp::exceptions::NameValidationError(\n\u002B            \u0022sub_namespace\u0022,\n\u002B            extension.c_str(),\n\u002B            \u0022sub-nodes should not extend nodes by an empty sub-namespace\u0022,\n\u002B            0);\n   }\n \n   std::string new_sub_namespace;\n@@ -86,7 \u002B92,11 @@ create_effective_namespace(const std::string \u0026 node_namespace, const std::string\n   // and do not need trimming of \u0060/\u0060 and other things, as they were validated\n   // in other functions already.\n \n-  if (node_namespace.back() == \u0027/\u0027) {\n\u002B  // A node may not have a sub_namespace if it is no sub_node. In this case,\n\u002B  // just return the original namespace\n\u002B  if (sub_namespace.empty()) {\n\u002B    return node_namespace;\n\u002B  } else if (node_namespace.back() == \u0027/\u0027) {\n     // this is the special case where node_namespace is just \u0060/\u0060\n     return node_namespace \u002B sub_namespace;\n   } else {\ndiff --git rclcpp/test/rclcpp/test_node.cpp rclcpp/test/rclcpp/test_node.cpp\nindex 70b207b0..e034af16 100644\n--- rclcpp/test/rclcpp/test_node.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_node.cpp\n@@ -102,6 \u002B102,7 @@ TEST_F(TestNode, get_name_and_namespace) {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/ns\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/ns\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/ns/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n@@ -116,30 \u002B117,35 @@ TEST_F(TestNode, get_name_and_namespace) {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022ns\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/ns\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/ns\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/ns/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/my/ns\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/my/ns\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/my/ns\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/my/ns/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n     auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022my/ns\u0022);\n     EXPECT_STREQ(\u0022my_node\u0022, node-\u003Eget_name());\n     EXPECT_STREQ(\u0022/my/ns\u0022, node-\u003Eget_namespace());\n\u002B    EXPECT_STREQ(\u0022/my/ns\u0022, node-\u003Eget_effective_namespace().c_str());\n     EXPECT_STREQ(\u0022/my/ns/my_node\u0022, node-\u003Eget_fully_qualified_name());\n   }\n   {\n@@ -278,6 \u002B284,13 @@ TEST_F(TestNode, subnode_construction_and_destruction) {\n       auto subnode = node-\u003Ecreate_sub_node(\u0022~sub_ns\u0022);\n     }, rclcpp::exceptions::InvalidNamespaceError);\n   }\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto node = std::make_shared\u003Crclcpp::Node\u003E(\u0022my_node\u0022, \u0022/ns\u0022);\n\u002B      auto subnode = node-\u003Ecreate_sub_node(\u0022\u0022);\n\u002B    }, rclcpp::exceptions::NameValidationError);\n\u002B  }\n }\n \n TEST_F(TestNode, get_logger) {\n",
    "BackportedTo": "galactic",
    "IsBackported": true
  },
  {
    "Repository": "rclcpp",
    "SHA": "cd0440f1a5ebab5698aeb2065b4aa279bdd9b69e",
    "RawMessage": "Remove an unused variable from the events executor tests. (#2270)",
    "Changes": "diff --git rclcpp/test/rclcpp/executors/test_events_executor.cpp rclcpp/test/rclcpp/executors/test_events_executor.cpp\nindex 0d678438..fb5c9a51 100644\n--- rclcpp/test/rclcpp/executors/test_events_executor.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/executors/test_events_executor.cpp\n@@ -75,8 \u002B75,6 @@ TEST_F(TestEventsExecutor, run_pub_sub)\n     !spin_exited \u0026\u0026\n     (std::chrono::high_resolution_clock::now() - start \u003C 1s))\n   {\n-    auto time = std::chrono::high_resolution_clock::now() - start;\n-    auto time_msec = std::chrono::duration_cast\u003Cstd::chrono::milliseconds\u003E(time);\n     std::this_thread::sleep_for(25ms);\n   }\n \n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "bc8c71b63f60f5df4796a42b3d9c246c9e6f2b09",
    "RawMessage": "Clock subscription callback group spins in its own thread (#1556)",
    "Changes": "diff --git rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\nindex b30e393d..1c9afebe 100644\n--- rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_interfaces/node_time_source.hpp\n@@ -48,7 \u002B48,8 @@ public:\n     rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging,\n     rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock,\n     rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters,\n-    const rclcpp::QoS \u0026 qos = rclcpp::RosoutQoS()\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::RosoutQoS(),\n\u002B    bool use_clock_thread = true\n   );\n \n   RCLCPP_PUBLIC\ndiff --git rclcpp/include/rclcpp/node_options.hpp rclcpp/include/rclcpp/node_options.hpp\nindex 7d6944c7..73a2c701 100644\n--- rclcpp/include/rclcpp/node_options.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node_options.hpp\n@@ -47,6 \u002B47,7 @@ public:\n    *   - start_parameter_services = true\n    *   - start_parameter_event_publisher = true\n    *   - clock_qos = rclcpp::ClockQoS()\n\u002B   *   - use_clock_thread = true\n    *   - rosout_qos = rclcpp::RosoutQoS()\n    *   - parameter_event_qos = rclcpp::ParameterEventQoS\n    *     - with history setting and depth from rmw_qos_profile_parameter_events\n@@ -258,6 \u002B259,20 @@ public:\n   NodeOptions \u0026\n   clock_qos(const rclcpp::QoS \u0026 clock_qos);\n \n\u002B\n\u002B  /// Return the use_clock_thread flag.\n\u002B  RCLCPP_PUBLIC\n\u002B  bool\n\u002B  use_clock_thread() const;\n\u002B\n\u002B  /// Set the use_clock_thread flag, return this for parameter idiom.\n\u002B  /**\n\u002B   * If true, a dedicated thread will be used to subscribe to \u0022/clock\u0022 topic.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  NodeOptions \u0026\n\u002B  use_clock_thread(bool use_clock_thread);\n\u002B\n   /// Return a reference to the parameter_event_qos QoS.\n   RCLCPP_PUBLIC\n   const rclcpp::QoS \u0026\n@@ -384,6 \u002B399,8 @@ private:\n \n   rclcpp::QoS clock_qos_ = rclcpp::ClockQoS();\n \n\u002B  bool use_clock_thread_ {true};\n\u002B\n   rclcpp::QoS parameter_event_qos_ = rclcpp::ParameterEventsQoS(\n     rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_parameter_events)\n   );\ndiff --git rclcpp/include/rclcpp/time_source.hpp rclcpp/include/rclcpp/time_source.hpp\nindex 3f569b49..bad683b4 100644\n--- rclcpp/include/rclcpp/time_source.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/time_source.hpp\n@@ -25,6 \u002B25,7 @@\n #include \u0022rcl_interfaces/msg/parameter_event.hpp\u0022\n \n #include \u0022rclcpp/node.hpp\u0022\n\u002B#include \u0022rclcpp/executors.hpp\u0022\n #include \u0022rclcpp/node_interfaces/node_parameters_interface.hpp\u0022\n \n \n@@ -57,7 \u002B58,10 @@ public:\n    * \\param qos QoS that will be used when creating a \u0060/clock\u0060 subscription.\n    */\n   RCLCPP_PUBLIC\n-  explicit TimeSource(rclcpp::Node::SharedPtr node, const rclcpp::QoS \u0026 qos = rclcpp::ClockQoS());\n\u002B  explicit TimeSource(\n\u002B    rclcpp::Node::SharedPtr node,\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ClockQoS(),\n\u002B    bool use_clock_thread = true);\n \n   /// Empty constructor\n   /**\n@@ -66,7 \u002B70,9 @@ public:\n    * \\param qos QoS that will be used when creating a \u0060/clock\u0060 subscription.\n    */\n   RCLCPP_PUBLIC\n-  explicit TimeSource(const rclcpp::QoS \u0026 qos = rclcpp::ClockQoS());\n\u002B  explicit TimeSource(\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ClockQoS(),\n\u002B    bool use_clock_thread = true);\n \n   /// Attack node to the time source.\n   /**\n@@ -118,6 \u002B124,11 @@ public:\n   RCLCPP_PUBLIC\n   ~TimeSource();\n \n\u002Bprotected:\n\u002B  // Dedicated thread for clock subscription.\n\u002B  bool use_clock_thread_;\n\u002B  std::thread clock_executor_thread_;\n\u002B\n private:\n   // Preserve the node reference\n   rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;\n@@ -140,6 \u002B151,9 @@ private:\n   using SubscriptionT = rclcpp::Subscription\u003CMessageT, Alloc\u003E;\n   std::shared_ptr\u003CSubscriptionT\u003E clock_subscription_{nullptr};\n   std::mutex clock_sub_lock_;\n\u002B  rclcpp::CallbackGroup::SharedPtr clock_callback_group_;\n\u002B  rclcpp::executors::SingleThreadedExecutor clock_executor_;\n\u002B  std::promise\u003Cvoid\u003E cancel_clock_executor_promise_;\n \n   // The clock callback itself\n   void clock_cb(const rosgraph_msgs::msg::Clock::SharedPtr msg);\ndiff --git rclcpp/src/rclcpp/node.cpp rclcpp/src/rclcpp/node.cpp\nindex 0d45f641..11770276 100644\n--- rclcpp/src/rclcpp/node.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node.cpp\n@@ -187,7 \u002B187,8 @@ Node::Node(\n       node_logging_,\n       node_clock_,\n       node_parameters_,\n-      options.clock_qos()\n\u002B      options.clock_qos(),\n\u002B      options.use_clock_thread()\n     )),\n   node_waitables_(new rclcpp::node_interfaces::NodeWaitables(node_base_.get())),\n   node_options_(options),\ndiff --git rclcpp/src/rclcpp/node_interfaces/node_time_source.cpp rclcpp/src/rclcpp/node_interfaces/node_time_source.cpp\nindex 415b9860..2bd3a098 100644\n--- rclcpp/src/rclcpp/node_interfaces/node_time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_interfaces/node_time_source.cpp\n@@ -27,7 \u002B27,8 @@ NodeTimeSource::NodeTimeSource(\n   rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging,\n   rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock,\n   rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters,\n-  const rclcpp::QoS \u0026 qos)\n\u002B  const rclcpp::QoS \u0026 qos,\n\u002B  bool use_clock_thread)\n : node_base_(node_base),\n   node_topics_(node_topics),\n   node_graph_(node_graph),\n@@ -35,7 \u002B36,7 @@ NodeTimeSource::NodeTimeSource(\n   node_logging_(node_logging),\n   node_clock_(node_clock),\n   node_parameters_(node_parameters),\n-  time_source_(qos)\n\u002B  time_source_(qos, use_clock_thread)\n {\n   time_source_.attachNode(\n     node_base_,\ndiff --git rclcpp/src/rclcpp/node_options.cpp rclcpp/src/rclcpp/node_options.cpp\nindex c76bafd9..06feffd1 100644\n--- rclcpp/src/rclcpp/node_options.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node_options.cpp\n@@ -78,6 \u002B78,7 @@ NodeOptions::operator=(const NodeOptions \u0026 other)\n     this-\u003Estart_parameter_services_ = other.start_parameter_services_;\n     this-\u003Estart_parameter_event_publisher_ = other.start_parameter_event_publisher_;\n     this-\u003Eclock_qos_ = other.clock_qos_;\n\u002B    this-\u003Euse_clock_thread_ = other.use_clock_thread_;\n     this-\u003Eparameter_event_qos_ = other.parameter_event_qos_;\n     this-\u003Erosout_qos_ = other.rosout_qos_;\n     this-\u003Eparameter_event_publisher_options_ = other.parameter_event_publisher_options_;\n@@ -272,6 \u002B273,19 @@ NodeOptions::clock_qos(const rclcpp::QoS \u0026 clock_qos)\n   return *this;\n }\n \n\u002Bbool\n\u002BNodeOptions::use_clock_thread() const\n\u002B{\n\u002B  return this-\u003Euse_clock_thread_;\n\u002B}\n\u002B\n\u002BNodeOptions \u0026\n\u002BNodeOptions::use_clock_thread(bool use_clock_thread)\n\u002B{\n\u002B  this-\u003Euse_clock_thread_ = use_clock_thread;\n\u002B  return *this;\n\u002B}\n\u002B\n const rclcpp::QoS \u0026\n NodeOptions::parameter_event_qos() const\n {\ndiff --git rclcpp/src/rclcpp/time_source.cpp rclcpp/src/rclcpp/time_source.cpp\nindex c8d82708..9f864282 100644\n--- rclcpp/src/rclcpp/time_source.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/time_source.cpp\n@@ -33,21 \u002B33,29 @@\n namespace rclcpp\n {\n \n-TimeSource::TimeSource(std::shared_ptr\u003Crclcpp::Node\u003E node, const rclcpp::QoS \u0026 qos)\n-: logger_(rclcpp::get_logger(\u0022rclcpp\u0022)),\n\u002BTimeSource::TimeSource(\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node,\n\u002B  const rclcpp::QoS \u0026 qos,\n\u002B  bool use_clock_thread)\n\u002B: use_clock_thread_(use_clock_thread),\n\u002B  logger_(rclcpp::get_logger(\u0022rclcpp\u0022)),\n   qos_(qos)\n {\n   this-\u003EattachNode(node);\n }\n \n-TimeSource::TimeSource(const rclcpp::QoS \u0026 qos)\n-: logger_(rclcpp::get_logger(\u0022rclcpp\u0022)),\n\u002BTimeSource::TimeSource(\n\u002B  const rclcpp::QoS \u0026 qos,\n\u002B  bool use_clock_thread)\n\u002B: use_clock_thread_(use_clock_thread),\n\u002B  logger_(rclcpp::get_logger(\u0022rclcpp\u0022)),\n   qos_(qos)\n {\n }\n \n void TimeSource::attachNode(rclcpp::Node::SharedPtr node)\n {\n\u002B  use_clock_thread_ = node-\u003Eget_node_options().use_clock_thread();\n   attachNode(\n     node-\u003Eget_node_base_interface(),\n     node-\u003Eget_node_topics_interface(),\n@@ -127,7 \u002B135,7 @@ void TimeSource::attachNode(\n void TimeSource::detachNode()\n {\n   this-\u003Eros_time_active_ = false;\n-  clock_subscription_.reset();\n\u002B  destroy_clock_sub();\n   parameter_subscription_.reset();\n   node_base_.reset();\n   node_topics_.reset();\n@@ -242,6 \u002B250,24 @@ void TimeSource::create_clock_sub()\n       rclcpp::QosPolicyKind::Reliability,\n     });\n \n\u002B  if (use_clock_thread_) {\n\u002B    clock_callback_group_ = node_base_-\u003Ecreate_callback_group(\n\u002B      rclcpp::CallbackGroupType::MutuallyExclusive,\n\u002B      false\n\u002B    );\n\u002B    options.callback_group = clock_callback_group_;\n\u002B    if (!clock_executor_thread_.joinable()) {\n\u002B      clock_executor_thread_ = std::thread(\n\u002B        [this]() {\n\u002B          cancel_clock_executor_promise_ = std::promise\u003Cvoid\u003E{};\n\u002B          auto future = cancel_clock_executor_promise_.get_future();\n\u002B          clock_executor_.add_callback_group(clock_callback_group_, node_base_);\n\u002B          clock_executor_.spin_until_future_complete(future);\n\u002B        }\n\u002B      );\n\u002B    }\n\u002B  }\n\u002B\n   clock_subscription_ = rclcpp::create_subscription\u003Crosgraph_msgs::msg::Clock\u003E(\n     node_parameters_,\n     node_topics_,\n@@ -255,6 \u002B281,12 @@ void TimeSource::create_clock_sub()\n void TimeSource::destroy_clock_sub()\n {\n   std::lock_guard\u003Cstd::mutex\u003E guard(clock_sub_lock_);\n\u002B  if (clock_executor_thread_.joinable()) {\n\u002B    cancel_clock_executor_promise_.set_value();\n\u002B    clock_executor_.cancel();\n\u002B    clock_executor_thread_.join();\n\u002B    clock_executor_.remove_callback_group(clock_callback_group_);\n\u002B  }\n   clock_subscription_.reset();\n }\n \ndiff --git rclcpp/test/rclcpp/test_time_source.cpp rclcpp/test/rclcpp/test_time_source.cpp\nindex 8901f6b2..3b64e9e8 100644\n--- rclcpp/test/rclcpp/test_time_source.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_time_source.cpp\n@@ -516,3 \u002B516,229 @@ TEST_F(TestTimeSource, no_pre_jump_callback) {\n   EXPECT_EQ(1, cbo.last_postcallback_id_);\n   EXPECT_EQ(1, cbo.post_callback_calls_);\n }\n\u002B\n\u002B// A TimeSource-inheriting class\n\u002B// that allows access to TimeSource protected attributes\n\u002B// use_clock_thread_ and clock_executor_thread_\n\u002Bclass ClockThreadTestingTimeSource : public rclcpp::TimeSource\n\u002B{\n\u002Bpublic:\n\u002B  ClockThreadTestingTimeSource()\n\u002B  : rclcpp::TimeSource()\n\u002B  {\n\u002B  }\n\u002B\n\u002B  bool GetUseClockThreadOption()\n\u002B  {\n\u002B    return this-\u003Euse_clock_thread_;\n\u002B  }\n\u002B\n\u002B  bool IsClockThreadJoinable()\n\u002B  {\n\u002B    return this-\u003Eclock_executor_thread_.joinable();\n\u002B  }\n\u002B};\n\u002B\n\u002BTEST_F(TestTimeSource, check_use_clock_thread_value) {\n\u002B  // Create three nodes, with use_clock_thread option\n\u002B  // respectively set to default, true, and false\n\u002B\n\u002B  auto default_node_ = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022default_option_node\u0022);\n\u002B\n\u002B  auto clock_thread_node_ = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022clock_thread_node\u0022,\n\u002B    rclcpp::NodeOptions().use_clock_thread(true));\n\u002B\n\u002B  auto no_clock_thread_node_ = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022no_clock_thread_node\u0022,\n\u002B    rclcpp::NodeOptions().use_clock_thread(false));\n\u002B\n\u002B  // Test value of use_clock_thread_ TimeSource attribute\n\u002B  // when the different nodes are attached\n\u002B\n\u002B  ClockThreadTestingTimeSource ts;\n\u002B\n\u002B  ts.attachNode(default_node_);\n\u002B  ASSERT_TRUE(ts.GetUseClockThreadOption());\n\u002B  ts.detachNode();\n\u002B\n\u002B  ts.attachNode(clock_thread_node_);\n\u002B  ASSERT_TRUE(ts.GetUseClockThreadOption());\n\u002B  ts.detachNode();\n\u002B\n\u002B  ts.attachNode(no_clock_thread_node_);\n\u002B  ASSERT_FALSE(ts.GetUseClockThreadOption());\n\u002B  ts.detachNode();\n\u002B}\n\u002B\n\u002BTEST_F(TestTimeSource, check_clock_thread_status) {\n\u002B  // Test if TimeSource clock-dedicated thread is running\n\u002B  // according to the use_sim_time parameter\n\u002B  // and to the options of the attached node\n\u002B  ClockThreadTestingTimeSource ts;\n\u002B\n\u002B  // Tests for default options node\n\u002B  auto default_node_ = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022default_option_node\u0022);\n\u002B\n\u002B  default_node_-\u003Eset_parameter(rclcpp::Parameter(\u0022use_sim_time\u0022, true));\n\u002B  ts.attachNode(default_node_);\n\u002B  ASSERT_TRUE(ts.IsClockThreadJoinable());\n\u002B  ts.detachNode();\n\u002B\n\u002B  default_node_-\u003Eset_parameter(rclcpp::Parameter(\u0022use_sim_time\u0022, false));\n\u002B  ts.attachNode(default_node_);\n\u002B  ASSERT_FALSE(ts.IsClockThreadJoinable());\n\u002B  ts.detachNode();\n\u002B\n\u002B  // Tests for node with use_clock_thread option forced to false\n\u002B  auto no_clock_thread_node_ = std::make_shared\u003Crclcpp::Node\u003E(\n\u002B    \u0022no_clock_thread_node\u0022,\n\u002B    rclcpp::NodeOptions().use_clock_thread(false));\n\u002B\n\u002B  no_clock_thread_node_-\u003Eset_parameter(rclcpp::Parameter(\u0022use_sim_time\u0022, true));\n\u002B  ts.attachNode(no_clock_thread_node_);\n\u002B  ASSERT_FALSE(ts.IsClockThreadJoinable());\n\u002B  ts.detachNode();\n\u002B\n\u002B  no_clock_thread_node_-\u003Eset_parameter(rclcpp::Parameter(\u0022use_sim_time\u0022, false));\n\u002B  ts.attachNode(no_clock_thread_node_);\n\u002B  ASSERT_FALSE(ts.IsClockThreadJoinable());\n\u002B  ts.detachNode();\n\u002B}\n\u002B\n\u002B// A Node-inheriting class\n\u002B// that regularly publishes a incremented Clock msg on topic \u0060/clock\u0027\n\u002Bclass SimClockPublisherNode : public rclcpp::Node\n\u002B{\n\u002Bpublic:\n\u002B  SimClockPublisherNode()\n\u002B  : rclcpp::Node(\u0022sim_clock_publisher_node\u0022)\n\u002B  {\n\u002B    // Create a clock publisher\n\u002B    clock_pub_ = this-\u003Ecreate_publisher\u003Crosgraph_msgs::msg::Clock\u003E(\n\u002B      \u0022/clock\u0022,\n\u002B      rclcpp::QoS(1)\n\u002B    );\n\u002B\n\u002B    // Create a 1ms timer\n\u002B    pub_timer_ = this-\u003Ecreate_wall_timer(\n\u002B      std::chrono::milliseconds(1),\n\u002B      std::bind(\n\u002B        \u0026SimClockPublisherNode::timer_callback,\n\u002B        this)\n\u002B    );\n\u002B\n\u002B    // Init clock msg to zero\n\u002B    clock_msg_.clock.sec = 0;\n\u002B    clock_msg_.clock.nanosec = 0;\n\u002B  }\n\u002B\n\u002B  ~SimClockPublisherNode()\n\u002B  {\n\u002B    // Cleanly stop executor and thread\n\u002B    node_executor.cancel();\n\u002B    node_thread_.join();\n\u002B  }\n\u002B\n\u002B  void SpinNode()\n\u002B  {\n\u002B    // Spin node in its own dedicated thread\n\u002B    node_thread_ = std::thread(\n\u002B      [this]() {\n\u002B        node_executor.add_node(this-\u003Eget_node_base_interface());\n\u002B        node_executor.spin();\n\u002B      });\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  void timer_callback()\n\u002B  {\n\u002B    // Increment clock msg and publish it\n\u002B    clock_msg_.clock.nanosec \u002B= 1000000;\n\u002B    clock_pub_-\u003Epublish(clock_msg_);\n\u002B  }\n\u002B\n\u002B  rclcpp::Publisher\u003Crosgraph_msgs::msg::Clock\u003E::SharedPtr clock_pub_;\n\u002B  rclcpp::TimerBase::SharedPtr pub_timer_;\n\u002B  rosgraph_msgs::msg::Clock clock_msg_;\n\u002B  std::thread node_thread_;\n\u002B  rclcpp::executors::SingleThreadedExecutor node_executor;\n\u002B};\n\u002B\n\u002B// A Node-inheriting class\n\u002B// that check its clock time within a timer callback\n\u002Bclass ClockThreadTestingNode : public rclcpp::Node\n\u002B{\n\u002Bpublic:\n\u002B  ClockThreadTestingNode()\n\u002B  : rclcpp::Node(\u0022clock_thread_testing_node\u0022)\n\u002B  {\n\u002B    // Set use_sim_time parameter to true to subscribe to \u0060/clock\u0060 topic\n\u002B    this-\u003Eset_parameter(rclcpp::Parameter(\u0022use_sim_time\u0022, true));\n\u002B\n\u002B    // Create a 100ms timer\n\u002B    timer_ = this-\u003Ecreate_wall_timer(\n\u002B      std::chrono::milliseconds(100),\n\u002B      std::bind(\n\u002B        \u0026ClockThreadTestingNode::timer_callback,\n\u002B        this)\n\u002B    );\n\u002B  }\n\u002B\n\u002B  bool GetIsCallbackFrozen()\n\u002B  {\n\u002B    return is_callback_frozen_;\n\u002B  }\n\u002B\n\u002Bprivate:\n\u002B  void timer_callback()\n\u002B  {\n\u002B    rclcpp::Time start_time = this-\u003Enow();\n\u002B    bool is_time_out = false;\n\u002B\n\u002B    // While loop condition tests\n\u002B    // if the node\u0027s clock time is incremented\n\u002B    while (rclcpp::ok() \u0026\u0026\n\u002B      !is_time_out)\n\u002B    {\n\u002B      rclcpp::sleep_for(std::chrono::milliseconds(100));\n\u002B      rclcpp::Time time_now = this-\u003Enow();\n\u002B      rclcpp::Duration time_spent = time_now - start_time;\n\u002B      is_time_out = time_spent.seconds() \u003E 1.0;\n\u002B    }\n\u002B\n\u002B    // If out of while loop, set variable to false\n\u002B    // and cancel timer to avoid to enter the callback again\n\u002B    is_callback_frozen_ = false;\n\u002B    timer_-\u003Ecancel();\n\u002B  }\n\u002B\n\u002B  rclcpp::TimerBase::SharedPtr timer_;\n\u002B  bool is_callback_frozen_ = true;\n\u002B};\n\u002B\n\u002BTEST_F(TestTimeSource, check_sim_time_updated_in_callback_if_use_clock_thread) {\n\u002B  // Test if clock time of a node with\n\u002B  // parameter use_sim_time = true and option use_clock_thread = true\n\u002B  // is updated while node is not spinning\n\u002B  // (in a timer callback)\n\u002B\n\u002B  // Create a \u0022sim time\u0022 publisher and spin it\n\u002B  SimClockPublisherNode pub_node;\n\u002B  pub_node.SpinNode();\n\u002B\n\u002B  // Spin node for 2 seconds\n\u002B  ClockThreadTestingNode clock_thread_testing_node;\n\u002B  auto steady_clock = rclcpp::Clock(RCL_STEADY_TIME);\n\u002B  auto start_time = steady_clock.now();\n\u002B  while (rclcpp::ok() \u0026\u0026\n\u002B    (steady_clock.now() - start_time).seconds() \u003C 2.0)\n\u002B  {\n\u002B    rclcpp::spin_some(clock_thread_testing_node.get_node_base_interface());\n\u002B  }\n\u002B\n\u002B  // Node should have get out of timer callback\n\u002B  ASSERT_FALSE(clock_thread_testing_node.GetIsCallbackFrozen());\n\u002B}\ndiff --git rclcpp_lifecycle/src/lifecycle_node.cpp rclcpp_lifecycle/src/lifecycle_node.cpp\nindex ee09e669..2370e43b 100644\n--- rclcpp_lifecycle/src/lifecycle_node.cpp\n\u002B\u002B\u002B rclcpp_lifecycle/src/lifecycle_node.cpp\n@@ -102,7 \u002B102,8 @@ LifecycleNode::LifecycleNode(\n       node_logging_,\n       node_clock_,\n       node_parameters_,\n-      options.clock_qos()\n\u002B      options.clock_qos(),\n\u002B      options.use_clock_thread()\n     )),\n   node_waitables_(new rclcpp::node_interfaces::NodeWaitables(node_base_.get())),\n   node_options_(options),\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "8344640bc9973b1ee4693f35121387539d5998af",
    "RawMessage": "Release iox_chunk to iceoryx in serdata_free if the iox_chunk is still available",
    "Changes": "diff --git rmw_cyclonedds_cpp/CMakeLists.txt rmw_cyclonedds_cpp/CMakeLists.txt\nindex 88cc9c6..5e9e731 100644\n--- rmw_cyclonedds_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_cyclonedds_cpp/CMakeLists.txt\n@@ -33,7 \u002B33,16 @@ find_package(tracetools REQUIRED)\n \n #find_package(cyclonedds_cmake_module REQUIRED)\n find_package(CycloneDDS QUIET CONFIG)\n-if(NOT CycloneDDS_FOUND)\n\u002Bif(CycloneDDS_FOUND)\n\u002B  # Support for shared memory in RMW depends on support for shared memory being compiled in\n\u002B  # Cyclone DDS and iceoryx_binding_c being available\n\u002B  get_target_property(cyclonedds_has_shm CycloneDDS::ddsc SHM_SUPPORT_IS_AVAILABLE)\n\u002B  if(cyclonedds_has_shm)\n\u002B    find_package(iceoryx_binding_c REQUIRED)\n\u002B  else()\n\u002B    message(STATUS \u0022Cyclone DDS is NOT compiled with support for shared memory\u0022)\n\u002B  endif()\n\u002Belse()\n   message(WARNING \u0022Could not find Eclipse Cyclone DDS - skipping \u0027${PROJECT_NAME}\u0027\u0022)\n   ament_package()\n   return()\n@@ -69,6 \u002B78,10 @@ add_library(rmw_cyclonedds_cpp\n target_link_libraries(rmw_cyclonedds_cpp PRIVATE\n   CycloneDDS::ddsc)\n \n\u002Bif(cyclonedds_has_shm)\n\u002B  target_link_libraries(rmw_cyclonedds_cpp PRIVATE iceoryx_binding_c::iceoryx_binding_c)\n\u002Bendif()\n\u002B\n target_link_libraries(rmw_cyclonedds_cpp PUBLIC\n   rmw::rmw)\n target_link_libraries(rmw_cyclonedds_cpp PRIVATE\ndiff --git rmw_cyclonedds_cpp/src/serdata.cpp rmw_cyclonedds_cpp/src/serdata.cpp\nindex 2ff7e9e..d3530ca 100644\n--- rmw_cyclonedds_cpp/src/serdata.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdata.cpp\n@@ -164,7 \u002B164,14 @@ static uint32_t serdata_rmw_size(const struct ddsi_serdata * dcmn)\n \n static void serdata_rmw_free(struct ddsi_serdata * dcmn)\n {\n-  auto * d = static_cast\u003Cconst serdata_rmw *\u003E(dcmn);\n\u002B  auto * d = static_cast\u003Cserdata_rmw *\u003E(dcmn);\n\u002B\n\u002B#ifdef DDS_HAS_SHM\n\u002B  if (d-\u003Eiox_chunk \u0026\u0026 d-\u003Eiox_subscriber) {\n\u002B    iox_sub_release_chunk(*static_cast\u003Ciox_sub_t *\u003E(d-\u003Eiox_subscriber), d-\u003Eiox_chunk);\n\u002B    d-\u003Eiox_chunk = nullptr;\n\u002B  }\n\u002B#endif\n   delete d;\n }\n \ndiff --git rmw_cyclonedds_cpp/src/serdata.hpp rmw_cyclonedds_cpp/src/serdata.hpp\nindex 84f3769..f0c73eb 100644\n--- rmw_cyclonedds_cpp/src/serdata.hpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdata.hpp\n@@ -24,6 \u002B24,9 @@\n #include \u0022dds/ddsi/ddsi_serdata.h\u0022\n #ifdef DDS_HAS_SHM\n #include \u0022dds/ddsi/q_xmsg.h\u0022\n\u002Bextern \u0022C\u0022 {\n\u002B#include \u0022dds/ddsi/shm_sync.h\u0022\n\u002B}\n #endif  // DDS_HAS_SHM\n \n #if !DDS_HAS_DDSI_SERTYPE\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "2e852fa973ec7ec3d04b52fb10d5baeedecf0af2",
    "RawMessage": "Improve the performance of rcutils_logging_format_message. (#372)",
    "Changes": "diff --git src/logging.c src/logging.c\nindex cf18fee..9854670 100644\n--- src/logging.c\n\u002B\u002B\u002B src/logging.c\n@@ -102,6 \u002B102,30 @@ static FILE * g_output_stream = NULL;\n \n static enum rcutils_colorized_output g_colorized_output = RCUTILS_COLORIZED_OUTPUT_AUTO;\n \n\u002Btypedef struct logging_input_s\n\u002B{\n\u002B  const char * name;\n\u002B  const rcutils_log_location_t * location;\n\u002B  const char * msg;\n\u002B  int severity;\n\u002B  rcutils_time_point_value_t timestamp;\n\u002B} logging_input_t;\n\u002B\n\u002Btypedef const char * (* token_handler)(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset);\n\u002B\n\u002Btypedef struct log_msg_part_s\n\u002B{\n\u002B  token_handler handler;\n\u002B  size_t start_offset;\n\u002B  size_t end_offset;\n\u002B} log_msg_part_t;\n\u002B\n\u002Bstatic size_t g_num_log_msg_handlers = 0;\n\u002Bstatic log_msg_part_t g_handlers[1024];\n\u002B\n rcutils_ret_t rcutils_logging_initialize(void)\n {\n   return rcutils_logging_initialize_with_allocator(rcutils_get_default_allocator());\n@@ -152,6 \u002B176,353 @@ static enum rcutils_get_env_retval rcutils_get_env_var_zero_or_one(\n   return RCUTILS_GET_ENV_ERROR;\n }\n \n\u002Bstatic const char * expand_time(\n\u002B  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,\n\u002B  rcutils_ret_t (* time_func)(const rcutils_time_point_value_t *, char *, size_t))\n\u002B{\n\u002B  // Temporary, local storage for integer/float conversion to string\n\u002B  // Note:\n\u002B  //   32 characters enough, because the most it can be is 20 characters\n\u002B  //   for the 19 possible digits in a signed 64-bit number plus the optional\n\u002B  //   decimal point in the floating point seconds version\n\u002B  char numeric_storage[32];\n\u002B\n\u002B  if (time_func(\n\u002B      \u0026logging_input-\u003Etimestamp, numeric_storage,\n\u002B      sizeof(numeric_storage)) != RCUTILS_RET_OK)\n\u002B  {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    rcutils_reset_error();\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  if (rcutils_char_array_strcat(logging_output, numeric_storage) != RCUTILS_RET_OK) {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    rcutils_reset_error();\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_time_as_seconds(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_seconds_string);\n\u002B}\n\u002B\n\u002Bstatic const char * expand_time_as_nanoseconds(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_nanoseconds_string);\n\u002B}\n\u002B\n\u002Bstatic const char * expand_line_number(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  if (logging_input-\u003Elocation) {\n\u002B    // Allow 9 digits for the expansion of the line number (otherwise, truncate).\n\u002B    char line_number_expansion[10];\n\u002B\n\u002B    // Even in the case of truncation the result will still be null-terminated.\n\u002B    int written = rcutils_snprintf(\n\u002B      line_number_expansion, sizeof(line_number_expansion), \u0022%zu\u0022,\n\u002B      logging_input-\u003Elocation-\u003Eline_number);\n\u002B    if (written \u003C 0) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n\u002B        \u0022failed to format line number: \u0027%zu\u0027\\n\u0022, logging_input-\u003Elocation-\u003Eline_number);\n\u002B      return NULL;\n\u002B    }\n\u002B\n\u002B    if (rcutils_char_array_strcat(logging_output, line_number_expansion) != RCUTILS_RET_OK) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B      rcutils_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B      return NULL;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_severity(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  const char * severity_string = g_rcutils_log_severity_names[logging_input-\u003Eseverity];\n\u002B  if (rcutils_char_array_strcat(logging_output, severity_string) != RCUTILS_RET_OK) {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    rcutils_reset_error();\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_name(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  if (NULL != logging_input-\u003Ename) {\n\u002B    if (rcutils_char_array_strcat(logging_output, logging_input-\u003Ename) != RCUTILS_RET_OK) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B      rcutils_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B      return NULL;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_message(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  if (rcutils_char_array_strcat(logging_output, logging_input-\u003Emsg) != RCUTILS_RET_OK) {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    rcutils_reset_error();\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_function_name(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  if (logging_input-\u003Elocation) {\n\u002B    if (rcutils_char_array_strcat(\n\u002B        logging_output,\n\u002B        logging_input-\u003Elocation-\u003Efunction_name) != RCUTILS_RET_OK)\n\u002B    {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B      rcutils_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B      return NULL;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic const char * expand_file_name(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)start_offset;\n\u002B  (void)end_offset;\n\u002B\n\u002B  if (logging_input-\u003Elocation) {\n\u002B    if (rcutils_char_array_strcat(\n\u002B        logging_output,\n\u002B        logging_input-\u003Elocation-\u003Efile_name) != RCUTILS_RET_OK)\n\u002B    {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B      rcutils_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B      return NULL;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Btypedef struct token_map_entry_s\n\u002B{\n\u002B  const char * token;\n\u002B  token_handler handler;\n\u002B} token_map_entry_t;\n\u002B\n\u002Bstatic const token_map_entry_t tokens[] = {\n\u002B  {.token = \u0022severity\u0022, .handler = expand_severity},\n\u002B  {.token = \u0022name\u0022, .handler = expand_name},\n\u002B  {.token = \u0022message\u0022, .handler = expand_message},\n\u002B  {.token = \u0022function_name\u0022, .handler = expand_function_name},\n\u002B  {.token = \u0022file_name\u0022, .handler = expand_file_name},\n\u002B  {.token = \u0022time\u0022, .handler = expand_time_as_seconds},\n\u002B  {.token = \u0022time_as_nanoseconds\u0022, .handler = expand_time_as_nanoseconds},\n\u002B  {.token = \u0022line_number\u0022, .handler = expand_line_number},\n\u002B};\n\u002B\n\u002Bstatic token_handler find_token_handler(const char * token)\n\u002B{\n\u002B  int token_number = sizeof(tokens) / sizeof(tokens[0]);\n\u002B  for (int token_index = 0; token_index \u003C token_number; token_index\u002B\u002B) {\n\u002B    if (strcmp(token, tokens[token_index].token) == 0) {\n\u002B      return tokens[token_index].handler;\n\u002B    }\n\u002B  }\n\u002B  return NULL;\n\u002B}\n\u002B\n\u002Bstatic const char * copy_from_orig(\n\u002B  const logging_input_t * logging_input,\n\u002B  rcutils_char_array_t * logging_output,\n\u002B  size_t start_offset, size_t end_offset)\n\u002B{\n\u002B  (void)logging_input;\n\u002B\n\u002B  if (rcutils_char_array_strncat(\n\u002B      logging_output,\n\u002B      g_rcutils_logging_output_format_string \u002B start_offset,\n\u002B      end_offset - start_offset) != RCUTILS_RET_OK)\n\u002B  {\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n\u002B    rcutils_reset_error();\n\u002B    RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B    return NULL;\n\u002B  }\n\u002B\n\u002B  return logging_output-\u003Ebuffer;\n\u002B}\n\u002B\n\u002Bstatic void parse_and_create_handlers_list(void)\n\u002B{\n\u002B  // Process the format string looking for known tokens.\n\u002B  const char token_start_delimiter = \u0027{\u0027;\n\u002B  const char token_end_delimiter = \u0027}\u0027;\n\u002B\n\u002B  const char * str = g_rcutils_logging_output_format_string;\n\u002B  size_t size = strlen(g_rcutils_logging_output_format_string);\n\u002B\n\u002B  g_num_log_msg_handlers = 0;\n\u002B\n\u002B  // Walk through the format string and create callbacks when they\u0027re encountered.\n\u002B  size_t i = 0;\n\u002B  while (i \u003C size) {\n\u002B    // Print everything up to the next token start delimiter.\n\u002B    size_t chars_to_start_delim = rcutils_find(str \u002B i, token_start_delimiter);\n\u002B    size_t remaining_chars = size - i;\n\u002B\n\u002B    if (chars_to_start_delim \u003E 0) {  // there is stuff before a token start delimiter\n\u002B      size_t chars_to_copy = chars_to_start_delim \u003E\n\u002B        remaining_chars ? remaining_chars : chars_to_start_delim;\n\u002B      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n\u002B      g_handlers[g_num_log_msg_handlers].start_offset = i;\n\u002B      g_handlers[g_num_log_msg_handlers].end_offset = i \u002B chars_to_copy;\n\u002B      if (g_num_log_msg_handlers \u003E= sizeof(g_handlers) - 1) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022Too many substitutions in the logging output format string; truncating\u0022);\n\u002B        rcutils_reset_error();\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        return;\n\u002B      }\n\u002B      g_num_log_msg_handlers\u002B\u002B;\n\u002B\n\u002B      i \u002B= chars_to_copy;\n\u002B      if (i \u003E= size) {  // perhaps no start delimiter was found\n\u002B        break;\n\u002B      }\n\u002B\n\u002B      continue;\n\u002B    }\n\u002B\n\u002B    // We are at a token start delimiter: determine if there\u0027s a known token or not.\n\u002B    // Potential tokens can\u0027t possibly be longer than the format string itself.\n\u002B    char token[RCUTILS_LOGGING_MAX_OUTPUT_FORMAT_LEN];\n\u002B\n\u002B    // Look for a token end delimiter.\n\u002B    size_t chars_to_end_delim = rcutils_find(str \u002B i, token_end_delimiter);\n\u002B    remaining_chars = size - i;\n\u002B\n\u002B    if (chars_to_end_delim \u003E remaining_chars) {\n\u002B      // No end delimiters found in the remainder of the format string;\n\u002B      // there won\u0027t be any more tokens so shortcut the rest of the checking.\n\u002B      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n\u002B      g_handlers[g_num_log_msg_handlers].start_offset = i;\n\u002B      g_handlers[g_num_log_msg_handlers].end_offset = i \u002B remaining_chars;\n\u002B      if (g_num_log_msg_handlers \u003E= sizeof(g_handlers) - 1) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022Too many substitutions in the logging output format string; truncating\u0022);\n\u002B        rcutils_reset_error();\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        return;\n\u002B      }\n\u002B      g_num_log_msg_handlers\u002B\u002B;\n\u002B      break;\n\u002B    }\n\u002B\n\u002B    // Found what looks like a token; determine if it\u0027s recognized.\n\u002B    size_t token_len = chars_to_end_delim - 1;  // Not including delimiters.\n\u002B    memcpy(token, str \u002B i \u002B 1, token_len);  // Skip the start delimiter.\n\u002B    token[token_len] = \u0027\\0\u0027;\n\u002B\n\u002B    token_handler expand_token = find_token_handler(token);\n\u002B\n\u002B    if (!expand_token) {\n\u002B      // This wasn\u0027t a token; print the start delimiter and continue the search as usual\n\u002B      // (the substring might contain more start delimiters).\n\u002B      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n\u002B      g_handlers[g_num_log_msg_handlers].start_offset = i;\n\u002B      g_handlers[g_num_log_msg_handlers].end_offset = i \u002B 1;\n\u002B      if (g_num_log_msg_handlers \u003E= sizeof(g_handlers) - 1) {\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B          \u0022Too many substitutions in the logging output format string; truncating\u0022);\n\u002B        rcutils_reset_error();\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B        return;\n\u002B      }\n\u002B      g_num_log_msg_handlers\u002B\u002B;\n\u002B      i\u002B\u002B;\n\u002B      continue;\n\u002B    }\n\u002B\n\u002B    g_handlers[g_num_log_msg_handlers].handler = expand_token;\n\u002B    // These are unused when using a token expander\n\u002B    g_handlers[g_num_log_msg_handlers].start_offset = 0;\n\u002B    g_handlers[g_num_log_msg_handlers].end_offset = 0;\n\u002B    if (g_num_log_msg_handlers \u003E= sizeof(g_handlers) - 1) {\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\n\u002B        \u0022Too many substitutions in the logging output format string; truncating\u0022);\n\u002B      rcutils_reset_error();\n\u002B      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022);\n\u002B      return;\n\u002B    }\n\u002B    g_num_log_msg_handlers\u002B\u002B;\n\u002B\n\u002B    // Skip ahead to avoid re-processing the token characters (including the 2 delimiters).\n\u002B    i \u002B= token_len \u002B 2;\n\u002B  }\n\u002B}\n\u002B\n rcutils_ret_t rcutils_logging_initialize_with_allocator(rcutils_allocator_t allocator)\n {\n   if (g_rcutils_logging_initialized) {\n@@ -286,7 \u002B657,10 @@ rcutils_ret_t rcutils_logging_initialize_with_allocator(rcutils_allocator_t allo\n     return RCUTILS_RET_STRING_MAP_INVALID;\n   }\n \n\u002B  parse_and_create_handlers_list();\n\u002B\n   g_rcutils_logging_severities_map_valid = true;\n\u002B\n   g_rcutils_logging_initialized = true;\n \n   return RCUTILS_RET_OK;\n@@ -308,6 \u002B682,7 @@ rcutils_ret_t rcutils_logging_shutdown(void)\n     }\n     g_rcutils_logging_severities_map_valid = false;\n   }\n\u002B  g_num_log_msg_handlers = 0;\n   g_rcutils_logging_initialized = false;\n   return ret;\n }\n@@ -512,26 \u002B887,6 @@ bool rcutils_logging_logger_is_enabled_for(const char * name, int severity)\n   }\n   return severity \u003E= logger_level;\n }\n-#define SAFE_FWRITE_TO_STDERR_AND(action) \\\n-  RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n-  rcutils_reset_error(); \\\n-  RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022); \\\n-  action;\n-\n-#define OK_OR_RETURN_NULL(op) \\\n-  if (op != RCUTILS_RET_OK) { \\\n-    SAFE_FWRITE_TO_STDERR_AND(return NULL); \\\n-  }\n-\n-#define OK_OR_RETURN_EARLY(op) \\\n-  if (op != RCUTILS_RET_OK) { \\\n-    return op; \\\n-  }\n-\n-#define APPEND_AND_RETURN_LOG_OUTPUT(s) \\\n-  OK_OR_RETURN_NULL(rcutils_char_array_strcat(logging_output, s)); \\\n-  return logging_output-\u003Ebuffer;\n-\n \n static void vrcutils_log_internal(\n   const rcutils_log_location_t * location,\n@@ -573,160 \u002B928,11 @@ void rcutils_log_internal(\n   va_end(args);\n }\n \n-typedef struct logging_input_s\n-{\n-  const char * name;\n-  const rcutils_log_location_t * location;\n-  const char * msg;\n-  int severity;\n-  rcutils_time_point_value_t timestamp;\n-} logging_input_t;\n-\n-typedef const char * (* token_handler)(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output);\n-\n-typedef struct token_map_entry_s\n-{\n-  const char * token;\n-  token_handler handler;\n-} token_map_entry_t;\n-\n-static const char * expand_time(\n-  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,\n-  rcutils_ret_t (* time_func)(const rcutils_time_point_value_t *, char *, size_t))\n-{\n-  // Temporary, local storage for integer/float conversion to string\n-  // Note:\n-  //   32 characters enough, because the most it can be is 20 characters\n-  //   for the 19 possible digits in a signed 64-bit number plus the optional\n-  //   decimal point in the floating point seconds version\n-  char numeric_storage[32];\n-  OK_OR_RETURN_NULL(time_func(\u0026logging_input-\u003Etimestamp, numeric_storage, sizeof(numeric_storage)));\n-  APPEND_AND_RETURN_LOG_OUTPUT(numeric_storage);\n-}\n-\n-static const char * expand_time_as_seconds(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_seconds_string);\n-}\n-\n-static const char * expand_time_as_nanoseconds(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_nanoseconds_string);\n-}\n-\n-static const char * expand_line_number(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  // Allow 9 digits for the expansion of the line number (otherwise, truncate).\n-  char line_number_expansion[10];\n-\n-  const rcutils_log_location_t * location = logging_input-\u003Elocation;\n-\n-  if (!location) {\n-    OK_OR_RETURN_NULL(rcutils_char_array_strcpy(logging_output, \u00220\u0022));\n-    return logging_output-\u003Ebuffer;\n-  }\n-\n-  // Even in the case of truncation the result will still be null-terminated.\n-  int written = rcutils_snprintf(\n-    line_number_expansion, sizeof(line_number_expansion), \u0022%zu\u0022, location-\u003Eline_number);\n-  if (written \u003C 0) {\n-    RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n-      \u0022failed to format line number: \u0027%zu\u0027\\n\u0022, location-\u003Eline_number);\n-    return NULL;\n-  }\n-\n-  APPEND_AND_RETURN_LOG_OUTPUT(line_number_expansion);\n-}\n-\n-static const char * expand_severity(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  const char * severity_string = g_rcutils_log_severity_names[logging_input-\u003Eseverity];\n-  APPEND_AND_RETURN_LOG_OUTPUT(severity_string);\n-}\n-\n-static const char * expand_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (NULL != logging_input-\u003Ename) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input-\u003Ename);\n-  }\n-  return logging_output-\u003Ebuffer;\n-}\n-\n-static const char * expand_message(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  OK_OR_RETURN_NULL(rcutils_char_array_strcat(logging_output, logging_input-\u003Emsg));\n-  return logging_output-\u003Ebuffer;\n-}\n-\n-static const char * expand_function_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (logging_input-\u003Elocation) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input-\u003Elocation-\u003Efunction_name);\n-  }\n-  return logging_output-\u003Ebuffer;\n-}\n-\n-static const char * expand_file_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (logging_input-\u003Elocation) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input-\u003Elocation-\u003Efile_name);\n-  }\n-  return logging_output-\u003Ebuffer;\n-}\n-\n-static const token_map_entry_t tokens[] = {\n-  {.token = \u0022severity\u0022, .handler = expand_severity},\n-  {.token = \u0022name\u0022, .handler = expand_name},\n-  {.token = \u0022message\u0022, .handler = expand_message},\n-  {.token = \u0022function_name\u0022, .handler = expand_function_name},\n-  {.token = \u0022file_name\u0022, .handler = expand_file_name},\n-  {.token = \u0022time\u0022, .handler = expand_time_as_seconds},\n-  {.token = \u0022time_as_nanoseconds\u0022, .handler = expand_time_as_nanoseconds},\n-  {.token = \u0022line_number\u0022, .handler = expand_line_number},\n-};\n-\n-static token_handler find_token_handler(const char * token)\n-{\n-  int token_number = sizeof(tokens) / sizeof(tokens[0]);\n-  for (int token_index = 0; token_index \u003C token_number; token_index\u002B\u002B) {\n-    if (strcmp(token, tokens[token_index].token) == 0) {\n-      return tokens[token_index].handler;\n-    }\n-  }\n-  return NULL;\n-}\n-\n rcutils_ret_t rcutils_logging_format_message(\n   const rcutils_log_location_t * location,\n   int severity, const char * name, rcutils_time_point_value_t timestamp,\n   const char * msg, rcutils_char_array_t * logging_output)\n {\n-  rcutils_ret_t status = RCUTILS_RET_OK;\n-  // Process the format string looking for known tokens.\n-  const char token_start_delimiter = \u0027{\u0027;\n-  const char token_end_delimiter = \u0027}\u0027;\n-\n-  const char * str = g_rcutils_logging_output_format_string;\n-  size_t size = strlen(g_rcutils_logging_output_format_string);\n-\n   const logging_input_t logging_input = {\n     .location = location,\n     .severity = severity,\n@@ -735,64 \u002B941,16 @@ rcutils_ret_t rcutils_logging_format_message(\n     .msg = msg\n   };\n \n-  // Walk through the format string and expand tokens when they\u0027re encountered.\n-  size_t i = 0;\n-  while (i \u003C size) {\n-    // Print everything up to the next token start delimiter.\n-    size_t chars_to_start_delim = rcutils_find(str \u002B i, token_start_delimiter);\n-    size_t remaining_chars = size - i;\n-\n-    if (chars_to_start_delim \u003E 0) {  // there are stuff before a token start delimiter\n-      size_t chars_to_copy = chars_to_start_delim \u003E\n-        remaining_chars ? remaining_chars : chars_to_start_delim;\n-      status = rcutils_char_array_strncat(logging_output, str \u002B i, chars_to_copy);\n-      OK_OR_RETURN_EARLY(status);\n-      i \u002B= chars_to_copy;\n-      if (i \u003E= size) {  // perhaps no start delimiter was found\n-        break;\n-      }\n-    }\n-\n-    // We are at a token start delimiter: determine if there\u0027s a known token or not.\n-    // Potential tokens can\u0027t possibly be longer than the format string itself.\n-    char token[RCUTILS_LOGGING_MAX_OUTPUT_FORMAT_LEN];\n-\n-    // Look for a token end delimiter.\n-    size_t chars_to_end_delim = rcutils_find(str \u002B i, token_end_delimiter);\n-    remaining_chars = size - i;\n-\n-    if (chars_to_end_delim \u003E remaining_chars) {\n-      // No end delimiters found in the remainder of the format string;\n-      // there won\u0027t be any more tokens so shortcut the rest of the checking.\n-      status = rcutils_char_array_strncat(logging_output, str \u002B i, remaining_chars);\n-      OK_OR_RETURN_EARLY(status);\n-      break;\n-    }\n-\n-    // Found what looks like a token; determine if it\u0027s recognized.\n-    size_t token_len = chars_to_end_delim - 1;  // Not including delimiters.\n-    memcpy(token, str \u002B i \u002B 1, token_len);  // Skip the start delimiter.\n-    token[token_len] = \u0027\\0\u0027;\n-\n-    token_handler expand_token = find_token_handler(token);\n-\n-    if (!expand_token) {\n-      // This wasn\u0027t a token; print the start delimiter and continue the search as usual\n-      // (the substring might contain more start delimiters).\n-      status = rcutils_char_array_strncat(logging_output, str \u002B i, 1);\n-      OK_OR_RETURN_EARLY(status);\n-      i\u002B\u002B;\n-      continue;\n-    }\n-\n-    if (!expand_token(\u0026logging_input, logging_output)) {\n\u002B  for (size_t i = 0; i \u003C g_num_log_msg_handlers; \u002B\u002Bi) {\n\u002B    if (g_handlers[i].handler(\n\u002B        \u0026logging_input, logging_output,\n\u002B        g_handlers[i].start_offset, g_handlers[i].end_offset) == NULL)\n\u002B    {\n       return RCUTILS_RET_ERROR;\n     }\n-    // Skip ahead to avoid re-processing the token characters (including the 2 delimiters).\n-    i \u002B= token_len \u002B 2;\n   }\n \n-  return status;\n\u002B  return RCUTILS_RET_OK;\n }\n \n #ifdef _WIN32\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "9584697c277a01ea17a3bd6e2eea29d71c9d9d0f",
    "RawMessage": "Explicitly link atomic when building with Clang (#1065)",
    "Changes": "diff --git rclpy/CMakeLists.txt rclpy/CMakeLists.txt\nindex 1e9afe6..305ac85 100644\n--- rclpy/CMakeLists.txt\n\u002B\u002B\u002B rclpy/CMakeLists.txt\n@@ -102,6 \u002B102,11 @@ pybind11_add_module(_rclpy_pybind11 SHARED\n   src/rclpy/utils.cpp\n   src/rclpy/wait_set.cpp\n )\n\u002B\n\u002Bif(CMAKE_C_COMPILER_ID MATCHES \u0022Clang\u0022)\n\u002B  target_link_libraries(_rclpy_pybind11 PRIVATE atomic)\n\u002Bendif()\n\u002B\n target_include_directories(_rclpy_pybind11 PRIVATE\n   src/rclpy/\n )\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "3df73f0e3882409910ef07438bc6e75ce2156aba",
    "RawMessage": "Implement generic client (#2358)",
    "Changes": "diff --git rclcpp/CMakeLists.txt rclcpp/CMakeLists.txt\nindex 1f78d03d..64b7caed 100644\n--- rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/CMakeLists.txt\n@@ -45,6 \u002B45,7 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/clock.cpp\n   src/rclcpp/context.cpp\n   src/rclcpp/contexts/default_context.cpp\n\u002B  src/rclcpp/create_generic_client.cpp\n   src/rclcpp/detail/add_guard_condition_to_rcl_wait_set.cpp\n   src/rclcpp/detail/resolve_intra_process_buffer_type.cpp\n   src/rclcpp/detail/resolve_parameter_overrides.cpp\n@@ -74,6 \u002B75,7 @@ set(${PROJECT_NAME}_SRCS\n   src/rclcpp/experimental/executors/events_executor/events_executor.cpp\n   src/rclcpp/experimental/timers_manager.cpp\n   src/rclcpp/future_return_code.cpp\n\u002B  src/rclcpp/generic_client.cpp\n   src/rclcpp/generic_publisher.cpp\n   src/rclcpp/generic_subscription.cpp\n   src/rclcpp/graph_listener.cpp\ndiff --git rclcpp/include/rclcpp/client.hpp rclcpp/include/rclcpp/client.hpp\nindex 85b0a2d5..f69ab0b2 100644\n--- rclcpp/include/rclcpp/client.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/client.hpp\n@@ -115,6 \u002B115,29 @@ struct FutureAndRequestId\n   /// Destructor.\n   ~FutureAndRequestId() = default;\n };\n\u002B\n\u002Btemplate\u003Ctypename PendingRequestsT, typename AllocatorT = std::allocator\u003Cint64_t\u003E\u003E\n\u002Bsize_t\n\u002Bprune_requests_older_than_impl(\n\u002B  PendingRequestsT \u0026 pending_requests,\n\u002B  std::mutex \u0026 pending_requests_mutex,\n\u002B  std::chrono::time_point\u003Cstd::chrono::system_clock\u003E time_point,\n\u002B  std::vector\u003Cint64_t, AllocatorT\u003E * pruned_requests = nullptr)\n\u002B{\n\u002B  std::lock_guard guard(pending_requests_mutex);\n\u002B  auto old_size = pending_requests.size();\n\u002B  for (auto it = pending_requests.begin(), last = pending_requests.end(); it != last; ) {\n\u002B    if (it-\u003Esecond.first \u003C time_point) {\n\u002B      if (pruned_requests) {\n\u002B        pruned_requests-\u003Epush_back(it-\u003Efirst);\n\u002B      }\n\u002B      it = pending_requests.erase(it);\n\u002B    } else {\n\u002B      \u002B\u002Bit;\n\u002B    }\n\u002B  }\n\u002B  return old_size - pending_requests.size();\n\u002B}\n }  // namespace detail\n \n namespace node_interfaces\n@@ -771,19 \u002B794,11 @@ public:\n     std::chrono::time_point\u003Cstd::chrono::system_clock\u003E time_point,\n     std::vector\u003Cint64_t, AllocatorT\u003E * pruned_requests = nullptr)\n   {\n-    std::lock_guard guard(pending_requests_mutex_);\n-    auto old_size = pending_requests_.size();\n-    for (auto it = pending_requests_.begin(), last = pending_requests_.end(); it != last; ) {\n-      if (it-\u003Esecond.first \u003C time_point) {\n-        if (pruned_requests) {\n-          pruned_requests-\u003Epush_back(it-\u003Efirst);\n-        }\n-        it = pending_requests_.erase(it);\n-      } else {\n-        \u002B\u002Bit;\n-      }\n-    }\n-    return old_size - pending_requests_.size();\n\u002B    return detail::prune_requests_older_than_impl(\n\u002B      pending_requests_,\n\u002B      pending_requests_mutex_,\n\u002B      time_point,\n\u002B      pruned_requests);\n   }\n \n   /// Configure client introspection.\ndiff --git rclcpp/include/rclcpp/create_generic_client.hpp rclcpp/include/rclcpp/create_generic_client.hpp\nnew file mode 100644\nindex 00000000..eade7bd9\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/create_generic_client.hpp\n@@ -0,0 \u002B1,90 @@\n\u002B// Copyright 2023 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__CREATE_GENERIC_CLIENT_HPP_\n\u002B#define RCLCPP__CREATE_GENERIC_CLIENT_HPP_\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rclcpp/generic_client.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_base_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_graph_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/get_node_services_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_base_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_graph_interface.hpp\u0022\n\u002B#include \u0022rclcpp/node_interfaces/node_services_interface.hpp\u0022\n\u002B#include \u0022rclcpp/qos.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002B/// Create a generic service client with a name of given type.\n\u002B/**\n\u002B * \\param[in] node_base NodeBaseInterface implementation of the node on which\n\u002B *  to create the client.\n\u002B * \\param[in] node_graph NodeGraphInterface implementation of the node on which\n\u002B *  to create the client.\n\u002B * \\param[in] node_services NodeServicesInterface implementation of the node on\n\u002B *  which to create the client.\n\u002B * \\param[in] service_name The name on which the service is accessible.\n\u002B * \\param[in] service_type The name of service type, e.g. \u0022test_msgs/srv/BasicTypes\u0022\n\u002B * \\param[in] qos Quality of service profile for client.\n\u002B * \\param[in] group Callback group to handle the reply to service calls.\n\u002B * \\return Shared pointer to the created client.\n\u002B */\n\u002BRCLCPP_PUBLIC\n\u002Brclcpp::GenericClient::SharedPtr\n\u002Bcreate_generic_client(\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeBaseInterface\u003E node_base,\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeGraphInterface\u003E node_graph,\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeServicesInterface\u003E node_services,\n\u002B  const std::string \u0026 service_name,\n\u002B  const std::string \u0026 service_type,\n\u002B  const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(),\n\u002B  rclcpp::CallbackGroup::SharedPtr group = nullptr);\n\u002B\n\u002B/// Create a generic service client with a name of given type.\n\u002B/**\n\u002B * The NodeT type needs to have NodeBaseInterface implementation, NodeGraphInterface implementation\n\u002B * and NodeServicesInterface implementation of the node which to create the client.\n\u002B *\n\u002B * \\param[in] node The node on which to create the client.\n\u002B * \\param[in] service_name The name on which the service is accessible.\n\u002B * \\param[in] service_type The name of service type, e.g. \u0022test_msgs/srv/BasicTypes\u0022\n\u002B * \\param[in] qos Quality of service profile for client.\n\u002B * \\param[in] group Callback group to handle the reply to service calls.\n\u002B * \\return Shared pointer to the created client.\n\u002B */\n\u002Btemplate\u003Ctypename NodeT\u003E\n\u002Brclcpp::GenericClient::SharedPtr\n\u002Bcreate_generic_client(\n\u002B  NodeT node,\n\u002B  const std::string \u0026 service_name,\n\u002B  const std::string \u0026 service_type,\n\u002B  const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(),\n\u002B  rclcpp::CallbackGroup::SharedPtr group = nullptr)\n\u002B{\n\u002B  return create_generic_client(\n\u002B    rclcpp::node_interfaces::get_node_base_interface(node),\n\u002B    rclcpp::node_interfaces::get_node_graph_interface(node),\n\u002B    rclcpp::node_interfaces::get_node_services_interface(node),\n\u002B    service_name,\n\u002B    service_type,\n\u002B    qos,\n\u002B    group\n\u002B  );\n\u002B}\n\u002B}  // namespace rclcpp\n\u002B\n\u002B#endif  // RCLCPP__CREATE_GENERIC_CLIENT_HPP_\ndiff --git rclcpp/include/rclcpp/generic_client.hpp rclcpp/include/rclcpp/generic_client.hpp\nnew file mode 100644\nindex 00000000..d6073dec\n--- /dev/null\n\u002B\u002B\u002B rclcpp/include/rclcpp/generic_client.hpp\n@@ -0,0 \u002B1,207 @@\n\u002B// Copyright 2023 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#ifndef RCLCPP__GENERIC_CLIENT_HPP_\n\u002B#define RCLCPP__GENERIC_CLIENT_HPP_\n\u002B\n\u002B#include \u003Cmap\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cfuture\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cvector\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022rcl/client.h\u0022\n\u002B\n\u002B#include \u0022rclcpp/client.hpp\u0022\n\u002B#include \u0022rclcpp/visibility_control.hpp\u0022\n\u002B#include \u0022rcpputils/shared_library.hpp\u0022\n\u002B\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/message_introspection.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Bclass GenericClient : public ClientBase\n\u002B{\n\u002Bpublic:\n\u002B  using Request = void *;   // Serialized data pointer of request message\n\u002B  using Response = void *;  // Serialized data pointer of response message\n\u002B\n\u002B  using SharedResponse = std::shared_ptr\u003Cvoid\u003E;\n\u002B\n\u002B  using Promise = std::promise\u003CSharedResponse\u003E;\n\u002B  using SharedPromise = std::shared_ptr\u003CPromise\u003E;\n\u002B\n\u002B  using Future = std::future\u003CSharedResponse\u003E;\n\u002B  using SharedFuture = std::shared_future\u003CSharedResponse\u003E;\n\u002B\n\u002B  RCLCPP_SMART_PTR_DEFINITIONS(GenericClient)\n\u002B\n\u002B  /// A convenient GenericClient::Future and request id pair.\n\u002B  /**\n\u002B   * Public members:\n\u002B   * - future: a std::future\u003Cvoid *\u003E.\n\u002B   * - request_id: the request id associated with the future.\n\u002B   *\n\u002B   * All the other methods are equivalent to the ones std::future provides.\n\u002B   */\n\u002B  struct FutureAndRequestId\n\u002B    : detail::FutureAndRequestId\u003CFuture\u003E\n\u002B  {\n\u002B    using detail::FutureAndRequestId\u003CFuture\u003E::FutureAndRequestId;\n\u002B\n\u002B    /// See std::future::share().\n\u002B    SharedFuture share() noexcept {return this-\u003Efuture.share();}\n\u002B\n\u002B    /// Move constructor.\n\u002B    FutureAndRequestId(FutureAndRequestId \u0026\u0026 other) noexcept = default;\n\u002B    /// Deleted copy constructor, each instance is a unique owner of the future.\n\u002B    FutureAndRequestId(const FutureAndRequestId \u0026 other) = delete;\n\u002B    /// Move assignment.\n\u002B    FutureAndRequestId \u0026 operator=(FutureAndRequestId \u0026\u0026 other) noexcept = default;\n\u002B    /// Deleted copy assignment, each instance is a unique owner of the future.\n\u002B    FutureAndRequestId \u0026 operator=(const FutureAndRequestId \u0026 other) = delete;\n\u002B    /// Destructor.\n\u002B    ~FutureAndRequestId() = default;\n\u002B  };\n\u002B\n\u002B  GenericClient(\n\u002B    rclcpp::node_interfaces::NodeBaseInterface * node_base,\n\u002B    rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,\n\u002B    const std::string \u0026 service_name,\n\u002B    const std::string \u0026 service_type,\n\u002B    rcl_client_options_t \u0026 client_options);\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  SharedResponse\n\u002B  create_response() override;\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  std::shared_ptr\u003Crmw_request_id_t\u003E\n\u002B  create_request_header() override;\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  void\n\u002B  handle_response(\n\u002B    std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n\u002B    std::shared_ptr\u003Cvoid\u003E response) override;\n\u002B\n\u002B  /// Send a request to the service server.\n\u002B  /**\n\u002B   * This method returns a \u0060FutureAndRequestId\u0060 instance\n\u002B   * that can be passed to Executor::spin_until_future_complete() to\n\u002B   * wait until it has been completed.\n\u002B   *\n\u002B   * If the future never completes,\n\u002B   * e.g. the call to Executor::spin_until_future_complete() times out,\n\u002B   * GenericClient::remove_pending_request() must be called to clean the client internal state.\n\u002B   * Not doing so will make the \u0060Client\u0060 instance to use more memory each time a response is not\n\u002B   * received from the service server.\n\u002B   *\n\u002B   * \u0060\u0060\u0060cpp\n\u002B   * auto future = client-\u003Easync_send_request(my_request);\n\u002B   * if (\n\u002B   *   rclcpp::FutureReturnCode::TIMEOUT ==\n\u002B   *   executor-\u003Espin_until_future_complete(future, timeout))\n\u002B   * {\n\u002B   *   client-\u003Eremove_pending_request(future);\n\u002B   *   // handle timeout\n\u002B   * } else {\n\u002B   *   handle_response(future.get());\n\u002B   * }\n\u002B   * \u0060\u0060\u0060\n\u002B   *\n\u002B   * \\param[in] request request to be send.\n\u002B   * \\return a FutureAndRequestId instance.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  FutureAndRequestId\n\u002B  async_send_request(const Request request);\n\u002B\n\u002B  /// Clean all pending requests older than a time_point.\n\u002B  /**\n\u002B   * \\param[in] time_point Requests that were sent before this point are going to be removed.\n\u002B   * \\param[inout] pruned_requests Removed requests id will be pushed to the vector\n\u002B   *  if a pointer is provided.\n\u002B   * \\return number of pending requests that were removed.\n\u002B   */\n\u002B  template\u003Ctypename AllocatorT = std::allocator\u003Cint64_t\u003E\u003E\n\u002B  size_t\n\u002B  prune_requests_older_than(\n\u002B    std::chrono::time_point\u003Cstd::chrono::system_clock\u003E time_point,\n\u002B    std::vector\u003Cint64_t, AllocatorT\u003E * pruned_requests = nullptr)\n\u002B  {\n\u002B    return detail::prune_requests_older_than_impl(\n\u002B      pending_requests_,\n\u002B      pending_requests_mutex_,\n\u002B      time_point,\n\u002B      pruned_requests);\n\u002B  }\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  size_t\n\u002B  prune_pending_requests();\n\u002B\n\u002B  RCLCPP_PUBLIC\n\u002B  bool\n\u002B  remove_pending_request(\n\u002B    int64_t request_id);\n\u002B\n\u002B  /// Take the next response for this client.\n\u002B  /**\n\u002B   * \\sa ClientBase::take_type_erased_response().\n\u002B   *\n\u002B   * \\param[out] response_out The reference to a Service Response into\n\u002B   *   which the middleware will copy the response being taken.\n\u002B   * \\param[out] request_header_out The request header to be filled by the\n\u002B   *   middleware when taking, and which can be used to associate the response\n\u002B   *   to a specific request.\n\u002B   * \\returns true if the response was taken, otherwise false.\n\u002B   * \\throws rclcpp::exceptions::RCLError based exceptions if the underlying\n\u002B   *   rcl function fail.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  bool\n\u002B  take_response(Response response_out, rmw_request_id_t \u0026 request_header_out)\n\u002B  {\n\u002B    return this-\u003Etake_type_erased_response(response_out, request_header_out);\n\u002B  }\n\u002B\n\u002Bprotected:\n\u002B  using CallbackInfoVariant = std::variant\u003C\n\u002B    std::promise\u003CSharedResponse\u003E\u003E;  // Use variant for extension\n\u002B\n\u002B  int64_t\n\u002B  async_send_request_impl(\n\u002B    const Request request,\n\u002B    CallbackInfoVariant value);\n\u002B\n\u002B  std::optional\u003CCallbackInfoVariant\u003E\n\u002B  get_and_erase_pending_request(\n\u002B    int64_t request_number);\n\u002B\n\u002B  RCLCPP_DISABLE_COPY(GenericClient)\n\u002B\n\u002B  std::map\u003Cint64_t, std::pair\u003C\n\u002B      std::chrono::time_point\u003Cstd::chrono::system_clock\u003E,\n\u002B      CallbackInfoVariant\u003E\u003E pending_requests_;\n\u002B  std::mutex pending_requests_mutex_;\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003Crcpputils::SharedLibrary\u003E ts_lib_;\n\u002B  const rosidl_typesupport_introspection_cpp::MessageMembers * response_members_;\n\u002B};\n\u002B}  // namespace rclcpp\n\u002B\n\u002B#endif  // RCLCPP__GENERIC_CLIENT_HPP_\ndiff --git rclcpp/include/rclcpp/node.hpp rclcpp/include/rclcpp/node.hpp\nindex 50b96bbe..35863abb 100644\n--- rclcpp/include/rclcpp/node.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/node.hpp\n@@ -42,6 \u002B42,7 @@\n #include \u0022rclcpp/clock.hpp\u0022\n #include \u0022rclcpp/context.hpp\u0022\n #include \u0022rclcpp/event.hpp\u0022\n\u002B#include \u0022rclcpp/generic_client.hpp\u0022\n #include \u0022rclcpp/generic_publisher.hpp\u0022\n #include \u0022rclcpp/generic_subscription.hpp\u0022\n #include \u0022rclcpp/logger.hpp\u0022\n@@ -320,6 \u002B321,22 @@ public:\n     const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(),\n     rclcpp::CallbackGroup::SharedPtr group = nullptr);\n \n\u002B  /// Create and return a GenericClient.\n\u002B  /**\n\u002B   * \\param[in] service_name The name on which the service is accessible.\n\u002B   * \\param[in] service_type The name of service type, e.g. \u0022std_srvs/srv/SetBool\u0022\n\u002B   * \\param[in] qos Quality of service profile for client.\n\u002B   * \\param[in] group Callback group to handle the reply to service calls.\n\u002B   * \\return Shared pointer to the created GenericClient.\n\u002B   */\n\u002B  RCLCPP_PUBLIC\n\u002B  rclcpp::GenericClient::SharedPtr\n\u002B  create_generic_client(\n\u002B    const std::string \u0026 service_name,\n\u002B    const std::string \u0026 service_type,\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS(),\n\u002B    rclcpp::CallbackGroup::SharedPtr group = nullptr);\n\u002B\n   /// Create and return a GenericPublisher.\n   /**\n    * The returned pointer will never be empty, but this function can throw various exceptions, for\ndiff --git rclcpp/src/rclcpp/create_generic_client.cpp rclcpp/src/rclcpp/create_generic_client.cpp\nnew file mode 100644\nindex 00000000..4b3b7ddc\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/create_generic_client.cpp\n@@ -0,0 \u002B1,44 @@\n\u002B// Copyright 2023 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u0022rclcpp/create_generic_client.hpp\u0022\n\u002B#include \u0022rclcpp/generic_client.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002Brclcpp::GenericClient::SharedPtr\n\u002Bcreate_generic_client(\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeBaseInterface\u003E node_base,\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeGraphInterface\u003E node_graph,\n\u002B  std::shared_ptr\u003Cnode_interfaces::NodeServicesInterface\u003E node_services,\n\u002B  const std::string \u0026 service_name,\n\u002B  const std::string \u0026 service_type,\n\u002B  const rclcpp::QoS \u0026 qos,\n\u002B  rclcpp::CallbackGroup::SharedPtr group)\n\u002B{\n\u002B  rcl_client_options_t options = rcl_client_get_default_options();\n\u002B  options.qos = qos.get_rmw_qos_profile();\n\u002B\n\u002B  auto cli = rclcpp::GenericClient::make_shared(\n\u002B    node_base.get(),\n\u002B    node_graph,\n\u002B    service_name,\n\u002B    service_type,\n\u002B    options);\n\u002B\n\u002B  auto cli_base_ptr = std::dynamic_pointer_cast\u003Crclcpp::ClientBase\u003E(cli);\n\u002B  node_services-\u003Eadd_client(cli_base_ptr, group);\n\u002B  return cli;\n\u002B}\n\u002B}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/generic_client.cpp rclcpp/src/rclcpp/generic_client.cpp\nnew file mode 100644\nindex 00000000..fdcfc70a\n--- /dev/null\n\u002B\u002B\u002B rclcpp/src/rclcpp/generic_client.cpp\n@@ -0,0 \u002B1,164 @@\n\u002B// Copyright 2023 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cfuture\u003E\n\u002B\n\u002B#include \u0022rclcpp/generic_client.hpp\u0022\n\u002B#include \u0022rclcpp/typesupport_helpers.hpp\u0022\n\u002B\n\u002B#include \u0022rosidl_runtime_c/service_type_support_struct.h\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/identifier.hpp\u0022\n\u002B#include \u0022rosidl_typesupport_introspection_cpp/service_introspection.hpp\u0022\n\u002B\n\u002Bnamespace rclcpp\n\u002B{\n\u002BGenericClient::GenericClient(\n\u002B  rclcpp::node_interfaces::NodeBaseInterface * node_base,\n\u002B  rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,\n\u002B  const std::string \u0026 service_name,\n\u002B  const std::string \u0026 service_type,\n\u002B  rcl_client_options_t \u0026 client_options)\n\u002B: ClientBase(node_base, node_graph)\n\u002B{\n\u002B  ts_lib_ = get_typesupport_library(\n\u002B    service_type, \u0022rosidl_typesupport_cpp\u0022);\n\u002B\n\u002B  auto service_ts_ = get_service_typesupport_handle(\n\u002B    service_type, \u0022rosidl_typesupport_cpp\u0022, *ts_lib_);\n\u002B\n\u002B  auto response_type_support_intro = get_message_typesupport_handle(\n\u002B    service_ts_-\u003Eresponse_typesupport,\n\u002B    rosidl_typesupport_introspection_cpp::typesupport_identifier);\n\u002B  response_members_ = static_cast\u003Cconst rosidl_typesupport_introspection_cpp::MessageMembers *\u003E(\n\u002B    response_type_support_intro-\u003Edata);\n\u002B\n\u002B  rcl_ret_t ret = rcl_client_init(\n\u002B    this-\u003Eget_client_handle().get(),\n\u002B    this-\u003Eget_rcl_node_handle(),\n\u002B    service_ts_,\n\u002B    service_name.c_str(),\n\u002B    \u0026client_options);\n\u002B  if (ret != RCL_RET_OK) {\n\u002B    if (ret == RCL_RET_SERVICE_NAME_INVALID) {\n\u002B      auto rcl_node_handle = this-\u003Eget_rcl_node_handle();\n\u002B      // this will throw on any validation problem\n\u002B      rcl_reset_error();\n\u002B      expand_topic_or_service_name(\n\u002B        service_name,\n\u002B        rcl_node_get_name(rcl_node_handle),\n\u002B        rcl_node_get_namespace(rcl_node_handle),\n\u002B        true);\n\u002B    }\n\u002B    rclcpp::exceptions::throw_from_rcl_error(ret, \u0022could not create generic client\u0022);\n\u002B  }\n\u002B}\n\u002B\n\u002Bstd::shared_ptr\u003Cvoid\u003E\n\u002BGenericClient::create_response()\n\u002B{\n\u002B  void * response = new uint8_t[response_members_-\u003Esize_of_];\n\u002B  response_members_-\u003Einit_function(response, rosidl_runtime_cpp::MessageInitialization::ZERO);\n\u002B  return std::shared_ptr\u003Cvoid\u003E(\n\u002B    response,\n\u002B    [this](void * p)\n\u002B    {\n\u002B      response_members_-\u003Efini_function(p);\n\u002B      delete[] reinterpret_cast\u003Cuint8_t *\u003E(p);\n\u002B    });\n\u002B}\n\u002B\n\u002Bstd::shared_ptr\u003Crmw_request_id_t\u003E\n\u002BGenericClient::create_request_header()\n\u002B{\n\u002B  // TODO(wjwwood): This should probably use rmw_request_id\u0027s allocator.\n\u002B  //                (since it is a C type)\n\u002B  return std::shared_ptr\u003Crmw_request_id_t\u003E(new rmw_request_id_t);\n\u002B}\n\u002B\n\u002Bvoid\n\u002BGenericClient::handle_response(\n\u002B  std::shared_ptr\u003Crmw_request_id_t\u003E request_header,\n\u002B  std::shared_ptr\u003Cvoid\u003E response)\n\u002B{\n\u002B  auto optional_pending_request =\n\u002B    this-\u003Eget_and_erase_pending_request(request_header-\u003Esequence_number);\n\u002B  if (!optional_pending_request) {\n\u002B    return;\n\u002B  }\n\u002B  auto \u0026 value = *optional_pending_request;\n\u002B  if (std::holds_alternative\u003CPromise\u003E(value)) {\n\u002B    auto \u0026 promise = std::get\u003CPromise\u003E(value);\n\u002B    promise.set_value(std::move(response));\n\u002B  }\n\u002B}\n\u002B\n\u002Bsize_t\n\u002BGenericClient::prune_pending_requests()\n\u002B{\n\u002B  std::lock_guard guard(pending_requests_mutex_);\n\u002B  auto ret = pending_requests_.size();\n\u002B  pending_requests_.clear();\n\u002B  return ret;\n\u002B}\n\u002B\n\u002Bbool\n\u002BGenericClient::remove_pending_request(int64_t request_id)\n\u002B{\n\u002B  std::lock_guard guard(pending_requests_mutex_);\n\u002B  return pending_requests_.erase(request_id) != 0u;\n\u002B}\n\u002B\n\u002Bstd::optional\u003CGenericClient::CallbackInfoVariant\u003E\n\u002BGenericClient::get_and_erase_pending_request(int64_t request_number)\n\u002B{\n\u002B  std::unique_lock\u003Cstd::mutex\u003E lock(pending_requests_mutex_);\n\u002B  auto it = pending_requests_.find(request_number);\n\u002B  if (it == pending_requests_.end()) {\n\u002B    RCUTILS_LOG_DEBUG_NAMED(\n\u002B      \u0022rclcpp\u0022,\n\u002B      \u0022Received invalid sequence number. Ignoring...\u0022);\n\u002B    return std::nullopt;\n\u002B  }\n\u002B  auto value = std::move(it-\u003Esecond.second);\n\u002B  pending_requests_.erase(request_number);\n\u002B  return value;\n\u002B}\n\u002B\n\u002BGenericClient::FutureAndRequestId\n\u002BGenericClient::async_send_request(const Request request)\n\u002B{\n\u002B  Promise promise;\n\u002B  auto future = promise.get_future();\n\u002B  auto req_id = async_send_request_impl(\n\u002B    request,\n\u002B    std::move(promise));\n\u002B  return FutureAndRequestId(std::move(future), req_id);\n\u002B}\n\u002B\n\u002Bint64_t\n\u002BGenericClient::async_send_request_impl(const Request request, CallbackInfoVariant value)\n\u002B{\n\u002B  int64_t sequence_number;\n\u002B  std::lock_guard\u003Cstd::mutex\u003E lock(pending_requests_mutex_);\n\u002B  rcl_ret_t ret = rcl_send_request(get_client_handle().get(), request, \u0026sequence_number);\n\u002B  if (RCL_RET_OK != ret) {\n\u002B    rclcpp::exceptions::throw_from_rcl_error(ret, \u0022failed to send request\u0022);\n\u002B  }\n\u002B  pending_requests_.try_emplace(\n\u002B    sequence_number,\n\u002B    std::make_pair(std::chrono::system_clock::now(), std::move(value)));\n\u002B  return sequence_number;\n\u002B}\n\u002B\n\u002B}  // namespace rclcpp\ndiff --git rclcpp/src/rclcpp/node.cpp rclcpp/src/rclcpp/node.cpp\nindex c31903f2..1a68c7f1 100644\n--- rclcpp/src/rclcpp/node.cpp\n\u002B\u002B\u002B rclcpp/src/rclcpp/node.cpp\n@@ -23,6 \u002B23,7 @@\n \n #include \u0022rcl/arguments.h\u0022\n \n\u002B#include \u0022rclcpp/create_generic_client.hpp\u0022\n #include \u0022rclcpp/detail/qos_parameters.hpp\u0022\n #include \u0022rclcpp/exceptions.hpp\u0022\n #include \u0022rclcpp/graph_listener.hpp\u0022\n@@ -676,3 \u002B677,20 @@ Node::get_node_options() const\n {\n   return this-\u003Enode_options_;\n }\n\u002B\n\u002Brclcpp::GenericClient::SharedPtr\n\u002BNode::create_generic_client(\n\u002B  const std::string \u0026 service_name,\n\u002B  const std::string \u0026 service_type,\n\u002B  const rclcpp::QoS \u0026 qos,\n\u002B  rclcpp::CallbackGroup::SharedPtr group)\n\u002B{\n\u002B  return rclcpp::create_generic_client(\n\u002B    node_base_,\n\u002B    node_graph_,\n\u002B    node_services_,\n\u002B    service_name,\n\u002B    service_type,\n\u002B    qos,\n\u002B    group);\n\u002B}\ndiff --git rclcpp/test/rclcpp/CMakeLists.txt rclcpp/test/rclcpp/CMakeLists.txt\nindex 0a9ba9ca..c17ed6fe 100644\n--- rclcpp/test/rclcpp/CMakeLists.txt\n\u002B\u002B\u002B rclcpp/test/rclcpp/CMakeLists.txt\n@@ -63,6 \u002B63,28 @@ if(TARGET test_create_timer)\n   target_link_libraries(test_create_timer ${PROJECT_NAME})\n   target_include_directories(test_create_timer PRIVATE ./)\n endif()\n\u002Bament_add_gtest(test_generic_client test_generic_client.cpp)\n\u002Bif(TARGET test_generic_client)\n\u002B  target_link_libraries(test_generic_client ${PROJECT_NAME}\n\u002B    mimick\n\u002B    ${rcl_interfaces_TARGETS}\n\u002B    rmw::rmw\n\u002B    rosidl_runtime_cpp::rosidl_runtime_cpp\n\u002B    rosidl_typesupport_cpp::rosidl_typesupport_cpp\n\u002B    ${test_msgs_TARGETS}\n\u002B  )\n\u002Bendif()\n\u002Bament_add_gtest(test_client_common test_client_common.cpp)\n\u002Bif(TARGET test_client_common)\n\u002B  target_link_libraries(test_client_common ${PROJECT_NAME}\n\u002B    mimick\n\u002B    ${rcl_interfaces_TARGETS}\n\u002B    rmw::rmw\n\u002B    rosidl_runtime_cpp::rosidl_runtime_cpp\n\u002B    rosidl_typesupport_cpp::rosidl_typesupport_cpp\n\u002B    ${test_msgs_TARGETS}\n\u002B  )\n\u002Bendif()\n ament_add_gtest(test_create_subscription test_create_subscription.cpp)\n if(TARGET test_create_subscription)\n   target_link_libraries(test_create_subscription ${PROJECT_NAME} ${test_msgs_TARGETS})\ndiff --git rclcpp/test/rclcpp/test_client.cpp rclcpp/test/rclcpp/test_client.cpp\nindex 9070e1ca..5c7e5046 100644\n--- rclcpp/test/rclcpp/test_client.cpp\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_client.cpp\n@@ -24,12 \u002B24,9 @@\n #include \u0022rcl_interfaces/srv/list_parameters.hpp\u0022\n \n #include \u0022../mocking_utils/patch.hpp\u0022\n-#include \u0022../utils/rclcpp_gtest_macros.hpp\u0022\n \n #include \u0022test_msgs/srv/empty.hpp\u0022\n \n-using namespace std::chrono_literals;\n-\n class TestClient : public ::testing::Test\n {\n protected:\n@@ -219,385 \u002B216,3 @@ TEST_F(TestClientSub, construction_and_destruction) {\n     }, rclcpp::exceptions::InvalidServiceNameError);\n   }\n }\n-\n-class TestClientWithServer : public ::testing::Test\n-{\n-protected:\n-  static void SetUpTestCase()\n-  {\n-    rclcpp::init(0, nullptr);\n-  }\n-\n-  static void TearDownTestCase()\n-  {\n-    rclcpp::shutdown();\n-  }\n-\n-  void SetUp()\n-  {\n-    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022node\u0022, \u0022ns\u0022);\n-\n-    auto callback = [](\n-      const test_msgs::srv::Empty::Request::SharedPtr,\n-      test_msgs::srv::Empty::Response::SharedPtr) {};\n-\n-    service = node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(service_name, std::move(callback));\n-  }\n-\n-  ::testing::AssertionResult SendEmptyRequestAndWait(\n-    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n-  {\n-    using SharedFuture = rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture;\n-\n-    auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-    if (!client-\u003Ewait_for_service()) {\n-      return ::testing::AssertionFailure() \u003C\u003C \u0022Waiting for service failed\u0022;\n-    }\n-\n-    auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-    bool received_response = false;\n-    ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n-    auto callback = [\u0026received_response, \u0026request_result](SharedFuture future_response) {\n-        if (nullptr == future_response.get()) {\n-          request_result = ::testing::AssertionFailure() \u003C\u003C \u0022Future response was null\u0022;\n-        }\n-        received_response = true;\n-      };\n-\n-    auto req_id = client-\u003Easync_send_request(request, std::move(callback));\n-\n-    auto start = std::chrono::steady_clock::now();\n-    while (!received_response \u0026\u0026\n-      (std::chrono::steady_clock::now() - start) \u003C timeout)\n-    {\n-      rclcpp::spin_some(node);\n-    }\n-\n-    if (!received_response) {\n-      return ::testing::AssertionFailure() \u003C\u003C \u0022Waiting for response timed out\u0022;\n-    }\n-    if (client-\u003Eremove_pending_request(req_id)) {\n-      return ::testing::AssertionFailure() \u003C\u003C \u0022Should not be able to remove a finished request\u0022;\n-    }\n-\n-    return request_result;\n-  }\n-\n-  std::shared_ptr\u003Crclcpp::Node\u003E node;\n-  std::shared_ptr\u003Crclcpp::Service\u003Ctest_msgs::srv::Empty\u003E\u003E service;\n-  const std::string service_name{\u0022empty_service\u0022};\n-};\n-\n-TEST_F(TestClientWithServer, async_send_request) {\n-  EXPECT_TRUE(SendEmptyRequestAndWait());\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_callback_with_request) {\n-  using SharedFutureWithRequest =\n-    rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFutureWithRequest;\n-\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-  ASSERT_TRUE(client-\u003Ewait_for_service(std::chrono::seconds(1)));\n-\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  bool received_response = false;\n-  auto callback = [\u0026request, \u0026received_response](SharedFutureWithRequest future) {\n-      auto request_response_pair = future.get();\n-      EXPECT_EQ(request, request_response_pair.first);\n-      EXPECT_NE(nullptr, request_response_pair.second);\n-      received_response = true;\n-    };\n-  auto req_id = client-\u003Easync_send_request(request, std::move(callback));\n-\n-  auto start = std::chrono::steady_clock::now();\n-  while (!received_response \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C std::chrono::seconds(1))\n-  {\n-    rclcpp::spin_some(node);\n-  }\n-  EXPECT_TRUE(received_response);\n-  EXPECT_FALSE(client-\u003Eremove_pending_request(req_id));\n-}\n-\n-TEST_F(TestClientWithServer, test_client_remove_pending_request) {\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022no_service_server_available_here\u0022);\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  auto future = client-\u003Easync_send_request(request);\n-\n-  EXPECT_TRUE(client-\u003Eremove_pending_request(future));\n-}\n-\n-TEST_F(TestClientWithServer, prune_requests_older_than_no_pruned) {\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  auto future = client-\u003Easync_send_request(request);\n-  auto time = std::chrono::system_clock::now() \u002B 1s;\n-\n-  EXPECT_EQ(1u, client-\u003Eprune_requests_older_than(time));\n-}\n-\n-TEST_F(TestClientWithServer, prune_requests_older_than_with_pruned) {\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  auto future = client-\u003Easync_send_request(request);\n-  auto time = std::chrono::system_clock::now() \u002B 1s;\n-\n-  std::vector\u003Cint64_t\u003E pruned_requests;\n-  EXPECT_EQ(1u, client-\u003Eprune_requests_older_than(time, \u0026pruned_requests));\n-  ASSERT_EQ(1u, pruned_requests.size());\n-  EXPECT_EQ(future.request_id, pruned_requests[0]);\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_rcl_send_request_error) {\n-  // Checking rcl_send_request in rclcpp::Client::async_send_request()\n-  auto mock = mocking_utils::patch_and_return(\u0022lib:rclcpp\u0022, rcl_send_request, RCL_RET_ERROR);\n-  EXPECT_THROW(SendEmptyRequestAndWait(), rclcpp::exceptions::RCLError);\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_rcl_service_server_is_available_error) {\n-  {\n-    // Checking rcl_service_server_is_available in rclcpp::ClientBase::service_is_ready\n-    auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_NODE_INVALID);\n-    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-  {\n-    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n-    auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_ERROR);\n-    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-  {\n-    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n-    auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_ERROR);\n-    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-}\n-\n-TEST_F(TestClientWithServer, take_response) {\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n-  ASSERT_TRUE(client-\u003Ewait_for_service(std::chrono::seconds(1)));\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  auto request_header = client-\u003Ecreate_request_header();\n-  test_msgs::srv::Empty::Response response;\n-\n-  client-\u003Easync_send_request(request);\n-  EXPECT_FALSE(client-\u003Etake_response(response, *request_header.get()));\n-\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_OK);\n-    EXPECT_TRUE(client-\u003Etake_response(response, *request_header.get()));\n-  }\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_CLIENT_TAKE_FAILED);\n-    EXPECT_FALSE(client-\u003Etake_response(response, *request_header.get()));\n-  }\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_ERROR);\n-    EXPECT_THROW(\n-      client-\u003Etake_response(response, *request_header.get()),\n-      rclcpp::exceptions::RCLError);\n-  }\n-}\n-\n-/*\n-   Testing on_new_response callbacks.\n- */\n-TEST_F(TestClient, on_new_response_callback) {\n-  auto client_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022client_node\u0022, \u0022ns\u0022);\n-  auto server_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022server_node\u0022, \u0022ns\u0022);\n-\n-  rclcpp::ServicesQoS client_qos;\n-  client_qos.keep_last(3);\n-  auto client = client_node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022test_service\u0022, client_qos);\n-  std::atomic\u003Csize_t\u003E server_requests_count {0};\n-  auto server_callback = [\u0026server_requests_count](\n-    const test_msgs::srv::Empty::Request::SharedPtr,\n-    test_msgs::srv::Empty::Response::SharedPtr) {server_requests_count\u002B\u002B;};\n-  auto server = server_node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n-    \u0022test_service\u0022, server_callback, client_qos);\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-\n-  std::atomic\u003Csize_t\u003E c1 {0};\n-  auto increase_c1_cb = [\u0026c1](size_t count_msgs) {c1 \u002B= count_msgs;};\n-  client-\u003Eset_on_new_response_callback(increase_c1_cb);\n-\n-  client-\u003Easync_send_request(request);\n-  auto start = std::chrono::steady_clock::now();\n-  while (server_requests_count == 0 \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 1u);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c1 == 0 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-\n-  std::atomic\u003Csize_t\u003E c2 {0};\n-  auto increase_c2_cb = [\u0026c2](size_t count_msgs) {c2 \u002B= count_msgs;};\n-  client-\u003Eset_on_new_response_callback(increase_c2_cb);\n-\n-  client-\u003Easync_send_request(request);\n-  start = std::chrono::steady_clock::now();\n-  while (server_requests_count == 1 \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 2u);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c1 == 0 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-  EXPECT_EQ(c2.load(), 1u);\n-\n-  client-\u003Eclear_on_new_response_callback();\n-\n-  client-\u003Easync_send_request(request);\n-  client-\u003Easync_send_request(request);\n-  client-\u003Easync_send_request(request);\n-  start = std::chrono::steady_clock::now();\n-  while (server_requests_count \u003C 5 \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 5u);\n-\n-  std::atomic\u003Csize_t\u003E c3 {0};\n-  auto increase_c3_cb = [\u0026c3](size_t count_msgs) {c3 \u002B= count_msgs;};\n-  client-\u003Eset_on_new_response_callback(increase_c3_cb);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c3 \u003C 3 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-  EXPECT_EQ(c2.load(), 1u);\n-  EXPECT_EQ(c3.load(), 3u);\n-\n-  std::function\u003Cvoid(size_t)\u003E invalid_cb = nullptr;\n-  EXPECT_THROW(client-\u003Eset_on_new_response_callback(invalid_cb), std::invalid_argument);\n-}\n-\n-TEST_F(TestClient, rcl_client_request_publisher_get_actual_qos_error) {\n-  auto mock = mocking_utils::patch_and_return(\n-    \u0022lib:rclcpp\u0022, rcl_client_request_publisher_get_actual_qos, nullptr);\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022service\u0022);\n-  RCLCPP_EXPECT_THROW_EQ(\n-    client-\u003Eget_request_publisher_actual_qos(),\n-    std::runtime_error(\u0022failed to get client\u0027s request publisher qos settings: error not set\u0022));\n-}\n-\n-TEST_F(TestClient, rcl_client_response_subscription_get_actual_qos_error) {\n-  auto mock = mocking_utils::patch_and_return(\n-    \u0022lib:rclcpp\u0022, rcl_client_response_subscription_get_actual_qos, nullptr);\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022service\u0022);\n-  RCLCPP_EXPECT_THROW_EQ(\n-    client-\u003Eget_response_subscription_actual_qos(),\n-    std::runtime_error(\u0022failed to get client\u0027s response subscription qos settings: error not set\u0022));\n-}\n-\n-TEST_F(TestClient, client_qos) {\n-  rclcpp::ServicesQoS qos_profile;\n-  qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n-  qos_profile.deadline(duration);\n-  qos_profile.lifespan(duration);\n-  qos_profile.liveliness_lease_duration(duration);\n-\n-  auto client =\n-    node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022client\u0022, qos_profile);\n-\n-  auto rp_qos = client-\u003Eget_request_publisher_actual_qos();\n-  auto rs_qos = client-\u003Eget_response_subscription_actual_qos();\n-\n-  EXPECT_EQ(qos_profile, rp_qos);\n-  // Lifespan has no meaning for subscription/readers\n-  rs_qos.lifespan(qos_profile.lifespan());\n-  EXPECT_EQ(qos_profile, rs_qos);\n-}\n-\n-TEST_F(TestClient, client_qos_depth) {\n-  using namespace std::literals::chrono_literals;\n-\n-  rclcpp::ServicesQoS client_qos_profile;\n-  client_qos_profile.keep_last(2);\n-\n-  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022test_qos_depth\u0022, client_qos_profile);\n-\n-  uint64_t server_cb_count_ = 0;\n-  auto server_callback = [\u0026](\n-    const test_msgs::srv::Empty::Request::SharedPtr,\n-    test_msgs::srv::Empty::Response::SharedPtr) {server_cb_count_\u002B\u002B;};\n-\n-  auto server_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022server_node\u0022, \u0022/ns\u0022);\n-\n-  rclcpp::QoS server_qos(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));\n-\n-  auto server = server_node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n-    \u0022test_qos_depth\u0022, std::move(server_callback), server_qos);\n-\n-  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n-  ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n-\n-  using SharedFuture = rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture;\n-  uint64_t client_cb_count_ = 0;\n-  auto client_callback = [\u0026client_cb_count_, \u0026request_result](SharedFuture future_response) {\n-      if (nullptr == future_response.get()) {\n-        request_result = ::testing::AssertionFailure() \u003C\u003C \u0022Future response was null\u0022;\n-      }\n-      client_cb_count_\u002B\u002B;\n-    };\n-\n-  uint64_t client_requests = 5;\n-  for (uint64_t i = 0; i \u003C client_requests; i\u002B\u002B) {\n-    client-\u003Easync_send_request(request, client_callback);\n-    std::this_thread::sleep_for(10ms);\n-  }\n-\n-  auto start = std::chrono::steady_clock::now();\n-  while ((server_cb_count_ \u003C client_requests) \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C 2s)\n-  {\n-    rclcpp::spin_some(server_node);\n-    std::this_thread::sleep_for(2ms);\n-  }\n-\n-  EXPECT_GT(server_cb_count_, client_qos_profile.depth());\n-\n-  start = std::chrono::steady_clock::now();\n-  while ((client_cb_count_ \u003C client_qos_profile.depth()) \u0026\u0026\n-    (std::chrono::steady_clock::now() - start) \u003C 1s)\n-  {\n-    rclcpp::spin_some(node);\n-  }\n-\n-  // Spin an extra time to check if client QoS depth has been ignored,\n-  // so more client callbacks might be called than expected.\n-  rclcpp::spin_some(node);\n-\n-  EXPECT_EQ(client_cb_count_, client_qos_profile.depth());\n-}\ndiff --git rclcpp/test/rclcpp/test_client_common.cpp rclcpp/test/rclcpp/test_client_common.cpp\nnew file mode 100644\nindex 00000000..65475bd8\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_client_common.cpp\n@@ -0,0 \u002B1,591 @@\n\u002B// Copyright 2024 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B#include \u0022../utils/rclcpp_gtest_macros.hpp\u0022\n\u002B\n\u002B#include \u0022rclcpp/create_generic_client.hpp\u0022\n\u002B#include \u0022rclcpp/exceptions.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B\n\u002B#include \u0022test_msgs/srv/empty.hpp\u0022\n\u002B\n\u002Btemplate\u003Ctypename T\u003E\n\u002Bclass TestAllClientTypesWithServer : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void SetUp()\n\u002B  {\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, \u0022ns\u0022);\n\u002B\n\u002B    auto callback = [](\n\u002B      const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B      test_msgs::srv::Empty::Response::SharedPtr) {};\n\u002B\n\u002B    service = node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(service_name, std::move(callback));\n\u002B  }\n\u002B\n\u002B  template\u003Ctypename ClientType\u003E\n\u002B  auto SendEmptyRequestAndWait(\n\u002B    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n\u002B  {\n\u002B    if constexpr (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B      return GenericClientSendEmptyRequestAndWait(timeout);\n\u002B    } else if constexpr (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B      return ClientSendEmptyRequestAndWait(timeout);\n\u002B    } else {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022No test for this client type\u0022;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  ::testing::AssertionResult GenericClientSendEmptyRequestAndWait(\n\u002B    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n\u002B  {\n\u002B    auto client = node-\u003Ecreate_generic_client(service_name, \u0022test_msgs/srv/Empty\u0022);\n\u002B    if (!client-\u003Ewait_for_service()) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Service is not available yet\u0022;\n\u002B    }\n\u002B\n\u002B    auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B\n\u002B    auto future_and_req_id = client-\u003Easync_send_request(request.get());\n\u002B\n\u002B    auto ret = rclcpp::spin_until_future_complete(node, future_and_req_id, timeout);\n\u002B    if (ret != rclcpp::FutureReturnCode::SUCCESS) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Waiting for response timed out\u0022;\n\u002B    }\n\u002B\n\u002B    if (client-\u003Eremove_pending_request(future_and_req_id.request_id)) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Should not be able to remove a finished request\u0022;\n\u002B    }\n\u002B\n\u002B    return ::testing::AssertionSuccess();\n\u002B  }\n\u002B\n\u002B  ::testing::AssertionResult ClientSendEmptyRequestAndWait(\n\u002B    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n\u002B  {\n\u002B    using SharedFuture = rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture;\n\u002B\n\u002B    auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n\u002B    if (!client-\u003Ewait_for_service()) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Waiting for service failed\u0022;\n\u002B    }\n\u002B\n\u002B    auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B    bool received_response = false;\n\u002B    ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n\u002B    auto callback = [\u0026received_response, \u0026request_result](SharedFuture future_response) {\n\u002B        if (nullptr == future_response.get()) {\n\u002B          request_result = ::testing::AssertionFailure() \u003C\u003C \u0022Future response was null\u0022;\n\u002B        }\n\u002B        received_response = true;\n\u002B      };\n\u002B\n\u002B    auto req_id = client-\u003Easync_send_request(request, std::move(callback));\n\u002B\n\u002B    auto start = std::chrono::steady_clock::now();\n\u002B    while (!received_response \u0026\u0026\n\u002B      (std::chrono::steady_clock::now() - start) \u003C timeout)\n\u002B    {\n\u002B      rclcpp::spin_some(node);\n\u002B    }\n\u002B\n\u002B    if (!received_response) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Waiting for response timed out\u0022;\n\u002B    }\n\u002B    if (client-\u003Eremove_pending_request(req_id)) {\n\u002B      return ::testing::AssertionFailure() \u003C\u003C \u0022Should not be able to remove a finished request\u0022;\n\u002B    }\n\u002B\n\u002B    return request_result;\n\u002B  }\n\u002B\n\u002B  template\u003Ctypename ClientType\u003E\n\u002B  auto create_client(\n\u002B    rclcpp::Node::SharedPtr node,\n\u002B    const std::string service_name = \u0022empty_service\u0022,\n\u002B    const rclcpp::QoS \u0026 qos = rclcpp::ServicesQoS())\n\u002B  {\n\u002B    if constexpr (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B      return node-\u003Ecreate_generic_client(service_name, \u0022test_msgs/srv/Empty\u0022, qos);\n\u002B    } else if constexpr (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B      return node-\u003Etemplate create_client\u003Ctest_msgs::srv::Empty\u003E(service_name, qos);\n\u002B    } else {\n\u002B      ASSERT_TRUE(false) \u003C\u003C \u0022Not know how to create this kind of client\u0022;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  template\u003Ctypename ClientType, typename RequestType\u003E\n\u002B  auto async_send_request(std::shared_ptr\u003CClientType\u003E client, std::shared_ptr\u003CRequestType\u003E request)\n\u002B  {\n\u002B    if constexpr (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B      return client-\u003Easync_send_request(request.get());\n\u002B    } else if constexpr (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B      return client-\u003Easync_send_request(request);\n\u002B    } else {\n\u002B      ASSERT_TRUE(false) \u003C\u003C \u0022Not know how to send request for this kind of client\u0022;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  template\u003Ctypename ClientType, typename ResponseType\u003E\n\u002B  auto take_response(\n\u002B    std::shared_ptr\u003CClientType\u003E client,\n\u002B    ResponseType \u0026 response,\n\u002B    std::shared_ptr\u003Crmw_request_id_t\u003E request_header)\n\u002B  {\n\u002B    if constexpr (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B      return client-\u003Etake_response(static_cast\u003Cvoid *\u003E(\u0026response), *request_header.get());\n\u002B    } else if constexpr (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B      return client-\u003Etake_response(response, *request_header.get());\n\u002B    } else {\n\u002B      ASSERT_TRUE(false) \u003C\u003C \u0022Not know how to take response for this kind of client\u0022;\n\u002B    }\n\u002B  }\n\u002B\n\u002B  std::shared_ptr\u003Crclcpp::Node\u003E node;\n\u002B  std::shared_ptr\u003Crclcpp::Service\u003Ctest_msgs::srv::Empty\u003E\u003E service;\n\u002B  const std::string service_name{\u0022empty_service\u0022};\n\u002B};\n\u002B\n\u002Busing ClientType =\n\u002B  ::testing::Types\u003C\n\u002B  rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E,\n\u002B  rclcpp::GenericClient\u003E;\n\u002B\n\u002Bclass ClientTypeNames\n\u002B{\n\u002Bpublic:\n\u002B  template\u003Ctypename T\u003E\n\u002B  static std::string GetName(int idx)\n\u002B  {\n\u002B    (void)idx;\n\u002B    if (std::is_same_v\u003CT, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B      return \u0022Client\u0022;\n\u002B    }\n\u002B\n\u002B    if (std::is_same_v\u003CT, rclcpp::GenericClient\u003E) {\n\u002B      return \u0022GenericClient\u0022;\n\u002B    }\n\u002B\n\u002B    return \u0022\u0022;\n\u002B  }\n\u002B};\n\u002B\n\u002BTYPED_TEST_SUITE(TestAllClientTypesWithServer, ClientType, ClientTypeNames);\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, async_send_request)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B  EXPECT_TRUE(this-\u003Etemplate SendEmptyRequestAndWait\u003CClientType\u003E());\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, test_client_remove_pending_request)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B\n\u002B  auto future_and_req_id = this-\u003Etemplate async_send_request\u003C\n\u002B    ClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B\n\u002B  EXPECT_TRUE(client-\u003Eremove_pending_request(future_and_req_id.request_id));\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, prune_requests_older_than_no_pruned)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B\n\u002B  auto future = this-\u003Etemplate async_send_request\u003C\n\u002B    ClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  auto time = std::chrono::system_clock::now() \u002B std::chrono::seconds(1);\n\u002B\n\u002B  EXPECT_EQ(1u, client-\u003Eprune_requests_older_than(time));\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, prune_requests_older_than_with_pruned)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B\n\u002B  auto future = this-\u003Etemplate async_send_request\u003C\n\u002B    ClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  auto time = std::chrono::system_clock::now() \u002B std::chrono::seconds(1);\n\u002B\n\u002B  std::vector\u003Cint64_t\u003E pruned_requests;\n\u002B  EXPECT_EQ(1u, client-\u003Eprune_requests_older_than(time, \u0026pruned_requests));\n\u002B  ASSERT_EQ(1u, pruned_requests.size());\n\u002B  EXPECT_EQ(future.request_id, pruned_requests[0]);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, async_send_request_rcl_send_request_error)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  // Checking rcl_send_request in rclcpp::Client::async_send_request() or\n\u002B  // rclcpp::GenericClient::async_send_request()\n\u002B  auto mock = mocking_utils::patch_and_return(\u0022lib:rclcpp\u0022, rcl_send_request, RCL_RET_ERROR);\n\u002B  EXPECT_THROW(this-\u003Etemplate SendEmptyRequestAndWait\u003CClientType\u003E(), rclcpp::exceptions::RCLError);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, async_send_request_rcl_service_server_is_available_error)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  {\n\u002B    // Checking rcl_service_server_is_available in rclcpp::ClientBase::service_is_ready\n\u002B    auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_NODE_INVALID);\n\u002B    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B  {\n\u002B    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n\u002B    auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_ERROR);\n\u002B    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B  {\n\u002B    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n\u002B    auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_service_server_is_available, RCL_RET_ERROR);\n\u002B    EXPECT_THROW(client-\u003Eservice_is_ready(), rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, take_response)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode);\n\u002B  ASSERT_TRUE(client-\u003Ewait_for_service(std::chrono::seconds(1)));\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B  auto request_header = client-\u003Ecreate_request_header();\n\u002B  test_msgs::srv::Empty::Response response;\n\u002B\n\u002B  this-\u003Etemplate async_send_request\u003C\n\u002B    ClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B\n\u002B  EXPECT_FALSE(this-\u003Etake_response(client, response, request_header));\n\u002B\n\u002B  {\n\u002B    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_OK);\n\u002B    EXPECT_TRUE(this-\u003Etake_response(client, response, request_header));\n\u002B  }\n\u002B  {\n\u002B    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_CLIENT_TAKE_FAILED);\n\u002B    EXPECT_FALSE(this-\u003Etake_response(client, response, request_header));\n\u002B  }\n\u002B  {\n\u002B    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n\u002B    auto mock = mocking_utils::patch_and_return(\n\u002B      \u0022lib:rclcpp\u0022, rcl_take_response, RCL_RET_ERROR);\n\u002B    EXPECT_THROW(\n\u002B      this-\u003Etake_response(client, response, request_header),\n\u002B      rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B}\n\u002B\n\u002B/*\n\u002B   Testing on_new_response callbacks.\n\u002B */\n\u002BTYPED_TEST(TestAllClientTypesWithServer, on_new_response_callback)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto client_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_client_node\u0022, \u0022ns\u0022);\n\u002B  auto server_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_server_node\u0022, \u0022ns\u0022);\n\u002B\n\u002B  rclcpp::ServicesQoS client_qos;\n\u002B  client_qos.keep_last(3);\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(client_node, \u0022test_service\u0022, client_qos);\n\u002B\n\u002B  std::atomic\u003Csize_t\u003E server_requests_count {0};\n\u002B  auto server_callback = [\u0026server_requests_count](\n\u002B    const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B    test_msgs::srv::Empty::Response::SharedPtr) {server_requests_count\u002B\u002B;};\n\u002B  auto server = server_node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n\u002B    \u0022test_service\u0022, server_callback, client_qos);\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B\n\u002B  std::atomic\u003Csize_t\u003E c1 {0};\n\u002B  auto increase_c1_cb = [\u0026c1](size_t count_msgs) {c1 \u002B= count_msgs;};\n\u002B  client-\u003Eset_on_new_response_callback(increase_c1_cb);\n\u002B\n\u002B  this-\u003Etemplate async_send_request\u003CClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  while (server_requests_count == 0 \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C std::chrono::seconds(10))\n\u002B  {\n\u002B    rclcpp::spin_some(server_node);\n\u002B  }\n\u002B\n\u002B  ASSERT_EQ(server_requests_count, 1u);\n\u002B\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  do {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B  } while (c1 == 0 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C std::chrono::seconds(10));\n\u002B\n\u002B  EXPECT_EQ(c1.load(), 1u);\n\u002B\n\u002B  std::atomic\u003Csize_t\u003E c2 {0};\n\u002B  auto increase_c2_cb = [\u0026c2](size_t count_msgs) {c2 \u002B= count_msgs;};\n\u002B  client-\u003Eset_on_new_response_callback(increase_c2_cb);\n\u002B\n\u002B  this-\u003Etemplate async_send_request\u003CClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  while (server_requests_count == 1 \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C std::chrono::seconds(10))\n\u002B  {\n\u002B    rclcpp::spin_some(server_node);\n\u002B  }\n\u002B\n\u002B  ASSERT_EQ(server_requests_count, 2u);\n\u002B\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  do {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B  } while (c1 == 0 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C std::chrono::seconds(10));\n\u002B\n\u002B  EXPECT_EQ(c1.load(), 1u);\n\u002B  EXPECT_EQ(c2.load(), 1u);\n\u002B\n\u002B  client-\u003Eclear_on_new_response_callback();\n\u002B\n\u002B  this-\u003Etemplate async_send_request\u003CClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  this-\u003Etemplate async_send_request\u003CClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  this-\u003Etemplate async_send_request\u003CClientType, test_msgs::srv::Empty::Request\u003E(client, request);\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  while (server_requests_count \u003C 5 \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C std::chrono::seconds(10))\n\u002B  {\n\u002B    rclcpp::spin_some(server_node);\n\u002B  }\n\u002B\n\u002B  ASSERT_EQ(server_requests_count, 5u);\n\u002B\n\u002B  std::atomic\u003Csize_t\u003E c3 {0};\n\u002B  auto increase_c3_cb = [\u0026c3](size_t count_msgs) {c3 \u002B= count_msgs;};\n\u002B  client-\u003Eset_on_new_response_callback(increase_c3_cb);\n\u002B\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  do {\n\u002B    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n\u002B  } while (c3 \u003C 3 \u0026\u0026 std::chrono::steady_clock::now() - start \u003C std::chrono::seconds(10));\n\u002B\n\u002B  EXPECT_EQ(c1.load(), 1u);\n\u002B  EXPECT_EQ(c2.load(), 1u);\n\u002B  EXPECT_EQ(c3.load(), 3u);\n\u002B\n\u002B  std::function\u003Cvoid(size_t)\u003E invalid_cb = nullptr;\n\u002B  EXPECT_THROW(client-\u003Eset_on_new_response_callback(invalid_cb), std::invalid_argument);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, client_qos)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  rclcpp::ServicesQoS qos_profile;\n\u002B  qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n\u002B  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n\u002B  qos_profile.deadline(duration);\n\u002B  qos_profile.lifespan(duration);\n\u002B  qos_profile.liveliness_lease_duration(duration);\n\u002B\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(\n\u002B    this-\u003Enode, this-\u003Eservice_name, qos_profile);\n\u002B\n\u002B  auto rp_qos = client-\u003Eget_request_publisher_actual_qos();\n\u002B  auto rs_qos = client-\u003Eget_response_subscription_actual_qos();\n\u002B\n\u002B  EXPECT_EQ(qos_profile, rp_qos);\n\u002B  // Lifespan has no meaning for subscription/readers\n\u002B  rs_qos.lifespan(qos_profile.lifespan());\n\u002B  EXPECT_EQ(qos_profile, rs_qos);\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, rcl_client_request_publisher_get_actual_qos_error)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto mock = mocking_utils::patch_and_return(\n\u002B    \u0022lib:rclcpp\u0022, rcl_client_request_publisher_get_actual_qos, nullptr);\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode, \u0022service\u0022);\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    client-\u003Eget_request_publisher_actual_qos(),\n\u002B    std::runtime_error(\u0022failed to get client\u0027s request publisher qos settings: error not set\u0022));\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, rcl_client_response_subscription_get_actual_qos_error)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  auto mock = mocking_utils::patch_and_return(\n\u002B    \u0022lib:rclcpp\u0022, rcl_client_response_subscription_get_actual_qos, nullptr);\n\u002B  auto client = this-\u003Etemplate create_client\u003CClientType\u003E(this-\u003Enode, \u0022service\u0022);\n\u002B  RCLCPP_EXPECT_THROW_EQ(\n\u002B    client-\u003Eget_response_subscription_actual_qos(),\n\u002B    std::runtime_error(\u0022failed to get client\u0027s response subscription qos settings: error not set\u0022));\n\u002B}\n\u002B\n\u002B// The following tests are only for rclcpp::Client\n\u002Bvoid client_async_send_request_callback_with_request(\n\u002B  rclcpp::Node::SharedPtr node, const std::string service_name)\n\u002B{\n\u002B  using SharedFutureWithRequest =\n\u002B    rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFutureWithRequest;\n\u002B\n\u002B  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(service_name);\n\u002B  ASSERT_TRUE(client-\u003Ewait_for_service(std::chrono::seconds(1)));\n\u002B\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B  bool received_response = false;\n\u002B  auto callback = [\u0026request, \u0026received_response](SharedFutureWithRequest future) {\n\u002B      auto request_response_pair = future.get();\n\u002B      EXPECT_EQ(request, request_response_pair.first);\n\u002B      EXPECT_NE(nullptr, request_response_pair.second);\n\u002B      received_response = true;\n\u002B    };\n\u002B  auto req_id = client-\u003Easync_send_request(request, std::move(callback));\n\u002B\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  while (!received_response \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C std::chrono::seconds(1))\n\u002B  {\n\u002B    rclcpp::spin_some(node);\n\u002B  }\n\u002B  EXPECT_TRUE(received_response);\n\u002B  EXPECT_FALSE(client-\u003Eremove_pending_request(req_id));\n\u002B}\n\u002BTYPED_TEST(TestAllClientTypesWithServer, async_send_request_callback_with_request)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  if (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B    client_async_send_request_callback_with_request(this-\u003Enode, this-\u003Eservice_name);\n\u002B  } else if (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B    GTEST_SKIP() \u003C\u003C \u0022Skipping test for GenericClient\u0022;\n\u002B  } else {\n\u002B    GTEST_SKIP() \u003C\u003C \u0022Skipping test\u0022;\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid client_qos_depth(rclcpp::Node::SharedPtr node)\n\u002B{\n\u002B  using namespace std::literals::chrono_literals;\n\u002B\n\u002B  rclcpp::ServicesQoS client_qos_profile;\n\u002B  client_qos_profile.keep_last(2);\n\u002B\n\u002B  auto client = node-\u003Ecreate_client\u003Ctest_msgs::srv::Empty\u003E(\u0022test_qos_depth\u0022, client_qos_profile);\n\u002B\n\u002B  uint64_t server_cb_count_ = 0;\n\u002B  auto server_callback = [\u0026](\n\u002B    const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B    test_msgs::srv::Empty::Response::SharedPtr) {server_cb_count_\u002B\u002B;};\n\u002B\n\u002B  auto server_node = std::make_shared\u003Crclcpp::Node\u003E(\u0022server_node\u0022, \u0022/ns\u0022);\n\u002B\n\u002B  rclcpp::QoS server_qos(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));\n\u002B\n\u002B  auto server = server_node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(\n\u002B    \u0022test_qos_depth\u0022, std::move(server_callback), server_qos);\n\u002B\n\u002B  auto request = std::make_shared\u003Ctest_msgs::srv::Empty::Request\u003E();\n\u002B  ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n\u002B\n\u002B  using SharedFuture = rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E::SharedFuture;\n\u002B  uint64_t client_cb_count_ = 0;\n\u002B  auto client_callback = [\u0026client_cb_count_, \u0026request_result](SharedFuture future_response) {\n\u002B      if (nullptr == future_response.get()) {\n\u002B        request_result = ::testing::AssertionFailure() \u003C\u003C \u0022Future response was null\u0022;\n\u002B      }\n\u002B      client_cb_count_\u002B\u002B;\n\u002B    };\n\u002B\n\u002B  uint64_t client_requests = 5;\n\u002B  for (uint64_t i = 0; i \u003C client_requests; i\u002B\u002B) {\n\u002B    client-\u003Easync_send_request(request, client_callback);\n\u002B    std::this_thread::sleep_for(10ms);\n\u002B  }\n\u002B\n\u002B  auto start = std::chrono::steady_clock::now();\n\u002B  while ((server_cb_count_ \u003C client_requests) \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C 2s)\n\u002B  {\n\u002B    rclcpp::spin_some(server_node);\n\u002B    std::this_thread::sleep_for(2ms);\n\u002B  }\n\u002B\n\u002B  EXPECT_GT(server_cb_count_, client_qos_profile.depth());\n\u002B\n\u002B  start = std::chrono::steady_clock::now();\n\u002B  while ((client_cb_count_ \u003C client_qos_profile.depth()) \u0026\u0026\n\u002B    (std::chrono::steady_clock::now() - start) \u003C 1s)\n\u002B  {\n\u002B    rclcpp::spin_some(node);\n\u002B  }\n\u002B\n\u002B  // Spin an extra time to check if client QoS depth has been ignored,\n\u002B  // so more client callbacks might be called than expected.\n\u002B  rclcpp::spin_some(node);\n\u002B\n\u002B  EXPECT_EQ(client_cb_count_, client_qos_profile.depth());\n\u002B}\n\u002B\n\u002BTYPED_TEST(TestAllClientTypesWithServer, qos_depth)\n\u002B{\n\u002B  using ClientType = TypeParam;\n\u002B\n\u002B  if (std::is_same_v\u003CClientType, rclcpp::Client\u003Ctest_msgs::srv::Empty\u003E\u003E) {\n\u002B    client_qos_depth(this-\u003Enode);\n\u002B  } else if (std::is_same_v\u003CClientType, rclcpp::GenericClient\u003E) {\n\u002B    GTEST_SKIP() \u003C\u003C \u0022Skipping test for GenericClient\u0022;\n\u002B  } else {\n\u002B    GTEST_SKIP() \u003C\u003C \u0022Skipping test\u0022;\n\u002B  }\n\u002B}\ndiff --git rclcpp/test/rclcpp/test_generic_client.cpp rclcpp/test/rclcpp/test_generic_client.cpp\nnew file mode 100644\nindex 00000000..be65ea1f\n--- /dev/null\n\u002B\u002B\u002B rclcpp/test/rclcpp/test_generic_client.cpp\n@@ -0,0 \u002B1,230 @@\n\u002B// Copyright 2023 Sony Group Corporation.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Cgtest/gtest.h\u003E\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cutility\u003E\n\u002B\n\u002B#include \u0022rclcpp/create_generic_client.hpp\u0022\n\u002B#include \u0022rclcpp/exceptions.hpp\u0022\n\u002B#include \u0022rclcpp/rclcpp.hpp\u0022\n\u002B#include \u0022rclcpp/serialization.hpp\u0022\n\u002B\n\u002B#include \u0022rcl_interfaces/srv/list_parameters.hpp\u0022\n\u002B\n\u002B#include \u0022../mocking_utils/patch.hpp\u0022\n\u002B\n\u002B#include \u0022test_msgs/srv/empty.hpp\u0022\n\u002B\n\u002Busing namespace std::chrono_literals;\n\u002B\n\u002B// All tests are from test_client\n\u002B\n\u002Bclass TestGenericClient : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void SetUp()\n\u002B  {\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, \u0022/ns\u0022);\n\u002B  }\n\u002B\n\u002B  void TearDown()\n\u002B  {\n\u002B    node.reset();\n\u002B  }\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B};\n\u002B\n\u002Bclass TestGenericClientSub : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  static void SetUpTestCase()\n\u002B  {\n\u002B    rclcpp::init(0, nullptr);\n\u002B  }\n\u002B\n\u002B  static void TearDownTestCase()\n\u002B  {\n\u002B    rclcpp::shutdown();\n\u002B  }\n\u002B\n\u002B  void SetUp()\n\u002B  {\n\u002B    node = std::make_shared\u003Crclcpp::Node\u003E(\u0022test_node\u0022, \u0022/ns\u0022);\n\u002B    subnode = node-\u003Ecreate_sub_node(\u0022sub_ns\u0022);\n\u002B  }\n\u002B  void TearDown()\n\u002B  {\n\u002B    node.reset();\n\u002B  }\n\u002B\n\u002B  rclcpp::Node::SharedPtr node;\n\u002B  rclcpp::Node::SharedPtr subnode;\n\u002B};\n\u002B\n\u002B/*\n\u002B   Testing client construction and destruction.\n\u002B */\n\u002BTEST_F(TestGenericClient, construction_and_destruction) {\n\u002B  {\n\u002B    auto client = node-\u003Ecreate_generic_client(\u0022test_service\u0022, \u0022test_msgs/srv/Empty\u0022);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = node-\u003Ecreate_generic_client(\u0022invalid_test_service?\u0022, \u0022test_msgs/srv/Empty\u0022);\n\u002B    }, rclcpp::exceptions::InvalidServiceNameError);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = node-\u003Ecreate_generic_client(\u0022test_service\u0022, \u0022test_msgs/srv/InvalidType\u0022);\n\u002B    }, std::runtime_error);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestGenericClient, construction_with_free_function) {\n\u002B  {\n\u002B    auto client = rclcpp::create_generic_client(\n\u002B      node-\u003Eget_node_base_interface(),\n\u002B      node-\u003Eget_node_graph_interface(),\n\u002B      node-\u003Eget_node_services_interface(),\n\u002B      \u0022test_service\u0022,\n\u002B      \u0022test_msgs/srv/Empty\u0022,\n\u002B      rclcpp::ServicesQoS(),\n\u002B      nullptr);\n\u002B  }\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = rclcpp::create_generic_client(\n\u002B        node-\u003Eget_node_base_interface(),\n\u002B        node-\u003Eget_node_graph_interface(),\n\u002B        node-\u003Eget_node_services_interface(),\n\u002B        \u0022invalid_?test_service\u0022,\n\u002B        \u0022test_msgs/srv/Empty\u0022,\n\u002B        rclcpp::ServicesQoS(),\n\u002B        nullptr);\n\u002B    }, rclcpp::exceptions::InvalidServiceNameError);\n\u002B  }\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = rclcpp::create_generic_client(\n\u002B        node-\u003Eget_node_base_interface(),\n\u002B        node-\u003Eget_node_graph_interface(),\n\u002B        node-\u003Eget_node_services_interface(),\n\u002B        \u0022test_service\u0022,\n\u002B        \u0022test_msgs/srv/InvalidType\u0022,\n\u002B        rclcpp::ServicesQoS(),\n\u002B        nullptr);\n\u002B    }, std::runtime_error);\n\u002B  }\n\u002B  {\n\u002B    auto client = rclcpp::create_generic_client(\n\u002B      node,\n\u002B      \u0022test_service\u0022,\n\u002B      \u0022test_msgs/srv/Empty\u0022,\n\u002B      rclcpp::ServicesQoS(),\n\u002B      nullptr);\n\u002B  }\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = rclcpp::create_generic_client(\n\u002B        node,\n\u002B        \u0022invalid_?test_service\u0022,\n\u002B        \u0022test_msgs/srv/Empty\u0022,\n\u002B        rclcpp::ServicesQoS(),\n\u002B        nullptr);\n\u002B    }, rclcpp::exceptions::InvalidServiceNameError);\n\u002B  }\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = rclcpp::create_generic_client(\n\u002B        node,\n\u002B        \u0022invalid_?test_service\u0022,\n\u002B        \u0022test_msgs/srv/InvalidType\u0022,\n\u002B        rclcpp::ServicesQoS(),\n\u002B        nullptr);\n\u002B    }, std::runtime_error);\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestGenericClient, construct_with_rcl_error) {\n\u002B  {\n\u002B    // reset() is not necessary for this exception, but handles unused return value warning\n\u002B    auto mock = mocking_utils::patch_and_return(\u0022lib:rclcpp\u0022, rcl_client_init, RCL_RET_ERROR);\n\u002B    EXPECT_THROW(\n\u002B      node-\u003Ecreate_generic_client(\u0022test_service\u0022, \u0022test_msgs/srv/Empty\u0022).reset(),\n\u002B      rclcpp::exceptions::RCLError);\n\u002B  }\n\u002B  {\n\u002B    // reset() is required for this one\n\u002B    auto mock = mocking_utils::patch_and_return(\u0022lib:rclcpp\u0022, rcl_client_fini, RCL_RET_ERROR);\n\u002B    EXPECT_NO_THROW(\n\u002B      node-\u003Ecreate_generic_client(\u0022test_service\u0022, \u0022test_msgs/srv/Empty\u0022).reset());\n\u002B  }\n\u002B}\n\u002B\n\u002BTEST_F(TestGenericClient, wait_for_service) {\n\u002B  const std::string service_name = \u0022test_service\u0022;\n\u002B\n\u002B  auto client = node-\u003Ecreate_generic_client(service_name, \u0022test_msgs/srv/Empty\u0022);\n\u002B  EXPECT_FALSE(client-\u003Ewait_for_service(std::chrono::nanoseconds(0)));\n\u002B  EXPECT_FALSE(client-\u003Ewait_for_service(std::chrono::milliseconds(10)));\n\u002B\n\u002B  auto callback = [](\n\u002B    const test_msgs::srv::Empty::Request::SharedPtr,\n\u002B    test_msgs::srv::Empty::Response::SharedPtr) {};\n\u002B\n\u002B  auto service =\n\u002B    node-\u003Ecreate_service\u003Ctest_msgs::srv::Empty\u003E(service_name, std::move(callback));\n\u002B\n\u002B  EXPECT_TRUE(client-\u003Ewait_for_service(std::chrono::nanoseconds(-1)));\n\u002B  EXPECT_TRUE(client-\u003Eservice_is_ready());\n\u002B}\n\u002B\n\u002B/*\n\u002B   Testing generic client construction and destruction for subnodes.\n\u002B */\n\u002BTEST_F(TestGenericClientSub, construction_and_destruction) {\n\u002B  {\n\u002B    auto client = subnode-\u003Ecreate_generic_client(\u0022test_service\u0022, \u0022test_msgs/srv/Empty\u0022);\n\u002B    EXPECT_STREQ(client-\u003Eget_service_name(), \u0022/ns/test_service\u0022);\n\u002B  }\n\u002B\n\u002B  {\n\u002B    ASSERT_THROW(\n\u002B    {\n\u002B      auto client = node-\u003Ecreate_generic_client(\u0022invalid_service?\u0022, \u0022test_msgs/srv/Empty\u0022);\n\u002B    }, rclcpp::exceptions::InvalidServiceNameError);\n\u002B  }\n\u002B}\n",
    "IsBackported": false
  },
  {
    "Repository": "geometry2",
    "SHA": "fdc32090c007a4500e1ac0cec6a09ffe45af2341",
    "RawMessage": "fix accessing freed resources (#386)",
    "Changes": "diff --git tf2_ros/include/tf2_ros/message_filter.h tf2_ros/include/tf2_ros/message_filter.h\nindex 9c92828b..a8b744b9 100644\n--- tf2_ros/include/tf2_ros/message_filter.h\n\u002B\u002B\u002B tf2_ros/include/tf2_ros/message_filter.h\n@@ -482,10 \u002B482,6 @@ private:\n   {\n     namespace mt = message_filters::message_traits;\n \n-    // find the message this request is associated with\n-    typename L_MessageInfo::iterator msg_it = messages_.begin();\n-    typename L_MessageInfo::iterator msg_end = messages_.end();\n-\n     MEvent saved_event;\n     bool event_found = false;\n \n@@ -493,6 \u002B489,10 @@ private:\n       // We will be accessing and mutating messages now, require unique lock\n       std::unique_lock\u003Cstd::mutex\u003E lock(messages_mutex_);\n \n\u002B      // find the message this request is associated with\n\u002B      typename L_MessageInfo::iterator msg_it = messages_.begin();\n\u002B      typename L_MessageInfo::iterator msg_end = messages_.end();\n\u002B\n       for (; msg_it != msg_end; \u002B\u002Bmsg_it) {\n         MessageInfo \u0026 info = *msg_it;\n         auto handle_it = std::find(info.handles.begin(), info.handles.end(), handle);\n",
    "IsBackported": false
  },
  {
    "Repository": "ros2cli",
    "SHA": "41b5073db20d3cbe9efa754d26e6ab5b2e3c10e2",
    "RawMessage": "Add ros2 service info (#771)",
    "Changes": "diff --git ros2cli/ros2cli/daemon/__init__.py ros2cli/ros2cli/daemon/__init__.py\nindex 38a2fe5..d885e6a 100644\n--- ros2cli/ros2cli/daemon/__init__.py\n\u002B\u002B\u002B ros2cli/ros2cli/daemon/__init__.py\n@@ -95,7 \u002B95,9 @@ def serve(server, *, timeout=2 * 60 * 60):\n                 bind(rclpy.action.get_action_server_names_and_types_by_node, node),\n                 bind(rclpy.action.get_action_client_names_and_types_by_node, node),\n                 node.count_publishers,\n-                node.count_subscribers\n\u002B                node.count_subscribers,\n\u002B                node.count_clients,\n\u002B                node.count_services\n             ]\n \n             server.register_introspection_functions()\ndiff --git ros2cli/test/test_daemon.py ros2cli/test/test_daemon.py\nindex e94218d..ce05b1c 100644\n--- ros2cli/test/test_daemon.py\n\u002B\u002B\u002B ros2cli/test/test_daemon.py\n@@ -237,3 \u002B237,11 @@ def test_count_publishers(daemon_node):\n \n def test_count_subscribers(daemon_node):\n     assert 1 == daemon_node.count_subscribers(TEST_TOPIC_NAME)\n\u002B\n\u002B\n\u002Bdef test_count_clients(daemon_node):\n\u002B    assert 1 == daemon_node.count_clients(TEST_SERVICE_NAME)\n\u002B\n\u002B\n\u002Bdef test_count_services(daemon_node):\n\u002B    assert 1 == daemon_node.count_services(TEST_SERVICE_NAME)\ndiff --git ros2service/ros2service/verb/info.py ros2service/ros2service/verb/info.py\nnew file mode 100644\nindex 0000000..f640fd7\n--- /dev/null\n\u002B\u002B\u002B ros2service/ros2service/verb/info.py\n@@ -0,0 \u002B1,54 @@\n\u002B# Copyright 2022 CLOBOT Co., Ltd.\n\u002B#\n\u002B# Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B# you may not use this file except in compliance with the License.\n\u002B# You may obtain a copy of the License at\n\u002B#\n\u002B#     http://www.apache.org/licenses/LICENSE-2.0\n\u002B#\n\u002B# Unless required by applicable law or agreed to in writing, software\n\u002B# distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B# See the License for the specific language governing permissions and\n\u002B# limitations under the License.\n\u002B\n\u002Bfrom ros2cli.node.strategy import add_arguments as add_strategy_node_arguments\n\u002Bfrom ros2cli.node.strategy import NodeStrategy\n\u002Bfrom ros2service.api import get_service_names_and_types\n\u002Bfrom ros2service.api import ServiceNameCompleter\n\u002Bfrom ros2topic.verb import VerbExtension\n\u002B\n\u002B\n\u002Bclass InfoVerb(VerbExtension):\n\u002B    \u0022\u0022\u0022Print information about a service.\u0022\u0022\u0022\n\u002B\n\u002B    def add_arguments(self, parser, cli_name):\n\u002B        add_strategy_node_arguments(parser)\n\u002B        arg = parser.add_argument(\n\u002B            \u0027service_name\u0027,\n\u002B            help=\u0022Name of the ROS service to get info (e.g. \u0027/add_two_ints\u0027)\u0022)\n\u002B        arg.completer = ServiceNameCompleter(\n\u002B            include_hidden_services_key=\u0027include_hidden_services\u0027)\n\u002B\n\u002B    def main(self, *, args):\n\u002B        with NodeStrategy(args) as node:\n\u002B            service_names_and_types = get_service_names_and_types(\n\u002B                node=node,\n\u002B                include_hidden_services=args.include_hidden_services)\n\u002B            service_name = args.service_name\n\u002B\n\u002B            for (s_name, s_types) in service_names_and_types:\n\u002B                if s_name == service_name:\n\u002B                    service_types = s_types\n\u002B                    break\n\u002B            else:\n\u002B                return \u0022Unknown service \u0027%s\u0027\u0022 % service_name\n\u002B\n\u002B            type_str = service_types[0] if len(service_types) == 1 else service_types\n\u002B            print(\u0027Type: %s\u0027 % type_str, end=\u0027\\n\u0027)\n\u002B\n\u002B            print(\u0027Clients count: %d\u0027 %\n\u002B                  node.count_clients(service_name), end=\u0027\\n\u0027)\n\u002B\n\u002B            print(\u0027Services count: %d\u0027 %\n\u002B                  node.count_services(service_name), end=\u0027\\n\u0027)\ndiff --git ros2service/setup.py ros2service/setup.py\nindex 74b3d6a..c599ad0 100644\n--- ros2service/setup.py\n\u002B\u002B\u002B ros2service/setup.py\n@@ -43,6 \u002B43,7 @@ The package provides the service command for the ROS 2 command line tools.\u0022\u0022\u0022,\n             \u0027call = ros2service.verb.call:CallVerb\u0027,\n             \u0027echo = ros2service.verb.echo:EchoVerb\u0027,\n             \u0027find = ros2service.verb.find:FindVerb\u0027,\n\u002B            \u0027info = ros2service.verb.info:InfoVerb\u0027,\n             \u0027list = ros2service.verb.list:ListVerb\u0027,\n             \u0027type = ros2service.verb.type:TypeVerb\u0027,\n         ],\n",
    "IsBackported": false
  },
  {
    "Repository": "rcl",
    "SHA": "1e565d56551f193b5cb1461a6ed71015508f7485",
    "RawMessage": "escalate RCL_RET_ACTION_xxx to 40XX. (#1191)",
    "Changes": "diff --git rcl/include/rcl/types.h rcl/include/rcl/types.h\nindex 6ae4628..223817e 100644\n--- rcl/include/rcl/types.h\n\u002B\u002B\u002B rcl/include/rcl/types.h\n@@ -127,8 \u002B127,26 @@ typedef rmw_ret_t rcl_ret_t;\n #define RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED 3001\n \n // rcl action specific ret codes in 40XX\n\u002B/// Action name does not pass validation return code.\n\u002B#define RCL_RET_ACTION_NAME_INVALID 4000\n /// No terminal timestamp for the goal as it has not reached a terminal state.\n-#define RCL_ACTION_RET_NOT_TERMINATED_YET 4001\n\u002B#define RCL_RET_ACTION_NOT_TERMINATED_YET 4001\n\u002B/// Action goal accepted return code.\n\u002B#define RCL_RET_ACTION_GOAL_ACCEPTED 4100\n\u002B/// Action goal rejected return code.\n\u002B#define RCL_RET_ACTION_GOAL_REJECTED 4101\n\u002B/// Action client is invalid return code.\n\u002B#define RCL_RET_ACTION_CLIENT_INVALID 4102\n\u002B/// Action client failed to take response return code.\n\u002B#define RCL_RET_ACTION_CLIENT_TAKE_FAILED 4103\n\u002B/// Action server is invalid return code.\n\u002B#define RCL_RET_ACTION_SERVER_INVALID 4200\n\u002B/// Action server failed to take request return code.\n\u002B#define RCL_RET_ACTION_SERVER_TAKE_FAILED 4201\n\u002B/// Action goal handle invalid return code.\n\u002B#define RCL_RET_ACTION_GOAL_HANDLE_INVALID 4300\n\u002B/// Action invalid event return code.\n\u002B#define RCL_RET_ACTION_GOAL_EVENT_INVALID 4301\n \n /// typedef for rmw_serialized_message_t;\n typedef rmw_serialized_message_t rcl_serialized_message_t;\ndiff --git rcl_action/include/rcl_action/types.h rcl_action/include/rcl_action/types.h\nindex c34bd42..30a16fb 100644\n--- rcl_action/include/rcl_action/types.h\n\u002B\u002B\u002B rcl_action/include/rcl_action/types.h\n@@ -33,26 \u002B33,6 @@ extern \u0022C\u0022\n \n #include \u0022rosidl_runtime_c/action_type_support_struct.h\u0022\n \n-// rcl action specific ret codes in 2XXX\n-/// Action name does not pass validation return code.\n-#define RCL_RET_ACTION_NAME_INVALID 2000\n-/// Action goal accepted return code.\n-#define RCL_RET_ACTION_GOAL_ACCEPTED 2100\n-/// Action goal rejected return code.\n-#define RCL_RET_ACTION_GOAL_REJECTED 2101\n-/// Action client is invalid return code.\n-#define RCL_RET_ACTION_CLIENT_INVALID 2102\n-/// Action client failed to take response return code.\n-#define RCL_RET_ACTION_CLIENT_TAKE_FAILED 2103\n-/// Action server is invalid return code.\n-#define RCL_RET_ACTION_SERVER_INVALID 2200\n-/// Action server failed to take request return code.\n-#define RCL_RET_ACTION_SERVER_TAKE_FAILED 2201\n-/// Action goal handle invalid return code.\n-#define RCL_RET_ACTION_GOAL_HANDLE_INVALID 2300\n-/// Action invalid event return code.\n-#define RCL_RET_ACTION_GOAL_EVENT_INVALID 2301\n-\n // TODO(jacobperron): Move these to a common place for UUIDs\n #define UUID_SIZE 16\n #define uuidcmp(uuid0, uuid1) (0 == memcmp(uuid0, uuid1, UUID_SIZE))\ndiff --git rcl_action/src/rcl_action/action_server.c rcl_action/src/rcl_action/action_server.c\nindex 65957cd..dfa82be 100644\n--- rcl_action/src/rcl_action/action_server.c\n\u002B\u002B\u002B rcl_action/src/rcl_action/action_server.c\n@@ -459,7 \u002B459,7 @@ _recalculate_expire_timer(\n       rcl_time_point_value_t goal_terminal_timestamp;\n       ret = rcl_action_goal_handle_get_goal_terminal_timestamp(\n         goal_handle, \u0026goal_terminal_timestamp);\n-      if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n\u002B      if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {\n         continue;\n       }\n       if (RCL_RET_OK != ret) {\n@@ -655,7 \u002B655,7 @@ rcl_action_expire_goals(\n     }\n \n     ret = rcl_action_goal_handle_get_goal_terminal_timestamp(goal_handle, \u0026goal_terminal_timestamp);\n-    if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n\u002B    if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {\n       continue;\n     }\n     if (RCL_RET_OK != ret) {\n@@ -738,7 \u002B738,7 @@ rcl_action_notify_goal_done(\n       rcl_time_point_value_t goal_terminal_timestamp;\n       rcl_ret_t ret = rcl_action_goal_handle_get_goal_terminal_timestamp(\n         goal_handle, \u0026goal_terminal_timestamp);\n-      if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n\u002B      if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {\n         ret = rcl_action_goal_handle_set_goal_terminal_timestamp(goal_handle, current_time);\n         if (RCL_RET_OK != ret) {\n           return RCL_RET_ERROR;\ndiff --git rcl_action/src/rcl_action/goal_handle.c rcl_action/src/rcl_action/goal_handle.c\nindex e7698d7..d6ba4e5 100644\n--- rcl_action/src/rcl_action/goal_handle.c\n\u002B\u002B\u002B rcl_action/src/rcl_action/goal_handle.c\n@@ -192,7 \u002B192,7 @@ rcl_action_goal_handle_get_goal_terminal_timestamp(\n   RCL_CHECK_ARGUMENT_FOR_NULL(timestamp, RCL_RET_INVALID_ARGUMENT);\n \n   if (goal_handle-\u003Eimpl-\u003Egoal_terminal_timestamp == INVAILD_GOAL_TERMINAL_TIMESTAMP) {\n-    return RCL_ACTION_RET_NOT_TERMINATED_YET;\n\u002B    return RCL_RET_ACTION_NOT_TERMINATED_YET;\n   }\n \n   *timestamp = goal_handle-\u003Eimpl-\u003Egoal_terminal_timestamp;\ndiff --git rcl_action/test/rcl_action/test_goal_handle.cpp rcl_action/test/rcl_action/test_goal_handle.cpp\nindex 2b96d98..a2fb08a 100644\n--- rcl_action/test/rcl_action/test_goal_handle.cpp\n\u002B\u002B\u002B rcl_action/test/rcl_action/test_goal_handle.cpp\n@@ -195,7 \u002B195,7 @@ TEST(TestGoalHandle, rcl_action_goal_handle_get_goal_terminal_timestamp)\n \n   rcl_time_point_value_t timestamp;\n   ret = rcl_action_goal_handle_get_goal_terminal_timestamp(\u0026goal_handle, \u0026timestamp);\n-  EXPECT_EQ(ret, RCL_ACTION_RET_NOT_TERMINATED_YET) \u003C\u003C rcl_get_error_string().str;\n\u002B  EXPECT_EQ(ret, RCL_RET_ACTION_NOT_TERMINATED_YET) \u003C\u003C rcl_get_error_string().str;\n   rcl_reset_error();\n \n   EXPECT_EQ(RCL_RET_OK, rcl_action_goal_handle_fini(\u0026goal_handle));\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "5e74a903c8d7125734449c111c0066fe5ed61ffc",
    "RawMessage": "Remove a bunch of unnecessary macros. (#482)",
    "Changes": "diff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex c83727f..5dd8bb5 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -117,27 \u002B117,10 @@ using namespace std::literals::chrono_literals;\n #define RET_NULL_X(var, code) do {if (!var) {RET_ERR_X(#var \u0022 is null\u0022, code);}} while (0)\n #define RET_ALLOC_X(var, code) do {if (!var) {RET_ERR_X(\u0022failed to allocate \u0022 #var, code);} \\\n } while (0)\n-#define RET_WRONG_IMPLID_X(var, code) do { \\\n-    if ((var)-\u003Eimplementation_identifier != eclipse_cyclonedds_identifier) { \\\n-      RET_ERR_X(#var \u0022 not from this implementation\u0022, code); \\\n-    } \\\n-} while (0)\n-#define RET_NULL_OR_EMPTYSTR_X(var, code) do { \\\n-    if (!var || strlen(var) == 0) { \\\n-      RET_ERR_X(#var \u0022 is null or empty string\u0022, code); \\\n-    } \\\n-} while (0)\n\u002B\n #define RET_ERR(msg) RET_ERR_X(msg, return RMW_RET_ERROR)\n #define RET_NULL(var) RET_NULL_X(var, return RMW_RET_ERROR)\n #define RET_ALLOC(var) RET_ALLOC_X(var, return RMW_RET_ERROR)\n-#define RET_WRONG_IMPLID(var) RET_WRONG_IMPLID_X(var, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n-#define RET_NULL_OR_EMPTYSTR(var) RET_NULL_OR_EMPTYSTR_X(var, return RMW_RET_ERROR)\n-#define RET_EXPECTED(func, expected_ret, error_msg, code) do { \\\n-    if ((expected_ret) != (func)) \\\n-    { \\\n-      RET_ERR_X(error_msg, code); \\\n-    } \\\n-} while (0)\n \n using rmw_dds_common::msg::ParticipantEntitiesInfo;\n \n@@ -804,10 \u002B787,8 @@ extern \u0022C\u0022 rmw_ret_t rmw_init_options_copy(const rmw_init_options_t * src, rmw_i\n     return RMW_RET_INVALID_ARGUMENT;\n   }\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    src,\n-    src-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B    init options copy, src-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   if (NULL != dst-\u003Eimplementation_identifier) {\n     RMW_SET_ERROR_MSG(\u0022expected zero-initialized dst\u0022);\n     return RMW_RET_INVALID_ARGUMENT;\n@@ -838,10 \u002B819,8 @@ extern \u0022C\u0022 rmw_ret_t rmw_init_options_fini(rmw_init_options_t * init_options)\n     return RMW_RET_INVALID_ARGUMENT;\n   }\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    init_options,\n-    init_options-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B    init options, init_options-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   rcutils_allocator_t * allocator = \u0026init_options-\u003Eallocator;\n   RCUTILS_CHECK_ALLOCATOR(allocator, return RMW_RET_INVALID_ARGUMENT);\n \n@@ -1552,17 \u002B1531,15 @@ static void * init_and_alloc_sample(\n {\n   // initialise the data allocator\n   if (alloc_on_heap) {\n-    RET_EXPECTED(\n-      dds_data_allocator_init_heap(\u0026entity-\u003Edata_allocator),\n-      DDS_RETCODE_OK,\n-      \u0022Reader data allocator initialization failed for heap\u0022,\n-      return nullptr);\n\u002B    if (dds_data_allocator_init_heap(\u0026entity-\u003Edata_allocator) != DDS_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Reader data allocator initialization failed for heap\u0022);\n\u002B      return nullptr;\n\u002B    }\n   } else {\n-    RET_EXPECTED(\n-      dds_data_allocator_init(entity-\u003Eenth, \u0026entity-\u003Edata_allocator),\n-      DDS_RETCODE_OK,\n-      \u0022Writer allocator initialisation failed\u0022,\n-      return nullptr);\n\u002B    if (dds_data_allocator_init(entity-\u003Eenth, \u0026entity-\u003Edata_allocator) != DDS_RETCODE_OK) {\n\u002B      RMW_SET_ERROR_MSG(\u0022Writer allocator initialisation failed\u0022);\n\u002B      return nullptr;\n\u002B    }\n   }\n   // allocate memory for message \u002B header\n   // the header will be initialized and the chunk pointer will be returned\n@@ -1583,19 \u002B1560,15 @@ static rmw_ret_t fini_and_free_sample(entityT \u0026 entity, void * loaned_message)\n   // fini the message\n   rmw_cyclonedds_cpp::fini_message(\u0026entity-\u003Etype_supports, loaned_message);\n   // free the message memory\n-  RET_EXPECTED(\n-    dds_data_allocator_free(\n-      \u0026entity-\u003Edata_allocator,\n-      loaned_message),\n-    DDS_RETCODE_OK,\n-    \u0022Failed to free the loaned message\u0022,\n-    return RMW_RET_ERROR);\n\u002B  if (dds_data_allocator_free(\u0026entity-\u003Edata_allocator, loaned_message) != DDS_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Failed to free the loaned message\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n   // fini the allocator\n-  RET_EXPECTED(\n-    dds_data_allocator_fini(\u0026entity-\u003Edata_allocator),\n-    DDS_RETCODE_OK,\n-    \u0022Failed to fini data allocator\u0022,\n-    return RMW_RET_ERROR);\n\u002B  if (dds_data_allocator_fini(\u0026entity-\u003Edata_allocator) != DDS_RETCODE_OK) {\n\u002B    RMW_SET_ERROR_MSG(\u0022Failed to fini data allocator\u0022);\n\u002B    return RMW_RET_ERROR;\n\u002B  }\n   return RMW_RET_OK;\n }\n \n@@ -1610,9 \u002B1583,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_init(const rmw_init_options_t * options, rmw_context_t\n     \u0022expected initialized init options\u0022,\n     return RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    options,\n-    options-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    options, options-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_FOR_NULL_WITH_MSG(\n     options-\u003Eenclave,\n@@ -1663,9 \u002B1634,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_shutdown(rmw_context_t * context)\n     \u0022expected initialized context\u0022,\n     return RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    context,\n-    context-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    context, context-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   context-\u003Eimpl-\u003Eis_shutdown = true;\n   return RMW_RET_OK;\n@@ -1679,9 \u002B1648,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_context_fini(rmw_context_t * context)\n     \u0022expected initialized context\u0022,\n     return RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    context,\n-    context-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    context, context-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   if (!context-\u003Eimpl-\u003Eis_shutdown) {\n     RMW_SET_ERROR_MSG(\u0022context has not been shutdown\u0022);\n@@ -1704,9 \u002B1671,7 @@ extern \u0022C\u0022 rmw_node_t * rmw_create_node(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    context,\n-    context-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    context, context-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return nullptr);\n   RMW_CHECK_FOR_NULL_WITH_MSG(\n     context-\u003Eimpl,\n@@ -1786,9 \u002B1751,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_node(rmw_node_t * node)\n   rmw_ret_t result_ret = RMW_RET_OK;\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto node_impl = static_cast\u003CCddsNode *\u003E(node-\u003Edata);\n \n@@ -1808,7 \u002B1771,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_node(rmw_node_t * node)\n extern \u0022C\u0022 const rmw_guard_condition_t * rmw_node_get_graph_guard_condition(const rmw_node_t * node)\n {\n   RET_NULL_X(node, return nullptr);\n-  RET_WRONG_IMPLID_X(node, return nullptr);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    return nullptr);\n   auto node_impl = static_cast\u003CCddsNode *\u003E(node-\u003Edata);\n   RET_NULL_X(node_impl, return nullptr);\n   return node-\u003Econtext-\u003Eimpl-\u003Ecommon.graph_guard_condition;\n@@ -2460,7 \u002B2425,11 @@ static CddsPublisher * create_cdds_publisher(\n   const char * topic_name,\n   const rmw_qos_profile_t * qos_policies)\n {\n-  RET_NULL_OR_EMPTYSTR_X(topic_name, return nullptr);\n\u002B  if (!topic_name || topic_name[0] == \u0027\\0\u0027) {\n\u002B    RMW_SET_ERROR_MSG(\u0022topic_name is null or empty string\u0022);\n\u002B    return nullptr;\n\u002B  }\n\u002B\n   RET_NULL_X(qos_policies, return nullptr);\n   const rosidl_message_type_support_t * type_support = get_typesupport(type_supports);\n   RET_NULL_X(type_support, return nullptr);\n@@ -2591,9 \u002B2560,7 @@ extern \u0022C\u0022 rmw_publisher_t * rmw_create_publisher(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, nullptr);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return nullptr);\n   RMW_CHECK_ARGUMENT_FOR_NULL(type_supports, nullptr);\n   RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, nullptr);\n@@ -2668,9 \u002B2635,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_gid_for_publisher(const rmw_publisher_t * publisher\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(gid, RMW_RET_INVALID_ARGUMENT);\n   auto pub = static_cast\u003Cconst CddsPublisher *\u003E(publisher-\u003Edata);\n@@ -2687,9 \u002B2652,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_gid_for_client(const rmw_client_t * client, rmw_gid\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    client,\n-    client-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    client, client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(gid, RMW_RET_INVALID_ARGUMENT);\n \n@@ -2709,15 \u002B2672,11 @@ extern \u0022C\u0022 rmw_ret_t rmw_compare_gids_equal(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(gid1, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    gid1,\n-    gid1-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    gid1, gid1-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(gid2, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    gid2,\n-    gid2-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    gid2, gid2-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(result, RMW_RET_INVALID_ARGUMENT);\n   /* alignment is potentially lost because of the translation to an array of bytes, so use\n@@ -2732,9 \u002B2691,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_publisher_count_matched_subscriptions(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n \n@@ -2751,7 \u002B2708,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_publisher_count_matched_subscriptions(\n rmw_ret_t rmw_publisher_assert_liveliness(const rmw_publisher_t * publisher)\n {\n   RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto pub = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n   if (dds_assert_liveliness(pub-\u003Eenth) \u003C 0) {\n     return RMW_RET_ERROR;\n@@ -2765,9 \u002B2724,7 @@ rmw_ret_t rmw_publisher_wait_for_all_acked(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n   auto pub = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n@@ -2796,9 \u002B2753,7 @@ rmw_ret_t rmw_publisher_get_actual_qos(const rmw_publisher_t * publisher, rmw_qo\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n   auto pub = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n@@ -2821,9 \u002B2776,7 @@ static rmw_ret_t borrow_loaned_message_int(\n   }\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(type_support, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(ros_message, RMW_RET_INVALID_ARGUMENT);\n   if (*ros_message) {\n@@ -2874,9 \u002B2827,7 @@ static rmw_ret_t return_loaned_message_from_publisher_int(\n   }\n   RCUTILS_CHECK_ARGUMENT_FOR_NULL(loaned_message, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n   auto cdds_publisher = static_cast\u003CCddsPublisher *\u003E(publisher-\u003Edata);\n@@ -2929,14 \u002B2880,10 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_publisher(rmw_node_t * node, rmw_publisher_t *\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    publisher,\n-    publisher-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n   rmw_ret_t ret = RMW_RET_OK;\n@@ -2983,7 \u002B2930,10 @@ static CddsSubscription * create_cdds_subscription(\n   const rosidl_message_type_support_t * type_supports, const char * topic_name,\n   const rmw_qos_profile_t * qos_policies, bool ignore_local_publications)\n {\n-  RET_NULL_OR_EMPTYSTR_X(topic_name, return nullptr);\n\u002B  if (!topic_name || topic_name[0] == \u0027\\0\u0027) {\n\u002B    RMW_SET_ERROR_MSG(\u0022topic_name is null or empty string\u0022);\n\u002B    return nullptr;\n\u002B  }\n   RET_NULL_X(qos_policies, return nullptr);\n   const rosidl_message_type_support_t * type_support = get_typesupport(type_supports);\n   RET_NULL_X(type_support, return nullptr);\n@@ -3121,9 \u002B3071,7 @@ extern \u0022C\u0022 rmw_subscription_t * rmw_create_subscription(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, nullptr);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return nullptr);\n   RMW_CHECK_ARGUMENT_FOR_NULL(type_supports, nullptr);\n   RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, nullptr);\n@@ -3199,9 \u002B3147,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_subscription_count_matched_publishers(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription,\n-    subscription-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    subscription, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n \n@@ -3221,9 \u002B3167,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_subscription_get_actual_qos(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription,\n-    subscription-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    subscription, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(qos, RMW_RET_INVALID_ARGUMENT);\n \n@@ -3286,14 \u002B3230,10 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_subscription(rmw_node_t * node, rmw_subscriptio\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription,\n-    subscription-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    subscription, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n   rmw_ret_t ret = RMW_RET_OK;\n@@ -3354,8 \u002B3294,7 @@ static rmw_ret_t rmw_take_int(\n     subscription, RMW_RET_INVALID_ARGUMENT);\n \n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription handle,\n-    subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    subscription handle, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   CddsSubscription * sub = static_cast\u003CCddsSubscription *\u003E(subscription-\u003Edata);\n   RET_NULL(sub);\n@@ -3405,11 \u002B3344,9 @@ static rmw_ret_t rmw_take_seq(\n \n   RMW_CHECK_ARGUMENT_FOR_NULL(\n     subscription, RMW_RET_INVALID_ARGUMENT);\n-  RET_WRONG_IMPLID(subscription);\n \n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription handle,\n-    subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    subscription handle, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n \n   if (0u == count) {\n@@ -3494,8 \u002B3431,7 @@ static rmw_ret_t rmw_take_ser_int(\n   RMW_CHECK_ARGUMENT_FOR_NULL(\n     taken, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription handle,\n-    subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    subscription handle, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   CddsSubscription * sub = static_cast\u003CCddsSubscription *\u003E(subscription-\u003Edata);\n   RET_NULL(sub);\n@@ -3580,8 \u002B3516,7 @@ static rmw_ret_t rmw_take_loan_int(\n   RMW_CHECK_ARGUMENT_FOR_NULL(\n     taken, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription handle,\n-    subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    subscription handle, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto cdds_subscription = static_cast\u003CCddsSubscription *\u003E(subscription-\u003Edata);\n   if (!cdds_subscription) {\n@@ -3749,8 \u002B3684,7 @@ static rmw_ret_t return_loaned_message_from_subscription_int(\n   RMW_CHECK_ARGUMENT_FOR_NULL(\n     loaned_message, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    subscription handle,\n-    subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    subscription handle, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto cdds_subscription = static_cast\u003CCddsSubscription *\u003E(subscription-\u003Edata);\n   if (!cdds_subscription) {\n@@ -3887,7 \u002B3821,10 @@ extern \u0022C\u0022 rmw_ret_t rmw_publisher_event_init(\n   rmw_event_t * rmw_event, const rmw_publisher_t * publisher, rmw_event_type_t event_type)\n {\n   RET_NULL(publisher);\n-  RET_WRONG_IMPLID(publisher);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    publisher, publisher-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B\n   return init_rmw_event(\n     rmw_event,\n     publisher-\u003Eimplementation_identifier,\n@@ -3899,7 \u002B3836,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_subscription_event_init(\n   rmw_event_t * rmw_event, const rmw_subscription_t * subscription, rmw_event_type_t event_type)\n {\n   RET_NULL(subscription);\n-  RET_WRONG_IMPLID(subscription);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    subscription, subscription-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   return init_rmw_event(\n     rmw_event,\n     subscription-\u003Eimplementation_identifier,\n@@ -3912,7 \u002B3851,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_take_event(\n   bool * taken)\n {\n   RET_NULL(event_handle);\n-  RET_WRONG_IMPLID(event_handle);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    event_handle, event_handle-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RET_NULL(taken);\n   RET_NULL(event_info);\n   switch (event_handle-\u003Eevent_type) {\n@@ -4155,7 \u002B4096,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_trigger_guard_condition(\n   const rmw_guard_condition_t * guard_condition_handle)\n {\n   RET_NULL(guard_condition_handle);\n-  RET_WRONG_IMPLID(guard_condition_handle);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    guard_condition_handle, guard_condition_handle-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto * gcond_impl = static_cast\u003CCddsGuardCondition *\u003E(guard_condition_handle-\u003Edata);\n   dds_set_guardcondition(gcond_impl-\u003Egcondh, true);\n   return RMW_RET_OK;\n@@ -4224,7 \u002B4167,9 @@ fail_alloc_wait_set:\n extern \u0022C\u0022 rmw_ret_t rmw_destroy_wait_set(rmw_wait_set_t * wait_set)\n {\n   RET_NULL(wait_set);\n-  RET_WRONG_IMPLID(wait_set);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    wait_set, wait_set-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto result = RMW_RET_OK;\n   auto ws = static_cast\u003CCddsWaitset *\u003E(wait_set-\u003Edata);\n   RET_NULL(ws);\n@@ -4385,7 \u002B4330,9 @@ extern \u0022C\u0022 rmw_ret_t rmw_wait(\n   rmw_wait_set_t * wait_set, const rmw_time_t * wait_timeout)\n {\n   RET_NULL_X(wait_set, return RMW_RET_INVALID_ARGUMENT);\n-  RET_WRONG_IMPLID(wait_set);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    wait_set, wait_set-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   CddsWaitset * ws = static_cast\u003CCddsWaitset *\u003E(wait_set-\u003Edata);\n   RET_NULL(ws);\n \n@@ -4410,25 \u002B4357,52 @@ extern \u0022C\u0022 rmw_ret_t rmw_wait(\n   {\n     size_t nelems = 0;\n     waitset_detach(ws);\n-#define ATTACH(type, var, name, cond) do { \\\n-    ws-\u003Evar.resize(0); \\\n-    if (var) { \\\n-      ws-\u003Evar.reserve(var-\u003Ename ## _count); \\\n-      for (size_t i = 0; i \u003C var-\u003Ename ## _count; i\u002B\u002B) { \\\n-        auto x = static_cast\u003Ctype *\u003E(var-\u003Ename ## s[i]); \\\n-        ws-\u003Evar.push_back(x); \\\n-        dds_waitset_attach(ws-\u003Ewaitseth, x-\u003Econd, nelems); \\\n-        nelems\u002B\u002B; \\\n-      } \\\n-    } \\\n-} \\\n-  while (0)\n-    ATTACH(CddsSubscription, subs, subscriber, rdcondh);\n-    ATTACH(CddsGuardCondition, gcs, guard_condition, gcondh);\n-    ATTACH(CddsService, srvs, service, service.sub-\u003Erdcondh);\n-    ATTACH(CddsClient, cls, client, client.sub-\u003Erdcondh);\n-#undef ATTACH\n \n\u002B    // Attach subscriptions\n\u002B    ws-\u003Esubs.resize(0);\n\u002B    if (subs) {\n\u002B      ws-\u003Esubs.reserve(subs-\u003Esubscriber_count);\n\u002B      for (size_t i = 0; i \u003C subs-\u003Esubscriber_count; i\u002B\u002B) {\n\u002B        auto x = static_cast\u003CCddsSubscription *\u003E(subs-\u003Esubscribers[i]);\n\u002B        ws-\u003Esubs.push_back(x);\n\u002B        dds_waitset_attach(ws-\u003Ewaitseth, x-\u003Erdcondh, nelems\u002B\u002B);\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Attach guard conditions\n\u002B    ws-\u003Egcs.resize(0);\n\u002B    if (gcs) {\n\u002B      ws-\u003Egcs.reserve(gcs-\u003Eguard_condition_count);\n\u002B      for (size_t i = 0; i \u003C gcs-\u003Eguard_condition_count; i\u002B\u002B) {\n\u002B        auto x = static_cast\u003CCddsGuardCondition *\u003E(gcs-\u003Eguard_conditions[i]);\n\u002B        ws-\u003Egcs.push_back(x);\n\u002B        dds_waitset_attach(ws-\u003Ewaitseth, x-\u003Egcondh, nelems\u002B\u002B);\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Attach service servers\n\u002B    ws-\u003Esrvs.resize(0);\n\u002B    if (srvs) {\n\u002B      ws-\u003Esrvs.reserve(srvs-\u003Eservice_count);\n\u002B      for (size_t i = 0; i \u003C srvs-\u003Eservice_count; i\u002B\u002B) {\n\u002B        auto x = static_cast\u003CCddsService *\u003E(srvs-\u003Eservices[i]);\n\u002B        ws-\u003Esrvs.push_back(x);\n\u002B        dds_waitset_attach(ws-\u003Ewaitseth, x-\u003Eservice.sub-\u003Erdcondh, nelems\u002B\u002B);\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Attach service clients\n\u002B    ws-\u003Ecls.resize(0);\n\u002B    if (cls) {\n\u002B      ws-\u003Ecls.reserve(cls-\u003Eclient_count);\n\u002B      for (size_t i = 0; i \u003C cls-\u003Eclient_count; i\u002B\u002B) {\n\u002B        auto x = static_cast\u003CCddsClient *\u003E(cls-\u003Eclients[i]);\n\u002B        ws-\u003Ecls.push_back(x);\n\u002B        dds_waitset_attach(ws-\u003Ewaitseth, x-\u003Eclient.sub-\u003Erdcondh, nelems\u002B\u002B);\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Attach events\n     ws-\u003Eevs.resize(0);\n     if (evs) {\n       std::unordered_set\u003Cdds_entity_t\u003E event_entities;\n@@ -4468,29 \u002B4442,58 @@ extern \u0022C\u0022 rmw_ret_t rmw_wait(\n \n   {\n     dds_attach_t trig_idx = 0;\n-    bool dummy;\n     size_t nelems = 0;\n-#define DETACH(type, var, name, cond, on_triggered) do { \\\n-    if (var) { \\\n-      for (size_t i = 0; i \u003C var-\u003Ename ## _count; i\u002B\u002B) { \\\n-        auto x = static_cast\u003Ctype *\u003E(var-\u003Ename ## s[i]); \\\n-        if (ws-\u003Etrigs[trig_idx] == static_cast\u003Cdds_attach_t\u003E(nelems)) { \\\n-          on_triggered; \\\n-          trig_idx\u002B\u002B; \\\n-        } else { \\\n-          var-\u003Ename ## s[i] = nullptr; \\\n-        } \\\n-        nelems\u002B\u002B; \\\n-      } \\\n-    } \\\n-} while (0)\n-    DETACH(CddsSubscription, subs, subscriber, rdcondh, (void) x);\n-    DETACH(\n-      CddsGuardCondition, gcs, guard_condition, gcondh,\n-      dds_take_guardcondition(x-\u003Egcondh, \u0026dummy));\n-    DETACH(CddsService, srvs, service, service.sub-\u003Erdcondh, (void) x);\n-    DETACH(CddsClient, cls, client, client.sub-\u003Erdcondh, (void) x);\n-#undef DETACH\n\u002B\n\u002B    // Detach subscriptions\n\u002B    if (subs) {\n\u002B      for (size_t i = 0; i \u003C subs-\u003Esubscriber_count; i\u002B\u002B) {\n\u002B        if (ws-\u003Etrigs[trig_idx] == static_cast\u003Cdds_attach_t\u003E(nelems)) {\n\u002B          trig_idx\u002B\u002B;\n\u002B        } else {\n\u002B          subs-\u003Esubscribers[i] = nullptr;\n\u002B        }\n\u002B        nelems\u002B\u002B;\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Detach guard conditions\n\u002B    if (gcs) {\n\u002B      for (size_t i = 0; i \u003C gcs-\u003Eguard_condition_count; i\u002B\u002B) {\n\u002B        auto x = static_cast\u003CCddsGuardCondition *\u003E(gcs-\u003Eguard_conditions[i]);\n\u002B        if (ws-\u003Etrigs[trig_idx] == static_cast\u003Cdds_attach_t\u003E(nelems)) {\n\u002B          bool dummy;\n\u002B          dds_take_guardcondition(x-\u003Egcondh, \u0026dummy);\n\u002B        } else {\n\u002B          gcs-\u003Eguard_conditions[i] = nullptr;\n\u002B        }\n\u002B        nelems\u002B\u002B;\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Detach service servers\n\u002B    if (srvs) {\n\u002B      for (size_t i = 0; i \u003C srvs-\u003Eservice_count; i\u002B\u002B) {\n\u002B        if (ws-\u003Etrigs[trig_idx] == static_cast\u003Cdds_attach_t\u003E(nelems)) {\n\u002B          trig_idx\u002B\u002B;\n\u002B        } else {\n\u002B          srvs-\u003Eservices[i] = nullptr;\n\u002B        }\n\u002B        nelems\u002B\u002B;\n\u002B      }\n\u002B    }\n\u002B\n\u002B    // Detach service clients\n\u002B    if (cls) {\n\u002B      for (size_t i = 0; i \u003C cls-\u003Eclient_count; i\u002B\u002B) {\n\u002B        if (ws-\u003Etrigs[trig_idx] == static_cast\u003Cdds_attach_t\u003E(nelems)) {\n\u002B          trig_idx\u002B\u002B;\n\u002B        } else {\n\u002B          cls-\u003Eclients[i] = nullptr;\n\u002B        }\n\u002B        nelems\u002B\u002B;\n\u002B      }\n\u002B    }\n\u002B\n     handle_active_events(evs);\n   }\n \n@@ -4622,8 \u002B4625,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_take_response(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    client,\n-    client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    client, client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto info = static_cast\u003CCddsClient *\u003E(client-\u003Edata);\n   dds_time_t source_timestamp;\n@@ -4673,8 \u002B4675,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_take_request(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    service,\n-    service-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    service, service-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n   return rmw_take_response_request(\n@@ -4751,8 \u002B4752,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_send_response(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    service,\n-    service-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    service, service-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(request_header, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(ros_response, RMW_RET_INVALID_ARGUMENT);\n@@ -4804,8 \u002B4804,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_send_request(\n   static std::atomic_uint next_request_id;\n   RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    client,\n-    client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n\u002B    client, client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(ros_request, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(sequence_id, RMW_RET_INVALID_ARGUMENT);\n@@ -4890,9 \u002B4889,7 @@ static rmw_ret_t rmw_init_cs(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(type_supports, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n@@ -5136,15 \u002B5133,11 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_client(rmw_node_t * node, rmw_client_t * client\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(client, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    client,\n-    client-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    client, client-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto info = static_cast\u003CCddsClient *\u003E(client-\u003Edata);\n   clean_waitset_caches();\n@@ -5233,15 \u002B5226,11 @@ extern \u0022C\u0022 rmw_ret_t rmw_destroy_service(rmw_node_t * node, rmw_service_t * serv\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(service, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    service,\n-    service-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    service, service-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   auto info = static_cast\u003CCddsService *\u003E(service-\u003Edata);\n   clean_waitset_caches();\n@@ -5276,9 \u002B5265,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_node_names(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_names)) {\n     return RMW_RET_INVALID_ARGUMENT;\n@@ -5304,9 \u002B5291,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_node_names_with_enclaves(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   if (RMW_RET_OK != rmw_check_zero_rmw_string_array(node_names)) {\n     return RMW_RET_INVALID_ARGUMENT;\n@@ -5334,9 \u002B5319,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_topic_names_and_types(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n     allocator, \u0022allocator argument is invalid\u0022, return RMW_RET_INVALID_ARGUMENT);\n@@ -5365,9 \u002B5348,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_service_names_and_types(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n     allocator, \u0022allocator argument is invalid\u0022, return RMW_RET_INVALID_ARGUMENT);\n@@ -5454,9 \u002B5435,13 @@ extern \u0022C\u0022 rmw_ret_t rmw_service_server_is_available(\n   bool * is_available)\n {\n   RET_NULL(node);\n-  RET_WRONG_IMPLID(node);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node, node-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RET_NULL(client);\n-  RET_WRONG_IMPLID(client);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    client, client-\u003Eimplementation_identifier,\n\u002B    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RET_NULL(is_available);\n   *is_available = false;\n \n@@ -5492,9 \u002B5477,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_count_publishers(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);\n   int validation_result = RMW_TOPIC_VALID;\n@@ -5520,9 \u002B5503,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_count_subscribers(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(topic_name, RMW_RET_INVALID_ARGUMENT);\n   int validation_result = RMW_TOPIC_VALID;\n@@ -5548,9 \u002B5529,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_count_clients(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n   int validation_result = RMW_TOPIC_VALID;\n@@ -5576,9 \u002B5555,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_count_services(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n   int validation_result = RMW_TOPIC_VALID;\n@@ -5620,9 \u002B5597,7 @@ static rmw_ret_t get_topic_names_and_types_by_node(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n     allocator, \u0022allocator argument is invalid\u0022, return RMW_RET_INVALID_ARGUMENT);\n@@ -5777,9 \u002B5752,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_publishers_info_by_topic(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n     allocator, \u0022allocator argument is invalid\u0022, return RMW_RET_INVALID_ARGUMENT);\n@@ -5811,9 \u002B5784,7 @@ extern \u0022C\u0022 rmw_ret_t rmw_get_subscriptions_info_by_topic(\n {\n   RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n-    node,\n-    node-\u003Eimplementation_identifier,\n-    eclipse_cyclonedds_identifier,\n\u002B    node, node-\u003Eimplementation_identifier, eclipse_cyclonedds_identifier,\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RCUTILS_CHECK_ALLOCATOR_WITH_MSG(\n     allocator, \u0022allocator argument is invalid\u0022, return RMW_RET_INVALID_ARGUMENT);\ndiff --git rmw_cyclonedds_cpp/src/serdes.hpp rmw_cyclonedds_cpp/src/serdes.hpp\nindex 9973572..eb2d6fe 100644\n--- rmw_cyclonedds_cpp/src/serdes.hpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdes.hpp\n@@ -174,24 \u002B174,27 @@ public:\n     pos \u002B= sz * sizeof(wchar_t);\n   }\n \n\u002B  // *INDENT-OFF*\n #define DESER8_A(T) DESER_A(T, )\n #define DESER_A(T, fn_swap) inline void deserializeA(T * x, size_t cnt) { \\\n-    if (cnt \u003E 0) { \\\n-      align(sizeof(T)); \\\n-      validate_size(cnt, sizeof(T)); \\\n-      if (swap_bytes) { \\\n-        for (size_t i = 0; i \u003C cnt; i\u002B\u002B) { \\\n-          x[i] = fn_swap(*reinterpret_cast\u003Cconst T *\u003E(data \u002B pos)); \\\n-          pos \u002B= sizeof(T); \\\n-        } \\\n-      } else { \\\n-        memcpy( \\\n-          reinterpret_cast\u003Cvoid *\u003E(x), reinterpret_cast\u003Cconst void *\u003E(data \u002B pos), \\\n-          cnt * sizeof(T)); \\\n-        pos \u002B= cnt * sizeof(T); \\\n\u002B  if (cnt \u003E 0) { \\\n\u002B    align(sizeof(T)); \\\n\u002B    validate_size(cnt, sizeof(T)); \\\n\u002B    if (swap_bytes) { \\\n\u002B      for (size_t i = 0; i \u003C cnt; i\u002B\u002B) { \\\n\u002B        x[i] = fn_swap(*reinterpret_cast\u003Cconst T *\u003E(data \u002B pos)); \\\n\u002B        pos \u002B= sizeof(T); \\\n       } \\\n\u002B    } else { \\\n\u002B      memcpy( \\\n\u002B        reinterpret_cast\u003Cvoid *\u003E(x), reinterpret_cast\u003Cconst void *\u003E(data \u002B pos), \\\n\u002B        cnt * sizeof(T)); \\\n\u002B      pos \u002B= cnt * sizeof(T); \\\n     } \\\n\u002B  } \\\n }\n\u002B  // *INDENT-ON*\n\u002B\n   DESER8_A(char);\n   DESER8_A(int8_t);\n   DESER8_A(uint8_t);\n",
    "IsBackported": false
  },
  {
    "Repository": "ros2cli",
    "SHA": "ddd614636911c7ffbd11129c0d3581577bccda1d",
    "RawMessage": "Remove TODO for OpenSplice DDS issue. (#928)",
    "Changes": "diff --git ros2topic/test/test_echo_pub.py ros2topic/test/test_echo_pub.py\nindex 6182073..3058385 100644\n--- ros2topic/test/test_echo_pub.py\n\u002B\u002B\u002B ros2topic/test/test_echo_pub.py\n@@ -73,11 \u002B73,6 @@ def generate_test_description():\n \n class TestROS2TopicEchoPub(unittest.TestCase):\n \n-    # TODO(hidmic): investigate why making use of the same rclpy node, executor\n-    #               and context for all tests on a per rmw implementation basis\n-    #               makes them fail on Linux-aarch64 when using \u0027rmw_opensplice_cpp\u0027.\n-    #               Presumably, interfaces creation/destruction and/or executor spinning\n-    #               on one test is affecting the other.\n     def setUp(self):\n         self.context = rclpy.context.Context()\n         rclpy.init(context=self.context)\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "159ced49bb904511154d9f6e595b64e1f5c0d8c0",
    "RawMessage": "Fix an inherent race in execution vs. destruction. (#1150)",
    "Changes": "diff --git rclpy/rclpy/executors.py rclpy/rclpy/executors.py\nindex 6f31879..c70a266 100644\n--- rclpy/rclpy/executors.py\n\u002B\u002B\u002B rclpy/rclpy/executors.py\n@@ -347,75 \u002B347,119 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n         raise NotImplementedError()\n \n     def _take_timer(self, tmr):\n-        with tmr.handle:\n-            tmr.handle.call_timer()\n-        return ()\n\u002B        try:\n\u002B            with tmr.handle:\n\u002B                tmr.handle.call_timer()\n\u002B\n\u002B                async def _execute():\n\u002B                    await await_or_execute(tmr.callback)\n\u002B                return _execute\n\u002B        except InvalidHandle:\n\u002B            # Timer is a Destroyable, which means that on __enter__ it can throw an\n\u002B            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n\u002B            # by just returning an empty argument, which means we will skip doing any real work\n\u002B            # in _execute_timer below\n\u002B            pass\n \n-    async def _execute_timer(self, tmr):\n-        await await_or_execute(tmr.callback)\n\u002B        return None\n \n     def _take_subscription(self, sub):\n-        with sub.handle:\n-            msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n-            if msg_info is not None:\n\u002B        try:\n\u002B            with sub.handle:\n\u002B                msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n\u002B                if msg_info is None:\n\u002B                    return None\n\u002B\n                 if sub._callback_type is Subscription.CallbackType.MessageOnly:\n-                    return (msg_info[0], )\n\u002B                    msg_tuple = (msg_info[0], )\n                 else:\n-                    return msg_info\n-        return ()\n\u002B                    msg_tuple = msg_info\n\u002B\n\u002B                async def _execute():\n\u002B                    await await_or_execute(sub.callback, *msg_tuple)\n\u002B\n\u002B                return _execute\n\u002B        except InvalidHandle:\n\u002B            # Subscription is a Destroyable, which means that on __enter__ it can throw an\n\u002B            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n\u002B            # by just returning an empty argument, which means we will skip doing any real work\n\u002B            # in _execute_subscription below\n\u002B            pass\n \n-    async def _execute_subscription(self, sub, *args):\n-        if args:\n-            await await_or_execute(sub.callback, *args)\n\u002B        return None\n \n     def _take_client(self, client):\n-        with client.handle:\n-            return (client.handle.take_response(client.srv_type.Response), )\n\u002B        try:\n\u002B            with client.handle:\n\u002B                header_and_response = client.handle.take_response(client.srv_type.Response)\n \n-    async def _execute_client(self, client, seq_and_response):\n-        header, response = seq_and_response\n-        if header is not None:\n-            try:\n-                sequence = header.request_id.sequence_number\n-                future = client.get_pending_request(sequence)\n-            except KeyError:\n-                # The request was cancelled\n-                pass\n-            else:\n-                future._set_executor(self)\n-                future.set_result(response)\n\u002B            async def _execute():\n\u002B                header, response = header_and_response\n\u002B                if header is None:\n\u002B                    return\n\u002B                try:\n\u002B                    sequence = header.request_id.sequence_number\n\u002B                    future = client.get_pending_request(sequence)\n\u002B                except KeyError:\n\u002B                    # The request was cancelled\n\u002B                    pass\n\u002B                else:\n\u002B                    future._set_executor(self)\n\u002B                    future.set_result(response)\n\u002B            return _execute\n\u002B\n\u002B        except InvalidHandle:\n\u002B            # Client is a Destroyable, which means that on __enter__ it can throw an\n\u002B            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n\u002B            # by just returning an empty argument, which means we will skip doing any real work\n\u002B            # in _execute_client below\n\u002B            pass\n\u002B\n\u002B        return None\n \n     def _take_service(self, srv):\n-        with srv.handle:\n-            request_and_header = srv.handle.service_take_request(srv.srv_type.Request)\n-        return (request_and_header, )\n-\n-    async def _execute_service(self, srv, request_and_header):\n-        if request_and_header is None:\n-            return\n-        (request, header) = request_and_header\n-        if request:\n-            response = await await_or_execute(srv.callback, request, srv.srv_type.Response())\n-            srv.send_response(response, header)\n\u002B        try:\n\u002B            with srv.handle:\n\u002B                request_and_header = srv.handle.service_take_request(srv.srv_type.Request)\n\u002B\n\u002B            async def _execute():\n\u002B                (request, header) = request_and_header\n\u002B                if header is None:\n\u002B                    return\n\u002B\n\u002B                response = await await_or_execute(srv.callback, request, srv.srv_type.Response())\n\u002B                srv.send_response(response, header)\n\u002B            return _execute\n\u002B        except InvalidHandle:\n\u002B            # Service is a Destroyable, which means that on __enter__ it can throw an\n\u002B            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n\u002B            # by just returning an empty argument, which means we will skip doing any real work\n\u002B            # in _execute_service below\n\u002B            pass\n\u002B\n\u002B        return None\n \n     def _take_guard_condition(self, gc):\n         gc._executor_triggered = False\n-        return ()\n \n-    async def _execute_guard_condition(self, gc):\n-        await await_or_execute(gc.callback)\n\u002B        async def _execute():\n\u002B            await await_or_execute(gc.callback)\n\u002B        return _execute\n\u002B\n\u002B    def _take_waitable(self, waitable):\n\u002B        data = waitable.take_data()\n \n-    async def _execute_waitable(self, waitable, data):\n-        for future in waitable._futures:\n-            future._set_executor(self)\n-        await waitable.execute(data)\n\u002B        async def _execute():\n\u002B            for future in waitable._futures:\n\u002B                future._set_executor(self)\n\u002B            await waitable.execute(data)\n\u002B        return _execute\n \n     def _make_handler(\n         self,\n         entity: WaitableEntityType,\n         node: \u0027Node\u0027,\n         take_from_wait_list: Callable,\n-        call_coroutine: Coroutine\n     ) -\u003E Task:\n         \u0022\u0022\u0022\n         Make a handler that performs work on an entity.\n@@ -423,7 \u002B467,6 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n         :param entity: An entity to wait on.\n         :param node: The node associated with the entity.\n         :param take_from_wait_list: Makes the entity to stop appearing in the wait list.\n-        :param call_coroutine: Does the work the entity is ready for\n         \u0022\u0022\u0022\n         # Mark this so it doesn\u0027t get added back to the wait list\n         entity._executor_event = True\n@@ -435,14 \u002B478,17 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n                 gc.trigger()\n                 return\n             with work_tracker:\n-                arg = take_from_wait_list(entity)\n\u002B                # The take_from_wait_list method here is expected to return either an async def\n\u002B                # method or None if there is no work to do.\n\u002B                call_coroutine = take_from_wait_list(entity)\n \n                 # Signal that this has been \u0027taken\u0027 and can be added back to the wait list\n                 entity._executor_event = False\n                 gc.trigger()\n \n                 try:\n-                    await call_coroutine(entity, *arg)\n\u002B                    if call_coroutine is not None:\n\u002B                        await call_coroutine()\n                 finally:\n                     entity.callback_group.ending_execution(entity)\n                     # Signal that work has been done so the next callback in a mutually exclusive\n@@ -642,8 \u002B688,7 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n                         # Only check waitables that were added to the wait set\n                         if wt in waitables and wt.is_ready(wait_set):\n                             if wt.callback_group.can_execute(wt):\n-                                handler = self._make_handler(\n-                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n\u002B                                handler = self._make_handler(wt, node, self._take_waitable)\n                                 yielded_work = True\n                                 yield handler, wt, node\n \n@@ -654,41 \u002B699,35 @@ class Executor(ContextManager[\u0027Executor\u0027]):\n                         # Check timer is ready to workaround rcl issue with cancelled timers\n                         if tmr.handle.is_timer_ready():\n                             if tmr.callback_group.can_execute(tmr):\n-                                handler = self._make_handler(\n-                                    tmr, node, self._take_timer, self._execute_timer)\n\u002B                                handler = self._make_handler(tmr, node, self._take_timer)\n                                 yielded_work = True\n                                 yield handler, tmr, node\n \n                 for sub in node.subscriptions:\n                     if sub.handle.pointer in subs_ready:\n                         if sub.callback_group.can_execute(sub):\n-                            handler = self._make_handler(\n-                                sub, node, self._take_subscription, self._execute_subscription)\n\u002B                            handler = self._make_handler(sub, node, self._take_subscription)\n                             yielded_work = True\n                             yield handler, sub, node\n \n                 for gc in node.guards:\n                     if gc._executor_triggered:\n                         if gc.callback_group.can_execute(gc):\n-                            handler = self._make_handler(\n-                                gc, node, self._take_guard_condition,\n-                                self._execute_guard_condition)\n\u002B                            handler = self._make_handler(gc, node, self._take_guard_condition)\n                             yielded_work = True\n                             yield handler, gc, node\n \n                 for client in node.clients:\n                     if client.handle.pointer in clients_ready:\n                         if client.callback_group.can_execute(client):\n-                            handler = self._make_handler(\n-                                client, node, self._take_client, self._execute_client)\n\u002B                            handler = self._make_handler(client, node, self._take_client)\n                             yielded_work = True\n                             yield handler, client, node\n \n                 for srv in node.services:\n                     if srv.handle.pointer in services_ready:\n                         if srv.callback_group.can_execute(srv):\n-                            handler = self._make_handler(\n-                                srv, node, self._take_service, self._execute_service)\n\u002B                            handler = self._make_handler(srv, node, self._take_service)\n                             yielded_work = True\n                             yield handler, srv, node\n \n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "56db2ba9fcc85ead292b0c3403cf27dba41854e2",
    "RawMessage": "update maintainers (#568)",
    "Changes": "diff --git ros2action/package.xml ros2action/package.xml\nindex a615a1a..66b165b 100644\n--- ros2action/package.xml\n\u002B\u002B\u002B ros2action/package.xml\n@@ -6,7 \u002B6,8 @@\n   \u003Cdescription\u003E\n     The action command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n   \u003Cauthor email=\u0022jacob@openrobotics.org\u0022\u003EJacob Perron\u003C/author\u003E\ndiff --git ros2action/setup.py ros2action/setup.py\nindex 080a396..0830929 100644\n--- ros2action/setup.py\n\u002B\u002B\u002B ros2action/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Jacob Perron\u0027,\n     author_email=\u0027jacob@openrobotics.org\u0027,\n-    maintainer=\u0027Jacob Perron\u0027,\n-    maintainer_email=\u0027jacob@openrobotics.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2action\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2cli/package.xml ros2cli/package.xml\nindex b5c99fa..d840b24 100644\n--- ros2cli/package.xml\n\u002B\u002B\u002B ros2cli/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     Framework for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\t\n\u002B\n   \u003Cexec_depend\u003Epython3-argcomplete\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Epython3-importlib-metadata\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Epython3-netifaces\u003C/exec_depend\u003E\ndiff --git ros2cli/setup.py ros2cli/setup.py\nindex 84361e9..cbe1631 100644\n--- ros2cli/setup.py\n\u002B\u002B\u002B ros2cli/setup.py\n@@ -24,8 \u002B24,8 @@ setup(\n     zip_safe=False,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2cli\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2component/package.xml ros2component/package.xml\nindex 29d15d2..6226cc4 100644\n--- ros2component/package.xml\n\u002B\u002B\u002B ros2component/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The component command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/author\u003E\t\n\u002B\n   \u003Cexec_depend\u003Eament_index_python\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Ecomposition_interfaces\u003C/exec_depend\u003E\n   \u003Cexec_depend\u003Ercl_interfaces\u003C/exec_depend\u003E\ndiff --git ros2component/setup.py ros2component/setup.py\nindex 5692c3b..211641b 100644\n--- ros2component/setup.py\n\u002B\u002B\u002B ros2component/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Michel Hidalgo\u0027,\n     author_email=\u0027michel@ekumenlabs.com\u0027,\n-    maintainer=\u0027Michel Hidalgo\u0027,\n-    maintainer_email=\u0027michel@ekumenlabs.com\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2component\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2doctor/package.xml ros2doctor/package.xml\nindex e7b712e..0e9867e 100644\n--- ros2doctor/package.xml\n\u002B\u002B\u002B ros2doctor/package.xml\n@@ -5,8 \u002B5,11 @@\n   \u003Cversion\u003E0.9.5\u003C/version\u003E\n   \u003Cdescription\u003EA command line tool to check potential issues in a ROS 2 system\u003C/description\u003E\n   \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Eament_index_python\u003C/exec_depend\u003E\ndiff --git ros2interface/package.xml ros2interface/package.xml\nindex 638df69..08e1c2b 100644\n--- ros2interface/package.xml\n\u002B\u002B\u002B ros2interface/package.xml\n@@ -6,9 \u002B6,13 @@\n   \u003Cdescription\u003E\n     The interface command for ROS 2 command line tools\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022jacob@osrfoundation.org\u0022\u003EJacob Perron\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor\u003ESiddharth Kucheria\u003C/author\u003E\n\u002B  \u003Cauthor email=\u0022jacob@osrfoundation.org\u0022\u003EJacob Perron\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Eament_index_python\u003C/exec_depend\u003E\ndiff --git ros2interface/setup.py ros2interface/setup.py\nindex 63486d0..30d1e3f 100644\n--- ros2interface/setup.py\n\u002B\u002B\u002B ros2interface/setup.py\n@@ -14,10 \u002B14,10 @@ setup(\n     ],\n     install_requires=[\u0027ros2cli\u0027],\n     zip_safe=True,\n-    author=\u0027Siddharth Kucheria\u0027,\n-    author_email=\u0027kucheria@osrfoundation.org\u0027,\n-    maintainer=\u0027Jacob Perron\u0027,\n-    maintainer_email=\u0027jacob@osrfoundation.org\u0027,\n\u002B    author=\u0027Siddharth Kucheria, Jacob Perron\u0027,\n\u002B    author_email=\u0027kucheria@osrfoundation.org, jacob@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2interface\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2lifecycle/package.xml ros2lifecycle/package.xml\nindex 123d263..be04500 100644\n--- ros2lifecycle/package.xml\n\u002B\u002B\u002B ros2lifecycle/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The lifecycle command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Erclpy\u003C/depend\u003E\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \ndiff --git ros2lifecycle/setup.py ros2lifecycle/setup.py\nindex 3ddb657..3cd56c5 100644\n--- ros2lifecycle/setup.py\n\u002B\u002B\u002B ros2lifecycle/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2lifecycle\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2lifecycle_test_fixtures/package.xml ros2lifecycle_test_fixtures/package.xml\nindex 9b1c064..8c1345c 100644\n--- ros2lifecycle_test_fixtures/package.xml\n\u002B\u002B\u002B ros2lifecycle_test_fixtures/package.xml\n@@ -4,9 \u002B4,12 @@\n   \u003Cname\u003Eros2lifecycle_test_fixtures\u003C/name\u003E\n   \u003Cversion\u003E0.9.5\u003C/version\u003E\n   \u003Cdescription\u003EPackage containing fixture nodes for ros2lifecycle tests\u003C/description\u003E\n-  \u003Cmaintainer email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022michel@ekumenlabs.com\u0022\u003EMichel Hidalgo\u003C/author\u003E\n\u002B\n   \u003Cbuildtool_depend\u003Eament_cmake\u003C/buildtool_depend\u003E\n \n   \u003Cdepend\u003Erclcpp\u003C/depend\u003E\ndiff --git ros2multicast/package.xml ros2multicast/package.xml\nindex 8a962f8..e3c3aef 100644\n--- ros2multicast/package.xml\n\u002B\u002B\u002B ros2multicast/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The multicast command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Ctest_depend\u003Eament_copyright\u003C/test_depend\u003E\ndiff --git ros2multicast/setup.py ros2multicast/setup.py\nindex de259b2..eb6d765 100644\n--- ros2multicast/setup.py\n\u002B\u002B\u002B ros2multicast/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2multicast\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2node/package.xml ros2node/package.xml\nindex 00c6993..68ef999 100644\n--- ros2node/package.xml\n\u002B\u002B\u002B ros2node/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The node command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Ctest_depend\u003Eament_copyright\u003C/test_depend\u003E\ndiff --git ros2node/setup.py ros2node/setup.py\nindex a2e6535..f10950d 100644\n--- ros2node/setup.py\n\u002B\u002B\u002B ros2node/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2node\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2param/package.xml ros2param/package.xml\nindex 43f5a0f..e5e7646 100644\n--- ros2param/package.xml\n\u002B\u002B\u002B ros2param/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The param command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Ercl_interfaces\u003C/depend\u003E\n   \u003Cdepend\u003Erclpy\u003C/depend\u003E\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\ndiff --git ros2param/setup.py ros2param/setup.py\nindex e59e3a3..4e89aa3 100644\n--- ros2param/setup.py\n\u002B\u002B\u002B ros2param/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2param\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2pkg/package.xml ros2pkg/package.xml\nindex dc9775a..f89ef10 100644\n--- ros2pkg/package.xml\n\u002B\u002B\u002B ros2pkg/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The pkg command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Eament_index_python\u003C/exec_depend\u003E\ndiff --git ros2pkg/setup.py ros2pkg/setup.py\nindex d8dc892..626a448 100644\n--- ros2pkg/setup.py\n\u002B\u002B\u002B ros2pkg/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2pkg\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2run/package.xml ros2run/package.xml\nindex 75dff6d..bc53199 100644\n--- ros2run/package.xml\n\u002B\u002B\u002B ros2run/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The run command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Eros2pkg\u003C/exec_depend\u003E\ndiff --git ros2run/setup.py ros2run/setup.py\nindex 16325ce..2524db1 100644\n--- ros2run/setup.py\n\u002B\u002B\u002B ros2run/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2run\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2service/package.xml ros2service/package.xml\nindex 949381a..020844e 100644\n--- ros2service/package.xml\n\u002B\u002B\u002B ros2service/package.xml\n@@ -6,9 \u002B6,12 @@\n   \u003Cdescription\u003E\n     The service command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n \n\u002B  \u003Cauthor email=\u0022william@osrfoundation.org\u0022\u003EWilliam Woodall\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Erclpy\u003C/depend\u003E\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \ndiff --git ros2service/setup.py ros2service/setup.py\nindex d350b00..641880d 100644\n--- ros2service/setup.py\n\u002B\u002B\u002B ros2service/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027William Woodall\u0027,\n     author_email=\u0027william@osrfoundation.org\u0027,\n-    maintainer=\u0027William Woodall\u0027,\n-    maintainer_email=\u0027william@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2service\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\ndiff --git ros2topic/package.xml ros2topic/package.xml\nindex 5d32d46..1131b22 100644\n--- ros2topic/package.xml\n\u002B\u002B\u002B ros2topic/package.xml\n@@ -6,10 \u002B6,13 @@\n   \u003Cdescription\u003E\n     The topic command for ROS 2 command line tools.\n   \u003C/description\u003E\n-  \u003Cmaintainer email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022clairewang@openrobotics.org\u0022\u003EClaire Wang\u003C/maintainer\u003E\n\u002B  \u003Cmaintainer email=\u0022mabel@openrobotics.org\u0022\u003EMabel Zhang\u003C/maintainer\u003E\n   \u003Clicense\u003EApache License 2.0\u003C/license\u003E\n   \u003Clicense\u003EBSD\u003C/license\u003E  \u003C!-- ros2topic/verb/delay.py|hz.py|bw.py are BSD --\u003E\n \n\u002B  \u003Cauthor email=\u0022dthomas@osrfoundation.org\u0022\u003EDirk Thomas\u003C/author\u003E\n\u002B\n   \u003Cdepend\u003Eros2cli\u003C/depend\u003E\n \n   \u003Cexec_depend\u003Epython3-numpy\u003C/exec_depend\u003E\ndiff --git ros2topic/setup.py ros2topic/setup.py\nindex 7ff4090..488ef33 100644\n--- ros2topic/setup.py\n\u002B\u002B\u002B ros2topic/setup.py\n@@ -16,8 \u002B16,8 @@ setup(\n     zip_safe=True,\n     author=\u0027Dirk Thomas\u0027,\n     author_email=\u0027dthomas@osrfoundation.org\u0027,\n-    maintainer=\u0027Dirk Thomas\u0027,\n-    maintainer_email=\u0027dthomas@osrfoundation.org\u0027,\n\u002B    maintainer=\u0027Claire Wang, Mabel Zhang\u0027,\n\u002B    maintainer_email=\u0027clairewang@openrobotics.org, mabel@openrobotics.org\u0027,\n     url=\u0027https://github.com/ros2/ros2cli/tree/master/ros2topic\u0027,\n     download_url=\u0027https://github.com/ros2/ros2cli/releases\u0027,\n     keywords=[],\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "90461677df74ed2dc3c5a4802a156a16f9082820",
    "RawMessage": "Updates to rcutils to make rosdoc2 generation happier. (#416)",
    "Changes": "diff --git Doxyfile Doxyfile\nindex d5b10f6..01cf2df 100644\n--- Doxyfile\n\u002B\u002B\u002B Doxyfile\n@@ -5,10 \u002B5,8 @@ PROJECT_NUMBER         = master\n PROJECT_BRIEF          = \u0022C API providing common utilities and data structures.\u0022\n \n # Use these lines to include the generated logging_macro.h (update install path if needed)\n-#INPUT                  = README.md ../../../install_isolated/rcutils/include\n-#STRIP_FROM_PATH        = /Users/william/ros2_ws/install_isolated/rcutils/include\n # Otherwise just generate for the local (non-generated header files)\n-INPUT                  = README.md ./include\n\u002BINPUT                  = CONTRIBUTING.md README.md QUALITY_DECLARATION.md ./include\n EXCLUDE_PATTERNS       = */stdatomic_helper/*\n USE_MDFILE_AS_MAINPAGE = README.md\n RECURSIVE              = YES\n@@ -26,6 \u002B24,7 @@ PREDEFINED             \u002B= RCUTILS_PUBLIC=\n PREDEFINED             \u002B= RCUTILS_PUBLIC_TYPE=\n PREDEFINED             \u002B= RCUTILS_WARN_UNUSED=\n PREDEFINED             \u002B= RCUTILS_ENABLE_FAULT_INJECTION=\n\u002BPREDEFINED             \u002B= DOXYGEN_ONLY\n \n # Tag files that do not exist will produce a warning and cross-project linking will not work.\n TAGFILES \u002B= \u0022../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/\u0022\ndiff --git include/rcutils/logging.h include/rcutils/logging.h\nindex aa9efdc..42eb240 100644\n--- include/rcutils/logging.h\n\u002B\u002B\u002B include/rcutils/logging.h\n@@ -215,12 \u002B215,12 @@ rcutils_logging_severity_level_from_string(\n  * \\param[in] args The variable argument list\n  */\n typedef void (* rcutils_logging_output_handler_t)(\n-  const rcutils_log_location_t *,  // location\n-  int,  // severity\n-  const char *,  // name\n-  rcutils_time_point_value_t,  // timestamp\n-  const char *,  // format\n-  va_list *  // args\n\u002B  const rcutils_log_location_t * location,\n\u002B  int severity,\n\u002B  const char * name,\n\u002B  rcutils_time_point_value_t timestamp,\n\u002B  const char * format,\n\u002B  va_list * args\n );\n \n /// Get the current output handler.\ndiff --git include/rcutils/sha256.h include/rcutils/sha256.h\nindex 3c0edd4..546622a 100644\n--- include/rcutils/sha256.h\n\u002B\u002B\u002B include/rcutils/sha256.h\n@@ -12,12 \u002B12,6 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-/// \\file Provides a simple SHA256 algorithm for hashing.\n-/// This implementation makes no security guarantees, its use case\n-/// is for non-sensitive comparison of message digests\n-/// Implementation originally copied from Brad Conte\n-/// https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c\n-\n /** \\file sha256.h\n  *  \\brief SHA256 implementation\n  *\n@@ -28,6 \u002B22,8 @@\n  *  Algorithm specification can be found here:\n  *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf\n  *  This implementation uses little endian byte order.\n\u002B *  This implementation makes no security guarantees, its use case if for\n\u002B *  non-sensitive comparison of message digests.\n  */\n \n #ifndef RCUTILS__SHA256_H_\n@@ -83,10 \u002B79,19 @@ void rcutils_sha256_update(rcutils_sha256_ctx_t * ctx, const uint8_t * data, siz\n  * \\param[out] output_hash Calculated sha256 message digest to be filled\n  * \\return void\n  */\n\u002B#ifdef DOXYGEN_ONLY\n\u002B// One of the tools used by rosdoc2 misunderstands uint8_t[] as a uint8_t,\n\u002B// so make it a pointer for documentation purposes.\n\u002BRCUTILS_PUBLIC\n\u002Bvoid rcutils_sha256_final(\n\u002B  rcutils_sha256_ctx_t * ctx,\n\u002B  uint8_t * output_hash);\n\u002B#else\n RCUTILS_PUBLIC\n void rcutils_sha256_final(\n   rcutils_sha256_ctx_t * ctx,\n   uint8_t output_hash[RCUTILS_SHA256_BLOCK_SIZE]);\n\u002B#endif\n \n #ifdef __cplusplus\n }\ndiff --git include/rcutils/types/hash_map.h include/rcutils/types/hash_map.h\nindex 55f43bf..25b69ee 100644\n--- include/rcutils/types/hash_map.h\n\u002B\u002B\u002B include/rcutils/types/hash_map.h\n@@ -44,7 \u002B44,7 @@ typedef struct RCUTILS_PUBLIC_TYPE rcutils_hash_map_s\n  * \\return A hash value for the provided string\n  */\n typedef size_t (* rcutils_hash_map_key_hasher_t)(\n-  const void *  // key to hash\n\u002B  const void * key\n );\n \n /// The function signature for a key comparison function.\n@@ -56,8 \u002B56,8 @@ typedef size_t (* rcutils_hash_map_key_hasher_t)(\n  * \\return Zero if val1 == val2.\n  */\n typedef int (* rcutils_hash_map_key_cmp_t)(\n-  const void *,  // val1\n-  const void *  // val2\n\u002B  const void * val1,\n\u002B  const void * val2\n );\n \n /**\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw",
    "SHA": "c9af228218e73ac2107a4aeebb05f9bde3d51714",
    "RawMessage": "Update publisher/subscription QoS query API documentation. (#263)",
    "Changes": "diff --git rmw/include/rmw/rmw.h rmw/include/rmw/rmw.h\nindex f9d19cb..a57efc1 100644\n--- rmw/include/rmw/rmw.h\n\u002B\u002B\u002B rmw/include/rmw/rmw.h\n@@ -470,14 \u002B470,26 @@ rmw_publisher_count_matched_subscriptions(\n  * depends on the underlying rmw implementation.\n  * If the underlying setting in use can\u0027t be represented in ROS terms,\n  * it will be set to RMW_*_UNKNOWN.\n- * The value of avoid_ros_namespace_conventions field is not resolved\n- * with this function. The rcl function rcl_publisher_get_actual_qos\n- * resolves it.\n\u002B *\n\u002B * \\note The value of avoid_ros_namespace_conventions field is not resolved\n\u002B *   with this function. The rcl function \u0060rcl_publisher_get_actual_qos()\u0060\n\u002B *   resolves it.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe [1]\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n  *\n  * \\param[in] publisher the publisher object to inspect\n  * \\param[out] qos the actual qos settings\n  * \\return \u0060RMW_RET_OK\u0060 if successful, or\n  * \\return \u0060RMW_RET_INVALID_ARGUMENT\u0060 if either argument is null, or\n\u002B * \\return \u0060RMW_RET_INCORRECT_RMW_IMPLEMENTATION\u0060 if publisher\n\u002B *   implementation identifier does not match, or\n  * \\return \u0060RMW_RET_ERROR\u0060 if an unexpected error occurs.\n  */\n RMW_PUBLIC\n@@ -775,9 \u002B787,19 @@ rmw_subscription_count_matched_publishers(\n  * depends on the underlying rmw implementation.\n  * If the underlying setting in use can\u0027t be represented in ROS terms,\n  * it will be set to RMW_*_UNKNOWN.\n- * The value of avoid_ros_namespace_conventions field is not resolved\n- * with this function. The rcl function rcl_subscription_get_actual_qos\n- * resolves it.\n\u002B *\n\u002B * \\note The value of avoid_ros_namespace_conventions field is not resolved\n\u002B *   with this function. The rcl function \u0060rcl_subscription_get_actual_qos()\u0060\n\u002B *   resolves it.\n\u002B *\n\u002B * \u003Chr\u003E\n\u002B * Attribute          | Adherence\n\u002B * ------------------ | -------------\n\u002B * Allocates Memory   | Maybe [1]\n\u002B * Thread-Safe        | No\n\u002B * Uses Atomics       | Maybe [1]\n\u002B * Lock-Free          | Maybe [1]\n\u002B * \u003Ci\u003E[1] rmw implementation defined, check the implementation documentation\u003C/i\u003E\n  *\n  * \\param[in] subscription the subscription object to inspect\n  * \\param[out] qos the actual qos settings\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "rviz",
    "SHA": "a9a4d9e8ff09de9b134d022a3ec856ee0c3d3729",
    "RawMessage": "Make rviz1_to_rviz2.py accept configs with missing values (#945)",
    "Changes": "diff --git rviz2/scripts/rviz1_to_rviz2.py rviz2/scripts/rviz1_to_rviz2.py\nindex 082ae603..62762f5e 100644\n--- rviz2/scripts/rviz1_to_rviz2.py\n\u002B\u002B\u002B rviz2/scripts/rviz1_to_rviz2.py\n@@ -73,18 \u002B73,18 @@ def migrate_panel_time(panel_dict):\n \n def migrate_visualization_manager(vm_dict):\n     vm_rviz2 = {\n-        \u0027Class\u0027: str(vm_dict[\u0027Class\u0027]),\n\u002B        \u0027Class\u0027: str(vm_dict.get(\u0027Class\u0027, \u0027\u0027)),\n         \u0027Displays\u0027: migrate_displays(vm_dict[\u0027Displays\u0027]),\n-        \u0027Enabled\u0027: bool(vm_dict[\u0027Enabled\u0027]),\n-        \u0027Name\u0027: str(vm_dict[\u0027Name\u0027]),\n\u002B        \u0027Enabled\u0027: bool(vm_dict.get(\u0027Enabled\u0027, True)),\n\u002B        \u0027Name\u0027: str(vm_dict.get(\u0027Name\u0027, \u0027root\u0027)),\n         \u0027Tools\u0027: migrate_visualization_manager_tools(vm_dict[\u0027Tools\u0027]),\n-        \u0027Value\u0027: bool(vm_dict[\u0027Value\u0027]),\n\u002B        \u0027Value\u0027: bool(vm_dict.get(\u0027Value\u0027, True)),\n         \u0027Views\u0027: migrate_visualization_manager_views(vm_dict[\u0027Views\u0027]),\n         \u0027Transformation\u0027: {\u0027Current\u0027: {\u0027Class\u0027: \u0027rviz_default_plugins/TF\u0027}},\n         \u0027Global Options\u0027: {\n-            \u0027Background Color\u0027: str(vm_dict[\u0027Global Options\u0027][\u0027Background Color\u0027]),\n-            \u0027Fixed Frame\u0027: str(vm_dict[\u0027Global Options\u0027][\u0027Fixed Frame\u0027]),\n-            \u0027Frame Rate\u0027: int(vm_dict[\u0027Global Options\u0027][\u0027Frame Rate\u0027]),\n\u002B            \u0027Background Color\u0027: str(vm_dict.get(\u0027Global Options\u0027, {}).get(\u0027Background Color\u0027, \u002748; 48; 48\u0027)),\n\u002B            \u0027Fixed Frame\u0027: str(vm_dict.get(\u0027Global Options\u0027, {}).get(\u0027Fixed Frame\u0027, \u0027map\u0027)),\n\u002B            \u0027Frame Rate\u0027: int(vm_dict.get(\u0027Global Options\u0027, {}).get(\u0027Frame Rate\u0027, 30)),\n         }\n     }\n     return vm_rviz2\n@@ -310,7 \u002B310,7 @@ def migrate_visualization_manager_tools(tools_list):\n         elif name == \u0027rviz/SetInitialPose\u0027:\n             rviz2 = {\n                 \u0027Class\u0027: \u0027rviz_default_plugins/SetInitialPose\u0027,\n-                \u0027Topic\u0027: migrate_topic(name = tool_dict[\u0027Topic\u0027]),\n\u002B                \u0027Topic\u0027: migrate_topic(name = tool_dict.get(\u0027Topic\u0027, \u0027/initialpose\u0027)),\n                 }\n             if \u0027X std deviation\u0027 in tool_dict:\n                 rviz2[\u0027Covariance x\u0027] = float(tool_dict[\u0027X std deviation\u0027])**2\n@@ -323,15 \u002B323,15 @@ def migrate_visualization_manager_tools(tools_list):\n         elif name == \u0027rviz/SetGoal\u0027:\n             rviz2 = {\n                 \u0027Class\u0027: \u0027rviz_default_plugins/SetGoal\u0027,\n-                \u0027Topic\u0027: migrate_topic(name = tool_dict[\u0027Topic\u0027]),\n\u002B                \u0027Topic\u0027: migrate_topic(name = tool_dict.get(\u0027Topic\u0027, \u0027/goal_pose\u0027)),\n                 }\n             del rviz2[\u0027Topic\u0027][\u0027Filter size\u0027]\n             tools_rviz2.append(rviz2)\n         elif name == \u0027rviz/PublishPoint\u0027:\n             rviz2 = {\n                 \u0027Class\u0027: \u0027rviz_default_plugins/PublishPoint\u0027,\n-                \u0027Single click\u0027: bool(tool_dict[\u0027Single click\u0027]),\n-                \u0027Topic\u0027: migrate_topic(name = tool_dict[\u0027Topic\u0027]),\n\u002B                \u0027Single click\u0027: bool(tool_dict.get(\u0027Single click\u0027, True)),\n\u002B                \u0027Topic\u0027: migrate_topic(name = tool_dict.get(\u0027Topic\u0027, \u0027/clicked_point\u0027)),\n                 }\n             del rviz2[\u0027Topic\u0027][\u0027Filter size\u0027]\n             tools_rviz2.append(rviz2)\ndiff --git rviz2/test/tools/configs/fuse_simple_tutorial.rviz rviz2/test/tools/configs/fuse_simple_tutorial.rviz\nnew file mode 100644\nindex 00000000..060b4456\n--- /dev/null\n\u002B\u002B\u002B rviz2/test/tools/configs/fuse_simple_tutorial.rviz\n@@ -0,0 \u002B1,112 @@\n\u002BPanels:\n\u002B- Class: rviz/Displays\n\u002B  Name: Displays\n\u002B  Property Tree Widget:\n\u002B    Expanded:\n\u002B    - /Odometry1/Covariance1/Position1\n\u002B    - /Odometry1/Covariance1/Orientation1\n\u002B  Tree Height: 675\n\u002B- Class: rviz/Selection\n\u002B  Name: Selection\n\u002B- Class: rviz/Tool Properties\n\u002B  Expanded:\n\u002B  - /2D Pose Estimate1\n\u002B  - /2D Nav Goal1\n\u002B  - /Publish Point1\n\u002B  Name: Tool Properties\n\u002B- Class: rviz/Views\n\u002B  Expanded:\n\u002B  - /Current View1\n\u002B  Name: Views\n\u002B- Class: rviz/Time\n\u002B  Name: Time\n\u002B- Class: rviz/Displays\n\u002B  Help Height: 70\n\u002B  Name: Displays\n\u002B  Property Tree Widget:\n\u002B    Expanded: null\n\u002B  Tree Height: 371\n\u002B- Class: rviz/Views\n\u002B  Expanded:\n\u002B  - /Current View1\n\u002B  Name: Views\n\u002BVisualization Manager:\n\u002B  Displays:\n\u002B  - Alpha: 0.5\n\u002B    Cell Size: 1\n\u002B    Class: rviz/Grid\n\u002B    Color: 160; 160; 164\n\u002B    Enabled: true\n\u002B    Line Style:\n\u002B      Line Width: 0.029999999329447746\n\u002B      Value: Lines\n\u002B    Name: Grid\n\u002B    Normal Cell Count: 0\n\u002B    Offset:\n\u002B      X: 0\n\u002B      Y: 0\n\u002B      Z: 0\n\u002B    Plane: XY\n\u002B    Plane Cell Count: 100\n\u002B    Reference Frame: \u003CFixed Frame\u003E\n\u002B    Value: true\n\u002B  - Angle Tolerance: 0.05000000074505806\n\u002B    Class: rviz/Odometry\n\u002B    Covariance:\n\u002B      Orientation:\n\u002B        Alpha: 0.20000000298023224\n\u002B        Color: 64; 84; 191\n\u002B        Color Style: Unique\n\u002B        Frame: Local\n\u002B        Offset: 1\n\u002B        Scale: 1\n\u002B        Value: true\n\u002B      Position:\n\u002B        Alpha: 0.10000000149011612\n\u002B        Color: 138; 226; 52\n\u002B        Scale: 1\n\u002B        Value: true\n\u002B      Value: false\n\u002B    Enabled: true\n\u002B    Keep: 10000\n\u002B    Name: Odometry\n\u002B    Position Tolerance: 0.10000000149011612\n\u002B    Queue Size: 10\n\u002B    Shape:\n\u002B      Alpha: 1\n\u002B      Axes Length: 1\n\u002B      Axes Radius: 0.10000000149011612\n\u002B      Color: 255; 25; 0\n\u002B      Head Length: 0.07500000298023224\n\u002B      Head Radius: 0.02500000037252903\n\u002B      Shaft Length: 0.25\n\u002B      Shaft Radius: 0.012500000186264515\n\u002B      Value: Arrow\n\u002B    Topic: /odom_filtered\n\u002B    Unreliable: false\n\u002B    Value: true\n\u002B  Global Options:\n\u002B    Fixed Frame: odom\n\u002B  Tools:\n\u002B  - Class: rviz/Interact\n\u002B  - Class: rviz/MoveCamera\n\u002B  - Class: rviz/Select\n\u002B  - Class: rviz/FocusCamera\n\u002B  - Class: rviz/Measure\n\u002B  - Class: rviz/SetInitialPose\n\u002B  - Class: rviz/SetGoal\n\u002B  - Class: rviz/PublishPoint\n\u002B  Views:\n\u002B    Current:\n\u002B      Angle: 0\n\u002B      Class: rviz/TopDownOrtho\n\u002B      Scale: 168.0491180419922\n\u002B      X: 2\n\u002B      Y: 0\n\u002B    Saved: null\n\u002BWindow Geometry:\n\u002B  Height: 1201\n\u002B  QMainWindow State: 000000ff00000000fd00000003000000000000015600000413fc020000000afb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000032e000000c900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000100044006900730070006c006100790073000000031c00000134000000c900fffffffb0000000a005600690065007700730100000371000000df000000a400ffffff000000010000010f00000413fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d00000413000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b2000000000000000000000003000007340000003efc0100000002fb0000000800540069006d0065010000000000000734000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c30000041300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000\n\u002B  Width: 1844\n\u002B  X: 72\n\u002B  Y: 27\ndiff --git rviz2/test/tools/configs/range_sensor_tutorial.rviz rviz2/test/tools/configs/range_sensor_tutorial.rviz\nnew file mode 100644\nindex 00000000..49684af8\n--- /dev/null\n\u002B\u002B\u002B rviz2/test/tools/configs/range_sensor_tutorial.rviz\n@@ -0,0 \u002B1,222 @@\n\u002BPanels:\n\u002B- Class: rviz/Displays\n\u002B  Help Height: 70\n\u002B  Name: Displays\n\u002B  Property Tree Widget:\n\u002B    Expanded:\n\u002B    - /True Robot Pose1/Shape1\n\u002B    - /Estimated Robot Pose1/Covariance1/Position1\n\u002B    Splitter Ratio: 0.6058823466300964\n\u002B  Tree Height: 757\n\u002B- Class: rviz/Selection\n\u002B  Name: Selection\n\u002B- Class: rviz/Tool Properties\n\u002B  Expanded:\n\u002B  - /2D Pose Estimate1\n\u002B  - /2D Nav Goal1\n\u002B  - /Publish Point1\n\u002B  Name: Tool Properties\n\u002B- Class: rviz/Views\n\u002B  Expanded:\n\u002B  - /Current View1\n\u002B  Name: Views\n\u002B- Class: rviz/Time\n\u002B  Name: Time\n\u002B  SyncSource: True Beacons\n\u002BVisualization Manager:\n\u002B  Displays:\n\u002B  - Alpha: 0.5\n\u002B    Cell Size: 1\n\u002B    Class: rviz/Grid\n\u002B    Color: 160; 160; 164\n\u002B    Enabled: false\n\u002B    Line Style:\n\u002B      Line Width: 0.029999999329447746\n\u002B      Value: Lines\n\u002B    Name: Grid\n\u002B    Normal Cell Count: 0\n\u002B    Offset:\n\u002B      X: 0\n\u002B      Y: 0\n\u002B      Z: 0\n\u002B    Plane: XY\n\u002B    Plane Cell Count: 100\n\u002B    Reference Frame: \u003CFixed Frame\u003E\n\u002B    Value: false\n\u002B  - Alpha: 1\n\u002B    Autocompute Intensity Bounds: true\n\u002B    Autocompute Value Bounds:\n\u002B      Max Value: 10\n\u002B      Min Value: -10\n\u002B      Value: true\n\u002B    Axis: Z\n\u002B    Channel Name: intensity\n\u002B    Class: rviz/PointCloud2\n\u002B    Color: 255; 25; 0\n\u002B    Color Transformer: FlatColor\n\u002B    Decay Time: 0\n\u002B    Enabled: true\n\u002B    Invert Rainbow: false\n\u002B    Max Color: 239; 41; 41\n\u002B    Min Color: 0; 0; 0\n\u002B    Name: True Beacons\n\u002B    Position Transformer: XYZ\n\u002B    Queue Size: 10\n\u002B    Selectable: true\n\u002B    Size (Pixels): 3\n\u002B    Size (m): 1.5\n\u002B    Style: Spheres\n\u002B    Topic: /true_beacons\n\u002B    Unreliable: false\n\u002B    Use Fixed Frame: true\n\u002B    Use rainbow: true\n\u002B    Value: true\n\u002B  - Angle Tolerance: 0.10000000149011612\n\u002B    Class: rviz/Odometry\n\u002B    Covariance:\n\u002B      Orientation:\n\u002B        Alpha: 0.5\n\u002B        Color: 255; 255; 127\n\u002B        Color Style: Unique\n\u002B        Frame: Local\n\u002B        Offset: 1\n\u002B        Scale: 1\n\u002B        Value: true\n\u002B      Position:\n\u002B        Alpha: 0.30000001192092896\n\u002B        Color: 204; 51; 204\n\u002B        Scale: 1\n\u002B        Value: true\n\u002B      Value: false\n\u002B    Enabled: true\n\u002B    Keep: 1\n\u002B    Name: True Robot Pose\n\u002B    Position Tolerance: 0.10000000149011612\n\u002B    Queue Size: 10\n\u002B    Shape:\n\u002B      Alpha: 1\n\u002B      Axes Length: 1\n\u002B      Axes Radius: 0.10000000149011612\n\u002B      Color: 255; 25; 0\n\u002B      Head Length: 5\n\u002B      Head Radius: 3\n\u002B      Shaft Length: 8\n\u002B      Shaft Radius: 1\n\u002B      Value: Arrow\n\u002B    Topic: /ground_truth\n\u002B    Unreliable: false\n\u002B    Value: true\n\u002B  - Alpha: 1\n\u002B    Autocompute Intensity Bounds: true\n\u002B    Autocompute Value Bounds:\n\u002B      Max Value: 0\n\u002B      Min Value: 0\n\u002B      Value: true\n\u002B    Axis: Z\n\u002B    Channel Name: intensity\n\u002B    Class: rviz/PointCloud2\n\u002B    Color: 138; 226; 52\n\u002B    Color Transformer: FlatColor\n\u002B    Decay Time: 0\n\u002B    Enabled: false\n\u002B    Invert Rainbow: false\n\u002B    Max Color: 255; 255; 255\n\u002B    Min Color: 0; 0; 0\n\u002B    Name: Prior Beacons\n\u002B    Position Transformer: XYZ\n\u002B    Queue Size: 10\n\u002B    Selectable: true\n\u002B    Size (Pixels): 3\n\u002B    Size (m): 2\n\u002B    Style: Spheres\n\u002B    Topic: /prior_beacons\n\u002B    Unreliable: false\n\u002B    Use Fixed Frame: true\n\u002B    Use rainbow: true\n\u002B    Value: false\n\u002B  - Alpha: 1\n\u002B    Autocompute Intensity Bounds: true\n\u002B    Autocompute Value Bounds:\n\u002B      Max Value: 10\n\u002B      Min Value: -10\n\u002B      Value: true\n\u002B    Axis: Z\n\u002B    Channel Name: intensity\n\u002B    Class: rviz/PointCloud2\n\u002B    Color: 237; 212; 0\n\u002B    Color Transformer: FlatColor\n\u002B    Decay Time: 0\n\u002B    Enabled: true\n\u002B    Invert Rainbow: false\n\u002B    Max Color: 255; 255; 255\n\u002B    Min Color: 0; 0; 0\n\u002B    Name: Estimated Beacons\n\u002B    Position Transformer: XYZ\n\u002B    Queue Size: 10\n\u002B    Selectable: true\n\u002B    Size (Pixels): 3\n\u002B    Size (m): 2.5\n\u002B    Style: Spheres\n\u002B    Topic: /state_estimation/beacon_publisher/beacons\n\u002B    Unreliable: false\n\u002B    Use Fixed Frame: true\n\u002B    Use rainbow: true\n\u002B    Value: true\n\u002B  - Angle Tolerance: 0.10000000149011612\n\u002B    Class: rviz/Odometry\n\u002B    Covariance:\n\u002B      Orientation:\n\u002B        Alpha: 0.5\n\u002B        Color: 255; 255; 127\n\u002B        Color Style: Unique\n\u002B        Frame: Local\n\u002B        Offset: 1\n\u002B        Scale: 1\n\u002B        Value: true\n\u002B      Position:\n\u002B        Alpha: 0.5\n\u002B        Color: 237; 212; 0\n\u002B        Scale: 10\n\u002B        Value: true\n\u002B      Value: true\n\u002B    Enabled: true\n\u002B    Keep: 1\n\u002B    Name: Estimated Robot Pose\n\u002B    Position Tolerance: 0.10000000149011612\n\u002B    Queue Size: 10\n\u002B    Shape:\n\u002B      Alpha: 1\n\u002B      Axes Length: 1\n\u002B      Axes Radius: 0.10000000149011612\n\u002B      Color: 237; 212; 0\n\u002B      Head Length: 5\n\u002B      Head Radius: 5\n\u002B      Shaft Length: 8\n\u002B      Shaft Radius: 1.5\n\u002B      Value: Arrow\n\u002B    Topic: /odom_filtered\n\u002B    Unreliable: false\n\u002B    Value: true\n\u002B  Tools:\n\u002B  - Class: rviz/Interact\n\u002B  - Class: rviz/MoveCamera\n\u002B  - Class: rviz/Select\n\u002B  - Class: rviz/FocusCamera\n\u002B  - Class: rviz/Measure\n\u002B  - Class: rviz/SetInitialPose\n\u002B  - Class: rviz/SetGoal\n\u002B  - Class: rviz/PublishPoint\n\u002B  Views:\n\u002B    Current:\n\u002B      Angle: 0\n\u002B      Class: rviz/TopDownOrtho\n\u002B      Scale: 5.1059746742248535\n\u002B      X: 10.475910186767578\n\u002B      Y: -13.87234878540039\n\u002B    Saved: null\n\u002BWindow Geometry:\n\u002B  Height: 1376\n\u002B  QMainWindow State: 000000ff00000000fd000000040000000000000156000004befc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005d00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003f0000037b000000cc00fffffffb0000000a0056006900650077007301000003c00000013d000000a900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f000004befc0200000002fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000005000000003efc0100000002fb0000000800540069006d00650100000000000005000000027500fffffffb0000000800540069006d00650100000000000004500000000000000000000003a4000004be00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000\n\u002B  Width: 1280\n\u002B  X: 1280\n\u002B  Y: 27\ndiff --git rviz2/test/tools/rviz1_to_2_check.py rviz2/test/tools/rviz1_to_2_check.py\nindex cbc6ea42..49e84e53 100644\n--- rviz2/test/tools/rviz1_to_2_check.py\n\u002B\u002B\u002B rviz2/test/tools/rviz1_to_2_check.py\n@@ -30,6 \u002B30,37 @@ def test_convert_all_supported_configs():\n     assert \u0027Panels\u0027 in yaml_output.keys()\n \n \n\u002Bdef test_convert_fuse_simple_tutorial_config():\n\u002B    result = subprocess.run(\n\u002B        [sys.executable, script(), config(\u0027fuse_simple_tutorial.rviz\u0027), \u0027-\u0027],\n\u002B        stdout=subprocess.PIPE,\n\u002B        stderr=subprocess.PIPE,\n\u002B        check=True)\n\u002B\n\u002B    output = result.stdout.decode()\n\u002B    assert len(output) \u003E 0\n\u002B    assert len(result.stderr) == 0\n\u002B\n\u002B    yaml_output = yaml.safe_load(output)\n\u002B    assert \u0027Background Color\u0027 in yaml_output[\u0027Visualization Manager\u0027][\u0027Global Options\u0027].keys()\n\u002B\n\u002B\n\u002Bdef test_convert_range_sensor_tutorial_config():\n\u002B    result = subprocess.run(\n\u002B        [sys.executable, script(), config(\u0027range_sensor_tutorial.rviz\u0027), \u0027-\u0027],\n\u002B        stdout=subprocess.PIPE,\n\u002B        stderr=subprocess.PIPE,\n\u002B        check=True)\n\u002B\n\u002B    output = result.stdout.decode()\n\u002B    assert len(output) \u003E 0\n\u002B    assert len(result.stderr) == 0\n\u002B\n\u002B    yaml_output = yaml.safe_load(output)\n\u002B    assert \u0027Panels\u0027 in yaml_output.keys()\n\u002B    assert \u0027Background Color\u0027 in yaml_output[\u0027Visualization Manager\u0027][\u0027Global Options\u0027].keys()\n\u002B\n\u002B\n def test_convert_all_ros1():\n     result = subprocess.run(\n         [sys.executable, script(), config(\u0027all_ros1.rviz\u0027), \u0027-\u0027],\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "e6cbafb0b60781d86900a73c335bc05f6c0a17a9",
    "RawMessage": "Added description how to use the iceoryx introspection",
    "Changes": "diff --git shared_memory_support.md shared_memory_support.md\nindex 7bc9df2..197d9f3 100644\n--- shared_memory_support.md\n\u002B\u002B\u002B shared_memory_support.md\n@@ -95,22 \u002B95,22 @@ We could also run the listener or talker without exporting the configuration fil\n \n ### Using Shared Memory in the example\n \n-To actually use Shared Memory the talker/listener example needs to be slightly rewritten to use a fixed size data type such as an unsigned integer. Adapting the publisher and subscription to use messages of type \u0060std_msgs::msg::UInt64\u0060 instead leads to an example which uses Shared Memory to transport the data. See [Restrictions](#Restrictions) for further information about when Shared Memory transfer will be used.\n\u002BTo actually use Shared Memory the talker/listener example needs to be slightly rewritten to use a fixed size data type such as an unsigned integer. Adapting the publisher and subscription to use messages of type \u0060std_msgs::msg::Uint32\u0060 instead leads to an example which uses Shared Memory to transport the data. See [Restrictions](#Restrictions) for further information about when Shared Memory transfer will be used.\n \n In the talker we use\n \n \u0060\u0060\u0060cpp\n-    std::unique_ptr\u003Cstd_msgs::msg::UInt64\u003E msg_;\n-    rclcpp::Publisher\u003Cstd_msgs::msg::UInt64\u003E::SharedPtr pub_;\n\u002B    std::unique_ptr\u003Cstd_msgs::msg::Uint32\u003E msg_;\n\u002B    rclcpp::Publisher\u003Cstd_msgs::msg::UInt32\u003E::SharedPtr pub_;\n     rclcpp::TimerBase::SharedPtr timer_;\n     // ... \n-    pub_ = this-\u003Ecreate_publisher\u003Cstd_msgs::msg::UInt64\u003E(\u0022chatter\u0022, qos);\n\u002B    pub_ = this-\u003Ecreate_publisher\u003Cstd_msgs::msg::Uint32\u003E(\u0022chatter\u0022, qos);\n \u0060\u0060\u0060\n \n and send the data with\n \n \u0060\u0060\u0060cpp\n-    msg_ = std::make_unique\u003Cstd_msgs::msg::UInt64\u003E();\n\u002B    msg_ = std::make_unique\u003Cstd_msgs::msg::Uint32\u003E();\n     msg_-\u003Edata = count_\u002B\u002B;\n     RCLCPP_INFO(this-\u003Eget_logger(), \u0022Publishing: \u0027Hello World: %lu\u0027\u0022, msg_-\u003Edata);\n     pub_-\u003Epublish(std::move(msg_));\n@@ -119,16 \u002B119,16 @@ and send the data with\n Similarly on the listener side we also change the message type of the subscription\n \n \u0060\u0060\u0060cpp\n-    rclcpp::Subscription\u003Cstd_msgs::msg::UInt64\u003E::SharedPtr sub_;\n\u002B    rclcpp::Subscription\u003Cstd_msgs::msg::Uint32\u003E::SharedPtr sub_;\n     // ...\n-    sub_ = create_subscription\u003Cstd_msgs::msg::UInt64\u003E(\u0022chatter\u0022, 10, callback);\n\u002B    sub_ = create_subscription\u003Cstd_msgs::msg::Uint32\u003E(\u0022chatter\u0022, 10, callback);\n \u0060\u0060\u0060\n \n and can then receive the data with\n \n \u0060\u0060\u0060cpp\n auto callback =\n-      [this](const std::shared_ptr\u003Cstd_msgs::msg::UInt64\u003E msg) -\u003E void\n\u002B      [this](const std::shared_ptr\u003Cstd_msgs::msg::Uint32\u003E msg) -\u003E void\n       {\n         RCLCPP_INFO(this-\u003Eget_logger(), \u0022I heard: [Hello World: %lu]\u0022, msg-\u003Edata);\n       };\n@@ -152,7 \u002B152,7 @@ If these conditions are satisfied we can publish the data in two different ways,\n We first create a message, populate it before passing it to the publisher.\n \n \u0060\u0060\u0060cpp\n-    msg_ = std::make_unique\u003Cstd_msgs::msg::UInt64\u003E();\n\u002B    msg_ = std::make_unique\u003Cstd_msgs::msg::Uint32\u003E();\n     msg_-\u003Edata = count_\u002B\u002B;      \n     pub_-\u003Epublish(std::move(msg_));\n \u0060\u0060\u0060\n@@ -171,7 \u002B171,9 @@ loaned_msg.get().data = count_\u002B\u002B;\n pub_-\u003Epublish(std::move(loaned_msg));\n \u0060\u0060\u0060\n \n-The publish overload here does not need to copy the data to Shared Memory since it already resides there. Hence no copy or serialization is performed and the data is transferred to any subscription in constant time (i.e. independent of the message size).\n\u002BThe publish overload here does not need to copy the data to Shared Memory since it already resides there. Hence no copy is performed and the data is transferred to any subscription in constant time (i.e. independent of the message size). Depending on the data type there serialization into the loaned message may still be required and publish will therefore not be independent of message size. This is not the case for [fixed size](#Types) data types.\n\u002B\n\u002BNote that to properly use loaning move semantics are essential, i.e. using \u0060std::move\u0060 when publishing is required. This allows efficiently transferring ownership of the internal message data back to the middleware without copy overhead. As a consequence read access of \u0060loaned_msg\u0060 after it was published is illegal (undefined behavior).\n \n ## Restrictions\n \n@@ -192,13 \u002B194,12 @@ Only a subset of QoS settings supports Shared Memory. Those are:\n \n 1. Liveliness: Automatic\n 2. Deadline: Infinity (0)\n-3. Reliability: Reliable\n-    - may be extended to Best Effort as well, but Shared Memory transfer is always reliable\n\u002B3. Reliability: Reliable or Best Effort\n 4. Durability: Volatile\n 5. History: Keep Last\n     - with history depth no larger than PubHistoryCapacity (in the configuration file)\n \n-These settings are used by default and applicable to a large class of applications.\n\u002BThese settings (with Reliability: Reliable) are used by default and applicable to a wide range of applications.\n \n ### Number of subscriptions per Process\n \n@@ -216,3 \u002B217,71 @@ Iceoryx uses configurable memory pools to define different sizes of memory chunk\n Depending on the size and frequency of messages send, the default configuration may not be sufficient to guarantee that memory can be loaned and hence the data sent. In this case it might help to use a custom configuration for the shared memory pools to increase the available Shared Memory. The configuration options are described in the [iceoryx configuration guide](https://github.com/eclipse-iceoryx/iceoryx/blob/master/doc/website/advanced/configuration-guide.md).\n \n Note that currently the internal loan call is blocking, which means if no memory is available it will not return (this will change in the future). This may happen if the configured memory is not sufficient for the overall system load, i.e. the memory needed was not available in the first place or is used by other samples which are currently read or written.\n\u002B\n\u002B## Verifing Shared Memory Usage\n\u002B\n\u002BIt is currently not possible to accurately check whether Shared Memory transfer actually takes place for a specific subscription. If the conditions in [Restrictions](#Restrictions) are met this should be the case. If the data rate or latency are beyond what is achievable using regular network communication this is an indication that at least partially Shared Memory communication via iceoryx is being used.\n\u002B\n\u002BAnother way to check whether Shared Memory is used is running the iceoryx introspection client, which allows tracking of various statistics of the iceoryx communication, Shared Memory utilization being one of them.\n\u002B\n\u002B### Building the iceoryx introspection\n\u002B\n\u002BThe introspection client is not build by default, so we need to do so manually.\n\u002BThe introspection depends on iceoryx_utils and iceoryx_posh and we will build against the libraries already build by the ROS 2 installation.\n\u002BAfter installing ROS 2 as described in [Installation](#Installation) navigate to the ROS 2 workspace and execute\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002Bcd ros2_rolling\n\u002B. ~/ros2_rolling/install/setup.bash\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BIn the introspection folder of the iceoryx repository (part of the ROS 2 installation) run cmake followed by make to build the introspection.\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002Bcd src/eclipse-iceoryx/iceoryx/tools/introspection\n\u002Bcmake -Bbuild\n\u002Bcd build\n\u002Bmake\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BAfterwards the executable *iox-introspection-client* should appear in the build folder.\n\u002B\n\u002B### Using the iceoryx introspection\n\u002B\n\u002BThe introspection requires RouDi to be running since it receives the statistics information directly from the RouDi middleware daemon by subscribing to built-in topics.\n\u002B\n\u002BStart RouDi and any applications of your system, e.g. [talker and listener](#Using-Shared-Memory-in-the-example).\n\u002B\n\u002BThe introspection is able to track the processes using iceoryx, the subscriptions using Shared Memory (those using network cannot be found here) and Shared Memory utilization data (i.e. the number and size of allocations in Shared Memory).\n\u002B\n\u002BExecuting\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002B./iox-introspection-client --h\n\u002B\u0060\u0060\u0060\n\u002B\n\u002Bin the folder where the introspection was build provides us with a list of the various options. In the following we will display all statistics by running\n\u002B\n\u002B\u0060\u0060\u0060console\n\u002B./iox-introspection-client --all\n\u002B\u0060\u0060\u0060\n\u002B\n\u002BTo verify that a particular connection is using Shared Memory we can proceed as follows. In the particular talker and listener example the internal ID of the talker and lister process should appear in the *Processes* section of the introspection. These IDs are unique but unfortunately cannot be easily traced back to the process.\n\u002B\n\u002BFrom the *Connections* section we can infer whether a specific topic is offered and whether a subscription to this topic exists. Note that AUTOSAR terminology is used for the displayed data but the topic information is available in the Instance and Event columns. Also note that the built-in topics used by the introspection are also listed.\n\u002B\n\u002BIf a publisher which uses Shared Memory publishes data, the memory utilization changes. This is visible in the *MemPool Status* section in the part listed in Segment Id: 1. If Shared Memory is used, the number of chunks in use should go up until a specific saturation point where it will stagnate or start to flutuate slightly as chunks are freed by the suscribing party. This is related to the settings in the [configuration](#Configuration-file-options) as these essentially control how much Shared Memory a specific subscribtion can use at most.\n\u002B\n\u002BIf we can observe memory chunks being used this is a strong indication that data is transferred by Shared Memory. However, this does not rule out that part of the communication (e.g. other subscriptions) is using the regular network tranfer. This cannot be conclusive in general if multiple subscriptions exist since we do not know which of them transfer data via Shared Memory by observing this statistic in isolation.\n\u002B\n\u002BThe Min Free statistic is also important, as it counts the minimum number of chunks of a specific size that were free in a particular system execution (i.e. this can only decrease monotonically). If this is running low it indicates that there may be not enough Shared Memory available. This can be increased by using a different [Shared Memory configuration](#Iceoryx-Shared-Memory-Configuration).\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n\u002B\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "d5c23e4f0962d220ba952bd973882ca391f551ae",
    "RawMessage": "Fixes from review.",
    "Changes": "diff --git include/rcutils/types/hash_map.h include/rcutils/types/hash_map.h\nindex 2c22e0b..55f43bf 100644\n--- include/rcutils/types/hash_map.h\n\u002B\u002B\u002B include/rcutils/types/hash_map.h\n@@ -156,7 \u002B156,7 @@ rcutils_get_zero_initialized_hash_map();\n  * \u0060\u0060\u0060\n  *\n  * \\param[inout] hash_map rcutils_hash_map_t to be initialized\n- * \\param[in] initial_capacity the amount of initial capacity for the hash_map\n\u002B * \\param[in] initial_capacity the amount of initial capacity for the hash_map - this must be greater than zero and a power of 2\n  * \\param[in] key_size the size (in bytes) of the key used to index the data\n  * \\param[in] data_size the size (in bytes) of the data being stored\n  * \\param[in] key_hashing_func a function that returns a hashed value for a key\ndiff --git test/test_hash_map.cpp test/test_hash_map.cpp\nindex 759a441..a4536d1 100644\n--- test/test_hash_map.cpp\n\u002B\u002B\u002B test/test_hash_map.cpp\n@@ -95,6 \u002B95,13 @@ TEST_F(HashMapBaseTest, init_map_initial_capacity_zero_fails) {\n   EXPECT_EQ(RCUTILS_RET_INVALID_ARGUMENT, ret) \u003C\u003C rcutils_get_error_string().str;\n }\n \n\u002BTEST_F(HashMapBaseTest, init_map_initial_capacity_not_power_of_two_fails) {\n\u002B  rcutils_ret_t ret = rcutils_hash_map_init(\n\u002B    \u0026map, 3, sizeof(uint32_t), sizeof(uint32_t),\n\u002B    test_hash_map_uint32_hash_func, test_uint32_cmp, \u0026allocator);\n\u002B  EXPECT_EQ(RCUTILS_RET_INVALID_ARGUMENT, ret) \u003C\u003C rcutils_get_error_string().str;\n\u002B}\n\u002B\n TEST_F(HashMapBaseTest, init_map_key_size_zero_fails) {\n   rcutils_ret_t ret = rcutils_hash_map_init(\n     \u0026map, 2, 0, sizeof(uint32_t),\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "5b22898f81551f1c36533f56012a4d96d2388ea5",
    "RawMessage": "Suppress a couple more of clang warnings in rviz_ogre_vendor. (#1102)",
    "Changes": "diff --git rviz_ogre_vendor/CMakeLists.txt rviz_ogre_vendor/CMakeLists.txt\nindex 7666ac02..dcdfafbf 100644\n--- rviz_ogre_vendor/CMakeLists.txt\n\u002B\u002B\u002B rviz_ogre_vendor/CMakeLists.txt\n@@ -56,6 \u002B56,8 @@ else()\n   set(OGRE_CXX_FLAGS \u0022-Wno-mismatched-new-delete ${OGRE_CXX_FLAGS}\u0022)\n   set(OGRE_CXX_FLAGS \u0022-Wno-range-loop-construct ${OGRE_CXX_FLAGS}\u0022)\n   set(OGRE_CXX_FLAGS \u0022-Wno-undef ${OGRE_CXX_FLAGS}\u0022)\n\u002B  set(OGRE_CXX_FLAGS \u0022-Wno-misleading-indentation ${OGRE_CXX_FLAGS}\u0022)\n\u002B  set(OGRE_CXX_FLAGS \u0022-Wno-implicit-const-int-float-conversion ${OGRE_CXX_FLAGS}\u0022)\n \n   if(NOT CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n     set(OGRE_CXX_FLAGS \u0022-Wno-maybe-uninitialized ${OGRE_CXX_FLAGS}\u0022)\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_cyclonedds",
    "SHA": "4383911781047513545bc61092150d3ca080fdab",
    "RawMessage": "Add space between \u0027ROS\u0027 and \u00272\u0027",
    "Changes": "diff --git .github/workflows/CI.yml .github/workflows/CI.yml\nindex f51baf2..9b779a4 100644\n--- .github/workflows/CI.yml\n\u002B\u002B\u002B .github/workflows/CI.yml\n@@ -1,4 \u002B1,4 @@\n-name: ROS2 CI\n\u002Bname: ROS 2 CI\n on: [push, pull_request]\n jobs:\n   build:\ndiff --git README.md README.md\nindex c4803d3..6d55a58 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -1,9 \u002B1,9 @@\n-# ROS2 RMW for Eclipse Cyclone DDS\n\u002B# ROS 2 RMW for Eclipse Cyclone DDS\n \n-**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS2. Make your **\u2261\u0192\u00C9\u00F3 run like a \u2261\u0192\u00DC\u00C7** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n\u002B**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS 2. Make your **\u2261\u0192\u00C9\u00F3 run like a \u2261\u0192\u00DC\u00C7** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n \n-This package lets [*ROS2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n-Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS2 experience. Let the Cyclone blow you away!\n\u002BThis package lets [*ROS 2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n\u002BCyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS 2 experience. Let the Cyclone blow you away!\n \n 1. Install:\n \n@@ -15,7 \u002B15,7 @@ Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most rob\n    apt install ros-dashing-rmw-cyclonedds-cpp\n    \u0060\u0060\u0060\n \n-2. Set env variable and run ROS2 apps as usual:\n\u002B2. Set env variable and run ROS 2 apps as usual:\n \n    \u0060\u0060\u0060export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\u0060\u0060\u0060\n \n@@ -63,7 \u002B63,7 @@ The following branches are actively maintained:\n * \u0060master\u0060, which targets the upcoming ROS version, [*Foxy*](https://index.ros.org/doc/ros2/Releases/Release-Foxy-Fitzroy/).\n * \u0060dashing-eloquent\u0060, which maintains compatibility with ROS releases [*Dashing*](https://index.ros.org/doc/ros2/Releases/Release-Dashing-Diademata/) and [*Eloquent*](https://index.ros.org/doc/ros2/Releases/Release-Eloquent-Elusor/)\n \n-If building ROS2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/master/ros2.repos)), you already have this package and Cyclone DDS:\n\u002BIf building ROS 2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/master/ros2.repos)), you already have this package and Cyclone DDS:\n \n     cd /opt/ros/master\n     rosdep install --from src -i\ndiff --git rmw_cyclonedds_cpp/src/rmw_node.cpp rmw_cyclonedds_cpp/src/rmw_node.cpp\nindex 89a4f5e..53ca3c4 100644\n--- rmw_cyclonedds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/rmw_node.cpp\n@@ -259,7 \u002B259,7 @@ struct rmw_context_impl_t\n   dds_entity_t rd_subscription;\n   dds_entity_t rd_publication;\n \n-  /* DDS publisher, subscriber used for ROS2 publishers and subscriptions */\n\u002B  /* DDS publisher, subscriber used for ROS 2 publishers and subscriptions */\n   dds_entity_t dds_pub;\n   dds_entity_t dds_sub;\n \ndiff --git rmw_cyclonedds_cpp/src/serdata.cpp rmw_cyclonedds_cpp/src/serdata.cpp\nindex 05b3286..6dd8542 100644\n--- rmw_cyclonedds_cpp/src/serdata.cpp\n\u002B\u002B\u002B rmw_cyclonedds_cpp/src/serdata.cpp\n@@ -201,7 \u002B201,7 @@ static struct ddsi_serdata * serdata_rmw_from_sample(\n     const struct sertopic_rmw * topic = static_cast\u003Cconst struct sertopic_rmw *\u003E(topiccmn);\n     auto d = std::make_unique\u003Cserdata_rmw\u003E(topic, kind);\n     if (kind != SDK_DATA) {\n-      /* ROS2 doesn\u0027t do keys, so SDK_KEY is trivial */\n\u002B      /* ROS 2 doesn\u0027t do keys, so SDK_KEY is trivial */\n     } else if (!topic-\u003Eis_request_header) {\n       size_t sz = topic-\u003Ecdr_writer-\u003Eget_serialized_size(sample);\n       d-\u003Eresize(sz);\n@@ -275,7 \u002B275,7 @@ static bool serdata_rmw_to_sample(\n     assert(bufptr == NULL);\n     assert(buflim == NULL);\n     if (d-\u003Ekind != SDK_DATA) {\n-      /* ROS2 doesn\u0027t do keys in a meaningful way yet */\n\u002B      /* ROS 2 doesn\u0027t do keys in a meaningful way yet */\n     } else if (!topic-\u003Eis_request_header) {\n       cycdeser sd(d-\u003Edata(), d-\u003Esize());\n       if (using_introspection_c_typesupport(topic-\u003Etype_support.typesupport_identifier_)) {\n@@ -325,7 \u002B325,7 @@ static bool serdata_rmw_topicless_to_sample(\n   static_cast\u003Cvoid\u003E(sample);\n   static_cast\u003Cvoid\u003E(bufptr);\n   static_cast\u003Cvoid\u003E(buflim);\n-  /* ROS2 doesn\u0027t do keys in a meaningful way yet */\n\u002B  /* ROS 2 doesn\u0027t do keys in a meaningful way yet */\n   return true;\n }\n \n@@ -333,7 \u002B333,7 @@ static bool serdata_rmw_eqkey(const struct ddsi_serdata * a, const struct ddsi_s\n {\n   static_cast\u003Cvoid\u003E(a);\n   static_cast\u003Cvoid\u003E(b);\n-  /* ROS2 doesn\u0027t do keys in a meaningful way yet */\n\u002B  /* ROS 2 doesn\u0027t do keys in a meaningful way yet */\n   return true;\n }\n \n@@ -345,7 \u002B345,7 @@ static size_t serdata_rmw_print(\n     auto d = static_cast\u003Cconst serdata_rmw *\u003E(dcmn);\n     const struct sertopic_rmw * topic = static_cast\u003Cconst struct sertopic_rmw *\u003E(tpcmn);\n     if (d-\u003Ekind != SDK_DATA) {\n-      /* ROS2 doesn\u0027t do keys in a meaningful way yet */\n\u002B      /* ROS 2 doesn\u0027t do keys in a meaningful way yet */\n       return static_cast\u003Csize_t\u003E(snprintf(buf, bufsize, \u0022:k:{}\u0022));\n     } else if (!topic-\u003Eis_request_header) {\n       cycprint sd(buf, bufsize, d-\u003Edata(), d-\u003Esize());\n@@ -394,7 \u002B394,7 @@ static void serdata_rmw_get_keyhash(\n   const struct ddsi_serdata * d, struct ddsi_keyhash * buf,\n   bool force_md5)\n {\n-  /* ROS2 doesn\u0027t do keys in a meaningful way yet, this is never called for topics without\n\u002B  /* ROS 2 doesn\u0027t do keys in a meaningful way yet, this is never called for topics without\n      key fields */\n   static_cast\u003Cvoid\u003E(d);\n   static_cast\u003Cvoid\u003E(force_md5);\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "c60ed31d872cba8d490f980751f2b8f945f8cd9b",
    "RawMessage": "Ensure compliant node construction/destruction API. (#408)",
    "Changes": "diff --git rmw_fastrtps_cpp/src/rmw_node.cpp rmw_fastrtps_cpp/src/rmw_node.cpp\nindex 5f1daf5..1fcf186 100644\n--- rmw_fastrtps_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_fastrtps_cpp/src/rmw_node.cpp\n@@ -28,6 \u002B28,7 @@\n \n #include \u0022rmw_fastrtps_shared_cpp/init_rmw_context_impl.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/rmw_common.hpp\u0022\n\u002B#include \u0022rmw_fastrtps_shared_cpp/rmw_context_impl.hpp\u0022\n \n #include \u0022rmw_fastrtps_cpp/identifier.hpp\u0022\n #include \u0022rmw_fastrtps_cpp/init_rmw_context_impl.hpp\u0022\n@@ -40,13 \u002B41,21 @@ rmw_create_node(\n   const char * name,\n   const char * namespace_)\n {\n-  RCUTILS_CHECK_ARGUMENT_FOR_NULL(context, NULL);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n     init context,\n     context-\u003Eimplementation_identifier,\n     eprosima_fastrtps_identifier,\n     // TODO(wjwwood): replace this with RMW_RET_INCORRECT_RMW_IMPLEMENTATION when refactored\n     return nullptr);\n\u002B  RMW_CHECK_FOR_NULL_WITH_MSG(\n\u002B    context-\u003Eimpl,\n\u002B    \u0022expected initialized context\u0022,\n\u002B    return nullptr);\n\u002B  if (context-\u003Eimpl-\u003Eis_shutdown) {\n\u002B    RCUTILS_SET_ERROR_MSG(\u0022context has been shutdown\u0022);\n\u002B    return nullptr;\n\u002B  }\n \n   if (RMW_RET_OK != rmw_fastrtps_cpp::increment_context_impl_ref_count(context)) {\n     return nullptr;\n@@ -68,6 \u002B77,13 @@ rmw_create_node(\n rmw_ret_t\n rmw_destroy_node(rmw_node_t * node)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node,\n\u002B    node-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n\u002B\n   rmw_context_t * context = node-\u003Econtext;\n   rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_destroy_node(\n     eprosima_fastrtps_identifier, node);\ndiff --git rmw_fastrtps_dynamic_cpp/src/rmw_node.cpp rmw_fastrtps_dynamic_cpp/src/rmw_node.cpp\nindex d6f345f..6c492ac 100644\n--- rmw_fastrtps_dynamic_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_fastrtps_dynamic_cpp/src/rmw_node.cpp\n@@ -28,6 \u002B28,7 @@\n \n #include \u0022rmw_fastrtps_shared_cpp/init_rmw_context_impl.hpp\u0022\n #include \u0022rmw_fastrtps_shared_cpp/rmw_common.hpp\u0022\n\u002B#include \u0022rmw_fastrtps_shared_cpp/rmw_context_impl.hpp\u0022\n \n #include \u0022rmw_fastrtps_dynamic_cpp/identifier.hpp\u0022\n #include \u0022rmw_fastrtps_dynamic_cpp/init_rmw_context_impl.hpp\u0022\n@@ -40,13 \u002B41,21 @@ rmw_create_node(\n   const char * name,\n   const char * namespace_)\n {\n-  RCUTILS_CHECK_ARGUMENT_FOR_NULL(context, NULL);\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);\n   RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n     init context,\n     context-\u003Eimplementation_identifier,\n     eprosima_fastrtps_identifier,\n     // TODO(wjwwood): replace this with RMW_RET_INCORRECT_RMW_IMPLEMENTATION when refactored\n-    return NULL);\n\u002B    return nullptr);\n\u002B  RMW_CHECK_FOR_NULL_WITH_MSG(\n\u002B    context-\u003Eimpl,\n\u002B    \u0022expected initialized context\u0022,\n\u002B    return nullptr);\n\u002B  if (context-\u003Eimpl-\u003Eis_shutdown) {\n\u002B    RCUTILS_SET_ERROR_MSG(\u0022context has been shutdown\u0022);\n\u002B    return nullptr;\n\u002B  }\n \n   if (RMW_RET_OK != rmw_fastrtps_dynamic_cpp::increment_context_impl_ref_count(context)) {\n     return nullptr;\n@@ -68,6 \u002B77,12 @@ rmw_create_node(\n rmw_ret_t\n rmw_destroy_node(rmw_node_t * node)\n {\n\u002B  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n\u002B  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n\u002B    node,\n\u002B    node-\u003Eimplementation_identifier,\n\u002B    eprosima_fastrtps_identifier,\n\u002B    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   rmw_context_t * context = node-\u003Econtext;\n   rmw_ret_t ret = rmw_fastrtps_shared_cpp::__rmw_destroy_node(\n     eprosima_fastrtps_identifier, node);\ndiff --git rmw_fastrtps_shared_cpp/src/rmw_node.cpp rmw_fastrtps_shared_cpp/src/rmw_node.cpp\nindex 14c9351..7a3a4f9 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_node.cpp\n@@ -25,6 \u002B25,10 @@\n #include \u0022rmw/error_handling.h\u0022\n #include \u0022rmw/impl/cpp/macros.hpp\u0022\n #include \u0022rmw/rmw.h\u0022\n\u002B#include \u0022rmw/validate_namespace.h\u0022\n\u002B#include \u0022rmw/validate_node_name.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/scope_exit.hpp\u0022\n \n #include \u0022rmw_dds_common/context.hpp\u0022\n \n@@ -42,44 \u002B46,61 @@ __rmw_create_node(\n   const char * name,\n   const char * namespace_)\n {\n-  if (!name) {\n-    RMW_SET_ERROR_MSG(\u0022name is null\u0022);\n\u002B  assert(identifier == context-\u003Eimplementation_identifier);\n\u002B\n\u002B  int validation_result = RMW_NODE_NAME_VALID;\n\u002B  rmw_ret_t ret = rmw_validate_node_name(name, \u0026validation_result, nullptr);\n\u002B  if (RMW_RET_OK != ret) {\n     return nullptr;\n   }\n-\n-  if (!namespace_) {\n-    RMW_SET_ERROR_MSG(\u0022namespace_ is null\u0022);\n\u002B  if (RMW_NODE_NAME_VALID != validation_result) {\n\u002B    const char * reason = rmw_node_name_validation_result_string(validation_result);\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022invalid node name: %s\u0022, reason);\n\u002B    return nullptr;\n\u002B  }\n\u002B  validation_result = RMW_NAMESPACE_VALID;\n\u002B  ret = rmw_validate_namespace(namespace_, \u0026validation_result, nullptr);\n\u002B  if (RMW_RET_OK != ret) {\n\u002B    return nullptr;\n\u002B  }\n\u002B  if (RMW_NAMESPACE_VALID != validation_result) {\n\u002B    const char * reason = rmw_node_name_validation_result_string(validation_result);\n\u002B    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\u0022invalid node namespace: %s\u0022, reason);\n     return nullptr;\n   }\n \n-  rmw_node_t * node_handle = nullptr;\n   auto common_context = static_cast\u003Crmw_dds_common::Context *\u003E(context-\u003Eimpl-\u003Ecommon);\n   rmw_dds_common::GraphCache \u0026 graph_cache = common_context-\u003Egraph_cache;\n-\n-  node_handle = rmw_node_allocate();\n-  if (!node_handle) {\n-    RMW_SET_ERROR_MSG(\u0022failed to allocate rmw_node_t\u0022);\n-    goto fail;\n\u002B  rmw_node_t * node_handle = rmw_node_allocate();\n\u002B  if (nullptr == node_handle) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to allocate node\u0022);\n\u002B    return nullptr;\n   }\n\u002B  auto cleanup_node = rcpputils::make_scope_exit(\n\u002B    [node_handle]() {\n\u002B      rmw_free(const_cast\u003Cchar *\u003E(node_handle-\u003Ename));\n\u002B      rmw_free(const_cast\u003Cchar *\u003E(node_handle-\u003Enamespace_));\n\u002B      rmw_node_free(node_handle);\n\u002B    });\n   node_handle-\u003Eimplementation_identifier = identifier;\n   node_handle-\u003Edata = nullptr;\n \n   node_handle-\u003Ename =\n     static_cast\u003Cconst char *\u003E(rmw_allocate(sizeof(char) * strlen(name) \u002B 1));\n-  if (!node_handle-\u003Ename) {\n-    RMW_SET_ERROR_MSG(\u0022failed to allocate memory\u0022);\n-    node_handle-\u003Enamespace_ = nullptr;  // to avoid free on uninitialized memory\n-    goto fail;\n\u002B  if (nullptr == node_handle-\u003Ename) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to copy node name\u0022);\n\u002B    return nullptr;\n   }\n   memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Ename), name, strlen(name) \u002B 1);\n \n   node_handle-\u003Enamespace_ =\n     static_cast\u003Cconst char *\u003E(rmw_allocate(sizeof(char) * strlen(namespace_) \u002B 1));\n-  if (!node_handle-\u003Enamespace_) {\n-    RMW_SET_ERROR_MSG(\u0022failed to allocate memory\u0022);\n-    goto fail;\n\u002B  if (nullptr == node_handle-\u003Enamespace_) {\n\u002B    RMW_SET_ERROR_MSG(\u0022failed to copy node namespace\u0022);\n\u002B    return nullptr;\n   }\n   memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Enamespace_), namespace_, strlen(namespace_) \u002B 1);\n\u002B\n   node_handle-\u003Econtext = context;\n \n   {\n@@ -92,24 \u002B113,16 @@ __rmw_create_node(\n     rmw_dds_common::msg::ParticipantEntitiesInfo participant_msg =\n       graph_cache.add_node(common_context-\u003Egid, name, namespace_);\n     if (RMW_RET_OK != __rmw_publish(\n-        identifier,\n\u002B        node_handle-\u003Eimplementation_identifier,\n         common_context-\u003Epub,\n         static_cast\u003Cvoid *\u003E(\u0026participant_msg),\n         nullptr))\n     {\n-      goto fail;\n\u002B      return nullptr;\n     }\n   }\n\u002B  cleanup_node.cancel();\n   return node_handle;\n-fail:\n-  if (node_handle) {\n-    rmw_free(const_cast\u003Cchar *\u003E(node_handle-\u003Enamespace_));\n-    node_handle-\u003Enamespace_ = nullptr;\n-    rmw_free(const_cast\u003Cchar *\u003E(node_handle-\u003Ename));\n-    node_handle-\u003Ename = nullptr;\n-  }\n-  rmw_node_free(node_handle);\n-  return nullptr;\n }\n \n rmw_ret_t\n@@ -117,16 \u002B130,7 @@ __rmw_destroy_node(\n   const char * identifier,\n   rmw_node_t * node)\n {\n-  rmw_ret_t result_ret = RMW_RET_OK;\n-  if (!node) {\n-    RMW_SET_ERROR_MSG(\u0022node handle is null\u0022);\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (node-\u003Eimplementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\u0022node handle not from this implementation\u0022);\n-    return RMW_RET_ERROR;\n-  }\n\u002B  assert(node-\u003Eimplementation_identifier == identifier);\n \n   auto common_context = static_cast\u003Crmw_dds_common::Context *\u003E(node-\u003Econtext-\u003Eimpl-\u003Ecommon);\n   rmw_dds_common::GraphCache \u0026 graph_cache = common_context-\u003Egraph_cache;\n@@ -134,21 \u002B138,18 @@ __rmw_destroy_node(\n     std::lock_guard\u003Cstd::mutex\u003E guard(common_context-\u003Enode_update_mutex);\n     rmw_dds_common::msg::ParticipantEntitiesInfo participant_msg =\n       graph_cache.remove_node(common_context-\u003Egid, node-\u003Ename, node-\u003Enamespace_);\n-    result_ret = __rmw_publish(\n\u002B    rmw_ret_t ret = __rmw_publish(\n       identifier,\n       common_context-\u003Epub,\n       static_cast\u003Cvoid *\u003E(\u0026participant_msg),\n       nullptr);\n-    if (RMW_RET_OK != result_ret) {\n-      return result_ret;\n\u002B    if (RMW_RET_OK != ret) {\n\u002B      return ret;\n     }\n   }\n   rmw_free(const_cast\u003Cchar *\u003E(node-\u003Ename));\n-  node-\u003Ename = nullptr;\n   rmw_free(const_cast\u003Cchar *\u003E(node-\u003Enamespace_));\n-  node-\u003Enamespace_ = nullptr;\n   rmw_node_free(node);\n-\n   return RMW_RET_OK;\n }\n \n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "geometry2",
    "SHA": "40ea54d4666b020b99286169d6511c0d02e50047",
    "RawMessage": "Add wait time option to view_frames (#374)",
    "Changes": "diff --git tf2_tools/tf2_tools/view_frames.py tf2_tools/tf2_tools/view_frames.py\nindex 519d84b2..b7f7e23b 100755\n--- tf2_tools/tf2_tools/view_frames.py\n\u002B\u002B\u002B tf2_tools/tf2_tools/view_frames.py\n@@ -27,6 \u002B27,7 @@\n \n # author: Wim Meeussen\n \n\u002Bimport argparse\n import subprocess\n import sys\n import time\n@@ -39,8 \u002B40,16 @@ import tf2_py as tf2\n import tf2_ros\n \n \n-def main(args=None):\n-    rclpy.init(args=args)\n\u002Bdef main():\n\u002B    rclpy.init(args=sys.argv)\n\u002B\n\u002B    args_without_ros = rclpy.utilities.remove_ros_args(sys.argv)\n\u002B    parser = argparse.ArgumentParser(\n\u002B        description=\u0027Create a diagram of the TF frames being broadcast over ROS\u0027)\n\u002B    parser.add_argument(\n\u002B        \u0027--wait-time\u0027, \u0027-t\u0027, type=float, default=5.0,\n\u002B        help=\u0027Listen to the /tf topic for this many seconds before rendering the frame tree\u0027)\n\u002B    parsed_args = parser.parse_args(args=args_without_ros[1:])\n \n     node = rclpy.create_node(\u0027view_frames\u0027)\n \n@@ -51,9 \u002B60,9 @@ def main(args=None):\n     executor.add_node(node)\n \n     # listen to tf for 5 seconds\n-    node.get_logger().info(\u0027Listening to tf data for 5 seconds...\u0027)\n\u002B    node.get_logger().info(f\u0027Listening to tf data for {parsed_args.wait_time} seconds...\u0027)\n     start_time = time.time()\n-    while (time.time() - start_time) \u003C 5.0:\n\u002B    while (time.time() - start_time) \u003C parsed_args.wait_time:\n         rclpy.spin_once(node, timeout_sec=0.1)\n \n     node.get_logger().info(\u0027Generating graph in frames.pdf file...\u0027)\n",
    "IsBackported": false
  },
  {
    "Repository": "ros2cli",
    "SHA": "ae9a8e347b16b8a0f0a34ff3a7c1d7a8ef4588fe",
    "RawMessage": "avoid flaky test that subscriber might not receive the message (#810)",
    "Changes": "diff --git ros2topic/test/test_echo_pub.py ros2topic/test/test_echo_pub.py\nindex 9465e0f..6182073 100644\n--- ros2topic/test/test_echo_pub.py\n\u002B\u002B\u002B ros2topic/test/test_echo_pub.py\n@@ -233,7 \u002B233,7 @@ class TestROS2TopicEchoPub(unittest.TestCase):\n     def test_pub_maxwait_yields(self, launch_service, proc_info, proc_output):\n         topic = \u0027/clitest/topic/pub/max_wait_timeout\u0027\n         command_action = ExecuteProcess(\n-            cmd=([\u0027ros2\u0027, \u0027topic\u0027, \u0027pub\u0027, \u0027-t\u0027, \u00271\u0027, \u0027--max-wait-time-secs\u0027, \u002720\u0027, topic,\n\u002B            cmd=([\u0027ros2\u0027, \u0027topic\u0027, \u0027pub\u0027, \u0027-t\u0027, \u002710\u0027, \u0027--max-wait-time-secs\u0027, \u002720\u0027, topic,\n                   \u0027std_msgs/String\u0027, \u0027data: hello\u0027]),\n             additional_env={\n                 \u0027PYTHONUNBUFFERED\u0027: \u00271\u0027\n",
    "IsBackported": false
  },
  {
    "Repository": "rclpy",
    "SHA": "a6aac563af6fa9825d8ea686ede6ad6df74d8a16",
    "RawMessage": "Set Context.__context to None in __init__ (#812)",
    "Changes": "diff --git rclpy/rclpy/context.py rclpy/rclpy/context.py\nindex f7a45ff..39c195c 100644\n--- rclpy/rclpy/context.py\n\u002B\u002B\u002B rclpy/rclpy/context.py\n@@ -38,6 \u002B38,7 @@ class Context:\n         self._callbacks = []\n         self._callbacks_lock = threading.Lock()\n         self._logging_initialized = False\n\u002B        self.__context = None\n \n     @property\n     def handle(self):\n@@ -65,28 \u002B66,27 @@ class Context:\n                 raise RuntimeError(\n                     \u0027Domain id ({}) should not be lower than zero.\u0027\n                     .format(domain_id))\n-            try:\n-                if self.__context is not None:\n-                    raise RuntimeError\n-            except AttributeError:\n-                self.__context = _rclpy.Context(\n-                    args if args is not None else sys.argv,\n-                    domain_id if domain_id is not None else _rclpy.RCL_DEFAULT_DOMAIN_ID)\n-                if initialize_logging and not self._logging_initialized:\n-                    with g_logging_configure_lock:\n-                        g_logging_ref_count \u002B= 1\n-                        if g_logging_ref_count == 1:\n-                            _rclpy.rclpy_logging_configure(self.__context)\n-                    self._logging_initialized = True\n\u002B\n\u002B            if self.__context is not None:\n\u002B                raise RuntimeError(\u0027Context.init() must only be called once\u0027)\n\u002B\n\u002B            self.__context = _rclpy.Context(\n\u002B                args if args is not None else sys.argv,\n\u002B                domain_id if domain_id is not None else _rclpy.RCL_DEFAULT_DOMAIN_ID)\n\u002B            if initialize_logging and not self._logging_initialized:\n\u002B                with g_logging_configure_lock:\n\u002B                    g_logging_ref_count \u002B= 1\n\u002B                    if g_logging_ref_count == 1:\n\u002B                        _rclpy.rclpy_logging_configure(self.__context)\n\u002B                self._logging_initialized = True\n \n     def ok(self):\n         \u0022\u0022\u0022Check if context hasn\u0027t been shut down.\u0022\u0022\u0022\n-        # imported locally to avoid loading extensions on module import\n-        try:\n-            with self.__context, self._lock:\n\u002B        with self._lock:\n\u002B            if self.__context is None:\n\u002B                return False\n\u002B            with self.__context:\n                 return self.__context.ok()\n-        except AttributeError:\n-            return False\n \n     def _call_on_shutdown_callbacks(self):\n         with self._callbacks_lock:\n@@ -98,7 \u002B98,8 @@ class Context:\n \n     def shutdown(self):\n         \u0022\u0022\u0022Shutdown this context.\u0022\u0022\u0022\n-        # imported locally to avoid loading extensions on module import\n\u002B        if self.__context is None:\n\u002B            raise RuntimeError(\u0027Context must be initialized before it can be shutdown\u0027)\n         with self.__context, self._lock:\n             self.__context.shutdown()\n         self._call_on_shutdown_callbacks()\n@@ -106,7 \u002B107,8 @@ class Context:\n \n     def try_shutdown(self):\n         \u0022\u0022\u0022Shutdown this context, if not already shutdown.\u0022\u0022\u0022\n-        # imported locally to avoid loading extensions on module import\n\u002B        if self.__context is None:\n\u002B            return\n         with self.__context, self._lock:\n             if self.__context.ok():\n                 self.__context.shutdown()\n@@ -141,5 \u002B143,7 @@ class Context:\n \n     def get_domain_id(self):\n         \u0022\u0022\u0022Get domain id of context.\u0022\u0022\u0022\n\u002B        if self.__context is None:\n\u002B            raise RuntimeError(\u0027Context must be initialized before it can have a domain id\u0027)\n         with self.__context, self._lock:\n             return self.__context.get_domain_id()\n",
    "IsBackported": false
  },
  {
    "Repository": "launch_ros",
    "SHA": "d38055ca61acc84134ccf10b50a8e5c8721ff883",
    "RawMessage": "Improve evaluate_paramenter_dict exceptions error message (#320)",
    "Changes": "diff --git launch_ros/launch_ros/utilities/evaluate_parameters.py launch_ros/launch_ros/utilities/evaluate_parameters.py\nindex 8917bc7..467bf70 100644\n--- launch_ros/launch_ros/utilities/evaluate_parameters.py\n\u002B\u002B\u002B launch_ros/launch_ros/utilities/evaluate_parameters.py\n@@ -93,16 \u002B93,20 @@ def evaluate_parameter_dict(\n                     if not check_sequence_type_is_allowed(yaml_evaluated_value):\n                         raise TypeError(\n                             \u0027Expected a non-empty sequence, with items of uniform type. \u0027\n-                            \u0027Allowed sequence item types are bool, int, float, str.\u0027\n\u002B                            \u0027Allowed sequence item types are bool, int, float, str. \u0027\n\u002B                            \u0027Got inconsistent input for \u0022{}\u0022\u0027.format(evaluated_name)\n                         )\n                     evaluated_value = tuple(yaml_evaluated_value)\n                 else:\n                     raise TypeError(\n                         \u0027Allowed value types are bytes, bool, int, float, str, Sequence[bool]\u0027\n-                        \u0027, Sequence[int], Sequence[float], Sequence[str]. Got {}.\u0027\n\u002B                        \u0027, Sequence[int], Sequence[float], Sequence[str]. Got {} for \u0022{}\u0022. \u0027\n                         \u0027If the parameter is meant to be a string, try wrapping it in \u0027\n                         \u0027launch_ros.parameter_descriptions.ParameterValue\u0027\n-                        \u0027(value, value_type=str)\u0027.format(type(yaml_evaluated_value))\n\u002B                        \u0027(value, value_type=str)\u0027.format(\n\u002B                            type(yaml_evaluated_value),\n\u002B                            evaluated_name\n\u002B                        )\n                     )\n             elif isinstance(value[0], Sequence):\n                 # Value is an array of a list of substitutions\n@@ -119,7 \u002B123,8 @@ def evaluate_parameter_dict(\n                 if not check_sequence_type_is_allowed(yaml_evaluated_value):\n                     raise TypeError(\n                         \u0027Expected a non-empty sequence, with items of uniform type. \u0027\n-                        \u0027Allowed sequence item types are bool, int, float, str.\u0027\n\u002B                        \u0027Allowed sequence item types are bool, int, float, str. \u0027\n\u002B                        \u0027Got inconsistent input for \u0022{}\u0022\u0027.format(evaluated_name)\n                     )\n                 evaluated_value = tuple(yaml_evaluated_value)\n             else:\n",
    "IsBackported": false
  },
  {
    "Repository": "common_interfaces",
    "SHA": "e3f1b328010d3ab94e4e0baab4ff3048ace81695",
    "RawMessage": "Add in a compatibility layer for older versions of numpy. (#185)",
    "Changes": "diff --git sensor_msgs_py/sensor_msgs_py/numpy_compat.py sensor_msgs_py/sensor_msgs_py/numpy_compat.py\nnew file mode 100644\nindex 0000000..9e84261\n--- /dev/null\n\u002B\u002B\u002B sensor_msgs_py/sensor_msgs_py/numpy_compat.py\n@@ -0,0 \u002B1,158 @@\n\u002B# Copyright 2005-2019 NumPy Developers.\n\u002B# Copyright 2022 Open Source Robotics Foundation, Inc.\n\u002B#\n\u002B# Redistribution and use in source and binary forms, with or without\n\u002B# modification, are permitted provided that the following conditions are met:\n\u002B#\n\u002B#    * Redistributions of source code must retain the above copyright\n\u002B#      notice, this list of conditions and the following disclaimer.\n\u002B#\n\u002B#    * Redistributions in binary form must reproduce the above copyright\n\u002B#      notice, this list of conditions and the following disclaimer in the\n\u002B#      documentation and/or other materials provided with the distribution.\n\u002B#\n\u002B#    * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B#      contributors may be used to endorse or promote products derived from\n\u002B#      this software without specific prior written permission.\n\u002B#\n\u002B# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n\u002B# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B# POSSIBILITY OF SUCH DAMAGE.\n\u002B\n\u002B# This is compatibility code for older versions of numpy that lack these functions.\n\u002B# The original code was copied from:\n\u002B# https://github.com/numpy/numpy/blob/3dec7099ce38cb189880f6f69df318f35ff9a5ea/numpy/lib/recfunctions.py\n\u002B# and then lightly edited for style.\n\u002B\n\u002Bimport numpy as np\n\u002B\n\u002B\n\u002Bdef _get_fields_and_offsets(dt, offset=0):\n\u002B    # counts up elements in subarrays, including nested subarrays, and returns\n\u002B    # base dtype and count\n\u002B    def count_elem(dt):\n\u002B        count = 1\n\u002B        while dt.shape != ():\n\u002B            for size in dt.shape:\n\u002B                count *= size\n\u002B            dt = dt.base\n\u002B        return dt, count\n\u002B\n\u002B    fields = []\n\u002B    for name in dt.names:\n\u002B        field = dt.fields[name]\n\u002B        f_dt, f_offset = field[0], field[1]\n\u002B        f_dt, n = count_elem(f_dt)\n\u002B\n\u002B        if f_dt.names is None:\n\u002B            fields.append((np.dtype((f_dt, (n,))), n, f_offset \u002B offset))\n\u002B        else:\n\u002B            subfields = _get_fields_and_offsets(f_dt, f_offset \u002B offset)\n\u002B            size = f_dt.itemsize\n\u002B\n\u002B            for i in range(n):\n\u002B                if i == 0:\n\u002B                    # optimization: avoid list comprehension if no subarray\n\u002B                    fields.extend(subfields)\n\u002B                else:\n\u002B                    fields.extend([(d, c, o \u002B i*size) for d, c, o in subfields])\n\u002B    return fields\n\u002B\n\u002B\n\u002Bdef structured_to_unstructured(arr, dtype=None, copy=False, casting=\u0027unsafe\u0027):\n\u002B    if arr.dtype.names is None:\n\u002B        raise ValueError(\u0027arr must be a structured array\u0027)\n\u002B\n\u002B    fields = _get_fields_and_offsets(arr.dtype)\n\u002B    n_fields = len(fields)\n\u002B    if n_fields == 0 and dtype is None:\n\u002B        raise ValueError(\u0027arr has no fields. Unable to guess dtype\u0027)\n\u002B    elif n_fields == 0:\n\u002B        # too many bugs elsewhere for this to work now\n\u002B        raise NotImplementedError(\u0027arr with no fields is not supported\u0027)\n\u002B\n\u002B    dts, counts, offsets = zip(*fields)\n\u002B    names = [\u0027f{}\u0027.format(n) for n in range(n_fields)]\n\u002B\n\u002B    if dtype is None:\n\u002B        out_dtype = np.result_type(*[dt.base for dt in dts])\n\u002B    else:\n\u002B        out_dtype = dtype\n\u002B\n\u002B    # Use a series of views and casts to convert to an unstructured array:\n\u002B\n\u002B    # first view using flattened fields (doesn\u0027t work for object arrays)\n\u002B    # Note: dts may include a shape for subarrays\n\u002B    flattened_fields = np.dtype({\u0027names\u0027: names,\n\u002B                                 \u0027formats\u0027: dts,\n\u002B                                 \u0027offsets\u0027: offsets,\n\u002B                                 \u0027itemsize\u0027: arr.dtype.itemsize})\n\u002B    arr = arr.view(flattened_fields)\n\u002B\n\u002B    # next cast to a packed format with all fields converted to new dtype\n\u002B    packed_fields = np.dtype({\u0027names\u0027: names,\n\u002B                              \u0027formats\u0027: [(out_dtype, dt.shape) for dt in dts]})\n\u002B    arr = arr.astype(packed_fields, copy=copy, casting=casting)\n\u002B\n\u002B    # finally is it safe to view the packed fields as the unstructured type\n\u002B    return arr.view((out_dtype, (sum(counts),)))\n\u002B\n\u002B\n\u002Bdef unstructured_to_structured(arr, dtype=None, names=None, align=False,\n\u002B                               copy=False, casting=\u0027unsafe\u0027):\n\u002B    if arr.shape == ():\n\u002B        raise ValueError(\u0027arr must have at least one dimension\u0027)\n\u002B    n_elem = arr.shape[-1]\n\u002B    if n_elem == 0:\n\u002B        # too many bugs elsewhere for this to work now\n\u002B        raise NotImplementedError(\u0027last axis with size 0 is not supported\u0027)\n\u002B\n\u002B    if dtype is None:\n\u002B        if names is None:\n\u002B            names = [\u0027f{}\u0027.format(n) for n in range(n_elem)]\n\u002B        out_dtype = np.dtype([(n, arr.dtype) for n in names], align=align)\n\u002B        fields = _get_fields_and_offsets(out_dtype)\n\u002B        dts, counts, offsets = zip(*fields)\n\u002B    else:\n\u002B        if names is not None:\n\u002B            raise ValueError(\u0022don\u0027t supply both dtype and names\u0022)\n\u002B        # sanity check of the input dtype\n\u002B        fields = _get_fields_and_offsets(dtype)\n\u002B        if len(fields) == 0:\n\u002B            dts, counts, offsets = [], [], []\n\u002B        else:\n\u002B            dts, counts, offsets = zip(*fields)\n\u002B\n\u002B        if n_elem != sum(counts):\n\u002B            raise ValueError(\u0027The length of the last dimension of arr must \u0027\n\u002B                             \u0027be equal to the number of fields in dtype\u0027)\n\u002B        out_dtype = dtype\n\u002B        if align and not out_dtype.isalignedstruct:\n\u002B            raise ValueError(\u0027align was True but dtype is not aligned\u0027)\n\u002B\n\u002B    names = [\u0027f{}\u0027.format(n) for n in range(len(fields))]\n\u002B\n\u002B    # Use a series of views and casts to convert to a structured array:\n\u002B\n\u002B    # first view as a packed structured array of one dtype\n\u002B    packed_fields = np.dtype({\u0027names\u0027: names,\n\u002B                              \u0027formats\u0027: [(arr.dtype, dt.shape) for dt in dts]})\n\u002B    arr = np.ascontiguousarray(arr).view(packed_fields)\n\u002B\n\u002B    # next cast to an unpacked but flattened format with varied dtypes\n\u002B    flattened_fields = np.dtype({\u0027names\u0027: names,\n\u002B                                 \u0027formats\u0027: dts,\n\u002B                                 \u0027offsets\u0027: offsets,\n\u002B                                 \u0027itemsize\u0027: out_dtype.itemsize})\n\u002B    arr = arr.astype(flattened_fields, copy=copy, casting=casting)\n\u002B\n\u002B    # finally view as the final nested dtype and remove the last axis\n\u002B    return arr.view(out_dtype)[..., 0]\ndiff --git sensor_msgs_py/sensor_msgs_py/point_cloud2.py sensor_msgs_py/sensor_msgs_py/point_cloud2.py\nindex 55c37fc..11a02ed 100644\n--- sensor_msgs_py/sensor_msgs_py/point_cloud2.py\n\u002B\u002B\u002B sensor_msgs_py/sensor_msgs_py/point_cloud2.py\n@@ -43,8 \u002B43,12 @@ import sys\n from typing import Iterable, List, NamedTuple, Optional\n \n import numpy as np\n-from numpy.lib.recfunctions import (structured_to_unstructured,\n-                                    unstructured_to_structured)\n\u002Btry:\n\u002B    from numpy.lib.recfunctions import (structured_to_unstructured, unstructured_to_structured)\n\u002Bexcept ImportError:\n\u002B    from sensor_msgs_py.numpy_compat import (structured_to_unstructured,\n\u002B                                             unstructured_to_structured)\n\u002B\n from sensor_msgs.msg import PointCloud2, PointField\n from std_msgs.msg import Header\n \ndiff --git sensor_msgs_py/test/test_point_cloud2.py sensor_msgs_py/test/test_point_cloud2.py\nindex 95aa09e..b097f80 100644\n--- sensor_msgs_py/test/test_point_cloud2.py\n\u002B\u002B\u002B sensor_msgs_py/test/test_point_cloud2.py\n@@ -31,7 \u002B31,11 @@ import sys\n import unittest\n \n import numpy as np\n-from numpy.lib.recfunctions import structured_to_unstructured\n\u002Btry:\n\u002B    from numpy.lib.recfunctions import structured_to_unstructured\n\u002Bexcept ImportError:\n\u002B    from sensor_msgs_py.numpy_compat import structured_to_unstructured\n\u002B\n from sensor_msgs.msg import PointCloud2, PointField\n from sensor_msgs_py import point_cloud2\n from std_msgs.msg import Header\n@@ -257,8 \u002B261,6 @@ class TestPointCloud2Methods(unittest.TestCase):\n         thispcd = point_cloud2.create_cloud_xyz32(\n             Header(frame_id=\u0027frame\u0027),\n             points3)\n-        print(thispcd)\n-        print(pcd3)\n         self.assertEqual(thispcd, pcd3)\n \n     def test_create_cloud__non_one_count(self):\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "f1327dfc09c507500383e488f1107bd05afda083",
    "RawMessage": "Fix format of code description on document (#313)",
    "Changes": "diff --git include/rcutils/macros.h include/rcutils/macros.h\nindex 50a5411..e264621 100644\n--- include/rcutils/macros.h\n\u002B\u002B\u002B include/rcutils/macros.h\n@@ -79,11 \u002B79,12 @@ extern \u0022C\u0022\n  * https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\n  *\n  * For the following function:\n\u002B * \u0060\u0060\u0060\n  * int snprintf(char *str, size_t size, const char *format, ...);\n  *              ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^\n  *              ARG 1      ARG 2        ARG 3               ARG 4\n  *                                      format string       first optional argument\n- *\n\u002B * \u0060\u0060\u0060\n  * format_string_index value would be 3, first_to_check_index value would be 4.\n  *\n  * IMPORTANT: the first argument has an index of ONE (not zero!).\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_dds_common",
    "SHA": "4c1d9ac6677d8a21b8b682de04f73997ed77b5a0",
    "RawMessage": "Update QD and documentation. (#23)",
    "Changes": "diff --git README.md README.md\nindex f81c8da..b8e8969 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -1,18 \u002B1,17 @@\n-# rmw_dds_common\n-\n-Package with a common implementation of Node discovery for all DDS based \u0060rmw\u0060 implementations, including:\n-\n-- A generic [\u0060GraphCache\u0060](rmw_dds_common/include/rmw_dds_common/graph_cache.hpp) to track DDS entities such as participants and data readers and writers, plus ROS nodes as an additional abstraction for any DDS based \u0060rmw\u0060 implementation to use\n-- Common messages to communicate [ROS nodes discovery information](https://github.com/ros2/design/pull/250):\n-  - [\u0060rmw_dds_common/msg/Gid\u0060](rmw_dds_common/msg/Gid.msg)\n-  - [\u0060rmw_dds_common/msg/NodeEntitiesInfo\u0060](rmw_dds_common/msg/NodeEntitiesInfo.msg)\n-  - [\u0060rmw_dds_common/msg/ParticipantEntitiesInfo\u0060](rmw_dds_common/msg/ParticipantEntitiesInfo.msg)\n-- Some useful data types and utilities:\n-  - A generic [\u0060Context\u0060](rmw_dds_common/include/rmw_dds_common/context.hpp) type to withhold most state needed to implement [ROS nodes discovery](https://github.com/ros2/design/pull/250)\n-  - [Comparison utilities and some C\u002B\u002B operator overloads](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) for \u0060rmw_gid_t\u0060 instances\n-  - [Conversion utilities](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) between \u0060rmw_dds_common/msg/Gid\u0060 messages and \u0060rmw_gid_t\u0060 instances\n\u002B# rmw_dds_common: ROS 2 C\u002B\u002B utilities for DDS-based RMWs\n \n\u002B\u0060rmw_dds_common\u0060 is a collection of C\u002B\u002B APIs to support DDS based, C\u002B\u002B RMW implementations. \n \n ## Quality Declaration\n \n This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](rmw_dds_common/QUALITY_DECLARATION.md) for more details.\n\u002B\n\u002B## API\n\u002B\n\u002BThis package contains:\n\u002B\n\u002B- Generic graph cache\n\u002B- Common discovery messages\n\u002B- Data types and utilities\n\u002B\n\u002BSee [feature list](rmw_dds_common/docs/FEATURES.md) for further reference.\ndiff --git rmw_dds_common/QUALITY_DECLARATION.md rmw_dds_common/QUALITY_DECLARATION.md\nindex cd5da6e..5fab0dc 100644\n--- rmw_dds_common/QUALITY_DECLARATION.md\n\u002B\u002B\u002B rmw_dds_common/QUALITY_DECLARATION.md\n@@ -59,7 \u002B59,7 @@ All pull requests must resolve related documentation changes before merging.\n \n ### Feature Documentation [3.i]\n \n-\u0060rmw_dds_common\u0060 does not yet have a list of features.\n\u002B\u0060rmw_dds_common\u0060 has a documented [feature list](docs/FEATURES.md).\n \n ### Public API Documentation [3.ii]\n \n@@ -95,7 \u002B95,19 @@ The tests aim to cover both typical usage and corner cases, but are quantified b\n \n ### Coverage [4.iii]\n \n-\u0060rmw_dds_common\u0060 does not currently track test coverage.\n\u002B\u0060rmw_dds_common\u0060 follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n\u002B\n\u002BThis includes:\n\u002B\n\u002B- tracking and reporting line coverage statistics\n\u002B- achieving and maintaining a reasonable branch line coverage (90-100%)\n\u002B- no lines are manually skipped in coverage calculations\n\u002B\n\u002BChanges are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n\u002B\n\u002BCurrent coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_dds_common_rmw_dds_common_include_rmw_dds_common/) and [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_dds_common_rmw_dds_common_src/). This package does not yet meet the 95% coverage guideline, but it is currently above 90%.\n\u002B\n\u002BA summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs).\n \n ### Performance [4.iv]\n \ndiff --git rmw_dds_common/docs/FEATURES.md rmw_dds_common/docs/FEATURES.md\nnew file mode 100644\nindex 0000000..a29114a\n--- /dev/null\n\u002B\u002B\u002B rmw_dds_common/docs/FEATURES.md\n@@ -0,0 \u002B1,13 @@\n\u002B# rmw_dds_common Features\n\u002B\n\u002BThis package includes:\n\u002B\n\u002B- A generic [\u0060GraphCache\u0060](rmw_dds_common/include/rmw_dds_common/graph_cache.hpp) to track DDS entities such as participants and data readers and writers, plus ROS nodes as an additional abstraction for any DDS based \u0060rmw\u0060 implementation to use\n\u002B- Common messages to communicate [ROS nodes discovery information](https://github.com/ros2/design/pull/250):\n\u002B  - [\u0060rmw_dds_common/msg/Gid\u0060](rmw_dds_common/msg/Gid.msg)\n\u002B  - [\u0060rmw_dds_common/msg/NodeEntitiesInfo\u0060](rmw_dds_common/msg/NodeEntitiesInfo.msg)\n\u002B  - [\u0060rmw_dds_common/msg/ParticipantEntitiesInfo\u0060](rmw_dds_common/msg/ParticipantEntitiesInfo.msg)\n\u002B- Some useful data types and utilities:\n\u002B  - A generic [\u0060Context\u0060](rmw_dds_common/include/rmw_dds_common/context.hpp) type to withhold most state needed to implement [ROS nodes discovery](https://github.com/ros2/design/pull/250)\n\u002B  - [Comparison utilities and some C\u002B\u002B operator overloads](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) for \u0060rmw_gid_t\u0060 instances\n\u002B  - [Conversion utilities](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) between \u0060rmw_dds_common/msg/Gid\u0060 messages and \u0060rmw_gid_t\u0060 instances\n",
    "BackportedTo": "foxy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "b6f1b6b17554a0948a1a59bab7287d1e982eda4a",
    "RawMessage": "QoS autodetection (#613)",
    "Changes": "diff --git ros2topic/ros2topic/api/__init__.py ros2topic/ros2topic/api/__init__.py\nindex 9cbfeef..ed9cf4c 100644\n--- ros2topic/ros2topic/api/__init__.py\n\u002B\u002B\u002B ros2topic/ros2topic/api/__init__.py\n@@ -12,10 \u002B12,9 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-import argparse\n-\n from argparse import ArgumentTypeError\n from time import sleep\n\u002Bfrom typing import Optional\n \n import rclpy\n \n@@ -160,7 \u002B159,7 @@ class TopicMessagePrototypeCompleter:\n \n def qos_profile_from_short_keys(\n     preset_profile: str, reliability: str = None, durability: str = None,\n-    depth: int = -1, history: str = None,\n\u002B    depth: Optional[int] = None, history: str = None,\n ) -\u003E rclpy.qos.QoSProfile:\n     \u0022\u0022\u0022Construct a QoSProfile given the name of a preset, and optional overrides.\u0022\u0022\u0022\n     # Build a QoS profile based on user-supplied arguments\n@@ -171,49 \u002B170,10 @@ def qos_profile_from_short_keys(\n         profile.durability = rclpy.qos.QoSDurabilityPolicy.get_from_short_key(durability)\n     if reliability:\n         profile.reliability = rclpy.qos.QoSReliabilityPolicy.get_from_short_key(reliability)\n-    if depth \u003E= 0:\n\u002B    if depth and depth \u003E= 0:\n         profile.depth = depth\n     else:\n         if (profile.durability == rclpy.qos.QoSDurabilityPolicy.TRANSIENT_LOCAL\n                 and profile.depth == 0):\n             profile.depth = 1\n-\n     return profile\n-\n-\n-def add_qos_arguments_to_argument_parser(\n-    parser: argparse.ArgumentParser, is_publisher: bool = True, default_preset: str = \u0027sensor_data\u0027\n-) -\u003E None:\n-    \u0022\u0022\u0022Extend an existing ArgumentParser to allow input of QoS policy overrides.\u0022\u0022\u0022\n-    verb = \u0027publish\u0027 if is_publisher else \u0027subscribe\u0027\n-    parser.add_argument(\n-        \u0027--qos-profile\u0027,\n-        choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n-        default=default_preset,\n-        help=\u0027Quality of service preset profile to {} with (default: {})\u0027\n-             .format(verb, default_preset))\n-    default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(\n-        default_preset)\n-    parser.add_argument(\n-        \u0027--qos-depth\u0027, metavar=\u0027N\u0027, type=int, default=-1,\n-        help=\u0027Queue size setting to {} with \u0027\n-             \u0027(overrides depth value of --qos-profile option)\u0027\n-             .format(verb))\n-    parser.add_argument(\n-        \u0027--qos-history\u0027,\n-        choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n-        help=\u0027History of samples setting to {} with \u0027\n-             \u0027(overrides history value of --qos-profile option, default: {})\u0027\n-             .format(verb, default_profile.history.short_key))\n-    parser.add_argument(\n-        \u0027--qos-reliability\u0027,\n-        choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n-        help=\u0027Quality of service reliability setting to {} with \u0027\n-             \u0027(overrides reliability value of --qos-profile option, default: {})\u0027\n-             .format(verb, default_profile.reliability.short_key))\n-    parser.add_argument(\n-        \u0027--qos-durability\u0027,\n-        choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n-        help=\u0027Quality of service durability setting to {} with \u0027\n-             \u0027(overrides durability value of --qos-profile option, default: {})\u0027\n-             .format(verb, default_profile.durability.short_key))\ndiff --git ros2topic/ros2topic/verb/echo.py ros2topic/ros2topic/verb/echo.py\nindex c9d03fe..0428c18 100644\n--- ros2topic/ros2topic/verb/echo.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/echo.py\n@@ -18,12 \u002B18,14 @@ from typing import TypeVar\n \n import rclpy\n from rclpy.node import Node\n\u002Bfrom rclpy.qos import QoSDurabilityPolicy\n\u002Bfrom rclpy.qos import QoSPresetProfiles\n from rclpy.qos import QoSProfile\n\u002Bfrom rclpy.qos import QoSReliabilityPolicy\n from rclpy.qos_event import SubscriptionEventCallbacks\n from rclpy.qos_event import UnsupportedEventTypeError\n from ros2cli.node.strategy import add_arguments as add_strategy_node_arguments\n from ros2cli.node.strategy import NodeStrategy\n-from ros2topic.api import add_qos_arguments_to_argument_parser\n from ros2topic.api import get_msg_class\n from ros2topic.api import qos_profile_from_short_keys\n from ros2topic.api import TopicNameCompleter\n@@ -35,6 \u002B37,7 @@ from rosidl_runtime_py.utilities import get_message\n \n DEFAULT_TRUNCATE_LENGTH = 128\n MsgType = TypeVar(\u0027MsgType\u0027)\n\u002Bdefault_profile_str = \u0027sensor_data\u0027\n \n \n class EchoVerb(VerbExtension):\n@@ -51,8 \u002B54,34 @@ class EchoVerb(VerbExtension):\n         parser.add_argument(\n             \u0027message_type\u0027, nargs=\u0027?\u0027,\n             help=\u0022Type of the ROS message (e.g. \u0027std_msgs/msg/String\u0027)\u0022)\n-        add_qos_arguments_to_argument_parser(\n-            parser, is_publisher=False, default_preset=\u0027sensor_data\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-profile\u0027,\n\u002B            choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n\u002B            help=\u0027Quality of service preset profile to subscribe with (default: {})\u0027\n\u002B                 .format(default_profile_str))\n\u002B        default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(default_profile_str)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-depth\u0027, metavar=\u0027N\u0027, type=int,\n\u002B            help=\u0027Queue size setting to subscribe with \u0027\n\u002B                 \u0027(overrides depth value of --qos-profile option)\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-history\u0027,\n\u002B            choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n\u002B            help=\u0027History of samples setting to subscribe with \u0027\n\u002B                 \u0027(overrides history value of --qos-profile option, default: {})\u0027\n\u002B                 .format(default_profile.history.short_key))\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-reliability\u0027,\n\u002B            choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n\u002B            help=\u0027Quality of service reliability setting to subscribe with \u0027\n\u002B                 \u0027(overrides reliability value of --qos-profile option, default: \u0027\n\u002B                 \u0027Automatically match existing publishers )\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-durability\u0027,\n\u002B            choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n\u002B            help=\u0027Quality of service durability setting to subscribe with \u0027\n\u002B                 \u0027(overrides durability value of --qos-profile option, default: \u0027\n\u002B                 \u0027Automatically match existing publishers )\u0027)\n         parser.add_argument(\n             \u0027--csv\u0027, action=\u0027store_true\u0027,\n             help=\u0027Output all recursive fields separated by commas (e.g. for \u0027\n@@ -84,6 \u002B113,65 @@ class EchoVerb(VerbExtension):\n         parser.add_argument(\n             \u0027--raw\u0027, action=\u0027store_true\u0027, help=\u0027Echo the raw binary representation\u0027)\n \n\u002B    def choose_qos(self, node, args):\n\u002B\n\u002B        if (args.qos_profile is not None or\n\u002B                args.qos_reliability is not None or\n\u002B                args.qos_durability is not None or\n\u002B                args.qos_depth is not None or\n\u002B                args.qos_history is not None):\n\u002B\n\u002B            if args.qos_profile is None:\n\u002B                args.qos_profile = default_profile_str\n\u002B            return qos_profile_from_short_keys(args.qos_profile,\n\u002B                                               reliability=args.qos_reliability,\n\u002B                                               durability=args.qos_durability,\n\u002B                                               depth=args.qos_depth,\n\u002B                                               history=args.qos_history)\n\u002B\n\u002B        qos_profile = QoSPresetProfiles.get_from_short_key(default_profile_str)\n\u002B        reliability_reliable_endpoints_count = 0\n\u002B        durability_transient_local_endpoints_count = 0\n\u002B\n\u002B        pubs_info = node.get_publishers_info_by_topic(args.topic_name)\n\u002B        publishers_count = len(pubs_info)\n\u002B        if publishers_count == 0:\n\u002B            return qos_profile\n\u002B\n\u002B        for info in pubs_info:\n\u002B            if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n\u002B                reliability_reliable_endpoints_count \u002B= 1\n\u002B            if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n\u002B                durability_transient_local_endpoints_count \u002B= 1\n\u002B\n\u002B        # If all endpoints are reliable, ask for reliable\n\u002B        if reliability_reliable_endpoints_count == publishers_count:\n\u002B            qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n\u002B        else:\n\u002B            if reliability_reliable_endpoints_count \u003E 0:\n\u002B                print(\n\u002B                    \u0027Some, but not all, publishers are offering \u0027\n\u002B                    \u0027QoSReliabilityPolicy.RELIABLE. Falling back to \u0027\n\u002B                    \u0027QoSReliabilityPolicy.BEST_EFFORT as it will connect \u0027\n\u002B                    \u0027to all publishers\u0027\n\u002B                )\n\u002B            qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n\u002B\n\u002B        # If all endpoints are transient_local, ask for transient_local\n\u002B        if durability_transient_local_endpoints_count == publishers_count:\n\u002B            qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n\u002B        else:\n\u002B            if durability_transient_local_endpoints_count \u003E 0:\n\u002B                print(\n\u002B                    \u0027Some, but not all, publishers are offering \u0027\n\u002B                    \u0027QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to \u0027\n\u002B                    \u0027QoSDurabilityPolicy.VOLATILE as it will connect \u0027\n\u002B                    \u0027to all publishers\u0027\n\u002B                )\n\u002B            qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n\u002B\n\u002B        return qos_profile\n\u002B\n     def main(self, *, args):\n \n         if args.lost_messages:\n@@ -107,14 \u002B195,10 @@ class EchoVerb(VerbExtension):\n         self.no_arr = args.no_arr\n         self.no_str = args.no_str\n \n-        qos_profile = qos_profile_from_short_keys(\n-            args.qos_profile,\n-            reliability=args.qos_reliability,\n-            durability=args.qos_durability,\n-            depth=args.qos_depth,\n-            history=args.qos_history)\n-\n         with NodeStrategy(args) as node:\n\u002B\n\u002B            qos_profile = self.choose_qos(node, args)\n\u002B\n             if args.message_type is None:\n                 message_type = get_msg_class(\n                     node, args.topic_name, include_hidden_topics=True)\ndiff --git ros2topic/ros2topic/verb/pub.py ros2topic/ros2topic/verb/pub.py\nindex 85ab0fc..9a46b63 100644\n--- ros2topic/ros2topic/verb/pub.py\n\u002B\u002B\u002B ros2topic/ros2topic/verb/pub.py\n@@ -20,7 \u002B20,6 @@ import rclpy\n from rclpy.node import Node\n from rclpy.qos import QoSProfile\n from ros2cli.node.direct import DirectNode\n-from ros2topic.api import add_qos_arguments_to_argument_parser\n from ros2topic.api import qos_profile_from_short_keys\n from ros2topic.api import TopicMessagePrototypeCompleter\n from ros2topic.api import TopicNameCompleter\n@@ -31,6 \u002B30,7 @@ from rosidl_runtime_py.utilities import get_message\n import yaml\n \n MsgType = TypeVar(\u0027MsgType\u0027)\n\u002Bdefault_profile_str = \u0027system_default\u0027\n \n \n def nonnegative_int(inval):\n@@ -90,16 \u002B90,49 @@ class PubVerb(VerbExtension):\n         parser.add_argument(\n             \u0027-n\u0027, \u0027--node-name\u0027,\n             help=\u0027Name of the created publishing node\u0027)\n-        add_qos_arguments_to_argument_parser(\n-            parser, is_publisher=True, default_preset=\u0027system_default\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-profile\u0027,\n\u002B            choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n\u002B            default=default_profile_str,\n\u002B            help=\u0027Quality of service preset profile to {} with (default: {})\u0027\n\u002B                 .format(\u0027publish\u0027, default_profile_str))\n\u002B        default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(\n\u002B            default_profile_str)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-depth\u0027, metavar=\u0027N\u0027, type=int, default=-1,\n\u002B            help=\u0027Queue size setting to publish with \u0027\n\u002B                 \u0027(overrides depth value of --qos-profile option)\u0027)\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-history\u0027,\n\u002B            choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n\u002B            help=\u0027History of samples setting to publish with \u0027\n\u002B                 \u0027(overrides history value of --qos-profile option, default: {})\u0027\n\u002B                 .format(default_profile.history.short_key))\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-reliability\u0027,\n\u002B            choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n\u002B            help=\u0027Quality of service reliability setting to publish with \u0027\n\u002B                 \u0027(overrides reliability value of --qos-profile option, default: {})\u0027\n\u002B                 .format(default_profile.reliability.short_key))\n\u002B        parser.add_argument(\n\u002B            \u0027--qos-durability\u0027,\n\u002B            choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n\u002B            help=\u0027Quality of service durability setting to publish with \u0027\n\u002B                 \u0027(overrides durability value of --qos-profile option, default: {})\u0027\n\u002B                 .format(default_profile.durability.short_key))\n \n     def main(self, *, args):\n         return main(args)\n \n \n def main(args):\n\u002B\n\u002B    qos_profile_name = args.qos_profile\n\u002B    if not qos_profile_name:\n\u002B        qos_profile_name = default_profile_str\n\u002B\n     qos_profile = qos_profile_from_short_keys(\n-        args.qos_profile, reliability=args.qos_reliability, durability=args.qos_durability,\n\u002B        qos_profile_name, reliability=args.qos_reliability, durability=args.qos_durability,\n         depth=args.qos_depth, history=args.qos_history)\n     times = args.times\n     if args.once:\n",
    "IsBackported": false
  },
  {
    "Repository": "rcutils",
    "SHA": "61b02641c9046065008459059dde1cfd7c390a05",
    "RawMessage": "Remove the temporary variable in RCUTILS_LOGGING_AUTOINIT (#290)",
    "Changes": "diff --git include/rcutils/logging.h include/rcutils/logging.h\nindex afd0831..8562131 100644\n--- include/rcutils/logging.h\n\u002B\u002B\u002B include/rcutils/logging.h\n@@ -516,17 \u002B516,18 @@ void rcutils_logging_console_output_handler(\n  * All logging macros ensure that this has been called once.\n  */\n #define RCUTILS_LOGGING_AUTOINIT \\\n-  if (RCUTILS_UNLIKELY(!g_rcutils_logging_initialized)) { \\\n-    rcutils_ret_t ret = rcutils_logging_initialize(); \\\n-    if (ret != RCUTILS_RET_OK) { \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n-        \u0022[rcutils|\u0022 __FILE__ \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \\\n-        \u0022] error initializing logging: \u0022); \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022); \\\n-      rcutils_reset_error(); \\\n\u002B  do { \\\n\u002B    if (RCUTILS_UNLIKELY(!g_rcutils_logging_initialized)) { \\\n\u002B      if (rcutils_logging_initialize() != RCUTILS_RET_OK) { \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n\u002B          \u0022[rcutils|\u0022 __FILE__ \u0022:\u0022 RCUTILS_STRINGIFY(__LINE__) \\\n\u002B          \u0022] error initializing logging: \u0022); \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n\u002B        RCUTILS_SAFE_FWRITE_TO_STDERR(\u0022\\n\u0022); \\\n\u002B        rcutils_reset_error(); \\\n\u002B      } \\\n     } \\\n-  }\n\u002B  } while (0)\n \n #ifdef __cplusplus\n }\ndiff --git resource/logging_macros.h.em resource/logging_macros.h.em\nindex f22d65c..7d72263 100644\n--- resource/logging_macros.h.em\n\u002B\u002B\u002B resource/logging_macros.h.em\n@@ -65,7 \u002B65,7 @@ extern \u0022C\u0022\n  */\n #define RCUTILS_LOG_COND_NAMED(severity, condition_before, condition_after, name, ...) \\\n   do { \\\n-    RCUTILS_LOGGING_AUTOINIT \\\n\u002B    RCUTILS_LOGGING_AUTOINIT; \\\n     static rcutils_log_location_t __rcutils_logging_location = {__func__, __FILE__, __LINE__}; \\\n     if (rcutils_logging_logger_is_enabled_for(name, severity)) { \\\n       condition_before \\\ndiff --git src/logging.c src/logging.c\nindex 65f6bda..59df0af 100644\n--- src/logging.c\n\u002B\u002B\u002B src/logging.c\n@@ -342,39 \u002B342,35 @@ rcutils_logging_severity_level_from_string(\n \n rcutils_logging_output_handler_t rcutils_logging_get_output_handler(void)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   return g_rcutils_logging_output_handler;\n }\n \n void rcutils_logging_set_output_handler(rcutils_logging_output_handler_t function)\n {\n-  // *INDENT-OFF* (prevent uncrustify from making unnecessary indents here)\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   g_rcutils_logging_output_handler = function;\n-  // *INDENT-ON*\n }\n \n int rcutils_logging_get_default_logger_level(void)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   return g_rcutils_logging_default_logger_level;\n }\n \n void rcutils_logging_set_default_logger_level(int level)\n {\n-  // *INDENT-OFF* (prevent uncrustify from making unnecessary indents here)\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   if (RCUTILS_LOG_SEVERITY_UNSET == level) {\n     // Restore the default\n     level = RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL;\n   }\n   g_rcutils_logging_default_logger_level = level;\n-  // *INDENT-ON*\n }\n \n int rcutils_logging_get_logger_level(const char * name)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   if (NULL == name) {\n     return -1;\n   }\n@@ -383,7 \u002B379,7 @@ int rcutils_logging_get_logger_level(const char * name)\n \n int rcutils_logging_get_logger_leveln(const char * name, size_t name_length)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   if (NULL == name) {\n     return -1;\n   }\n@@ -421,7 \u002B417,7 @@ int rcutils_logging_get_logger_leveln(const char * name, size_t name_length)\n \n int rcutils_logging_get_logger_effective_level(const char * name)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   if (NULL == name) {\n     return -1;\n   }\n@@ -453,7 \u002B449,7 @@ int rcutils_logging_get_logger_effective_level(const char * name)\n \n rcutils_ret_t rcutils_logging_set_logger_level(const char * name, int level)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   if (NULL == name) {\n     RCUTILS_SET_ERROR_MSG(\u0022Invalid logger name\u0022);\n     return RCUTILS_RET_INVALID_ARGUMENT;\n@@ -494,7 \u002B490,7 @@ rcutils_ret_t rcutils_logging_set_logger_level(const char * name, int level)\n \n bool rcutils_logging_logger_is_enabled_for(const char * name, int severity)\n {\n-  RCUTILS_LOGGING_AUTOINIT\n\u002B  RCUTILS_LOGGING_AUTOINIT;\n   int logger_level = g_rcutils_logging_default_logger_level;\n   if (name) {\n     logger_level = rcutils_logging_get_logger_effective_level(name);\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "ace4934c5bc687f569708c5cb8fc8efb5156a275",
    "RawMessage": "Refactor GID/GUID",
    "Changes": "diff --git rmw_gurumdds_cpp/CMakeLists.txt rmw_gurumdds_cpp/CMakeLists.txt\nindex a663ab8..55a3fef 100644\n--- rmw_gurumdds_cpp/CMakeLists.txt\n\u002B\u002B\u002B rmw_gurumdds_cpp/CMakeLists.txt\n@@ -61,6 \u002B61,7 @@ add_library(rmw_gurumdds_cpp\n   src/demangle.cpp\n   src/event_converter.cpp\n   src/get_entities.cpp\n\u002B  src/gid.cpp\n   src/graph_cache.cpp\n   src/identifier.cpp\n   src/names_and_types_helpers.cpp\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/cdr_serialization_buffer.inl rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/cdr_serialization_buffer.inl\nindex 3cbb1ea..5dba73e 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/cdr_serialization_buffer.inl\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/cdr_serialization_buffer.inl\n@@ -13,7 \u002B13,7 @@ inline CdrSerializationBuffer\u003Ctrue\u003E::CdrSerializationBuffer(uint8_t * buf, size_\n   if (size \u003C CDR_HEADER_SIZE) {\n     throw std::runtime_error(\u0022Insufficient buffer size\u0022);\n   }\n-  memset(buf, 0, CDR_HEADER_SIZE);\n\u002B  std::memset(buf, 0, CDR_HEADER_SIZE);\n   buf[CDR_HEADER_ENDIAN_IDX] = CDR_SYSTEM_ENDIAN;\n   buf_ = buf \u002B CDR_HEADER_SIZE;\n   size_ = size - CDR_HEADER_SIZE;\n@@ -85,7 \u002B85,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::operator\u003C\u003C(const std::string \u0026 sr\n     if (offset_ \u002B src.size() \u002B 1 \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, src.c_str(), src.size() \u002B 1);\n\u002B    std::memcpy(buf_ \u002B offset_, src.c_str(), src.size() \u002B 1);\n   }\n   advance(src.size() \u002B 1);\n }\n@@ -100,7 \u002B100,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::operator\u003C\u003C(const std::u16string \u0026\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n \n-    memcpy(buf_ \u002B offset_, src.data(), sizeof(char16_t) * src.size());\n\u002B    std::memcpy(buf_ \u002B offset_, src.data(), sizeof(char16_t) * src.size());\n   }\n   advance(src.size() * sizeof(char16_t));\n }\n@@ -114,7 \u002B114,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::operator\u003C\u003C(const rosidl_runtime_c\n     if (offset_ \u002B src.size \u002B 1 \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, src.data, src.size \u002B 1);\n\u002B    std::memcpy(buf_ \u002B offset_, src.data, src.size \u002B 1);\n   }\n   advance(src.size \u002B 1);\n }\n@@ -129,7 \u002B129,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::operator\u003C\u003C(const rosidl_runtime_c\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n \n-    memcpy(buf_ \u002B offset_, src.data, sizeof(char16_t) * src.size);\n\u002B    std::memcpy(buf_ \u002B offset_, src.data, sizeof(char16_t) * src.size);\n   }\n   advance(src.size * sizeof(char16_t));\n }\n@@ -146,7 \u002B146,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::copy_arr(const uint8_t * arr, siz\n     if (offset_ \u002B cnt * sizeof(uint8_t) \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint8_t));\n\u002B    std::memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint8_t));\n   }\n   advance(cnt * sizeof(uint8_t));\n }\n@@ -163,7 \u002B163,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::copy_arr(const uint16_t * arr, si\n     if (offset_ \u002B cnt * sizeof(uint16_t) \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint16_t));\n\u002B    std::memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint16_t));\n   }\n   advance(cnt * sizeof(uint16_t));\n }\n@@ -180,7 \u002B180,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::copy_arr(const uint32_t * arr, si\n     if (offset_ \u002B cnt * sizeof(uint32_t) \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint32_t));\n\u002B    std::memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint32_t));\n   }\n   advance(cnt * sizeof(uint32_t));\n }\n@@ -197,7 \u002B197,7 @@ inline void CdrSerializationBuffer\u003CSERIALIZE\u003E::copy_arr(const uint64_t * arr, si\n     if (offset_ \u002B cnt * sizeof(uint64_t) \u003E size_) {\n       throw std::runtime_error(\u0022Out of buffer\u0022);\n     }\n-    memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint64_t));\n\u002B    std::memcpy(buf_ \u002B offset_, arr, cnt * sizeof(uint64_t));\n   }\n   advance(cnt * sizeof(uint64_t));\n }\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.hpp\nindex bb06967..f24fa55 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.hpp\n@@ -15,39 \u002B15,49 @@\n #ifndef RMW_GURUMDDS__GID_HPP_\n #define RMW_GURUMDDS__GID_HPP_\n \n-#include \u003Ccstring\u003E\n-#include \u003Ciostream\u003E\n-#include \u003Cmap\u003E\n-#include \u003Cset\u003E\n-#include \u003Cstring\u003E\n-#include \u003Cvector\u003E\n-\n #include \u0022rmw/types.h\u0022\n \n\u002B#include \u0022rmw_dds_common/gid_utils.hpp\u0022\n\u002B\n #include \u0022rmw_gurumdds_cpp/dds_include.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n \n namespace rmw_gurumdds_cpp\n {\n-inline\n-void guid_to_gid(const dds_GUID_t \u0026 guid, rmw_gid_t \u0026 gid)\n-{\n-  static_assert(\n-    RMW_GID_STORAGE_SIZE \u003E= sizeof(guid),\n-    \u0022rmw_gid_t type too small for an dds GUID\u0022);\n-  memset(\u0026gid, 0, sizeof(gid));\n-  memcpy(gid.data, reinterpret_cast\u003Cconst void *\u003E(\u0026guid), sizeof(guid));\n-  gid.implementation_identifier = RMW_GURUMDDS_ID;\n-}\n-\n-inline\n-void entity_get_gid(dds_Entity * const entity, rmw_gid_t \u0026 gid)\n\u002Bvoid ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds);\n\u002B\n\u002Bvoid dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros);\n\u002B\n\u002Bvoid guid_to_gid(const dds_GUID_t \u0026 guid, rmw_gid_t \u0026 gid);\n\u002B\n\u002Bvoid entity_get_gid(dds_Entity * const entity, rmw_gid_t \u0026 gid);\n\u002B/**\n\u002B * Structure to hold GUID information for DDS instances.\n\u002B */\n\u002Bstruct Guid_t: public dds_GUID_t\n {\n-  dds_GUID_t dds_guid;\n-  if (dds_Entity_get_guid(entity, \u0026dds_guid) == dds_RETCODE_OK) {\n-    guid_to_gid(dds_guid, gid);\n-  }\n-}\n\u002B  static constexpr uint32_t ENTITYID_PARTICIPANT = 0x000001C1;\n\u002B\n\u002B  Guid_t();\n\u002B\n\u002B  Guid_t(const dds_GUID_t \u0026 other);\n\u002B\n\u002B  Guid_t(const dds_ParticipantBuiltinTopicData\u0026 builtin_topic_data);\n\u002B\n\u002B  template\u003Ctypename TBuiltinTopicData\u003E\n\u002B  Guid_t(const TBuiltinTopicData\u0026 builtin_topic_data);\n\u002B\n\u002B  template\u003Ctypename TBuiltinTopicData\u003E\n\u002B  static Guid_t for_participant(const TBuiltinTopicData\u0026 builtin_topic_data);\n\u002B\n\u002B  bool operator==(const dds_GUID_t \u0026 other) const;\n\u002B\n\u002B  bool operator!=(const Guid_t \u0026 other) const;\n\u002B\n\u002B  bool operator\u003C(const Guid_t \u0026 other) const;\n\u002B}; // struct Guid_t\n } // namespace rmw_gurumdds_cpp\n \n\u002B#include \u0022rmw_gurumdds_cpp/gid.inl\u0022\n\u002B\n #endif // RMW_GURUMDDS__GID_HPP_\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.inl rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.inl\nnew file mode 100644\nindex 0000000..4b78c7b\n--- /dev/null\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/gid.inl\n@@ -0,0 \u002B1,57 @@\n\u002B#ifndef RMW_GURUMDDS__GID_INL_\n\u002B#define RMW_GURUMDDS__GID_INL_\n\u002B\n\u002B#include \u003Ccstring\u003E\n\u002B\n\u002Bnamespace rmw_gurumdds_cpp\n\u002B{\n\u002Binline void ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds)\n\u002B{\n\u002B  std::memcpy(guid_dds, guid_ros, 12);\n\u002B  std::memcpy(\u0026guid_dds[12], \u0026guid_ros[12], 4);\n\u002B}\n\u002B\n\u002Binline void dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros)\n\u002B{\n\u002B  std::memcpy(guid_ros, guid_dds, 12);\n\u002B  std::memcpy(\u0026guid_ros[12], \u0026guid_dds[12], 4);\n\u002B}\n\u002B\n\u002Binline void guid_to_gid(const dds_GUID_t \u0026 guid, rmw_gid_t \u0026 gid)\n\u002B{\n\u002B  static_assert(\n\u002B    RMW_GID_STORAGE_SIZE \u003E= sizeof(guid),\n\u002B    \u0022rmw_gid_t type too small for an dds GUID\u0022);\n\u002B  std::memset(\u0026gid, 0, sizeof(gid));\n\u002B  std::memcpy(gid.data, reinterpret_cast\u003Cconst void *\u003E(\u0026guid), sizeof(guid));\n\u002B  gid.implementation_identifier = RMW_GURUMDDS_ID;\n\u002B}\n\u002B\n\u002Binline void entity_get_gid(dds_Entity * const entity, rmw_gid_t \u0026 gid)\n\u002B{\n\u002B  dds_GUID_t dds_guid;\n\u002B  if (dds_Entity_get_guid(entity, \u0026dds_guid) == dds_RETCODE_OK) {\n\u002B    guid_to_gid(dds_guid, gid);\n\u002B  }\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename TBuiltinTopicData\u003E\n\u002BGuid_t::Guid_t(const TBuiltinTopicData\u0026 builtin_topic_data) {\n\u002B  static_assert(std::is_same_v\u003CTBuiltinTopicData, dds_PublicationBuiltinTopicData\u003E\n\u002B    || std::is_same_v\u003CTBuiltinTopicData, dds_SubscriptionBuiltinTopicData\u003E);\n\u002B  std::memcpy(prefix, \u0026builtin_topic_data.participant_key, sizeof(prefix));\n\u002B  std::memcpy(\u0026entityId, \u0026builtin_topic_data.key, sizeof(entityId));\n\u002B}\n\u002B\n\u002Btemplate\u003Ctypename TBuiltinTopicData\u003E\n\u002BGuid_t Guid_t::for_participant(const TBuiltinTopicData\u0026 builtin_topic_data) {\n\u002B  static_assert(std::is_same_v\u003CTBuiltinTopicData, dds_PublicationBuiltinTopicData\u003E\n\u002B    || std::is_same_v\u003CTBuiltinTopicData, dds_SubscriptionBuiltinTopicData\u003E);\n\u002B  Guid_t guid;\n\u002B  std::memcpy(guid.prefix, \u0026builtin_topic_data.participant_key, sizeof(guid.prefix));\n\u002B  guid.entityId = ENTITYID_PARTICIPANT;\n\u002B  return guid;\n\u002B}\n\u002B} // namespace rmw_gurumdds_cpp\n\u002B\n\u002B#endif // RMW_GURUMDDS__GID_INL_\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/guid.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/guid.hpp\ndeleted file mode 100644\nindex 18364eb..0000000\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/guid.hpp\n\u002B\u002B\u002B /dev/null\n@@ -1,129 \u002B0,0 @@\n-// Copyright 2019 GurumNetworks, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#ifndef RMW_GURUMDDS__GUID_HPP_\n-#define RMW_GURUMDDS__GUID_HPP_\n-\n-#include \u003Ccstring\u003E\n-#include \u003Ciostream\u003E\n-#include \u003Cmap\u003E\n-#include \u003Cset\u003E\n-#include \u003Cstring\u003E\n-#include \u003Cvector\u003E\n-\n-#include \u0022rmw_gurumdds_cpp/dds_include.hpp\u0022\n-\n-namespace rmw_gurumdds_cpp\n-{\n-typedef uint8_t octet;\n-\n-/**\n- * Structure to hold GUID information for DDS instances.\n- */\n-struct GuidPrefix_t\n-{\n-  static constexpr size_t kSize = 16;\n-  octet value[kSize];\n-\n-  GuidPrefix_t()\n-  {\n-    memset(value, 0, kSize);\n-  }\n-\n-  explicit GuidPrefix_t(octet guid[kSize])\n-  {\n-    memcpy(value, guid, kSize);\n-  }\n-\n-  GuidPrefix_t(const GuidPrefix_t \u0026 g)\n-  {\n-    memcpy(value, g.value, kSize);\n-  }\n-\n-  GuidPrefix_t(GuidPrefix_t \u0026\u0026 g) noexcept\n-  {\n-    memmove(value, g.value, kSize);\n-  }\n-\n-  GuidPrefix_t \u0026 operator=(const GuidPrefix_t \u0026 guidpre)\n-  {\n-    memcpy(value, guidpre.value, kSize);\n-    return *this;\n-  }\n-\n-  GuidPrefix_t \u0026 operator=(GuidPrefix_t \u0026\u0026 guidpre) noexcept\n-  {\n-    memmove(value, guidpre.value, kSize);\n-    return *this;\n-  }\n-\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS_PUBLIC\n-\n-  bool operator==(const GuidPrefix_t \u0026 prefix) const\n-  {\n-    return memcmp(value, prefix.value, kSize) == 0;\n-  }\n-\n-  bool operator!=(const GuidPrefix_t \u0026 prefix) const\n-  {\n-    return memcmp(value, prefix.value, kSize) != 0;\n-  }\n-\n-#endif\n-};\n-\n-inline bool operator\u003C(const GuidPrefix_t \u0026 g1, const GuidPrefix_t \u0026 g2)\n-{\n-  for (uint8_t i = 0; i \u003C GuidPrefix_t::kSize; \u002B\u002Bi) {\n-    if (g1.value[i] \u003C g2.value[i]) {\n-      return true;\n-    } else if (g1.value[i] \u003E g2.value[i]) {\n-      return false;\n-    }\n-  }\n-  return false;\n-}\n-\n-inline std::ostream \u0026 operator\u003C\u003C(std::ostream \u0026 output, const GuidPrefix_t \u0026 guiP)\n-{\n-  output \u003C\u003C std::hex;\n-  for (uint8_t i = 0; i \u003C GuidPrefix_t::kSize - 1; \u002B\u002Bi) {\n-    output \u003C\u003C static_cast\u003Cint\u003E(guiP.value[i]) \u003C\u003C \u0022.\u0022;\n-  }\n-  output \u003C\u003C static_cast\u003Cint\u003E(guiP.value[GuidPrefix_t::kSize - 1]);\n-  return output \u003C\u003C std::dec;\n-}\n-\n-inline void dds_BuiltinTopicKey_to_GUID(\n-  struct GuidPrefix_t * guid,\n-  dds_BuiltinTopicKey_t btk)\n-{\n-  memset(guid-\u003Evalue, 0, GuidPrefix_t::kSize);\n-#if BIG_ENDIAN\n-  memcpy(guid-\u003Evalue, reinterpret_cast\u003Coctet *\u003E(btk.value), GuidPrefix_t::kSize - 4);\n-#else\n-  octet const * keyBuffer = reinterpret_cast\u003Coctet *\u003E(btk.value);\n-  for (uint8_t i = 0; i \u003C 3; \u002B\u002Bi) {\n-    octet * guidElement = \u0026(guid-\u003Evalue[i * 4]);\n-    octet const * keyBufferElement = keyBuffer \u002B (i * 4);\n-    guidElement[0] = keyBufferElement[3];\n-    guidElement[1] = keyBufferElement[2];\n-    guidElement[2] = keyBufferElement[1];\n-    guidElement[3] = keyBufferElement[0];\n-  }\n-#endif\n-}\n-} // namespace rmw_gurumdds_cpp\n-\n-#endif // RMW_GURUMDDS__GUID_HPP_\ndiff --git rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/type_support_service.hpp rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/type_support_service.hpp\nindex 685e8c7..d6e82c9 100644\n--- rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/type_support_service.hpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/include/rmw_gurumdds_cpp/type_support_service.hpp\n@@ -1009,20 \u002B1009,6 @@ deserialize_response_enhanced(\n   return false;\n }\n \n-inline void\n-ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds)\n-{\n-  memcpy(guid_dds, guid_ros, 12);\n-  memcpy(\u0026guid_dds[12], \u0026guid_ros[12], 4);\n-}\n-\n-inline void\n-dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros)\n-{\n-  memcpy(guid_ros, guid_dds, 12);\n-  memcpy(\u0026guid_ros[12], \u0026guid_dds[12], 4);\n-}\n-\n inline void\n ros_sn_to_dds_sn(int64_t sn_ros, uint64_t * sn_dds)\n {\ndiff --git rmw_gurumdds_cpp/src/cdr_deser_buffer.cpp rmw_gurumdds_cpp/src/cdr_deser_buffer.cpp\nindex 72ebd4c..fd9eb26 100644\n--- rmw_gurumdds_cpp/src/cdr_deser_buffer.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/cdr_deser_buffer.cpp\n@@ -186,7 \u002B186,7 @@ void CdrDeserializationBuffer::copy_arr(uint8_t * arr, size_t cnt) {\n   if (offset_ \u002B cnt \u003E size_) {\n     throw std::runtime_error(\u0022Out of buffer\u0022);\n   }\n-  memcpy(arr, buf_ \u002B offset_, cnt);\n\u002B  std::memcpy(arr, buf_ \u002B offset_, cnt);\n   advance(cnt);\n }\n \n@@ -206,7 \u002B206,7 @@ void CdrDeserializationBuffer::copy_arr(uint16_t * arr, size_t cnt) {\n       arr[i] = bswap16(src[i]);\n     }\n   } else {\n-    memcpy(arr, src, cnt * sizeof(uint16_t));\n\u002B    std::memcpy(arr, src, cnt * sizeof(uint16_t));\n   }\n   advance(cnt * sizeof(uint16_t));\n }\n@@ -227,7 \u002B227,7 @@ void CdrDeserializationBuffer::copy_arr(uint32_t * arr, size_t cnt) {\n       arr[i] = bswap32(src[i]);\n     }\n   } else {\n-    memcpy(arr, src, cnt * sizeof(uint32_t));\n\u002B    std::memcpy(arr, src, cnt * sizeof(uint32_t));\n   }\n   advance(cnt * sizeof(uint32_t));\n }\n@@ -248,7 \u002B248,7 @@ void CdrDeserializationBuffer::copy_arr(uint64_t * arr, size_t cnt) {\n       arr[i] = bswap32(src[i]);\n     }\n   } else {\n-    memcpy(arr, src, cnt * sizeof(uint64_t));\n\u002B    std::memcpy(arr, src, cnt * sizeof(uint64_t));\n   }\n   advance(cnt * sizeof(uint64_t));\n }\ndiff --git rmw_gurumdds_cpp/src/gid.cpp rmw_gurumdds_cpp/src/gid.cpp\nnew file mode 100644\nindex 0000000..751f233\n--- /dev/null\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/gid.cpp\n@@ -0,0 \u002B1,48 @@\n\u002B// Copyright 2019 GurumNetworks, Inc.\n\u002B//\n\u002B// Licensed under the Apache License, Version 2.0 (the \u0022License\u0022);\n\u002B// you may not use this file except in compliance with the License.\n\u002B// You may obtain a copy of the License at\n\u002B//\n\u002B//     http://www.apache.org/licenses/LICENSE-2.0\n\u002B//\n\u002B// Unless required by applicable law or agreed to in writing, software\n\u002B// distributed under the License is distributed on an \u0022AS IS\u0022 BASIS,\n\u002B// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u002B// See the License for the specific language governing permissions and\n\u002B// limitations under the License.\n\u002B\n\u002B#include \u003Ccstring\u003E\n\u002B#include \u003Ctype_traits\u003E\n\u002B\n\u002B#include \u0022rmw/types.h\u0022\n\u002B\n\u002B#include \u0022rmw_gurumdds_cpp/dds_include.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n\u002B\n\u002Bnamespace rmw_gurumdds_cpp\n\u002B{\n\u002BGuid_t::Guid_t() : dds_GUID_t{} {}\n\u002B\n\u002BGuid_t::Guid_t(const dds_GUID_t \u0026 other) : dds_GUID_t{other} {}\n\u002B\n\u002BGuid_t::Guid_t(const dds_ParticipantBuiltinTopicData\u0026 builtin_topic_data) {\n\u002B  std::memcpy(prefix, \u0026builtin_topic_data.key, sizeof(prefix));\n\u002B  entityId = ENTITYID_PARTICIPANT;\n\u002B}\n\u002B\n\u002Bbool Guid_t::operator==(const dds_GUID_t \u0026 other) const\n\u002B{\n\u002B  return std::memcmp(this, \u0026other, sizeof(dds_GUID_t)) == 0;\n\u002B}\n\u002B\n\u002Bbool Guid_t::operator!=(const Guid_t \u0026 other) const\n\u002B{\n\u002B  return std::memcmp(this, \u0026other, sizeof(dds_GUID_t)) != 0;\n\u002B}\n\u002B\n\u002Bbool Guid_t::operator\u003C(const Guid_t \u0026 other) const\n\u002B{\n\u002B  return std::memcmp(this, \u0026other, sizeof(dds_GUID_t)) \u003C 0;\n\u002B}\n\u002B} // namespace rmw_gurumdds_cpp\ndiff --git rmw_gurumdds_cpp/src/graph_cache.cpp rmw_gurumdds_cpp/src/graph_cache.cpp\nindex 0cc0e8e..97eae13 100644\n--- rmw_gurumdds_cpp/src/graph_cache.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/graph_cache.cpp\n@@ -20,16 \u002B20,15 @@\n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/context_listener_thread.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_publisher.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_subscription.hpp\u0022\n \n #include \u0022rosidl_typesupport_cpp/message_type_support.hpp\u0022\n \n-\n static rmw_ret_t add_entity(\n   rmw_context_impl_t * ctx,\n   const rmw_gid_t * const endp_gid,\n@@ -723,7 \u002B722,7 @@ on_participant_info(rmw_context_impl_t * ctx)\n       return RMW_RET_ERROR;\n     }\n     if (taken) {\n-      if (memcmp(\u0026msg.gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE) == 0) {\n\u002B      if (std::memcmp(\u0026msg.gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE) == 0) {\n         continue;\n       }\n \n@@ -752,7 \u002B751,7 @@ add_participant(\n   rmw_gid_t gid;\n   rmw_gurumdds_cpp::guid_to_gid(*dp_guid, gid);\n \n-  if (0 == memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n\u002B  if (0 == std::memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n     // Ignore own announcements\n     return RMW_RET_OK;\n   }\n@@ -775,7 \u002B774,7 @@ remove_participant(\n   rmw_gid_t gid;\n   rmw_gurumdds_cpp::guid_to_gid(*dp_guid, gid);\n \n-  if (0 == memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n\u002B  if (0 == std::memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n     // Ignore own announcements\n     return RMW_RET_OK;\n   }\n@@ -804,7 \u002B803,7 @@ add_remote_entity(\n   rmw_gurumdds_cpp::guid_to_gid(*endp_guid, endp_gid);\n   rmw_gurumdds_cpp::guid_to_gid(*dp_guid, dp_gid);\n \n-  if (0 == memcmp(dp_gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n\u002B  if (0 == std::memcmp(dp_gid.data, ctx-\u003Ecommon_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n     // Ignore own announcements\n     return RMW_RET_OK;\n   }\n@@ -847,7 \u002B846,7 @@ remove_entity(\n   rmw_gid_t gid;\n   rmw_gurumdds_cpp::guid_to_gid(*guid, gid);\n \n-  if (0 == memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, 12)) {\n\u002B  if (0 == std::memcmp(gid.data, ctx-\u003Ecommon_ctx.gid.data, 12)) {\n     // compare entities\u0027 GUID prefixes to determine whether they belong to the same participat\n     // (hence 12 instead of 16 bytes)\n     // Ignore own announcements\ndiff --git rmw_gurumdds_cpp/src/qos.cpp rmw_gurumdds_cpp/src/qos.cpp\nindex 4db1445..61eb793 100644\n--- rmw_gurumdds_cpp/src/qos.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/qos.cpp\n@@ -12,6 \u002B12,7 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n\u002B#include \u003Ccstring\u003E\n #include \u003Cstring\u003E\n \n #include \u0022rosidl_runtime_c/type_hash.h\u0022\n@@ -168,7 \u002B169,7 @@ get_datawriter_qos(\n     rmw_reset_error();\n   }\n \n-  memcpy(datawriter_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n\u002B  std::memcpy(datawriter_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n \n   return true;\n }\n@@ -196,7 \u002B197,7 @@ bool get_datareader_qos(\n     rmw_reset_error();\n   }\n \n-  memcpy(datareader_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n\u002B  std::memcpy(datareader_qos-\u003Euser_data.value, user_data_str.data(), user_data_str.size());\n \n   return true;\n }\ndiff --git rmw_gurumdds_cpp/src/rmw_client.cpp rmw_gurumdds_cpp/src/rmw_client.cpp\nindex 0102bd7..5f15767 100644\n--- rmw_gurumdds_cpp/src/rmw_client.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_client.cpp\n@@ -29,13 \u002B29,13 @@\n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/names_and_types_helpers.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/namespace_prefix.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/type_support_service.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/types.hpp\u0022\n \n@@ -352,7 \u002B352,7 @@ rmw_create_client(\n \n   // Set GUID\n   dds_DataWriter_get_guid(request_writer, client_guid);\n-  memcpy(client_info-\u003Ewriter_guid, client_guid, sizeof(client_guid));\n\u002B  std::memcpy(client_info-\u003Ewriter_guid, client_guid, sizeof(client_guid));\n \n   rmw_gurumdds_cpp::entity_get_gid(\n     reinterpret_cast\u003Cdds_Entity *\u003E(client_info-\u003Erequest_writer),\n@@ -366,7 \u002B366,7 @@ rmw_create_client(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for client\u0022);\n     goto fail;\n   }\n-  memset(rmw_client, 0, sizeof(rmw_client_t));\n\u002B  std::memset(rmw_client, 0, sizeof(rmw_client_t));\n \n   rmw_client-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n   rmw_client-\u003Edata = client_info;\n@@ -375,7 \u002B375,7 @@ rmw_create_client(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for client name\u0022);\n     goto fail;\n   }\n-  memcpy(const_cast\u003Cchar *\u003E(rmw_client-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n\u002B  std::memcpy(const_cast\u003Cchar *\u003E(rmw_client-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n \n   if (rmw_gurumdds_cpp::graph_cache::on_client_created(ctx, node, client_info) != RMW_RET_OK) {\n     RCUTILS_LOG_ERROR_NAMED(RMW_GURUMDDS_ID, \u0022failed to update graph for client creation\u0022);\n@@ -814,7 \u002B814,7 @@ rmw_send_request(\n     }\n \n     dds_SampleInfoEx sampleinfo_ex;\n-    memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B    std::memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n     rmw_gurumdds_cpp::ros_sn_to_dds_sn(\u002B\u002Bclient_info-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n     rmw_gurumdds_cpp::ros_guid_to_dds_guid(\n       reinterpret_cast\u003Cconst uint8_t *\u003E(client_info-\u003Ewriter_guid),\n@@ -952,7 \u002B952,7 @@ rmw_take_response(\n           return RMW_RET_ERROR;\n         }\n \n-        if (memcmp(client_info-\u003Ewriter_guid, client_guid, 16) == 0) {\n\u002B        if (std::memcmp(client_info-\u003Ewriter_guid, client_guid, RMW_GID_STORAGE_SIZE) == 0) {\n           request_header-\u003Esource_timestamp =\n             sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sample_info-\u003Esource_timestamp.nanosec;\n@@ -960,7 \u002B960,7 @@ rmw_take_response(\n             sampleinfo_ex-\u003Ereception_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sampleinfo_ex-\u003Ereception_timestamp.nanosec;\n           request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n-          memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B          std::memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);\n \n           *taken = true;\n         }\n@@ -1027,7 \u002B1027,7 @@ rmw_take_response(\n           return RMW_RET_ERROR;\n         }\n \n-        if (memcmp(client_info-\u003Ewriter_guid, client_guid, 16) == 0) {\n\u002B        if (std::memcmp(client_info-\u003Ewriter_guid, client_guid, RMW_GID_STORAGE_SIZE) == 0) {\n           request_header-\u003Esource_timestamp =\n             sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sample_info-\u003Esource_timestamp.nanosec;\n@@ -1035,7 \u002B1035,7 @@ rmw_take_response(\n             sampleinfo_ex-\u003Ereception_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n             sampleinfo_ex-\u003Ereception_timestamp.nanosec;\n           request_header-\u003Erequest_id.sequence_number = sequence_number;\n-          memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B          std::memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);\n \n           *taken = true;\n         }\ndiff --git rmw_gurumdds_cpp/src/rmw_compare_gids_equal.cpp rmw_gurumdds_cpp/src/rmw_compare_gids_equal.cpp\nindex c5ab8ca..d351b44 100644\n--- rmw_gurumdds_cpp/src/rmw_compare_gids_equal.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_compare_gids_equal.cpp\n@@ -17,6 \u002B17,8 @@\n #include \u0022rmw/rmw.h\u0022\n #include \u0022rmw/types.h\u0022\n \n\u002B#include \u0022rmw_dds_common/gid_utils.hpp\u0022\n\u002B\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n \n extern \u0022C\u0022\n@@ -38,7 \u002B40,7 @@ rmw_compare_gids_equal(const rmw_gid_t * gid1, const rmw_gid_t * gid2, bool * re\n     return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n   RMW_CHECK_ARGUMENT_FOR_NULL(result, RMW_RET_INVALID_ARGUMENT);\n \n-  *result = memcmp(gid1-\u003Edata, gid2-\u003Edata, 16) == 0;\n\u002B  *result = gid1 == gid2;\n   return RMW_RET_OK;\n }\n }  // extern \u0022C\u0022\ndiff --git rmw_gurumdds_cpp/src/rmw_context_impl.cpp rmw_gurumdds_cpp/src/rmw_context_impl.cpp\nindex 34d8952..41cd817 100644\n--- rmw_gurumdds_cpp/src/rmw_context_impl.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_context_impl.cpp\n@@ -12,6 \u002B12,8 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n\u002B#include \u003Ccstring\u003E\n\u002B\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n \n using rmw_dds_common::msg::ParticipantEntitiesInfo;\n@@ -170,8 \u002B172,8 @@ rmw_context_impl_s::initialize_participant(\n   }\n \n   participant_qos.user_data.size = node_user_data.size();\n-  memset(participant_qos.user_data.value, 0, sizeof(participant_qos.user_data.value));\n-  memcpy(participant_qos.user_data.value, node_user_data.c_str(), node_user_data.size());\n\u002B  std::memset(participant_qos.user_data.value, 0, sizeof(participant_qos.user_data.value));\n\u002B  std::memcpy(participant_qos.user_data.value, node_user_data.c_str(), node_user_data.size());\n \n   std::string static_discovery_id;\n   static_discovery_id \u002B= node_namespace;\ndiff --git rmw_gurumdds_cpp/src/rmw_get_topic_endpoint_info.cpp rmw_gurumdds_cpp/src/rmw_get_topic_endpoint_info.cpp\nindex 21dba28..b8c162f 100644\n--- rmw_gurumdds_cpp/src/rmw_get_topic_endpoint_info.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_get_topic_endpoint_info.cpp\n@@ -22,11 \u002B22,11 @@\n #include \u0022rmw/types.h\u0022\n \n #include \u0022rmw_gurumdds_cpp/demangle.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/guid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/names_and_types_helpers.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/namespace_prefix.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n \n extern \u0022C\u0022\n {\ndiff --git rmw_gurumdds_cpp/src/rmw_node.cpp rmw_gurumdds_cpp/src/rmw_node.cpp\nindex 3b898a4..36352e9 100644\n--- rmw_gurumdds_cpp/src/rmw_node.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_node.cpp\n@@ -13,6 \u002B13,7 @@\n // limitations under the License.\n \n #include \u003Carray\u003E\n\u002B#include \u003Ccstring\u003E\n \n #include \u0022rcutils/filesystem.h\u0022\n #include \u0022rcutils/logging_macros.h\u0022\n@@ -140,7 \u002B141,7 @@ rmw_create_node(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for node name\u0022);\n     return nullptr;\n   }\n-  memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Ename), name, strlen(name) \u002B 1);\n\u002B  std::memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Ename), name, strlen(name) \u002B 1);\n \n   node_handle-\u003Enamespace_ =\n     static_cast\u003Cconst char *\u003E(rmw_allocate(sizeof(char) * strlen(namespace_) \u002B 1));\n@@ -148,7 \u002B149,7 @@ rmw_create_node(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for node namespace\u0022);\n     return nullptr;\n   }\n-  memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Enamespace_), namespace_, strlen(namespace_) \u002B 1);\n\u002B  std::memcpy(const_cast\u003Cchar *\u003E(node_handle-\u003Enamespace_), namespace_, strlen(namespace_) \u002B 1);\n \n   node_handle-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n   node_handle-\u003Edata = nullptr;\ndiff --git rmw_gurumdds_cpp/src/rmw_publisher.cpp rmw_gurumdds_cpp/src/rmw_publisher.cpp\nindex 7771fb2..0fe6745 100644\n--- rmw_gurumdds_cpp/src/rmw_publisher.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_publisher.cpp\n@@ -28,13 \u002B28,13 @@\n \n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n-#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/names_and_types_helpers.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/namespace_prefix.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_publisher.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/type_support_common.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/type_support_service.hpp\u0022\n@@ -238,7 \u002B238,7 @@ create_publisher(\n     RCUTILS_LOG_ERROR_NAMED(RMW_GURUMDDS_ID, \u0022failed to allocate publisher\u0027s topic name\u0022);\n     return nullptr;\n   }\n-  memcpy(\n\u002B  std::memcpy(\n     const_cast\u003Cchar *\u003E(rmw_publisher-\u003Etopic_name),\n     topic_name,\n     strlen(topic_name) \u002B 1);\n@@ -362,9 \u002B362,9 @@ rmw_ret_t publish(\n   }\n \n   dds_SampleInfoEx sampleinfo_ex;\n-  memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B  std::memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n   ros_sn_to_dds_sn(\u002B\u002Bpublisher_info-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n-  ros_guid_to_dds_guid(\n\u002B  rmw_gurumdds_cpp::ros_guid_to_dds_guid(\n       reinterpret_cast\u003Cconst uint8_t *\u003E(publisher_info-\u003Epublisher_gid.data),\n       reinterpret_cast\u003Cuint8_t *\u003E(\u0026sampleinfo_ex.src_guid));\n \ndiff --git rmw_gurumdds_cpp/src/rmw_service.cpp rmw_gurumdds_cpp/src/rmw_service.cpp\nindex b8aaf4e..97b8697 100644\n--- rmw_gurumdds_cpp/src/rmw_service.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_service.cpp\n@@ -26,13 \u002B26,13 @@\n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/names_and_types_helpers.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/namespace_prefix.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/types.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/type_support_service.hpp\u0022\n@@ -358,7 \u002B358,7 @@ rmw_create_service(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for service\u0022);\n     goto fail;\n   }\n-  memset(rmw_service, 0, sizeof(rmw_service_t));\n\u002B  std::memset(rmw_service, 0, sizeof(rmw_service_t));\n   rmw_service-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n   rmw_service-\u003Edata = service_info;\n   rmw_service-\u003Eservice_name =\n@@ -367,7 \u002B367,7 @@ rmw_create_service(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for service name\u0022);\n     goto fail;\n   }\n-  memcpy(const_cast\u003Cchar *\u003E(rmw_service-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n\u002B  std::memcpy(const_cast\u003Cchar *\u003E(rmw_service-\u003Eservice_name), service_name, strlen(service_name) \u002B 1);\n \n   if (rmw_gurumdds_cpp::graph_cache::on_service_created(ctx, node, service_info) != RMW_RET_OK) {\n     RCUTILS_LOG_ERROR_NAMED(RMW_GURUMDDS_ID, \u0022failed to update graph for service creation\u0022);\n@@ -722,7 \u002B722,7 @@ rmw_take_request(\n         sampleinfo_ex-\u003Ereception_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sampleinfo_ex-\u003Ereception_timestamp.nanosec;\n       request_header-\u003Erequest_id.sequence_number = ((int64_t)sn_high) \u003C\u003C 32 | sn_low;\n-      memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B      std::memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);\n     }\n \n     dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n@@ -792,7 \u002B792,7 @@ rmw_take_request(\n         sampleinfo_ex-\u003Ereception_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sampleinfo_ex-\u003Ereception_timestamp.nanosec;\n       request_header-\u003Erequest_id.sequence_number = sequence_number;\n-      memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, 16);\n\u002B      std::memcpy(request_header-\u003Erequest_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);\n     }\n \n     dds_DataReader_raw_return_loan(request_reader, data_values, sample_infos, sample_sizes);\n@@ -901,7 \u002B901,7 @@ rmw_send_response(\n     }\n \n     dds_SampleInfoEx sampleinfo_ex;\n-    memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n\u002B    std::memset(\u0026sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n     rmw_gurumdds_cpp::ros_sn_to_dds_sn(request_header-\u003Esequence_number, \u0026sampleinfo_ex.seq);\n     rmw_gurumdds_cpp::ros_guid_to_dds_guid(\n       request_header-\u003Ewriter_guid,\ndiff --git rmw_gurumdds_cpp/src/rmw_subscription.cpp rmw_gurumdds_cpp/src/rmw_subscription.cpp\nindex 81b1506..7966520 100644\n--- rmw_gurumdds_cpp/src/rmw_subscription.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_subscription.cpp\n@@ -28,13 \u002B28,13 @@\n #include \u0022rmw_dds_common/qos.hpp\u0022\n \n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/identifier.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/names_and_types_helpers.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/namespace_prefix.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_subscription.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/type_support_common.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/type_support_service.hpp\u0022\n@@ -280,7 \u002B280,7 @@ create_subscription(\n     RMW_SET_ERROR_MSG(\u0022failed to allocate memory for topic name\u0022);\n     return nullptr;\n   }\n-  memcpy(\n\u002B  std::memcpy(\n     const_cast\u003Cchar *\u003E(rmw_subscription-\u003Etopic_name),\n     topic_name,\n     strlen(topic_name) \u002B 1);\n@@ -473,7 \u002B473,7 @@ take(\n     if (message_info != nullptr) {\n       int64_t sequence_number = 0;\n       dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n-      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B      rmw_gurumdds_cpp::dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n@@ -484,14 \u002B484,14 @@ take(\n       message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n       sender_gid-\u003Eimplementation_identifier = identifier;\n-      memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B      std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n         topic_reader, sample_info-\u003Epublication_handle, sender_gid-\u003Edata);\n       if (ret != dds_RETCODE_OK) {\n         if (ret == dds_RETCODE_ERROR) {\n           RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \u0022Failed to get publication handle\u0022);\n         }\n-        memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B        std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       }\n     }\n   }\n@@ -602,14 \u002B602,14 @@ take_serialized(\n       }\n     }\n \n-    memcpy(serialized_message-\u003Ebuffer, sample, sample_size);\n\u002B    std::memcpy(serialized_message-\u003Ebuffer, sample, sample_size);\n \n     *taken = true;\n \n     if (message_info != nullptr) {\n       int64_t sequence_number = 0;\n       dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast\u003Cdds_SampleInfoEx *\u003E(sample_info);\n-      dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n\u002B      rmw_gurumdds_cpp::dds_sn_to_ros_sn(sampleinfo_ex-\u003Eseq, \u0026sequence_number);\n       message_info-\u003Esource_timestamp =\n         sample_info-\u003Esource_timestamp.sec * static_cast\u003Cint64_t\u003E(1000000000) \u002B\n         sample_info-\u003Esource_timestamp.nanosec;\n@@ -620,14 \u002B620,14 @@ take_serialized(\n       message_info-\u003Ereception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n       rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n       sender_gid-\u003Eimplementation_identifier = identifier;\n-      memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B      std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n         topic_reader, sample_info-\u003Epublication_handle, sender_gid-\u003Edata);\n       if (ret != dds_RETCODE_OK) {\n         if (ret == dds_RETCODE_ERROR) {\n           RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \u0022Failed to get publication handle\u0022);\n         }\n-        memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B        std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n       }\n     }\n   }\n@@ -1054,7 \u002B1054,7 @@ rmw_take_sequence(\n           sampleinfo_ex-\u003Ereception_timestamp.nanosec;\n         rmw_gid_t * sender_gid = \u0026message_info-\u003Epublisher_gid;\n         sender_gid-\u003Eimplementation_identifier = RMW_GURUMDDS_ID;\n-        memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B        std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n \n         dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n           topic_reader, sample_info-\u003Epublication_handle, sender_gid-\u003Edata);\n@@ -1062,7 \u002B1062,7 @@ rmw_take_sequence(\n           if (ret == dds_RETCODE_ERROR) {\n             RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \u0022Failed to get publication handle\u0022);\n           }\n-          memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n\u002B          std::memset(sender_gid-\u003Edata, 0, RMW_GID_STORAGE_SIZE);\n         }\n \n         (*taken)\u002B\u002B;\ndiff --git rmw_gurumdds_cpp/src/types.cpp rmw_gurumdds_cpp/src/types.cpp\nindex d6913d6..f80f865 100644\n--- rmw_gurumdds_cpp/src/types.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/types.cpp\n@@ -18,9 \u002B18,9 @@\n \n #include \u0022rmw_gurumdds_cpp/event_converter.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/graph_cache.hpp\u0022\n-#include \u0022rmw_gurumdds_cpp/guid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/qos.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/rmw_context_impl.hpp\u0022\n\u002B#include \u0022rmw_gurumdds_cpp/gid.hpp\u0022\n #include \u0022rmw_gurumdds_cpp/types.hpp\u0022\n \n #define ENTITYID_PARTICIPANT 0x000001C1\n@@ -340,21 \u002B340,15 @@ void on_participant_changed(\n   const dds_ParticipantBuiltinTopicData * data,\n   dds_InstanceHandle_t handle)\n {\n-  dds_DomainParticipant * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0));\n-\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n   if (ctx == nullptr) {\n     return;\n   }\n \n-  dds_GUID_t dp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(\u0026dp_guid_prefix, data-\u003Ekey);\n-  memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-  dp_guid.entityId = ENTITYID_PARTICIPANT;\n-\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid{*data};\n   if (handle == dds_HANDLE_NIL) {\n     rmw_gurumdds_cpp::graph_cache::remove_participant(ctx, \u0026dp_guid);\n   } else {\n@@ -384,36 \u002B378,28 @@ void on_publication_changed(\n   const dds_PublicationBuiltinTopicData * data,\n   dds_InstanceHandle_t handle)\n {\n-  dds_DomainParticipant * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0));\n-\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n   if (ctx == nullptr) {\n     return;\n   }\n \n-  dds_GUID_t endp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix, endp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(\u0026dp_guid_prefix, data-\u003Eparticipant_key);\n-  memcpy(endp_guid.prefix, dp_guid_prefix.value, sizeof(endp_guid.prefix));\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(\u0026endp_guid_prefix, data-\u003Ekey);\n-  memcpy(\u0026endp_guid.entityId, endp_guid_prefix.value, sizeof(endp_guid.entityId));\n-\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n\u002B  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n\u002B  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n\u002B  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n   if (handle == dds_HANDLE_NIL) {\n     RCUTILS_LOG_DEBUG_NAMED(\n       \u0022pub on data available\u0022,\n       \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[2],\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n       endp_guid.entityId);\n     rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n   } else {\n-    dds_GUID_t dp_guid;\n-    memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-    dp_guid.entityId = ENTITYID_PARTICIPANT;\n-\n     rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n       ctx,\n       \u0026endp_guid,\n@@ -427,18 \u002B413,17 @@ void on_publication_changed(\n       \u0026data-\u003Eliveliness,\n       \u0026data-\u003Elifespan,\n       false);\n-\n     RCUTILS_LOG_DEBUG_NAMED(\n       \u0022pub on data available\u0022,\n       \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n       \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[2],\n\u002B      dp_guid_prefix[0],\n\u002B      dp_guid_prefix[1],\n\u002B      dp_guid_prefix[2],\n       dp_guid.entityId,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[2],\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n       endp_guid.entityId);\n   }\n }\n@@ -448,36 \u002B433,28 @@ void on_subscription_changed(\n   const dds_SubscriptionBuiltinTopicData * data,\n   dds_InstanceHandle_t handle)\n {\n-  dds_DomainParticipant * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n-    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0));\n-\n\u002B  auto * participant = const_cast\u003Cdds_DomainParticipant *\u003E(a_participant);\n\u002B  auto * ctx = reinterpret_cast\u003Crmw_context_impl_t *\u003E(\n\u002B    dds_Entity_get_context(reinterpret_cast\u003Cdds_Entity *\u003E(participant), 0)\n\u002B  );\n   if (ctx == nullptr) {\n     return;\n   }\n \n-  dds_GUID_t endp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix, endp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(\u0026dp_guid_prefix, data-\u003Eparticipant_key);\n-  memcpy(endp_guid.prefix, dp_guid_prefix.value, sizeof(endp_guid.prefix));\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(\u0026endp_guid_prefix, data-\u003Ekey);\n-  memcpy(\u0026endp_guid.entityId, endp_guid_prefix.value, sizeof(endp_guid.entityId));\n-\n\u002B  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n\u002B  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n\u002B  const auto * dp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix);\n\u002B  const auto * endp_guid_prefix = reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix);\n   if (handle == dds_HANDLE_NIL) {\n     RCUTILS_LOG_DEBUG_NAMED(\n       \u0022sub on data available\u0022,\n       \u0022[ud] endp_gid=0x%08X.0x%08X.0x%08X.0x%08X \u0022,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[2],\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n       endp_guid.entityId);\n     rmw_gurumdds_cpp::graph_cache::remove_entity(ctx, \u0026endp_guid, false);\n   } else {\n-    dds_GUID_t dp_guid;\n-    memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-    dp_guid.entityId = ENTITYID_PARTICIPANT;\n-\n     rmw_gurumdds_cpp::graph_cache::add_remote_entity(\n       ctx,\n       \u0026endp_guid,\n@@ -491,18 \u002B468,17 @@ void on_subscription_changed(\n       \u0026data-\u003Eliveliness,\n       nullptr,\n       true);\n-\n     RCUTILS_LOG_DEBUG_NAMED(\n       \u0022sub on data available\u0022,\n       \u0022dp_gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022\n       \u0022gid=0x%08X.0x%08X.0x%08X.0x%08X, \u0022,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(dp_guid.prefix)[2],\n\u002B      dp_guid_prefix[0],\n\u002B      dp_guid_prefix[1],\n\u002B      dp_guid_prefix[2],\n       dp_guid.entityId,\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[0],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[1],\n-      reinterpret_cast\u003Cconst uint32_t *\u003E(endp_guid.prefix)[2],\n\u002B      endp_guid_prefix[0],\n\u002B      endp_guid_prefix[1],\n\u002B      endp_guid_prefix[2],\n       endp_guid.entityId);\n   }\n }\n",
    "IsBackported": false
  },
  {
    "Repository": "rclcpp",
    "SHA": "d5ec2580805c3abd8b6fecaf3d09040e00e9f15e",
    "RawMessage": "typo fix. (#1790)",
    "Changes": "diff --git rclcpp/include/rclcpp/subscription_base.hpp rclcpp/include/rclcpp/subscription_base.hpp\nindex 7653292b..72ddc23b 100644\n--- rclcpp/include/rclcpp/subscription_base.hpp\n\u002B\u002B\u002B rclcpp/include/rclcpp/subscription_base.hpp\n@@ -107,7 \u002B107,7 @@ public:\n   /// Get the actual QoS settings, after the defaults have been determined.\n   /**\n    * The actual configuration applied when using RMW_QOS_POLICY_*_SYSTEM_DEFAULT\n-   * can only be resolved after the creation of the publisher, and it\n\u002B   * can only be resolved after the creation of the subscription, and it\n    * depends on the underlying rmw implementation.\n    * If the underlying setting in use can\u0027t be represented in ROS terms,\n    * it will be set to RMW_QOS_POLICY_*_UNKNOWN.\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_implementation",
    "SHA": "e9f60082b76e0621629c146d160b72bdac82ae45",
    "RawMessage": "Make sure to find_package(rmw) in rmw_implementation. (#242)",
    "Changes": "diff --git rmw_implementation/CMakeLists.txt rmw_implementation/CMakeLists.txt\nindex 39c1ff3..ca542c5 100644\n--- rmw_implementation/CMakeLists.txt\n\u002B\u002B\u002B rmw_implementation/CMakeLists.txt\n@@ -13,6 \u002B13,7 @@ if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0022Clang\u0022)\n endif()\n \n find_package(ament_cmake REQUIRED)\n\u002Bfind_package(rmw REQUIRED)\n find_package(rmw_implementation_cmake REQUIRED)\n \n if(BUILD_TESTING)\n",
    "BackportedTo": "jazzy",
    "IsBackported": true
  },
  {
    "Repository": "ros2cli",
    "SHA": "8e46bf2608d04e81a3d088ccc5087dbde9f3e32f",
    "RawMessage": "cosmetic fixes for ros2param dump command. (#933)",
    "Changes": "diff --git ros2param/ros2param/verb/dump.py ros2param/ros2param/verb/dump.py\nindex d5c3de7..a34d348 100644\n--- ros2param/ros2param/verb/dump.py\n\u002B\u002B\u002B ros2param/ros2param/verb/dump.py\n@@ -46,19 \u002B46,6 @@ class DumpVerb(VerbExtension):\n             \u0027--timeout\u0027, metavar=\u0027N\u0027, type=int, default=1,\n             help=\u0027Wait for N seconds until node becomes available (default %(default)s sec)\u0027)\n \n-    @staticmethod\n-    def get_parameter_values(node, node_name, params):\n-        response = call_get_parameters(\n-            node=node, node_name=node_name,\n-            parameter_names=params)\n-\n-        # requested parameter not set\n-        if not response.values:\n-            return None\n-\n-        # extract type specific value\n-        return [get_value(parameter_value=i) for i in response.values]\n-\n     def insert_dict(self, dictionary, key, value):\n         split = key.split(PARAMETER_SEPARATOR_STRING, 1)\n         if len(split) \u003E 1:\n@@ -80,7 \u002B67,7 @@ class DumpVerb(VerbExtension):\n         with DirectNode(args) as node:\n             yaml_output = {node_name.full_name: {\u0027ros__parameters\u0027: {}}}\n \n-            # retrieve values\n\u002B            # retrieve parameter names\n             response = call_list_parameters(node=node, node_name=absolute_node_name)\n             if response is None:\n                 print(\n@@ -93,17 \u002B80,26 @@ class DumpVerb(VerbExtension):\n                     \u0027Exception while calling list_parameters service of node \u0027\n                     f\u0022\u0027{node_name.full_name}\u0027: {e}\u0022, file=sys.stderr)\n                 return\n-\n-            response = response.result().result.names\n-            response = sorted(response)\n-            parameter_values = self.get_parameter_values(node, absolute_node_name, response)\n-            if parameter_values is None:\n\u002B            parameter_names = sorted(response.result().result.names)\n\u002B\n\u002B            # retrieve parameter values\n\u002B            response = None\n\u002B            try:\n\u002B                response = call_get_parameters(\n\u002B                    node=node, node_name=absolute_node_name, parameter_names=parameter_names)\n\u002B            except RuntimeError as e:\n                 print(\n                     \u0027Exception while calling get_parameters service of node \u0027\n                     f\u0022\u0027{node_name.full_name}\u0027: {e}\u0022, file=sys.stderr)\n                 return\n-\n-            for param_name, pval in zip(response, parameter_values):\n\u002B            if response.values is None:\n\u002B                # pass through here, no parameters are available with this node.\n\u002B                # since this is not failure, it proceeds to print the yaml as consistent behavior.\n\u002B                pass\n\u002B            parameter_values = [get_value(parameter_value=i) for i in response.values]\n\u002B\n\u002B            # create dictionary with parameter names and values\n\u002B            for param_name, pval in zip(parameter_names, parameter_values):\n                 self.insert_dict(\n                     yaml_output[node_name.full_name][\u0027ros__parameters\u0027], param_name, pval)\n \n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw_gurumdds",
    "SHA": "5f1637c48b5a876beaeebf2c53b249faf6fc467b",
    "RawMessage": "Update feature support",
    "Changes": "diff --git rmw_gurumdds_cpp/src/rmw_features.cpp rmw_gurumdds_cpp/src/rmw_features.cpp\nindex 2b335e0..e9511fa 100644\n--- rmw_gurumdds_cpp/src/rmw_features.cpp\n\u002B\u002B\u002B rmw_gurumdds_cpp/src/rmw_features.cpp\n@@ -17,5 \u002B17,11 @@\n bool\n rmw_feature_supported(rmw_feature_t feature)\n {\n-  return feature == RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER ? true : false;\n\u002B  switch(feature) {\n\u002B    case RMW_FEATURE_MESSAGE_INFO_RECEPTION_SEQUENCE_NUMBER:\n\u002B    case RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER:\n\u002B      return true;\n\u002B    default:\n\u002B      return false;\n\u002B  }\n }\n",
    "IsBackported": false
  },
  {
    "Repository": "rcpputils",
    "SHA": "99f2644c9dbc5673b4782005abaa7e5622638c71",
    "RawMessage": "Fix include order for cpplint (#158)",
    "Changes": "diff --git test/test_accumulator.cpp test/test_accumulator.cpp\nindex da31676..c4ec50b 100644\n--- test/test_accumulator.cpp\n\u002B\u002B\u002B test/test_accumulator.cpp\n@@ -20,12 \u002B20,12 @@\n #endif\n #endif\n \n-#include \u003Crcppmath/rolling_mean_accumulator.hpp\u003E\n-\n-#include \u003Cgtest/gtest.h\u003E\n #include \u003Ccmath\u003E\n #include \u003Cmemory\u003E\n \n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcppmath/rolling_mean_accumulator.hpp\u0022\n \n TEST(TestAccumulator, test_accumulator)\n {\ndiff --git test/test_env.cpp test/test_env.cpp\nindex 30a3e0e..81ca59c 100644\n--- test/test_env.cpp\n\u002B\u002B\u002B test/test_env.cpp\n@@ -12,13 \u002B12,12 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#include \u003Cgtest/gtest.h\u003E\n-\n-#include \u003Crcpputils/env.hpp\u003E\n-\n #include \u003Cstdexcept\u003E\n #include \u003Cstring\u003E\n \n\u002B#include \u0022gtest/gtest.h\u0022\n\u002B\n\u002B#include \u0022rcpputils/env.hpp\u0022\n \n /* Tests get_env_var.\n  *\n",
    "IsBackported": false
  },
  {
    "Repository": "rviz",
    "SHA": "e3b56ed7058502d94fe3d1c27948d4f4e9be58a8",
    "RawMessage": "Added Effort plugin (#990)",
    "Changes": "diff --git README.md README.md\nindex a3554090..989667a4 100644\n--- README.md\n\u002B\u002B\u002B README.md\n@@ -15,13 \u002B15,14 @@ For some displays, the [documentation is updated](docs/FEATURES.md).\n | Displays              | Tools         | View Controller       | Panels          |\n | --------------------- | ------------- | --------------------- | --------------- |\n | Axes                  | Move Camera   | Orbit                 | Displays        |\n-| Camera                | Focus Camera  | XY Orbit              | Help            | \n-| Fluid Pressure        | Measure       | First Person          | Selections      |\n-| Grid                  | Select        | Third Person Follower | Time            |\n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Illuminance           | Publish Point |                       | Views           |\n-| Image                 | Initial Pose  |\n-| Interactive Marker    | Interact      |\n\u002B| Camera                | Focus Camera  | XY Orbit              | Help            |\n\u002B| Effort                | Measure       | First Person          | Selections      |\n\u002B| Fluid                 | Select        | Third Person Follower | Time            |\n\u002B| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n\u002B| Grid Cells            | Publish Point |                       | Views           |\n\u002B| Illuminance           | Initial Pose  |\n\u002B| Image                 | Interact      |\n\u002B| Interactive Marker    |\n | Laser Scan            |\n | Map                   |\n | Marker                |\n@@ -47,7 \u002B48,6 @@ These features have not been ported to \u0060ros2/rviz\u0060 yet.\n | Displays      |\n | ------------- |\n | DepthCloud    |\n-| Effort        |\n \n Other features:\n - Stereo\ndiff --git rviz_default_plugins/CMakeLists.txt rviz_default_plugins/CMakeLists.txt\nindex 5e8aecc6..e3091993 100644\n--- rviz_default_plugins/CMakeLists.txt\n\u002B\u002B\u002B rviz_default_plugins/CMakeLists.txt\n@@ -82,6 \u002B82,7 @@ find_package(visualization_msgs REQUIRED)\n set(rviz_default_plugins_headers_to_moc\n   include/rviz_default_plugins/displays/axes/axes_display.hpp\n   include/rviz_default_plugins/displays/camera/camera_display.hpp\n\u002B  include/rviz_default_plugins/displays/effort/effort_display.hpp\n   include/rviz_default_plugins/displays/fluid_pressure/fluid_pressure_display.hpp\n   include/rviz_default_plugins/displays/grid/grid_display.hpp\n   include/rviz_default_plugins/displays/grid_cells/grid_cells_display.hpp\n@@ -135,6 \u002B136,7 @@ endforeach()\n set(rviz_default_plugins_source_files\n   src/rviz_default_plugins/displays/axes/axes_display.cpp\n   src/rviz_default_plugins/displays/camera/camera_display.cpp\n\u002B  src/rviz_default_plugins/displays/effort/effort_display.cpp\n   src/rviz_default_plugins/displays/grid/grid_display.cpp\n   src/rviz_default_plugins/displays/grid_cells/grid_cells_display.cpp\n   src/rviz_default_plugins/displays/fluid_pressure/fluid_pressure_display.cpp\n@@ -750,6 \u002B752,21 @@ if(BUILD_TESTING)\n     )\n   endif()\n \n\u002B  ament_add_gtest(effort_display_visual_test\n\u002B    test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\n\u002B    test/rviz_default_plugins/publishers/effort_publisher.hpp\n\u002B    test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\n\u002B    ${SKIP_VISUAL_TESTS}\n\u002B    TIMEOUT 180)\n\u002B  if(TARGET effort_display_visual_test)\n\u002B    target_include_directories(effort_display_visual_test PRIVATE test)\n\u002B    target_link_libraries(effort_display_visual_test\n\u002B      rviz_visual_testing_framework::rviz_visual_testing_framework\n\u002B      rclcpp::rclcpp\n\u002B      ${sensor_msgs_TARGETS}\n\u002B    )\n\u002B  endif()\n\u002B\n   ament_add_gtest(fluid_pressure_display_visual_test\n     test/rviz_default_plugins/displays/fluid_pressure/fluid_pressure_display_visual_test.cpp\n     ${SKIP_VISUAL_TESTS}\ndiff --git rviz_default_plugins/include/rviz_default_plugins/displays/effort/effort_display.hpp rviz_default_plugins/include/rviz_default_plugins/displays/effort/effort_display.hpp\nnew file mode 100644\nindex 00000000..44a357e6\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/include/rviz_default_plugins/displays/effort/effort_display.hpp\n@@ -0,0 \u002B1,160 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_\n\u002B#define RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_\n\u002B\n\u002B#include \u003Curdf/model.h\u003E\n\u002B\n\u002B#include \u003Cdeque\u003E\n\u002B#include \u003Cmap\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u003Crclcpp/rclcpp.hpp\u003E\n\u002B#include \u003Crviz_common/message_filter_display.hpp\u003E\n\u002B#include \u003Crviz_common/properties/bool_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/int_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/float_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/string_property.hpp\u003E\n\u002B#include \u003Crviz_common/properties/property.hpp\u003E\n\u002B#include \u003Crviz_rendering/objects/effort_visual.hpp\u003E\n\u002B#include \u003Csensor_msgs/msg/joint_state.hpp\u003E\n\u002B#include \u003Cstd_msgs/msg/string.hpp\u003E\n\u002B\n\u002B#include \u0022rviz_default_plugins/visibility_control.hpp\u0022\n\u002B\n\u002Bnamespace rviz_default_plugins\n\u002B{\n\u002Bnamespace displays\n\u002B{\n\u002Bclass JointInfo : public QObject\n\u002B{\n\u002B  Q_OBJECT\n\u002B\n\u002Bpublic:\n\u002B  JointInfo(const std::string \u0026 name, rviz_common::properties::Property * parent_category);\n\u002B  ~JointInfo() override;\n\u002B\n\u002B  void setEffort(double e);\n\u002B  inline double getEffort()\n\u002B  {\n\u002B    return effort_;\n\u002B  }\n\u002B  void setMaxEffort(double m);\n\u002B  inline double getMaxEffort()\n\u002B  {\n\u002B    return max_effort_;\n\u002B  }\n\u002B  bool getEnabled() const;\n\u002B\n\u002B  rclcpp::Time last_update_;\n\u002B\n\u002Bpublic Q_SLOTS:\n\u002B  void updateVisibility();\n\u002B\n\u002Bprivate:\n\u002B  std::string name_;\n\u002B  double effort_, max_effort_;\n\u002B\n\u002B  rviz_common::properties::Property * category_;\n\u002B  rviz_common::properties::FloatProperty * effort_property_;\n\u002B  rviz_common::properties::FloatProperty * max_effort_property_;\n\u002B};\n\u002B\n\u002Bclass RVIZ_DEFAULT_PLUGINS_PUBLIC EffortDisplay\n\u002B  : public rviz_common::MessageFilterDisplay\u003Csensor_msgs::msg::JointState\u003E\n\u002B{\n\u002B  Q_OBJECT\n\u002B\n\u002Bpublic:\n\u002B  EffortDisplay();\n\u002B  ~EffortDisplay() override;\n\u002B\n\u002B  // Overrides of public virtual functions from the Display class.\n\u002B  void onInitialize() override;\n\u002B  void reset() override;\n\u002B\n\u002B  void load(const rviz_common::Config \u0026 config) override;\n\u002B\n\u002B  void update(float wall_dt, float ros_dt) override;\n\u002B\n\u002Bprivate Q_SLOTS:\n\u002B  // Helper function to apply color and alpha to all visuals.\n\u002B  void updateColorAndAlpha();\n\u002B  void updateHistoryLength();\n\u002B  void updateRobotDescription();\n\u002B  void updateTfPrefix();\n\u002B\n\u002Bprivate:\n\u002B  std::shared_ptr\u003CJointInfo\u003E getJointInfo(const std::string \u0026 joint);\n\u002B  void subscribeToRobotDescription();\n\u002B\n\u002Bprotected:\n\u002B  // overrides from Display\n\u002B  void onEnable() override;\n\u002B  void onDisable() override;\n\u002B\n\u002B  void load();\n\u002B  void clear();\n\u002B\n\u002B  // The object for urdf model\n\u002B  std::shared_ptr\u003Curdf::Model\u003E robot_model_;\n\u002B\n\u002B  std::string robot_description_;\n\u002B  std::string robot_description_topic_;\n\u002B\n\u002Bprivate:\n\u002B  void processMessage(sensor_msgs::msg::JointState::ConstSharedPtr msg) override;\n\u002B  void topic_callback(const std_msgs::msg::String \u0026 msg);\n\u002B\n\u002B  rclcpp::Subscription\u003Cstd_msgs::msg::String\u003E::SharedPtr subscription_;\n\u002B  rclcpp::executors::SingleThreadedExecutor::SharedPtr executor_;\n\u002B\n\u002B  // Storage for the list of visuals.  It is a circular buffer where\n\u002B  // data gets popped from the front (oldest) and pushed to the back (newest)\n\u002B  std::deque\u003Cstd::shared_ptr\u003Crviz_rendering::EffortVisual\u003E\u003E visuals_;\n\u002B\n\u002B  typedef std::map\u003Cstd::string, std::shared_ptr\u003CJointInfo\u003E\u003E M_JointInfo;\n\u002B  M_JointInfo joints_;\n\u002B\n\u002B  // Property objects for user-editable properties.\n\u002B  rviz_common::properties::FloatProperty * alpha_property_, * width_property_, * scale_property_;\n\u002B  rviz_common::properties::IntProperty * history_length_property_;\n\u002B\n\u002B  rviz_common::properties::StringProperty * robot_description_property_;\n\u002B  rviz_common::properties::StringProperty * tf_prefix_property_;\n\u002B  rviz_common::properties::Property * joints_category_;\n\u002B  rviz_common::properties::BoolProperty * all_enabled_property_;\n\u002B};\n\u002B\n\u002B}  // namespace displays\n\u002B}  // namespace rviz_default_plugins\n\u002B\n\u002B#endif  // RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_\ndiff --git rviz_default_plugins/plugins_description.xml rviz_default_plugins/plugins_description.xml\nindex 5cf6a1e3..79887f22 100644\n--- rviz_default_plugins/plugins_description.xml\n\u002B\u002B\u002B rviz_default_plugins/plugins_description.xml\n@@ -25,6 \u002B25,17 @@\n     \u003Cmessage_type\u003Esensor_msgs/msg/CompressedImage\u003C/message_type\u003E\n   \u003C/class\u003E\n \n\u002B  \u003Cclass\n\u002B    name=\u0022rviz_default_plugins/Effort\u0022\n\u002B    type=\u0022rviz_default_plugins::displays::EffortDisplay\u0022\n\u002B    base_class_type=\u0022rviz_common::Display\u0022\n\u002B  \u003E\n\u002B    \u003Cdescription\u003E\n\u002B      The Effort display shows a sensor_msgs/JointState/effort message as circled arrows around each revolute joint in the robot.\n\u002B    \u003C/description\u003E\n\u002B    \u003Cmessage_type\u003Esensor_msgs/msg/JointState\u003C/message_type\u003E\n\u002B  \u003C/class\u003E\n\u002B\n   \u003Cclass\n     name=\u0022rviz_default_plugins/Grid\u0022\n     type=\u0022rviz_default_plugins::displays::GridDisplay\u0022\ndiff --git rviz_default_plugins/src/rviz_default_plugins/displays/effort/effort_display.cpp rviz_default_plugins/src/rviz_default_plugins/displays/effort/effort_display.cpp\nnew file mode 100644\nindex 00000000..80ea938c\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/src/rviz_default_plugins/displays/effort/effort_display.cpp\n@@ -0,0 \u002B1,413 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u0022rviz_default_plugins/displays/effort/effort_display.hpp\u0022\n\u002B\n\u002B#include \u003COgreSceneNode.h\u003E\n\u002B#include \u003COgreSceneManager.h\u003E\n\u002B#include \u003Curdf/model.h\u003E\n\u002B\n\u002B#include \u003CQString\u003E\n\u002B\n\u002B#include \u003Cchrono\u003E\n\u002B#include \u003Ccstddef\u003E\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cutility\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002B#include \u003Crviz_common/validate_floats.hpp\u003E\n\u002B\n\u002B#include \u003Crviz_common/properties/property.hpp\u003E\n\u002B#include \u003Crviz_rendering/objects/effort_visual.hpp\u003E\n\u002B#include \u003Csensor_msgs/msg/joint_state.hpp\u003E\n\u002B\n\u002Busing namespace std::chrono_literals;\n\u002B\n\u002Bnamespace rviz_default_plugins\n\u002B{\n\u002Bnamespace displays\n\u002B{\n\u002BJointInfo::JointInfo(const std::string \u0026 name, rviz_common::properties::Property * parent_category)\n\u002B{\n\u002B  name_ = name;\n\u002B  effort_ = 0;\n\u002B  max_effort_ = 0;\n\u002B\n\u002B  category_ = new rviz_common::properties::Property(\n\u002B    QString::fromStdString(name_), true, \u0022\u0022, parent_category,\n\u002B    SLOT(updateVisibility()), this);\n\u002B\n\u002B  effort_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Effort\u0022, 0, \u0022Effort value of this joint.\u0022, category_);\n\u002B  effort_property_-\u003EsetReadOnly(true);\n\u002B\n\u002B  max_effort_property_ =\n\u002B    new rviz_common::properties::FloatProperty(\n\u002B    \u0022Max Effort\u0022, 0, \u0022Max Effort value of this joint.\u0022, category_);\n\u002B  max_effort_property_-\u003EsetReadOnly(true);\n\u002B}\n\u002B\n\u002BJointInfo::~JointInfo()\n\u002B{\n\u002B}\n\u002B\n\u002Bstd::shared_ptr\u003CJointInfo\u003E EffortDisplay::getJointInfo(const std::string \u0026 joint)\n\u002B{\n\u002B  M_JointInfo::iterator it = joints_.find(joint);\n\u002B  if (it == joints_.end()) {\n\u002B    return nullptr;\n\u002B  }\n\u002B\n\u002B  return it-\u003Esecond;\n\u002B}\n\u002B\n\u002Bvoid JointInfo::updateVisibility()\n\u002B{\n\u002B}\n\u002B\n\u002Bvoid JointInfo::setEffort(double e)\n\u002B{\n\u002B  effort_property_-\u003EsetFloat(e);\n\u002B  effort_ = e;\n\u002B}\n\u002B\n\u002Bvoid JointInfo::setMaxEffort(double m)\n\u002B{\n\u002B  max_effort_property_-\u003EsetFloat(m);\n\u002B  max_effort_ = m;\n\u002B}\n\u002B\n\u002Bbool JointInfo::getEnabled() const\n\u002B{\n\u002B  return category_-\u003EgetValue().toBool();\n\u002B}\n\u002B\n\u002BEffortDisplay::EffortDisplay()\n\u002B: rviz_common::MessageFilterDisplay\u003Csensor_msgs::msg::JointState\u003E()\n\u002B{\n\u002B  alpha_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Alpha\u0022, 1.0f, \u00220 is fully transparent, 1.0 is fully opaque.\u0022,\n\u002B    this, SLOT(updateColorAndAlpha()));\n\u002B\n\u002B  width_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Width\u0022, 0.02f, \u0022Width to drow effort circle\u0022, this,\n\u002B    SLOT(updateColorAndAlpha()));\n\u002B\n\u002B  scale_property_ = new rviz_common::properties::FloatProperty(\n\u002B    \u0022Scale\u0022, 1.0f, \u0022Scale to draw effort circle\u0022, this,\n\u002B    SLOT(updateColorAndAlpha()));\n\u002B\n\u002B  history_length_property_ = new rviz_common::properties::IntProperty(\n\u002B    \u0022History Length\u0022, 1, \u0022Number of prior measurements to display.\u0022, this,\n\u002B    SLOT(updateHistoryLength()));\n\u002B\n\u002B  history_length_property_-\u003EsetMin(1);\n\u002B  history_length_property_-\u003EsetMax(100000);\n\u002B\n\u002B  robot_description_property_ =\n\u002B    new rviz_common::properties::StringProperty(\n\u002B    \u0022Robot Description\u0022, \u0022/robot_description\u0022,\n\u002B    \u0022Name of the topic from which to load the robot \u0022\n\u002B    \u0022description.\u0022,\n\u002B    this, SLOT(updateRobotDescription()));\n\u002B\n\u002B  tf_prefix_property_ = new rviz_common::properties::StringProperty(\n\u002B    \u0022TF Prefix\u0022, \u0022\u0022,\n\u002B    \u0022Robot Model normally assumes the link name is the same as the tf frame name. \u0022\n\u002B    \u0022This option allows you to set a prefix.  Mainly useful for multi-robot situations.\u0022,\n\u002B    this, SLOT(updateTfPrefix()));\n\u002B\n\u002B  joints_category_ = new rviz_common::properties::Property(\u0022Joints\u0022, QVariant(), \u0022\u0022, this);\n\u002B}\n\u002B\n\u002BEffortDisplay::~EffortDisplay()\n\u002B{\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::onInitialize()\n\u002B{\n\u002B  MFDClass::onInitialize();\n\u002B  updateHistoryLength();\n\u002B}\n\u002B\n\u002B// Set the number of past visuals to show.\n\u002Bvoid EffortDisplay::updateHistoryLength()\n\u002B{\n\u002B  while (visuals_.size() \u003E static_cast\u003Csize_t\u003E(history_length_property_-\u003EgetInt())) {\n\u002B    visuals_.pop_front();\n\u002B  }\n\u002B}\n\u002B\n\u002B// Clear the visuals by deleting their objects.\n\u002Bvoid EffortDisplay::reset()\n\u002B{\n\u002B  MFDClass::reset();\n\u002B  visuals_.clear();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::load(const rviz_common::Config \u0026 config)\n\u002B{\n\u002B  rviz_common::Display::load(config);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::topic_callback(const std_msgs::msg::String \u0026 msg)\n\u002B{\n\u002B  robot_description_ = msg.data;\n\u002B  robot_model_ = std::shared_ptr\u003Curdf::Model\u003E(new urdf::Model());\n\u002B  if (!robot_model_-\u003EinitString(robot_description_)) {\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusProperty::Error,\n\u002B      \u0022URDF\u0022, \u0022Unable to parse robot model description!\u0022);\n\u002B    return;\n\u002B  }\n\u002B  setStatus(rviz_common::properties::StatusProperty::Ok, \u0022URDF\u0022, \u0022Robot model parsed Ok\u0022);\n\u002B\n\u002B  for (std::map\u003Cstd::string, urdf::JointSharedPtr\u003E::iterator it = robot_model_-\u003Ejoints_.begin();\n\u002B    it != robot_model_-\u003Ejoints_.end(); it\u002B\u002B)\n\u002B  {\n\u002B    urdf::JointSharedPtr joint = it-\u003Esecond;\n\u002B    if (joint-\u003Etype == urdf::Joint::REVOLUTE || joint-\u003Etype == 2) {\n\u002B      std::string joint_name = it-\u003Efirst;\n\u002B      urdf::JointLimitsSharedPtr limit = joint-\u003Elimits;\n\u002B      joints_[joint_name] = std::make_shared\u003CJointInfo\u003E(joint_name, joints_category_);\n\u002B      joints_[joint_name]-\u003EsetMaxEffort(limit-\u003Eeffort);\n\u002B    }\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::subscribeToRobotDescription()\n\u002B{\n\u002B  if (this-\u003Erobot_description_topic_ == robot_description_property_-\u003EgetStdString()) {\n\u002B    return;\n\u002B  }\n\u002B  this-\u003Erobot_description_topic_ = robot_description_property_-\u003EgetStdString();\n\u002B\n\u002B  using std::placeholders::_1;\n\u002B\n\u002B  try {\n\u002B    rclcpp::SubscriptionOptions sub_opts;\n\u002B    sub_opts.event_callbacks.message_lost_callback =\n\u002B      [\u0026](rclcpp::QOSMessageLostInfo \u0026 info)\n\u002B      {\n\u002B        std::ostringstream sstm;\n\u002B        sstm \u003C\u003C \u0022Some messages were lost:\\n\u003E\\tNumber of new lost messages: \u0022 \u003C\u003C\n\u002B          info.total_count_change \u003C\u003C \u0022 \\n\u003E\\tTotal number of messages lost: \u0022 \u003C\u003C\n\u002B          info.total_count;\n\u002B        setStatus(\n\u002B          rviz_common::properties::StatusLevel::Warn,\n\u002B          \u0022Topic\u0022,\n\u002B          QString(sstm.str().c_str()));\n\u002B      };\n\u002B\n\u002B    this-\u003Esubscription_ = context_-\u003EgetRosNodeAbstraction().lock()-\u003Eget_raw_node()-\u003E\n\u002B      template create_subscription\u003Cstd_msgs::msg::String\u003E(\n\u002B      robot_description_property_-\u003EgetStdString(),\n\u002B      rclcpp::QoS(1).transient_local(),\n\u002B      std::bind(\u0026EffortDisplay::topic_callback, this, _1),\n\u002B      sub_opts);\n\u002B    setStatus(rviz_common::properties::StatusLevel::Ok, \u0022Array Topic\u0022, \u0022OK\u0022);\n\u002B  } catch (rclcpp::exceptions::InvalidTopicNameError \u0026 e) {\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusLevel::Error,\n\u002B      \u0022Topic\u0022,\n\u002B      QString(\u0022Error subscribing: \u0022) \u002B e.what());\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::load()\n\u002B{\n\u002B  this-\u003EsubscribeToRobotDescription();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::update(float wall_dt, float ros_dt)\n\u002B{\n\u002B  (void) wall_dt;\n\u002B  (void) ros_dt;\n\u002B}\n\u002B\n\u002B// Set the current color and alpha values for each visual.\n\u002Bvoid EffortDisplay::updateColorAndAlpha()\n\u002B{\n\u002B  float width = width_property_-\u003EgetFloat();\n\u002B  float scale = scale_property_-\u003EgetFloat();\n\u002B\n\u002B  for (size_t i = 0; i \u003C visuals_.size(); i\u002B\u002B) {\n\u002B    visuals_[i]-\u003EsetWidth(width);\n\u002B    visuals_[i]-\u003EsetScale(scale);\n\u002B  }\n\u002B}\n\u002B\n\u002Bstd::string concat(const std::string \u0026 prefix, const std::string \u0026 frame)\n\u002B{\n\u002B  if (prefix.empty()) {\n\u002B    return frame;\n\u002B  }\n\u002B\n\u002B  std::string composite = prefix;\n\u002B  composite.append(\u0022/\u0022);\n\u002B  composite.append(frame);\n\u002B  return composite;\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::processMessage(sensor_msgs::msg::JointState::ConstSharedPtr msg)\n\u002B{\n\u002B  // Robot model might not be loaded yet\n\u002B  if (!robot_model_) {\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusLevel::Error,\n\u002B      \u0022Process message\u0022,\n\u002B      QString(\u0022Robot model might not be loaded yet\u0022));\n\u002B    return;\n\u002B  }\n\u002B  // We are keeping a circular buffer of visual pointers.  This gets\n\u002B  // the next one, or creates and stores it if the buffer is not full\n\u002B  std::shared_ptr\u003Crviz_rendering::EffortVisual\u003E visual;\n\u002B  if (visuals_.size() == static_cast\u003Csize_t\u003E(history_length_property_-\u003EgetInt())) {\n\u002B    visual = visuals_.front();\n\u002B  } else {\n\u002B    visual = std::make_shared\u003Crviz_rendering::EffortVisual\u003E(\n\u002B      context_-\u003EgetSceneManager(), scene_node_);\n\u002B  }\n\u002B  visual-\u003EsetWidth(width_property_-\u003EgetFloat());\n\u002B  visual-\u003EsetScale(scale_property_-\u003EgetFloat());\n\u002B\n\u002B  if (visuals_.size() \u003E= static_cast\u003Csize_t\u003E(history_length_property_-\u003EgetInt())) {\n\u002B    visuals_.pop_front();\n\u002B  }\n\u002B\n\u002B  std::vector\u003Cstd::string\u003E joints;\n\u002B  size_t joint_num = msg-\u003Ename.size();\n\u002B  if (joint_num != msg-\u003Eeffort.size()) {\n\u002B    setStatus(\n\u002B      rviz_common::properties::StatusProperty::Error, \u0022Topic\u0022,\n\u002B      \u0022Received a joint state msg with different joint names and efforts size!\u0022);\n\u002B    return;\n\u002B  }\n\u002B  for (size_t i = 0; i \u003C joint_num; \u002B\u002Bi) {\n\u002B    const std::string \u0026 joint_name = msg-\u003Ename[i];\n\u002B    std::shared_ptr\u003CJointInfo\u003E joint_info = getJointInfo(joint_name);\n\u002B    if (!joint_info) {\n\u002B      continue;  // skip joints..\n\u002B    }\n\u002B\n\u002B    // update effort property\n\u002B    joint_info-\u003EsetEffort(msg-\u003Eeffort[i]);\n\u002B    joint_info-\u003Elast_update_ = msg-\u003Eheader.stamp;\n\u002B\n\u002B    const urdf::Joint * joint = robot_model_-\u003EgetJoint(joint_name).get();\n\u002B    int joint_type = joint-\u003Etype;\n\u002B    if (joint_type == urdf::Joint::REVOLUTE) {\n\u002B      std::string tf_frame_id = concat(\n\u002B        tf_prefix_property_-\u003EgetStdString(), joint-\u003Echild_link_name);\n\u002B      Ogre::Quaternion orientation;\n\u002B      Ogre::Vector3 position;\n\u002B\n\u002B      // Call rviz::FrameManager to get the transform from the fixed frame to the joint\u0027s frame.\n\u002B      if (!context_-\u003EgetFrameManager()-\u003EgetTransform(\n\u002B          tf_frame_id, msg-\u003Eheader.stamp, position, orientation))\n\u002B      {\n\u002B        setStatus(\n\u002B          rviz_common::properties::StatusProperty::Error,\n\u002B          QString::fromStdString(joint_name),\n\u002B          QString(\u0022Error transforming from frame \u0027%1\u0027 to frame \u0027%2\u0027\u0022)\n\u002B          .arg(tf_frame_id.c_str(), qPrintable(fixed_frame_)));\n\u002B        continue;\n\u002B      }\n\u002B      tf2::Vector3 axis_joint(joint-\u003Eaxis.x, joint-\u003Eaxis.y, joint-\u003Eaxis.z);\n\u002B      tf2::Vector3 axis_z(0, 0, 1);\n\u002B      tf2::Quaternion axis_rotation(axis_joint.cross(axis_z), axis_joint.angle(axis_z));\n\u002B      if (std::isnan(axis_rotation.x()) ||\n\u002B        std::isnan(axis_rotation.y()) ||\n\u002B        std::isnan(axis_rotation.z()))\n\u002B      {\n\u002B        axis_rotation = tf2::Quaternion::getIdentity();\n\u002B      }\n\u002B\n\u002B      tf2::Quaternion axis_orientation(orientation.x, orientation.y, orientation.z, orientation.w);\n\u002B      tf2::Quaternion axis_rot = axis_orientation * axis_rotation;\n\u002B      Ogre::Quaternion joint_orientation(Ogre::Real(axis_rot.w()), Ogre::Real(axis_rot.x()),\n\u002B        Ogre::Real(axis_rot.y()), Ogre::Real(axis_rot.z()));\n\u002B      visual-\u003EsetFramePosition(joint_name, position);\n\u002B      visual-\u003EsetFrameOrientation(joint_name, joint_orientation);\n\u002B      visual-\u003EsetFrameEnabled(joint_name, joint_info-\u003EgetEnabled());\n\u002B\n\u002B      if (!rviz_common::validateFloats(joint_info-\u003EgetEffort())) {\n\u002B        setStatus(\n\u002B          rviz_common::properties::StatusProperty::Error,\n\u002B          QString::fromStdString(joint_name),\n\u002B          QString(\u0022Invalid effort: %1\u0022).arg(joint_info-\u003EgetEffort()));\n\u002B        visual-\u003EsetFrameEnabled(joint_name, false);\n\u002B      } else {\n\u002B        setStatus(\n\u002B          rviz_common::properties::StatusProperty::Ok,\n\u002B          QString::fromStdString(joint_name),\n\u002B          QString());\n\u002B      }\n\u002B      visual-\u003EsetEffort(joint_name, joint_info-\u003EgetEffort(), joint_info-\u003EgetMaxEffort());\n\u002B    }\n\u002B  }\n\u002B  visuals_.push_back(visual);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::updateRobotDescription()\n\u002B{\n\u002B  if (isEnabled()) {\n\u002B    load();\n\u002B    context_-\u003EqueueRender();\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::onEnable()\n\u002B{\n\u002B  load();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::onDisable()\n\u002B{\n\u002B  clear();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::clear()\n\u002B{\n\u002B  clearStatuses();\n\u002B  robot_description_.clear();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplay::updateTfPrefix()\n\u002B{\n\u002B  clearStatuses();\n\u002B  context_-\u003EqueueRender();\n\u002B}\n\u002B\n\u002B}  // namespace displays\n\u002B}  // namespace rviz_default_plugins\n\u002B\n\u002B#include \u003Cpluginlib/class_list_macros.hpp\u003E  // NOLINT\n\u002BPLUGINLIB_EXPORT_CLASS(rviz_default_plugins::displays::EffortDisplay, rviz_common::Display)\ndiff --git rviz_default_plugins/test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp rviz_default_plugins/test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\nnew file mode 100644\nindex 00000000..4fca64f4\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\n@@ -0,0 \u002B1,59 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u0022rviz_visual_testing_framework/visual_test_fixture.hpp\u0022\n\u002B#include \u0022rviz_visual_testing_framework/visual_test_publisher.hpp\u0022\n\u002B\n\u002B#include \u0022../../page_objects/effort_display_page_object.hpp\u0022\n\u002B#include \u0022../../publishers/effort_publisher.hpp\u0022\n\u002B\n\u002BTEST_F(VisualTestFixture, wrenches_are_displayed) {\n\u002B  auto effort_publisher = std::make_shared\u003Cnodes::EffortPublisher\u003E();\n\u002B  auto effort_visual_publisher =\n\u002B    std::make_unique\u003CVisualTestPublisher\u003E(effort_publisher, \u0022effort_frame\u0022);\n\u002B\n\u002B  setCamPose(Ogre::Vector3(10, 10, 16));\n\u002B  setCamLookAt(Ogre::Vector3(0, 0, 0));\n\u002B\n\u002B  auto effort_display = addDisplay\u003CEffortDisplayPageObject\u003E();\n\u002B  effort_display-\u003EsetTopic(\u0022/joint_states\u0022);\n\u002B  effort_display-\u003EsetScale(2);\n\u002B  effort_display-\u003EsetWidth(4);\n\u002B  effort_display-\u003EsetRobotDescription(\u0022robot_description\u0022);\n\u002B\n\u002B  captureMainWindow();\n\u002B\n\u002B  effort_display-\u003EsetAlpha(0.0f);\n\u002B  captureMainWindow(\u0022empty_scene\u0022);\n\u002B\n\u002B  assertScreenShotsIdentity();\n\u002B}\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.cpp rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\nnew file mode 100644\nindex 00000000..192838f6\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\n@@ -0,0 \u002B1,68 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u0022effort_display_page_object.hpp\u0022\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B#include \u003Cvector\u003E\n\u002B\n\u002BEffortDisplayPageObject::EffortDisplayPageObject()\n\u002B: BasePageObject(0, \u0022Effort\u0022)\n\u002B{}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setTopic(QString topic)\n\u002B{\n\u002B  setComboBox(\u0022Topic\u0022, topic);\n\u002B  waitForFirstMessage();\n\u002B}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setAlpha(float alpha)\n\u002B{\n\u002B  setFloat(\u0022Alpha\u0022, alpha);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setScale(float scale)\n\u002B{\n\u002B  setFloat(\u0022Scale\u0022, scale);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setWidth(float width)\n\u002B{\n\u002B  setFloat(\u0022Width\u0022, width);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setHistoryLength(int history)\n\u002B{\n\u002B  setInt(\u0022History Length\u0022, history);\n\u002B}\n\u002B\n\u002Bvoid EffortDisplayPageObject::setRobotDescription(QString topic)\n\u002B{\n\u002B  setString(\u0022Robot Description\u0022, topic);\n\u002B}\ndiff --git rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.hpp rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.hpp\nnew file mode 100644\nindex 00000000..72dd4a50\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/page_objects/effort_display_page_object.hpp\n@@ -0,0 \u002B1,48 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_\n\u002B#define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_\n\u002B\n\u002B#include \u0022rviz_visual_testing_framework/page_objects/base_page_object.hpp\u0022\n\u002B\n\u002Bclass EffortDisplayPageObject : public BasePageObject\n\u002B{\n\u002Bpublic:\n\u002B  EffortDisplayPageObject();\n\u002B\n\u002B  void setTopic(QString topic);\n\u002B  void setAlpha(float alpha);\n\u002B  void setScale(float scale);\n\u002B  void setWidth(float width);\n\u002B  void setHistoryLength(int history);\n\u002B  void setRobotDescription(QString topic);\n\u002B};\n\u002B\n\u002B#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_\ndiff --git rviz_default_plugins/test/rviz_default_plugins/publishers/effort_publisher.hpp rviz_default_plugins/test/rviz_default_plugins/publishers/effort_publisher.hpp\nnew file mode 100644\nindex 00000000..5584bc03\n--- /dev/null\n\u002B\u002B\u002B rviz_default_plugins/test/rviz_default_plugins/publishers/effort_publisher.hpp\n@@ -0,0 \u002B1,88 @@\n\u002B/*\n\u002B * Copyright (c) 2019, Martin Idel\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the copyright holder nor the names of its contributors\n\u002B *       may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_\n\u002B#define RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_\n\u002B\n\u002B#include \u003Cstring\u003E\n\u002B#include \u003Cchrono\u003E\n\u002B\n\u002B#include \u003Crclcpp/rclcpp.hpp\u003E\n\u002B#include \u003Csensor_msgs/msg/joint_state.hpp\u003E\n\u002B\n\u002Busing namespace std::chrono_literals;  // NOLINT\n\u002B\n\u002Bnamespace nodes\n\u002B{\n\u002B\n\u002Bclass EffortPublisher : public rclcpp::Node\n\u002B{\n\u002Bpublic:\n\u002B  EffortPublisher();\n\u002B\n\u002Bprivate:\n\u002B  sensor_msgs::msg::JointState createJointStateMessage();\n\u002B\n\u002B  rclcpp::TimerBase::SharedPtr timer_;\n\u002B  rclcpp::Publisher\u003Csensor_msgs::msg::JointState\u003E::SharedPtr publisher_;\n\u002B};\n\u002B\n\u002BEffortPublisher::EffortPublisher()\n\u002B: Node(\u0022effort_publisher\u0022)\n\u002B{\n\u002B  publisher_ = this-\u003Ecreate_publisher\u003Csensor_msgs::msg::JointState\u003E(\u0022joint_states\u0022, 10);\n\u002B\n\u002B  auto timer_callback =\n\u002B    [this]() -\u003E void {\n\u002B      auto message = createJointStateMessage();\n\u002B      this-\u003Epublisher_-\u003Epublish(message);\n\u002B    };\n\u002B  timer_ = this-\u003Ecreate_wall_timer(500ms, timer_callback);\n\u002B}\n\u002B\n\u002Bsensor_msgs::msg::JointState EffortPublisher::createJointStateMessage()\n\u002B{\n\u002B  sensor_msgs::msg::JointState msg;\n\u002B  msg.name.push_back(\u0022joint1\u0022);\n\u002B  msg.name.push_back(\u0022joint2\u0022);\n\u002B  msg.position.push_back(0.0);\n\u002B  msg.position.push_back(0.0);\n\u002B\n\u002B  msg.header.frame_id = \u0022world\u0022;\n\u002B\n\u002B  msg.effort.push_back(1);\n\u002B  msg.effort.push_back(2);\n\u002B  msg.header.stamp = this-\u003Eget_clock()-\u003Enow();\n\u002B\n\u002B  return msg;\n\u002B}\n\u002B\n\u002B}  // namespace nodes\n\u002B\n\u002B#endif  // RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_\ndiff --git rviz_rendering/CMakeLists.txt rviz_rendering/CMakeLists.txt\nindex 13aac191..ca027874 100644\n--- rviz_rendering/CMakeLists.txt\n\u002B\u002B\u002B rviz_rendering/CMakeLists.txt\n@@ -85,6 \u002B85,7 @@ add_library(rviz_rendering SHARED\n   src/rviz_rendering/objects/axes.cpp\n   src/rviz_rendering/objects/billboard_line.cpp\n   src/rviz_rendering/objects/covariance_visual.cpp\n\u002B  src/rviz_rendering/objects/effort_visual.cpp\n   src/rviz_rendering/objects/grid.cpp\n   src/rviz_rendering/objects/line.cpp\n   src/rviz_rendering/objects/movable_text.cpp\n@@ -226,6 \u002B227,18 @@ if(BUILD_TESTING)\n     )\n   endif()\n \n\u002B  ament_add_gmock(effort_visual_test_target\n\u002B    test/rviz_rendering/objects/effort_visual_test.cpp\n\u002B    ${SKIP_DISPLAY_TESTS})\n\u002B  if(TARGET effort_visual_test_target)\n\u002B    target_link_libraries(effort_visual_test_target\n\u002B      rviz_ogre_vendor::OgreMain\n\u002B      rviz_rendering\n\u002B      rviz_rendering_test_utils\n\u002B      Qt5::Widgets  # explicitly do this for include directories (not necessary for external use)\n\u002B    )\n\u002B  endif()\n\u002B\n   ament_add_gmock(grid_test_target\n     test/rviz_rendering/objects/grid_test.cpp\n     ${SKIP_DISPLAY_TESTS})\ndiff --git rviz_rendering/include/rviz_rendering/objects/effort_visual.hpp rviz_rendering/include/rviz_rendering/objects/effort_visual.hpp\nnew file mode 100644\nindex 00000000..82a9a582\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/include/rviz_rendering/objects/effort_visual.hpp\n@@ -0,0 \u002B1,89 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#ifndef RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_\n\u002B#define RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_\n\u002B\n\u002B#include \u003Cmap\u003E\n\u002B#include \u003Cstring\u003E\n\u002B\n\u002B#include \u003COgreSceneNode.h\u003E\n\u002B#include \u003COgreSceneManager.h\u003E\n\u002B\n\u002B#include \u0022rviz_rendering/objects/arrow.hpp\u0022\n\u002B#include \u0022rviz_rendering/objects/billboard_line.hpp\u0022\n\u002B\n\u002B#include \u0022rviz_rendering/visibility_control.hpp\u0022\n\u002B\n\u002Bnamespace rviz_rendering\n\u002B{\n\u002Bclass EffortVisual\n\u002B{\n\u002Bpublic:\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node);\n\u002B\n\u002B  // set rainbow color\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void getRainbowColor(float value, Ogre::ColourValue \u0026 color);\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setEffort(const std::string \u0026 joint_name, double effort, double max_effort);\n\u002B\n\u002B  // set the pose of coordinates frame the each joint refers to.\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setFramePosition(const std::string \u0026 joint_name, const Ogre::Vector3 \u0026 position);\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setFrameOrientation(const std::string \u0026 joint_name, const Ogre::Quaternion \u0026 orientation);\n\u002B\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setFrameEnabled(const std::string \u0026 joint_name, const bool e);\n\u002B\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setWidth(float w);\n\u002B\n\u002B  RVIZ_RENDERING_PUBLIC\n\u002B  void setScale(float s);\n\u002B\n\u002Bprivate:\n\u002B  // The object implementing the effort circle\n\u002B  std::map\u003Cstd::string, rviz_rendering::BillboardLine *\u003E effort_circle_;\n\u002B  std::map\u003Cstd::string, rviz_rendering::Arrow *\u003E effort_arrow_;\n\u002B  std::map\u003Cstd::string, bool\u003E effort_enabled_;\n\u002B\n\u002B  Ogre::SceneManager * scene_manager_;\n\u002B  Ogre::SceneNode * parent_node_;\n\u002B\n\u002B  std::map\u003Cstd::string, Ogre::Vector3\u003E position_;\n\u002B  std::map\u003Cstd::string, Ogre::Quaternion\u003E orientation_;\n\u002B\n\u002B  float width_, scale_;\n\u002B};\n\u002B}  // namespace rviz_rendering\n\u002B\n\u002B#endif  // RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_\ndiff --git rviz_rendering/src/rviz_rendering/objects/effort_visual.cpp rviz_rendering/src/rviz_rendering/objects/effort_visual.cpp\nnew file mode 100644\nindex 00000000..fd6ac1e8\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/src/rviz_rendering/objects/effort_visual.cpp\n@@ -0,0 \u002B1,153 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B #define _USE_MATH_DEFINES\n\u002B#include \u0022rviz_rendering/objects/effort_visual.hpp\u0022\n\u002B\n\u002B#include \u003Calgorithm\u003E\n\u002B#include \u003Ccmath\u003E\n\u002B\n\u002Bnamespace rviz_rendering\n\u002B{\n\u002BEffortVisual::EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node)\n\u002B: scene_manager_(scene_manager), parent_node_(parent_node)\n\u002B{\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::getRainbowColor(float value, Ogre::ColourValue \u0026 color)\n\u002B{\n\u002B  value = std::min(value, 1.0f);\n\u002B  value = std::max(value, 0.0f);\n\u002B\n\u002B  float h = value * 5.0f \u002B 1.0f;\n\u002B  int i = static_cast\u003Cint\u003E(floor(h));\n\u002B  float f = h - static_cast\u003Cfloat\u003E(i);\n\u002B  if (!(i \u0026 1)) {\n\u002B    f = 1 - f;  // if i is even\n\u002B  }\n\u002B  float n = 1 - f;\n\u002B\n\u002B  if (i \u003C= 1) {\n\u002B    color[0] = n, color[1] = 0, color[2] = 1;\n\u002B  } else if (i == 2) {\n\u002B    color[0] = 0, color[1] = n, color[2] = 1;\n\u002B  } else if (i == 3) {\n\u002B    color[0] = 0, color[1] = 1, color[2] = n;\n\u002B  } else if (i == 4) {\n\u002B    color[0] = n, color[1] = 1, color[2] = 0;\n\u002B  } else if (i \u003E= 5) {\n\u002B    color[0] = 1, color[1] = n, color[2] = 0;\n\u002B  }\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::setEffort(const std::string \u0026 joint_name, double effort, double max_effort)\n\u002B{\n\u002B  bool enabled = effort_enabled_.insert(std::make_pair(joint_name, true)).first-\u003Esecond;\n\u002B\n\u002B  // enable or disable draw\n\u002B  if (effort_circle_.find(joint_name) != effort_circle_.end() \u0026\u0026 !enabled) {  // enable-\u003Edisable\n\u002B    delete (effort_circle_[joint_name]);\n\u002B    delete (effort_arrow_[joint_name]);\n\u002B    effort_circle_.erase(joint_name);\n\u002B    effort_arrow_.erase(joint_name);\n\u002B  }\n\u002B  if (effort_circle_.find(joint_name) == effort_circle_.end() \u0026\u0026 enabled) {  // disable -\u003E enable\n\u002B    effort_circle_[joint_name] = new rviz_rendering::BillboardLine(scene_manager_, parent_node_);\n\u002B    effort_arrow_[joint_name] = new rviz_rendering::Arrow(scene_manager_, parent_node_);\n\u002B  }\n\u002B\n\u002B  if (!enabled) {\n\u002B    return;\n\u002B  }\n\u002B\n\u002B  float effort_value;\n\u002B\n\u002B  if (max_effort != 0.0) {\n\u002B    effort_value = static_cast\u003Cfloat\u003E(std::fmin(fabs(effort) / max_effort, 1.0f) \u002B 0.05f);\n\u002B  } else {\n\u002B    effort_value = static_cast\u003Cfloat\u003E(fabs(effort) \u002B 0.05f);\n\u002B  }\n\u002B\n\u002B  effort_arrow_[joint_name]-\u003Eset(0, width_ * 2.0f, width_ * 2.0f * 1.0f, width_ * 2.0f * 2.0f);\n\u002B  if (effort \u003E 0) {\n\u002B    effort_arrow_[joint_name]-\u003EsetDirection(orientation_[joint_name] * Ogre::Vector3(-1, 0, 0));\n\u002B  } else {\n\u002B    effort_arrow_[joint_name]-\u003EsetDirection(orientation_[joint_name] * Ogre::Vector3(1, 0, 0));\n\u002B  }\n\u002B  effort_arrow_[joint_name]-\u003EsetPosition(\n\u002B    orientation_[joint_name] *\n\u002B    Ogre::Vector3(0, 0.05f \u002B effort_value * scale_ * 0.5f, 0) \u002B\n\u002B    position_[joint_name]);\n\u002B  effort_circle_[joint_name]-\u003Eclear();\n\u002B  effort_circle_[joint_name]-\u003EsetLineWidth(width_);\n\u002B  for (int i = 0; i \u003C 30; i\u002B\u002B) {\n\u002B    Ogre::Vector3 point =\n\u002B      Ogre::Vector3(\n\u002B      static_cast\u003Cfloat\u003E((0.05f \u002B effort_value * scale_ * 0.5f) * sin(i * 2.0f * M_PI / 32.0f)),\n\u002B      static_cast\u003Cfloat\u003E((0.05f \u002B effort_value * scale_ * 0.5f) * cos(i * 2.0f * M_PI / 32.0f)),\n\u002B      static_cast\u003Cfloat\u003E(0));\n\u002B    if (effort \u003C 0) {\n\u002B      point.x = -point.x;\n\u002B    }\n\u002B    effort_circle_[joint_name]-\u003EaddPoint(orientation_[joint_name] * point \u002B position_[joint_name]);\n\u002B  }\n\u002B  Ogre::ColourValue color;\n\u002B  getRainbowColor(effort_value, color);\n\u002B  effort_arrow_[joint_name]-\u003EsetColor(color.r, color.g, color.b, color.a);\n\u002B  effort_circle_[joint_name]-\u003EsetColor(color.r, color.g, color.b, color.a);\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::setFrameEnabled(const std::string \u0026 joint_name, const bool e)\n\u002B{\n\u002B  effort_enabled_[joint_name] = e;\n\u002B}\n\u002B\n\u002B// Position and orientation are passed through to the SceneNode.\n\u002Bvoid EffortVisual::setFramePosition(const std::string \u0026 joint_name, const Ogre::Vector3 \u0026 position)\n\u002B{\n\u002B  position_[joint_name] = position;\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::setFrameOrientation(\n\u002B  const std::string \u0026 joint_name, const Ogre::Quaternion \u0026 orientation)\n\u002B{\n\u002B  orientation_[joint_name] = orientation;\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::setWidth(float w)\n\u002B{\n\u002B  width_ = w;\n\u002B}\n\u002B\n\u002Bvoid EffortVisual::setScale(float s)\n\u002B{\n\u002B  scale_ = s;\n\u002B}\n\u002B\n\u002B}  // namespace rviz_rendering\ndiff --git rviz_rendering/test/rviz_rendering/objects/effort_visual_test.cpp rviz_rendering/test/rviz_rendering/objects/effort_visual_test.cpp\nnew file mode 100644\nindex 00000000..bfe8ca6a\n--- /dev/null\n\u002B\u002B\u002B rviz_rendering/test/rviz_rendering/objects/effort_visual_test.cpp\n@@ -0,0 \u002B1,139 @@\n\u002B/*\n\u002B * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n\u002B * All rights reserved.\n\u002B *\n\u002B * Redistribution and use in source and binary forms, with or without\n\u002B * modification, are permitted provided that the following conditions are met:\n\u002B *\n\u002B *     * Redistributions of source code must retain the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer.\n\u002B *     * Redistributions in binary form must reproduce the above copyright\n\u002B *       notice, this list of conditions and the following disclaimer in the\n\u002B *       documentation and/or other materials provided with the distribution.\n\u002B *     * Neither the name of the Willow Garage, Inc. nor the names of its\n\u002B *       contributors may be used to endorse or promote products derived from\n\u002B *       this software without specific prior written permission.\n\u002B *\n\u002B * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0022AS IS\u0022\n\u002B * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\u002B * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\u002B * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n\u002B * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\u002B * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n\u002B * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n\u002B * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n\u002B * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\u002B * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\u002B * POSSIBILITY OF SUCH DAMAGE.\n\u002B */\n\u002B\n\u002B#include \u003Cgmock/gmock.h\u003E\n\u002B\n\u002B#include \u003COgreRoot.h\u003E\n\u002B#include \u003COgreSceneNode.h\u003E\n\u002B\n\u002B#include \u003Cmemory\u003E\n\u002B\n\u002B#include \u0022../ogre_testing_environment.hpp\u0022\n\u002B#include \u0022../scene_graph_introspection.hpp\u0022\n\u002B#include \u0022rviz_rendering/objects/effort_visual.hpp\u0022\n\u002B\n\u002Busing namespace ::testing;  // NOLINT\n\u002B\n\u002BMATCHER_P(ColorEq, expected, \u0022\u0022) {\n\u002B  return Ogre::Math::Abs(expected.a - arg.a) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.r - arg.r) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.g - arg.g) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.b - arg.b) \u003C 0.0001f;\n\u002B}\n\u002B\n\u002BMATCHER_P(Vector3Eq, expected, \u0022\u0022) {\n\u002B  return Ogre::Math::Abs(expected.x - arg.x) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.y - arg.y) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.z - arg.z) \u003C 0.0001f;\n\u002B}\n\u002B\n\u002BMATCHER_P(QuaterionEq, expected, \u0022\u0022) {\n\u002B  return Ogre::Math::Abs(expected.x - arg.x) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.y - arg.y) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.z - arg.z) \u003C 0.0001f \u0026\u0026\n\u002B         Ogre::Math::Abs(expected.w - arg.w) \u003C 0.0001f;\n\u002B}\n\u002B\n\u002B\n\u002Bclass EffortVisualTestFixture : public ::testing::Test\n\u002B{\n\u002Bprotected:\n\u002B  void SetUp()\n\u002B  {\n\u002B    testing_environment_ = std::make_shared\u003Crviz_rendering::OgreTestingEnvironment\u003E();\n\u002B    testing_environment_-\u003EsetUpOgreTestEnvironment();\n\u002B  }\n\u002B\n\u002B  std::shared_ptr\u003Crviz_rendering::OgreTestingEnvironment\u003E testing_environment_;\n\u002B};\n\u002B\n\u002BOgre::SceneNode * findForceArrow(Ogre::SceneNode * scene_node)\n\u002B{\n\u002B  auto arrows = rviz_rendering::findAllArrows(scene_node);\n\u002B  auto billboard_line = rviz_rendering::findOneBillboardChain(scene_node);\n\u002B  for (const auto \u0026 arrow : arrows) {\n\u002B    if (billboard_line-\u003EgetParentSceneNode()-\u003EgetParent() == arrow-\u003EgetParent()) {\n\u002B      return arrow;\n\u002B    }\n\u002B  }\n\u002B  return nullptr;\n\u002B}\n\u002B\n\u002B\n\u002BTEST_F(EffortVisualTestFixture, setEffort_sets_force_arrow_correctly) {\n\u002B  auto scene_manager = Ogre::Root::getSingletonPtr()-\u003EcreateSceneManager();\n\u002B  auto root_node = scene_manager-\u003EgetRootSceneNode();\n\u002B\n\u002B  auto effort_visual = std::make_shared\u003Crviz_rendering::EffortVisual\u003E(scene_manager, root_node);\n\u002B\n\u002B  Ogre::ColourValue color;\n\u002B  effort_visual-\u003EgetRainbowColor(0, color);\n\u002B\n\u002B  EXPECT_THAT(color, ColorEq(Ogre::ColourValue(1, 0, 1, 1)));\n\u002B  effort_visual-\u003EgetRainbowColor(1, color);\n\u002B  EXPECT_THAT(color, ColorEq(Ogre::ColourValue(1, 0, 0, 1)));\n\u002B\n\u002B  effort_visual-\u003EsetEffort(\u0022joint1\u0022, 1, 10);\n\u002B\n\u002B  effort_visual-\u003EsetFramePosition(\u0022joint1\u0022, Ogre::Vector3());\n\u002B  auto arrows = rviz_rendering::findAllArrows(root_node);\n\u002B  EXPECT_THAT(arrows, SizeIs(1u));\n\u002B  EXPECT_THAT(\n\u002B    arrows[0]-\u003EconvertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n\u002B    Vector3Eq(Ogre::Vector3(0.0f, 0.0f, -0.05f)));\n\u002B\n\u002B  EXPECT_THAT(\n\u002B    arrows[0]-\u003EconvertWorldToLocalOrientation(Ogre::Quaternion()),\n\u002B    QuaterionEq(Ogre::Quaternion(0.5, 0.5, -0.5, -0.5)));\n\u002B\n\u002B  Ogre::Vector3 pos1(1, 2, 3);\n\u002B  effort_visual-\u003EsetFramePosition(\u0022joint1\u0022, pos1);\n\u002B  effort_visual-\u003EsetEffort(\u0022joint1\u0022, 1, 10);\n\u002B  EXPECT_THAT(\n\u002B    arrows[0]-\u003EconvertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n\u002B    Vector3Eq(Ogre::Vector3(3.0f, 1.0f, -2.05f)));\n\u002B}\n\u002B\n\u002BTEST_F(EffortVisualTestFixture, setEffort_hides_force_arrow_for_larger_width_than_scale) {\n\u002B  auto scene_manager = Ogre::Root::getSingletonPtr()-\u003EcreateSceneManager();\n\u002B  auto root_node = scene_manager-\u003EgetRootSceneNode();\n\u002B\n\u002B  auto effort_visual = std::make_shared\u003Crviz_rendering::EffortVisual\u003E(scene_manager, root_node);\n\u002B\n\u002B  Ogre::Vector3 pos1(1, 2, 3);\n\u002B  effort_visual-\u003EsetEffort(\u0022joint1\u0022, 1, 10);\n\u002B\n\u002B  effort_visual-\u003EsetScale(0.7f);\n\u002B  effort_visual-\u003EsetWidth(5);\n\u002B\n\u002B  auto arrows = rviz_rendering::findAllArrows(root_node);\n\u002B  EXPECT_THAT(arrows, SizeIs(1u));\n\u002B  auto force_arrow = findForceArrow(root_node);\n\u002B  EXPECT_THAT(force_arrow-\u003EgetScale(), Vector3Eq(Ogre::Vector3(1, 1, 1)));\n\u002B}\n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rcpputils",
    "SHA": "f96811a9047fa6a084a885219c88b415bc544487",
    "RawMessage": "Add in a missing cstdint. (#178)",
    "Changes": "diff --git include/rcpputils/filesystem_helper.hpp include/rcpputils/filesystem_helper.hpp\nindex 9fd1090..872b0d0 100644\n--- include/rcpputils/filesystem_helper.hpp\n\u002B\u002B\u002B include/rcpputils/filesystem_helper.hpp\n@@ -39,6 \u002B39,7 @@\n #ifndef RCPPUTILS__FILESYSTEM_HELPER_HPP_\n #define RCPPUTILS__FILESYSTEM_HELPER_HPP_\n \n\u002B#include \u003Ccstdint\u003E\n #include \u003Cstring\u003E\n #include \u003Cvector\u003E\n \n",
    "BackportedTo": "iron",
    "IsBackported": true
  },
  {
    "Repository": "rmw",
    "SHA": "ac633c09056fb8525c072513c4a2665e7c13a530",
    "RawMessage": "Add \u0027best available\u0027 QoS policies (#320)",
    "Changes": "diff --git rmw/include/rmw/qos_profiles.h rmw/include/rmw/qos_profiles.h\nindex 89b30e9..b034350 100644\n--- rmw/include/rmw/qos_profiles.h\n\u002B\u002B\u002B rmw/include/rmw/qos_profiles.h\n@@ -100,6 \u002B100,32 @@ static const rmw_qos_profile_t rmw_qos_profile_system_default =\n   false\n };\n \n\u002B/// Match majority of endpoints currently available while maintaining the highest level of service\n\u002B/**\n\u002B * Reliability, durability, deadline, liveliness, and liveliness lease duration policies will be\n\u002B * chosen at the time of creating a subscription or publisher.\n\u002B *\n\u002B * The actual QoS policy can be retrieved after the endpoint is created with\n\u002B * \u0060rmw_get_subscriptions_info_by_topic\u0060 or \u0060rmw_get_publishers_info_by_topic\u0060.\n\u002B *\n\u002B * The middleware is not expected to update policies after creating a subscription or\n\u002B * publisher, even if one or more policies are incompatible with newly discovered endpoints.\n\u002B * Therefore, this profile should be used with care since non-deterministic behavior\n\u002B * can occur due to races with discovery.\n\u002B */\n\u002Bstatic const rmw_qos_profile_t rmw_qos_profile_best_available =\n\u002B{\n\u002B  RMW_QOS_POLICY_HISTORY_KEEP_LAST,\n\u002B  10,\n\u002B  RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE,\n\u002B  RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE,\n\u002B  RMW_QOS_DEADLINE_BEST_AVAILABLE,\n\u002B  RMW_QOS_LIFESPAN_DEFAULT,\n\u002B  RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE,\n\u002B  RMW_QOS_LIVELINESS_LEASE_DURATION_BEST_AVAILABLE,\n\u002B  false\n\u002B};\n\u002B\n static const rmw_qos_profile_t rmw_qos_profile_unknown =\n {\n   RMW_QOS_POLICY_HISTORY_UNKNOWN,\ndiff --git rmw/include/rmw/types.h rmw/include/rmw/types.h\nindex 2dd3153..59f261d 100644\n--- rmw/include/rmw/types.h\n\u002B\u002B\u002B rmw/include/rmw/types.h\n@@ -382,7 \u002B382,26 @@ typedef enum RMW_PUBLIC_TYPE rmw_qos_reliability_policy_e\n   RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,\n \n   /// Reliability policy has not yet been set\n-  RMW_QOS_POLICY_RELIABILITY_UNKNOWN\n\u002B  RMW_QOS_POLICY_RELIABILITY_UNKNOWN,\n\u002B\n\u002B  /// Will match the majority of endpoints and use a reliable policy if possible\n\u002B  /**\n\u002B   * A policy will be chosen at the time of creating a subscription or publisher.\n\u002B   * A reliable policy will by chosen if it matches with all discovered endpoints,\n\u002B   * otherwise a best effort policy will be chosen.\n\u002B   *\n\u002B   * The QoS policy reported by functions like \u0060rmw_subscription_get_actual_qos\u0060 or\n\u002B   * \u0060rmw_publisher_get_actual_qos\u0060 may be best available, reliable, or best effort.\n\u002B   *\n\u002B   * Services and clients are not supported and default to the reliability value in\n\u002B   * \u0060rmw_qos_profile_services_default\u0060.\n\u002B   *\n\u002B   * The middleware is not expected to update the policy after creating a subscription or\n\u002B   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n\u002B   * Therefore, this policy should be used with care since non-deterministic behavior\n\u002B   * can occur due to races with discovery.\n\u002B   */\n\u002B  RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE\n } rmw_qos_reliability_policy_t;\n \n /// QoS history enumerations describing how samples endure\n@@ -414,7 \u002B433,29 @@ typedef enum RMW_PUBLIC_TYPE rmw_qos_durability_policy_e\n   RMW_QOS_POLICY_DURABILITY_VOLATILE,\n \n   /// Durability policy has not yet been set\n-  RMW_QOS_POLICY_DURABILITY_UNKNOWN\n\u002B  RMW_QOS_POLICY_DURABILITY_UNKNOWN,\n\u002B\n\u002B  /// Will match the majority of endpoints and use a transient local policy if possible\n\u002B  /**\n\u002B   * A policy will be chosen at the time of creating a subscription or publisher.\n\u002B   * A transient local policy will by chosen if it matches with all discovered endpoints,\n\u002B   * otherwise a volatile policy will be chosen.\n\u002B   *\n\u002B   * In the case that a volatile policy is chosen for a subscription, any messages sent before\n\u002B   * the subscription was created by transient local publishers will not be received.\n\u002B   *\n\u002B   * The QoS policy reported by functions like \u0060rmw_subscription_get_actual_qos\u0060 or\n\u002B   * \u0060rmw_publisher_get_actual_qos\u0060 may be best available, transient local, or volatile.\n\u002B   *\n\u002B   * Services and clients are not supported and default to the durability value in\n\u002B   * \u0060rmw_qos_profile_services_default\u0060.\n\u002B   *\n\u002B   * The middleware is not expected to update the policy after creating a subscription or\n\u002B   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n\u002B   * Therefore, this policy should be used with care since non-deterministic behavior\n\u002B   * can occur due to races with discovery.\n\u002B   */\n\u002B  RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE\n } rmw_qos_durability_policy_t;\n \n #define RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG \\\n@@ -453,17 \u002B494,80 @@ typedef enum RMW_PUBLIC_TYPE rmw_qos_liveliness_policy_e\n   RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = 3,\n \n   /// Liveliness policy has not yet been set\n-  RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4\n\u002B  RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4,\n\u002B\n\u002B  /// Will match the majority of endpoints and use a manual by topic policy if possible\n\u002B  /**\n\u002B   * A policy will be chosen at the time of creating a subscription or publisher.\n\u002B   * A manual by topic policy will by chosen if it matches with all discovered endpoints,\n\u002B   * otherwise an automatic policy will be chosen.\n\u002B   *\n\u002B   * The QoS policy reported by functions like \u0060rmw_subscription_get_actual_qos\u0060 or\n\u002B   * \u0060rmw_publisher_get_actual_qos\u0060 may be best available, automatic, or manual by topic.\n\u002B   *\n\u002B   * Services and clients are not supported and default to the liveliness value in\n\u002B   * \u0060rmw_qos_profile_services_default\u0060.\n\u002B   *\n\u002B   * The middleware is not expected to update the policy after creating a subscription or\n\u002B   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n\u002B   * Therefore, this policy should be used with care since non-deterministic behavior\n\u002B   * can occur due to races with discovery.\n\u002B   */\n\u002B  RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE = 5\n } rmw_qos_liveliness_policy_t;\n \n /// QoS Deadline default.\n #define RMW_QOS_DEADLINE_DEFAULT RMW_DURATION_UNSPECIFIED\n\u002B/// Will match the majority of endpoints while maintaining as strict a policy as possible\n\u002B/**\n\u002B * Value is RMW_DURATION_INFINITE - 1.\n\u002B *\n\u002B * A policy will be chosen at the time of creating a subscription or publisher.\n\u002B * For a subscription, the deadline will be the maximum value of all discovered publisher\n\u002B * deadlines.\n\u002B * For a publisher, the deadline will be the minimum value of all discovered subscription\n\u002B * deadlines.\n\u002B *\n\u002B * The QoS policy reported by functions like \u0060rmw_subscription_get_actual_qos\u0060 or\n\u002B * \u0060rmw_publisher_get_actual_qos\u0060 may be best available or the actual deadline value.\n\u002B *\n\u002B * Services and clients are not supported and default to the deadline value in\n\u002B * \u0060rmw_qos_profile_services_default\u0060.\n\u002B *\n\u002B * The middleware is not expected to update the policy after creating a subscription or\n\u002B * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n\u002B * Therefore, this policy should be used with care since non-deterministic behavior\n\u002B * can occur due to races with discovery.\n\u002B */\n\u002B#define RMW_QOS_DEADLINE_BEST_AVAILABLE {9223372036LL, 854775806LL}\n \n /// QoS Lifespan default.\n #define RMW_QOS_LIFESPAN_DEFAULT RMW_DURATION_UNSPECIFIED\n \n /// QoS Liveliness lease duration default.\n #define RMW_QOS_LIVELINESS_LEASE_DURATION_DEFAULT RMW_DURATION_UNSPECIFIED\n\u002B/// Will match the majority of endpoints while maintaining as strict a policy as possible\n\u002B/**\n\u002B * Value is RMW_DURATION_INFINITE - 1.\n\u002B *\n\u002B * A policy will be chosen at the time of creating a subscription or publisher.\n\u002B * For a subscription, the lease duration will be the maximum value of all discovered publisher\n\u002B * lease durations.\n\u002B * For a publisher, the lease duration will be the minimum value of all discovered subscription\n\u002B * lease durations.\n\u002B *\n\u002B * The QoS policy reported by functions like \u0060rmw_subscription_get_actual_qos\u0060 or\n\u002B * \u0060rmw_publisher_get_actual_qos\u0060 may be best available or the actual lease duration value.\n\u002B *\n\u002B * Services and clients are not supported and default to the lease duration value in\n\u002B * \u0060rmw_qos_profile_services_default\u0060.\n\u002B *\n\u002B * The middleware is not expected to update the policy after creating a subscription or\n\u002B * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n\u002B * Therefore, this policy should be used with care since non-deterministic behavior\n\u002B * can occur due to races with discovery.\n\u002B */\n\u002B#define RMW_QOS_LIVELINESS_LEASE_DURATION_BEST_AVAILABLE {9223372036LL, 854775806LL}\n \n /// ROS MiddleWare quality of service profile.\n typedef struct RMW_PUBLIC_TYPE rmw_qos_profile_s\ndiff --git rmw/src/qos_string_conversions.c rmw/src/qos_string_conversions.c\nindex 9826578..d578328 100644\n--- rmw/src/qos_string_conversions.c\n\u002B\u002B\u002B rmw/src/qos_string_conversions.c\n@@ -53,6 \u002B53,8 @@ rmw_qos_durability_policy_to_str(enum rmw_qos_durability_policy_e value)\n       return \u0022transient_local\u0022;\n     case RMW_QOS_POLICY_DURABILITY_VOLATILE:\n       return \u0022volatile\u0022;\n\u002B    case RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE:\n\u002B      return \u0022best_available\u0022;\n     case RMW_QOS_POLICY_DURABILITY_UNKNOWN:  // fallthrough\n     default:\n       return NULL;\n@@ -85,6 \u002B87,8 @@ rmw_qos_liveliness_policy_to_str(enum rmw_qos_liveliness_policy_e value)\n       return \u0022automatic\u0022;\n     case RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC:\n       return \u0022manual_by_topic\u0022;\n\u002B    case RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE:\n\u002B      return \u0022best_available\u0022;\n     case RMW_QOS_POLICY_LIVELINESS_UNKNOWN:  // fallthrough\n     default:\n       return NULL;\n@@ -101,6 \u002B105,8 @@ rmw_qos_reliability_policy_to_str(enum rmw_qos_reliability_policy_e value)\n       return \u0022reliable\u0022;\n     case RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT:\n       return \u0022best_effort\u0022;\n\u002B    case RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE:\n\u002B      return \u0022best_available\u0022;\n     case RMW_QOS_POLICY_RELIABILITY_UNKNOWN:  // fallthrough\n     default:\n       return NULL;\n@@ -157,6 \u002B163,9 @@ rmw_qos_durability_policy_from_str(const char * str)\n   if (RMW_QOS_STREQ_WITH_LITERAL(\u0022volatile\u0022, str)) {\n     return RMW_QOS_POLICY_DURABILITY_VOLATILE;\n   }\n\u002B  if (RMW_QOS_STREQ_WITH_LITERAL(\u0022best_available\u0022, str)) {\n\u002B    return RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE;\n\u002B  }\n   return RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n }\n \n@@ -189,6 \u002B198,9 @@ rmw_qos_liveliness_policy_from_str(const char * str)\n   if (RMW_QOS_STREQ_WITH_LITERAL(\u0022manual_by_topic\u0022, str)) {\n     return RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC;\n   }\n\u002B  if (RMW_QOS_STREQ_WITH_LITERAL(\u0022best_available\u0022, str)) {\n\u002B    return RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE;\n\u002B  }\n   return RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n }\n \n@@ -205,5 \u002B217,8 @@ rmw_qos_reliability_policy_from_str(const char * str)\n   if (RMW_QOS_STREQ_WITH_LITERAL(\u0022best_effort\u0022, str)) {\n     return RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n   }\n\u002B  if (RMW_QOS_STREQ_WITH_LITERAL(\u0022best_available\u0022, str)) {\n\u002B    return RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE;\n\u002B  }\n   return RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n }\ndiff --git rmw/test/test_qos_string_conversions.cpp rmw/test/test_qos_string_conversions.cpp\nindex 126ad39..922001c 100644\n--- rmw/test/test_qos_string_conversions.cpp\n\u002B\u002B\u002B rmw/test/test_qos_string_conversions.cpp\n@@ -41,15 \u002B41,18 @@ TEST(test_qos_policy_stringify, test_policy_values) {\n   TEST_QOS_POLICY_VALUE_STRINGIFY(durability, RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(durability, RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(durability, RMW_QOS_POLICY_DURABILITY_VOLATILE);\n\u002B  TEST_QOS_POLICY_VALUE_STRINGIFY(durability, RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(history, RMW_QOS_POLICY_HISTORY_KEEP_LAST);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(history, RMW_QOS_POLICY_HISTORY_KEEP_ALL);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(history, RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(liveliness, RMW_QOS_POLICY_LIVELINESS_AUTOMATIC);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(liveliness, RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(liveliness, RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT);\n\u002B  TEST_QOS_POLICY_VALUE_STRINGIFY(liveliness, RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(reliability, RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(reliability, RMW_QOS_POLICY_RELIABILITY_RELIABLE);\n   TEST_QOS_POLICY_VALUE_STRINGIFY(reliability, RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT);\n\u002B  TEST_QOS_POLICY_VALUE_STRINGIFY(reliability, RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE);\n \n   TEST_QOS_POLICY_STRINGIFY_CORNER_CASES(durability, DURABILITY);\n   TEST_QOS_POLICY_STRINGIFY_CORNER_CASES(history, HISTORY);\n",
    "IsBackported": false
  },
  {
    "Repository": "rmw_fastrtps",
    "SHA": "de507bb1525861b69e3aa95e10e26abdd32e610c",
    "RawMessage": "Check for errors while doing an rmw_discovery_options_copy. (#690)",
    "Changes": "diff --git rmw_fastrtps_shared_cpp/src/rmw_init.cpp rmw_fastrtps_shared_cpp/src/rmw_init.cpp\nindex 8db15ec..fbd72a1 100644\n--- rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n\u002B\u002B\u002B rmw_fastrtps_shared_cpp/src/rmw_init.cpp\n@@ -87,6 \u002B87,12 @@ rmw_init_options_copy(\n     \u0026src-\u003Ediscovery_options,\n     \u0026allocator,\n     \u0026tmp.discovery_options);\n\u002B  if (ret != RMW_RET_OK) {\n\u002B    allocator.deallocate(tmp.enclave, allocator.state);\n\u002B    rmw_security_options_fini(\u0026tmp.security_options, \u0026allocator);\n\u002B    // Error already set\n\u002B    return ret;\n\u002B  }\n   *dst = tmp;\n   return RMW_RET_OK;\n }\n",
    "IsBackported": false
  }
]