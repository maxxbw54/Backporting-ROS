{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-| Grid                  | Select        | Third Person Follower | Tool Properties | \n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Views           |\n-| Illuminance           | Publish Point |\n+| Grid                  | Select        | Third Person Follower | Time            |\n+| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Illuminance           | Publish Point |                       | Views           |"},{"role":"user","content":"-| Displays      | Panels |\n-| ------------- | ------ |\n-| DepthCloud    | Time   |\n+| Displays      |\n+| ------------- |\n+| DepthCloud    |"},{"role":"user","content":"+  src/rviz_common/time_panel.hpp"},{"role":"user","content":"+  src/rviz_common/time_panel.cpp"},{"role":"user","content":"-  # TODO(wjwwood): restore these panels when ported\n-  # - Class: rviz/Time\n-  #   Name: Time\n-  #   SyncMode: 0\n-  #   SyncSource: \"\"\n+  - Class: rviz_common/Time\n+    Experimental: false\n+    Name: Time\n+    SyncMode: 0\n+    SyncSource: \"\""},{"role":"user","content":"-// TODO(wjwwood): reenable the remaining panels"},{"role":"user","content":"-// #include \"./time_panel.hpp\"\n+#include \"./time_panel.hpp\""},{"role":"user","content":"-// static Panel * newTimePanel() {return new TimePanel();}"},{"role":"user","content":"-  // addBuiltInClass(\"rviz\", \"Time\",\n-  //   \"Show the current time\", &newTimePanel);\n+  addBuiltInClass(\n+    \"rviz_common\", \"Time\",\n+    \"Show the current time\",\n+    [manager]() -> Panel * {\n+      return new TimePanel(manager, nullptr);\n+    });"},{"role":"user","content":"-#include \"include/rviz_common/display_group.hpp\"\n+#include \"rviz_common/display_group.hpp\""},{"role":"user","content":"-namespace rviz\n+namespace rviz_common"},{"role":"user","content":"-TimePanel::TimePanel(QWidget * parent)\n-: Panel(parent)\n+TimePanel::TimePanel(VisualizationManager * manager, QWidget * parent)\n+: Panel(parent), vis_manager_(manager)"},{"role":"user","content":"+  experimentalToggled(false);"},{"role":"user","content":"-      display_group, SIGNAL(displayAdded(rviz::Display*)), this,\n-      SLOT(onDisplayAdded(rviz::Display*)));\n+      display_group, &DisplayGroup::displayAdded,\n+      this, &TimePanel::onDisplayAdded);"},{"role":"user","content":"-      display_group, SIGNAL(displayRemoved(rviz::Display*)), this,\n-      SLOT(onDisplayRemoved(rviz::Display*)));\n+      display_group, &DisplayGroup::displayRemoved,\n+      this, &TimePanel::onDisplayRemoved);"},{"role":"user","content":"-      rviz::Display * display = display_group->getDisplayAt(i);\n+      rviz_common::Display * display = display_group->getDisplayAt(i);"},{"role":"user","content":"-    connect(display, SIGNAL(timeSignal(rviz::Display *, ros::Time)), this,\n-      SLOT(onTimeSignal(rviz::Display *, ros::Time)));\n+    connect(display, SIGNAL(timeSignal(rviz_common::Display *, rclcpp::Time)), this,\n+      SLOT(onTimeSignal(rviz_common::Display *, rclcpp::Time)));"},{"role":"user","content":"-void TimePanel::onTimeSignal(Display * display, ros::Time time)\n+void TimePanel::onTimeSignal(Display * display, rclcpp::Time time)"},{"role":"user","content":"+  Q_UNUSED(index);\n+"},{"role":"user","content":"-  vis_manager_->getFrameManager()->setSyncMode( (FrameManager::SyncMode)mode);\n+  vis_manager_->getFrameManager()->setSyncMode(FrameManager::SyncMode(mode) );"},{"role":"user","content":"-}  // namespace rviz\n+}  // namespace rviz_common"},{"role":"user","content":"-#include \"rviz_rendering/panel.hpp\"\n-#include \"ros/time.h\"\n+#include \"rviz_common/panel.hpp\"\n+#include \"rclcpp/rclcpp.hpp\""},{"role":"user","content":"-namespace rviz\n+namespace rviz_common"},{"role":"user","content":"-  explicit TimePanel(QWidget * parent = 0);\n+  explicit TimePanel(\n+    VisualizationManager * manager,\n+    QWidget * parent = nullptr);"},{"role":"user","content":"-  void onDisplayAdded(rviz::Display * display);\n-  void onDisplayRemoved(rviz::Display * display);\n+  void onDisplayAdded(rviz_common::Display * display);\n+  void onDisplayRemoved(rviz_common::Display * display);"},{"role":"user","content":"-  void onTimeSignal(rviz::Display * display, ros::Time time);\n+  void onTimeSignal(rviz_common::Display * display, rclcpp::Time time);"},{"role":"user","content":"+\n+  VisualizationManager * vis_manager_;"},{"role":"user","content":"-}  // namespace rviz\n+}  // namespace rviz_common"},{"role":"user","content":"-  // TODO(wjwwood): why does this function return now - begin, whereas the getWallClockElapsed\n-  //                returns a pre-calculated elapsed value?\n-  //                figure out how this function is being used and make these consistent\n-  return (frame_manager_->getTime() - ros_time_begin_).nanoseconds() / 1e9;\n+  return static_cast<double>(ros_time_elapsed_) / 1e9;"},{"role":"user","content":"-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!-- Created with Inkscape (http://www.inkscape.org/) -->\n-\n-<svg\n-   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n-   xmlns:cc=\"http://creativecommons.org/ns#\"\n-   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n-   xmlns:svg=\"http://www.w3.org/2000/svg\"\n-   xmlns=\"http://www.w3.org/2000/svg\"\n-   xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n-   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n-   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n-   width=\"16px\"\n-   height=\"16px\"\n-   id=\"svg3851\"\n-   version=\"1.1\"\n-   inkscape:version=\"0.48.3.1 r9886\"\n-   sodipodi:docname=\"Time.svg\"\n-   inkscape:export-filename=\"/work/gossow/rviz/rviz/icons/visibility.png\"\n-   inkscape:export-xdpi=\"90\"\n-   inkscape:export-ydpi=\"90\">\n-  <defs\n-     id=\"defs3853\">\n-    <inkscape:perspective\n-       sodipodi:type=\"inkscape:persp3d\"\n-       inkscape:vp_x=\"-1.0827572 : -0.75044646 : 1\"\n-       inkscape:vp_y=\"0 : 1000 : 0\"\n-       inkscape:vp_z=\"95.903066 : 6.0333593 : 1\"\n-       inkscape:persp3d-origin=\"8 : 5.3333333 : 1\"\n-       id=\"perspective3847\" />\n-    <linearGradient\n-       id=\"linearGradient3837\">\n-      <stop\n-         style=\"stop-color:#808080;stop-opacity:1;\"\n-         offset=\"0\"\n-         id=\"stop3839\" />\n-      <stop\n-         style=\"stop-color:#e9e9e9;stop-opacity:1;\"\n-         offset=\"1\"\n-         id=\"stop3841\" />\n-    </linearGradient>\n-    <linearGradient\n-       id=\"linearGradient3841\">\n-      <stop\n-         id=\"stop3843\"\n-         offset=\"0\"\n-         style=\"stop-color:#ffffff;stop-opacity:1;\" />\n-      <stop\n-         style=\"stop-color:#ffffff;stop-opacity:1;\"\n-         offset=\"0.34984758\"\n-         id=\"stop3845\" />\n-      <stop\n-         id=\"stop3849\"\n-         offset=\"0.5454545\"\n-         style=\"stop-color:#e8e8e8;stop-opacity:1;\" />\n-      <stop\n-         id=\"stop3847\"\n-         offset=\"1\"\n-         style=\"stop-color:#252525;stop-opacity:1;\" />\n-    </linearGradient>\n-    <linearGradient\n-       id=\"linearGradient3824\">\n-      <stop\n-         style=\"stop-color:#ffffff;stop-opacity:1;\"\n-         offset=\"0\"\n-         id=\"stop3826\" />\n-      <stop\n-         id=\"stop3832\"\n-         offset=\"0.5\"\n-         style=\"stop-color:#ffffff;stop-opacity:1;\" />\n-      <stop\n-         style=\"stop-color:#d2d2d2;stop-opacity:1;\"\n-         offset=\"1\"\n-         id=\"stop3828\" />\n-    </linearGradient>\n-    <linearGradient\n-       id=\"linearGradient3827\">\n-      <stop\n-         style=\"stop-color:#8ca6f1;stop-opacity:1;\"\n-         offset=\"0\"\n-         id=\"stop3829\" />\n-      <stop\n-         id=\"stop3836\"\n-         offset=\"0.73972601\"\n-         style=\"stop-color:#5a72b4;stop-opacity:1;\" />\n-      <stop\n-         style=\"stop-color:#293e78;stop-opacity:1;\"\n-         offset=\"1\"\n-         id=\"stop3831\" />\n-    </linearGradient>\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect3829\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m 4.8980822,-0.72049866 6.1888208,0\"\n-       bendpath2=\"M 11.086903,-0.72049866 16.270482,14.741843\"\n-       bendpath3=\"M -0.25926539,14.751544 16.270482,14.741891\"\n-       bendpath4=\"M 4.8980822,-0.72049866 -0.25926539,14.751544\"\n-       bendpath3-nodetypes=\"cc\"\n-       bendpath4-nodetypes=\"cc\"\n-       bendpath2-nodetypes=\"cc\" />\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect3819\"\n-       is_visible=\"true\"\n-       yy=\"true\"\n-       xx=\"true\"\n-       bendpath1=\"m -11,0.5 6.0000002,0\"\n-       bendpath2=\"m -4.9999998,0.5 0,15\"\n-       bendpath3=\"m -11,15.5 6.0000002,0\"\n-       bendpath4=\"m -11,0.5 0,15\" />\n-    <linearGradient\n-       id=\"linearGradient5756\">\n-      <stop\n-         style=\"stop-color:#c8c8c8;stop-opacity:1;\"\n-         offset=\"0\"\n-         id=\"stop5758\" />\n-      <stop\n-         style=\"stop-color:#ffffff;stop-opacity:1;\"\n-         offset=\"1\"\n-         id=\"stop5760\" />\n-    </linearGradient>\n-    <inkscape:path-effect\n-       bendpath4-nodetypes=\"cc\"\n-       bendpath2-nodetypes=\"cc\"\n-       bendpath4=\"m 0.40934447,12.183659 c 5.22111233,-2.7860162 10.20346753,-2.563681 15.00000053,0\"\n-       bendpath3=\"m 15.409345,12.183659 0,-6.0000003\"\n-       bendpath2=\"m 0.40934447,6.1836587 c 5.17204473,-2.752717 10.16772953,-2.683658 15.00000053,0\"\n-       bendpath1=\"m 0.40934447,12.183659 0,-6.0000003\"\n-       xx=\"true\"\n-       yy=\"false\"\n-       is_visible=\"true\"\n-       id=\"path-effect5700\"\n-       effect=\"envelope\" />\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect5673\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m 3.7040018,0.50188195 6.0000002,0\"\n-       bendpath2=\"m 9.704002,0.50188195 c 2.752717,5.17204475 2.683658,10.16772905 0,15.00000005\"\n-       bendpath3=\"m 3.7040018,15.501882 6.0000002,0\"\n-       bendpath4=\"m 3.7040018,0.50188195 c 2.7860161,5.22111235 2.5636809,10.20346705 0,15.00000005\"\n-       bendpath2-nodetypes=\"cc\"\n-       bendpath4-nodetypes=\"cc\" />\n-    <inkscape:path-effect\n-       effect=\"bend_path\"\n-       id=\"path-effect5590\"\n-       is_visible=\"true\"\n-       bendpath=\"m 6.5,8 4,0\"\n-       prop_scale=\"1\"\n-       scale_y_rel=\"true\"\n-       vertical=\"false\" />\n-    <inkscape:path-effect\n-       effect=\"vonkoch\"\n-       id=\"path-effect5588\"\n-       is_visible=\"true\"\n-       ref_path=\"m 6.5,8 4,0\"\n-       generator=\"m 6.5,15.5 1.3333333,0 m 1.3333334,0 1.3333333,0\"\n-       similar_only=\"false\"\n-       nbgenerations=\"1\"\n-       drawall=\"true\"\n-       maxComplexity=\"1000\" />\n-    <inkscape:path-effect\n-       effect=\"rough_hatches\"\n-       id=\"path-effect5586\"\n-       is_visible=\"false\"\n-       direction=\"8.5,3 , 1,0\"\n-       dist_rdm=\"75;1\"\n-       growth=\"0\"\n-       do_bend=\"true\"\n-       bender=\"8.5,8 , 5,0\"\n-       bottom_edge_variation=\"1.5;1\"\n-       top_edge_variation=\"1.5;1\"\n-       bottom_tgt_variation=\"0;1\"\n-       top_tgt_variation=\"0;1\"\n-       scale_bf=\"1\"\n-       scale_bb=\"1\"\n-       scale_tf=\"1\"\n-       scale_tb=\"1\"\n-       top_smth_variation=\"0;1\"\n-       bottom_smth_variation=\"0;1\"\n-       fat_output=\"true\"\n-       stroke_width_top=\"1\"\n-       stroke_width_bottom=\"1\"\n-       front_thickness=\"1\"\n-       back_thickness=\"0.25\" />\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect5582\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m 6.5,0.5 4,0\"\n-       bendpath2=\"m 10.5,0.5 0,15\"\n-       bendpath3=\"m 6.5,15.5 4,0\"\n-       bendpath4=\"m 6.5,0.5 0,15\" />\n-    <marker\n-       inkscape:stockid=\"Arrow2Lend\"\n-       orient=\"auto\"\n-       refY=\"0.0\"\n-       refX=\"0.0\"\n-       id=\"Arrow2Lend\"\n-       style=\"overflow:visible;\">\n-      <path\n-         id=\"path4397\"\n-         style=\"font-size:12.0;fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;\"\n-         d=\"M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z \"\n-         transform=\"scale(1.1) rotate(180) translate(1,0)\" />\n-    </marker>\n-    <marker\n-       inkscape:stockid=\"Arrow2Lstart\"\n-       orient=\"auto\"\n-       refY=\"0.0\"\n-       refX=\"0.0\"\n-       id=\"Arrow2Lstart\"\n-       style=\"overflow:visible\">\n-      <path\n-         id=\"path4394\"\n-         style=\"font-size:12.0;fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round\"\n-         d=\"M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z \"\n-         transform=\"scale(1.1) translate(1,0)\" />\n-    </marker>\n-    <marker\n-       inkscape:stockid=\"Arrow1Lstart\"\n-       orient=\"auto\"\n-       refY=\"0.0\"\n-       refX=\"0.0\"\n-       id=\"Arrow1Lstart\"\n-       style=\"overflow:visible\">\n-      <path\n-         id=\"path4376\"\n-         d=\"M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z \"\n-         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1.0pt;marker-start:none\"\n-         transform=\"scale(0.8) translate(12.5,0)\" />\n-    </marker>\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect5673-8\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m -1.9996646,0.50189386 6,0\"\n-       bendpath2=\"m 4.0003354,0.50189386 c 2.7527172,5.17204484 2.6836582,10.16772914 0,15.00000014\"\n-       bendpath3=\"m -1.9996646,15.501894 6,0\"\n-       bendpath4=\"m -1.9996646,0.50189386 c 2.7860161,5.22111244 2.5636809,10.20346714 0,15.00000014\"\n-       bendpath2-nodetypes=\"cc\"\n-       bendpath4-nodetypes=\"cc\" />\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect5673-7\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m -11,0.5 6.0000002,0\"\n-       bendpath2=\"m -4.9999998,0.5 c 2.7527168,5.1720447 2.6836578,10.167729 0,15\"\n-       bendpath3=\"m -11,15.5 6.0000002,0\"\n-       bendpath4=\"m -11,0.5 c 2.7860161,5.2211123 2.5636809,10.203467 0,15\"\n-       bendpath2-nodetypes=\"cc\"\n-       bendpath4-nodetypes=\"cc\" />\n-    <inkscape:path-effect\n-       effect=\"envelope\"\n-       id=\"path-effect5673-7-1\"\n-       is_visible=\"true\"\n-       yy=\"false\"\n-       xx=\"true\"\n-       bendpath1=\"m 3.8034148,0.59873227 6,0\"\n-       bendpath2=\"m 9.8034148,0.59873227 c 2.7527172,5.17204473 2.6836582,10.16772873 0,14.99999973\"\n-       bendpath3=\"m 3.8034148,15.598732 6,0\"\n-       bendpath4=\"m 3.8034148,0.59873227 c 2.7860159,5.22111233 2.5636807,10.20346673 0,14.99999973\"\n-       bendpath2-nodetypes=\"cc\"\n-       bendpath4-nodetypes=\"cc\" />\n-    <linearGradient\n-       inkscape:collect=\"always\"\n-       xlink:href=\"#linearGradient5756\"\n-       id=\"linearGradient5762\"\n-       x1=\"12\"\n-       y1=\"11.5\"\n-       x2=\"7.5\"\n-       y2=\"6\"\n-       gradientUnits=\"userSpaceOnUse\"\n-       gradientTransform=\"matrix(-1.030301,0,0,1.030301,16.242408,-0.242408)\" />\n-    <linearGradient\n-       inkscape:collect=\"always\"\n-       xlink:href=\"#linearGradient5756\"\n-       id=\"linearGradient3798\"\n-       x1=\"4\"\n-       y1=\"14\"\n-       x2=\"9\"\n-       y2=\"8.5\"\n-       gradientUnits=\"userSpaceOnUse\" />\n-    <linearGradient\n-       inkscape:collect=\"always\"\n-       xlink:href=\"#linearGradient4548\"\n-       id=\"linearGradient4546\"\n-       x1=\"17\"\n-       y1=\"1043.4717\"\n-       x2=\"17\"\n-       y2=\"1040.5363\"\n-       gradientUnits=\"userSpaceOnUse\"\n-       gradientTransform=\"matrix(0.5297937,0,0,0.42583335,-0.44892098,605.26716)\" />\n-    <linearGradient\n-       id=\"linearGradient4548\">\n-      <stop\n-         style=\"stop-color:#000000;stop-opacity:1;\"\n-         offset=\"0\"\n-         id=\"stop4550\" />\n-      <stop\n-         id=\"stop4552\"\n-         offset=\"0.4999913\"\n-         style=\"stop-color:#ffffff;stop-opacity:1;\" />\n-      <stop\n-         style=\"stop-color:#000000;stop-opacity:1;\"\n-         offset=\"1\"\n-         id=\"stop4554\" />\n-    </linearGradient>\n-  </defs>\n-  <sodipodi:namedview\n-     id=\"base\"\n-     pagecolor=\"#ffffff\"\n-     bordercolor=\"#666666\"\n-     borderopacity=\"1.0\"\n-     inkscape:pageopacity=\"0.0\"\n-     inkscape:pageshadow=\"2\"\n-     inkscape:zoom=\"32\"\n-     inkscape:cx=\"8.3183485\"\n-     inkscape:cy=\"12.957031\"\n-     inkscape:current-layer=\"text3853\"\n-     showgrid=\"true\"\n-     inkscape:grid-bbox=\"true\"\n-     inkscape:document-units=\"px\"\n-     inkscape:window-width=\"1247\"\n-     inkscape:window-height=\"1547\"\n-     inkscape:window-x=\"1311\"\n-     inkscape:window-y=\"24\"\n-     inkscape:window-maximized=\"0\">\n-    <inkscape:grid\n-       type=\"xygrid\"\n-       id=\"grid5567\"\n-       empspacing=\"4\"\n-       visible=\"true\"\n-       enabled=\"true\"\n-       snapvisiblegridlinesonly=\"true\"\n-       spacingx=\"0.25px\"\n-       spacingy=\"0.25px\" />\n-    <inkscape:grid\n-       type=\"xygrid\"\n-       id=\"grid5569\"\n-       empspacing=\"8\"\n-       visible=\"true\"\n-       enabled=\"true\"\n-       snapvisiblegridlinesonly=\"true\"\n-       color=\"#ff0000\"\n-       opacity=\"0.1254902\" />\n-  </sodipodi:namedview>\n-  <metadata\n-     id=\"metadata3856\">\n-    <rdf:RDF>\n-      <cc:Work\n-         rdf:about=\"\">\n-        <dc:format>image/svg+xml</dc:format>\n-        <dc:type\n-           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n-        <dc:title></dc:title>\n-      </cc:Work>\n-    </rdf:RDF>\n-  </metadata>\n-  <g\n-     id=\"layer1\"\n-     inkscape:label=\"Layer 1\"\n-     inkscape:groupmode=\"layer\">\n-    <g\n-       style=\"font-size:21.55789566px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#3f3f3f;fill-opacity:1;stroke:none;font-family:Sans;-inkscape-font-specification:Sans Bold\"\n-       id=\"text3853\">\n-      <path\n-         sodipodi:type=\"arc\"\n-         style=\"fill:#ffffff;fill-opacity:1;stroke:#656565;stroke-width:2.28571438999999987;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none\"\n-         id=\"path3879\"\n-         sodipodi:cx=\"8\"\n-         sodipodi:cy=\"8\"\n-         sodipodi:rx=\"8\"\n-         sodipodi:ry=\"8\"\n-         d=\"M 16,8 A 8,8 0 1 1 0,8 8,8 0 1 1 16,8 z\"\n-         transform=\"matrix(0.875,0,0,0.875,1,1)\" />\n-      <path\n-         style=\"fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:square;stroke-linejoin:miter;stroke-opacity:1\"\n-         d=\"m 7.5,4.5 0,4 4,0\"\n-         id=\"path3881\"\n-         inkscape:connector-curvature=\"0\"\n-         sodipodi:nodetypes=\"ccc\" />\n-    </g>\n-  </g>\n-  <g\n-     inkscape:groupmode=\"layer\"\n-     id=\"layer2\"\n-     inkscape:label=\"Layer\" />\n-</svg>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        callback: Callable[[TimerInfo], None],\n+        callback: Union[Callable[[], None], Callable[[TimerInfo], None], None],"},{"role":"user","content":"+from typing import Protocol"},{"role":"user","content":"+from typing import Union"},{"role":"user","content":"-from rclpy.clock import Clock, ClockType\n+from rclpy.clock import Clock\n+from rclpy.clock_type import ClockType"},{"role":"user","content":"+from rclpy.destroyable import DestroyableType"},{"role":"user","content":"+class TimerHandle(DestroyableType, Protocol):\n+    \"\"\"Type alias of _rclpy.Timer.\"\"\"\n+\n+    def reset_timer(self) -> None:\n+        ...\n+\n+    def is_timer_ready(self) -> bool:\n+        ...\n+\n+    def call_timer(self) -> None:\n+        ...\n+\n+    def change_timer_period(self, period_nsec: int) -> None:\n+        ...\n+\n+    def time_until_next_call(self) -> Optional[int]:\n+        ...\n+\n+    def time_since_last_call(self) -> int:\n+        ...\n+\n+    def get_timer_period(self) -> int:\n+        ...\n+\n+    def cancel_timer(self) -> None:\n+        ...\n+\n+    def is_timer_canceled(self) -> bool:\n+        ...\n+\n+"},{"role":"user","content":"-        callback: Callable,\n+        callback: Union[Callable[[], None], Callable[[TimerInfo], None], None],"},{"role":"user","content":"+        if self._context.handle is None:\n+            raise RuntimeError('Context must be initialized before create a TimerHandle.')"},{"role":"user","content":"-            self.__timer = _rclpy.Timer(\n+            self.__timer: TimerHandle = _rclpy.Timer("},{"role":"user","content":"-    def handle(self):\n+    def handle(self) -> TimerHandle:"},{"role":"user","content":"-    def destroy(self):\n+    def destroy(self) -> None:"},{"role":"user","content":"-    def clock(self):\n+    def clock(self) -> Clock:"},{"role":"user","content":"-    def timer_period_ns(self):\n+    def timer_period_ns(self) -> int:"},{"role":"user","content":"-    def timer_period_ns(self, value):\n+    def timer_period_ns(self, value: int) -> None:"},{"role":"user","content":"-    def is_ready(self):\n+    def is_ready(self) -> bool:"},{"role":"user","content":"-    def is_canceled(self):\n+    def is_canceled(self) -> bool:"},{"role":"user","content":"-    def cancel(self):\n+    def cancel(self) -> None:"},{"role":"user","content":"-    def reset(self):\n+    def reset(self) -> None:"},{"role":"user","content":"-    def time_since_last_call(self):\n+    def time_since_last_call(self) -> int:"},{"role":"user","content":"-    def time_until_next_call(self):\n+    def time_until_next_call(self) -> Optional[int]:"},{"role":"user","content":"-    def __init__(self, timer: Timer, *, context):\n+    def __init__(self, timer: Timer, *, context: Context):"},{"role":"user","content":"-    def _on_shutdown(self):\n+    def _on_shutdown(self) -> None:"},{"role":"user","content":"-    def destroy(self):\n+    def destroy(self) -> None:"},{"role":"user","content":"-    def _presleep(self):\n+    def _presleep(self) -> None:"},{"role":"user","content":"-    def _postsleep(self):\n+    def _postsleep(self) -> None:"},{"role":"user","content":"-    def sleep(self):\n+    def sleep(self) -> None:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        :return: The service response, or None if timed out.\n+        :return: The service response."},{"role":"user","content":"+        :raises: TimeoutError if the response is not available within the timeout."},{"role":"user","content":"+                raise TimeoutError()"},{"role":"user","content":"+            # make sure thread has started to avoid exception via join()\n+            self.assertTrue(executor_thread.is_alive())"},{"role":"user","content":"-            result = cli.call(GetParameters.Request(), 0.5)\n-            self.assertTrue(result is None)\n+            # make sure thread has started to avoid exception via join()\n+            self.assertTrue(executor_thread.is_alive())\n+            with self.assertRaises(TimeoutError):\n+                cli.call(GetParameters.Request(), 0.5)\n+        finally:"},{"role":"user","content":"-        finally:"},{"role":"user","content":"+                # make sure thread has started to avoid exception via join()\n+                self.assertTrue(executor_thread.is_alive())"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+/// \\param[in] node_fqn a Fully Qualified Name of node, default value is nullptr.\n+///   If it's not nullptr, return the relative node parameters belonging to this node_fqn."},{"role":"user","content":"-parameter_map_from(const rcl_params_t * const c_params);\n+parameter_map_from(const rcl_params_t * const c_params, const char * node_fqn = nullptr);"},{"role":"user","content":"-      rclcpp::ParameterMap initial_map = rclcpp::parameter_map_from(params);\n+      rclcpp::ParameterMap initial_map = rclcpp::parameter_map_from(params, node_fqn.c_str());"},{"role":"user","content":"-      // Enforce wildcard matching precedence\n-      // TODO(cottsay) implement further wildcard matching\n-      const std::array<std::string, 2> node_matching_names{\"/**\", node_fqn};\n-      for (const auto & node_name : node_matching_names) {\n-        if (initial_map.count(node_name) > 0) {\n-          // Combine parameter yaml files, overwriting values in older ones\n-          for (const rclcpp::Parameter & param : initial_map.at(node_name)) {\n-            result[param.get_name()] =\n-              rclcpp::ParameterValue(param.get_value_message());\n-          }\n+      if (initial_map.count(node_fqn) > 0) {\n+        // Combine parameter yaml files, overwriting values in older ones\n+        for (const rclcpp::Parameter & param : initial_map.at(node_fqn)) {\n+          result[param.get_name()] =\n+            rclcpp::ParameterValue(param.get_value_message());"},{"role":"user","content":"+#include <regex>"},{"role":"user","content":"+#include \"rcpputils/find_and_replace.hpp\""},{"role":"user","content":"-rclcpp::parameter_map_from(const rcl_params_t * const c_params)\n+rclcpp::parameter_map_from(const rcl_params_t * const c_params, const char * node_fqn)"},{"role":"user","content":"+    if (node_fqn) {\n+      // Update the regular expression [\"/*\" -> \"(/\\\\w+)\" and \"/**\" -> \"(/\\\\w+)*\"]\n+      std::string regex = rcpputils::find_and_replace(node_name, \"/*\", \"(/\\\\w+)\");\n+      if (!std::regex_match(node_fqn, std::regex(regex))) {\n+        // No need to parse the items because the user just care about node_fqn\n+        continue;\n+      }\n+\n+      node_name = node_fqn;\n+    }\n+"},{"role":"user","content":"+"},{"role":"user","content":"+#include \"rcpputils/filesystem_helper.hpp\"\n+"},{"role":"user","content":"+    test_resources_path /= \"test_node_parameters\";"},{"role":"user","content":"+\n+  rcpputils::fs::path test_resources_path{TEST_RESOURCES_DIRECTORY};"},{"role":"user","content":"+\n+TEST_F(TestNodeParameters, wildcard_with_namespace)\n+{\n+  rclcpp::NodeOptions opts;\n+  opts.arguments(\n+  {\n+    \"--ros-args\",\n+    \"--params-file\", (test_resources_path / \"wildcards.yaml\").string()\n+  });\n+\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\", opts);\n+\n+  auto * node_parameters =\n+    dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+    node->get_node_parameters_interface().get());\n+  ASSERT_NE(nullptr, node_parameters);\n+\n+  const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+  EXPECT_EQ(7u, parameter_overrides.size());\n+  EXPECT_EQ(parameter_overrides.at(\"full_wild\").get<std::string>(), \"full_wild\");\n+  EXPECT_EQ(parameter_overrides.at(\"namespace_wild\").get<std::string>(), \"namespace_wild\");\n+  EXPECT_EQ(\n+    parameter_overrides.at(\"namespace_wild_another\").get<std::string>(),\n+    \"namespace_wild_another\");\n+  EXPECT_EQ(\n+    parameter_overrides.at(\"namespace_wild_one_star\").get<std::string>(),\n+    \"namespace_wild_one_star\");\n+  EXPECT_EQ(parameter_overrides.at(\"node_wild_in_ns\").get<std::string>(), \"node_wild_in_ns\");\n+  EXPECT_EQ(\n+    parameter_overrides.at(\"node_wild_in_ns_another\").get<std::string>(),\n+    \"node_wild_in_ns_another\");\n+  EXPECT_EQ(parameter_overrides.at(\"explicit_in_ns\").get<std::string>(), \"explicit_in_ns\");\n+  EXPECT_EQ(parameter_overrides.count(\"should_not_appear\"), 0u);\n+}\n+\n+TEST_F(TestNodeParameters, wildcard_no_namespace)\n+{\n+  rclcpp::NodeOptions opts;\n+  opts.arguments(\n+  {\n+    \"--ros-args\",\n+    \"--params-file\", (test_resources_path / \"wildcards.yaml\").string()\n+  });\n+\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node2\", opts);\n+\n+  auto * node_parameters =\n+    dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+    node->get_node_parameters_interface().get());\n+  ASSERT_NE(nullptr, node_parameters);\n+\n+  const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+  EXPECT_EQ(5u, parameter_overrides.size());\n+  EXPECT_EQ(parameter_overrides.at(\"full_wild\").get<std::string>(), \"full_wild\");\n+  EXPECT_EQ(parameter_overrides.at(\"namespace_wild\").get<std::string>(), \"namespace_wild\");\n+  EXPECT_EQ(\n+    parameter_overrides.at(\"namespace_wild_another\").get<std::string>(),\n+    \"namespace_wild_another\");\n+  EXPECT_EQ(parameter_overrides.at(\"node_wild_no_ns\").get<std::string>(), \"node_wild_no_ns\");\n+  EXPECT_EQ(parameter_overrides.at(\"explicit_no_ns\").get<std::string>(), \"explicit_no_ns\");\n+  EXPECT_EQ(parameter_overrides.count(\"should_not_appear\"), 0u);\n+  // \"/*\" match exactly one token, not expect to get `namespace_wild_one_star`\n+  EXPECT_EQ(parameter_overrides.count(\"namespace_wild_one_star\"), 0u);\n+}\n+\n+TEST_F(TestNodeParameters, params_by_order)\n+{\n+  rclcpp::NodeOptions opts;\n+  opts.arguments(\n+  {\n+    \"--ros-args\",\n+    \"--params-file\", (test_resources_path / \"params_by_order.yaml\").string()\n+  });\n+\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\", opts);\n+\n+  auto * node_parameters =\n+    dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+    node->get_node_parameters_interface().get());\n+  ASSERT_NE(nullptr, node_parameters);\n+\n+  const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+  EXPECT_EQ(3u, parameter_overrides.size());\n+  EXPECT_EQ(parameter_overrides.at(\"a_value\").get<std::string>(), \"last_one_win\");\n+  EXPECT_EQ(parameter_overrides.at(\"foo\").get<std::string>(), \"foo\");\n+  EXPECT_EQ(parameter_overrides.at(\"bar\").get<std::string>(), \"bar\");\n+}\n+\n+TEST_F(TestNodeParameters, complicated_wildcards)\n+{\n+  rclcpp::NodeOptions opts;\n+  opts.arguments(\n+  {\n+    \"--ros-args\",\n+    \"--params-file\", (test_resources_path / \"complicated_wildcards.yaml\").string()\n+  });\n+\n+  {\n+    // regex matched: /**/foo/*/bar\n+    std::shared_ptr<rclcpp::Node> node =\n+      std::make_shared<rclcpp::Node>(\"node2\", \"/a/b/c/foo/d/bar\", opts);\n+\n+    auto * node_parameters =\n+      dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+      node->get_node_parameters_interface().get());\n+    ASSERT_NE(nullptr, node_parameters);\n+\n+    const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+    EXPECT_EQ(2u, parameter_overrides.size());\n+    EXPECT_EQ(parameter_overrides.at(\"foo\").get<std::string>(), \"foo\");\n+    EXPECT_EQ(parameter_overrides.at(\"bar\").get<std::string>(), \"bar\");\n+  }\n+\n+  {\n+    // regex not matched: /**/foo/*/bar\n+    std::shared_ptr<rclcpp::Node> node =\n+      std::make_shared<rclcpp::Node>(\"node2\", \"/a/b/c/foo/bar\", opts);\n+\n+    auto * node_parameters =\n+      dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+      node->get_node_parameters_interface().get());\n+    ASSERT_NE(nullptr, node_parameters);\n+\n+    const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+    EXPECT_EQ(0u, parameter_overrides.size());\n+  }\n+}"},{"role":"user","content":"+#include <unordered_map>"},{"role":"user","content":"+\n+TEST(Test_parameter_map_from, one_node_one_param_by_node_fqn)\n+{\n+  rcl_params_t * c_params = make_params({\"foo\"});\n+  make_node_params(c_params, 0, {\"string_param\"});\n+\n+  std::string hello_world = \"hello world\";\n+  char * c_hello_world = new char[hello_world.length() + 1];\n+  std::snprintf(c_hello_world, hello_world.size() + 1, \"%s\", hello_world.c_str());\n+  c_params->params[0].parameter_values[0].string_value = c_hello_world;\n+\n+  rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, \"/foo\");\n+  const std::vector<rclcpp::Parameter> & params = map.at(\"/foo\");\n+  EXPECT_STREQ(\"string_param\", params.at(0).get_name().c_str());\n+  EXPECT_STREQ(hello_world.c_str(), params.at(0).get_value<std::string>().c_str());\n+\n+  c_params->params[0].parameter_values[0].string_value = NULL;\n+  delete[] c_hello_world;\n+  rcl_yaml_node_struct_fini(c_params);\n+}\n+\n+TEST(Test_parameter_map_from, multi_nodes_same_param_name_by_node_fqn)\n+{\n+  std::vector<std::string> node_names_keys = {\n+    \"/**\",              // index: 0\n+    \"/*\",               // index: 1\n+    \"/**/node\",         // index: 2\n+    \"/*/node\",          // index: 3\n+    \"/ns/node\"          // index: 4\n+  };\n+\n+  rcl_params_t * c_params = make_params(node_names_keys);\n+\n+  std::vector<char *> param_values;\n+  for (size_t i = 0; i < node_names_keys.size(); ++i) {\n+    make_node_params(c_params, i, {\"string_param\"});\n+    std::string hello_world = \"hello world\" + std::to_string(i);\n+    char * c_hello_world = new char[hello_world.length() + 1];\n+    std::snprintf(c_hello_world, hello_world.size() + 1, \"%s\", hello_world.c_str());\n+    c_params->params[i].parameter_values[0].string_value = c_hello_world;\n+    param_values.push_back(c_hello_world);\n+  }\n+\n+  std::unordered_map<std::string, std::vector<size_t>> node_fqn_expected = {\n+    {\"/ns/foo/another_node\", {0}},\n+    {\"/another\", {0, 1}},\n+    {\"/node\", {0, 1, 2}},\n+    {\"/another_ns/node\", {0, 2, 3}},\n+    {\"/ns/node\", {0, 2, 3, 4}},\n+  };\n+\n+  for (auto & kv : node_fqn_expected) {\n+    rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, kv.first.c_str());\n+    const std::vector<rclcpp::Parameter> & params = map.at(kv.first);\n+\n+    EXPECT_EQ(kv.second.size(), params.size());\n+    for (size_t i = 0; i < params.size(); ++i) {\n+      std::string param_value = \"hello world\" + std::to_string(kv.second[i]);\n+      EXPECT_STREQ(\"string_param\", params.at(i).get_name().c_str());\n+      EXPECT_STREQ(param_value.c_str(), params.at(i).get_value<std::string>().c_str());\n+    }\n+  }\n+\n+  for (size_t i = 0; i < node_names_keys.size(); ++i) {\n+    c_params->params[i].parameter_values[0].string_value = NULL;\n+  }\n+  for (auto c_hello_world : param_values) {\n+    delete[] c_hello_world;\n+  }\n+  rcl_yaml_node_struct_fini(c_params);\n+}\n+\n+TEST(Test_parameter_map_from, multi_nodes_diff_param_name_by_node_fqn)\n+{\n+  std::vector<std::string> node_names_keys = {\n+    \"/**\",              // index: 0\n+    \"/*\",               // index: 1\n+    \"/**/node\",         // index: 2\n+    \"/*/node\",          // index: 3\n+    \"/ns/**\",           // index: 4\n+    \"/ns/*\",            // index: 5\n+    \"/ns/**/node\",      // index: 6\n+    \"/ns/*/node\",       // index: 7\n+    \"/ns/**/a/*/node\",  // index: 8\n+    \"/ns/node\"          // index: 9\n+  };\n+\n+  rcl_params_t * c_params = make_params(node_names_keys);\n+\n+  for (size_t i = 0; i < node_names_keys.size(); ++i) {\n+    std::string param_name = \"string_param\" + std::to_string(i);\n+    make_node_params(c_params, i, {param_name});\n+  }\n+\n+  std::string hello_world = \"hello world\";\n+  char * c_hello_world = new char[hello_world.length() + 1];\n+  std::snprintf(c_hello_world, hello_world.size() + 1, \"%s\", hello_world.c_str());\n+\n+  for (size_t i = 0; i < node_names_keys.size(); ++i) {\n+    c_params->params[i].parameter_values[0].string_value = c_hello_world;\n+  }\n+\n+  std::unordered_map<std::string, std::vector<size_t>> node_fqn_expected = {\n+    {\"/ns/node\", {0, 2, 3, 4, 5, 6, 9}},\n+    {\"/node\", {0, 1, 2}},\n+    {\"/ns/foo/node\", {0, 2, 4, 6, 7}},\n+    {\"/ns/foo/a/node\", {0, 2, 4, 6}},\n+    {\"/ns/foo/a/bar/node\", {0, 2, 4, 6, 8}},\n+    {\"/ns/a/bar/node\", {0, 2, 4, 6, 8}},\n+    {\"/ns/foo/zoo/a/bar/node\", {0, 2, 4, 6, 8}},\n+  };\n+\n+  for (auto & kv : node_fqn_expected) {\n+    rclcpp::ParameterMap map = rclcpp::parameter_map_from(c_params, kv.first.c_str());\n+    const std::vector<rclcpp::Parameter> & params = map.at(kv.first);\n+    EXPECT_EQ(kv.second.size(), params.size());\n+    for (size_t i = 0; i < params.size(); ++i) {\n+      std::string param_name = \"string_param\" + std::to_string(kv.second[i]);\n+      EXPECT_STREQ(param_name.c_str(), params.at(i).get_name().c_str());\n+      EXPECT_STREQ(hello_world.c_str(), params.at(i).get_value<std::string>().c_str());\n+    }\n+  }\n+\n+  for (size_t i = 0; i < node_names_keys.size(); ++i) {\n+    c_params->params[i].parameter_values[0].string_value = NULL;\n+  }\n+  delete[] c_hello_world;\n+  rcl_yaml_node_struct_fini(c_params);\n+}"},{"role":"user","content":"+/**/foo/*/bar:\n+  node2:\n+    ros__parameters:\n+      foo: \"foo\"\n+      bar: \"bar\""},{"role":"user","content":"+/**:\n+  node2:\n+    ros__parameters:\n+      a_value: \"first\"\n+      foo: \"foo\"\n+\n+/ns:\n+  node2:\n+    ros__parameters:\n+      a_value: \"second\"\n+      bar: \"bar\"\n+\n+/*:\n+  node2:\n+    ros__parameters:\n+      a_value: \"last_one_win\""},{"role":"user","content":"+/**:\n+  ros__parameters:\n+    full_wild: \"full_wild\"\n+\n+/**:\n+  node2:\n+    ros__parameters:\n+      namespace_wild: \"namespace_wild\"\n+\n+/**/node2:\n+  ros__parameters:\n+    namespace_wild_another: \"namespace_wild_another\"\n+\n+/*:\n+  node2:\n+    ros__parameters:\n+      namespace_wild_one_star: \"namespace_wild_one_star\"\n+\n+ns:\n+  \"*\":\n+    ros__parameters:\n+      node_wild_in_ns: \"node_wild_in_ns\"\n+\n+/ns/*:\n+  ros__parameters:\n+    node_wild_in_ns_another: \"node_wild_in_ns_another\"\n+\n+ns:\n+  node2:\n+    ros__parameters:\n+      explicit_in_ns: \"explicit_in_ns\"\n+\n+\"*\":\n+  ros__parameters:\n+    node_wild_no_ns: \"node_wild_no_ns\"\n+\n+node2:\n+  ros__parameters:\n+    explicit_no_ns: \"explicit_no_ns\"\n+\n+ns:\n+  nodeX:\n+    ros__parameters:\n+      should_not_appear: \"incorrect_node_name\"\n+\n+/**/nodeX:\n+  ros__parameters:\n+    should_not_appear: \"incorrect_node_name\"\n+\n+nsX:\n+  node2:\n+    ros__parameters:\n+      should_not_appear: \"incorrect_namespace\"\n+\n+/nsX/*:\n+  ros__parameters:\n+    should_not_appear: \"incorrect_namespace\""},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+cmake_minimum_required(VERSION 3.14)\n+\n+project(rmw_security_common)\n+\n+# Default to C99\n+if(NOT CMAKE_C_STANDARD)\n+  set(CMAKE_C_STANDARD 99)\n+endif()\n+\n+\n+# Default to C++17\n+if(NOT CMAKE_CXX_STANDARD)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+endif()\n+\n+if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n+  add_compile_options(-Wall -Wextra -Wpedantic)\n+endif()\n+\n+find_package(ament_cmake REQUIRED)\n+find_package(rcutils REQUIRED)\n+find_package(rmw REQUIRED)\n+\n+ament_add_default_options()\n+ament_export_dependencies(rcutils)\n+\n+add_library(${PROJECT_NAME}_library\n+  src/security.cpp)\n+\n+set_target_properties(${PROJECT_NAME}_library\n+  PROPERTIES OUTPUT_NAME ${PROJECT_NAME})\n+target_link_libraries(${PROJECT_NAME}_library PUBLIC\n+  rcutils::rcutils\n+  rmw::rmw)\n+target_include_directories(${PROJECT_NAME}_library\n+  PUBLIC\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n+  \"$<INSTALL_INTERFACE:include/${PROJECT_NAME}>\")\n+\n+# Causes the visibility macros to use dllexport rather than dllimport,\n+# which is appropriate when building the dll but not consuming it.\n+target_compile_definitions(${PROJECT_NAME}_library\n+  PRIVATE \"RMW_SECURITY_COMMON_BUILDING_LIBRARY\")\n+\n+install(\n+  TARGETS ${PROJECT_NAME}_library EXPORT ${PROJECT_NAME}_library\n+  ARCHIVE DESTINATION lib\n+  LIBRARY DESTINATION lib\n+  RUNTIME DESTINATION bin\n+)\n+\n+# Export old-style CMake variables\n+ament_export_include_directories(\"include/${PROJECT_NAME}\")\n+ament_export_libraries(${PROJECT_NAME}_library)\n+\n+# Export modern CMake targets\n+ament_export_targets(${PROJECT_NAME}_library)\n+\n+install(\n+  DIRECTORY include/\n+  DESTINATION include/${PROJECT_NAME})\n+\n+if(BUILD_TESTING)\n+  find_package(ament_lint_auto REQUIRED)\n+  find_package(ament_cmake_gmock REQUIRED)\n+  ament_lint_auto_find_test_dependencies()\n+\n+  ament_add_gmock(test_security test/test_security.cpp)\n+  if(TARGET test_security)\n+    target_link_libraries(test_security\n+      ${PROJECT_NAME}_library\n+      rcutils::rcutils)\n+  endif()\n+endif()\n+\n+ament_package()"},{"role":"user","content":"+// Copyright 2025 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RMW_SECURITY_COMMON__SECURITY_HPP_\n+#define RMW_SECURITY_COMMON__SECURITY_HPP_\n+\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"rcutils/types/string_map.h\"\n+#include \"rmw/types.h\"\n+#include \"rmw_security_common/visibility_control.h\"\n+\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+/// Get the set of security files in a security enclave.\n+/**\n+ * This function will look through the passed in 'secure root'\n+ * for a set of required filenames that must be in the enclave.\n+ * If any of the required filenames are missing, the 'result'\n+ * will be empty and the function will return false.\n+ * If all of the required filenames are present, then this function\n+ * will fill in the 'result' map with a key-value pair of\n+ * friendy name -> filename.  If the prefix is not empty, then\n+ * the prefix will be applied to the filename.\n+ *\n+ * The friendly names that this function will currently fill in are:\n+ *   IDENTITY_CA\n+ *   CERTIFICATE\n+ *   PRIVATE_KEY\n+ *   PERMISSIONS_CA\n+ *   GOVERNANCE\n+ *   PERMISSIONS\n+ *\n+ * \\param[in]  prefix An optional prefix to apply to the filenames when storing them.\n+ * \\param[in]  secure_root The path to the security enclave to look at.\n+ * \\param[out] result The map where the friendly name -> filename pairs are stored.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or\n+ * \\return `RMW_RET_ERROR` an unexpected error occurs.\n+ */\n+RMW_SECURITY_COMMON_PUBLIC\n+rmw_ret_t get_security_files(\n+  const char * prefix,\n+  const char * secure_root,\n+  rcutils_string_map_t * result);\n+\n+/// Get the set of security files in a security enclave.\n+/**\n+ * This function will look through the passed in 'secure root'\n+ * for a set of required filenames that must be in the enclave.\n+ * If any of the required filenames are missing, the 'result'\n+ * will be empty and the function will return false.\n+ * If all of the required filenames are present, then this function\n+ * will fill in the 'result' map with a key-value pair of\n+ * friendy name -> filename.  If the prefix is not empty, then\n+ * the prefix will be applied to the filename.\n+ *\n+ * The friendly names that this function will currently fill in are:\n+ *   IDENTITY_CA\n+ *   CERTIFICATE\n+ *   PRIVATE_KEY\n+ *   PERMISSIONS_CA\n+ *   GOVERNANCE\n+ *   PERMISSIONS\n+ *\n+ * \\param[in]  supports_pkcs11 Whether the RMW has support for PKCS#11 URIs.\n+ * \\param[in]  prefix An optional prefix to apply to the filenames when storing them.\n+ * \\param[in]  secure_root The path to the security enclave to look at.\n+ * \\param[out] result The map where the friendly name -> filename pairs are stored.\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or\n+ * \\return `RMW_RET_ERROR` an unexpected error occurs.\n+ */\n+RMW_SECURITY_COMMON_PUBLIC\n+rmw_ret_t get_security_files_support_pkcs(\n+  bool supports_pkcs11,\n+  const char * prefix,\n+  const char * secure_root,\n+  rcutils_string_map_t * result);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif  // RMW_SECURITY_COMMON__SECURITY_HPP_"},{"role":"user","content":"+// Copyright 2025 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_\n+#define RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+// This logic was borrowed (then namespaced) from the examples on the gcc wiki:\n+//     https://gcc.gnu.org/wiki/Visibility\n+\n+#if defined _WIN32 || defined __CYGWIN__\n+  #ifdef __GNUC__\n+    #define RMW_SECURITY_COMMON_EXPORT __attribute__ ((dllexport))\n+    #define RMW_SECURITY_COMMON_IMPORT __attribute__ ((dllimport))\n+  #else\n+    #define RMW_SECURITY_COMMON_EXPORT __declspec(dllexport)\n+    #define RMW_SECURITY_COMMON_IMPORT __declspec(dllimport)\n+  #endif\n+  #ifdef RMW_SECURITY_COMMON_BUILDING_LIBRARY\n+    #define RMW_SECURITY_COMMON_PUBLIC RMW_SECURITY_COMMON_EXPORT\n+  #else\n+    #define RMW_SECURITY_COMMON_PUBLIC RMW_SECURITY_COMMON_IMPORT\n+  #endif\n+  #define RMW_SECURITY_COMMON_PUBLIC_TYPE RMW_SECURITY_COMMON_PUBLIC\n+  #define RMW_SECURITY_COMMON_LOCAL\n+#else\n+  #define RMW_SECURITY_COMMON_EXPORT __attribute__ ((visibility(\"default\")))\n+  #define RMW_SECURITY_COMMON_IMPORT\n+  #if __GNUC__ >= 4\n+    #define RMW_SECURITY_COMMON_PUBLIC __attribute__ ((visibility(\"default\")))\n+    #define RMW_SECURITY_COMMON_LOCAL  __attribute__ ((visibility(\"hidden\")))\n+  #else\n+    #define RMW_SECURITY_COMMON_PUBLIC\n+    #define RMW_SECURITY_COMMON_LOCAL\n+  #endif\n+  #define RMW_SECURITY_COMMON_PUBLIC_TYPE\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif  // RMW_SECURITY_COMMON__VISIBILITY_CONTROL_H_"},{"role":"user","content":"+<?xml version=\"1.0\"?>\n+<?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?>\n+<package format=\"3\">\n+  <name>rmw_security_common</name>\n+  <version>7.5.1</version>\n+  <description>Define a common rmw secutiry utils</description>\n+\n+  <maintainer email=\"alejandro@openrobotics.org\">Alejandro Hernandez Cordero</maintainer>\n+\n+  <license>Apache License 2.0</license>\n+\n+  <author email=\"alejandro@openrobotics.org\">Alejandro Hernandez Cordero</author>\n+\n+  <buildtool_depend>ament_cmake</buildtool_depend>\n+\n+  <depend>rcutils</depend>\n+  <depend>rmw</depend>\n+\n+  <test_depend>ament_cmake_gmock</test_depend>\n+  <test_depend>ament_lint_auto</test_depend>\n+  <test_depend>ament_lint_common</test_depend>\n+\n+  <export>\n+    <build_type>ament_cmake</build_type>\n+  </export>\n+</package>"},{"role":"user","content":"+// Copyright 2025 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <filesystem>\n+#include <fstream>\n+#include <functional>\n+#include <string>\n+#include <utility>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include \"rmw/error_handling.h\"\n+#include \"rmw/types.h\"\n+\n+#include \"rmw_security_common/security.hpp\"\n+\n+// Processor for security attributes with FILE URI\n+static bool process_file_uri_security_file(\n+  bool /*supports_pkcs11*/,\n+  const std::string & prefix,\n+  const std::filesystem::path & full_path,\n+  std::string & result)\n+{\n+  if (!std::filesystem::is_regular_file(full_path)) {\n+    return false;\n+  }\n+  result = prefix + full_path.generic_string();\n+  return true;\n+}\n+\n+// Processor for security attributes with PKCS#11 URI\n+static bool process_pkcs_uri_security_file(\n+  bool supports_pkcs11,\n+  const std::string & /*prefix*/,\n+  const std::filesystem::path & full_path,\n+  std::string & result)\n+{\n+  if (!supports_pkcs11) {\n+    return false;\n+  }\n+\n+  const std::string p11_prefix(\"pkcs11:\");\n+\n+  std::ifstream ifs(full_path);\n+  if (!ifs.is_open()) {\n+    return false;\n+  }\n+\n+  if (!(ifs >> result)) {\n+    return false;\n+  }\n+  if (result.find(p11_prefix) != 0) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+rmw_ret_t get_security_files(\n+  const char * prefix,\n+  const char * secure_root,\n+  rcutils_string_map_t * result)\n+{\n+  return get_security_files_support_pkcs(false, prefix, secure_root, result);\n+}\n+\n+rmw_ret_t get_security_files_support_pkcs(\n+  bool supports_pkcs11,\n+  const char * prefix,\n+  const char * secure_root,\n+  rcutils_string_map_t * result)\n+{\n+  // check arguments that could be null\n+  RCUTILS_CHECK_ARGUMENT_FOR_NULL(prefix, RMW_RET_INVALID_ARGUMENT);\n+  RCUTILS_CHECK_ARGUMENT_FOR_NULL(secure_root, RMW_RET_INVALID_ARGUMENT);\n+  RCUTILS_CHECK_ARGUMENT_FOR_NULL(result, RMW_RET_INVALID_ARGUMENT);\n+\n+  std::string prefix_std(prefix);\n+  std::string secure_root_std(secure_root);\n+\n+  using std::placeholders::_1;\n+  using std::placeholders::_2;\n+  using std::placeholders::_3;\n+  using std::placeholders::_4;\n+  using security_file_processor =\n+    std::function<bool (bool, const std::string &, const std::filesystem::path &, std::string &)>;\n+  using processor_vector =\n+    std::vector<std::pair<std::string, security_file_processor>>;\n+\n+  // Key: the security attribute\n+  // Value: ordered sequence of pairs. Each pair contains one possible file name\n+  //        for the attribute and the corresponding processor method\n+  // Pairs are ordered by priority: the first one matching is used.\n+  const std::unordered_map<std::string, processor_vector> required_files{\n+    {\"IDENTITY_CA\", {\n+        {\"identity_ca.cert.p11\", std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n+        {\"identity_ca.cert.pem\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+    {\"CERTIFICATE\", {\n+        {\"cert.p11\", std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n+        {\"cert.pem\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+    {\"PRIVATE_KEY\", {\n+        {\"key.p11\", std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n+        {\"key.pem\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+    {\"PERMISSIONS_CA\", {\n+        {\"permissions_ca.cert.p11\", std::bind(process_pkcs_uri_security_file, _1, _2, _3, _4)},\n+        {\"permissions_ca.cert.pem\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+    {\"GOVERNANCE\", {\n+        {\"governance.p7s\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+    {\"PERMISSIONS\", {\n+        {\"permissions.p7s\", std::bind(process_file_uri_security_file, _1, _2, _3, _4)}}},\n+  };\n+\n+  const std::unordered_map<std::string, std::string> optional_files{\n+    {\"CRL\", \"crl.pem\"},\n+  };\n+\n+  std::unordered_map<std::string, std::string> result_std;\n+\n+  for (const std::pair<const std::string,\n+    std::vector<std::pair<std::string, security_file_processor>>> & el : required_files)\n+  {\n+    std::string attribute_value;\n+    bool processed = false;\n+    for (auto & proc : el.second) {\n+      std::filesystem::path full_path(secure_root_std);\n+      full_path /= proc.first;\n+      if (proc.second(supports_pkcs11, prefix_std, full_path, attribute_value)) {\n+        processed = true;\n+        break;\n+      }\n+    }\n+    if (!processed) {\n+      result_std.clear();\n+      return RMW_RET_ERROR;\n+    }\n+    result_std[el.first] = attribute_value;\n+  }\n+\n+  for (const std::pair<const std::string, std::string> & el : optional_files) {\n+    std::filesystem::path full_path(secure_root_std);\n+    full_path /= el.second;\n+    if (std::filesystem::is_regular_file(full_path)) {\n+      result_std[el.first] = prefix_std + full_path.generic_string();\n+    }\n+  }\n+\n+  rmw_ret_t ret;\n+  ret = rcutils_string_map_reserve(result, result_std.size());\n+\n+  if (ret != RMW_RET_OK) {\n+    RMW_SET_ERROR_MSG(\"failed to reserve memory for the string map\");\n+    return RMW_RET_ERROR;\n+  }\n+\n+  for (const auto & [key, value] : result_std) {\n+    ret = rcutils_string_map_set(result, key.c_str(), value.c_str());\n+    if (ret != RMW_RET_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to insert value in the string map\");\n+      return RMW_RET_ERROR;\n+    }\n+  }\n+\n+  return RMW_RET_OK;\n+}"},{"role":"user","content":"+// Copyright 2025 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <array>\n+#include <cstddef>\n+#include <filesystem>\n+#include <fstream>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"rmw_security_common/security.hpp\"\n+\n+#include \"rcutils/allocator.h\"\n+\n+// Utility to write test content on required files\n+template<size_t N>\n+static void write_test_content(const std::array<std::string, N> & required_files)\n+{\n+  for (const std::string & filename : required_files) {\n+    std::filesystem::path full_path = std::filesystem::path(\"./test_folder\") / filename;\n+    std::ofstream output_buffer{full_path.generic_string()};\n+    output_buffer << \"test\";\n+    ASSERT_TRUE(std::filesystem::exists(full_path));\n+  }\n+}\n+\n+// Utility to write pkcs11 content on required files\n+template<size_t N>\n+static void write_test_pkcs11_content(const std::array<std::string, N> & pkcs11_files)\n+{\n+  for (const std::string & filename : pkcs11_files) {\n+    std::filesystem::path full_path = std::filesystem::path(\"./test_folder\") / filename;\n+    std::ofstream output_buffer{full_path.generic_string()};\n+    output_buffer << \"pkcs11://\" << filename;\n+    ASSERT_TRUE(std::filesystem::exists(full_path));\n+  }\n+}\n+\n+class test_security : public ::testing::TestWithParam<bool> {};\n+\n+TEST_P(test_security, files_exist_no_prefix)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 6> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+    std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+    std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+    std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+    std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, files_exist_with_prefix)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 6> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+    std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+    std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+    std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+    std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, file_missing)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 5> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_ERROR,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  size_t capacity = 0;\n+  ret = rcutils_string_map_get_capacity(&security_files, &capacity);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(capacity, 0UL);\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, optional_file_exist)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 7> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\", \"crl.pem\",\n+  };\n+  write_test_content(required_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+    std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+    std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+    std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+    std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  EXPECT_EQ(\n+    rcutils_string_map_get(&security_files, \"CRL\"),\n+    std::filesystem::path(\"./test_folder/crl.pem\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, wrong_pkcs11_file_ignored)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 10> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\",\n+    \"identity_ca.cert.p11\", \"cert.p11\", \"key.p11\",\n+    \"permissions_ca.cert.p11\"\n+  };\n+  write_test_content(required_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+    std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+    std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+    std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+    std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, pkcs11_support_check)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 6> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  std::array<std::string, 4> pkcs11_files = {\n+    \"identity_ca.cert.p11\", \"cert.p11\", \"key.p11\",\n+    \"permissions_ca.cert.p11\"\n+  };\n+  write_test_pkcs11_content(pkcs11_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+  if (GetParam()) {\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+      \"pkcs11://identity_ca.cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+      \"pkcs11://cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+      \"pkcs11://key.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+      \"pkcs11://permissions_ca.cert.p11\");\n+  } else {\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+      std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+      std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+      std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+      std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  }\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, only_pkcs11_present)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 2> required_files = {\n+    \"governance.p7s\", \"permissions.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  std::array<std::string, 4> pkcs11_files = {\n+    \"identity_ca.cert.p11\", \"cert.p11\", \"key.p11\",\n+    \"permissions_ca.cert.p11\"\n+  };\n+  write_test_pkcs11_content(pkcs11_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  if (GetParam()) {\n+    ASSERT_EQ(RMW_RET_OK,\n+      get_security_files_support_pkcs(\n+        GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+      \"pkcs11://identity_ca.cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+      \"pkcs11://cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+      \"pkcs11://key.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+      \"pkcs11://permissions_ca.cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+      std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+      std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+  } else {\n+    ASSERT_EQ(RMW_RET_ERROR,\n+      get_security_files_support_pkcs(\n+        GetParam(), \"\", dir.generic_string().c_str(), &security_files));\n+\n+    size_t capacity = 0;\n+    ret = rcutils_string_map_get_capacity(&security_files, &capacity);\n+    ASSERT_EQ(RMW_RET_OK, ret);\n+\n+    ASSERT_EQ(capacity, 0UL);\n+  }\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+TEST_P(test_security, pkcs11_prefix_ignored)\n+{\n+  std::filesystem::path dir = std::filesystem::path(\"./test_folder\");\n+  std::filesystem::remove_all(dir);\n+  EXPECT_TRUE(std::filesystem::create_directories(dir));\n+  EXPECT_TRUE(std::filesystem::exists(dir));\n+  EXPECT_TRUE(std::filesystem::is_directory(dir));\n+\n+  std::array<std::string, 6> required_files = {\n+    \"identity_ca.cert.pem\", \"cert.pem\", \"key.pem\",\n+    \"permissions_ca.cert.pem\", \"governance.p7s\", \"permissions.p7s\"\n+  };\n+  write_test_content(required_files);\n+\n+  std::array<std::string, 4> pkcs11_files = {\n+    \"identity_ca.cert.p11\", \"cert.p11\", \"key.p11\",\n+    \"permissions_ca.cert.p11\"\n+  };\n+  write_test_pkcs11_content(pkcs11_files);\n+\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+\n+  ASSERT_EQ(RMW_RET_OK,\n+    get_security_files_support_pkcs(\n+      GetParam(), \"file://\", dir.generic_string().c_str(), &security_files));\n+\n+  if (GetParam()) {\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+      \"pkcs11://identity_ca.cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+      \"pkcs11://cert.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+      \"pkcs11://key.p11\");\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+      \"pkcs11://permissions_ca.cert.p11\");\n+  } else {\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")),\n+      \"file://\" + std::filesystem::path(\"./test_folder/identity_ca.cert.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")),\n+      \"file://\" + std::filesystem::path(\"./test_folder/cert.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")),\n+      \"file://\" + std::filesystem::path(\"./test_folder/key.pem\").generic_string());\n+    EXPECT_EQ(\n+      std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")),\n+      \"file://\" + std::filesystem::path(\"./test_folder/permissions_ca.cert.pem\").generic_string());\n+  }\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")),\n+    \"file://\" + std::filesystem::path(\"./test_folder/governance.p7s\").generic_string());\n+  EXPECT_EQ(\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")),\n+    \"file://\" + std::filesystem::path(\"./test_folder/permissions.p7s\").generic_string());\n+\n+  ret = rcutils_string_map_fini(&security_files);\n+  ASSERT_EQ(RMW_RET_OK, ret);\n+}\n+\n+INSTANTIATE_TEST_SUITE_P(\n+  test_security,\n+  test_security,\n+  ::testing::Values(false, true),\n+  [](const testing::TestParamInfo<bool> & info) {\n+    return info.param ? \"with_pkcs11_support\" : \"with_no_pkcs11_support\";\n+  });"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#if defined(__MACH__)\n+#if defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#endif  // defined(__MACH__)\n+#endif  // defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#if !defined(__MACH__)  // Assume clock_get_time is available on OS X.\n+#if !defined(__MACH__) && !defined(__APPLE__)   // Assume clock_get_time is available on OS X."},{"role":"user","content":"-#endif  // !defined(__MACH__)\n+#endif  // !defined(__MACH__) && !defined(__APPLE__)"},{"role":"user","content":"-#if defined(__MACH__)\n+#if defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#else  // defined(__MACH__)\n+#else  // defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#endif  // defined(__MACH__)\n+#endif  // defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#if defined(__MACH__)\n+#if defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#else  // defined(__MACH__)\n+#else  // defined(__MACH__) && defined(__APPLE__)"},{"role":"user","content":"-#endif  // defined(__MACH__)\n+#endif  // defined(__MACH__) && defined(__APPLE__)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  <maintainer email=\"ivanpauno@ekumenlabs.com\">Ivan Paunovic</maintainer>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# Export rcl_logging_interface to give downstream packages access to it's headers"},{"role":"user","content":"+ament_export_dependencies(rcpputils)\n+ament_export_dependencies(rcutils)\n+ament_export_dependencies(spdlog_vendor)\n+ament_export_dependencies(spdlog)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  /// NodeT::SharedPtr Constructor\n-  template<typename NodeT>\n-  NodeInterfaces(std::shared_ptr<NodeT> node)  // NOLINT(runtime/explicit)\n-  : NodeInterfaces(node ? *node : throw std::invalid_argument(\"given node pointer is nullptr\"))\n-  {}\n-"},{"role":"user","content":"-    auto node_interfaces = NodeInterfaces<NodeBaseInterface, NodeGraphInterface>(node);\n+    auto node_interfaces = NodeInterfaces<NodeBaseInterface, NodeGraphInterface>(*node);"},{"role":"user","content":"-    some_func(node);\n+    some_func(*node);"},{"role":"user","content":"-    NodeInterfaces<NodeBaseInterface, NodeGraphInterface> ni_with_two(node);\n+    NodeInterfaces<NodeBaseInterface, NodeGraphInterface> ni_with_two(*node);"},{"role":"user","content":"-    >(node);\n+    >(*node);"},{"role":"user","content":"-    >(node);\n+    >(*node);"},{"role":"user","content":"-  auto ni = rclcpp::node_interfaces::NodeInterfaces<ALL_RCLCPP_NODE_INTERFACES>(node);\n+  auto ni = rclcpp::node_interfaces::NodeInterfaces<ALL_RCLCPP_NODE_INTERFACES>(*node);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-/// Create and return an rmw subscription.\n+/// Create a subscription and return a handle to that subscription."},{"role":"user","content":"- * \\TODO(wjwwood): add detailed documentation, adding a not about one of the\n- *   arguments for now.\n+ * This function can fail, and therefore return `NULL`, if:\n+ *   - node is not a valid non-null handle for this rmw implementation,\n+ *     as returned by `rmw_create_node()`\n+ *   - type_support is a not valid non-null message type support, as returned by\n+ *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`\n+ *   - topic_name is not a valid non-null topic name, according to\n+ *     `rmw_validate_full_topic_name()` if ROS namespace conventions apply\n+ *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies\n+ *   - subscription_options is not a valid non-null option set, such as the one\n+ *     returned by `rmw_get_default_subscription_options()`\n+ *   - memory allocation fails during subscription creation\n+ *   - an unspecified error occurs"},{"role":"user","content":"- * The argument `subscription_options` must not be nullptr.\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Yes\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>"},{"role":"user","content":"- * \\param[in] subscription_options options for configuring the subscription\n+ * \\param[in] node Handle to node with which to register this subscription\n+ * \\param[in] type_support Type support for the messages to be subscribed to\n+ * \\param[in] topic_name Name of the topic to subscribe to, often a fully qualified\n+ *   topic name unless `qos_profile` is configured to avoid ROS namespace conventions\n+ *   i.e. to create a native topic subscription\n+ * \\param[in] qos_profile QoS policies for this subscription\n+ * \\param[in] subscription_options Options for configuring this subscription\n+ * \\return rmw subscription handle, or `NULL` if there was an error"},{"role":"user","content":"+/// Finalize a given subscription handle, reclaim the resources, and deallocate the subscription\n+/// handle.\n+/**\n+ * This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`\n+ * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle\n+ * unchanged.\n+ * Otherwise, it will proceed despite errors, freeing as many resources as it can, including\n+ * the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription\n+ * handle is undefined behavior.\n+ *\n+ * \\pre Given node must be the one the subscription was registered with.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | No\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>\n+ *\n+ * \\param[in] node Handle to node with which the given subscription is registered\n+ * \\param[in] subscription Handle to subscription to be finalized\n+ * \\return `RMW_RET_OK` if successful, or\n+ * \\return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or\n+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription\n+ *   implementation identifier does not match, or\n+ * \\return `RMW_RET_ERROR` if an unexpected error occurs.\n+ */"},{"role":"user","content":"+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription\n+ *   implementation identifier does not match, or"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+# Notes on statically typed parameters\n+\n+## Introduction\n+\n+Until ROS 2 Foxy, all parameters could change type anytime, except if the user installed a parameter callback to reject a change.\n+This could generate confusing errors, for example:\n+\n+```\n+$ ros2 run demo_nodes_py listener &\n+$ ros2 param set /listener use_sim_time not_a_boolean\n+[ERROR] [1614712713.233733147] [listener]: use_sim_time parameter set to something besides a bool\n+Set parameter successful\n+$ ros2 param get /listener use_sim_time\n+String value is: not_a_boolean\n+```\n+\n+For most use cases, having static parameter types is enough.\n+This article documents some of the decisions that were made when implementing static parameter types enforcement in:\n+\n+* https://github.com/ros2/rclcpp/pull/1522\n+* https://github.com/ros2/rclpy/pull/683\n+\n+## Allowing dynamically typed parameters\n+\n+There might be some scenarios where dynamic typing is desired, so a `dynamic_typing` field was added to the [parameter descriptor](https://github.com/ros2/rcl_interfaces/blob/09b5ed93a733adb9deddc47f9a4a8c6e9f584667/rcl_interfaces/msg/ParameterDescriptor.msg#L25).\n+It defaults to `false`.\n+\n+For example:\n+\n+```cpp\n+rcl_interfaces::msg::ParameterDescriptor descriptor;\n+descriptor.dynamic_typing = true;\n+\n+node->declare_parameter(\"dynamically_typed_parameter\", rclcpp::ParameterValue{}, descriptor);\n+```\n+\n+```py\n+rcl_interfaces.msg.ParameterDescriptor descriptor;\n+descriptor.dynamic_typing = True;\n+\n+node.declare_parameter(\"dynamically_typed_parameter\", None, descriptor);\n+```\n+\n+## How is the parameter type specified?\n+\n+The parameter type will be inferred from the default value provided when declaring it.\n+\n+## Statically typed parameters when allowing undeclared parameters\n+\n+When undeclared parameters are allowed and a parameter is set without a previous declaration, the parameter will be dynamically typed.\n+This is consistent with other allowed behaviors when undeclared parameters are allowed, e.g. trying to get an undeclared parameter returns \"NOT_SET\".\n+Parameter declarations will remain special and dynamic or static typing will be used based on the parameter descriptor (default to static).\n+\n+## Declaring a parameter without a default value\n+\n+There might be cases were a default value does not make sense and the user must always provide an override.\n+In those cases, the parameter type can be specified explicitly:\n+\n+```cpp\n+// method signature\n+template<typename T>\n+Node::declare_parameter<T>(std::string name, rcl_interfaces::msg::ParameterDescriptor = rcl_interfaces::msg::ParameterDescriptor{});\n+// or alternatively\n+Node::declare_parameter(std::string name, rclcpp::ParameterType type, rcl_interfaces::msg::ParameterDescriptor = rcl_interfaces::msg::ParameterDescriptor{});\n+\n+// examples\n+node->declare_parameter<int64_t>(\"my_integer_parameter\");  // declare an integer parameter\n+node->declare_parameter(\"another_integer_parameter\", rclcpp::ParameterType::PARAMETER_INTEGER);  // another way to do the same\n+```\n+\n+```py\n+# method signature\n+Node.declare_parameter(name: str, param_type: rclpy.Parameter.Type, descriptor: rcl_interfaces.msg.ParameterDescriptor = rcl_interfaces.msg.ParameterDescriptor())\n+\n+# example\n+node.declare_parameter('my_integer_parameter', rclpy.Parameter.Type.INTEGER);  # declare an integer parameter\n+```\n+\n+If the parameter may be unused, but when used requires a parameter override, then you could conditionally declare it:\n+\n+```cpp\n+auto mode = node->declare_parameter(\"mode\", \"modeA\");  // \"mode\" parameter is an string\n+if (mode == \"modeB\") {\n+    node->declare_parameter<int64_t>(\"param_needed_when_mode_b\");  // when \"modeB\", the user must provide \"param_needed_when_mode_b\"\n+}\n+```\n+\n+## Other migration notes\n+\n+Declaring a parameter with only a name is deprecated:\n+\n+```cpp\n+node->declare_parameter(\"my_param\");  // this generates a build warning\n+```\n+\n+```py\n+node.declare_parameter(\"my_param\");  # this generates a python user warning\n+```\n+\n+Before, you could initialize a parameter with the \"NOT SET\" value (in cpp `rclcpp::ParameterValue{}`, in python `None`).\n+Now this will throw an exception in both cases:\n+\n+```cpp\n+node->declare_parameter(\"my_param\", rclcpp::ParameterValue{});  // not valid, will throw exception\n+```\n+\n+```py\n+node.declare_parameter(\"my_param\", None);  # not valid, will raise error\n+```\n+\n+## Possible improvements\n+\n+### Easier way to declare dynamically typed parameters\n+\n+Declaring a dynamically typed parameter in `rclcpp` could be considered to be a bit verbose:\n+\n+```cpp\n+rcl_interfaces::msg::ParameterDescriptor descriptor;\n+descriptor.dynamic_typing = true;\n+\n+node->declare_parameter(name, rclcpp::ParameterValue{}, descriptor);\n+```\n+\n+the following ways could be supported to make it simpler:\n+\n+```cpp\n+node->declare_parameter(name, rclcpp::PARAMETER_DYNAMIC);\n+node->declare_parameter(name, default_value, rclcpp::PARAMETER_DYNAMIC);\n+```\n+\n+or alternatively:\n+\n+```cpp\n+node->declare_parameter(name, default_value, rclcpp::ParameterDescriptor{}.dynamic_typing());\n+```\n+\n+For `rclpy`, there's already a short way to do it:\n+\n+```py\n+node.declare_parameter(name, default_value, rclpy.ParameterDescriptor(dynamic_typing=true));\n+```"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    RMW_SET_ERROR_MSG(\"expected initialized dst\");\n+    RMW_SET_ERROR_MSG(\"expected initialized src\");"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+   * If the parameter has not been initialized, then this method may throw the\n+   * rclcpp::exceptions::ParameterUninitializedException exception."},{"role":"user","content":"-   * not throw an exception, and instead return a default initialized\n-   * rclcpp::Parameter, which has a type of\n+   * not throw the rclcpp::exceptions::ParameterNotDeclaredException exception,\n+   * and instead return a default initialized rclcpp::Parameter, which has a type of"},{"role":"user","content":"+   * \\throws rclcpp::exceptions::ParameterUninitializedException if the parameter\n+   *   has not been initialized."},{"role":"user","content":"-   * Like get_parameters(), this method may throw the\n+   * Like get_parameter(const std::string &), this method may throw the"},{"role":"user","content":"-   * not allowed.\n+   * not allowed, and may throw the rclcpp::exceptions::ParameterUninitializedException exception."},{"role":"user","content":"-   * Also like get_parameters(), if undeclared parameters are allowed and the\n+   * Also like get_parameter(const std::string &), if undeclared parameters are allowed and the"},{"role":"user","content":"+   * \\throws rclcpp::exceptions::ParameterUninitializedException if any of the\n+   *   parameters have not been initialized."},{"role":"user","content":"-  std::lock_guard<std::recursive_mutex> lock(mutex_);"},{"role":"user","content":"+  std::lock_guard<std::recursive_mutex> lock(mutex_);"},{"role":"user","content":"-    auto found_parameter = parameters_.find(name);\n-    if (found_parameter != parameters_.cend()) {\n-      // found\n-      results.emplace_back(name, found_parameter->second.value);\n-    } else if (this->allow_undeclared_) {\n-      // not found, but undeclared allowed\n-      results.emplace_back(name, rclcpp::ParameterValue());\n-    } else {\n-      // not found, and undeclared are not allowed\n-      throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n-    }\n+    results.emplace_back(this->get_parameter(name));"},{"role":"user","content":"-  if (\n-    parameters_.end() != param_iter &&\n-    (param_iter->second.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n-    param_iter->second.descriptor.dynamic_typing))\n-  {\n-    return rclcpp::Parameter{name, param_iter->second.value};\n+  if (parameters_.end() != param_iter) {\n+    if (\n+      param_iter->second.value.get_type() != rclcpp::ParameterType::PARAMETER_NOT_SET ||\n+      param_iter->second.descriptor.dynamic_typing)\n+    {\n+      return rclcpp::Parameter{name, param_iter->second.value};\n+    }\n+    throw rclcpp::exceptions::ParameterUninitializedException(name);"},{"role":"user","content":"-    return rclcpp::Parameter{};\n-  } else if (parameters_.end() == param_iter) {\n-    throw rclcpp::exceptions::ParameterNotDeclaredException(name);\n+    return rclcpp::Parameter{name};"},{"role":"user","content":"-    throw rclcpp::exceptions::ParameterUninitializedException(name);\n+    throw rclcpp::exceptions::ParameterNotDeclaredException(name);"},{"role":"user","content":"+      } catch (const rclcpp::exceptions::ParameterUninitializedException & ex) {\n+        RCLCPP_DEBUG(rclcpp::get_logger(\"rclcpp\"), \"Failed to get parameters: %s\", ex.what());"},{"role":"user","content":"+    EXPECT_THROW(\n+      node->get_parameters({\"integer_override_not_given\"}),\n+      rclcpp::exceptions::ParameterUninitializedException);"},{"role":"user","content":"+\n+TEST_F(TestNode, parameter_uninitialized_exception_even_if_allow_undeclared) {\n+  rclcpp::NodeOptions no;\n+  no.allow_undeclared_parameters(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\", no);\n+  {\n+    const std::string param_name = \"integer_override_not_given\";\n+    auto param_value = node->declare_parameter(param_name, rclcpp::PARAMETER_INTEGER);\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param_value.get_type());\n+    // Throws if not set before access\n+    EXPECT_THROW(\n+      node->get_parameter(param_name),\n+      rclcpp::exceptions::ParameterUninitializedException);\n+    EXPECT_THROW(\n+      node->get_parameters({param_name}),\n+      rclcpp::exceptions::ParameterUninitializedException);\n+  }\n+}\n+\n+TEST_F(TestNode, get_parameter_with_node_allow_undeclared) {\n+  rclcpp::NodeOptions no;\n+  no.allow_undeclared_parameters(true);\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\", no);\n+  {\n+    const std::string param_name = \"allow_undeclared_param\";\n+    auto param = node->get_parameter(param_name);\n+    EXPECT_EQ(param_name, param.get_name());\n+    EXPECT_EQ(rclcpp::PARAMETER_NOT_SET, param.get_type());\n+    EXPECT_EQ(rclcpp::ParameterValue{}, param.get_parameter_value());\n+  }\n+}"},{"role":"user","content":"+  node->declare_parameter(\"baz\", rclcpp::PARAMETER_INTEGER);"},{"role":"user","content":"+  {\n+    // not throw ParameterUninitializedException while getting parameter from service\n+    // even if the parameter is not initialized in the node\n+    std::vector<std::string> names{\"baz\"};\n+    std::vector<rclcpp::Parameter> parameters = synchronous_client->get_parameters(names, 10s);\n+    ASSERT_EQ(0u, parameters.size());\n+  }\n+"},{"role":"user","content":"+  node_with_option->declare_parameter(\"baz\", rclcpp::PARAMETER_INTEGER);"},{"role":"user","content":"+  {\n+    // not throw ParameterUninitializedException while getting parameter from service\n+    // even if the parameter is not initialized in the node\n+    std::vector<std::string> names{\"baz\"};\n+    std::vector<rclcpp::Parameter> parameters = synchronous_client->get_parameters(names, 10s);\n+    ASSERT_EQ(0u, parameters.size());\n+  }\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"rviz_common/visibility_control.hpp\""},{"role":"user","content":"-class ToolManager : public QObject\n+class RVIZ_COMMON_PUBLIC ToolManager : public QObject"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-Any contribution that you make to this repository will\n-be under the Apache 2 License, as dictated by that\n-[license](http://www.apache.org/licenses/LICENSE-2.0.html):\n+# Contribution Guidelines\n+\n+The present document provides a set of guidelines to which contributors must adhere.\n+\n+- [Contribution Guidelines](#contribution-guidelines)\n+  - [Contributions Licensing](#contributions-licensing)\n+  - [Developer Certificate of Origin](#developer-certificate-of-origin)\n+\n+## Contributions Licensing\n+\n+Any contribution that you make to this repository will be under the Apache 2 License, as dictated by that [license](http://www.apache.org/licenses/LICENSE-2.0.html):"},{"role":"user","content":"+\n+## Developer Certificate of Origin\n+\n+Contributors must sign-off each commit by adding a `Signed-off-by: ...` line to commit messages to certify that they have the right to submit the code they are contributing to the project according to the [Developer Certificate of Origin (DCO) Version 1.1](https://developercertificate.org/)."},{"role":"user","content":"+The quality declarations for the packages are avaiable in QUALITY_DECLARATION.md files in the corresponding subfolders.\n+"},{"role":"user","content":"+\n+## Code coverage\n+The code coverage is tested with every commit, pull request. Results are available at [codecov](https://app.codecov.io/gh/ros2/rclc/branch/master/).\n+\n+[![codecov](https://codecov.io/gh/ros2/rclc/branch/master/graph/badge.svg?token=QzyykDh4zF)](https://codecov.io/gh/ros2/rclc)"},{"role":"user","content":"+ignore:\n+  - \"rclc_examples\"\n+  - \"rclc/test\"\n+  - \"rclc_lifecycle/test\""},{"role":"user","content":"+This document is a declaration of software quality for the `rclc` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n+# `rclc` Quality Declaration\n+\n+The package `rclc` claims to be in the **Quality Level 2** category when it is used with a **Quality Level 2** middleware.\n+\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n+## Version Policy [1]\n+\n+### Version Scheme [1.i]\n+\n+`rclc` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n+\n+### Version Stability [1.ii]\n+\n+`rclc` is at a stable version, i.e. `>= 1.0.0`.\n+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n+\n+### Public API Declaration [1.iii]\n+\n+All symbols in the installed headers are considered part of the public API.\n+\n+All installed headers are in the [`include`](./include/rclc) directory of the package, headers in any other folders are not installed and considered private.\n+\n+### API Stability Policy [1.iv]\n+\n+`rclc` will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n+\n+### ABI Stability Policy [1.v]\n+\n+`rclc` contains C code and therefore must be concerned with ABI stability and will maintain ABI stability within a ROS distribution. Because an ABI-break is considered as major version change, there will be no major releases once the ROS distribution is released.\n+\n+### API and ABI Stability Within a Released ROS Distribution [1.vi]\n+\n+`rclc` will not break API nor ABI within a released ROS distribution, i.e. no major releases once the ROS distribution is released. \n+\n+## Change Control Process [2]\n+\n+The stability of `rclc` is ensured through reviews, CI and tests.\n+The change control process can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n+\n+All changes to `rclc` occur through pull requests that are required to pass all CI tests.\n+In case of failure, only maintainers can merge the pull request, and only when there is enough evidence that the failure is unrelated to the change.\n+Additionally, all pull requests must have at least one positive review from another contributor that did not author the pull request.\n+\n+### Change Requests [2.i]\n+\n+All changes will occur through a pull request.\n+\n+### Contributor Origin [2.ii]\n+\n+This package uses [Developer Certificate of Origin (DCO)](https://developercertificate.org/) as its confirmation of contributor origin policy since version 1.0.0. More information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n+\n+### Peer Review Policy [2.iii]\n+\n+All pull requests will be peer-reviewed by at least one other contributor who did not author the pull request. Approval is required before merging.\n+\n+### Continuous Integration [2.iv]\n+\n+All pull requests must pass CI to be considered for merging, unless maintainers consider that there is enough evidence that the failure is unrelated to the changes.\n+CI testing is automatically triggered by incoming pull requests.\n+Current results can be seen [../README.md](../README.md).\n+\n+###  Documentation Policy [2.v]\n+\n+All pull requests must resolve related documentation changes before merging.\n+\n+## Documentation [3]\n+\n+### Feature Documentation [3.i]\n+\n+`rclc` features are documented in the package [README.md](README.md) and in the header files. \n+\n+### Public API Documentation [3.ii]\n+\n+`rclc` has embedded API documentation.\n+\n+### License [3.iii]\n+\n+The license for `rclc` is Apache 2.0, and a summary can be found in each source file.\n+A full copy of the license can be found [here](../LICENSE).\n+\n+### Copyright Statements [3.iv]\n+\n+The copyright holders each provide a statement of copyright in each source code file in `rclc`.\n+\n+## Testing [4]\n+\n+### Feature Testing [4.i]\n+\n+`rclc` provides tests which simulate typical usage, and they are located in the [`test` directory](test).\n+New features are required to have tests before being added as stated in [CONTRIBUTING](CONTRIBUTING.md).\n+Current results can be seen [../README.md](../README.md).\n+\n+Most features in `rclc` have corresponding tests which simulate typical usage, and they are located in the [`test`](./test) directory.\n+New features are required to have tests before being added.\n+\n+### Public API Testing [4.ii]\n+\n+Each part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n+\n+### Coverage [4.iii]\n+\n+The coverage report is available in the [../README.md](../README.md).\n+\n+`rclc` checks the coverage of every commit. Last coverage assessment can be seen in [Codecov](https://app.codecov.io/gh/ros2/rclc/commits).\n+\n+### Coverage [4.iv]\n+\n+Performance tests for `rclc` have not been implemented.\n+\n+### Linters and Static Analysis [4.v]\n+\n+`rclc` code style is enforced using [uncrustify](https://github.com/uncrustify/uncrustify).\n+Among the CI tests, there are tests that ensure that every pull request is compliant with the code style.\n+The latest CI results can be seen [../README.md](../README.md).\n+\n+`rclc` uses and passes all the standard linters and static analysis tools for a C99 package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n+\n+Results of the latest linter tests can be found in the [../README.md](../README.md)\n+\n+## Dependencies [5]\n+\n+Below are evaluations of each of `rclc`'s run-time and build-time dependencies that have been determined to influence the quality.\n+\n+It has several \"buildtool\" dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n+It also has several test dependencies, which do not affect the resulting quality of the package, because they are only used to build and run the test code.\n+\n+### Direct Runtime ROS Dependencies [5.i]\n+\n+#### `rcl`\n+\n+The `rcl` package provides the API of the common library to support implementation of language specific ROS Client Libraries.\n+\n+It is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl/blob/master/rcl/QUALITY_DECLARATION.md).\n+\n+#### `rcutils`\n+\n+The `rcutils` package provides an API which contains common utilities and data structures needed when programming in C.\n+\n+It is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcutils/blob/master/QUALITY_DECLARATION.md).\n+\n+#### `rosidl_generator_c`\n+\n+The `rosidl_generator_c` package is a core-ros package and provides an API that generates message types for C programming language.\n+\n+The quality statement for this repository is not available.\n+\n+### Optional Direct Runtime ROS Dependencies [5.ii]\n+\n+`rclc` has no optional Direct Runtime ROS dependencies that need to be considered for this declaration.\n+\n+### Direct Runtime non-ROS Dependency [5.iii]\n+\n+`rclc` has no Direct Runtime non-ROS dependencies that need to be considered for this declaration.\n+\n+## Platform Support [6]\n+\n+`rclc` supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers) for Galactic Release (i.e.: Linux amd64, Linux arm64 and Windows 10), and tests each change against all of them.\n+\n+## Security [7]\n+\n+### Vulnerability Disclosure Policy [7.i]\n+\n+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n+\n+# Current status Summary\n+\n+The chart below compares the requirements in the REP-2004 with the current state of the `rclc` package.\n+\n+|Number| Requirement| Current state |\n+|--|--|--|\n+|1| **Version policy** |---|\n+|1.i|Version Policy available | Γ£ô |\n+|1.ii|Stable version |Γ£ô|\n+|1.iii|Declared public API|Γ£ô|\n+|1.iv|API stability policy|Γ£ô|\n+|1.v|ABI stability policy|Γ£ô|\n+|1.vi|API/ABI stable within ros distribution|Γ£ô|\n+|2| **Change control process** |---|\n+|2.i| All changes occur on change request | Γ£ô|\n+|2.ii| Contributor origin (DCO, CLA, etc) | Γ£ô|\n+|2.iii| Peer review policy | Γ£ô |\n+|2.iv| CI policy for change requests | Γ£ô |\n+|2.v| Documentation policy for change requests | Γ£ô |\n+|3| **Documentation** | --- |\n+|3.i| Per feature documentation | Γ£ô |\n+|3.ii| Per public API item documentation | Γ£ô |\n+|3.iii| Declared License(s) | Γ£ô |\n+|3.iv| Copyright in source files| Γ£ô |\n+|3.v.a| Quality declaration linked to README | Γ£ô |\n+|3.v.b| Centralized declaration available for peer review |Γ£ô|\n+|4| Testing | --- |\n+|4.i| Feature items tests | Γ£ô |\n+|4.ii| Public API tests | Γ£ô |\n+|4.iii.a| Using coverage | Γ£ô |\n+|4.iii.a| Coverage policy | Γ£ô |\n+|4.iv.a| Performance tests (if applicable) | x |\n+|4.iv.b| Performance tests policy| x |\n+|4.v.a| Code style enforcement (linters)| Γ£ô |\n+|4.v.b| Use of static analysis tools | Γ£ô |\n+|5| Dependencies | --- |\n+|5.i| Must not have ROS lower level dependencies | Γ£ô |\n+|5.ii| Optional ROS lower level dependencies| Γ£ô |\n+|5.iii| Justifies quality use of non-ROS dependencies |Γ£ô|\n+|6| Platform support | --- |\n+|6.i| Support targets Tier1 ROS platforms| Γ£ô |\n+|7| Security | --- |\n+|7.i| Vulnerability Disclosure Policy | Γ£ô |"},{"role":"user","content":"+The quality declaration is available in [QUALITY_DECLARATION.md](QUALITY_DECLARATION.md).\n+"},{"role":"user","content":"+This document is a declaration of software quality for the `rclc_lifecycle` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n+# `rclc_lifecycle` Quality Declaration\n+\n+The package `rclc_lifecycle` claims to be in the **Quality Level 2** category when it is used with a **Quality Level 2** middleware.\n+\n+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Quality Categories in REP-2004](https://www.ros.org/reps/rep-2004.html).\n+\n+## Version Policy [1]\n+\n+### Version Scheme [1.i]\n+\n+`rclc_lifecycle` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).\n+\n+### Version Stability [1.ii]\n+\n+`rclc_lifecycle` is at a stable version, i.e. `>= 1.0.0`.\n+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).\n+\n+### Public API Declaration [1.iii]\n+\n+All symbols in the installed headers are considered part of the public API.\n+\n+All installed headers are in the [`include`](./include/rclc_lifecycle) directory of the package, headers in any other folders are not installed and considered private.\n+\n+### API Stability Policy [1.iv]\n+\n+`rclc_lifecycle` will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.\n+\n+### ABI Stability Policy [1.v]\n+\n+`rclc_lifecycle` contains C code and therefore must be concerned with ABI stability and will maintain ABI stability within a ROS distribution. Because an ABI-break is considered as major version change, there will be no major releases once the ROS distribution is released.\n+\n+### API and ABI Stability Within a Released ROS Distribution [1.vi]\n+\n+`rclc_lifecycle` will not break API nor ABI within a released ROS distribution, i.e. no major releases once the ROS distribution is released. \n+\n+## Change Control Process [2]\n+\n+The stability of `rclc_lifecycle` is ensured through reviews, CI and tests.\n+The change control process can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n+\n+All changes to `rclc_lifecycle` occur through pull requests that are required to pass all CI tests.\n+In case of failure, only maintainers can merge the pull request, and only when there is enough evidence that the failure is unrelated to the change.\n+Additionally, all pull requests must have at least one positive review from another contributor that did not author the pull request.\n+\n+### Change Requests [2.i]\n+\n+All changes will occur through a pull request.\n+\n+### Contributor Origin [2.ii]\n+\n+This package uses [Developer Certificate of Origin (DCO)](https://developercertificate.org/) as its confirmation of contributor origin policy since version 1.0.0. More information can be found in [CONTRIBUTING](../CONTRIBUTING.md).\n+\n+### Peer Review Policy [2.iii]\n+\n+All pull requests will be peer-reviewed by at least one other contributor who did not author the pull request. Approval is required before merging.\n+\n+### Continuous Integration [2.iv]\n+\n+All pull requests must pass CI to be considered for merging, unless maintainers consider that there is enough evidence that the failure is unrelated to the changes.\n+CI testing is automatically triggered by incoming pull requests.\n+Current results can be seen [../README.md](../README.md).\n+\n+###  Documentation Policy [2.v]\n+\n+All pull requests must resolve related documentation changes before merging.\n+\n+## Documentation [3]\n+\n+### Feature Documentation [3.i]\n+\n+`rclc_lifecycle` features are documented in the package [README.md](README.md) and in the header files. \n+\n+### Public API Documentation [3.ii]\n+\n+`rclc_lifecycle` has embedded API documentation.\n+\n+New additions to the public API require documentation before being added.\n+\n+### License [3.iii]\n+\n+The license for `rclc_lifecycle` is Apache 2.0, and a summary can be found in each source file.\n+A full copy of the license can be found [here](../LICENSE).\n+\n+### Copyright Statements [3.iv]\n+\n+The copyright holders each provide a statement of copyright in each source code file in `rclc_lifecycle`.\n+\n+## Testing [4]\n+\n+### Feature Testing [4.i]\n+\n+`rclc_lifecycle` provides tests which simulate typical usage, and they are located in the [`test` directory](test).\n+New features are required to have tests before being added as stated in [CONTRIBUTING](CONTRIBUTING.md).\n+Current results can be seen [../README.md](../README.md).\n+\n+Most features in `rclc_lifecycle` have corresponding tests which simulate typical usage, and they are located in the [`test`](./test) directory.\n+New features are required to have tests before being added.\n+\n+### Public API Testing [4.ii]\n+\n+Each part of the public API has tests, and new additions or changes to the public API require tests before being added. The tests aim to cover both typical usage and corner cases, but are quantified by contributing to code coverage.\n+\n+### Coverage [4.iii]\n+\n+The coverage report is available in the [../README.md](../README.md).\n+\n+`rclc_lifecycle` checks the coverage of every commit. Last coverage assessment can be seen in [Codecov](https://app.codecov.io/gh/ros2/rclc_lifecycle/commits).\n+\n+### Coverage [4.iv]\n+\n+Performance tests for `rclc_lifecycle` have not been implemented.\n+\n+### Linters and Static Analysis [4.v]\n+\n+`rclc_lifecycle` code style is enforced using [uncrustify](https://github.com/uncrustify/uncrustify).\n+Among the CI tests, there are tests that ensure that every pull request is compliant with the code style.\n+The latest CI results can be seen [../README.md](../README.md).\n+\n+`rclc_lifecycle` uses and passes all the standard linters and static analysis tools for a C99 package as described in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#linters-and-static-analysis).\n+\n+Results of the latest linter tests can be found in the [../README.md](../README.md)\n+\n+## Dependencies [5]\n+\n+Below are evaluations of each of `rclc_lifecycle`'s run-time and build-time dependencies that have been determined to influence the quality.\n+\n+It has several \"buildtool\" dependencies, which do not affect the resulting quality of the package, because they do not contribute to the public library API.\n+It also has several test dependencies, which do not affect the resulting quality of the package, because they are only used to build and run the test code.\n+\n+### Direct Runtime ROS Dependencies [5.i]\n+\n+#### `rclc`\n+\n+The `rcl` package provides the API of the C programming language based on rcl.\n+\n+It is **Quality Level 2**, see its [Quality Declaration document](https://github.com/ros2/rclc/blob/master/rclc/QUALITY_DECLARATION.md).\n+\n+#### `rcl_lifecycle`\n+\n+The `rcl_lifecycle` package provides functionality for ROS 2 lifecycle nodes in C.\n+\n+It is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl/blob/master/rcl_lifecycle/QUALITY_DECLARATION.md).\n+\n+#### `lifecycle_msgs`\n+\n+The `lifecycle_msgs` contains message and service definitions for managing lifecycle nodes. These messages and services form a standardized interface for transitioning these managed nodes through a known state-machine.\n+\n+It is **Quality Level 1**, see its [Quality Declaration document](https://github.com/ros2/rcl_interfaces/blob/master/lifecycle_msgs/QUALITY_DECLARATION.md).\n+\n+\n+\n+### Optional Direct Runtime ROS Dependencies [5.ii]\n+\n+`rclc_lifecycle` has no optional Direct Runtime ROS dependencies that need to be considered for this declaration.\n+\n+### Direct Runtime non-ROS Dependency [5.iii]\n+\n+`rclc_lifecycle` has no Direct Runtime non-ROS dependencies that need to be considered for this declaration.\n+\n+## Platform Support [6]\n+\n+`rclc_lifecycle` supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers) for Galactic Release (i.e.: Linux amd64, Linux arm64 and Windows 10), and tests each change against all of them.\n+\n+## Security [7]\n+\n+### Vulnerability Disclosure Policy [7.i]\n+\n+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).\n+\n+# Current status Summary\n+\n+The chart below compares the requirements in the REP-2004 with the current state of the `rclc_lifecycle` package.\n+\n+|Number| Requirement| Current state |\n+|--|--|--|\n+|1| **Version policy** |---|\n+|1.i|Version Policy available | Γ£ô |\n+|1.ii|Stable version |Γ£ô|\n+|1.iii|Declared public API|Γ£ô|\n+|1.iv|API stability policy|Γ£ô|\n+|1.v|ABI stability policy|Γ£ô|\n+|1.vi|API/ABI stable within ros distribution|Γ£ô|\n+|2| **Change control process** |---|\n+|2.i| All changes occur on change request | Γ£ô|\n+|2.ii| Contributor origin (DCO, CLA, etc) | Γ£ô|\n+|2.iii| Peer review policy | Γ£ô |\n+|2.iv| CI policy for change requests | Γ£ô |\n+|2.v| Documentation policy for change requests | Γ£ô |\n+|3| **Documentation** | --- |\n+|3.i| Per feature documentation | Γ£ô |\n+|3.ii| Per public API item documentation | Γ£ô |\n+|3.iii| Declared License(s) | Γ£ô |\n+|3.iv| Copyright in source files| Γ£ô |\n+|3.v.a| Quality declaration linked to README | Γ£ô |\n+|3.v.b| Centralized declaration available for peer review |Γ£ô|\n+|4| Testing | --- |\n+|4.i| Feature items tests | Γ£ô |\n+|4.ii| Public API tests | Γ£ô |\n+|4.iii.a| Using coverage | Γ£ô |\n+|4.iii.a| Coverage policy | Γ£ô |\n+|4.iv.a| Performance tests (if applicable) | x |\n+|4.iv.b| Performance tests policy| x |\n+|4.v.a| Code style enforcement (linters)| Γ£ô |\n+|4.v.b| Use of static analysis tools | Γ£ô |\n+|5| Dependencies | --- |\n+|5.i| Must not have ROS lower level dependencies | Γ£ô |\n+|5.ii| Optional ROS lower level dependencies| Γ£ô |\n+|5.iii| Justifies quality use of non-ROS dependencies |Γ£ô|\n+|6| Platform support | --- |\n+|6.i| Support targets Tier1 ROS platforms| Γ£ô |\n+|7| Security | --- |\n+|7.i| Vulnerability Disclosure Policy | Γ£ô |"},{"role":"user","content":"+The quality declaration is available in [QUALITY_DECLARATION.md](QUALITY_DECLARATION.md)."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  const dds_time_t tstamp = dds_time();\n+  TRACETOOLS_TRACEPOINT(rmw_publish, (const void *)publisher, serialized_message, tstamp);"},{"role":"user","content":"+  d->timestamp.v = tstamp;\n+  d->statusinfo = 0;"},{"role":"user","content":"-  const bool ok = (dds_writecdr(pub->enth, d) >= 0);\n+  const bool ok = (dds_forwardcdr(pub->enth, d) >= 0);"},{"role":"user","content":"+          TRACETOOLS_TRACEPOINT(\n+            rmw_take,\n+            static_cast<const void *>(subscription),\n+            static_cast<const void *>(serialized_message),\n+            (message_info ? message_info->source_timestamp : 0LL),\n+            *taken);"},{"role":"user","content":"+          TRACETOOLS_TRACEPOINT(\n+            rmw_take,\n+            static_cast<const void *>(subscription),\n+            static_cast<const void *>(serialized_message),\n+            (message_info ? message_info->source_timestamp : 0LL),\n+            *taken);"},{"role":"user","content":"+        TRACETOOLS_TRACEPOINT(\n+          rmw_take,\n+          static_cast<const void *>(subscription),\n+          static_cast<const void *>(serialized_message),\n+          (message_info ? message_info->source_timestamp : 0LL),\n+          *taken);"},{"role":"user","content":"+  TRACETOOLS_TRACEPOINT(\n+    rmw_take,\n+    static_cast<const void *>(subscription),\n+    static_cast<const void *>(serialized_message),\n+    0LL,\n+    *taken);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    rosout_qos_profile: Optional[Union[QoSProfile, int]] = qos_profile_rosout_default,\n+    rosout_qos_profile: Union[QoSProfile, int] = qos_profile_rosout_default,"},{"role":"user","content":"-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n+        action_type: Type[Action],"},{"role":"user","content":"-            self._client_handle = _rclpy.ActionClient(\n-                node.handle,\n-                action_type,\n-                action_name,\n-                goal_service_qos_profile.get_c_qos_profile(),\n-                result_service_qos_profile.get_c_qos_profile(),\n-                cancel_service_qos_profile.get_c_qos_profile(),\n-                feedback_sub_qos_profile.get_c_qos_profile(),\n-                status_sub_qos_profile.get_c_qos_profile()\n-            )\n+            self._client_handle: '_rclpy.ActionClient[GoalT, ResultT, FeedbackT]' =  \\\n+                _rclpy.ActionClient(\n+                    node.handle,\n+                    action_type,\n+                    action_name,\n+                    goal_service_qos_profile.get_c_qos_profile(),\n+                    result_service_qos_profile.get_c_qos_profile(),\n+                    cancel_service_qos_profile.get_c_qos_profile(),\n+                    feedback_sub_qos_profile.get_c_qos_profile(),\n+                    status_sub_qos_profile.get_c_qos_profile()\n+                )"},{"role":"user","content":"+from typing_extensions import TypeAlias"},{"role":"user","content":"-    from typing_extensions import TypeAlias\n-"},{"role":"user","content":"-    ServerGoalHandleDict: 'TypeAlias' = Dict[str, object]\n+    ServerGoalHandleDict: TypeAlias = Dict[str, object]"},{"role":"user","content":"-GoalEvent = _rclpy.GoalEvent\n+GoalEvent: TypeAlias = _rclpy.GoalEvent"},{"role":"user","content":"-        action_type: Type[Action[GoalT, ResultT, FeedbackT]],\n+        action_type: Type[Action],"},{"role":"user","content":"-            self._handle = _rclpy.ActionServer(\n-                node.handle,\n-                node.get_clock().handle,\n-                action_type,\n-                action_name,\n-                goal_service_qos_profile.get_c_qos_profile(),\n-                result_service_qos_profile.get_c_qos_profile(),\n-                cancel_service_qos_profile.get_c_qos_profile(),\n-                feedback_pub_qos_profile.get_c_qos_profile(),\n-                status_pub_qos_profile.get_c_qos_profile(),\n-                result_timeout,\n-            )\n+            self._handle: '_rclpy.ActionServer[GoalT, ResultT, FeedbackT]' = \\\n+                _rclpy.ActionServer(\n+                    node.handle,\n+                    node.get_clock().handle,\n+                    action_type,\n+                    action_name,\n+                    goal_service_qos_profile.get_c_qos_profile(),\n+                    result_service_qos_profile.get_c_qos_profile(),\n+                    cancel_service_qos_profile.get_c_qos_profile(),\n+                    feedback_pub_qos_profile.get_c_qos_profile(),\n+                    status_pub_qos_profile.get_c_qos_profile(),\n+                    result_timeout,\n+                )"},{"role":"user","content":"-    def action_type(self) -> Type[Action[GoalT, ResultT, FeedbackT]]:\n+    def action_type(self) -> Type[Action]:"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv],"},{"role":"user","content":"-    def __init__(self, node: Node, srv_type: type[Srv[SrvRequestT, SrvResponseT]],\n+    def __init__(self, node: Node, srv_type: type[Srv],"},{"role":"user","content":"-    def __init__(self, node: Node, pysrv_type: type[Srv[SrvRequestT, SrvResponseT]],\n+    def __init__(self, node: Node, pysrv_type: type[Srv],"},{"role":"user","content":"-                 enable_rosout: bool) -> None: ...\n+                 enable: bool, rosout_qos_profile: rmw_qos_profile_t) -> None: ..."},{"role":"user","content":"-            pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n+            pyaction_type: type[Action],"},{"role":"user","content":"-        pyaction_type: type[Action[GoalT, ResultT, FeedbackT]],\n+        pyaction_type: type[Action],"},{"role":"user","content":"-        rosout_qos_profile: Optional[Union[QoSProfile, int]] = qos_profile_rosout_default,\n+        rosout_qos_profile: Union[QoSProfile, int] = qos_profile_rosout_default,"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv],"},{"role":"user","content":"-                client_impl = _rclpy.Client(\n+                client_impl: '_rclpy.Client[SrvRequestT, SrvResponseT]' = _rclpy.Client("},{"role":"user","content":"-        client = Client(\n+        client: Client[SrvRequestT, SrvResponseT] = Client("},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv],"},{"role":"user","content":"-                service_impl = _rclpy.Service(\n+                service_impl: '_rclpy.Service[SrvRequestT, SrvResponseT]' = _rclpy.Service("},{"role":"user","content":"+from rclpy.client import Client"},{"role":"user","content":"-        self._get_parameter_client = self.node.create_client(\n+        self._get_parameter_client: Client[GetParameters.Request,\n+                                           GetParameters.Response] = self.node.create_client("},{"role":"user","content":"-        self._list_parameter_client = self.node.create_client(\n+        self._list_parameter_client: Client[ListParameters.Request,\n+                                            ListParameters.Response] = self.node.create_client("},{"role":"user","content":"-        self._set_parameter_client = self.node.create_client(\n+        self._set_parameter_client: Client[SetParameters.Request,\n+                                           SetParameters.Response] = self.node.create_client("},{"role":"user","content":"-        self._get_parameter_types_client = self.node.create_client(\n+        self._get_parameter_types_client: Client[GetParameterTypes.Request,\n+                                                 GetParameterTypes.Response] = \\\n+            self.node.create_client("},{"role":"user","content":"-        self._describe_parameters_client = self.node.create_client(\n+        self._describe_parameters_client: Client[DescribeParameters.Request,\n+                                                 DescribeParameters.Response] = \\\n+            self.node.create_client("},{"role":"user","content":"-        self._set_parameters_atomically_client = self.node.create_client(\n+        self._set_parameters_atomically_client: Client[SetParametersAtomically.Request,\n+                                                       SetParametersAtomically.Response] = \\\n+            self.node.create_client("},{"role":"user","content":"-        callback: Optional[Callable[[ListParameters.Response], None]] = None\n+        callback: Optional[Callable[[Future[ListParameters.Response]], None]] = None"},{"role":"user","content":"-                       callback: Optional[Callable[[GetParameters.Response], None]] = None\n+                       callback: Optional[Callable[[Future[GetParameters.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n+        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[DescribeParameters.Response], None]] = None\n+        callback: Optional[Callable[[Future[DescribeParameters.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[GetParameterTypes.Response], None]] = None\n+        callback: Optional[Callable[[Future[GetParameterTypes.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[SetParametersAtomically.Response], None]] = None\n+        callback: Optional[Callable[[Future[SetParametersAtomically.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n+        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n+        callback: Optional[Callable[[Future[SetParameters.Response]], None]] = None"},{"role":"user","content":"-        callback: Optional[Callable[[SetParameters.Response], None]] = None\n-    ) -> Future[SetParameters.Response]:\n+        callback: Optional[Callable[[Future[SetParametersAtomically.Response]], None]] = None\n+    ) -> Future[SetParametersAtomically.Response]:"},{"role":"user","content":"-        will be of type ``rcl_interfaces.srv.SetParameters.Response``.\n+        will be of type ``rcl_interfaces.srv.SetParametersAtomically.Response``."},{"role":"user","content":"-from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple\n+from typing import Callable, Dict, Iterable, List, Optional, Tuple"},{"role":"user","content":"+from rcl_interfaces.msg import Parameter as ParameterMsg"},{"role":"user","content":"-from rclpy.parameter import Parameter"},{"role":"user","content":"-        callback: Callable[[Parameter[Any]], None],\n+        callback: Callable[[ParameterMsg], None],"},{"role":"user","content":"-            callback: Callable[[Parameter[Any]], None],\n+            callback: Callable[[ParameterMsg], None],"},{"role":"user","content":"-    ) -> Optional[Parameter[Any]]:\n+    ) -> Optional[ParameterMsg]:"},{"role":"user","content":"-    def get_parameters_from_event(event: ParameterEvent) -> Iterable[Parameter[Any]]:\n+    def get_parameters_from_event(event: ParameterEvent) -> Iterable[ParameterMsg]:"},{"role":"user","content":"-        callback: Callable[[Parameter[Any]], None],\n+        callback: Callable[[ParameterMsg], None],"},{"role":"user","content":"-        srv_type: Type[Srv[SrvRequestT, SrvResponseT]],\n+        srv_type: Type[Srv],"},{"role":"user","content":"-from typing import Any, ClassVar, Iterable, Optional, Protocol, Type, TypeVar, Union\n+from typing import Any, ClassVar, Optional, Protocol, Type, TypeVar, Union"},{"role":"user","content":"-\n-from action_msgs.msg._goal_status_array import GoalStatusArray\n-from action_msgs.srv._cancel_goal import CancelGoal"},{"role":"user","content":"-from service_msgs.msg._service_event_info import ServiceEventInfo\n+from service_msgs.msg import ServiceEventInfo"},{"role":"user","content":"-class EventMessage(Msg, Protocol[SrvRequestT, SrvResponseT]):\n+class EventMessage(Msg, Protocol):"},{"role":"user","content":"-    request: Iterable[SrvRequestT]\n-    response: Iterable[SrvResponseT]"},{"role":"user","content":"-class Srv(Protocol[SrvRequestT, SrvResponseT], metaclass=CommonMsgSrvMetaClass):\n+class Srv(Protocol, metaclass=CommonMsgSrvMetaClass):"},{"role":"user","content":"-    Request: Type[SrvRequestT]\n-    Response: Type[SrvResponseT]\n-    Event: Type[EventMessage[SrvRequestT, SrvResponseT]]\n+    pass\n+    # Request: ClassVar[Type[Any]]\n+    # Response: ClassVar[Type[Any]]\n+    # Event: ClassVar[Type[Any]]"},{"role":"user","content":"-SendGoalService: TypeAlias = Srv[SendGoalServiceRequest[GoalT], SendGoalServiceResponse]\n+SendGoalService: TypeAlias = Srv"},{"role":"user","content":"-GetResultService: TypeAlias = Srv[GetResultServiceRequest, GetResultServiceResponse[ResultT]]\n+GetResultService: TypeAlias = Srv"},{"role":"user","content":"-class Impl(Protocol[GoalT, ResultT, FeedbackT]):\n-\n-    SendGoalService: Type[SendGoalService[GoalT]]\n-    GetResultService: Type[GetResultService[ResultT]]\n-    FeedbackMessage: Type[FeedbackMessage[FeedbackT]]\n-    CancelGoalService: ClassVar[Type[CancelGoal]]\n-    GoalStatusMessage: ClassVar[Type[GoalStatusArray]]\n-\n+class Action(Protocol, metaclass=CommonMsgSrvMetaClass):\n+    pass\n+    # Goal: ClassVar[Type[Any]]\n+    # Result: ClassVar[Type[Any]]\n+    # Feedback: ClassVar[Type[Any]]"},{"role":"user","content":"-class Action(Protocol[GoalT,\n-                      ResultT,\n-                      FeedbackT],\n-             metaclass=CommonMsgSrvMetaClass):\n-    Goal: Type[GoalT]\n-    Result: Type[ResultT]\n-    Feedback: Type[FeedbackT]\n+    # class Impl(Protocol):"},{"role":"user","content":"-    Impl: Type[Impl[GoalT, ResultT, FeedbackT]]\n+    #     SendGoalService: ClassVar[Type[Any]]\n+    #     GetResultService: ClassVar[Type[Any]]\n+    #     FeedbackMessage: ClassVar[Type[Any]]\n+    #     CancelGoalService: ClassVar[Type[CancelGoal]]\n+    #     GoalStatusMessage: ClassVar[Type[GoalStatusArray]]"},{"role":"user","content":"-SrvT = TypeVar('SrvT', bound=Srv[Any, Any])\n-ActionT = TypeVar('ActionT', bound=Action[Any, Any, Any])\n+SrvT = TypeVar('SrvT', bound=Srv)\n+ActionT = TypeVar('ActionT', bound=Action)"},{"role":"user","content":"-def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv[Any, Any],\n-                                                       Action[Any, Any, Any]]]) -> None:\n+def check_for_type_support(msg_or_srv_type: Type[Union[Msg, Srv, Action]]) -> None:"},{"role":"user","content":"-def check_is_valid_srv_type(srv_type: Type[Srv[Any, Any]]) -> None:\n+def check_is_valid_srv_type(srv_type: Type[Srv]) -> None:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+RMW_INTERFACE_FN(\n+  rmw_subscription_set_content_filter,\n+  rmw_ret_t, RMW_RET_ERROR,\n+  2, ARG_TYPES(\n+    rmw_subscription_t *, const rmw_subscription_content_filter_options_t *))\n+\n+RMW_INTERFACE_FN(\n+  rmw_subscription_get_content_filter,\n+  rmw_ret_t, RMW_RET_ERROR,\n+  3, ARG_TYPES(\n+    const rmw_subscription_t *, rcutils_allocator_t *,\n+    rmw_subscription_content_filter_options_t *))\n+"},{"role":"user","content":"+  GET_SYMBOL(rmw_subscription_set_content_filter)\n+  GET_SYMBOL(rmw_subscription_get_content_filter)"},{"role":"user","content":"+  symbol_rmw_subscription_set_content_filter = nullptr;\n+  symbol_rmw_subscription_get_content_filter = nullptr;"},{"role":"user","content":"+#include <chrono>\n+#include <thread>\n+"},{"role":"user","content":"+#include \"rmw/subscription_content_filter_options.h\""},{"role":"user","content":"+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), no_content_filter_get) {\n+  rmw_subscription_content_filter_options_t options;\n+  auto allocator = rcutils_get_default_allocator();\n+  rmw_ret_t ret = rmw_subscription_get_content_filter(sub, &allocator, &options);\n+  EXPECT_NE(RMW_RET_OK, ret);\n+}\n+\n+TEST_F(CLASSNAME(TestSubscriptionUse, RMW_IMPLEMENTATION), no_content_filter_set) {\n+  rmw_ret_t ret;\n+  bool taken = false;\n+\n+  // Create publisher\n+  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n+  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, &qos_profile, &pub_options);\n+  ASSERT_NE(nullptr, pub) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) << rmw_get_error_string().str;\n+  });\n+\n+  size_t subscription_count = 0u;\n+  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n+    ret = rmw_publisher_count_matched_subscriptions(pub, &subscription_count);\n+    if (RMW_RET_OK == ret && 1u == subscription_count) {  // Early return on failure.\n+      break;\n+    }\n+  }\n+\n+  // Publish message with float (3.14159) from publisher to subscription\n+  test_msgs__msg__BasicTypes original_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&original_message));\n+  original_message.float32_value = 3.14159f;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__msg__BasicTypes__fini(&original_message);\n+  });\n+\n+  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n+  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n+\n+  ret = rmw_publish(pub, &original_message, null_allocation_p);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  // expect to get message because no content filter set\n+  {\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+\n+    test_msgs__msg__BasicTypes output_message{};\n+    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      test_msgs__msg__BasicTypes__fini(&output_message);\n+    });\n+\n+    ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+    // whatever the cft is supported or not\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    EXPECT_TRUE(taken);\n+    EXPECT_EQ(original_message, output_message);\n+  }\n+\n+  // set content filter with 3.14\n+  rmw_subscription_content_filter_options_t options =\n+    rmw_get_zero_initialized_content_filter_options();\n+  auto allocator = rcutils_get_default_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+      \"float32_value=3.14\",\n+      0,\n+      nullptr,\n+      &allocator,\n+      &options));\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_content_filter_options_fini(&options, &allocator));\n+  });\n+\n+  ret = rmw_subscription_set_content_filter(sub, &options);\n+  if (ret != RMW_RET_UNSUPPORTED) {\n+    ASSERT_EQ(RMW_RET_OK, ret);\n+    // waiting to allow for filter propagation\n+    std::this_thread::sleep_for(std::chrono::seconds(1));\n+    ret = rmw_publish(pub, &original_message, null_allocation_p);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_TIMEOUT, ret) << rmw_get_error_string().str;\n+    ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n+\n+    // content filter subscription with 3.14 that is not equal with 3.14159\n+    {\n+      test_msgs__msg__BasicTypes output_message{};\n+      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+      {\n+        test_msgs__msg__BasicTypes__fini(&output_message);\n+      });\n+\n+      ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+      EXPECT_FALSE(taken);\n+    }\n+  }\n+}\n+"},{"role":"user","content":"+\n+class CLASSNAME (TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION)\n+  : public CLASSNAME(TestSubscription, RMW_IMPLEMENTATION)\n+{\n+protected:\n+  using Base = CLASSNAME(TestSubscription, RMW_IMPLEMENTATION);\n+\n+  void SetUp() override\n+  {\n+    Base::SetUp();\n+    // Tighten QoS policies to force mismatch.\n+    qos_profile.reliability = RMW_QOS_POLICY_RELIABILITY_RELIABLE;\n+    rmw_subscription_options_t options = rmw_get_default_subscription_options();\n+\n+    // Create subscription with content filter\n+    auto allocator = rcutils_get_default_allocator();\n+\n+    rmw_subscription_content_filter_options_t * content_filter_options =\n+      static_cast<rmw_subscription_content_filter_options_t *>(\n+      allocator.allocate(\n+        sizeof(rmw_subscription_content_filter_options_t), allocator.state));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      allocator.deallocate(content_filter_options, allocator.state);\n+    });\n+    *content_filter_options = rmw_get_zero_initialized_content_filter_options();\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters,\n+        &allocator,\n+        content_filter_options));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(content_filter_options, &allocator));\n+    });\n+    options.content_filter_options = content_filter_options;\n+\n+    sub = rmw_create_subscription(node, ts, topic_name, &qos_profile, &options);\n+    ASSERT_NE(nullptr, sub) << rmw_get_error_string().str;\n+  }\n+\n+  void TearDown() override\n+  {\n+    rmw_ret_t ret = rmw_destroy_subscription(node, sub);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+    Base::TearDown();\n+  }\n+\n+  rmw_subscription_t * sub{nullptr};\n+  const char * const topic_name = \"/test\";\n+  const rosidl_message_type_support_t * ts{\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes)};\n+  rmw_qos_profile_t qos_profile{rmw_qos_profile_default};\n+  const char * filter_expression = \"float32_value=%0\";\n+  enum { expression_parameters_count = 1 };\n+  const char * expression_parameters[expression_parameters_count] = {\n+    \"3.14159\"\n+  };\n+  const char * expression_parameters_2[expression_parameters_count] = {\n+    \"3.14\"\n+  };\n+};\n+\n+TEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), get_content_filter) {\n+  rmw_subscription_content_filter_options_t options;\n+  auto allocator = rcutils_get_default_allocator();\n+  rmw_ret_t ret = rmw_subscription_get_content_filter(sub, &allocator, &options);\n+  if (sub->is_cft_enabled) {\n+    EXPECT_EQ(RMW_RET_OK, ret);\n+    EXPECT_STREQ(options.filter_expression, filter_expression);\n+    ASSERT_EQ(expression_parameters_count, options.expression_parameters.size);\n+    for (size_t i = 0; i < options.expression_parameters.size; ++i) {\n+      EXPECT_STREQ(\n+        options.expression_parameters.data[i],\n+        expression_parameters[i]);\n+    }\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_content_filter_options_fini(&options, &allocator));\n+  } else {\n+    EXPECT_EQ(RMW_RET_UNSUPPORTED, ret);\n+  }\n+}\n+\n+TEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), set_content_filter) {\n+  rmw_subscription_content_filter_options_t options =\n+    rmw_get_zero_initialized_content_filter_options();\n+  auto allocator = rcutils_get_default_allocator();\n+  EXPECT_EQ(\n+    RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+      filter_expression,\n+      expression_parameters_count,\n+      expression_parameters_2,\n+      &allocator,\n+      &options));\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_content_filter_options_fini(&options, &allocator));\n+  });\n+\n+  bool is_cft_enabled = sub->is_cft_enabled;\n+  rmw_ret_t ret = rmw_subscription_set_content_filter(sub, &options);\n+  if (is_cft_enabled) {\n+    EXPECT_EQ(RMW_RET_OK, ret);\n+  } else {\n+    EXPECT_EQ(RMW_RET_UNSUPPORTED, ret);\n+  }\n+}\n+\n+TEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_get_begin) {\n+  rmw_ret_t ret;\n+  bool taken = false;\n+\n+  // Create publisher\n+  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n+  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, &qos_profile, &pub_options);\n+  ASSERT_NE(nullptr, pub) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) << rmw_get_error_string().str;\n+  });\n+\n+  bool is_cft_enabled = sub->is_cft_enabled;\n+\n+  size_t subscription_count = 0u;\n+  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n+    ret = rmw_publisher_count_matched_subscriptions(pub, &subscription_count);\n+    if (RMW_RET_OK == ret && 1u == subscription_count) {  // Early return on failure.\n+      break;\n+    }\n+  }\n+\n+  // Publish message with float (3.14159) from publisher to subscription\n+  test_msgs__msg__BasicTypes original_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&original_message));\n+  original_message.float32_value = 3.14159f;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__msg__BasicTypes__fini(&original_message);\n+  });\n+\n+  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n+  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n+\n+  ret = rmw_publish(pub, &original_message, null_allocation_p);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  // expect to get message because content filter is 3.14159\n+  {\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+\n+    test_msgs__msg__BasicTypes output_message{};\n+    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      test_msgs__msg__BasicTypes__fini(&output_message);\n+    });\n+\n+    ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+    // whatever the cft is supported or not\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    EXPECT_TRUE(taken);\n+    EXPECT_EQ(original_message, output_message);\n+  }\n+\n+  // set content filter with 3.14\n+  if (is_cft_enabled) {\n+    rmw_subscription_content_filter_options_t options =\n+      rmw_get_zero_initialized_content_filter_options();\n+    auto allocator = rcutils_get_default_allocator();\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters_2,\n+        &allocator,\n+        &options));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(&options, &allocator));\n+    });\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_set_content_filter(sub, &options));\n+    // waiting to allow for filter propagation\n+    std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+    ret = rmw_publish(pub, &original_message, null_allocation_p);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_TIMEOUT, ret) << rmw_get_error_string().str;\n+    ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n+\n+    // content filter subscription with 3.14 that is not equal with 3.14159\n+    {\n+      test_msgs__msg__BasicTypes output_message{};\n+      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+      {\n+        test_msgs__msg__BasicTypes__fini(&output_message);\n+      });\n+\n+      ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+      EXPECT_FALSE(taken);\n+    }\n+  }\n+}\n+\n+TEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_get_later) {\n+  rmw_ret_t ret;\n+  bool taken = false;\n+\n+  // Create publisher\n+  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n+  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, &qos_profile, &pub_options);\n+  ASSERT_NE(nullptr, pub) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) << rmw_get_error_string().str;\n+  });\n+\n+  bool is_cft_enabled = sub->is_cft_enabled;\n+\n+  size_t subscription_count = 0u;\n+  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n+    ret = rmw_publisher_count_matched_subscriptions(pub, &subscription_count);\n+    if (RMW_RET_OK == ret && 1u == subscription_count) {  // Early return on failure.\n+      break;\n+    }\n+  }\n+\n+  // Publish message with float (3.14) from publisher to subscription\n+  test_msgs__msg__BasicTypes original_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&original_message));\n+  original_message.float32_value = 3.14f;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__msg__BasicTypes__fini(&original_message);\n+  });\n+\n+  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n+  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n+\n+  ret = rmw_publish(pub, &original_message, null_allocation_p);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  {\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+\n+    // if cft is supported, not to expect to get the message because content filter is 3.14159\n+    if (is_cft_enabled) {\n+      EXPECT_EQ(RMW_RET_TIMEOUT, ret) << rmw_get_error_string().str;\n+      ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n+    } else {\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+      ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+    }\n+\n+    test_msgs__msg__BasicTypes output_message{};\n+    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      test_msgs__msg__BasicTypes__fini(&output_message);\n+    });\n+\n+    ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    if (is_cft_enabled) {\n+      EXPECT_FALSE(taken);\n+    } else {\n+      EXPECT_TRUE(taken);\n+      EXPECT_EQ(original_message, output_message);\n+    }\n+  }\n+\n+  // set content filter with 3.14\n+  if (is_cft_enabled) {\n+    rmw_subscription_content_filter_options_t options =\n+      rmw_get_zero_initialized_content_filter_options();\n+    auto allocator = rcutils_get_default_allocator();\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        filter_expression,\n+        expression_parameters_count,\n+        expression_parameters_2,\n+        &allocator,\n+        &options));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(&options, &allocator));\n+    });\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_set_content_filter(sub, &options));\n+    // waiting to allow for filter propagation\n+    std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+    ret = rmw_publish(pub, &original_message, null_allocation_p);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {5, 0};  // 5000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+\n+    // content filter subscription with 3.14 that is equal with 3.14\n+    {\n+      test_msgs__msg__BasicTypes output_message{};\n+      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+      {\n+        test_msgs__msg__BasicTypes__fini(&output_message);\n+      });\n+\n+      ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+      EXPECT_TRUE(taken);\n+      EXPECT_EQ(original_message, output_message);\n+    }\n+  }\n+}\n+\n+TEST_F(CLASSNAME(TestContentFilterSubscriptionUse, RMW_IMPLEMENTATION), content_filter_reset) {\n+  rmw_ret_t ret;\n+  bool taken = false;\n+\n+  // Create publisher\n+  rmw_publisher_options_t pub_options = rmw_get_default_publisher_options();\n+  rmw_publisher_t * pub = rmw_create_publisher(node, ts, topic_name, &qos_profile, &pub_options);\n+  ASSERT_NE(nullptr, pub) << rmw_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    EXPECT_EQ(RMW_RET_OK, rmw_destroy_publisher(node, pub)) << rmw_get_error_string().str;\n+  });\n+\n+  bool is_cft_enabled = sub->is_cft_enabled;\n+\n+  size_t subscription_count = 0u;\n+  SLEEP_AND_RETRY_UNTIL(rmw_intraprocess_discovery_delay, rmw_intraprocess_discovery_delay * 10) {\n+    ret = rmw_publisher_count_matched_subscriptions(pub, &subscription_count);\n+    if (RMW_RET_OK == ret && 1u == subscription_count) {  // Early return on failure.\n+      break;\n+    }\n+  }\n+\n+  // Publish message with float (3.14) from publisher to subscription\n+  test_msgs__msg__BasicTypes original_message{};\n+  ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&original_message));\n+  original_message.float32_value = 3.14f;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__msg__BasicTypes__fini(&original_message);\n+  });\n+\n+  rmw_publisher_allocation_t * null_allocation_p{nullptr};\n+  rmw_subscription_allocation_t * null_allocation_s{nullptr};\n+\n+  ret = rmw_publish(pub, &original_message, null_allocation_p);\n+  EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+  {\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {1, 0};  // 1000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+\n+    // if cft is supported, not to expect to get the message because content filter is 3.14159\n+    if (is_cft_enabled) {\n+      EXPECT_EQ(RMW_RET_TIMEOUT, ret) << rmw_get_error_string().str;\n+      ASSERT_EQ(nullptr, subscriptions.subscribers[0]);\n+    } else {\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+      ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+    }\n+\n+    test_msgs__msg__BasicTypes output_message{};\n+    ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      test_msgs__msg__BasicTypes__fini(&output_message);\n+    });\n+\n+    ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    if (is_cft_enabled) {\n+      EXPECT_FALSE(taken);\n+    } else {\n+      EXPECT_TRUE(taken);\n+      EXPECT_EQ(original_message, output_message);\n+    }\n+  }\n+\n+  // set content filter with empty(\"\")\n+  if (is_cft_enabled) {\n+    rmw_subscription_content_filter_options_t options =\n+      rmw_get_zero_initialized_content_filter_options();\n+    auto allocator = rcutils_get_default_allocator();\n+    EXPECT_EQ(\n+      RMW_RET_OK, rmw_subscription_content_filter_options_init(\n+        \"\",\n+        0,\n+        nullptr,\n+        &allocator,\n+        &options));\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK,\n+        rmw_subscription_content_filter_options_fini(&options, &allocator));\n+    });\n+\n+    EXPECT_EQ(\n+      RMW_RET_OK,\n+      rmw_subscription_set_content_filter(sub, &options));\n+    // waiting to allow for filter propagation\n+    std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+    ret = rmw_publish(pub, &original_message, null_allocation_p);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+    rmw_subscriptions_t subscriptions;\n+    void * subscriptions_storage[1];\n+    subscriptions_storage[0] = sub->data;\n+    subscriptions.subscribers = subscriptions_storage;\n+    subscriptions.subscriber_count = 1;\n+\n+    rmw_wait_set_t * wait_set = rmw_create_wait_set(&context, 1);\n+    ASSERT_NE(nullptr, wait_set) << rmw_get_error_string().str;\n+    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+    {\n+      EXPECT_EQ(\n+        RMW_RET_OK, rmw_destroy_wait_set(wait_set)) << rmw_get_error_string().str;\n+    });\n+    rmw_time_t timeout = {5, 0};  // 5000ms\n+    ret = rmw_wait(&subscriptions, nullptr, nullptr, nullptr, nullptr, wait_set, &timeout);\n+    EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+    ASSERT_NE(nullptr, subscriptions.subscribers[0]);\n+\n+    // content filter subscription is reset\n+    {\n+      test_msgs__msg__BasicTypes output_message{};\n+      ASSERT_TRUE(test_msgs__msg__BasicTypes__init(&output_message));\n+      OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+      {\n+        test_msgs__msg__BasicTypes__fini(&output_message);\n+      });\n+\n+      ret = rmw_take(sub, &output_message, &taken, null_allocation_s);\n+      EXPECT_EQ(RMW_RET_OK, ret) << rmw_get_error_string().str;\n+\n+      EXPECT_TRUE(taken);\n+      EXPECT_EQ(original_message, output_message);\n+    }\n+  }\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            for idl_stem in sorted(modules[subfolder]):\n-                module_name = '_' + \\\n+            module_names = {}\n+            for idl_stem in modules[subfolder]:\n+                module_names[idl_stem] = '_' + \\"},{"role":"user","content":"+            # sorting after lower case conversion to get true order\n+            for module_name, idl_stem in \\\n+                sorted((value, key) for (key,value) in module_names.items()):"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-find_package(ament_cmake_auto REQUIRED)\n-set(required_dependencies\n-  \"geometry_msgs\"\n-  \"orocos_kdl\"\n-  \"tf2\"\n-  \"tf2_ros\"\n-)\n-ament_auto_find_build_dependencies(REQUIRED ${required_dependencies})\n+find_package(geometry_msgs REQUIRED)\n+find_package(orocos_kdl REQUIRED)\n+find_package(tf2 REQUIRED)\n+find_package(tf2_ros REQUIRED)"},{"role":"user","content":"+add_library(${PROJECT_NAME} INTERFACE)\n+target_include_directories(${PROJECT_NAME} INTERFACE\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n+  \"$<INSTALL_INTERFACE:include>\")\n+target_link_libraries(${PROJECT_NAME} INTERFACE\n+  ${geometry_msgs_TARGETS}\n+  orocos-kdl\n+  tf2::tf2\n+  tf2_ros::tf2_ros)\n+"},{"role":"user","content":"-    target_include_directories(test_tf2_geometry_msgs PUBLIC include)\n-    ament_target_dependencies(test_tf2_geometry_msgs\n-      \"geometry_msgs\"\n-      \"orocos_kdl\"\n-      \"rclcpp\"\n-      \"tf2\"\n-      \"tf2_ros\"\n+    target_link_libraries(test_tf2_geometry_msgs\n+      ${PROJECT_NAME}\n+      rclcpp::rclcpp\n+      # Used, but not linked to test ${PROJECT_NAME}'s exports:\n+      #   tf2_ros::tf2_ros"},{"role":"user","content":"-add_library(${PROJECT_NAME} INTERFACE)\n-target_include_directories(${PROJECT_NAME} INTERFACE $<INSTALL_INTERFACE:include>)\n-ament_target_dependencies(${PROJECT_NAME} INTERFACE ${required_dependencies})\n-\n-install(\n-  TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}\n-  INCLUDES DESTINATION include\n-)\n+install(TARGETS ${PROJECT_NAME} EXPORT export_${PROJECT_NAME})\n+install(DIRECTORY include/ DESTINATION include)"},{"role":"user","content":"-ament_export_targets(${PROJECT_NAME})\n-ament_export_dependencies(${required_dependencies})\n+ament_export_targets(export_${PROJECT_NAME})\n+ament_export_dependencies(\n+  \"geometry_msgs\"\n+  \"orocos_kdl\"\n+  \"tf2\"\n+  \"tf2_ros\")"},{"role":"user","content":"-ament_auto_package()\n+ament_package()"},{"role":"user","content":"-  <buildtool_depend>ament_cmake_auto</buildtool_depend>\n+  <buildtool_depend>ament_cmake</buildtool_depend>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  static_cast<void>(subscription);\n-  static_cast<void>(dynamic_message);\n-  static_cast<void>(taken);\n-  static_cast<void>(allocation);\n+  RCUTILS_UNUSED(subscription);\n+  RCUTILS_UNUSED(dynamic_message);\n+  RCUTILS_UNUSED(taken);\n+  RCUTILS_UNUSED(allocation);"},{"role":"user","content":"-  static_cast<void>(subscription);\n-  static_cast<void>(dynamic_message);\n-  static_cast<void>(taken);\n-  static_cast<void>(message_info);\n-  static_cast<void>(allocation);\n+  RCUTILS_UNUSED(subscription);\n+  RCUTILS_UNUSED(dynamic_message);\n+  RCUTILS_UNUSED(taken);\n+  RCUTILS_UNUSED(message_info);\n+  RCUTILS_UNUSED(allocation);"},{"role":"user","content":"-  static_cast<void>(serialization_lib_name);\n-  static_cast<void>(allocator);\n-  static_cast<void>(serialization_support);\n+  RCUTILS_UNUSED(serialization_lib_name);\n+  RCUTILS_UNUSED(allocator);\n+  RCUTILS_UNUSED(serialization_support);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher,\n+    publisher->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription,\n+    subscription->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n+"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription_count, RMW_RET_INVALID_ARGUMENT);\n-"},{"role":"user","content":"-  if (info != nullptr) {\n-    *subscription_count = info->listener_->subscriptionCount();\n-  }\n+\n+  *subscription_count = info->listener_->subscriptionCount();"},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(subscription, RMW_RET_INVALID_ARGUMENT);\n-  RMW_CHECK_ARGUMENT_FOR_NULL(publisher_count, RMW_RET_INVALID_ARGUMENT);\n-"},{"role":"user","content":"-  if (info != nullptr) {\n-    *publisher_count = info->listener_->publisherCount();\n-  }\n+\n+  *publisher_count = info->listener_->publisherCount();\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            cycle_count = 0\n-            while cycle_count < 5:\n+            for i in range(5):"},{"role":"user","content":"-                    time.sleep(0.1)\n+                    time.sleep(0.2)"},{"role":"user","content":"-        cycle_count = 0\n-        while cycle_count < 5:\n+        for i in range(5):"},{"role":"user","content":"-                time.sleep(0.1)\n+                time.sleep(0.2)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ament_add_gtest(test_rmw_qos_to_dds_attributes test_rmw_qos_to_dds_attributes.cpp)\n+if(TARGET test_rmw_qos_to_dds_attributes)\n+  target_link_libraries(test_rmw_qos_to_dds_attributes ${PROJECT_NAME})\n+endif()\n+"},{"role":"user","content":"+// Copyright 2017 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <tuple>\n+\n+#include \"gtest/gtest.h\"\n+\n+#include \"fastrtps/attributes/PublisherAttributes.h\"\n+#include \"fastrtps/attributes/SubscriberAttributes.h\"\n+\n+#include \"rmw_fastrtps_shared_cpp/qos.hpp\"\n+\n+#include \"rmw/error_handling.h\"\n+\n+\n+using eprosima::fastrtps::SubscriberAttributes;\n+\n+class GetDataReaderQoSTest : public ::testing::Test\n+{\n+protected:\n+  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n+  SubscriberAttributes subscriber_attributes_{};\n+};\n+\n+TEST_F(GetDataReaderQoSTest, test_unknown_history_policy_conversion_fails) {\n+  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n+  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataReaderQoSTest, unknown_reliability_policy_conversion_fails) {\n+  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n+  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataReaderQoSTest, unknown_durability_policy_conversion_fails) {\n+  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n+  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataReaderQoSTest, unknown_liveliness_policy_conversion_fails) {\n+  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n+  EXPECT_FALSE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataReaderQoSTest, nominal_conversion) {\n+  qos_profile_.depth = 10u;\n+  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n+  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n+  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n+  qos_profile_.lifespan.sec = 0u;\n+  qos_profile_.lifespan.nsec = 500000000u;\n+  qos_profile_.deadline.sec = 0u;\n+  qos_profile_.deadline.nsec = 100000000u;\n+  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n+  qos_profile_.liveliness_lease_duration.sec = 10u;\n+  qos_profile_.liveliness_lease_duration.nsec = 0u;\n+\n+  EXPECT_TRUE(get_datareader_qos(qos_profile_, subscriber_attributes_));\n+\n+  EXPECT_EQ(\n+    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n+    subscriber_attributes_.qos.m_reliability.kind);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n+    subscriber_attributes_.qos.m_durability.kind);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n+    subscriber_attributes_.qos.m_liveliness.kind);\n+  EXPECT_EQ(0, subscriber_attributes_.qos.m_lifespan.duration.seconds);\n+  EXPECT_EQ(500000000u, subscriber_attributes_.qos.m_lifespan.duration.nanosec);\n+  EXPECT_EQ(0, subscriber_attributes_.qos.m_deadline.period.seconds);\n+  EXPECT_EQ(100000000u, subscriber_attributes_.qos.m_deadline.period.nanosec);\n+  EXPECT_EQ(10, subscriber_attributes_.qos.m_liveliness.lease_duration.seconds);\n+  EXPECT_EQ(0u, subscriber_attributes_.qos.m_liveliness.lease_duration.nanosec);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n+    subscriber_attributes_.topic.historyQos.kind);\n+  EXPECT_EQ(10, subscriber_attributes_.topic.historyQos.depth);\n+}\n+\n+using eprosima::fastrtps::PublisherAttributes;\n+\n+class GetDataWriterQoSTest : public ::testing::Test\n+{\n+protected:\n+  rmw_qos_profile_t qos_profile_{rmw_qos_profile_default};\n+  PublisherAttributes publisher_attributes_{};\n+};\n+\n+TEST_F(GetDataWriterQoSTest, test_unknown_history_policy_conversion_fails) {\n+  qos_profile_.history = RMW_QOS_POLICY_HISTORY_UNKNOWN;\n+  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataWriterQoSTest, unknown_reliability_policy_conversion_fails) {\n+  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_UNKNOWN;\n+  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataWriterQoSTest, unknown_durability_policy_conversion_fails) {\n+  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_UNKNOWN;\n+  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataWriterQoSTest, unknown_liveliness_policy_conversion_fails) {\n+  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_UNKNOWN;\n+  EXPECT_FALSE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n+  EXPECT_TRUE(rmw_error_is_set());\n+  rmw_reset_error();\n+}\n+\n+TEST_F(GetDataWriterQoSTest, nominal_conversion) {\n+  qos_profile_.depth = 10u;\n+  qos_profile_.history = RMW_QOS_POLICY_HISTORY_KEEP_LAST;\n+  qos_profile_.reliability = RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;\n+  qos_profile_.durability = RMW_QOS_POLICY_DURABILITY_VOLATILE;\n+  qos_profile_.lifespan.sec = 0u;\n+  qos_profile_.lifespan.nsec = 500000000u;\n+  qos_profile_.deadline.sec = 0u;\n+  qos_profile_.deadline.nsec = 100000000u;\n+  qos_profile_.liveliness = RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;\n+  qos_profile_.liveliness_lease_duration.sec = 10u;\n+  qos_profile_.liveliness_lease_duration.nsec = 0u;\n+\n+  EXPECT_TRUE(get_datawriter_qos(qos_profile_, publisher_attributes_));\n+\n+  EXPECT_EQ(\n+    eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS,\n+    publisher_attributes_.qos.m_reliability.kind);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::VOLATILE_DURABILITY_QOS,\n+    publisher_attributes_.qos.m_durability.kind);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::AUTOMATIC_LIVELINESS_QOS,\n+    publisher_attributes_.qos.m_liveliness.kind);\n+  EXPECT_EQ(0, publisher_attributes_.qos.m_lifespan.duration.seconds);\n+  EXPECT_EQ(500000000u, publisher_attributes_.qos.m_lifespan.duration.nanosec);\n+  EXPECT_EQ(0, publisher_attributes_.qos.m_deadline.period.seconds);\n+  EXPECT_EQ(100000000u, publisher_attributes_.qos.m_deadline.period.nanosec);\n+  EXPECT_EQ(10, publisher_attributes_.qos.m_liveliness.lease_duration.seconds);\n+  EXPECT_EQ(0u, publisher_attributes_.qos.m_liveliness.lease_duration.nanosec);\n+  EXPECT_EQ(\n+    eprosima::fastrtps::KEEP_LAST_HISTORY_QOS,\n+    publisher_attributes_.topic.historyQos.kind);\n+  EXPECT_EQ(10, publisher_attributes_.topic.historyQos.depth);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+rmw_ret_t\n+rmw_count_clients(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  return rmw_api_connextdds_count_clients(node, service_name, count);\n+}\n+\n+rmw_ret_t\n+rmw_count_services(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  return rmw_api_connextdds_count_services(node, service_name, count);\n+}\n+\n+"},{"role":"user","content":"+RMW_CONNEXTDDS_PUBLIC\n+rmw_ret_t\n+rmw_api_connextdds_count_clients(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count);\n+\n+RMW_CONNEXTDDS_PUBLIC\n+rmw_ret_t\n+rmw_api_connextdds_count_services(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count);\n+"},{"role":"user","content":"+rmw_ret_t\n+rmw_api_connextdds_count_clients(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    RMW_CONNEXTDDS_ID,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);\n+\n+  int validation_result = RMW_TOPIC_VALID;\n+  rmw_ret_t ret =\n+    rmw_validate_full_topic_name(service_name, &validation_result, nullptr);\n+  if (RMW_RET_OK != ret) {\n+    return ret;\n+  }\n+  if (RMW_TOPIC_VALID != validation_result) {\n+    const char * reason =\n+      rmw_full_topic_name_validation_result_string(validation_result);\n+    RMW_CONNEXT_LOG_ERROR_A_SET(\"invalid service name: %s\", reason)\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+\n+  auto common_context = &node->context->impl->common;\n+  const std::string mangled_rp_service_name =\n+    rmw_connextdds_create_topic_name(\n+    ROS_SERVICE_RESPONSE_PREFIX, service_name, \"Reply\", false);\n+  return common_context->graph_cache.get_reader_count(\n+    mangled_rp_service_name, count);\n+}\n+\n+\n+rmw_ret_t\n+rmw_api_connextdds_count_services(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    RMW_CONNEXTDDS_ID,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(service_name, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(count, RMW_RET_INVALID_ARGUMENT);\n+\n+  int validation_result = RMW_TOPIC_VALID;\n+  rmw_ret_t ret =\n+    rmw_validate_full_topic_name(service_name, &validation_result, nullptr);\n+  if (RMW_RET_OK != ret) {\n+    return ret;\n+  }\n+  if (RMW_TOPIC_VALID != validation_result) {\n+    const char * reason =\n+      rmw_full_topic_name_validation_result_string(validation_result);\n+    RMW_CONNEXT_LOG_ERROR_A_SET(\"invalid service name: %s\", reason)\n+    return RMW_RET_INVALID_ARGUMENT;\n+  }\n+\n+  auto common_context = &node->context->impl->common;\n+  const std::string mangled_rp_service_name =\n+    rmw_connextdds_create_topic_name(\n+    ROS_SERVICE_RESPONSE_PREFIX, service_name, \"Reply\", false);\n+  return common_context->graph_cache.get_writer_count(\n+    mangled_rp_service_name, count);\n+}\n+\n+"},{"role":"user","content":"+rmw_ret_t\n+rmw_count_clients(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  return rmw_api_connextdds_count_clients(node, service_name, count);\n+}\n+\n+\n+rmw_ret_t\n+rmw_count_services(\n+  const rmw_node_t * node,\n+  const char * service_name,\n+  size_t * count)\n+{\n+  return rmw_api_connextdds_count_services(node, service_name, count);\n+}\n+\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  RMW_CHECK_ARGUMENT_FOR_NULL(\n-    message_info, RMW_RET_INVALID_ARGUMENT);\n-"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(message_info, RMW_RET_INVALID_ARGUMENT);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not NULL\n+   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr"},{"role":"user","content":"-    const TimePoint & time, std::string * error_msg = NULL) const override;\n+    const TimePoint & time, std::string * error_msg = nullptr) const override;"},{"role":"user","content":"-   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not NULL\n+   * \\param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr"},{"role":"user","content":"-    const std::string & fixed_frame, std::string * error_msg = NULL) const override;\n+    const std::string & fixed_frame, std::string * error_msg = nullptr) const override;"},{"role":"user","content":"-    * \\param[out] error_msg if non-NULL, fill with produced error messaging.\n+    * \\param[out] error_msg if non-nullptr, fill with produced error messaging."},{"role":"user","content":"-  /**@brief Traverse the transform tree. If frame_chain is not NULL, store the traversed frame tree in vector frame_chain.\n+  /**@brief Traverse the transform tree. If frame_chain is not nullptr, store the traversed frame tree in vector frame_chain."},{"role":"user","content":"-   *   Ignored if NULL.\n+   *   Ignored if nullptr."},{"role":"user","content":"-   *   Ignored if NULL.\n+   *   Ignored if nullptr."},{"role":"user","content":"-    if (frame == NULL) {\n+    if (frame == nullptr) {"},{"role":"user","content":"-    if (frame_ptr == NULL) {\n+    if (frame_ptr == nullptr) {"},{"role":"user","content":"-  CompactFrameID parent_id = frame->getParent(time, NULL);\n+  CompactFrameID parent_id = frame->getParent(time, nullptr);"},{"role":"user","content":"-  int buff_size = rcutils_snprintf(NULL, 0, format_str, current_time);\n+  int buff_size = rcutils_snprintf(nullptr, 0, format_str, current_time);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        # Note: parameter overrides and parameter event publisher need to be ready at this point\n-        # to be able to declare 'use_sim_time' if it was not declared yet."},{"role":"user","content":"-        self._time_source = TimeSource(node=self)\n-        self._time_source.attach_clock(self._clock)"},{"role":"user","content":"+        # Init a time source.\n+        # Note: parameter overrides and parameter event publisher need to be ready at this point\n+        # to be able to declare 'use_sim_time' if it was not declared yet.\n+        self._time_source = TimeSource(node=self)\n+        self._time_source.attach_clock(self._clock)\n+"},{"role":"user","content":"+from rclpy.parameter import Parameter"},{"role":"user","content":"+    def test_create_node_with_parameter_overrides(self):\n+        node_name = 'create_node_with_parameter_overrides_test'\n+        rclpy.create_node(\n+            node_name, context=self.context,\n+            automatically_declare_parameters_from_overrides=True,\n+            parameter_overrides=[\n+                Parameter('use_sim_time', Parameter.Type.BOOL, True)\n+            ]\n+        ).destroy_node()\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  std::mutex handle_mutex_;\n+  std::recursive_mutex handle_mutex_;"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"-  std::lock_guard<std::mutex> guard(handle_mutex_);\n+  std::lock_guard<std::recursive_mutex> guard(handle_mutex_);"},{"role":"user","content":"+TEST_F(TestClientAgainstServer, deadlock_in_callbacks)\n+{\n+  std::atomic<bool> feedback_callback_called = false;\n+  std::atomic<bool> response_callback_called = false;\n+  std::atomic<bool> result_callback_called = false;\n+  std::atomic<bool> no_deadlock = false;\n+\n+  std::thread tr = std::thread(\n+    [&]() {\n+      auto action_client = rclcpp_action::create_client<ActionType>(client_node, action_name);\n+      ASSERT_TRUE(action_client->wait_for_action_server(WAIT_FOR_SERVER_TIMEOUT));\n+\n+      ActionGoal goal;\n+\n+      using GoalHandle = rclcpp_action::ClientGoalHandle<ActionType>;\n+      rclcpp_action::Client<ActionType>::SendGoalOptions ops;\n+      ops.feedback_callback =\n+      [&feedback_callback_called](const GoalHandle::SharedPtr handle,\n+      ActionType::Feedback::ConstSharedPtr) {\n+        // call functions on the handle that acquire the lock\n+        handle->get_status();\n+        handle->is_feedback_aware();\n+        handle->is_result_aware();\n+\n+        feedback_callback_called = true;\n+      };\n+      ops.goal_response_callback = [&response_callback_called](\n+        const GoalHandle::SharedPtr & handle) {\n+        // call functions on the handle that acquire the lock\n+        handle->get_status();\n+        handle->is_feedback_aware();\n+        handle->is_result_aware();\n+\n+        response_callback_called = true;\n+      };\n+      ops.result_callback = [&result_callback_called](\n+        const GoalHandle::WrappedResult &) {\n+        result_callback_called = true;\n+      };\n+\n+      goal.order = 6;\n+      auto future_goal_handle = action_client->async_send_goal(goal, ops);\n+      dual_spin_until_future_complete(future_goal_handle);\n+      auto goal_handle = future_goal_handle.get();\n+\n+      ASSERT_TRUE(goal_handle);\n+\n+      ASSERT_EQ(RCL_RET_OK, rcl_set_ros_time_override(clock.get_clock_handle(), RCL_S_TO_NS(2)));\n+\n+      auto result_future = action_client->async_get_result(goal_handle);\n+      dual_spin_until_future_complete(result_future);\n+\n+      EXPECT_TRUE(result_future.valid());\n+      auto result = result_future.get();\n+\n+      no_deadlock = true;\n+    });\n+\n+  auto start_time = std::chrono::system_clock::now();\n+\n+  while (std::chrono::system_clock::now() - start_time < std::chrono::milliseconds(2000) &&\n+    !no_deadlock)\n+  {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n+  }\n+\n+  if (no_deadlock) {\n+    tr.join();\n+  } else {\n+    // In case of a failure, the thread is assumed to be in a deadlock.\n+    // We detach the thread so we don't block further tests.\n+    tr.detach();\n+  }\n+\n+  EXPECT_TRUE(no_deadlock);\n+  EXPECT_TRUE(response_callback_called);\n+  EXPECT_TRUE(result_callback_called);\n+  EXPECT_TRUE(feedback_callback_called);\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <rcpputils/filesystem_helper.hpp>\n-#include <rcpputils/env.hpp>\n-#include <rcutils/allocator.h>\n-#include <rcutils/env.h>\n-#include <rcutils/error_handling.h>\n-"},{"role":"user","content":"+\n+#include \"rcpputils/filesystem_helper.hpp\"\n+#include \"rcpputils/env.hpp\"\n+#include \"rcutils/allocator.h\"\n+#include \"rcutils/env.h\"\n+#include \"rcutils/error_handling.h\"\n+"},{"role":"user","content":"-#include <rcpputils/filesystem_helper.hpp>\n-#include <rcutils/allocator.h>\n-#include <rcutils/logging.h>\n-#include <rcutils/process.h>\n-#include <rcutils/snprintf.h>\n-#include <rcutils/time.h>\n-"},{"role":"user","content":"+#include \"rcpputils/filesystem_helper.hpp\"\n+#include \"rcutils/allocator.h\"\n+#include \"rcutils/logging.h\"\n+#include \"rcutils/process.h\"\n+#include \"rcutils/snprintf.h\"\n+#include \"rcutils/time.h\"\n+"},{"role":"user","content":"-#include <rcpputils/filesystem_helper.hpp>\n-#include <rcutils/allocator.h>\n-#include <rcutils/env.h>\n-#include <rcutils/error_handling.h>\n-#include <rcutils/process.h>\n-#include <rcutils/types/string_array.h>\n-"},{"role":"user","content":"+#include \"rcpputils/filesystem_helper.hpp\"\n+#include \"rcutils/allocator.h\"\n+#include \"rcutils/env.h\"\n+#include \"rcutils/error_handling.h\"\n+#include \"rcutils/process.h\"\n+#include \"rcutils/types/string_array.h\"\n+"},{"role":"user","content":"-#include <rcpputils/filesystem_helper.hpp>\n-#include <rcpputils/env.hpp>\n-#include <rcutils/allocator.h>\n-#include <rcutils/env.h>\n-#include <rcutils/error_handling.h>\n-#include <rcutils/logging.h>\n-#include <rcutils/testing/fault_injection.h>\n-"},{"role":"user","content":"-#include \"fixtures.hpp\""},{"role":"user","content":"+\n+#include \"rcpputils/filesystem_helper.hpp\"\n+#include \"rcpputils/env.hpp\"\n+#include \"rcutils/allocator.h\"\n+#include \"rcutils/env.h\"\n+#include \"rcutils/error_handling.h\"\n+#include \"rcutils/logging.h\"\n+#include \"rcutils/testing/fault_injection.h\"\n+\n+#include \"fixtures.hpp\""},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+@{\n+TEMPLATE(\n+    '_msg_support.c.em',\n+    package_name=package_name, interface_path=interface_path,\n+    message=service.event_message, include_directives=include_directives)\n+}@"},{"role":"user","content":"+@{\n+TEMPLATE(\n+    '_msg_support.c.em',\n+    package_name=package_name, interface_path=interface_path,\n+    message=action.send_goal_service.event_message,\n+    include_directives=include_directives)\n+}@\n+"},{"role":"user","content":"+@{\n+TEMPLATE(\n+    '_msg_support.c.em',\n+    package_name=package_name, interface_path=interface_path,\n+    message=action.get_result_service.event_message,\n+    include_directives=include_directives)\n+}@\n+"},{"role":"user","content":"+from rosidl_parser.definition import SERVICE_EVENT_MESSAGE_SUFFIX\n+from rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX\n+from rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX"},{"role":"user","content":"+        if (\n+            type_.name.endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX) or\n+            type_.name.endswith(SERVICE_REQUEST_MESSAGE_SUFFIX)\n+        ):\n+            continue"},{"role":"user","content":"+from rosidl_parser.definition import SERVICE_RESPONSE_MESSAGE_SUFFIX\n+from rosidl_parser.definition import SERVICE_REQUEST_MESSAGE_SUFFIX"},{"role":"user","content":"-@[    if nested_header in include_directives]@\n+@[    if type_[-1].endswith(SERVICE_REQUEST_MESSAGE_SUFFIX) or type_[-1].endswith(SERVICE_RESPONSE_MESSAGE_SUFFIX)]\n+@# Service request/response messages are included in the srv__struct\n+@[continue]\n+@[    elif nested_header in include_directives]@"},{"role":"user","content":"+TEMPLATE(\n+    '_msg.py.em',\n+    package_name=package_name, interface_path=interface_path,\n+    message=service.event_message, import_statements=import_statements)"},{"role":"user","content":"+            if @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name)._TYPE_SUPPORT is None:\n+                @(module_name).Metaclass_@(service.event_message.structure.namespaced_type.name).__import_type_support__()"},{"role":"user","content":"+    from @('.'.join(service.namespaced_type.namespaces)).@(module_name) import @(service.event_message.structure.namespaced_type.name) as Event"},{"role":"user","content":"+\n+@{\n+TEMPLATE(\n+    '_msg_pkg_typesupport_entry_point.c.em',\n+    package_name=package_name, idl_type=idl_type,\n+    message=service.event_message, typesupport_impl=typesupport_impl,\n+    include_directives=include_directives,\n+    register_functions=register_functions)\n+}@"},{"role":"user","content":"+                if subfolder == 'srv':\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_Event  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_Request  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_Response  # noqa: F401\\n')\n+                elif subfolder == 'action':\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_GetResult_Event  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_GetResult_Request  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_GetResult_Response  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_SendGoal_Event  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_SendGoal_Request  # noqa: F401\\n')\n+                    f.write(\n+                        f'from {package_name}.{subfolder}.{module_name} import '\n+                        f'{idl_stem}_SendGoal_Response  # noqa: F401\\n')"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+/**\n+ * \\def RCUTILS_NO_FAULT_INJECTION\n+ *\n+ * A convenience macro built around rcutils_fault_injection_set_count() to pause fault\n+ * injection during `code` execution.\n+ * This macro is intended to be used within RCUTILS_FAULT_INJECTION_TEST() blocks.\n+ *\n+ * `code` is executed within a do-while loop and therefore any variables declared within are in\n+ * their own scope block.\n+ *\n+ * Here's a simple example:\n+ *  RCUTILS_FAULT_INJECTION_TEST({\n+ *    rcl_ret_t ret = rcl_init(argc, argv, options, context);\n+ *    if (RCL_RET_OK == ret)\n+ *    {\n+ *      RCUTILS_NO_FAULT_INJECTION({\n+ *        ret = rcl_shutdown(context);\n+ *      });\n+ *    }\n+ * });\n+ *\n+ * In this example, on successful rcl_init(), rcl_shutdown() is called while ensuring that\n+ * it will not fail due to fault injection.\n+ */\n+#define RCUTILS_NO_FAULT_INJECTION(code) \\\n+  do { \\\n+    int64_t no_fault_injection_count = rcutils_fault_injection_get_count(); \\\n+    rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL); \\\n+    code; \\\n+    rcutils_fault_injection_set_count(no_fault_injection_count); \\\n+  } while (0)\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+RMW_INTERFACE_FN(\n+  rmw_event_type_is_supported,\n+  bool, RMW_EVENT_INVALID,\n+  1, ARG_TYPES(\n+    rmw_event_type_t))\n+"},{"role":"user","content":"+  GET_SYMBOL(rmw_event_type_is_supported)"},{"role":"user","content":"+  symbol_rmw_event_type_is_supported = nullptr;"},{"role":"user","content":"-    // rmw_zenoh does not support RMW_EVENT_LIVELINESS_CHANGED.\n-    // TODO(Yadunund): Rely on API suggested in https://github.com/ros2/rmw/issues/394 instead.\n-    if (std::string(rmw_get_implementation_identifier()).find(\"rmw_zenoh_cpp\") == 0) {\n+    if (!rmw_event_type_is_supported(RMW_EVENT_LIVELINESS_CHANGED)) {"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master"},{"role":"user","content":"-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @sloretz @adityapande-1995"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+      test/test_type_hash.py"},{"role":"user","content":"+from rclpy.type_hash import TypeHash"},{"role":"user","content":"+        '_topic_type_hash',"},{"role":"user","content":"+        self.topic_type_hash = kwargs.get('topic_type_hash', TypeHash())"},{"role":"user","content":"+    @property\n+    def topic_type_hash(self):\n+        \"\"\"\n+        Get field 'topic_type_hash'.\n+\n+        :returns: topic_type_hash attribute\n+        :rtype: TypeHash\n+        \"\"\"\n+        return self._topic_type_hash\n+\n+    @topic_type_hash.setter\n+    def topic_type_hash(self, value):\n+        if isinstance(value, TypeHash):\n+            self._topic_type_hash = value\n+        elif isinstance(value, dict):\n+            self._topic_type_hash = TypeHash(**value)\n+        else:\n+            assert False\n+"},{"role":"user","content":"-            'Topic type hash: UNKNOWN',\n+            f'Topic type hash: {self.topic_type_hash}',"},{"role":"user","content":"+# Copyright 2023 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+class TypeHash:\n+    \"\"\"Type hash.\"\"\"\n+\n+    _TYPE_HASH_SIZE = 32\n+\n+    __slots__ = [\n+        '_version',\n+        '_value',\n+    ]\n+\n+    def __init__(self, **kwargs):\n+        assert all('_' + key in self.__slots__ for key in kwargs.keys()), \\\n+            'Invalid arguments passed to constructor: %r' % kwargs.keys()\n+\n+        self.version = kwargs.get('version', -1)\n+        self.value = kwargs.get('value', bytes(self._TYPE_HASH_SIZE))\n+\n+    @property\n+    def version(self):\n+        \"\"\"\n+        Get field 'version'.\n+\n+        :returns: version attribute\n+        :rtype: int\n+        \"\"\"\n+        return self._version\n+\n+    @version.setter\n+    def version(self, value):\n+        assert isinstance(value, int)\n+        self._version = value\n+\n+    @property\n+    def value(self):\n+        \"\"\"\n+        Get field 'value'.\n+\n+        :returns: value attribute\n+        :rtype: bytes\n+        \"\"\"\n+        return self._value\n+\n+    @value.setter\n+    def value(self, value):\n+        assert isinstance(value, bytes)\n+        self._value = value\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, TypeHash):\n+            return False\n+        return all(\n+            self.__getattribute__(slot) == other.__getattribute__(slot)\n+            for slot in self.__slots__)\n+\n+    def __str__(self):\n+        if self._version <= 0 or len(self._value) != self._TYPE_HASH_SIZE:\n+            return 'INVALID'\n+\n+        return f'RIHS{self._version:02}_{self._value.hex()}'"},{"role":"user","content":"+  py_endpoint_info_dict[\"topic_type_hash\"] =\n+    convert_to_type_hash_dict(&topic_endpoint_info->topic_type_hash);"},{"role":"user","content":"+\n+py::dict\n+convert_to_type_hash_dict(const rosidl_type_hash_t * type_hash)\n+{\n+  // Create dictionary and populate arguments with type hash object\n+  py::dict type_hash_kwargs;\n+\n+  type_hash_kwargs[\"version\"] = py::int_(type_hash->version);\n+  type_hash_kwargs[\"value\"] = py::bytes(\n+    reinterpret_cast<const char *>(type_hash->value),\n+    ROSIDL_TYPE_HASH_SIZE);\n+\n+  return type_hash_kwargs;\n+}"},{"role":"user","content":"+\n+/// Convert a C rosidl_type_hash_t into a Python dictionary.\n+/**\n+ * \\param[in] type_hash Pointer to a rosidl_type_hash_t to convert\n+ * \\return Python dictionary\n+ */\n+py::dict\n+convert_to_type_hash_dict(const rosidl_type_hash_t * type_hash);"},{"role":"user","content":"-            'Topic type hash: UNKNOWN\\n' \\\n+            'Topic type hash: INVALID\\n' \\"},{"role":"user","content":"+# Copyright 2023 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+from rclpy.type_hash import TypeHash\n+\n+# From std_msgs/msg/String.json\n+STD_MSGS_STRING_TYPE_HASH_DICT = {\n+    'version': 1,\n+    'value': b'\\xdf\\x66\\x8c\\x74\\x04\\x82\\xbb\\xd4\\x8f\\xb3\\x9d\\x76\\xa7\\x0d\\xfd\\x4b'\n+             b'\\xd5\\x9d\\xb1\\x28\\x80\\x21\\x74\\x35\\x03\\x25\\x9e\\x94\\x8f\\x6b\\x1a\\x18',\n+}\n+STD_MSGS_STRING_TYPE_HASH_STR = 'RIHS01_' \\\n+                                'df668c740482bbd48fb39d76a70dfd4bd59db1288021743503259e948f6b1a18'\n+\n+\n+class TestTypeHash(unittest.TestCase):\n+\n+    def test_dict_constructor(self):\n+        type_hash = TypeHash(**STD_MSGS_STRING_TYPE_HASH_DICT)\n+        self.assertEqual(STD_MSGS_STRING_TYPE_HASH_DICT['version'], type_hash.version)\n+        self.assertEqual(STD_MSGS_STRING_TYPE_HASH_DICT['value'], type_hash.value)\n+\n+    def test_print_valid(self):\n+        actual_str = str(TypeHash(**STD_MSGS_STRING_TYPE_HASH_DICT))\n+        expected_str = STD_MSGS_STRING_TYPE_HASH_STR\n+        self.assertEqual(expected_str, actual_str)\n+\n+    def test_print_invalid(self):\n+        actual_str = str(TypeHash())\n+        expected_str = 'INVALID'\n+        self.assertEqual(expected_str, actual_str)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ * Depending on the RMW in use, discovery may be asynchronous.  Therefore, creating a publisher\n+ * and then calling this API may not show the newly created publisher immediately.\n+ *"},{"role":"user","content":"+ * Depending on the RMW in use, discovery may be asynchronous.  Therefore, creating a subscription\n+ * and then calling this API may not show the newly created subscription immediately.\n+ *"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    In this case, the value QoSCompatility.WARNING is set as part of\n+    In this case, the value QoSCompatibility.WARNING is set as part of"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  rmw_ret_t ret;"},{"role":"user","content":"-    if ((ret = rmw_serialized_message_resize(serialized_message, size) != RMW_RET_OK)) {\n+    rmw_ret_t ret = rmw_serialized_message_resize(serialized_message, size);\n+    if (RMW_RET_OK != ret) {"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+For building documentation, you need an installation of ROS 2.\n+"},{"role":"user","content":"-    cd rclpy/docs\n+Source your ROS 2 installation, for example:\n+\n+    . /opt/ros/foxy/setup.bash\n+\n+Build code:\n+\n+    mkdir -p rclpy_ws/src\n+    cd rclpy_ws/src\n+    git clone https://github.com/ros2/rclpy.git\n+    cd ..\n+    colcon build --symlink-install\n+\n+Source workspace and build docs:\n+\n+    source install/setup.bash\n+    cd src/rclpy/rclpy/docs"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <mutex>"},{"role":"user","content":"-    rclcpp::shutdown();\n+    {\n+      std::lock_guard<std::mutex> guard(shutdown_mutex_);\n+      rclcpp::shutdown();\n+    }"},{"role":"user","content":"-    while (rclcpp::ok()) {\n-      rclcpp::spin_some(lifecycle_node_->get_node_base_interface());\n-      rclcpp::spin_some(lifecycle_client_);\n+    while (true) {\n+      {\n+        std::lock_guard<std::mutex> guard(shutdown_mutex_);\n+        if (!rclcpp::ok()) {\n+          break;\n+        }\n+        rclcpp::spin_some(lifecycle_node_->get_node_base_interface());\n+        rclcpp::spin_some(lifecycle_client_);\n+      }"},{"role":"user","content":"+  std::mutex shutdown_mutex_;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        get_symbol(shared_ptr_callback_));\n+        tracetools::get_symbol(shared_ptr_callback_));"},{"role":"user","content":"-        get_symbol(shared_ptr_with_request_header_callback_));\n+        tracetools::get_symbol(shared_ptr_with_request_header_callback_));"},{"role":"user","content":"-        get_symbol(shared_ptr_callback_));\n+        tracetools::get_symbol(shared_ptr_callback_));"},{"role":"user","content":"-        get_symbol(shared_ptr_with_info_callback_));\n+        tracetools::get_symbol(shared_ptr_with_info_callback_));"},{"role":"user","content":"-        get_symbol(unique_ptr_callback_));\n+        tracetools::get_symbol(unique_ptr_callback_));"},{"role":"user","content":"-        get_symbol(unique_ptr_with_info_callback_));\n+        tracetools::get_symbol(unique_ptr_with_info_callback_));"},{"role":"user","content":"-      get_symbol(callback_));\n+      tracetools::get_symbol(callback_));"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        return ()"},{"role":"user","content":"-    async def _execute_timer(self, tmr, _):\n+    async def _execute_timer(self, tmr):"},{"role":"user","content":"-                return msg_info[0]\n-        return None\n+                if sub._callback_type is Subscription.CallbackType.MessageOnly:\n+                    return (msg_info[0], )\n+                else:\n+                    return msg_info\n+        return ()"},{"role":"user","content":"-    async def _execute_subscription(self, sub, msg):\n-        if msg:\n-            await await_or_execute(sub.callback, msg)\n+    async def _execute_subscription(self, sub, *args):\n+        if args:\n+            await await_or_execute(sub.callback, *args)"},{"role":"user","content":"-            return client.handle.take_response(client.srv_type.Response)\n+            return (client.handle.take_response(client.srv_type.Response), )"},{"role":"user","content":"-        return request_and_header\n+        return (request_and_header, )"},{"role":"user","content":"+        return ()"},{"role":"user","content":"-    async def _execute_guard_condition(self, gc, _):\n+    async def _execute_guard_condition(self, gc):"},{"role":"user","content":"-                    await call_coroutine(entity, arg)\n+                    await call_coroutine(entity, *arg)"},{"role":"user","content":"-                                wt, node, lambda e: e.take_data(), self._execute_waitable)\n+                                wt, node, lambda e: (e.take_data(), ), self._execute_waitable)"},{"role":"user","content":"+from enum import Enum\n+import inspect"},{"role":"user","content":"+    class CallbackType(Enum):\n+        MessageOnly = 0\n+        WithMessageInfo = 1\n+"},{"role":"user","content":"+\n+    @property\n+    def callback(self):\n+        return self._callback\n+\n+    @callback.setter\n+    def callback(self, value):\n+        self._callback = value\n+        self._callback_type = Subscription.CallbackType.MessageOnly\n+        try:\n+            inspect.signature(value).bind(object())\n+            return\n+        except TypeError:\n+            pass\n+        try:\n+            inspect.signature(value).bind(object(), object())\n+            self._callback_type = Subscription.CallbackType.WithMessageInfo\n+            return\n+        except TypeError:\n+            pass\n+        raise RuntimeError(\n+            'Subscription.__init__(): callback should be either be callable with one argument'\n+            '(to get only the message) or two (to get message and message info)')"},{"role":"user","content":"-\n+  py::object pub_seq_number = py::none();\n+  if (message_info.publication_sequence_number != RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED) {\n+    pub_seq_number = py::int_(message_info.publication_sequence_number);\n+  }\n+  py::object rec_seq_number = py::none();\n+  if (message_info.reception_sequence_number != RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED) {\n+    rec_seq_number = py::int_(message_info.reception_sequence_number);\n+  }"},{"role":"user","content":"-      \"received_timestamp\"_a = message_info.received_timestamp));\n+      \"received_timestamp\"_a = message_info.received_timestamp,\n+      \"publication_sequence_number\"_a = pub_seq_number,\n+      \"reception_sequence_number\"_a = rec_seq_number));"},{"role":"user","content":"+from rclpy.subscription import Subscription"},{"role":"user","content":"+\n+\n+def test_subscription_callback_type():\n+    node = Node('test_node', namespace='test_subscription/test_subscription_callback_type')\n+    sub = node.create_subscription(\n+        msg_type=Empty,\n+        topic='test_subscription/test_subscription_callback_type/topic',\n+        qos_profile=10,\n+        callback=lambda _: None)\n+    assert sub._callback_type == Subscription.CallbackType.MessageOnly\n+    sub = node.create_subscription(\n+        msg_type=Empty,\n+        topic='test_subscription/test_subscription_callback_type/topic',\n+        qos_profile=10,\n+        callback=lambda _, _2: None)\n+    assert sub._callback_type == Subscription.CallbackType.WithMessageInfo\n+    with pytest.raises(RuntimeError):\n+        node.create_subscription(\n+            msg_type=Empty,\n+            topic='test_subscription/test_subscription_callback_type/topic',\n+            qos_profile=10,\n+            callback=lambda _, _2, _3: None)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  tf2"},{"role":"user","content":"+#include <geometry_msgs/msg/point.hpp>\n+#include <geometry_msgs/msg/point_stamped.hpp>\n+#include <geometry_msgs/msg/pose.hpp>\n+#include <geometry_msgs/msg/pose_stamped.hpp>\n+#include <geometry_msgs/msg/transform_stamped.hpp>"},{"role":"user","content":"+#include <tf2/transform_datatypes.h>"},{"role":"user","content":"+#include <Eigen/Geometry>\n+"},{"role":"user","content":"-// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented\n-// TEST(TfEigen, ConvertVector3dStamped)\n-// {\n-//   const tf2::Stamped<Eigen::Vector3d> v(Eigen::Vector3d(1,2,3),\n-//     tf2::TimePoint(std::chrono::seconds(5)), \"test\");\n+TEST(TfEigen, ConvertVector3dStamped)\n+{\n+  const tf2::Stamped<Eigen::Vector3d> v(Eigen::Vector3d(1, 2, 3), tf2::TimePoint(\n+      std::chrono::seconds(5)), \"test\");"},{"role":"user","content":"-//   tf2::Stamped<Eigen::Vector3d> v1;\n-//   geometry_msgs::msg::PointStamped p1;\n-//   tf2::convert(v, p1);\n-//   tf2::convert(p1, v1);\n+  tf2::Stamped<Eigen::Vector3d> v1;\n+  geometry_msgs::msg::PointStamped p1;\n+  tf2::convert(v, p1);\n+  tf2::convert(p1, v1);"},{"role":"user","content":"-//   EXPECT_EQ(v, v1);\n-// }\n+  EXPECT_EQ(v, v1);\n+}"},{"role":"user","content":"+// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented"},{"role":"user","content":"-// TEST(TfEigen, ConvertAffine3dStamped)\n-// {\n-//   const Eigen::Affine3d v_nonstamped(\n-//     Eigen::Translation3d(1,2,3) * Eigen::AngleAxis<double>(1, Eigen::Vector3d::UnitX()));\n-//   const tf2::Stamped<Eigen::Affine3d> v(\n-//     v_nonstamped, tf2::TimePoint(std::chrono::seconds(42)), \"test_frame\");\n-\n-//   tf2::Stamped<Eigen::Affine3d> v1;\n-//   geometry_msgs::msg::PoseStamped p1;\n-//   tf2::convert(v, p1);\n-//   tf2::convert(p1, v1);\n-\n-//   EXPECT_EQ(v.translation(), v1.translation());\n-//   EXPECT_EQ(v.rotation(), v1.rotation());\n-//   EXPECT_EQ(v.frame_id_, v1.frame_id_);\n-//   EXPECT_EQ(v.stamp_, v1.stamp_);\n-// }\n+TEST(TfEigen, ConvertAffine3dStamped)\n+{\n+  const Eigen::Affine3d v_nonstamped(Eigen::Translation3d(1, 2, 3) * Eigen::AngleAxis<double>(\n+      1, Eigen::Vector3d::UnitX()));\n+  const tf2::Stamped<Eigen::Affine3d> v(v_nonstamped, tf2::TimePoint(\n+      std::chrono::seconds(42)), \"test_frame\");\n+\n+  tf2::Stamped<Eigen::Affine3d> v1;\n+  geometry_msgs::msg::PoseStamped p1;\n+  tf2::convert(v, p1);\n+  tf2::convert(p1, v1);\n+\n+  EXPECT_EQ(v.translation(), v1.translation());\n+  EXPECT_EQ(v.rotation(), v1.rotation());\n+  EXPECT_EQ(v.frame_id_, v1.frame_id_);\n+  EXPECT_EQ(v.stamp_, v1.stamp_);\n+}"},{"role":"user","content":"+// TODO(clalancette) Re-enable these tests once we have tf2/convert.h:convert(A, B) implemented"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-This package claims to be in the **Quality Level 2** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details.\n+This package claims to be in the **Quality Level 1** category, see the [Quality Declaration](QUALITY_DECLARATION.md) for more details."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-\n-\n-def pytest_launch_collect_makemodule(path, parent, entrypoint):\n-    marks = getattr(entrypoint, 'pytestmark', [])\n-    if marks and any(m.name == 'rostest' for m in marks):\n-        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n-\n-\n-def pytest_configure(config):\n-    config.addinivalue_line(\n-        'markers',\n-        'rostest: mark a generate_test_description function as a ROS launch test entrypoint'\n-    )"},{"role":"user","content":"+# Copyright 2019 Open Source Robotics Foundation, Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+# Only import standard python modules here\n+# This module intentionally delays imports as late as possible to avoid\n+# importing downstream modules in upstream packages when built with a merged\n+# workspace.\n+\n+\n+def pytest_launch_collect_makemodule(path, parent, entrypoint):\n+    marks = getattr(entrypoint, 'pytestmark', [])\n+    if marks and any(m.name == 'rostest' for m in marks):\n+        from launch_testing_ros.pytest.hooks import LaunchROSTestModule\n+        return LaunchROSTestModule.from_parent(parent=parent, fspath=path)\n+\n+\n+def pytest_configure(config):\n+    config.addinivalue_line(\n+        'markers',\n+        'rostest: mark a generate_test_description function as a ROS launch test entrypoint'\n+    )"},{"role":"user","content":"+    py_modules=['launch_testing_ros_pytest_entrypoint'],"},{"role":"user","content":"-        'pytest11': ['launch_ros = launch_testing_ros.pytest.hooks'],\n+        'pytest11': ['launch_ros = launch_testing_ros_pytest_entrypoint'],"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  <build_export_depend>rosidl_core_runtime</build_export_depend>\n+"},{"role":"user","content":"-"},{"role":"user","content":"+  <build_export_depend>rosidl_core_runtime</build_export_depend>\n+"},{"role":"user","content":"+  <build_export_depend>rosidl_core_runtime</build_export_depend>\n+"},{"role":"user","content":"-"},{"role":"user","content":"+  <build_export_depend>rosidl_core_runtime</build_export_depend>\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    'members': None,\n-    'undoc-members': True,\n+    'members': True,  # document members\n+    'undoc-members': True,  # also document members without documentation"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ament_add_gtest(test_node_interfaces__node_base\n+  rclcpp/node_interfaces/test_node_base.cpp)\n+if(TARGET test_node_interfaces__node_base)\n+  target_link_libraries(test_node_interfaces__node_base ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_clock\n+  rclcpp/node_interfaces/test_node_clock.cpp)\n+if(TARGET test_node_interfaces__node_clock)\n+  target_link_libraries(test_node_interfaces__node_clock ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_graph\n+  rclcpp/node_interfaces/test_node_graph.cpp)\n+if(TARGET test_node_interfaces__node_graph)\n+  ament_target_dependencies(\n+    test_node_interfaces__node_graph\n+    \"test_msgs\")\n+  target_link_libraries(test_node_interfaces__node_graph ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_parameters\n+  rclcpp/node_interfaces/test_node_parameters.cpp)\n+if(TARGET test_node_interfaces__node_parameters)\n+  target_link_libraries(test_node_interfaces__node_parameters ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_services\n+  rclcpp/node_interfaces/test_node_services.cpp)\n+if(TARGET test_node_interfaces__node_services)\n+  target_link_libraries(test_node_interfaces__node_services ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_timers\n+  rclcpp/node_interfaces/test_node_timers.cpp)\n+if(TARGET test_node_interfaces__node_timers)\n+  target_link_libraries(test_node_interfaces__node_timers ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_topics\n+  rclcpp/node_interfaces/test_node_topics.cpp)\n+if(TARGET test_node_interfaces__node_topics)\n+  ament_target_dependencies(\n+    test_node_interfaces__node_topics\n+    \"test_msgs\")\n+  target_link_libraries(test_node_interfaces__node_topics ${PROJECT_NAME})\n+endif()\n+ament_add_gtest(test_node_interfaces__node_waitables\n+  rclcpp/node_interfaces/test_node_waitables.cpp)\n+if(TARGET test_node_interfaces__node_waitables)\n+  target_link_libraries(test_node_interfaces__node_waitables ${PROJECT_NAME})\n+endif()"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_base.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+class TestNodeBase : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeBase, construct_from_node)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_base =\n+    dynamic_cast<rclcpp::node_interfaces::NodeBase *>(node->get_node_base_interface().get());\n+  ASSERT_NE(nullptr, node_base);\n+\n+  EXPECT_STREQ(\"node\", node_base->get_name());\n+  EXPECT_STREQ(\"/ns\", node_base->get_namespace());\n+\n+  EXPECT_STREQ(\"/ns/node\", node_base->get_fully_qualified_name());\n+  EXPECT_NE(nullptr, node_base->get_context());\n+  EXPECT_NE(nullptr, node_base->get_rcl_node_handle());\n+  EXPECT_NE(nullptr, node_base->get_shared_rcl_node_handle());\n+\n+  const auto * const_node_base = node_base;\n+  EXPECT_NE(nullptr, const_node_base->get_rcl_node_handle());\n+  EXPECT_NE(nullptr, const_node_base->get_shared_rcl_node_handle());\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+\n+#include \"rclcpp/node_interfaces/node_clock.hpp\"\n+#include \"rclcpp/node.hpp\"\n+\n+class TestNodeClock : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeClock, construct_from_node)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_clock =\n+    dynamic_cast<rclcpp::node_interfaces::NodeClock *>(node->get_node_clock_interface().get());\n+  ASSERT_NE(nullptr, node_clock);\n+  EXPECT_NE(nullptr, node_clock->get_clock());\n+\n+  const auto * const_node_clock = node_clock;\n+  EXPECT_NE(nullptr, const_node_clock->get_clock());\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_base.hpp\"\n+#include \"rclcpp/node_interfaces/node_graph.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+#include \"test_msgs/msg/empty.hpp\"\n+\n+class TestNodeGraph : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeGraph, construct_from_node)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  auto topic_names_and_types = node_graph->get_topic_names_and_types(false);\n+  EXPECT_LT(0u, topic_names_and_types.size());\n+\n+  auto service_names_and_types = node_graph->get_service_names_and_types();\n+  EXPECT_LT(0u, service_names_and_types.size());\n+\n+  auto names = node_graph->get_node_names();\n+  EXPECT_EQ(1u, names.size());\n+\n+  auto names_and_namespaces = node_graph->get_node_names_and_namespaces();\n+  EXPECT_EQ(1u, names_and_namespaces.size());\n+\n+  EXPECT_EQ(0u, node_graph->count_publishers(\"not_a_topic\"));\n+  EXPECT_EQ(0u, node_graph->count_subscribers(\"not_a_topic\"));\n+}\n+\n+TEST_F(TestNodeGraph, get_topic_names_and_types)\n+{\n+  auto node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+  auto topic_names_and_types = node_graph->get_topic_names_and_types();\n+  EXPECT_LT(0u, topic_names_and_types.size());\n+}\n+\n+TEST_F(TestNodeGraph, get_service_names_and_types)\n+{\n+  auto node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+  auto service_names_and_types = node_graph->get_service_names_and_types();\n+  EXPECT_LT(0u, service_names_and_types.size());\n+}\n+\n+TEST_F(TestNodeGraph, get_service_names_and_types_by_node)\n+{\n+  auto node1 = std::make_shared<rclcpp::Node>(\"node1\", \"ns\");\n+  auto node2 = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node1->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  EXPECT_THROW(\n+    node_graph->get_service_names_and_types_by_node(\"not_a_node\", \"not_absolute_namespace\"),\n+    std::runtime_error);\n+  auto service_names_and_types1 = node_graph->get_service_names_and_types_by_node(\"node1\", \"/ns\");\n+  auto service_names_and_types2 = node_graph->get_service_names_and_types_by_node(\"node2\", \"/ns\");\n+  EXPECT_EQ(service_names_and_types1.size(), service_names_and_types2.size());\n+}\n+\n+TEST_F(TestNodeGraph, get_node_names_and_namespaces)\n+{\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  auto names_and_namespaces = node_graph->get_node_names_and_namespaces();\n+  EXPECT_EQ(1u, names_and_namespaces.size());\n+}\n+\n+TEST_F(TestNodeGraph, notify_shutdown)\n+{\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  EXPECT_NO_THROW(node_graph->notify_shutdown());\n+}\n+\n+TEST_F(TestNodeGraph, wait_for_graph_change)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  EXPECT_NO_THROW(node_graph->notify_graph_change());\n+  EXPECT_THROW(\n+    node_graph->wait_for_graph_change(nullptr, std::chrono::milliseconds(1)),\n+    rclcpp::exceptions::InvalidEventError);\n+\n+  auto event = std::make_shared<rclcpp::Event>();\n+  EXPECT_THROW(\n+    node_graph->wait_for_graph_change(event, std::chrono::milliseconds(0)),\n+    rclcpp::exceptions::EventNotRegisteredError);\n+}\n+\n+TEST_F(TestNodeGraph, get_info_by_topic)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  const rclcpp::QoS publisher_qos(1);\n+  auto publisher = node->create_publisher<test_msgs::msg::Empty>(\"topic\", publisher_qos);\n+  auto callback = [](const test_msgs::msg::Empty::SharedPtr) {};\n+\n+  const rclcpp::QoS subscriber_qos(10);\n+  auto subscription =\n+    node->create_subscription<test_msgs::msg::Empty>(\n+    \"topic\", subscriber_qos, std::move(callback));\n+\n+  const auto * node_graph =\n+    dynamic_cast<rclcpp::node_interfaces::NodeGraph *>(node->get_node_graph_interface().get());\n+  ASSERT_NE(nullptr, node_graph);\n+\n+  auto publishers = node_graph->get_publishers_info_by_topic(\"topic\", false);\n+  ASSERT_EQ(1u, publishers.size());\n+\n+  auto publisher_endpoint_info = publishers[0];\n+  const auto const_publisher_endpoint_info = publisher_endpoint_info;\n+  EXPECT_STREQ(\"node\", publisher_endpoint_info.node_name().c_str());\n+  EXPECT_STREQ(\"node\", const_publisher_endpoint_info.node_name().c_str());\n+  EXPECT_STREQ(\"/ns\", publisher_endpoint_info.node_namespace().c_str());\n+  EXPECT_STREQ(\"/ns\", const_publisher_endpoint_info.node_namespace().c_str());\n+  EXPECT_STREQ(\"test_msgs/msg/Empty\", publisher_endpoint_info.topic_type().c_str());\n+  EXPECT_STREQ(\"test_msgs/msg/Empty\", const_publisher_endpoint_info.topic_type().c_str());\n+  EXPECT_EQ(rclcpp::EndpointType::Publisher, publisher_endpoint_info.endpoint_type());\n+  EXPECT_EQ(rclcpp::EndpointType::Publisher, const_publisher_endpoint_info.endpoint_type());\n+\n+  rclcpp::QoS actual_qos = publisher_endpoint_info.qos_profile();\n+  EXPECT_EQ(0u, actual_qos.get_rmw_qos_profile().depth);\n+\n+  rclcpp::QoS const_actual_qos = const_publisher_endpoint_info.qos_profile();\n+  EXPECT_EQ(0u, const_actual_qos.get_rmw_qos_profile().depth);\n+\n+  auto endpoint_gid = publisher_endpoint_info.endpoint_gid();\n+  auto const_endpoint_gid = const_publisher_endpoint_info.endpoint_gid();\n+  bool endpoint_gid_is_all_zeros = true;\n+  for (size_t i = 0; i < RMW_GID_STORAGE_SIZE; ++i) {\n+    endpoint_gid_is_all_zeros &= (endpoint_gid[i] == 0);\n+    EXPECT_EQ(endpoint_gid[i], const_endpoint_gid[i]);\n+  }\n+  EXPECT_FALSE(endpoint_gid_is_all_zeros);\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/**\n+ * NodeParameters is a complicated interface with lots of code, but it is tested elsewhere\n+ * very thoroughly. This currently just includes unittests for the currently uncovered\n+ * functionality.\n+ */\n+\n+#include <gtest/gtest.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_parameters.hpp\"\n+\n+class TestNodeParameters : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeParameters, list_parameters)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_parameters =\n+    dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+    node->get_node_parameters_interface().get());\n+  ASSERT_NE(nullptr, node_parameters);\n+\n+  std::vector<std::string> prefixes;\n+  const auto list_result = node_parameters->list_parameters(prefixes, 1u);\n+\n+  // Currently the only default parameter is 'use_sim_time', but that may change.\n+  size_t number_of_parameters = list_result.names.size();\n+  EXPECT_GE(1u, number_of_parameters);\n+\n+  const std::string parameter_name = \"new_parameter\";\n+  const rclcpp::ParameterValue value(true);\n+  const rcl_interfaces::msg::ParameterDescriptor descriptor;\n+  const auto added_parameter_value =\n+    node_parameters->declare_parameter(parameter_name, value, descriptor, false);\n+  EXPECT_EQ(value.get<bool>(), added_parameter_value.get<bool>());\n+\n+  auto list_result2 = node_parameters->list_parameters(prefixes, 1u);\n+  EXPECT_EQ(number_of_parameters + 1u, list_result2.names.size());\n+\n+  EXPECT_NE(\n+    std::find(list_result2.names.begin(), list_result2.names.end(), parameter_name),\n+    list_result2.names.end());\n+}\n+\n+TEST_F(TestNodeParameters, parameter_overrides)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  auto * node_parameters =\n+    dynamic_cast<rclcpp::node_interfaces::NodeParameters *>(\n+    node->get_node_parameters_interface().get());\n+  ASSERT_NE(nullptr, node_parameters);\n+\n+  const auto & parameter_overrides = node_parameters->get_parameter_overrides();\n+  EXPECT_EQ(0u, parameter_overrides.size());\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_services.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+class TestService : public rclcpp::ServiceBase\n+{\n+public:\n+  explicit TestService(rclcpp::Node * node)\n+  : rclcpp::ServiceBase(node->get_node_base_interface()->get_shared_rcl_node_handle()) {}\n+\n+  std::shared_ptr<void> create_request() override {return nullptr;}\n+  std::shared_ptr<rmw_request_id_t> create_request_header() override {return nullptr;}\n+  void handle_request(std::shared_ptr<rmw_request_id_t>, std::shared_ptr<void>) override {}\n+};\n+\n+class TestClient : public rclcpp::ClientBase\n+{\n+public:\n+  explicit TestClient(rclcpp::Node * node)\n+  : rclcpp::ClientBase(node->get_node_base_interface().get(), node->get_node_graph_interface()) {}\n+\n+  std::shared_ptr<void> create_response() override {return nullptr;}\n+  std::shared_ptr<rmw_request_id_t> create_request_header() override {return nullptr;}\n+  void handle_response(\n+    std::shared_ptr<rmw_request_id_t>, std::shared_ptr<void>) override {}\n+};\n+\n+class TestNodeService : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeService, add_service)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_services =\n+    dynamic_cast<rclcpp::node_interfaces::NodeServices *>(\n+    node->get_node_services_interface().get());\n+  ASSERT_NE(nullptr, node_services);\n+\n+  auto service = std::make_shared<TestService>(node.get());\n+  auto callback_group = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_NO_THROW(\n+    node_services->add_service(service, callback_group));\n+\n+  // Check that adding a service from node to a callback group of different_node throws exception.\n+  std::shared_ptr<rclcpp::Node> different_node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group_in_different_node =\n+    different_node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_THROW(\n+    node_services->add_service(service, callback_group_in_different_node),\n+    std::runtime_error);\n+}\n+\n+TEST_F(TestNodeService, add_client)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_services =\n+    dynamic_cast<rclcpp::node_interfaces::NodeServices *>(\n+    node->get_node_services_interface().get());\n+  ASSERT_NE(nullptr, node_services);\n+\n+  auto client = std::make_shared<TestClient>(node.get());\n+  auto callback_group = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_NO_THROW(node_services->add_client(client, callback_group));\n+\n+  // Check that adding a client from node to a callback group of different_node throws exception.\n+  std::shared_ptr<rclcpp::Node> different_node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group_in_different_node =\n+    different_node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_THROW(\n+    node_services->add_client(client, callback_group_in_different_node),\n+    std::runtime_error);\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_timers.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+class TestTimer : public rclcpp::TimerBase\n+{\n+public:\n+  explicit TestTimer(rclcpp::Node * node)\n+  : TimerBase(node->get_clock(), std::chrono::nanoseconds(1),\n+      node->get_node_base_interface()->get_context()) {}\n+\n+  void execute_callback() override {}\n+  bool is_steady() override {return false;}\n+};\n+\n+class TestNodeTimers : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeTimers, add_timer)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto node_timers =\n+    dynamic_cast<rclcpp::node_interfaces::NodeTimers *>(node->get_node_timers_interface().get());\n+  ASSERT_NE(nullptr, node_timers);\n+  auto timer = std::make_shared<TestTimer>(node.get());\n+  auto callback_group = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_NO_THROW(node_timers->add_timer(timer, callback_group));\n+\n+  // Check that adding timer from node to callback group in different_node throws exception.\n+  std::shared_ptr<rclcpp::Node> different_node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group_in_different_node =\n+    different_node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_THROW(\n+    node_timers->add_timer(timer, callback_group_in_different_node),\n+    std::runtime_error);\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <string>\n+#include <type_traits>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_topics.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+#include \"test_msgs/msg/empty.hpp\"\n+\n+namespace\n+{\n+\n+const rosidl_message_type_support_t EmptyTypeSupport()\n+{\n+  return *rosidl_typesupport_cpp::get_message_type_support_handle<test_msgs::msg::Empty>();\n+}\n+\n+const rcl_publisher_options_t PublisherOptions()\n+{\n+  return rclcpp::PublisherOptionsWithAllocator<std::allocator<void>>().template\n+         to_rcl_publisher_options<test_msgs::msg::Empty>(rclcpp::QoS(10));\n+}\n+\n+const rcl_subscription_options_t SubscriptionOptions()\n+{\n+  return rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>>().template\n+         to_rcl_subscription_options<test_msgs::msg::Empty>(rclcpp::QoS(10));\n+}\n+\n+}  // namespace\n+\n+class TestPublisher : public rclcpp::PublisherBase\n+{\n+public:\n+  explicit TestPublisher(rclcpp::Node * node)\n+  : rclcpp::PublisherBase(\n+      node->get_node_base_interface().get(), \"topic\", EmptyTypeSupport(), PublisherOptions()) {}\n+};\n+\n+class TestSubscription : public rclcpp::SubscriptionBase\n+{\n+public:\n+  explicit TestSubscription(rclcpp::Node * node)\n+  : rclcpp::SubscriptionBase(\n+      node->get_node_base_interface().get(), EmptyTypeSupport(), \"topic\", SubscriptionOptions()) {}\n+  std::shared_ptr<void> create_message() override {return nullptr;}\n+\n+  std::shared_ptr<rclcpp::SerializedMessage>\n+  create_serialized_message() override {return nullptr;}\n+\n+  void handle_message(std::shared_ptr<void> &, const rclcpp::MessageInfo &) override {}\n+  void handle_loaned_message(void *, const rclcpp::MessageInfo &) override {}\n+  void return_message(std::shared_ptr<void> &) override {}\n+  void return_serialized_message(std::shared_ptr<rclcpp::SerializedMessage> &) override {}\n+};\n+\n+class TestNodeTopics : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeTopics, add_publisher)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  // This dynamic cast is not necessary for the unittest itself, but instead is used to ensure\n+  // the proper type is being tested and covered.\n+  auto * node_topics =\n+    dynamic_cast<rclcpp::node_interfaces::NodeTopics *>(node->get_node_topics_interface().get());\n+  ASSERT_NE(nullptr, node_topics);\n+  auto publisher = std::make_shared<TestPublisher>(node.get());\n+  auto callback_group = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_NO_THROW(node_topics->add_publisher(publisher, callback_group));\n+\n+  // Check that adding publisher from node to a callback group in different_node throws exception.\n+  std::shared_ptr<rclcpp::Node> different_node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group_in_different_node =\n+    different_node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_THROW(\n+    node_topics->add_publisher(publisher, callback_group_in_different_node),\n+    std::runtime_error);\n+}\n+\n+TEST_F(TestNodeTopics, add_subscription)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  auto * node_topics =\n+    dynamic_cast<rclcpp::node_interfaces::NodeTopics *>(node->get_node_topics_interface().get());\n+  ASSERT_NE(nullptr, node_topics);\n+  auto subscription = std::make_shared<TestSubscription>(node.get());\n+  auto callback_group = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_NO_THROW(node_topics->add_subscription(subscription, callback_group));\n+\n+  // Check that adding subscription from node to callback group in different_node throws exception.\n+  std::shared_ptr<rclcpp::Node> different_node = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group_in_different_node =\n+    different_node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  EXPECT_THROW(\n+    node_topics->add_subscription(subscription, callback_group_in_different_node),\n+    std::runtime_error);\n+}"},{"role":"user","content":"+// Copyright 2020 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rcl/node_options.h\"\n+#include \"rclcpp/node.hpp\"\n+#include \"rclcpp/node_interfaces/node_waitables.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+class TestWaitable : public rclcpp::Waitable\n+{\n+public:\n+  bool add_to_wait_set(rcl_wait_set_t *) override {return false;}\n+  bool is_ready(rcl_wait_set_t *) override {return false;}\n+  void execute() override {}\n+};\n+\n+class TestNodeWaitables : public ::testing::Test\n+{\n+public:\n+  void SetUp()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  void TearDown()\n+  {\n+    rclcpp::shutdown();\n+  }\n+};\n+\n+TEST_F(TestNodeWaitables, add_remove_waitable)\n+{\n+  std::shared_ptr<rclcpp::Node> node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  auto * node_waitables =\n+    dynamic_cast<rclcpp::node_interfaces::NodeWaitables *>(\n+    node->get_node_waitables_interface().get());\n+  ASSERT_NE(nullptr, node_waitables);\n+\n+  std::shared_ptr<rclcpp::Node> node2 = std::make_shared<rclcpp::Node>(\"node2\", \"ns\");\n+\n+  auto callback_group1 = node->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  auto callback_group2 = node2->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n+  auto waitable = std::make_shared<TestWaitable>();\n+  EXPECT_NO_THROW(\n+    node_waitables->add_waitable(waitable, callback_group1));\n+  EXPECT_THROW(\n+    node_waitables->add_waitable(waitable, callback_group2),\n+    std::runtime_error);\n+  EXPECT_NO_THROW(node_waitables->remove_waitable(waitable, callback_group1));\n+  EXPECT_NO_THROW(node_waitables->remove_waitable(waitable, callback_group2));\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-import multiprocessing\n+import os"},{"role":"user","content":"+import warnings"},{"role":"user","content":"-    :param num_threads: number of worker threads in the pool. If ``None``, the number of threads\n-        will use :func:`multiprocessing.cpu_count`. If that's not implemented the number of threads\n-        defaults to 1.\n+    :param num_threads: number of worker threads in the pool.\n+        If ``None``, the number of threads will be automatically set by querying the underlying OS\n+        for the CPU affinity of the process space.\n+        If the OS doesn't provide this information, defaults to 2."},{"role":"user","content":"-            try:\n-                num_threads = multiprocessing.cpu_count()\n-            except NotImplementedError:\n-                num_threads = 1\n+            # On Linux, it will try to use the number of CPU this process has access to.\n+            # Other platforms, os.sched_getaffinity() doesn't exist so we use the number of CPUs.\n+            if hasattr(os, 'sched_getaffinity'):\n+                num_threads = len(os.sched_getaffinity(0))\n+            else:\n+                num_threads = os.cpu_count()\n+            # The calls above may still return None if they aren't supported\n+            if num_threads is None:\n+                num_threads = 2\n+        if num_threads == 1:\n+            warnings.warn(\n+                'MultiThreadedExecutor is used with a single thread.\\n'\n+                'Use the SingleThreadedExecutor instead.')"},{"role":"user","content":"+import os"},{"role":"user","content":"+import warnings"},{"role":"user","content":"+    def test_multi_threaded_executor_num_threads(self):\n+        self.assertIsNotNone(self.node.handle)\n+\n+        # check default behavior, either platform configuration or defaults to 2\n+        executor = MultiThreadedExecutor(context=self.context)\n+        if hasattr(os, 'sched_getaffinity'):\n+            platform_threads = len(os.sched_getaffinity(0))\n+        else:\n+            platform_threads = os.cpu_count()\n+        self.assertEqual(platform_threads, executor._executor._max_workers)\n+        executor.shutdown()\n+\n+        # check specified thread number w/o warning\n+        executor = MultiThreadedExecutor(num_threads=3, context=self.context)\n+        self.assertEqual(3, executor._executor._max_workers)\n+        executor.shutdown()\n+\n+        # check specified thread number = 1, expecting UserWarning\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter('always', category=UserWarning)\n+            executor = MultiThreadedExecutor(num_threads=1, context=self.context)\n+            self.assertEqual(1, executor._executor._max_workers)\n+            executor.shutdown()\n+            assert len(w) == 1\n+            assert issubclass(w[0].category, UserWarning)\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"- * \\brief Restrict a value between two bounds\n+ *  \\brief Restrict a value between two bounds."},{"role":"user","content":"-/// If v compares less than lo, returns lo; otherwise if hi compares less\n-//  than v, returns hi; otherwise returns v. Uses operator< to compare the values"},{"role":"user","content":"- * \\param[in] v the value to clamp\n- * \\param[in] lo the lower boundary\n- * \\param[in] hi the higher boundary\n+ * If v compares less than lo, returns lo; otherwise if hi compares less\n+ * than v, returns hi; otherwise returns v. Uses operator< to compare the values.\n+ *\n+ * \\param[in] v The value to clamp.\n+ * \\param[in] lo The lower boundary.\n+ * \\param[in] hi The higher boundary."},{"role":"user","content":"- * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp\n+ * \\note Implementation from https://en.cppreference.com/w/cpp/algorithm/clamp."},{"role":"user","content":"- *  a dangling reference if that parameter is returned\n- **/\n+ *  a dangling reference if that parameter is returned.\n+ */"},{"role":"user","content":"-/// Like the function above, but uses comp to compare the values."},{"role":"user","content":"+ * Performs clamping with a provided Comparison object (comp).\n+ *\n+ * \\param[in] v The value to clamp.\n+ * \\param[in] lo The lower boundary.\n+ * \\param[in] hi The higher boundary."},{"role":"user","content":"- * less than the second\n- **/\n+ * less than the second.\n+ * \\return Reference to lo if v is less than lo, reference to hi if hi is less than v, otherwise\n+ * reference to v.\n+ * \\sa rcppmath::clamp(const T&, const T&, const T&)\n+ */"},{"role":"user","content":"- * \\brief Simplification of boost::accumulators::accumulator_set<double,\n- *  bacc::stats<bacc::tag::rolling_mean>> to avoid dragging boost dependencies\n+ * \\brief Computes the mean of the last accumulated elements."},{"role":"user","content":"- * Computes the mean of the last accumulated elements\n+ * This is a simplified version of boost's rolling mean accumulator,\n+ * written to avoid dragging in boost dependencies."},{"role":"user","content":"+  /**\n+   * Constructs the rolling mean accumulator with a specified window size.\n+   *\n+   * \\param[in] rolling_window_size The unsigned integral length of the accumulator's window length.\n+   */"},{"role":"user","content":"+  /**\n+   * Collects the provided value in the accumulator's buffer.\n+   *\n+   * \\param[in] val The value to accumulate.\n+   */"},{"role":"user","content":"+  /**\n+   * Calculates the rolling mean accumulated insofar.\n+   *\n+   * \\return Rolling mean of the accumulated values.\n+   */"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  RCLCPP_PUBLIC\n-  Logger(const Logger &) = default;\n-"},{"role":"user","content":"-  const auto get_callback_vector = [this](auto & mutex, auto & callback_set) {\n+  const auto get_callback_vector = [](auto & mutex, auto & callback_set) {"},{"role":"user","content":"+          (void)total;"},{"role":"user","content":"-  use_take_shared_method() const\n+  use_take_shared_method() const override"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+typedef enum\n+{\n+  NONE,\n+  SINGLE_THREADED,\n+  MULTI_THREADED,\n+  NON_POSIX,\n+} rclc_executor_type_t;\n+"},{"role":"user","content":"+/// function pointer specification\n+typedef struct rclc_executor_t_s rclc_executor_t;\n+typedef rcl_ret_t (* rclc_executor_func_t)(rclc_executor_t *);\n+"},{"role":"user","content":"-typedef struct\n+struct rclc_executor_t_s"},{"role":"user","content":"+  /// Type of Executor\n+  rclc_executor_type_t type;"},{"role":"user","content":"-} rclc_executor_t;\n+  /// pointer to custom executor data structure\n+  void * custom;\n+};"},{"role":"user","content":"+  /// pointer to custom handle\n+  void * custom;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    std::weak_ptr<rcl_node_t> weak_node_handle(node_handle_);"},{"role":"user","content":"-      new rcl_service_t, [weak_node_handle, service_name](rcl_service_t * service)\n+      new rcl_service_t, [handle = node_handle_, service_name](rcl_service_t * service)"},{"role":"user","content":"-        auto handle = weak_node_handle.lock();\n-        if (handle) {\n-          if (rcl_service_fini(service, handle.get()) != RCL_RET_OK) {\n-            RCLCPP_ERROR(\n-              rclcpp::get_node_logger(handle.get()).get_child(\"rclcpp\"),\n-              \"Error in destruction of rcl service handle: %s\",\n-              rcl_get_error_string().str);\n-            rcl_reset_error();\n-          }\n-        } else {\n-          RCLCPP_ERROR_STREAM(\n-            rclcpp::get_logger(\"rclcpp\"),\n-            \"Error in destruction of rcl service handle \" << service_name <<\n-              \": the Node Handle was destructed too early. You will leak memory\");\n+        if (rcl_service_fini(service, handle.get()) != RCL_RET_OK) {\n+          RCLCPP_ERROR(\n+            rclcpp::get_node_logger(handle.get()).get_child(\"rclcpp\"),\n+            \"Error in destruction of rcl service handle: %s\",\n+            rcl_get_error_string().str);\n+          rcl_reset_error();"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclpy/qos.cpp"},{"role":"user","content":"+\n+\n+QoSCompatibility = _rclpy.QoSCompatibility\n+\n+\n+def qos_check_compatible(publisher_qos: QoSProfile, subscription_qos: QoSProfile):\n+    \"\"\"\n+    Check if two QoS profiles are compatible.\n+\n+    Two QoS profiles are compatible if a publisher and subscription\n+    using the QoS policies can communicate with each other.\n+\n+    If any policies have value \"system default\" or \"unknown\" then it is possible that\n+    compatibility cannot be determined.\n+    In this case, the value QoSCompatility.WARNING is set as part of\n+    the returned structure.\n+    \"\"\"\n+    result = _rclpy.rclpy_qos_check_compatible(\n+        publisher_qos.get_c_qos_profile(),\n+        subscription_qos.get_c_qos_profile()\n+    )\n+    compatibility = QoSCompatibility(\n+        result.compatibility\n+    )\n+    reason = result.reason\n+    return compatibility, reason"},{"role":"user","content":"+#include \"qos.hpp\""},{"role":"user","content":"+  py::enum_<rmw_qos_compatibility_type_t>(m, \"QoSCompatibility\")\n+  .value(\"OK\", RMW_QOS_COMPATIBILITY_OK)\n+  .value(\"WARNING\", RMW_QOS_COMPATIBILITY_WARNING)\n+  .value(\"ERROR\", RMW_QOS_COMPATIBILITY_ERROR);\n+\n+  py::class_<rclpy::QoSCheckCompatibleResult>(\n+    m, \"QoSCheckCompatibleResult\",\n+    \"Result type for checking QoS compatibility with result\")\n+  .def(py::init<>())\n+  .def_readonly(\"compatibility\", &rclpy::QoSCheckCompatibleResult::compatibility)\n+  .def_readonly(\"reason\", &rclpy::QoSCheckCompatibleResult::reason);\n+"},{"role":"user","content":"+  m.def(\n+    \"rclpy_qos_check_compatible\", &rclpy::qos_check_compatible,\n+    \"Check if two QoS profiles are compatible.\");\n+"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Include pybind11 before rclpy_common/handle.h includes Python.h\n+\n+#include <rmw/error_handling.h>\n+#include <rmw/incompatible_qos_events_statuses.h>\n+#include <rmw/qos_profiles.h>\n+#include <rmw/types.h>\n+\n+#include <pybind11/pybind11.h>\n+\n+#include \"qos.hpp\"\n+#include \"rclpy_common/exceptions.hpp\"\n+\n+namespace rclpy\n+{\n+\n+QoSCheckCompatibleResult\n+qos_check_compatible(\n+  const py::capsule & publisher_qos_profile,\n+  const py::capsule & subscription_qos_profile\n+)\n+{\n+  if (0 != strcmp(\"rmw_qos_profile_t\", publisher_qos_profile.name())) {\n+    throw py::value_error(\"capsule is not an rmw_qos_profile_t\");\n+  }\n+  auto publisher_qos_profile_ = static_cast<rmw_qos_profile_t *>(publisher_qos_profile);\n+\n+  if (0 != strcmp(\"rmw_qos_profile_t\", subscription_qos_profile.name())) {\n+    throw py::value_error(\"capsule is not an rmw_qos_profile_t\");\n+  }\n+  auto subscription_qos_profile_ = static_cast<rmw_qos_profile_t *>(subscription_qos_profile);\n+\n+  QoSCheckCompatibleResult result;\n+  rmw_ret_t ret = rmw_qos_profile_check_compatible(\n+    *publisher_qos_profile_,\n+    *subscription_qos_profile_,\n+    &result.compatibility,\n+    result.reason,\n+    sizeof(QoSCheckCompatibleResult::reason));\n+\n+  if (RMW_RET_OK != ret) {\n+    throw RMWError(\"failed to check if qos profiles are compatible\");\n+  }\n+\n+  return result;\n+}\n+\n+}  // namespace rclpy"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLPY__QOS_HPP_\n+#define RCLPY__QOS_HPP_\n+\n+#include <rmw/qos_profiles.h>\n+\n+#include <pybind11/pybind11.h>\n+\n+\n+namespace py = pybind11;\n+\n+namespace rclpy\n+{\n+\n+/// Result type for checking QoS compatibility\n+/**\n+ * \\see rclpy::qos_check_compatible()\n+ */\n+struct QoSCheckCompatibleResult\n+{\n+  /// Compatibility result.\n+  rmw_qos_compatibility_type_t compatibility;\n+\n+  /// Reason for a (possible) incompatibility.\n+  /**\n+   * Set if compatiblity is RMW_QOS_COMPATIBILITY_WARNING or RMW_QOS_COMPATIBILITY_ERROR.\n+   * Not set if the QoS profiles are compatible.\n+   */\n+  char reason[2048];\n+};\n+\n+/// Check if two QoS profiles are compatible.\n+/**\n+ * Two QoS profiles are compatible if a publisher and subcription\n+ * using the QoS policies can communicate with each other.\n+ *\n+ * If any policies have value \"system default\" or \"unknown\" then it is possible that\n+ * compatiblity cannot be determined.\n+ * In this case, the value RMW_QOS_COMPATIBILITY_WARNING is set as part of\n+ * the returned structure.\n+ *\n+ * \\param[in] publisher_qos_profile: The QoS profile for a publisher.\n+ * \\param[in] subscription_qos_profile: The QoS profile for a subscription.\n+ * \\return Struct with compatiblity set to RMW_QOS_COMPATIBILITY_OK if the QoS profiles are\n+ *   compatible, or\n+ * \\return Struct with compatibility set to RMW_QOS_COMPATIBILITY_WARNING if there is a chance\n+ *   the QoS profiles are not compatible, or\n+ * \\return Struct with compatibility set to RMW_QOS_COMPATIBILITY_ERROR if the QoS profiles are\n+ *   not compatible.\n+ * \\throws RMWError if an unexpected error occurs.\n+ */\n+QoSCheckCompatibleResult\n+qos_check_compatible(\n+  const py::capsule & publisher_qos_profile,\n+  const py::capsule & subscription_qos_profile\n+);\n+\n+}  // namespace rclpy\n+\n+#endif  // RCLPY__QOS_HPP_"},{"role":"user","content":"+from rclpy.qos import qos_check_compatible"},{"role":"user","content":"+from rclpy.qos import QoSCompatibility"},{"role":"user","content":"+\n+\n+class TestCheckQosCompatibility(unittest.TestCase):\n+\n+    def test_compatible(self):\n+        qos = QoSProfile(\n+            depth=1,\n+            reliability=QoSReliabilityPolicy.RELIABLE,\n+            durability=QoSDurabilityPolicy.VOLATILE,\n+            lifespan=Duration(seconds=1),\n+            deadline=Duration(seconds=1),\n+            liveliness=QoSLivelinessPolicy.AUTOMATIC,\n+            liveliness_lease_duration=Duration(seconds=1),\n+        )\n+        compatibility, reason = qos_check_compatible(\n+            qos, qos\n+        )\n+\n+        assert compatibility == QoSCompatibility.OK\n+        assert reason == ''\n+\n+    def test_incompatible(self):\n+        \"\"\"\n+        This test is assuming a DDS implementation.\n+\n+        It's possible that a \"best effort\" publisher and \"reliable\"\n+        subscription is a valid match in a non-DDS implementation.\n+        \"\"\"\n+        pub_qos = QoSProfile(\n+            depth=1,\n+            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n+        )\n+        sub_qos = QoSProfile(\n+            depth=1,\n+            reliability=QoSReliabilityPolicy.RELIABLE,\n+        )\n+\n+        compatibility, reason = qos_check_compatible(\n+            pub_qos, sub_qos\n+        )\n+\n+        assert compatibility == QoSCompatibility.ERROR\n+        assert reason != ''\n+\n+    def test_warn_of_possible_incompatibility(self):\n+        \"\"\"\n+        This test is assuming a DDS implementation.\n+\n+        It's possible that a \"best effort\" publisher and \"reliable\"\n+        subscription is a valid match in a non-DDS implementation.\n+        \"\"\"\n+        pub_qos = QoSPresetProfiles.SYSTEM_DEFAULT.value\n+        sub_qos = QoSProfile(\n+            depth=1,\n+            reliability=QoSReliabilityPolicy.RELIABLE,\n+        )\n+        compatibility, reason = qos_check_compatible(\n+            pub_qos, sub_qos\n+        )\n+\n+        assert compatibility == QoSCompatibility.WARNING\n+        assert reason != ''"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  <test_depend>mimick_vendor</test_depend>\n-  <test_depend>rcpputils</test_depend>\n-  <test_depend>rmw</test_depend>\n-  <test_depend>rmw_implementation_cmake</test_depend>"},{"role":"user","content":"+  <test_depend>mimick_vendor</test_depend>"},{"role":"user","content":"+  <test_depend>rcpputils</test_depend>\n+  <test_depend>rmw</test_depend>\n+  <test_depend>rmw_implementation_cmake</test_depend>"},{"role":"user","content":"+find_package(mimick_vendor REQUIRED)"},{"role":"user","content":"-    LIBRARIES ${PROJECT_NAME}\n+    LIBRARIES ${PROJECT_NAME} mimick"},{"role":"user","content":"-  : proxy_(proxy)\n+  : target_(target), proxy_(proxy)"},{"role":"user","content":"-    auto MMK_MANGLE(mock_type, create) =\n-      PatchTraits<ID, ReturnT(ArgTs...)>::MMK_MANGLE(mock_type, create);\n-    mock_ = mmk_mock(target.c_str(), mock_type);"},{"role":"user","content":"-    auto type_erased_trampoline =\n-      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n-    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+    replace_with(replacement);"},{"role":"user","content":"-    auto type_erased_trampoline =\n-      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n-    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+    replace_with(replacement);"},{"role":"user","content":"-  mock_type mock_;\n+  void replace_with(std::function<ReturnT(ArgTs...)> replacement)\n+  {\n+    if (mock_) {\n+      throw std::logic_error(\"Cannot configure patch more than once\");\n+    }\n+    auto type_erased_trampoline =\n+      reinterpret_cast<mmk_fn>(prepare_trampoline<ID>(replacement));\n+    auto MMK_MANGLE(mock_type, create) =\n+      PatchTraits<ID, ReturnT(ArgTs...)>::MMK_MANGLE(mock_type, create);\n+    mock_ = mmk_mock(target_.c_str(), mock_type);\n+    mmk_when(proxy_(any<ArgTs>()...), .then_call = type_erased_trampoline);\n+  }\n+\n+  mock_type mock_{nullptr};\n+  std::string target_;"},{"role":"user","content":"-/// Patch a `function` with a used-provided `replacement` in a given `scope`.\n-#define patch(scope, function, replacement) \\\n+/// Prepare a mocking_utils::Patch for patching a `function` in a given `scope`\n+/// but defer applying any changes.\n+#define prepare_patch(scope, function) \\"},{"role":"user","content":"-  ).then_call(replacement)\n+  )"},{"role":"user","content":"-/// Patch a function with a function that only returns a value\n-#define patch_and_return(scope, function, return_value) \\\n-  patch(scope, function, [&](auto && ...) {return return_value;})\n+/// Patch a `function` with a used-provided `replacement` in a given `scope`.\n+#define patch(scope, function, replacement) \\\n+  prepare_patch(scope, function).then_call(replacement)\n+\n+/// Patch a `function` to always yield a given `return_code` in a given `scope`.\n+#define patch_and_return(scope, function, return_code) \\\n+  patch(scope, function, [&](auto && ...) {return return_code;})\n+\n+/// Patch a `function` to execute normally but always yield a given `return_code`\n+/// in a given `scope`.\n+#define inject_on_return(scope, function, return_code) \\\n+  patch( \\\n+    scope, function, ([&, base = function](auto && ... __args) { \\\n+      static_cast<void>(base(std::forward<decltype(__args)>(__args)...)); \\\n+      return return_code; \\\n+    }))"},{"role":"user","content":"+#include \"rmw/rmw.h\"\n+#include \"rmw/validate_full_topic_name.h\""},{"role":"user","content":"+#include \"../mocking_utils/patch.hpp\""},{"role":"user","content":"-    const char * name = \"test_subscription_node\";\n+    constexpr char name[] = \"test_subscription_node\";"},{"role":"user","content":"-  const char * topic = \"chatter\";\n-  const char * expected_topic = \"/chatter\";\n+  constexpr char topic[] = \"chatter\";\n+  constexpr char expected_topic[] = \"/chatter\";"},{"role":"user","content":"+// Define dummy comparison operators for rcutils_allocator_t type\n+// to use with the Mimick mocking library\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, ==)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, !=)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, <)\n+MOCKING_UTILS_BOOL_OPERATOR_RETURNS_FALSE(rcutils_allocator_t, >)\n+"},{"role":"user","content":"-  const char * topic = \"/chatter\";\n+  constexpr char topic[] = \"/chatter\";"},{"role":"user","content":"+  rcl_reset_error();\n+"},{"role":"user","content":"+  rcl_reset_error();"},{"role":"user","content":"+"},{"role":"user","content":"-  rcl_subscription_options_t bad_subscription_options = rcl_subscription_get_default_options();\n-  bad_subscription_options.allocator = get_failing_allocator();\n-  ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &bad_subscription_options);\n+  {\n+    rcutils_ret_t rcutils_string_map_init_returns = RCUTILS_RET_BAD_ALLOC;\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rcl\", rcutils_string_map_init, rcutils_string_map_init_returns);\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_BAD_ALLOC, ret);\n+    rcl_reset_error();\n+\n+    rcutils_string_map_init_returns = RCUTILS_RET_ERROR;\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_ERROR, ret);\n+    rcl_reset_error();\n+  }\n+  {\n+    auto mock =\n+      mocking_utils::inject_on_return(\"lib:rcl\", rcutils_string_map_fini, RCUTILS_RET_ERROR);\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_ERROR, ret);\n+    rcl_reset_error();\n+  }\n+  {\n+    rmw_ret_t rmw_validate_full_topic_name_returns = RMW_RET_OK;\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_validate_full_topic_name,\n+      [&](auto, int * result, auto) {\n+        *result = RMW_TOPIC_INVALID_TOO_LONG;\n+        return rmw_validate_full_topic_name_returns;\n+      });\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_TOPIC_NAME_INVALID, ret);\n+    rcl_reset_error();\n+\n+    rmw_validate_full_topic_name_returns = RMW_RET_ERROR;\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_ERROR, ret);\n+    rcl_reset_error();\n+  }\n+  {\n+    auto mock =\n+      mocking_utils::patch_and_return(\"lib:rcl\", rmw_create_subscription, nullptr);\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_ERROR, ret);\n+    rcl_reset_error();\n+  }\n+  {\n+    auto mock =\n+      mocking_utils::patch_and_return(\"lib:rcl\", rmw_subscription_get_actual_qos, RMW_RET_ERROR);\n+    ret = rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+    EXPECT_EQ(RCL_RET_ERROR, ret);\n+    rcl_reset_error();\n+  }"},{"role":"user","content":"+  EXPECT_EQ(RCL_RET_SUBSCRIPTION_INVALID, rcl_subscription_fini(nullptr, this->node_ptr));\n+  rcl_reset_error();"},{"role":"user","content":"-  ret = rcl_subscription_fini(&subscription, this->node_ptr);\n-  EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  auto mock =\n+    mocking_utils::inject_on_return(\"lib:rcl\", rmw_destroy_subscription, RMW_RET_ERROR);\n+  EXPECT_EQ(RCL_RET_ERROR, rcl_subscription_fini(&subscription, this->node_ptr));\n+  rcl_reset_error();\n+\n+  // Make sure finalization completed anyways.\n+  ASSERT_EQ(NULL, subscription.impl);"},{"role":"user","content":"-  const char * topic = \"/chatter\";\n+  constexpr char topic[] = \"/chatter\";"},{"role":"user","content":"-  const char * topic = \"rcl_test_subscription_nominal_string_chatter\";\n+  constexpr char topic[] = \"rcl_test_subscription_nominal_string_chatter\";"},{"role":"user","content":"-  const char * test_string = \"testing\";\n+  constexpr char test_string[] = \"testing\";"},{"role":"user","content":"-  const char * topic = \"rcl_test_subscription_nominal_string_sequence_chatter\";\n+  constexpr char topic[] = \"rcl_test_subscription_nominal_string_sequence_chatter\";"},{"role":"user","content":"-  const char * test_string = \"testing\";\n+  constexpr char test_string[] = \"testing\";"},{"role":"user","content":"-  const char * topic = \"/chatterSer\";\n+  constexpr char topic[] = \"/chatterSer\";"},{"role":"user","content":"-  const char * test_string = \"testing\";\n+  constexpr char test_string[] = \"testing\";"},{"role":"user","content":"-  const char * topic = \"rcl_loan\";\n+  constexpr char topic[] = \"rcl_loan\";"},{"role":"user","content":"-    test_msgs__msg__Strings msg;\n-    test_msgs__msg__Strings * msg_loaned;\n-    test_msgs__msg__Strings__init(&msg);\n-    OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n-    {\n-      test_msgs__msg__Strings__fini(&msg);\n-    });\n-\n-    // Only if rmw supports the functionality\n-    if (rcl_subscription_can_loan_messages(&subscription)) {\n-      ret = rcl_take_loaned_message(\n-        &subscription, reinterpret_cast<void **>(&msg_loaned), nullptr, nullptr);\n-      ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-      ASSERT_EQ(\n-        std::string(test_string),\n-        std::string(msg_loaned->string_value.data, msg_loaned->string_value.size));\n-    } else {\n-      ret = rcl_take(&subscription, &msg, nullptr, nullptr);\n-      ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n-      ASSERT_EQ(\n-        std::string(test_string), std::string(msg.string_value.data, msg.string_value.size));\n+    auto patch_take =\n+      mocking_utils::prepare_patch(\"lib:rcl\", rmw_take_loaned_message_with_info);\n+    auto patch_return =\n+      mocking_utils::prepare_patch(\"lib:rcl\", rmw_return_loaned_message_from_subscription);\n+\n+    if (!rcl_subscription_can_loan_messages(&subscription)) {\n+      // If rcl (and ultimately rmw) does not support message loaning,\n+      // mock it so that a unit test can still be constructed.\n+      patch_take.then_call(\n+        [](auto sub, void ** loaned_message, auto taken, auto msg_info, auto allocation) {\n+          auto msg = new(std::nothrow) test_msgs__msg__Strings{};\n+          if (!msg) {\n+            return RMW_RET_BAD_ALLOC;\n+          }\n+          test_msgs__msg__Strings__init(msg);\n+          *loaned_message = static_cast<void *>(msg);\n+          rmw_ret_t ret = rmw_take_with_info(sub, *loaned_message, taken, msg_info, allocation);\n+          if (RMW_RET_OK != ret) {\n+            delete msg;\n+          }\n+          return ret;\n+        });\n+      patch_return.then_call(\n+        [](auto, void * loaned_message) {\n+          auto msg = reinterpret_cast<test_msgs__msg__Strings *>(loaned_message);\n+          test_msgs__msg__Strings__fini(msg);\n+          delete msg;\n+\n+          return RMW_RET_OK;\n+        });"},{"role":"user","content":"+\n+    test_msgs__msg__Strings * msg_loaned = nullptr;\n+    ret = rcl_take_loaned_message(\n+      &subscription, reinterpret_cast<void **>(&msg_loaned), nullptr, nullptr);\n+    ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+    EXPECT_EQ(\n+      std::string(test_string),\n+      std::string(msg_loaned->string_value.data, msg_loaned->string_value.size));\n+    ret = rcl_return_loaned_message_from_subscription(&subscription, msg_loaned);\n+    EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  }\n+}\n+\n+/* Test for all failure modes in subscription take with loaned messages function.\n+ */\n+TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_bad_take_loaned_message) {\n+  constexpr char topic[] = \"rcl_loan\";\n+  const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n+  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n+\n+  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n+  rmw_ret_t ret = rcl_subscription_init(\n+    &subscription, this->node_ptr, ts, topic,\n+    &subscription_options);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  test_msgs__msg__Strings * loaned_message = nullptr;\n+  void ** type_erased_loaned_message_pointer = reinterpret_cast<void **>(&loaned_message);\n+  rmw_message_info_t * message_info = nullptr;  // is a valid argument\n+  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID, rcl_take_loaned_message(\n+      nullptr, type_erased_loaned_message_pointer, message_info, allocation));\n+  rcl_reset_error();\n+\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_take_loaned_message(&subscription, nullptr, message_info, allocation));\n+  rcl_reset_error();\n+\n+  test_msgs__msg__Strings dummy_message;\n+  loaned_message = &dummy_message;\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT, rcl_take_loaned_message(\n+      &subscription, type_erased_loaned_message_pointer, message_info, allocation));\n+  rcl_reset_error();\n+  loaned_message = nullptr;\n+\n+  {\n+    rmw_ret_t rmw_take_loaned_message_with_info_returns = RMW_RET_OK;\n+    auto mock = mocking_utils::patch(\n+      \"lib:rcl\", rmw_take_loaned_message_with_info,\n+      [&](auto, auto, bool * taken, auto && ...) {\n+        *taken = false;\n+        return rmw_take_loaned_message_with_info_returns;\n+      });\n+\n+    EXPECT_EQ(\n+      RCL_RET_SUBSCRIPTION_TAKE_FAILED, rcl_take_loaned_message(\n+        &subscription, type_erased_loaned_message_pointer, message_info, allocation));\n+    rcl_reset_error();\n+\n+    rmw_take_loaned_message_with_info_returns = RMW_RET_BAD_ALLOC;\n+    EXPECT_EQ(\n+      RCL_RET_BAD_ALLOC, rcl_take_loaned_message(\n+        &subscription, type_erased_loaned_message_pointer, message_info, allocation));\n+    rcl_reset_error();\n+\n+    rmw_take_loaned_message_with_info_returns = RMW_RET_UNSUPPORTED;\n+    EXPECT_EQ(\n+      RCL_RET_UNSUPPORTED, rcl_take_loaned_message(\n+        &subscription, type_erased_loaned_message_pointer, message_info, allocation));\n+    rcl_reset_error();\n+\n+    rmw_take_loaned_message_with_info_returns = RMW_RET_ERROR;\n+    EXPECT_EQ(\n+      RCL_RET_ERROR, rcl_take_loaned_message(\n+        &subscription, type_erased_loaned_message_pointer, message_info, allocation));\n+    rcl_reset_error();"},{"role":"user","content":"+\n+  EXPECT_EQ(\n+    RCL_RET_OK,\n+    rcl_subscription_fini(&subscription, this->node_ptr)) << rcl_get_error_string().str;\n+}\n+\n+/* Test for all failure modes in subscription return loaned messages function.\n+ */\n+TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_bad_return_loaned_message) {\n+  constexpr char topic[] = \"rcl_loan\";\n+  const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, Strings);\n+  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n+  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n+  test_msgs__msg__Strings dummy_message;\n+  test_msgs__msg__Strings__init(&dummy_message);\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    test_msgs__msg__Strings__fini(&dummy_message);\n+  });\n+  void * loaned_message = &dummy_message;\n+\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID,\n+    rcl_return_loaned_message_from_subscription(nullptr, loaned_message));\n+  rcl_reset_error();\n+\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID,\n+    rcl_return_loaned_message_from_subscription(&subscription, loaned_message));\n+  rcl_reset_error();\n+\n+  rmw_ret_t ret = rcl_subscription_init(\n+    &subscription, this->node_ptr, ts, topic,\n+    &subscription_options);\n+  ASSERT_EQ(RMW_RET_OK, ret) << rcl_get_error_string().str;\n+\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT, rcl_return_loaned_message_from_subscription(&subscription, nullptr));\n+  rcl_reset_error();\n+\n+  {\n+    rmw_ret_t rmw_return_loaned_message_from_subscription_returns = RMW_RET_OK;\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rcl\", rmw_return_loaned_message_from_subscription,\n+      rmw_return_loaned_message_from_subscription_returns);\n+\n+    EXPECT_EQ(\n+      RCL_RET_OK, rcl_return_loaned_message_from_subscription(&subscription, loaned_message)) <<\n+      rcl_get_error_string().str;\n+\n+    rmw_return_loaned_message_from_subscription_returns = RMW_RET_UNSUPPORTED;\n+    EXPECT_EQ(\n+      RCL_RET_UNSUPPORTED, rcl_return_loaned_message_from_subscription(\n+        &subscription,\n+        loaned_message));\n+    rcl_reset_error();\n+\n+    rmw_return_loaned_message_from_subscription_returns = RMW_RET_ERROR;\n+    EXPECT_EQ(\n+      RCL_RET_ERROR, rcl_return_loaned_message_from_subscription(&subscription, loaned_message));\n+    rcl_reset_error();\n+  }\n+\n+  EXPECT_EQ(\n+    RCL_RET_OK,\n+    rcl_subscription_fini(&subscription, this->node_ptr)) << rcl_get_error_string().str;"},{"role":"user","content":"-  const char * topic = \"test_get_options\";\n+  constexpr char topic[] = \"test_get_options\";"},{"role":"user","content":"+  rmw_ret_t rmw_take_with_info_returns = RMW_RET_OK;\n+  auto mock = mocking_utils::patch(\n+    \"lib:rcl\", rmw_take_with_info,\n+    [&](auto, auto, bool * taken, auto...) {\n+      *taken = false;\n+      return rmw_take_with_info_returns;\n+    });\n+"},{"role":"user","content":"+\n+  rmw_take_with_info_returns = RMW_RET_BAD_ALLOC;\n+  EXPECT_EQ(\n+    RCL_RET_BAD_ALLOC, rcl_take(&subscription, &msg, &message_info, nullptr));\n+  rcl_reset_error();\n+\n+  rmw_take_with_info_returns = RMW_RET_ERROR;\n+  EXPECT_EQ(\n+    RCL_RET_ERROR, rcl_take(&subscription, &msg, &message_info, nullptr));\n+  rcl_reset_error();"},{"role":"user","content":"-  size_t initial_capacity_ser = 0u;\n+  size_t initial_serialization_capacity = 0u;"},{"role":"user","content":"-      &serialized_msg, initial_capacity_ser, &allocator)) << rcl_get_error_string().str;\n+      &serialized_msg, initial_serialization_capacity, &allocator)) <<\n+    rcl_get_error_string().str;"},{"role":"user","content":"+  rmw_message_info_t * message_info = nullptr;  // is a valid argument\n+  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument"},{"role":"user","content":"-    rcl_take_serialized_message(nullptr, &serialized_msg, nullptr, nullptr));\n+    rcl_take_serialized_message(nullptr, &serialized_msg, message_info, allocation));"},{"role":"user","content":"-    rcl_take_serialized_message(&subscription_zero_init, &serialized_msg, nullptr, nullptr));\n+    rcl_take_serialized_message(\n+      &subscription_zero_init, &serialized_msg,\n+      message_info, allocation));"},{"role":"user","content":"+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_take_serialized_message(&subscription, nullptr, message_info, allocation));\n+  rcl_reset_error();\n+\n+  rmw_ret_t rmw_take_serialized_message_with_info_returns = RMW_RET_OK;\n+  auto mock = mocking_utils::patch(\n+    \"lib:rcl\", rmw_take_serialized_message_with_info,\n+    [&](auto, auto, bool * taken, auto...) {\n+      *taken = false;\n+      return rmw_take_serialized_message_with_info_returns;\n+    });\n+"},{"role":"user","content":"-    rcl_take_serialized_message(&subscription, &serialized_msg, nullptr, nullptr));\n+    rcl_take_serialized_message(&subscription, &serialized_msg, message_info, allocation));\n+  rcl_reset_error();\n+\n+  rmw_take_serialized_message_with_info_returns = RMW_RET_BAD_ALLOC;\n+  EXPECT_EQ(\n+    RCL_RET_BAD_ALLOC,\n+    rcl_take_serialized_message(&subscription, &serialized_msg, message_info, allocation));\n+  rcl_reset_error();\n+\n+  rmw_take_serialized_message_with_info_returns = RMW_RET_ERROR;\n+  EXPECT_EQ(\n+    RCL_RET_ERROR,\n+    rcl_take_serialized_message(&subscription, &serialized_msg, message_info, allocation));"},{"role":"user","content":"+  rmw_subscription_allocation_t * allocation = nullptr;  // is a valid argument"},{"role":"user","content":"-    rcl_take_sequence(nullptr, seq_size, &messages, &message_infos, nullptr));\n+    rcl_take_sequence(nullptr, seq_size, &messages, &message_infos, allocation));"},{"role":"user","content":"-    rcl_take_sequence(&subscription_zero_init, seq_size, &messages, &message_infos, nullptr));\n+    rcl_take_sequence(&subscription_zero_init, seq_size, &messages, &message_infos, allocation));"},{"role":"user","content":"-    rcl_take_sequence(&subscription, seq_size + 1, &messages, &message_infos, nullptr));\n+    rcl_take_sequence(&subscription, seq_size + 1, &messages, &message_infos, allocation));"},{"role":"user","content":"-    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos_short, nullptr));\n+    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos_short, allocation));\n+  rcl_reset_error();\n+\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_take_sequence(&subscription, seq_size, nullptr, &message_infos, allocation));"},{"role":"user","content":"-  // This test fails for rmw_cyclonedds_cpp function rmw_take_sequence\n-  // Tracked here: https://github.com/ros2/rmw_cyclonedds/issues/193\n-  /*\n+  EXPECT_EQ(\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_take_sequence(&subscription, seq_size, &messages, nullptr, allocation));\n+  rcl_reset_error();\n+\n+  rmw_ret_t rmw_take_sequence_returns = RMW_RET_OK;\n+  auto mock = mocking_utils::patch(\n+    \"lib:rcl\", rmw_take_sequence,\n+    [&](auto, auto, auto, auto, size_t * taken, auto) {\n+      *taken = 0u;\n+      return rmw_take_sequence_returns;\n+    });\n+"},{"role":"user","content":"-    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos, nullptr));\n+    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos, allocation));\n+  rcl_reset_error();\n+\n+  rmw_take_sequence_returns = RMW_RET_BAD_ALLOC;\n+  EXPECT_EQ(\n+    RCL_RET_BAD_ALLOC,\n+    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos, allocation));\n+  rcl_reset_error();\n+\n+  rmw_take_sequence_returns = RMW_RET_ERROR;\n+  EXPECT_EQ(\n+    RCL_RET_ERROR,\n+    rcl_take_sequence(&subscription, seq_size, &messages, &message_infos, allocation));"},{"role":"user","content":"-  */"},{"role":"user","content":"-/* Using bad arguments subscription methods\n+/* Test for all failure modes in subscription get_publisher_count function."},{"role":"user","content":"-TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscription_bad_argument) {\n-  size_t pub_count = 0;\n+TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_bad_get_publisher_count) {\n+  size_t publisher_count = 0;\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID,\n+    rcl_subscription_get_publisher_count(nullptr, &publisher_count));\n+  rcl_reset_error();\n+\n+  EXPECT_EQ(\n+    RCL_RET_SUBSCRIPTION_INVALID,\n+    rcl_subscription_get_publisher_count(&subscription_zero_init, &publisher_count));\n+  rcl_reset_error();"},{"role":"user","content":"-    RCL_RET_SUBSCRIPTION_INVALID, rcl_subscription_get_publisher_count(nullptr, &pub_count));\n+    RCL_RET_INVALID_ARGUMENT,\n+    rcl_subscription_get_publisher_count(&subscription, nullptr));"},{"role":"user","content":"+\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rcl\", rmw_subscription_count_matched_publishers, RMW_RET_ERROR);\n+  EXPECT_EQ(\n+    RCL_RET_ERROR,\n+    rcl_subscription_get_publisher_count(&subscription, &publisher_count));\n+  rcl_reset_error();\n+}\n+\n+/* Using bad arguments subscription methods\n+ */\n+TEST_F(CLASSNAME(TestSubscriptionFixtureInit, RMW_IMPLEMENTATION), test_subscription_bad_argument) {"},{"role":"user","content":"-  EXPECT_EQ(\n-    RCL_RET_SUBSCRIPTION_INVALID,\n-    rcl_subscription_get_publisher_count(&subscription_zero_init, &pub_count));\n-  rcl_reset_error();"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  *taken = 0;\n+\n+  // Reset length of output sequences\n+  message_sequence->size = 0;\n+  message_info_sequence->size = 0;\n+"},{"role":"user","content":"-  *taken = 0;\n-\n-  dds_ReturnCode_t ret = dds_DataReader_raw_take_w_sampleinfoex(\n-    topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n-    dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);\n-\n-  if (ret == dds_RETCODE_NO_DATA) {\n-    RCUTILS_LOG_DEBUG_NAMED(\n-      RMW_GURUMDDS_ID, \"No data on topic %s\", subscription->topic_name);\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_OK;\n-  }\n-\n-  if (ret != dds_RETCODE_OK) {\n-    RMW_SET_ERROR_MSG(\"failed to take data\");\n-    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-    dds_DataSeq_delete(data_values);\n-    dds_SampleInfoSeq_delete(sample_infos);\n-    dds_UnsignedLongSeq_delete(sample_sizes);\n-    return RMW_RET_ERROR;\n-  }\n+  while (*taken < count) {\n+    dds_ReturnCode_t ret = dds_DataReader_raw_take(\n+      topic_reader, dds_HANDLE_NIL, data_values, sample_infos, sample_sizes, count,\n+      dds_ANY_SAMPLE_STATE, dds_ANY_VIEW_STATE, dds_ANY_INSTANCE_STATE);"},{"role":"user","content":"-  RCUTILS_LOG_DEBUG_NAMED(\n-    RMW_GURUMDDS_ID, \"Received data on topic %s\", subscription->topic_name);\n+    if (ret == dds_RETCODE_NO_DATA) {\n+      RCUTILS_LOG_DEBUG_NAMED(\n+        RMW_GURUMDDS_ID, \"No data on topic %s\", subscription->topic_name);\n+      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n+      break;\n+    }"},{"role":"user","content":"-  for (uint32_t i = 0; i < dds_SampleInfoSeq_length(sample_infos); i++) {\n-    dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n+    if (ret != dds_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"failed to take data\");\n+      dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n+      dds_DataSeq_delete(data_values);\n+      dds_SampleInfoSeq_delete(sample_infos);\n+      dds_UnsignedLongSeq_delete(sample_sizes);\n+      return RMW_RET_ERROR;\n+    }"},{"role":"user","content":"-    if (sample_info->valid_data) {\n-      void * sample = dds_DataSeq_get(data_values, i);\n-      if (sample == nullptr) {\n-        RMW_SET_ERROR_MSG(\"failed to get message\");\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n-        return RMW_RET_ERROR;\n-      }\n-      uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);\n-      bool result = deserialize_cdr_to_ros(\n-        info->rosidl_message_typesupport->data,\n-        info->rosidl_message_typesupport->typesupport_identifier,\n-        message_sequence->data[*taken],\n-        sample,\n-        static_cast<size_t>(sample_size)\n-      );\n-      if (!result) {\n-        RMW_SET_ERROR_MSG(\"failed to deserialize message\");\n-        dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n-        dds_DataSeq_delete(data_values);\n-        dds_SampleInfoSeq_delete(sample_infos);\n-        dds_UnsignedLongSeq_delete(sample_sizes);\n-        return RMW_RET_ERROR;\n-      }\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      RMW_GURUMDDS_ID, \"Received data on topic %s\", subscription->topic_name);\n+\n+    for (uint32_t i = 0; i < dds_SampleInfoSeq_length(sample_infos); i++) {\n+      dds_SampleInfo * sample_info = dds_SampleInfoSeq_get(sample_infos, i);\n+\n+      if (sample_info->valid_data) {\n+        void * sample = dds_DataSeq_get(data_values, i);\n+        if (sample == nullptr) {\n+          RMW_SET_ERROR_MSG(\"failed to get message\");\n+          dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n+          dds_DataSeq_delete(data_values);\n+          dds_SampleInfoSeq_delete(sample_infos);\n+          dds_UnsignedLongSeq_delete(sample_sizes);\n+          return RMW_RET_ERROR;\n+        }\n+        uint32_t sample_size = dds_UnsignedLongSeq_get(sample_sizes, i);\n+        bool result = deserialize_cdr_to_ros(\n+          info->rosidl_message_typesupport->data,\n+          info->rosidl_message_typesupport->typesupport_identifier,\n+          message_sequence->data[*taken],\n+          sample,\n+          static_cast<size_t>(sample_size)\n+        );\n+        if (!result) {\n+          RMW_SET_ERROR_MSG(\"failed to deserialize message\");\n+          dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);\n+          dds_DataSeq_delete(data_values);\n+          dds_SampleInfoSeq_delete(sample_infos);\n+          dds_UnsignedLongSeq_delete(sample_sizes);\n+          return RMW_RET_ERROR;\n+        }"},{"role":"user","content":"-      int64_t sequence_number = 0;\n-      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);\n-      dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);\n+        auto message_info = &(message_info_sequence->data[*taken]);"},{"role":"user","content":"-      auto message_info = &(message_info_sequence->data[*taken]);\n+        message_info->source_timestamp =\n+          sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n+          sample_info->source_timestamp.nanosec;\n+        // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n+        message_info->received_timestamp = 0;\n+        rmw_gid_t * sender_gid = &message_info->publisher_gid;\n+        sender_gid->implementation_identifier = RMW_GURUMDDS_ID;\n+        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-      message_info->source_timestamp =\n-        sample_info->source_timestamp.sec * static_cast<int64_t>(1000000000) +\n-        sample_info->source_timestamp.nanosec;\n-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      message_info->received_timestamp = 0;\n-      message_info->publication_sequence_number = sequence_number;\n-      message_info->reception_sequence_number = RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED;\n-      rmw_gid_t * sender_gid = &message_info->publisher_gid;\n-      sender_gid->implementation_identifier = RMW_GURUMDDS_ID;\n-      memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n-        topic_reader, sample_info->publication_handle, sender_gid->data);\n-      if (ret != dds_RETCODE_OK) {\n-        if (ret == dds_RETCODE_ERROR) {\n-          RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+        dds_ReturnCode_t ret = dds_DataReader_get_guid_from_publication_handle(\n+          topic_reader, sample_info->publication_handle, sender_gid->data);\n+        if (ret != dds_RETCODE_OK) {\n+          if (ret == dds_RETCODE_ERROR) {\n+            RCUTILS_LOG_WARN_NAMED(RMW_GURUMDDS_ID, \"Failed to get publication handle\");\n+          }\n+          memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n-      }"},{"role":"user","content":"-      (*taken)++;\n+        (*taken)++;\n+      }"},{"role":"user","content":"+    dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);"},{"role":"user","content":"-  dds_DataReader_raw_return_loan(topic_reader, data_values, sample_infos, sample_sizes);"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    def destroy(self):\n+    def destroy(self) -> None:"},{"role":"user","content":"+class NodeHandle:\n+    pass\n+\n+"},{"role":"user","content":"-        publisher_class: Type[Publisher] = Publisher,\n+        publisher_class: Type[Publisher[MsgT]] = Publisher[MsgT],"},{"role":"user","content":"-from typing import Generic, List, Optional, Type, TypeVar, Union\n+from typing import Generic, List, Optional, Protocol, Type, TYPE_CHECKING, TypeVar, Union"},{"role":"user","content":"-from rclpy.duration import Duration\n+from rclpy.destroyable import DestroyableType\n+from rclpy.duration import Duration, DurationType"},{"role":"user","content":"+if TYPE_CHECKING:\n+    from rclpy.node import NodeHandle\n+\n+\n+class PublisherHandle(DestroyableType, Protocol[MsgT]):\n+\n+    def __init__(self, arg0: 'NodeHandle', arg1: Type[MsgT], arg2: str, arg3: object) -> None:\n+        \"\"\"Create PublisherHandle.\"\"\"\n+\n+    @property\n+    def pointer(self) -> int:\n+        \"\"\"Get the address of the entity as an integer.\"\"\"\n+\n+    def get_logger_name(self) -> str:\n+        \"\"\"Get the name of the logger associated with the node of the publisher.\"\"\"\n+\n+    def get_subscription_count(self) -> int:\n+        \"\"\"Count subscribers from a publisher.\"\"\"\n+\n+    def get_topic_name(self) -> str:\n+        \"\"\"Retrieve the topic name from a Publisher.\"\"\"\n+\n+    def publish(self, arg0: MsgT) -> None:\n+        \"\"\"Publish a message.\"\"\"\n+\n+    def publish_raw(self, arg0: bytes) -> None:\n+        \"\"\"Publish a serialized message.\"\"\"\n+\n+    def wait_for_all_acked(self, arg0: DurationType) -> bool:\n+        \"\"\"Wait until all published message data is acknowledged.\"\"\"\n+"},{"role":"user","content":"-        publisher_impl: _rclpy.Publisher,\n+        publisher_impl: PublisherHandle[MsgT],"},{"role":"user","content":"-    def handle(self):\n+    def handle(self) -> PublisherHandle[MsgT]:"},{"role":"user","content":"-    def destroy(self):\n+    def destroy(self) -> None:"},{"role":"user","content":"-    def __enter__(self) -> 'Publisher':\n+    def __enter__(self) -> 'Publisher[MsgT]':"},{"role":"user","content":"-MsgT = TypeVar('MsgT', bound=Msg)\n+MsgT = TypeVar('MsgT', bound=Msg, contravariant=True)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-typedef struct logging_input\n+typedef struct logging_input_s"},{"role":"user","content":"-} logging_input;\n+} logging_input_t;"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-typedef struct token_map_entry\n+typedef struct token_map_entry_s"},{"role":"user","content":"-} token_map_entry;\n+} token_map_entry_t;"},{"role":"user","content":"-  const logging_input * logging_input, rcutils_char_array_t * logging_output,\n+  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-  const logging_input * logging_input,\n+  const logging_input_t * logging_input,"},{"role":"user","content":"-static const token_map_entry tokens[] = {\n+static const token_map_entry_t tokens[] = {"},{"role":"user","content":"-  const logging_input logging_input = {\n+  const logging_input_t logging_input = {"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    assert numpy.array_equal(arr_of_float32_with_nan, msg.float32_values, equal_nan=True)\n+    arr_with_nan = numpy.isnan(arr_of_float32_with_nan)\n+    assert numpy.shape(arr_of_float32_with_nan) == numpy.shape(msg.float32_values) and (\n+        numpy.asarray(arr_of_float32_with_nan[~arr_with_nan] ==\n+                      msg.float32_values[~arr_with_nan]).all())"},{"role":"user","content":"-    assert numpy.array_equal(arr_of_float64_with_nan, msg.float64_values, equal_nan=True)\n-\n+    arr_with_nan = numpy.isnan(arr_of_float64_with_nan)\n+    assert numpy.shape(arr_of_float64_with_nan) == numpy.shape(msg.float64_values) and (\n+        numpy.asarray(arr_of_float64_with_nan[~arr_with_nan] ==\n+                      msg.float64_values[~arr_with_nan]).all())"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from rclpy.exceptions import ROSInterruptException"},{"role":"user","content":"-    _thread = threading.Thread(target=sleep_check_exception, args=rate, daemon=True)\n+    _thread = threading.Thread(target=sleep_check_exception, args=(rate,), daemon=True)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  typename NodeTopicsT,\n-  typename ROSMessageType = typename SubscriptionT::ROSMessageType>\n+  typename NodeTopicsT\n+>"},{"role":"user","content":"-  std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics<ROSMessageType>>\n+  std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics>"},{"role":"user","content":"-              std::to_string(options.topic_stats_options.publish_period.count()) +\n-              \" ms\");\n+              std::to_string(options.topic_stats_options.publish_period.count()) + \" ms\");"},{"role":"user","content":"-    subscription_topic_stats = std::make_shared<\n-      rclcpp::topic_statistics::SubscriptionTopicStatistics<ROSMessageType>\n-      >(node_topics_interface->get_node_base_interface()->get_name(), publisher);\n+    subscription_topic_stats =\n+      std::make_shared<rclcpp::topic_statistics::SubscriptionTopicStatistics>(\n+      node_topics_interface->get_node_base_interface()->get_name(), publisher);"},{"role":"user","content":"-      rclcpp::topic_statistics::SubscriptionTopicStatistics<ROSMessageType>\n+      rclcpp::topic_statistics::SubscriptionTopicStatistics"},{"role":"user","content":"-    std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics<ROSMessageType>>;\n+    std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics>;"},{"role":"user","content":"-      subscription_topic_statistics_->handle_message(*typed_message, time);\n+      subscription_topic_statistics_->handle_message(message_info.get_rmw_message_info(), time);"},{"role":"user","content":"-      subscription_topic_statistics_->handle_message(*typed_message, time);\n+      subscription_topic_statistics_->handle_message(message_info.get_rmw_message_info(), time);"},{"role":"user","content":"-  typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType,\n-  typename ROSMessageType = typename SubscriptionT::ROSMessageType\n+  typename MessageMemoryStrategyT = typename SubscriptionT::MessageMemoryStrategyType"},{"role":"user","content":"-  std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics<ROSMessageType>>\n+  std::shared_ptr<rclcpp::topic_statistics::SubscriptionTopicStatistics>"},{"role":"user","content":"- *\n- * \\tparam CallbackMessageT the subscribed message type\n- */\n-template<typename CallbackMessageT>\n+  */"},{"role":"user","content":"-  using TopicStatsCollector =\n-    libstatistics_collector::topic_statistics_collector::TopicStatisticsCollector<\n-    CallbackMessageT>;\n-  using ReceivedMessageAge =\n-    libstatistics_collector::topic_statistics_collector::ReceivedMessageAgeCollector<\n-    CallbackMessageT>;\n-  using ReceivedMessagePeriod =\n-    libstatistics_collector::topic_statistics_collector::ReceivedMessagePeriodCollector<\n-    CallbackMessageT>;\n+  using TopicStatsCollector = libstatistics_collector::TopicStatisticsCollector;\n+  using ReceivedMessageAge = libstatistics_collector::ReceivedMessageAgeCollector;\n+  using ReceivedMessagePeriod = libstatistics_collector::ReceivedMessagePeriodCollector;"},{"role":"user","content":"-   * \\param received_message the message received by the subscription\n+   * \\param message_info the message info corresponding to the received message"},{"role":"user","content":"-    const CallbackMessageT & received_message,\n+    const rmw_message_info_t & message_info,"},{"role":"user","content":"-      collector->OnMessageReceived(received_message, now_nanoseconds.nanoseconds());\n+      collector->OnMessageReceived(message_info, now_nanoseconds.nanoseconds());"},{"role":"user","content":"-#include <atomic>"},{"role":"user","content":"+#include <utility>"},{"role":"user","content":"-#include \"rclcpp/msg/message_with_header.hpp\""},{"role":"user","content":"-#include \"statistics_msgs/msg/statistic_data_point.hpp\""},{"role":"user","content":"+#include \"test_msgs/msg/strings.hpp\""},{"role":"user","content":"-using rclcpp::msg::MessageWithHeader;"},{"role":"user","content":"- * Wrapper class to test and expose parts of the SubscriptionTopicStatistics<T> class.\n- * \\tparam CallbackMessageT\n+ * Wrapper class to test and expose parts of the SubscriptionTopicStatistics class."},{"role":"user","content":"-template<typename CallbackMessageT>\n-class TestSubscriptionTopicStatistics : public SubscriptionTopicStatistics<CallbackMessageT>\n+class TestSubscriptionTopicStatistics : public SubscriptionTopicStatistics"},{"role":"user","content":"-  : SubscriptionTopicStatistics<CallbackMessageT>(node_name, publisher)\n+  : SubscriptionTopicStatistics(node_name, std::move(publisher))"},{"role":"user","content":"-  virtual ~TestSubscriptionTopicStatistics() = default;\n+  ~TestSubscriptionTopicStatistics() override = default;"},{"role":"user","content":"-  std::vector<StatisticData> get_current_collector_data() const\n-  {\n-    return SubscriptionTopicStatistics<CallbackMessageT>::get_current_collector_data();\n-  }\n+  using SubscriptionTopicStatistics::get_current_collector_data;"},{"role":"user","content":"- * Empty publisher node: used to publish empty messages\n+ * PublisherNode wrapper: used to create publisher node"},{"role":"user","content":"-class EmptyPublisher : public rclcpp::Node\n+template<typename MessageT>\n+class PublisherNode : public rclcpp::Node"},{"role":"user","content":"-  EmptyPublisher(\n+  PublisherNode("},{"role":"user","content":"-    publisher_ = create_publisher<Empty>(topic, 10);\n+    publisher_ = create_publisher<MessageT>(topic, 10);"},{"role":"user","content":"-  virtual ~EmptyPublisher() = default;\n+  ~PublisherNode() override = default;"},{"role":"user","content":"-    auto msg = Empty{};\n+    auto msg = MessageT{};"},{"role":"user","content":"-  rclcpp::Publisher<Empty>::SharedPtr publisher_;\n+  typename rclcpp::Publisher<MessageT>::SharedPtr publisher_;"},{"role":"user","content":"- * MessageWithHeader publisher node: used to publish MessageWithHeader with `header` value set\n- */\n-class MessageWithHeaderPublisher : public rclcpp::Node\n-{\n-public:\n-  MessageWithHeaderPublisher(\n-    const std::string & name, const std::string & topic,\n-    const std::chrono::milliseconds & publish_period = std::chrono::milliseconds{100})\n-  : Node(name)\n-  {\n-    publisher_ = create_publisher<MessageWithHeader>(topic, 10);\n-    publish_timer_ = this->create_wall_timer(\n-      publish_period, [this]() {\n-        this->publish_message();\n-      });\n-    uniform_dist_ = std::uniform_int_distribution<uint32_t>{1000000, 100000000};\n-  }\n-\n-  virtual ~MessageWithHeaderPublisher() = default;\n-\n-private:\n-  void publish_message()\n-  {\n-    std::random_device rd;\n-    std::mt19937 gen{rd()};\n-    uint32_t d = uniform_dist_(gen);\n-    auto msg = MessageWithHeader{};\n-    // Subtract ~1 second (add some noise for a non-zero standard deviation)\n-    // so the received message age calculation is always > 0\n-    msg.header.stamp = this->now() - rclcpp::Duration{1, d};\n-    publisher_->publish(msg);\n-  }\n-\n-  rclcpp::Publisher<MessageWithHeader>::SharedPtr publisher_;\n-  rclcpp::TimerBase::SharedPtr publish_timer_;\n-  std::uniform_int_distribution<uint32_t> uniform_dist_;\n-};\n-\n-/**\n- * TransitionMessageStamp publisher node : used to publish MessageWithHeader with `header` value set\n+ * TransitionMessageStamp publisher emulator node : used to emulate publishing messages by\n+ * directly calling rclcpp::Subscription::handle_message(msg_shared_ptr, message_info)."},{"role":"user","content":"-\n-class TransitionMessageStampPublisher : public rclcpp::Node\n+template<typename MessageT>\n+class TransitionMessageStampPublisherEmulator : public rclcpp::Node"},{"role":"user","content":"-  TransitionMessageStampPublisher(\n-    const std::string & name, const std::string & topic,\n+  TransitionMessageStampPublisherEmulator(\n+    const std::string & name,"},{"role":"user","content":"+    typename rclcpp::Subscription<MessageT>::SharedPtr subscription,"},{"role":"user","content":"-  : Node(name), transition_duration_(transition_duration), message_age_offset_(message_age_offset)\n+  : Node(name), transition_duration_(transition_duration), message_age_offset_(message_age_offset),\n+    subscription_(std::move(subscription))"},{"role":"user","content":"-    publisher_ = create_publisher<MessageWithHeader>(topic, 10);"},{"role":"user","content":"-    auto msg = MessageWithHeader{};\n+    std::shared_ptr<void> msg_shared_ptr = std::make_shared<MessageT>();\n+    rmw_message_info_t rmw_message_info = rmw_get_zero_initialized_message_info();\n+"},{"role":"user","content":"-      msg.header.stamp = now - message_age_offset_;\n+      rmw_message_info.source_timestamp = (now - message_age_offset_).nanoseconds();"},{"role":"user","content":"-      msg.header.stamp = now;\n+      rmw_message_info.source_timestamp = now.nanoseconds();"},{"role":"user","content":"-    publisher_->publish(msg);\n+    rclcpp::MessageInfo message_info{rmw_message_info};\n+    subscription_->handle_message(msg_shared_ptr, message_info);"},{"role":"user","content":"+  typename rclcpp::Subscription<MessageT>::SharedPtr subscription_;"},{"role":"user","content":"-\n-  rclcpp::Publisher<MessageWithHeader>::SharedPtr publisher_;"},{"role":"user","content":"- * Empty subscriber node: used to create subscriber topic statistics requirements\n+ * Message subscriber node: used to create subscriber with enabled topic statistics collectors\n+ *"},{"role":"user","content":"-class EmptySubscriber : public rclcpp::Node\n+template<typename MessageT>\n+class SubscriberWithTopicStatistics : public rclcpp::Node"},{"role":"user","content":"-  EmptySubscriber(const std::string & name, const std::string & topic)\n+  SubscriberWithTopicStatistics(\n+    const std::string & name, const std::string & topic,\n+    std::chrono::milliseconds publish_period = defaultStatisticsPublishPeriod)"},{"role":"user","content":"-    // manually enable topic statistics via options\n+    // Manually enable topic statistics via options"},{"role":"user","content":"+    options.topic_stats_options.publish_period = publish_period;"},{"role":"user","content":"-    auto callback = [](Empty::UniquePtr msg) {\n+    auto callback = [](typename MessageT::UniquePtr msg) {"},{"role":"user","content":"-    subscription_ = create_subscription<Empty,\n-        std::function<void(Empty::UniquePtr)>>(\n+    subscription_ = create_subscription<MessageT,\n+        std::function<void(typename MessageT::UniquePtr)>>("},{"role":"user","content":"-  virtual ~EmptySubscriber() = default;\n-\n-private:\n-  rclcpp::Subscription<Empty>::SharedPtr subscription_;\n-};\n+  ~SubscriberWithTopicStatistics() override = default;"},{"role":"user","content":"-/**\n- * MessageWithHeader subscriber node: used to create subscriber topic statistics requirements\n- */\n-class MessageWithHeaderSubscriber : public rclcpp::Node\n-{\n-public:\n-  MessageWithHeaderSubscriber(const std::string & name, const std::string & topic)\n-  : Node(name)\n+  typename rclcpp::Subscription<MessageT>::SharedPtr get_subscription()"},{"role":"user","content":"-    // manually enable topic statistics via options\n-    auto options = rclcpp::SubscriptionOptions();\n-    options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n-    options.topic_stats_options.publish_period = defaultStatisticsPublishPeriod;\n-\n-    auto callback = [](MessageWithHeader::UniquePtr msg) {\n-        (void) msg;\n-      };\n-    subscription_ = create_subscription<MessageWithHeader,\n-        std::function<void(MessageWithHeader::UniquePtr)>>(\n-      topic,\n-      rclcpp::QoS(rclcpp::KeepAll()),\n-      callback,\n-      options);\n+    return subscription_;"},{"role":"user","content":"-  virtual ~MessageWithHeaderSubscriber() = default;"},{"role":"user","content":"-  rclcpp::Subscription<MessageWithHeader>::SharedPtr subscription_;\n+  typename rclcpp::Subscription<MessageT>::SharedPtr subscription_;"},{"role":"user","content":"-  void SetUp()\n+  void SetUp() override"},{"role":"user","content":"-  void TearDown()\n+  void TearDown() override"},{"role":"user","content":"-/**\n- * Check if a received statistics message is empty (no data was observed)\n- * \\param message_to_check\n- */\n-void check_if_statistics_message_is_empty(const MetricsMessage & message_to_check)\n-{\n-  for (const auto & stats_point : message_to_check.statistics) {\n-    const auto type = stats_point.data_type;\n-    switch (type) {\n-      case StatisticDataType::STATISTICS_DATA_TYPE_SAMPLE_COUNT:\n-        EXPECT_EQ(0, stats_point.data) << \"unexpected sample count\" << stats_point.data;\n-        break;\n-      case StatisticDataType::STATISTICS_DATA_TYPE_AVERAGE:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_MINIMUM:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_MAXIMUM:\n-      case StatisticDataType::STATISTICS_DATA_TYPE_STDDEV:\n-        EXPECT_TRUE(std::isnan(stats_point.data)) << \"unexpected value\" << stats_point.data <<\n-          \" for type:\" << type;\n-        break;\n-      default:\n-        FAIL() << \"received unknown statistics type: \" << std::dec <<\n-          static_cast<unsigned int>(type);\n-    }\n-  }\n-}\n-"},{"role":"user","content":"-TEST(TestSubscriptionTopicStatistics, test_invalid_publish_period)\n+TEST_F(TestSubscriptionTopicStatisticsFixture, test_invalid_publish_period)"},{"role":"user","content":"-  rclcpp::init(0 /* argc */, nullptr /* argv */);\n-\n-  auto node = std::make_shared<rclcpp::Node>(\"test_period_node\");\n-\n-  auto options = rclcpp::SubscriptionOptions();\n-  options.topic_stats_options.state = rclcpp::TopicStatisticsState::Enable;\n-  options.topic_stats_options.publish_period = std::chrono::milliseconds(0);\n-\n-  auto callback = [](Empty::UniquePtr msg) {\n-      (void) msg;\n-    };\n-"},{"role":"user","content":"-    (node->create_subscription<Empty, std::function<void(Empty::UniquePtr)>>(\n-      \"should_throw_invalid_arg\",\n-      rclcpp::QoS(rclcpp::KeepAll()),\n-      callback,\n-      options)), std::invalid_argument);\n-\n-  rclcpp::shutdown();\n+    SubscriberWithTopicStatistics<Empty>(\n+      \"test_period_node\", \"should_throw_invalid_arg\", std::chrono::milliseconds(0)\n+    ),\n+    std::invalid_argument);"},{"role":"user","content":"-  auto empty_subscriber = std::make_shared<EmptySubscriber>(\n+  auto empty_subscriber = std::make_shared<SubscriberWithTopicStatistics<Empty>>("},{"role":"user","content":"-  auto sub_topic_stats = std::make_unique<TestSubscriptionTopicStatistics<Empty>>(\n+  auto sub_topic_stats = std::make_unique<TestSubscriptionTopicStatistics>("},{"role":"user","content":"-  auto empty_publisher = std::make_shared<EmptyPublisher>(\n+  auto empty_publisher = std::make_shared<PublisherNode<Empty>>("},{"role":"user","content":"-  auto empty_subscriber = std::make_shared<EmptySubscriber>(\n+  auto empty_subscriber = std::make_shared<SubscriberWithTopicStatistics<Empty>>("},{"role":"user","content":"-  ex.spin_until_future_complete(\n-    statistics_listener->GetFuture(),\n-    kTestTimeout);\n-\n-  // Compare message counts, sample count should be the same as published and received count\n-  EXPECT_EQ(kNumExpectedMessages, statistics_listener->GetNumberOfMessagesReceived());\n-\n-  // Check the received message total count\n-  const auto received_messages = statistics_listener->GetReceivedMessages();\n-  EXPECT_EQ(kNumExpectedMessages, received_messages.size());\n-\n-  // check the type of statistics that were received and their counts\n-  uint64_t message_age_count{0};\n-  uint64_t message_period_count{0};\n-\n-  std::set<std::string> received_metrics;\n-  for (const auto & msg : received_messages) {\n-    if (msg.metrics_source == \"message_age\") {\n-      message_age_count++;\n-    }\n-    if (msg.metrics_source == \"message_period\") {\n-      message_period_count++;\n-    }\n-  }\n-  EXPECT_EQ(kNumExpectedMessageAgeMessages, message_age_count);\n-  EXPECT_EQ(kNumExpectedMessagePeriodMessages, message_period_count);\n-\n-  // Check the collected statistics for message period.\n-  // Message age statistics will not be calculated because Empty messages\n-  // don't have a `header` with timestamp. This means that we expect to receive a `message_age`\n-  // and `message_period` message for each empty message published.\n-  for (const auto & msg : received_messages) {\n-    if (msg.metrics_source == kMessageAgeSourceLabel) {\n-      check_if_statistics_message_is_empty(msg);\n-    } else if (msg.metrics_source == kMessagePeriodSourceLabel) {\n-      check_if_statistic_message_is_populated(msg);\n-    }\n-  }\n-}\n-\n-TEST_F(TestSubscriptionTopicStatisticsFixture, test_receive_stats_for_message_with_header)\n-{\n-  // Create a MessageWithHeader publisher\n-  auto msg_with_header_publisher = std::make_shared<MessageWithHeaderPublisher>(\n-    kTestPubNodeName,\n-    kTestSubStatsTopic);\n-  // empty_subscriber has a topic statistics instance as part of its subscription\n-  // this will listen to and generate statistics for the empty message\n-\n-  // Create a listener for topic statistics messages\n-  auto statistics_listener = std::make_shared<rclcpp::topic_statistics::MetricsMessageSubscriber>(\n-    \"test_receive_stats_for_message_with_header\",\n-    \"/statistics\",\n-    kNumExpectedMessages);\n-\n-  auto msg_with_header_subscriber = std::make_shared<MessageWithHeaderSubscriber>(\n-    kTestSubNodeName,\n-    kTestSubStatsTopic);\n-\n-  rclcpp::executors::SingleThreadedExecutor ex;\n-  ex.add_node(msg_with_header_publisher);\n-  ex.add_node(statistics_listener);\n-  ex.add_node(msg_with_header_subscriber);\n-\n-  // Spin and get future\n-  ex.spin_until_future_complete(\n-    statistics_listener->GetFuture(),\n-    kTestTimeout);\n+  ex.spin_until_future_complete(statistics_listener->GetFuture(), kTestTimeout);"},{"role":"user","content":"+  // Check the collected statistics for message period."},{"role":"user","content":"-  // Create a MessageWithHeader publisher\n-  auto msg_with_header_publisher = std::make_shared<TransitionMessageStampPublisher>(\n-    kTestPubNodeName, kTestSubStatsTopic, kUnstableMessageAgeWindowDuration,\n-    kUnstableMessageAgeOffset);\n-\n-  // msg_with_header_subscriber has a topic statistics instance as part of its\n+  // msg_subscriber_with_topic_statistics has a topic statistics instance as part of its"},{"role":"user","content":"-  auto msg_with_header_subscriber =\n-    std::make_shared<MessageWithHeaderSubscriber>(kTestSubNodeName, kTestSubStatsTopic);\n+  auto msg_subscriber_with_topic_statistics =\n+    std::make_shared<SubscriberWithTopicStatistics<test_msgs::msg::Strings>>(\n+    kTestSubNodeName,\n+    kTestSubStatsTopic);\n+\n+  // Create a message publisher\n+  auto msg_publisher =\n+    std::make_shared<TransitionMessageStampPublisherEmulator<test_msgs::msg::Strings>>(\n+    kTestPubNodeName, kUnstableMessageAgeWindowDuration,\n+    kUnstableMessageAgeOffset, msg_subscriber_with_topic_statistics->get_subscription());\n+"},{"role":"user","content":"-  ex.add_node(msg_with_header_publisher);\n+  ex.add_node(msg_publisher);"},{"role":"user","content":"-  ex.add_node(msg_with_header_subscriber);\n+  ex.add_node(msg_subscriber_with_topic_statistics);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  <author email=\"william@osrfoundation.org\">William Woodall</author>"},{"role":"user","content":"+  <author email=\"william@osrfoundation.org\">William Woodall</author>"},{"role":"user","content":"+  <author email=\"william@osrfoundation.org\">William Woodall</author>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclpy/wait_set.cpp"},{"role":"user","content":"-class _WaitSet:\n-    \"\"\"Make sure the wait set gets destroyed when a generator exits.\"\"\"\n-\n-    def __enter__(self):\n-        self.wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n-        return self.wait_set\n-\n-    def __exit__(self, t, v, tb):\n-        _rclpy.rclpy_destroy_wait_set(self.wait_set)\n-\n-"},{"role":"user","content":"-            with _WaitSet() as wait_set, ExitStack() as context_stack:\n+            wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n+            with ExitStack() as context_stack:"},{"role":"user","content":"-\n-/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n-static PyObject *\n-rclpy_get_zero_initialized_wait_set(PyObject * Py_UNUSED(self), PyObject * Py_UNUSED(args))\n-{\n-  rcl_wait_set_t * wait_set = PyMem_Malloc(sizeof(rcl_wait_set_t));\n-  if (!wait_set) {\n-    PyErr_Format(PyExc_MemoryError, \"Failed to allocate memory for wait set\");\n-    return NULL;\n-  }\n-  *wait_set = rcl_get_zero_initialized_wait_set();\n-  PyObject * pywait_set = PyCapsule_New(wait_set, \"rcl_wait_set_t\", NULL);\n-\n-  return pywait_set;\n-}\n-\n-/// Initialize a wait set\n-/**\n- * Raises RuntimeError if the wait set could not be initialized\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] node_name string name of the node to be created\n- * \\param[in] number_of_subscriptions int\n- * \\param[in] number_of_guard_conditions int\n- * \\param[in] number_of_timers int\n- * \\param[in] number_of_clients int\n- * \\param[in] number_of_services int\n- * \\return None\n- */\n-static PyObject *\n-rclpy_wait_set_init(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-  unsigned PY_LONG_LONG number_of_subscriptions;\n-  unsigned PY_LONG_LONG number_of_guard_conditions;\n-  unsigned PY_LONG_LONG number_of_timers;\n-  unsigned PY_LONG_LONG number_of_clients;\n-  unsigned PY_LONG_LONG number_of_services;\n-  unsigned PY_LONG_LONG number_of_events;\n-  PyObject * pycontext;\n-\n-  if (!PyArg_ParseTuple(\n-      args, \"OKKKKKKO\", &pywait_set, &number_of_subscriptions,\n-      &number_of_guard_conditions, &number_of_timers,\n-      &number_of_clients, &number_of_services, &number_of_events, &pycontext))\n-  {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  rcl_context_t * context = rclpy_handle_get_pointer_from_capsule(pycontext, \"rcl_context_t\");\n-  if (!context) {\n-    return NULL;\n-  }\n-\n-  rcl_ret_t ret = rcl_wait_set_init(\n-    wait_set,\n-    number_of_subscriptions,\n-    number_of_guard_conditions,\n-    number_of_timers,\n-    number_of_clients,\n-    number_of_services,\n-    number_of_events,\n-    context,\n-    rcl_get_default_allocator());\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError,\n-      \"Failed to initialize wait set: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_NONE;\n-}\n-\n-/// Clear all the pointers in the wait set\n-/**\n- * Raises RuntimeError if any rcl error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return NULL\n- */\n-static PyObject *\n-rclpy_wait_set_clear_entities(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-\n-  if (!PyArg_ParseTuple(args, \"O\", &pywait_set)) {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError, \"Failed to clear wait set: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_TRUE;\n-}\n-\n-/// Add an entity to the wait set structure\n-/**\n- * Raises RuntimeError if the entity type is unknown or any rcl error occurrs\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyentity Capsule pointing to the entity to add\n- * \\return Index in waitset entity was added at\n- */\n-static PyObject *\n-rclpy_wait_set_add_entity(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  PyObject * pyentity;\n-  size_t index;\n-\n-  if (!PyArg_ParseTuple(args, \"zOO\", &entity_type, &pywait_set, &pyentity)) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret;\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  if (0 == strcmp(entity_type, \"subscription\")) {\n-    rclpy_subscription_t * sub =\n-      rclpy_handle_get_pointer_from_capsule(pyentity, \"rclpy_subscription_t\");\n-    if (!sub) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_subscription(wait_set, &(sub->subscription), &index);\n-  } else if (0 == strcmp(entity_type, \"client\")) {\n-    rclpy_client_t * client = rclpy_handle_get_pointer_from_capsule(pyentity, \"rclpy_client_t\");\n-    if (!client) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_client(wait_set, &(client->client), &index);\n-  } else if (0 == strcmp(entity_type, \"service\")) {\n-    rclpy_service_t * srv = rclpy_handle_get_pointer_from_capsule(pyentity, \"rclpy_service_t\");\n-    if (!srv) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_service(wait_set, &(srv->service), &index);\n-  } else if (0 == strcmp(entity_type, \"timer\")) {\n-    rcl_timer_t * timer = rclpy_handle_get_pointer_from_capsule(pyentity, \"rcl_timer_t\");\n-    if (!timer) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_timer(wait_set, timer, &index);\n-  } else if (0 == strcmp(entity_type, \"guard_condition\")) {\n-    rcl_guard_condition_t * guard_condition = rclpy_handle_get_pointer_from_capsule(\n-      pyentity, \"rcl_guard_condition_t\");\n-    if (!guard_condition) {\n-      return NULL;\n-    }\n-    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, &index);\n-  } else if (0 == strcmp(entity_type, \"event\")) {\n-    rcl_event_t * event = rclpy_handle_get_pointer_from_capsule(pyentity, \"rcl_event_t\");\n-    ret = rcl_wait_set_add_event(wait_set, event, &index);\n-  } else {\n-    PyErr_Format(\n-      PyExc_RuntimeError, \"'%s' is not a known entity\", entity_type);\n-    return NULL;\n-  }\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError,\n-      \"Failed to add '%s' to wait set: %s\", entity_type, rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  return PyLong_FromSize_t(index);\n-}\n-\n-/// Check if an entity in the wait set is ready by its index\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError if the entity type is unknown\n- * Raises IndexError if the given index is beyond the number of entities in the set\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyindex location in the wait set of the entity to check\n- * \\return True if the entity at the index in the wait set is not NULL\n- */\n-static PyObject *\n-rclpy_wait_set_is_ready(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  PyObject * pyindex;\n-  size_t index;\n-\n-  if (!PyArg_ParseTuple(args, \"zOO\", &entity_type, &pywait_set, &pyindex)) {\n-    return NULL;\n-  }\n-\n-  index = PyLong_AsSize_t(pyindex);\n-  if (PyErr_Occurred()) {\n-    // Error already set\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  void ** entities = NULL;\n-  size_t num_entities = 0;\n-  if (0 == strcmp(entity_type, \"subscription\")) {\n-    entities = (void *)wait_set->subscriptions;\n-    num_entities = wait_set->size_of_subscriptions;\n-  } else if (0 == strcmp(entity_type, \"client\")) {\n-    entities = (void *)wait_set->clients;\n-    num_entities = wait_set->size_of_clients;\n-  } else if (0 == strcmp(entity_type, \"service\")) {\n-    entities = (void *)wait_set->services;\n-    num_entities = wait_set->size_of_services;\n-  } else if (0 == strcmp(entity_type, \"timer\")) {\n-    entities = (void *)wait_set->timers;\n-    num_entities = wait_set->size_of_timers;\n-  } else if (0 == strcmp(entity_type, \"guard_condition\")) {\n-    entities = (void *)wait_set->guard_conditions;\n-    num_entities = wait_set->size_of_guard_conditions;\n-  } else if (0 == strcmp(entity_type, \"event\")) {\n-    entities = (void *)wait_set->events;\n-    num_entities = wait_set->size_of_events;\n-  } else {\n-    PyErr_Format(\n-      PyExc_RuntimeError, \"'%s' is not a known entity\", entity_type);\n-    return NULL;\n-  }\n-\n-  if (!entities) {\n-    PyErr_Format(PyExc_RuntimeError, \"Wait set '%s' isn't allocated\", entity_type);\n-    return NULL;\n-  }\n-  if (index >= num_entities) {\n-    PyErr_Format(PyExc_IndexError, \"%s index too big %zu >= %zu\", entity_type, index, num_entities);\n-    return NULL;\n-  }\n-  if (NULL != entities[index]) {\n-    Py_RETURN_TRUE;\n-  }\n-  Py_RETURN_FALSE;\n-}\n-\n-/// Destroy the wait set structure\n-/**\n- * Raises RuntimeError if the wait set could not be destroyed\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return None\n- */\n-static PyObject *\n-rclpy_destroy_wait_set(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-\n-  if (!PyArg_ParseTuple(args, \"O\", &pywait_set)) {\n-    return NULL;\n-  }\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError, \"Failed to fini wait set: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-\n-  PyMem_Free(wait_set);\n-\n-  if (PyCapsule_SetPointer(pywait_set, Py_None)) {\n-    // exception set by PyCapsule_SetPointer\n-    return NULL;\n-  }\n-\n-  Py_RETURN_NONE;\n-}\n-\n-#define GET_LIST_READY_ENTITIES(ENTITY_TYPE) \\\n-  size_t idx; \\\n-  size_t idx_max; \\\n-  idx_max = wait_set->size_of_ ## ENTITY_TYPE ## s; \\\n-  const rcl_ ## ENTITY_TYPE ## _t ** struct_ptr = wait_set->ENTITY_TYPE ## s; \\\n-  for (idx = 0; idx < idx_max; idx ++) { \\\n-    if (struct_ptr[idx]) { \\\n-      PyObject * obj = PyLong_FromVoidPtr((void *) struct_ptr[idx]); \\\n-      if (obj) { \\\n-        int rc = PyList_Append(entity_ready_list, obj); \\\n-        Py_DECREF(obj); \\\n-        if (rc != 0) { \\\n-          Py_DECREF(entity_ready_list); \\\n-          return NULL; \\\n-        } \\\n-      } else { \\\n-        Py_DECREF(entity_ready_list); \\\n-        return NULL; \\\n-      } \\\n-    } \\\n-  } \\\n-  return entity_ready_list;\n-/// Get list of non-null entities in wait set\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if the entity type is not known\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return List of wait set entities pointers ready for take\n- */\n-static PyObject *\n-rclpy_get_ready_entities(PyObject * Py_UNUSED(self), PyObject * args)\n-{\n-  const char * entity_type;\n-  PyObject * pywait_set;\n-  if (!PyArg_ParseTuple(args, \"zO\", &entity_type, &pywait_set)) {\n-    return NULL;\n-  }\n-\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-\n-  PyObject * entity_ready_list = PyList_New(0);\n-  if (0 == strcmp(entity_type, \"subscription\")) {\n-    GET_LIST_READY_ENTITIES(subscription)\n-  } else if (0 == strcmp(entity_type, \"client\")) {\n-    GET_LIST_READY_ENTITIES(client)\n-  } else if (0 == strcmp(entity_type, \"service\")) {\n-    GET_LIST_READY_ENTITIES(service)\n-  } else if (0 == strcmp(entity_type, \"timer\")) {\n-    GET_LIST_READY_ENTITIES(timer)\n-  } else if (0 == strcmp(entity_type, \"guard_condition\")) {\n-    GET_LIST_READY_ENTITIES(guard_condition)\n-  }\n-  Py_DECREF(entity_ready_list);\n-  PyErr_Format(\n-    PyExc_RuntimeError, \"'%s' is not a known entity\", entity_type);\n-  return NULL;\n-}\n-\n-/// Wait until timeout is reached or event happened\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if there was an error while waiting\n- *\n- * This function will wait for an event to happen or for the timeout to expire.\n- * A negative timeout means wait forever, a timeout of 0 means no wait\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n- * \\return NULL\n- */\n-static PyObject *\n-rclpy_wait(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pywait_set;\n-  PY_LONG_LONG timeout = -1;\n-\n-  if (!PyArg_ParseTuple(args, \"O|K\", &pywait_set, &timeout)) {\n-    return NULL;\n-  }\n-  rcl_wait_set_t * wait_set = PyCapsule_GetPointer(pywait_set, \"rcl_wait_set_t\");\n-  if (!wait_set) {\n-    return NULL;\n-  }\n-  rcl_ret_t ret;\n-\n-  // Could be a long wait, release the GIL\n-  Py_BEGIN_ALLOW_THREADS;\n-  ret = rcl_wait(wait_set, timeout);\n-  Py_END_ALLOW_THREADS;\n-\n-  if (ret != RCL_RET_OK && ret != RCL_RET_TIMEOUT) {\n-    PyErr_Format(\n-      module_state->RCLError, \"Failed to wait on wait set: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    return NULL;\n-  }\n-  Py_RETURN_NONE;\n-}\n-"},{"role":"user","content":"-  {\n-    \"rclpy_get_zero_initialized_wait_set\", rclpy_get_zero_initialized_wait_set, METH_NOARGS,\n-    \"rclpy_get_zero_initialized_wait_set.\"\n-  },\n-\n-  {\n-    \"rclpy_wait_set_init\", rclpy_wait_set_init, METH_VARARGS,\n-    \"rclpy_wait_set_init.\"\n-  },\n-\n-  {\n-    \"rclpy_wait_set_clear_entities\", rclpy_wait_set_clear_entities, METH_VARARGS,\n-    \"rclpy_wait_set_clear_entities.\"\n-  },\n-\n-  {\n-    \"rclpy_wait_set_add_entity\", rclpy_wait_set_add_entity, METH_VARARGS,\n-    \"rclpy_wait_set_add_entity.\"\n-  },\n-\n-  {\n-    \"rclpy_wait_set_is_ready\", rclpy_wait_set_is_ready, METH_VARARGS,\n-    \"rclpy_wait_set_is_ready.\"\n-  },\n-\n-  {\n-    \"rclpy_destroy_wait_set\", rclpy_destroy_wait_set, METH_VARARGS,\n-    \"rclpy_destroy_wait_set.\"\n-  },\n-\n-  {\n-    \"rclpy_get_ready_entities\", rclpy_get_ready_entities, METH_VARARGS,\n-    \"List non null entities in wait set.\"\n-  },\n-\n-  {\n-    \"rclpy_wait\", rclpy_wait, METH_VARARGS,\n-    \"rclpy_wait.\"\n-  },\n-"},{"role":"user","content":"+#include \"wait_set.hpp\""},{"role":"user","content":"+\n+  m.def(\n+    \"rclpy_get_zero_initialized_wait_set\", &rclpy::get_zero_initialized_wait_set,\n+    \"rclpy_get_zero_initialized_wait_set.\");\n+  m.def(\n+    \"rclpy_wait_set_init\", &rclpy::wait_set_init,\n+    \"rclpy_wait_set_init.\");\n+  m.def(\n+    \"rclpy_wait_set_clear_entities\", &rclpy::wait_set_clear_entities,\n+    \"rclpy_wait_set_clear_entities.\");\n+  m.def(\n+    \"rclpy_wait_set_add_entity\", &rclpy::wait_set_add_entity,\n+    \"rclpy_wait_set_add_entity.\");\n+  m.def(\n+    \"rclpy_wait_set_is_ready\", &rclpy::wait_set_is_ready,\n+    \"rclpy_wait_set_is_ready.\");\n+  m.def(\n+    \"rclpy_get_ready_entities\", &rclpy::get_ready_entities,\n+    \"List non null entities in wait set.\");\n+  m.def(\n+    \"rclpy_wait\", &rclpy::wait,\n+    \"rclpy_wait.\");"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Include pybind11 before rclpy_common/handle.h includes Python.h\n+#include <pybind11/pybind11.h>\n+\n+#include <rcl/error_handling.h>\n+#include <rcl/rcl.h>\n+#include <rcl/types.h>\n+\n+#include <cstring>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+\n+extern \"C\"\n+{\n+#include \"rclpy_common/common.h\"\n+}\n+#include \"rclpy_common/handle.h\"\n+\n+#include \"rclpy_common/exceptions.hpp\"\n+#include \"wait_set.hpp\"\n+\n+namespace rclpy\n+{\n+/// Destructor for a wait set\n+void\n+_rclpy_destroy_wait_set(PyObject * pycapsule)\n+{\n+  auto wait_set = static_cast<rcl_wait_set_t *>(PyCapsule_GetPointer(pycapsule, \"rcl_wait_set_t\"));\n+\n+  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n+  if (ret != RCL_RET_OK) {\n+    // Warning should use line number of the current stack frame\n+    int stack_level = 1;\n+    PyErr_WarnFormat(\n+      PyExc_RuntimeWarning, stack_level,\n+      \"Failed to fini wait set: %s\", rcl_get_error_string().str);\n+    rcl_reset_error();\n+  }\n+\n+  PyMem_Free(wait_set);\n+}\n+\n+py::capsule\n+get_zero_initialized_wait_set()\n+{\n+  auto deleter = [](rcl_wait_set_t * ptr) {PyMem_FREE(ptr);};\n+  auto wait_set = std::unique_ptr<rcl_wait_set_t, decltype(deleter)>(\n+    static_cast<rcl_wait_set_t *>(PyMem_Malloc(sizeof(rcl_wait_set_t))),\n+    deleter);\n+  if (!wait_set) {\n+    throw std::bad_alloc();\n+  }\n+\n+  *wait_set = rcl_get_zero_initialized_wait_set();\n+  return py::capsule(wait_set.release(), \"rcl_wait_set_t\", _rclpy_destroy_wait_set);\n+}\n+\n+void\n+wait_set_init(\n+  py::capsule pywait_set,\n+  size_t number_of_subscriptions,\n+  size_t number_of_guard_conditions,\n+  size_t number_of_timers,\n+  size_t number_of_clients,\n+  size_t number_of_services,\n+  size_t number_of_events,\n+  py::capsule pycontext)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  auto context = static_cast<rcl_context_t *>(\n+    rclpy_handle_get_pointer_from_capsule(pycontext.ptr(), \"rcl_context_t\"));\n+  if (!context) {\n+    throw py::error_already_set();\n+  }\n+\n+  rcl_ret_t ret = rcl_wait_set_init(\n+    wait_set,\n+    number_of_subscriptions,\n+    number_of_guard_conditions,\n+    number_of_timers,\n+    number_of_clients,\n+    number_of_services,\n+    number_of_events,\n+    context,\n+    rcl_get_default_allocator());\n+  if (ret != RCL_RET_OK) {\n+    throw RCLError(\"failed to initialize wait set\");\n+  }\n+}\n+\n+void\n+wait_set_clear_entities(py::capsule pywait_set)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n+  if (ret != RCL_RET_OK) {\n+    throw RCLError(\"failed to clear wait set\");\n+  }\n+}\n+\n+size_t\n+wait_set_add_entity(const std::string & entity_type, py::capsule pywait_set, py::capsule pyentity)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  rcl_ret_t ret = RCL_RET_ERROR;\n+  size_t index;\n+\n+  if (\"subscription\" == entity_type) {\n+    auto sub = static_cast<rclpy_subscription_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rclpy_subscription_t\"));\n+    if (!sub) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_subscription(wait_set, &(sub->subscription), &index);\n+  } else if (\"client\" == entity_type) {\n+    auto client = static_cast<rclpy_client_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rclpy_client_t\"));\n+    if (!client) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_client(wait_set, &(client->client), &index);\n+  } else if (\"service\" == entity_type) {\n+    auto srv = static_cast<rclpy_service_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rclpy_service_t\"));\n+    if (!srv) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_service(wait_set, &(srv->service), &index);\n+  } else if (\"timer\" == entity_type) {\n+    auto timer = static_cast<rcl_timer_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rcl_timer_t\"));\n+    if (!timer) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_timer(wait_set, timer, &index);\n+  } else if (\"guard_condition\" == entity_type) {\n+    auto guard_condition = static_cast<rcl_guard_condition_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rcl_guard_condition_t\"));\n+    if (!guard_condition) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, &index);\n+  } else if (\"event\" == entity_type) {\n+    auto event = static_cast<rcl_event_t *>(\n+      rclpy_handle_get_pointer_from_capsule(pyentity.ptr(), \"rcl_event_t\"));\n+    if (!event) {\n+      throw py::error_already_set();\n+    }\n+    ret = rcl_wait_set_add_event(wait_set, event, &index);\n+  } else {\n+    std::string error_text{\"'\"};\n+    error_text += entity_type;\n+    error_text += \"' is not a known entity\";\n+    throw std::runtime_error(error_text);\n+  }\n+  if (ret != RCL_RET_OK) {\n+    std::string error_text{\"failed to add'\"};\n+    error_text += entity_type;\n+    error_text += \"' to waitset\";\n+    throw RCLError(error_text);\n+  }\n+  return index;\n+}\n+\n+bool\n+wait_set_is_ready(const std::string & entity_type, py::capsule pywait_set, size_t index)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  const void ** entities = NULL;\n+  size_t num_entities = 0;\n+  if (\"subscription\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->subscriptions);\n+    num_entities = wait_set->size_of_subscriptions;\n+  } else if (\"client\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->clients);\n+    num_entities = wait_set->size_of_clients;\n+  } else if (\"service\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->services);\n+    num_entities = wait_set->size_of_services;\n+  } else if (\"timer\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->timers);\n+    num_entities = wait_set->size_of_timers;\n+  } else if (\"guard_condition\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->guard_conditions);\n+    num_entities = wait_set->size_of_guard_conditions;\n+  } else if (\"event\" == entity_type) {\n+    entities = reinterpret_cast<const void **>(wait_set->events);\n+    num_entities = wait_set->size_of_events;\n+  } else {\n+    std::string error_text{\"'\"};\n+    error_text += entity_type;\n+    error_text += \"' is not a known entity\";\n+    throw std::runtime_error(error_text);\n+  }\n+\n+  if (!entities) {\n+    std::string error_text{\"wait set '\"};\n+    error_text += entity_type;\n+    error_text += \"' isn't allocated\";\n+    throw std::runtime_error(error_text);\n+  }\n+  if (index >= num_entities) {\n+    throw std::out_of_range(\"wait set index too big\");\n+  }\n+  return nullptr != entities[index];\n+}\n+\n+template<typename EntityArray>\n+py::list\n+_get_ready_entities(const EntityArray ** entities, const size_t num_entities)\n+{\n+  py::list entity_list;\n+  for (size_t i = 0; i < num_entities; ++i) {\n+    auto address = reinterpret_cast<size_t>(entities[i]);\n+    if (address) {\n+      entity_list.append(address);\n+    }\n+  }\n+  return entity_list;\n+}\n+\n+py::list\n+get_ready_entities(const std::string & entity_type, py::capsule pywait_set)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  if (\"subscription\" == entity_type) {\n+    return _get_ready_entities(wait_set->subscriptions, wait_set->size_of_subscriptions);\n+  } else if (\"client\" == entity_type) {\n+    return _get_ready_entities(wait_set->clients, wait_set->size_of_clients);\n+  } else if (\"service\" == entity_type) {\n+    return _get_ready_entities(wait_set->services, wait_set->size_of_services);\n+  } else if (\"timer\" == entity_type) {\n+    return _get_ready_entities(wait_set->timers, wait_set->size_of_timers);\n+  } else if (\"guard_condition\" == entity_type) {\n+    return _get_ready_entities(wait_set->guard_conditions, wait_set->size_of_guard_conditions);\n+  }\n+\n+  std::string error_text{\"'\"};\n+  error_text += entity_type;\n+  error_text += \"' is not a known entity\";\n+  throw std::runtime_error(error_text);\n+}\n+\n+void\n+wait(py::capsule pywait_set, int64_t timeout)\n+{\n+  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n+    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n+  }\n+  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+\n+  rcl_ret_t ret;\n+\n+  // Could be a long wait, release the GIL\n+  {\n+    py::gil_scoped_release gil_release;\n+    ret = rcl_wait(wait_set, timeout);\n+  }\n+\n+  if (ret != RCL_RET_OK && ret != RCL_RET_TIMEOUT) {\n+    throw RCLError(\"failed to wait on wait set\");\n+  }\n+}\n+}  // namespace rclpy"},{"role":"user","content":"+// Copyright 2021 Open Source Robotics Foundation, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLPY__WAIT_SET_HPP_\n+#define RCLPY__WAIT_SET_HPP_\n+\n+#include <pybind11/pybind11.h>\n+\n+#include <string>\n+\n+namespace py = pybind11;\n+\n+namespace rclpy\n+{\n+/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n+py::capsule\n+get_zero_initialized_wait_set();\n+\n+/// Initialize a wait set\n+/**\n+ * Raises RCLError if the wait set could not be initialized\n+ *\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ * \\param[in] node_name string name of the node to be created\n+ * \\param[in] number_of_subscriptions int\n+ * \\param[in] number_of_guard_conditions int\n+ * \\param[in] number_of_timers int\n+ * \\param[in] number_of_clients int\n+ * \\param[in] number_of_services int\n+ * \\param[in] pycontext Capsule pointing to an rcl_context_t\n+ */\n+void\n+wait_set_init(\n+  py::capsule pywait_set,\n+  size_t number_of_subscriptions,\n+  size_t number_of_guard_conditions,\n+  size_t number_of_timers,\n+  size_t number_of_clients,\n+  size_t number_of_services,\n+  size_t number_of_events,\n+  py::capsule pycontext);\n+\n+/// Clear all the pointers in the wait set\n+/**\n+ * Raises RCLError if any rcl error occurs\n+ *\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ */\n+void\n+wait_set_clear_entities(py::capsule pywait_set);\n+\n+/// Add an entity to the wait set structure\n+/**\n+ * Raises RuntimeError if the entity type is unknown\n+ * Raises RCLError if any lower level error occurs\n+ *\n+ * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ * \\param[in] pyentity Capsule pointing to the entity to add\n+ * \\return Index in waitset entity was added at\n+ */\n+size_t\n+wait_set_add_entity(const std::string & entity_type, py::capsule pywait_set, py::capsule pyentity);\n+\n+/// Check if an entity in the wait set is ready by its index\n+/**\n+ * This must be called after waiting on the wait set.\n+ * Raises RuntimeError if the entity type is unknown\n+ * Raises IndexError if the given index is beyond the number of entities in the set\n+ *\n+ * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ * \\param[in] index location in the wait set of the entity to check\n+ * \\return True if the entity at the index in the wait set is not NULL\n+ */\n+bool\n+wait_set_is_ready(const std::string & entity_type, py::capsule pywait_set, size_t index);\n+\n+/// Get list of non-null entities in wait set\n+/**\n+ * Raises ValueError if pywait_set is not a wait set capsule\n+ * Raises RuntimeError if the entity type is not known\n+ *\n+ * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ * \\return List of wait set entities pointers ready for take\n+ */\n+py::list\n+get_ready_entities(const std::string & entity_type, py::capsule pywait_set);\n+\n+/// Wait until timeout is reached or event happened\n+/**\n+ * Raises ValueError if pywait_set is not a wait set capsule\n+ * Raises RCLError if there was an error while waiting\n+ *\n+ * This function will wait for an event to happen or for the timeout to expire.\n+ * A negative timeout means wait forever, a timeout of 0 means no wait\n+ * \\param[in] pywait_set Capsule pointing to the wait set structure\n+ * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n+ */\n+void\n+wait(py::capsule pywait_set, int64_t timeout);\n+}  // namespace rclpy\n+\n+#endif  // RCLPY__WAIT_SET_HPP_"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+extern const char * const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR;\n+"},{"role":"user","content":"+/// Check if loaned message is disabled, according to the environment variable.\n+/**\n+ * If the `ROS_DISABLE_LOANED_MESSAGES` environment variable is set to \"1\",\n+ * `disable_loaned_message` will be set to true.\n+ *\n+ * \\param[out] disable_loaned_message Must not be NULL.\n+ * \\return #RCL_RET_INVALID_ARGUMENT if an argument is not valid, or\n+ * \\return #RCL_RET_ERROR if an unexpected error happened, or\n+ * \\return #RCL_RET_OK.\n+ */\n+RCL_PUBLIC\n+rcl_ret_t\n+rcl_get_disable_loaned_message(bool * disable_loaned_message);\n+"},{"role":"user","content":"+#include \"rcutils/env.h\""},{"role":"user","content":"+const char * const RCL_DISABLE_LOANED_MESSAGES_ENV_VAR = \"ROS_DISABLE_LOANED_MESSAGES\";\n+"},{"role":"user","content":"+rcl_ret_t\n+rcl_get_disable_loaned_message(bool * disable_loaned_message)\n+{\n+  const char * env_val = NULL;\n+  const char * env_error_str = NULL;\n+\n+  RCL_CHECK_ARGUMENT_FOR_NULL(disable_loaned_message, RCL_RET_INVALID_ARGUMENT);\n+\n+  env_error_str = rcutils_get_env(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR, &env_val);\n+  if (NULL != env_error_str) {\n+    RCL_SET_ERROR_MSG_WITH_FORMAT_STRING(\n+      \"Error getting env var: '\" RCUTILS_STRINGIFY(RCL_DISABLE_LOANED_MESSAGES_ENV_VAR) \"': %s\\n\",\n+      env_error_str);\n+    return RCL_RET_ERROR;\n+  }\n+\n+  *disable_loaned_message = (strcmp(env_val, \"1\") == 0);\n+  return RCL_RET_OK;\n+}"},{"role":"user","content":"+\n+  bool disable_loaned_message = false;\n+  rcl_ret_t ret = rcl_get_disable_loaned_message(&disable_loaned_message);\n+  if (ret == RCL_RET_OK && disable_loaned_message) {\n+    return false;\n+  }\n+"},{"role":"user","content":"+\n+  bool disable_loaned_message = false;\n+  rcl_ret_t ret = rcl_get_disable_loaned_message(&disable_loaned_message);\n+  if (ret == RCL_RET_OK && disable_loaned_message) {\n+    return false;\n+  }\n+"},{"role":"user","content":"+#include \"rcutils/env.h\""},{"role":"user","content":"+\n+/* Tests special case node_options\n+ */\n+TEST_F(CLASSNAME(TestNodeFixture, RMW_IMPLEMENTATION), test_rcl_get_disable_loaned_message) {\n+  {\n+    EXPECT_EQ(RCL_RET_INVALID_ARGUMENT, rcl_get_disable_loaned_message(nullptr));\n+    rcl_reset_error();\n+  }\n+\n+  {\n+    bool disable_loaned_message = false;\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rcl\", rcutils_get_env, \"internal error\");\n+    EXPECT_EQ(RCL_RET_ERROR, rcl_get_disable_loaned_message(&disable_loaned_message));\n+    rcl_reset_error();\n+  }\n+\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    bool disable_loaned_message = true;\n+    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(&disable_loaned_message));\n+    EXPECT_FALSE(disable_loaned_message);\n+  }\n+\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"1\"));\n+    bool disable_loaned_message = false;\n+    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(&disable_loaned_message));\n+    EXPECT_TRUE(disable_loaned_message);\n+  }\n+\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"2\"));\n+    bool disable_loaned_message = true;\n+    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(&disable_loaned_message));\n+    EXPECT_FALSE(disable_loaned_message);\n+  }\n+\n+  {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"11\"));\n+    bool disable_loaned_message = true;\n+    EXPECT_EQ(RCL_RET_OK, rcl_get_disable_loaned_message(&disable_loaned_message));\n+    EXPECT_FALSE(disable_loaned_message);\n+  }\n+}"},{"role":"user","content":"+#include \"rcl/node.h\"\n+#include \"rcutils/env.h\""},{"role":"user","content":"+TEST_F(CLASSNAME(TestPublisherFixture, RMW_IMPLEMENTATION), test_publisher_loan_disable) {\n+  rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();\n+  const rosidl_message_type_support_t * ts =\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n+  constexpr char topic_name[] = \"pod_msg\";\n+  rcl_publisher_options_t publisher_options = rcl_publisher_get_default_options();\n+  rcl_ret_t ret =\n+    rcl_publisher_init(&publisher, this->node_ptr, ts, topic_name, &publisher_options);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_ret_t ret = rcl_publisher_fini(&publisher, this->node_ptr);\n+    EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  });\n+\n+  if (rcl_publisher_can_loan_messages(&publisher)) {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    EXPECT_TRUE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"1\"));\n+    EXPECT_FALSE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"2\"));\n+    EXPECT_TRUE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"Unexpected\"));\n+    EXPECT_TRUE(rcl_publisher_can_loan_messages(&publisher));\n+  } else {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    EXPECT_FALSE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"1\"));\n+    EXPECT_FALSE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"2\"));\n+    EXPECT_FALSE(rcl_publisher_can_loan_messages(&publisher));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"Unexpected\"));\n+    EXPECT_FALSE(rcl_publisher_can_loan_messages(&publisher));\n+  }\n+}\n+"},{"role":"user","content":"+#include \"rcl/node.h\"\n+#include \"rcutils/env.h\""},{"role":"user","content":"+TEST_F(CLASSNAME(TestSubscriptionFixture, RMW_IMPLEMENTATION), test_subscription_loan_disable) {\n+  rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();\n+  const rosidl_message_type_support_t * ts =\n+    ROSIDL_GET_MSG_TYPE_SUPPORT(test_msgs, msg, BasicTypes);\n+  constexpr char topic[] = \"pod_msg\";\n+  rcl_subscription_options_t subscription_options = rcl_subscription_get_default_options();\n+  rcl_ret_t ret =\n+    rcl_subscription_init(&subscription, this->node_ptr, ts, topic, &subscription_options);\n+  ASSERT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  OSRF_TESTING_TOOLS_CPP_SCOPE_EXIT(\n+  {\n+    rcl_ret_t ret = rcl_subscription_fini(&subscription, this->node_ptr);\n+    EXPECT_EQ(RCL_RET_OK, ret) << rcl_get_error_string().str;\n+  });\n+\n+  if (rcl_subscription_can_loan_messages(&subscription)) {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    EXPECT_TRUE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"1\"));\n+    EXPECT_FALSE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"2\"));\n+    EXPECT_TRUE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"Unexpected\"));\n+    EXPECT_TRUE(rcl_subscription_can_loan_messages(&subscription));\n+  } else {\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"0\"));\n+    EXPECT_FALSE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"1\"));\n+    EXPECT_FALSE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"2\"));\n+    EXPECT_FALSE(rcl_subscription_can_loan_messages(&subscription));\n+    ASSERT_TRUE(rcutils_set_env(\"ROS_DISABLE_LOANED_MESSAGES\", \"Unexpected\"));\n+    EXPECT_FALSE(rcl_subscription_can_loan_messages(&subscription));\n+  }\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from typing import Optional"},{"role":"user","content":"-    def wait_for_service(self, timeout_sec: float = None) -> bool:\n+    def wait_for_service(self, timeout_sec: Optional[float] = None) -> bool:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"rcutils/macros.h\"\n+"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"user","content":"+    RCUTILS_UNUSED(_);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  /// Move constructor\n+  RCLCPP_PUBLIC\n+  Time(Time && rhs) noexcept;\n+"},{"role":"user","content":"+   * Copy assignment operator"},{"role":"user","content":"+  /**\n+   * Move assignment operator\n+   */\n+  RCLCPP_PUBLIC\n+  Time &\n+  operator=(Time && rhs) noexcept;\n+"},{"role":"user","content":"+Time::Time(Time && rhs) noexcept = default;\n+"},{"role":"user","content":"-Time::~Time()\n-{\n-}\n+Time::~Time() = default;"},{"role":"user","content":"+Time &\n+Time::operator=(Time && rhs) noexcept = default;\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+[pytest]\n+junit_family=xunit2"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    Ogre::Vector3 parent_position = mParentNode->_getDerivedPosition() +\n-      Ogre::Vector3::UNIT_Y * global_translation_;\n+    Ogre::Vector3 parent_position = mParentNode->_getDerivedPosition() + global_translation_;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+from rclpy.executors import ExternalShutdownException"},{"role":"user","content":"-    rclpy.init(args=args)\n-\n-    node = Listener()"},{"role":"user","content":"-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n+        with rclpy.init(args=args):\n+            node = Listener()\n+            rclpy.spin(node)\n+    except (KeyboardInterrupt, ExternalShutdownException):"},{"role":"user","content":"-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()"},{"role":"user","content":"+from rclpy.executors import ExternalShutdownException"},{"role":"user","content":"-    rclpy.init(args=args)\n-\n-    node = TestNode()\n-"},{"role":"user","content":"-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n+        with rclpy.init(args=args):\n+            node = TestNode()\n+            rclpy.spin(node)\n+    except (KeyboardInterrupt, ExternalShutdownException):"},{"role":"user","content":"-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()"},{"role":"user","content":"+from rclpy.executors import ExternalShutdownException"},{"role":"user","content":"-    rclpy.init(args=args)\n-\n-    node = Talker()\n-"},{"role":"user","content":"-        rclpy.spin(node)\n-    except KeyboardInterrupt:\n+        with rclpy.init(args=args):\n+            node = Talker()\n+            rclpy.spin(node)\n+    except (KeyboardInterrupt, ExternalShutdownException):"},{"role":"user","content":"-    finally:\n-        node.destroy_node()\n-        rclpy.shutdown()"},{"role":"user","content":"-    rclpy.init()\n-    node = rclpy.create_node('test_ros_timer_action_node')\n-    yield node\n-    rclpy.shutdown()\n+    with rclpy.init():\n+        node = rclpy.create_node('test_ros_timer_action_node')\n+        yield node"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()\n+            wait_set = None"},{"role":"user","content":"-                _rclpy.rclpy_wait_set_init(\n-                    wait_set,\n+                wait_set = _rclpy.WaitSet("},{"role":"user","content":"-                _rclpy.rclpy_wait_set_clear_entities(wait_set)\n+                wait_set.clear_entities()"},{"role":"user","content":"-                    _rclpy.rclpy_wait_set_add_subscription(wait_set, sub_handle)\n+                    wait_set.add_subscription(sub_handle)"},{"role":"user","content":"-                    _rclpy.rclpy_wait_set_add_client(wait_set, cli_handle)\n+                    wait_set.add_client(cli_handle)"},{"role":"user","content":"-                    _rclpy.rclpy_wait_set_add_service(wait_set, srv_capsule)\n+                    wait_set.add_service(srv_capsule)"},{"role":"user","content":"-                    _rclpy.rclpy_wait_set_add_timer(wait_set, tmr_handle)\n+                    wait_set.add_timer(tmr_handle)"},{"role":"user","content":"-                    _rclpy.rclpy_wait_set_add_entity('guard_condition', wait_set, gc_capsule)\n+                    wait_set.add_entity('guard_condition', gc_capsule)"},{"role":"user","content":"-                _rclpy.rclpy_wait(wait_set, timeout_nsec)\n+                wait_set.wait(timeout_nsec)"},{"role":"user","content":"-                subs_ready = _rclpy.rclpy_get_ready_entities('subscription', wait_set)\n-                guards_ready = _rclpy.rclpy_get_ready_entities('guard_condition', wait_set)\n-                timers_ready = _rclpy.rclpy_get_ready_entities('timer', wait_set)\n-                clients_ready = _rclpy.rclpy_get_ready_entities('client', wait_set)\n-                services_ready = _rclpy.rclpy_get_ready_entities('service', wait_set)\n+                subs_ready = wait_set.get_ready_entities('subscription')\n+                guards_ready = wait_set.get_ready_entities('guard_condition')\n+                timers_ready = wait_set.get_ready_entities('timer')\n+                clients_ready = wait_set.get_ready_entities('client')\n+                services_ready = wait_set.get_ready_entities('service')"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('event', wait_set, self._event_index):\n+        if wait_set.is_ready('event', self._event_index):"},{"role":"user","content":"-            self._event_index = _rclpy.rclpy_wait_set_add_event(wait_set, self.__event)\n+            self._event_index = wait_set.add_event(self.__event)"},{"role":"user","content":"-\n-  m.def(\n-    \"rclpy_get_zero_initialized_wait_set\", &rclpy::get_zero_initialized_wait_set,\n-    \"rclpy_get_zero_initialized_wait_set.\");\n-  m.def(\n-    \"rclpy_wait_set_init\", &rclpy::wait_set_init,\n-    \"rclpy_wait_set_init.\");\n-  m.def(\n-    \"rclpy_wait_set_clear_entities\", &rclpy::wait_set_clear_entities,\n-    \"rclpy_wait_set_clear_entities.\");\n-  m.def(\n-    \"rclpy_wait_set_add_entity\", &rclpy::wait_set_add_entity,\n-    \"rclpy_wait_set_add_entity.\");\n-  m.def(\n-    \"rclpy_wait_set_add_client\", &rclpy::wait_set_add_client,\n-    \"Add a client to the wait set.\");\n-  m.def(\n-    \"rclpy_wait_set_add_service\", &rclpy::wait_set_add_service,\n-    \"Add a service to the wait set.\");\n-  m.def(\n-    \"rclpy_wait_set_add_subscription\", &rclpy::wait_set_add_subscription,\n-    \"Add a subscription to the wait set.\");\n-  m.def(\n-    \"rclpy_wait_set_add_timer\", &rclpy::wait_set_add_timer,\n-    \"Add a timer to the wait set.\");\n-  m.def(\n-    \"rclpy_wait_set_add_event\", &rclpy::wait_set_add_event,\n-    \"Add an event to the wait set.\");\n-  m.def(\n-    \"rclpy_wait_set_is_ready\", &rclpy::wait_set_is_ready,\n-    \"rclpy_wait_set_is_ready.\");\n-  m.def(\n-    \"rclpy_get_ready_entities\", &rclpy::get_ready_entities,\n-    \"List non null entities in wait set.\");\n-  m.def(\n-    \"rclpy_wait\", &rclpy::wait,\n-    \"rclpy_wait.\");\n+  rclpy::define_waitset(m);"},{"role":"user","content":"-ActionClient::add_to_waitset(py::capsule pywait_set)\n+ActionClient::add_to_waitset(WaitSet & wait_set)"},{"role":"user","content":"-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    wait_set, rcl_action_client_.get(), NULL, NULL);\n+    wait_set.rcl_ptr(), rcl_action_client_.get(), NULL, NULL);"},{"role":"user","content":"-ActionClient::is_ready(py::capsule pywait_set)\n+ActionClient::is_ready(WaitSet & wait_set)"},{"role":"user","content":"-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    wait_set,\n+    wait_set.rcl_ptr(),"},{"role":"user","content":"+#include \"wait_set.hpp\""},{"role":"user","content":"-   * \\param[in] pywait_set Capsule pointing to the wait set structure.\n+   * \\param[in] wait_set Capsule pointing to the wait set structure."},{"role":"user","content":"-  is_ready(py::capsule pywait_set);\n+  is_ready(WaitSet & wait_set);"},{"role":"user","content":"-   * \\param[in] pywait_set Capsule pointer to an rcl_wait_set_t.\n+   * \\param[in] wait_set Capsule pointer to an rcl_wait_set_t."},{"role":"user","content":"-  add_to_waitset(py::capsule pywait_set);\n+  add_to_waitset(WaitSet & wait_set);"},{"role":"user","content":"-ActionServer::is_ready(py::capsule pywait_set)\n+ActionServer::is_ready(WaitSet & wait_set)"},{"role":"user","content":"-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);"},{"role":"user","content":"-    wait_set,\n+    wait_set.rcl_ptr(),"},{"role":"user","content":"-ActionServer::add_to_waitset(py::capsule pywait_set)\n+ActionServer::add_to_waitset(WaitSet & wait_set)"},{"role":"user","content":"-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-  rcl_ret_t ret = rcl_action_wait_set_add_action_server(wait_set, rcl_action_server_.get(), NULL);\n+  rcl_ret_t ret = rcl_action_wait_set_add_action_server(\n+    wait_set.rcl_ptr(), rcl_action_server_.get(), NULL);"},{"role":"user","content":"+#include \"wait_set.hpp\""},{"role":"user","content":"-  is_ready(py::capsule pywait_set);\n+  is_ready(WaitSet & wait_set);"},{"role":"user","content":"-  add_to_waitset(py::capsule pywait_set);\n+  add_to_waitset(WaitSet & wait_set);"},{"role":"user","content":"-/// Destructor for a wait set\n-void\n-_rclpy_destroy_wait_set(PyObject * pycapsule)\n-{\n-  auto wait_set = static_cast<rcl_wait_set_t *>(PyCapsule_GetPointer(pycapsule, \"rcl_wait_set_t\"));\n-\n-  rcl_ret_t ret = rcl_wait_set_fini(wait_set);\n-  if (ret != RCL_RET_OK) {\n-    // Warning should use line number of the current stack frame\n-    int stack_level = 1;\n-    PyErr_WarnFormat(\n-      PyExc_RuntimeWarning, stack_level,\n-      \"Failed to fini wait set: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-  }\n-\n-  PyMem_Free(wait_set);\n-}\n-\n-py::capsule\n-get_zero_initialized_wait_set()\n+WaitSet::WaitSet()"},{"role":"user","content":"-  auto deleter = [](rcl_wait_set_t * ptr) {PyMem_FREE(ptr);};\n-  auto wait_set = std::unique_ptr<rcl_wait_set_t, decltype(deleter)>(\n-    static_cast<rcl_wait_set_t *>(PyMem_Malloc(sizeof(rcl_wait_set_t))),\n-    deleter);\n-  if (!wait_set) {\n-    throw std::bad_alloc();\n-  }\n-\n-  *wait_set = rcl_get_zero_initialized_wait_set();\n-  return py::capsule(wait_set.release(), \"rcl_wait_set_t\", _rclpy_destroy_wait_set);\n+  // Create a client\n+  rcl_wait_set_ = std::shared_ptr<rcl_wait_set_t>(\n+    new rcl_wait_set_t,\n+    [](rcl_wait_set_t * waitset)\n+    {\n+      rcl_ret_t ret = rcl_wait_set_fini(waitset);\n+      if (RCL_RET_OK != ret) {\n+        // Warning should use line number of the current stack frame\n+        int stack_level = 1;\n+        PyErr_WarnFormat(\n+          PyExc_RuntimeWarning, stack_level, \"Failed to fini wait set: %s\",\n+          rcl_get_error_string().str);\n+        rcl_reset_error();\n+      }\n+      delete waitset;\n+    });\n+  *rcl_wait_set_ = rcl_get_zero_initialized_wait_set();"},{"role":"user","content":"-void\n-wait_set_init(\n-  py::capsule pywait_set,\n+WaitSet::WaitSet("},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+  // Create a client\n+  rcl_wait_set_ = std::shared_ptr<rcl_wait_set_t>(\n+    new rcl_wait_set_t,\n+    [](rcl_wait_set_t * waitset)\n+    {\n+      rcl_ret_t ret = rcl_wait_set_fini(waitset);\n+      if (RCL_RET_OK != ret) {\n+        // Warning should use line number of the current stack frame\n+        int stack_level = 1;\n+        PyErr_WarnFormat(\n+          PyExc_RuntimeWarning, stack_level, \"Failed to fini wait set: %s\",\n+          rcl_get_error_string().str);\n+        rcl_reset_error();\n+      }\n+      delete waitset;\n+    });\n+  *rcl_wait_set_ = rcl_get_zero_initialized_wait_set();"},{"role":"user","content":"-    wait_set,\n+    rcl_wait_set_.get(),"},{"role":"user","content":"-  if (ret != RCL_RET_OK) {\n+  if (RCL_RET_OK != ret) {"},{"role":"user","content":"-wait_set_clear_entities(py::capsule pywait_set)\n+WaitSet::destroy()"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n+  rcl_wait_set_.reset();\n+}"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_clear(wait_set);\n+void\n+WaitSet::clear_entities()\n+{\n+  rcl_ret_t ret = rcl_wait_set_clear(rcl_wait_set_.get());"},{"role":"user","content":"-wait_set_add_entity(const std::string & entity_type, py::capsule pywait_set, py::capsule pyentity)\n+WaitSet::add_entity(const std::string & entity_type, py::capsule pyentity)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    ret = rcl_wait_set_add_guard_condition(wait_set, guard_condition, &index);\n+    ret = rcl_wait_set_add_guard_condition(rcl_wait_set_.get(), guard_condition, &index);"},{"role":"user","content":"-wait_set_add_service(const py::capsule pywait_set, const Service & service)\n+WaitSet::add_service(const Service & service)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_add_service(wait_set, service.rcl_ptr(), &index);\n+  rcl_ret_t ret = rcl_wait_set_add_service(rcl_wait_set_.get(), service.rcl_ptr(), &index);"},{"role":"user","content":"-wait_set_add_subscription(const py::capsule pywait_set, const Subscription & subscription)\n+WaitSet::add_subscription(const Subscription & subscription)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_add_subscription(wait_set, subscription.rcl_ptr(), &index);\n+  rcl_ret_t ret = rcl_wait_set_add_subscription(\n+    rcl_wait_set_.get(), subscription.rcl_ptr(), &index);"},{"role":"user","content":"-wait_set_add_timer(const py::capsule pywait_set, const Timer & timer)\n+WaitSet::add_timer(const Timer & timer)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_add_timer(wait_set, timer.rcl_ptr(), &index);\n+  rcl_ret_t ret = rcl_wait_set_add_timer(rcl_wait_set_.get(), timer.rcl_ptr(), &index);"},{"role":"user","content":"-wait_set_add_client(const py::capsule pywait_set, const Client & client)\n+WaitSet::add_client(const Client & client)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_add_client(wait_set, client.rcl_ptr(), &index);\n+  rcl_ret_t ret = rcl_wait_set_add_client(rcl_wait_set_.get(), client.rcl_ptr(), &index);"},{"role":"user","content":"-wait_set_add_event(const py::capsule pywait_set, const QoSEvent & event)\n+WaitSet::add_event(const QoSEvent & event)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-  rcl_ret_t ret = rcl_wait_set_add_event(wait_set, event.rcl_ptr(), &index);\n+  rcl_ret_t ret = rcl_wait_set_add_event(rcl_wait_set_.get(), event.rcl_ptr(), &index);"},{"role":"user","content":"-wait_set_is_ready(const std::string & entity_type, py::capsule pywait_set, size_t index)\n+WaitSet::is_ready(const std::string & entity_type, size_t index)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->subscriptions);\n-    num_entities = wait_set->size_of_subscriptions;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->subscriptions);\n+    num_entities = rcl_wait_set_->size_of_subscriptions;"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->clients);\n-    num_entities = wait_set->size_of_clients;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->clients);\n+    num_entities = rcl_wait_set_->size_of_clients;"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->services);\n-    num_entities = wait_set->size_of_services;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->services);\n+    num_entities = rcl_wait_set_->size_of_services;"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->timers);\n-    num_entities = wait_set->size_of_timers;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->timers);\n+    num_entities = rcl_wait_set_->size_of_timers;"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->guard_conditions);\n-    num_entities = wait_set->size_of_guard_conditions;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->guard_conditions);\n+    num_entities = rcl_wait_set_->size_of_guard_conditions;"},{"role":"user","content":"-    entities = reinterpret_cast<const void **>(wait_set->events);\n-    num_entities = wait_set->size_of_events;\n+    entities = reinterpret_cast<const void **>(rcl_wait_set_->events);\n+    num_entities = rcl_wait_set_->size_of_events;"},{"role":"user","content":"-get_ready_entities(const std::string & entity_type, py::capsule pywait_set)\n+WaitSet::get_ready_entities(const std::string & entity_type)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    return _get_ready_entities(wait_set->subscriptions, wait_set->size_of_subscriptions);\n+    return _get_ready_entities(\n+      rcl_wait_set_->subscriptions, rcl_wait_set_->size_of_subscriptions);"},{"role":"user","content":"-    return _get_ready_entities(wait_set->clients, wait_set->size_of_clients);\n+    return _get_ready_entities(\n+      rcl_wait_set_->clients, rcl_wait_set_->size_of_clients);"},{"role":"user","content":"-    return _get_ready_entities(wait_set->services, wait_set->size_of_services);\n+    return _get_ready_entities(\n+      rcl_wait_set_->services, rcl_wait_set_->size_of_services);"},{"role":"user","content":"-    return _get_ready_entities(wait_set->timers, wait_set->size_of_timers);\n+    return _get_ready_entities(\n+      rcl_wait_set_->timers, rcl_wait_set_->size_of_timers);"},{"role":"user","content":"-    return _get_ready_entities(wait_set->guard_conditions, wait_set->size_of_guard_conditions);\n+    return _get_ready_entities(\n+      rcl_wait_set_->guard_conditions, rcl_wait_set_->size_of_guard_conditions);"},{"role":"user","content":"-wait(py::capsule pywait_set, int64_t timeout)\n+WaitSet::wait(int64_t timeout)"},{"role":"user","content":"-  if (0 != std::strcmp(\"rcl_wait_set_t\", pywait_set.name())) {\n-    throw py::value_error(\"capsule is not an rcl_wait_set_t\");\n-  }\n-  auto wait_set = static_cast<rcl_wait_set_t *>(pywait_set);\n-"},{"role":"user","content":"-    ret = rcl_wait(wait_set, timeout);\n+    ret = rcl_wait(rcl_wait_set_.get(), timeout);"},{"role":"user","content":"-  if (ret != RCL_RET_OK && ret != RCL_RET_TIMEOUT) {\n+  if (RCL_RET_OK != ret && RCL_RET_TIMEOUT != ret) {"},{"role":"user","content":"+\n+void define_waitset(py::object module)\n+{\n+  py::class_<WaitSet, Destroyable, std::shared_ptr<WaitSet>>(module, \"WaitSet\")\n+  .def(py::init<size_t, size_t, size_t, size_t, size_t, size_t, py::capsule>())\n+  .def(py::init<>())\n+  .def_property_readonly(\n+    \"pointer\", [](const WaitSet & waitset) {\n+      return reinterpret_cast<size_t>(waitset.rcl_ptr());\n+    },\n+    \"Get the address of the entity as an integer\")\n+  .def(\n+    \"clear_entities\", &WaitSet::clear_entities,\n+    \"Clear all the pointers in the wait set\")\n+  .def(\n+    \"add_entity\", &WaitSet::add_entity,\n+    \"Add an entity to the wait set structure\")\n+  .def(\n+    \"add_service\", &WaitSet::add_service,\n+    \"Add a service to the wait set structure\")\n+  .def(\n+    \"add_subscription\", &WaitSet::add_subscription,\n+    \"Add a subcription to the wait set structure\")\n+  .def(\n+    \"add_client\", &WaitSet::add_client,\n+    \"Add a client to the wait set structure\")\n+  .def(\n+    \"add_timer\", &WaitSet::add_timer,\n+    \"Add a timer to the wait set structure\")\n+  .def(\n+    \"add_event\", &WaitSet::add_event,\n+    \"Add an event to the wait set structure\")\n+  .def(\n+    \"is_ready\", &WaitSet::is_ready,\n+    \"Check if an entity in the wait set is ready by its index\")\n+  .def(\n+    \"get_ready_entities\", &WaitSet::get_ready_entities,\n+    \"Get list of entities ready by entity type\")\n+  .def(\n+    \"wait\", &WaitSet::wait,\n+    \"Wait until timeout is reached or event happened\");\n+}"},{"role":"user","content":"+#include \"destroyable.hpp\""},{"role":"user","content":"-/// Return a Capsule pointing to a zero initialized rcl_wait_set_t structure\n-py::capsule\n-get_zero_initialized_wait_set();\n-\n-/// Initialize a wait set\n-/**\n- * Raises RCLError if the wait set could not be initialized\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] node_name string name of the node to be created\n- * \\param[in] number_of_subscriptions int\n- * \\param[in] number_of_guard_conditions int\n- * \\param[in] number_of_timers int\n- * \\param[in] number_of_clients int\n- * \\param[in] number_of_services int\n- * \\param[in] pycontext Capsule pointing to an rcl_context_t\n- */\n-void\n-wait_set_init(\n-  py::capsule pywait_set,\n-  size_t number_of_subscriptions,\n-  size_t number_of_guard_conditions,\n-  size_t number_of_timers,\n-  size_t number_of_clients,\n-  size_t number_of_services,\n-  size_t number_of_events,\n-  py::capsule pycontext);\n-\n-/// Clear all the pointers in the wait set\n-/**\n- * Raises RCLError if any rcl error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- */\n-void\n-wait_set_clear_entities(py::capsule pywait_set);\n-\n-/// Add an entity to the wait set structure\n-/**\n- * Raises RuntimeError if the entity type is unknown\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] pyentity Capsule pointing to the entity to add\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_entity(const std::string & entity_type, py::capsule pywait_set, py::capsule pyentity);\n-\n-/// Add a service to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] service a service to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_service(const py::capsule pywait_set, const Service & service);\n-\n-/// Add a subcription to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] service a service to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_subscription(const py::capsule pywait_set, const Subscription & subscription);\n-\n-/// Add a client to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] client a client to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_client(const py::capsule pywait_set, const Client & client);\n-\n-/// Add a timer to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timer a timer to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_timer(const py::capsule pywait_set, const Timer & timer);\n-\n-/// Add an event to the wait set structure\n-/**\n- * Raises RCLError if any lower level error occurs\n- *\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] event a QoSEvent to add to the wait set\n- * \\return Index in waitset entity was added at\n- */\n-size_t\n-wait_set_add_event(const py::capsule pywait_set, const QoSEvent & event);\n-\n-/// Check if an entity in the wait set is ready by its index\n-/**\n- * This must be called after waiting on the wait set.\n- * Raises RuntimeError if the entity type is unknown\n- * Raises IndexError if the given index is beyond the number of entities in the set\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] index location in the wait set of the entity to check\n- * \\return True if the entity at the index in the wait set is not NULL\n- */\n-bool\n-wait_set_is_ready(const std::string & entity_type, py::capsule pywait_set, size_t index);\n-\n-/// Get list of non-null entities in wait set\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RuntimeError if the entity type is not known\n- *\n- * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\return List of wait set entities pointers ready for take\n- */\n-py::list\n-get_ready_entities(const std::string & entity_type, py::capsule pywait_set);\n-\n-/// Wait until timeout is reached or event happened\n-/**\n- * Raises ValueError if pywait_set is not a wait set capsule\n- * Raises RCLError if there was an error while waiting\n- *\n- * This function will wait for an event to happen or for the timeout to expire.\n- * A negative timeout means wait forever, a timeout of 0 means no wait\n- * \\param[in] pywait_set Capsule pointing to the wait set structure\n- * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n- */\n-void\n-wait(py::capsule pywait_set, int64_t timeout);\n+class WaitSet : public Destroyable, public std::enable_shared_from_this<WaitSet>\n+{\n+public:\n+  /// Initialize a wait set\n+  WaitSet();\n+\n+  /// Initialize a wait set\n+  /**\n+   * Raises RCLError if the wait set could not be initialized\n+   *\n+   * \\param[in] node_name string name of the node to be created\n+   * \\param[in] number_of_subscriptions a positive number or zero\n+   * \\param[in] number_of_guard_conditions int\n+   * \\param[in] number_of_timers int\n+   * \\param[in] number_of_clients int\n+   * \\param[in] number_of_services int\n+   * \\param[in] pycontext Capsule pointing to an rcl_context_t\n+   */\n+  WaitSet(\n+    size_t number_of_subscriptions,\n+    size_t number_of_guard_conditions,\n+    size_t number_of_timers,\n+    size_t number_of_clients,\n+    size_t number_of_services,\n+    size_t number_of_events,\n+    py::capsule pycontext);\n+\n+  /// Clear all the pointers in the wait set\n+  /**\n+   * Raises RCLError if any rcl error occurs\n+   */\n+  void\n+  clear_entities();\n+\n+  /// Add an entity to the wait set structure\n+  /**\n+   * Raises RuntimeError if the entity type is unknown\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+   * \\param[in] pyentity Capsule pointing to the entity to add\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_entity(const std::string & entity_type, py::capsule pyentity);\n+\n+  /// Add a service to the wait set structure\n+  /**\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] service a service to add to the wait set\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_service(const Service & service);\n+\n+  /// Add a subcription to the wait set structure\n+  /**\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] service a service to add to the wait set\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_subscription(const Subscription & subscription);\n+\n+  /// Add a client to the wait set structure\n+  /**\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] client a client to add to the wait set\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_client(const Client & client);\n+\n+  /// Add a timer to the wait set structure\n+  /**\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] timer a timer to add to the wait set\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_timer(const Timer & timer);\n+\n+  /// Add an event to the wait set structure\n+  /**\n+   * Raises RCLError if any lower level error occurs\n+   *\n+   * \\param[in] event a QoSEvent to add to the wait set\n+   * \\return Index in waitset entity was added at\n+   */\n+  size_t\n+  add_event(const QoSEvent & event);\n+\n+  /// Check if an entity in the wait set is ready by its index\n+  /**\n+   * This must be called after waiting on the wait set.\n+   * Raises RuntimeError if the entity type is unknown\n+   * Raises IndexError if the given index is beyond the number of entities in the set\n+   *\n+   * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+   * \\param[in] index location in the wait set of the entity to check\n+   * \\return True if the entity at the index in the wait set is not NULL\n+   */\n+  bool\n+  is_ready(const std::string & entity_type, size_t index);\n+\n+  /// Get list of entities ready by entity type\n+  /**\n+   * Raises RuntimeError if the entity type is not known\n+   *\n+   * \\param[in] entity_type string defining the entity [\"subscription, client, service\"]\n+   * \\return List of wait set entities pointers ready for take\n+   */\n+  py::list\n+  get_ready_entities(const std::string & entity_type);\n+\n+  /// Wait until timeout is reached or event happened\n+  /**\n+   * Raises RCLError if there was an error while waiting\n+   *\n+   * This function will wait for an event to happen or for the timeout to expire.\n+   * A negative timeout means wait forever, a timeout of 0 means no wait\n+   * \\param[in] timeout optional time to wait before waking up (in nanoseconds)\n+   */\n+  void\n+  wait(int64_t timeout);\n+\n+  /// Get rcl_client_t pointer\n+  rcl_wait_set_t * rcl_ptr() const\n+  {\n+    return rcl_wait_set_.get();\n+  }\n+\n+  /// Force an early destruction of this object\n+  void destroy() override;\n+\n+private:\n+  std::shared_ptr<rcl_wait_set_t> rcl_wait_set_;\n+};\n+\n+/// Define a pybind11 wrapper for an rclpy::Service\n+void define_waitset(py::object module);"},{"role":"user","content":"-        wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()"},{"role":"user","content":"-            _rclpy.rclpy_wait_set_init(wait_set, 0, 0, 0, 0, 0, 3, context_handle)\n+            wait_set = _rclpy.WaitSet(0, 0, 0, 0, 0, 3, context_handle)"},{"role":"user","content":"-            deadline_event_index = _rclpy.rclpy_wait_set_add_event(wait_set, deadline_event_handle)\n+            deadline_event_index = wait_set.add_event(deadline_event_handle)"},{"role":"user","content":"-            liveliness_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, liveliness_event_handle)\n+            liveliness_event_index = wait_set.add_event(\n+                    liveliness_event_handle)"},{"role":"user","content":"-                incompatible_qos_event_index = _rclpy.rclpy_wait_set_add_event(\n-                        wait_set, incompatible_qos_event_handle)\n+                incompatible_qos_event_index = wait_set.add_event(\n+                        incompatible_qos_event_handle)"},{"role":"user","content":"-        _rclpy.rclpy_wait(wait_set, 0)\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready('event', wait_set, deadline_event_index))\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready('event', wait_set, liveliness_event_index))\n+        wait_set.wait(0)\n+        self.assertFalse(wait_set.is_ready('event', deadline_event_index))\n+        self.assertFalse(wait_set.is_ready('event', liveliness_event_index))"},{"role":"user","content":"-            self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\n-                'event', wait_set, incompatible_qos_event_index))\n+            self.assertFalse(wait_set.is_ready(\n+                'event', incompatible_qos_event_index))"},{"role":"user","content":"-        wait_set = _rclpy.rclpy_get_zero_initialized_wait_set()"},{"role":"user","content":"-            _rclpy.rclpy_wait_set_init(wait_set, 0, 0, 0, 0, 0, 3, context_handle)\n+            wait_set = _rclpy.WaitSet(0, 0, 0, 0, 0, 3, context_handle)"},{"role":"user","content":"-            deadline_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, deadline_event_handle)\n+            deadline_event_index = wait_set.add_event(deadline_event_handle)"},{"role":"user","content":"-            liveliness_event_index = _rclpy.rclpy_wait_set_add_event(\n-                    wait_set, liveliness_event_handle)\n+            liveliness_event_index = wait_set.add_event(liveliness_event_handle)"},{"role":"user","content":"-                incompatible_qos_event_index = _rclpy.rclpy_wait_set_add_event(\n-                        wait_set, incompatible_qos_event_handle)\n+                incompatible_qos_event_index = wait_set.add_event(\n+                        incompatible_qos_event_handle)"},{"role":"user","content":"-        _rclpy.rclpy_wait(wait_set, 0)\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready('event', wait_set, deadline_event_index))\n-        self.assertFalse(_rclpy.rclpy_wait_set_is_ready('event', wait_set, liveliness_event_index))\n+        wait_set.wait(0)\n+        self.assertFalse(wait_set.is_ready('event', deadline_event_index))\n+        self.assertFalse(wait_set.is_ready('event', liveliness_event_index))"},{"role":"user","content":"-            self.assertFalse(_rclpy.rclpy_wait_set_is_ready(\n-                'event', wait_set, incompatible_qos_event_index))\n+            self.assertFalse(wait_set.is_ready(\n+                'event', incompatible_qos_event_index))"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('client', wait_set, self.client_index):\n+        if wait_set.is_ready('client', self.client_index):"},{"role":"user","content":"-        self.client_index = _rclpy.rclpy_wait_set_add_client(wait_set, self.client)\n+        self.client_index = wait_set.add_client(self.client)"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('service', wait_set, self.server_index):\n+        if wait_set.is_ready('service', self.server_index):"},{"role":"user","content":"-        self.server_index = _rclpy.rclpy_wait_set_add_service(wait_set, self.server)\n+        self.server_index = wait_set.add_service(self.server)"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('timer', wait_set, self.timer_index):\n+        if wait_set.is_ready('timer', self.timer_index):"},{"role":"user","content":"-        self.timer_index = _rclpy.rclpy_wait_set_add_timer(wait_set, self.timer)\n+        self.timer_index = wait_set.add_timer(self.timer)"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('subscription', wait_set, self.subscription_index):\n+        if wait_set.is_ready('subscription', self.subscription_index):"},{"role":"user","content":"-        self.subscription_index = _rclpy.rclpy_wait_set_add_subscription(\n-            wait_set, self.subscription)\n+        self.subscription_index = wait_set.add_subscription(\n+            self.subscription)"},{"role":"user","content":"-        if _rclpy.rclpy_wait_set_is_ready('guard_condition', wait_set, self.guard_condition_index):\n+        if wait_set.is_ready('guard_condition', self.guard_condition_index):"},{"role":"user","content":"-        self.guard_condition_index = _rclpy.rclpy_wait_set_add_entity(\n-            'guard_condition', wait_set, self.guard_condition)\n+        self.guard_condition_index = wait_set.add_entity(\n+            'guard_condition', self.guard_condition)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#ifdef ROSIDL_TYPESUPPORT_FASTRTPS_HAS_PLAIN_TYPES\n+  char bounds_info;\n+  serialized_size_max =\n+    static_cast<uint32_t>(callbacks->max_serialized_size(bounds_info));\n+  full_bounded = 0 != (bounds_info & ROSIDL_TYPESUPPORT_FASTRTPS_BOUNDED_TYPE);\n+#else"},{"role":"user","content":"+#endif"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  return status == 0;\n+  return status == 0 && p_built.is_directory();"},{"role":"user","content":"+  EXPECT_FALSE(rcpputils::fs::create_directories(file));"},{"role":"user","content":"+\n+  // Empty path/directory cannot be created\n+  EXPECT_FALSE(rcpputils::fs::create_directories(rcpputils::fs::path(\"\")));"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  target_link_libraries(test_static_single_threaded_executor ${PROJECT_NAME})\n+  ament_target_dependencies(test_static_single_threaded_executor\n+    \"test_msgs\")\n+  target_link_libraries(test_static_single_threaded_executor ${PROJECT_NAME} mimick)"},{"role":"user","content":"+#include <future>"},{"role":"user","content":"+#include <stdexcept>"},{"role":"user","content":"+#include \"test_msgs/srv/empty.hpp\"\n+\n+#include \"../../mocking_utils/patch.hpp\"\n+#include \"../../utils/rclcpp_gtest_macros.hpp\"\n+"},{"role":"user","content":"+\n+TEST_F(TestStaticSingleThreadedExecutor, add_callback_group_trigger_guard_failed) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_trigger_guard_condition, RCL_RET_ERROR);\n+    RCLCPP_EXPECT_THROW_EQ(\n+      executor.add_callback_group(cb_group, node->get_node_base_interface(), true),\n+      std::runtime_error(\"error not set\"));\n+  }\n+}\n+\n+TEST_F(TestStaticSingleThreadedExecutor, add_node_trigger_guard_failed) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_trigger_guard_condition, RCL_RET_ERROR);\n+    RCLCPP_EXPECT_THROW_EQ(\n+      executor.add_node(node),\n+      std::runtime_error(\"error not set\"));\n+  }\n+}\n+\n+TEST_F(TestStaticSingleThreadedExecutor, remove_callback_group_trigger_guard_failed) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  rclcpp::CallbackGroup::SharedPtr cb_group = node->create_callback_group(\n+    rclcpp::CallbackGroupType::MutuallyExclusive);\n+\n+  executor.add_callback_group(cb_group, node->get_node_base_interface(), true);\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_trigger_guard_condition, RCL_RET_ERROR);\n+    RCLCPP_EXPECT_THROW_EQ(\n+      executor.remove_callback_group(cb_group, true),\n+      std::runtime_error(\"error not set\"));\n+  }\n+}\n+\n+TEST_F(TestStaticSingleThreadedExecutor, remove_node_failed) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_trigger_guard_condition, RCL_RET_ERROR);\n+    RCLCPP_EXPECT_THROW_EQ(\n+      executor.remove_node(node, true),\n+      std::runtime_error(\"Node needs to be associated with this executor.\"));\n+  }\n+}\n+\n+TEST_F(TestStaticSingleThreadedExecutor, remove_node_trigger_guard_failed) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+\n+  executor.add_node(node);\n+\n+  {\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_trigger_guard_condition, RCL_RET_ERROR);\n+    RCLCPP_EXPECT_THROW_EQ(\n+      executor.remove_node(node, true),\n+      std::runtime_error(\"error not set\"));\n+  }\n+}\n+\n+TEST_F(TestStaticSingleThreadedExecutor, execute_service) {\n+  rclcpp::executors::StaticSingleThreadedExecutor executor;\n+  auto node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n+  executor.add_node(node);\n+\n+  auto service =\n+    node->create_service<test_msgs::srv::Empty>(\n+    \"service\",\n+    [](\n+      const test_msgs::srv::Empty::Request::SharedPtr,\n+      test_msgs::srv::Empty::Response::SharedPtr) {});\n+  auto client = node->create_client<test_msgs::srv::Empty>(\"service\");\n+\n+  std::promise<void> promise;\n+  std::future<void> future = promise.get_future();\n+  EXPECT_EQ(\n+    rclcpp::FutureReturnCode::TIMEOUT,\n+    executor.spin_until_future_complete(future, std::chrono::milliseconds(1)));\n+\n+  executor.remove_node(node);\n+  executor.spin_until_future_complete(future, std::chrono::milliseconds(1));\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            self.node, 'lookup_transform', check_frequency=10.0, timeout_padding=0.0)\n+            self.node, 'lookup_transform', check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))"},{"role":"user","content":"-            self.node, 'lookup_transform', check_frequency=10.0, timeout_padding=0.0)\n+            self.node, 'lookup_transform', check_frequency=10.0, timeout_padding=rclpy.duration.Duration(seconds=0.0))"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  endif()"},{"role":"user","content":"-  ament_add_pytest_test(test_cli_extension test/test_cli_extension.py\n-    PYTHON_EXECUTABLE \"${BUILDTYPE_PYTHON_EXECUTABLE}\"\n-  )\n+    ament_add_pytest_test(test_cli_extension test/test_cli_extension.py\n+      PYTHON_EXECUTABLE \"${BUILDTYPE_PYTHON_EXECUTABLE}\"\n+    )\n+  endif()"},{"role":"user","content":"+    def __init__(self, name, *, typesupport_implementations=None):\n+        super().__init__(name)\n+        if typesupport_implementations is None:\n+            typesupport_implementations = ['rosidl_typesupport_c']\n+            typesupport_implementations.extend(\n+                get_resources('rosidl_typesupport_c'))\n+        self.__typesupport_implementations = typesupport_implementations\n+"},{"role":"user","content":"-        typesupport_implementations = ['rosidl_typesupport_c']\n-        typesupport_implementations.extend(\n-            get_resources('rosidl_typesupport_c')\n-        )"},{"role":"user","content":"-                typesupport_implementations)\n+                self.__typesupport_implementations)"},{"role":"user","content":"+from ament_index_python import get_resources"},{"role":"user","content":"-def test_cli_extension_for_smoke(tmp_path):\n-    generate(\n-        package_name='rosidl_generator_py',\n-        interface_files=[PACKAGE_DIR + ':msg/StringArrays.msg'],\n-        types=['py'],\n-        output_path=tmp_path\n-    )\n+def test_cli_extension_for_smoke(tmp_path, capsys):\n+    # NOTE(hidmic): pytest and empy do not play along,\n+    # the latter expects some proxy will stay in sys.stdout\n+    # and the former insists in overwriting it\n+    interface_files = [PACKAGE_DIR + ':msg/StringArrays.msg']\n+\n+    with capsys.disabled():  # so do everything in one run\n+        # Passing target typesupport implementations explictly\n+        generate(\n+            package_name='rosidl_typesupport_py',\n+            interface_files=interface_files,\n+            types=['py[typesupport_implementations:{}]'.format(\n+                list(get_resources('rosidl_typesupport_c'))\n+            )],\n+            output_path=tmp_path / 'explicit_args'\n+        )\n+\n+        # Using default typesupport implementations\n+        generate(\n+            package_name='rosidl_typesupport_pu',\n+            interface_files=interface_files,\n+            types=['py'],\n+            output_path=tmp_path / 'defaults'\n+        )"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-name: Mirror rolling to master\n-\n-on:\n-  push:\n-    branches: [ rolling ]\n-\n-jobs:\n-  mirror-to-master:\n-    runs-on: ubuntu-latest\n-    steps:\n-    - uses: zofrex/mirror-branch@v1\n-      with:\n-        target-branch: master"},{"role":"user","content":"-# This file was generated by https://github.com/audrow/update-ros2-repos\n-* @eboasson @ivanpauno "},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <utility>"},{"role":"user","content":"+  void add_item(std::unique_ptr<Item> item)\n+  {\n+    std::lock_guard<std::mutex> guard(mtx);\n+    items.push_back(std::move(item));\n+  }\n+\n+  std::unique_ptr<Item> erase_item(void * loaned_message)\n+  {\n+    std::unique_ptr<Item> ret{nullptr};\n+\n+    std::lock_guard<std::mutex> guard(mtx);\n+    for (auto it = items.begin(); it != items.end(); ++it) {\n+      if (loaned_message == (*it)->data_seq.buffer()[0]) {\n+        ret = std::move(*it);\n+        items.erase(it);\n+        break;\n+      }\n+    }\n+\n+    return ret;\n+  }\n+\n+private:"},{"role":"user","content":"-  eprosima::fastrtps::ResourceLimitedVector<Item> items RCPPUTILS_TSA_GUARDED_BY(mtx);\n+  using ItemVector = eprosima::fastrtps::ResourceLimitedVector<std::unique_ptr<Item>>;\n+  ItemVector items RCPPUTILS_TSA_GUARDED_BY(mtx);"},{"role":"user","content":"-  auto loan_mgr = info->loan_manager_;\n-  std::unique_lock<std::mutex> guard(loan_mgr->mtx);\n-  auto item = loan_mgr->items.emplace_back();\n-  if (nullptr == item) {\n-    RMW_SET_ERROR_MSG(\"Out of resources for loaned message info\");\n-    return RMW_RET_ERROR;\n-  }\n+\n+  auto item = std::make_unique<rmw_fastrtps_shared_cpp::LoanManager::Item>();"},{"role":"user","content":"+\n+      info->loan_manager_->add_item(std::move(item));\n+"},{"role":"user","content":"-  loan_mgr->items.pop_back();"},{"role":"user","content":"-  auto loan_mgr = info->loan_manager_;\n-  std::lock_guard<std::mutex> guard(loan_mgr->mtx);\n-  for (auto it = loan_mgr->items.begin(); it != loan_mgr->items.end(); ++it) {\n-    if (loaned_message == it->data_seq.buffer()[0]) {\n-      if (!info->data_reader_->return_loan(it->data_seq, it->info_seq)) {\n-        RMW_SET_ERROR_MSG(\"Error returning loan\");\n-        return RMW_RET_ERROR;\n-      }\n-      loan_mgr->items.erase(it);\n-      return RMW_RET_OK;\n+  std::unique_ptr<rmw_fastrtps_shared_cpp::LoanManager::Item> item;\n+  item = info->loan_manager_->erase_item(loaned_message);\n+  if (item != nullptr) {\n+    if (!info->data_reader_->return_loan(item->data_seq, item->info_seq)) {\n+      RMW_SET_ERROR_MSG(\"Error returning loan\");\n+      return RMW_RET_ERROR;"},{"role":"user","content":"+\n+    return RMW_RET_OK;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"./common.h\""},{"role":"user","content":"-  __cleanup_context(context);\n-  return RCL_RET_OK;\n+  return __cleanup_context(context);"},{"role":"user","content":"-void\n+rcl_ret_t"},{"role":"user","content":"+  rcl_ret_t ret = RCL_RET_OK;"},{"role":"user","content":"-    rcl_ret_t ret = rcl_arguments_fini(&(context->global_arguments));\n+    ret = rcl_arguments_fini(&(context->global_arguments));"},{"role":"user","content":"-      rcl_ret_t ret = rcl_init_options_fini(&(context->impl->init_options));\n-      if (RCL_RET_OK != ret) {\n+      rcl_ret_t init_options_fini_ret = rcl_init_options_fini(&(context->impl->init_options));\n+      if (RCL_RET_OK != init_options_fini_ret) {\n+        if (RCL_RET_OK == ret) {\n+          ret = init_options_fini_ret;\n+        }"},{"role":"user","content":"-      rmw_ret_t rmw_ret = rmw_context_fini(&(context->impl->rmw_context));\n-      if (RMW_RET_OK != rmw_ret) {\n+      rmw_ret_t rmw_context_fini_ret = rmw_context_fini(&(context->impl->rmw_context));\n+      if (RMW_RET_OK != rmw_context_fini_ret) {\n+        if (RCL_RET_OK == ret) {\n+          ret = rcl_convert_rmw_ret_to_rcl_ret(rmw_context_fini_ret);\n+        }"},{"role":"user","content":"+\n+  return ret;"},{"role":"user","content":"-void\n+rcl_ret_t"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# INCLUDE_DIRS, LIBRARIES, and AMENT_DEPENDENCIES which are passed to\n-# target_include_directories(), target_link_libraries(), and\n-# ament_target_dependencies() respectively.\n+# INCLUDE_DIRS and LIBRARIES which are passed to\n+# target_include_directories() and target_link_libraries(), respectively."},{"role":"user","content":"-# :param AMENT_DEPENDENCIES: list of depends to pass ament_target_dependencies\n-# :type AMENT_DEPENDENCIES: list of strings"},{"role":"user","content":"-    \"SRCS;ENV;APPEND_ENV;APPEND_LIBRARY_DIRS;INCLUDE_DIRS;LIBRARIES;AMENT_DEPENDENCIES\"\n+    \"SRCS;ENV;APPEND_ENV;APPEND_LIBRARY_DIRS;INCLUDE_DIRS;LIBRARIES\""},{"role":"user","content":"-    # Add extra ament dependencies, if any.\n-    if(_ARG_AMENT_DEPENDENCIES)\n-      if(_ARG_TRACE)\n-        message(STATUS \"  rcl_add_custom_gtest() AMENT_DEPENDENCIES: ${_ARG_AMENT_DEPENDENCIES}\")\n-      endif()\n-      ament_target_dependencies(${target} ${_ARG_AMENT_DEPENDENCIES})\n-    endif()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  // clear the wait result and wait for work without blocking to collect the work\n+  // for the first time\n+  // both spin_some and spin_all wait for work at the beginning\n+  wait_result_.reset();\n+  wait_for_work(std::chrono::milliseconds(0));\n+  bool just_waited = true;\n+\n+  // The logic of this while loop is as follows:\n+  //\n+  // - while not shutdown, and spinning (not canceled), and not max duration reached...\n+  // - try to get an executable item to execute, and execute it if available\n+  // - otherwise, reset the wait result, and ...\n+  // - if there was no work available just after waiting, break the loop unconditionally\n+  //   - this is appropriate for both spin_some and spin_all which use this function\n+  // - else if exhaustive = true, then wait for work again\n+  //   - this is only used for spin_all and not spin_some\n+  // - else break\n+  //   - this only occurs with spin_some\n+  //\n+  // The logic of this loop is subtle and should be carefully changed if at all.\n+  // See also:\n+  //   https://github.com/ros2/rclcpp/issues/2508\n+  //   https://github.com/ros2/rclcpp/pull/2517"},{"role":"user","content":"-    if (!wait_result_.has_value()) {\n-      wait_for_work(std::chrono::milliseconds(0));\n-    }\n-"},{"role":"user","content":"+      just_waited = false;"},{"role":"user","content":"-      // If nothing is ready, reset the result to signal we are\n-      // ready to wait again\n+      // if nothing is ready, reset the result to clear it"},{"role":"user","content":"-    }"},{"role":"user","content":"-    if (!wait_result_.has_value() && !exhaustive) {\n-      // In the case of spin some, then we can exit\n-      // In the case of spin all, then we will allow ourselves to wait again.\n-      break;\n+      if (just_waited) {\n+        // there was no work after just waiting, always exit in this case\n+        // before the exhaustive condition can be checked\n+        break;\n+      }\n+\n+      if (exhaustive) {\n+        // if exhaustive, wait for work again\n+        // this only happens for spin_all; spin_some only waits at the start\n+        wait_for_work(std::chrono::milliseconds(0));\n+        just_waited = true;\n+      } else {\n+        break;\n+      }"},{"role":"user","content":"+    is_ready_count_++;"},{"role":"user","content":"+  size_t\n+  get_is_ready_call_count() const\n+  {\n+    return is_ready_count_;\n+  }\n+"},{"role":"user","content":"+  std::atomic<size_t> is_ready_count_ = 0;"},{"role":"user","content":"+\n+template<typename T>\n+class TestBusyWaiting : public ::testing::Test\n+{\n+public:\n+  void SetUp() override\n+  {\n+    rclcpp::init(0, nullptr);\n+\n+    const auto test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+    std::stringstream test_name;\n+    test_name << test_info->test_case_name() << \"_\" << test_info->name();\n+    node = std::make_shared<rclcpp::Node>(\"node\", test_name.str());\n+    callback_group = node->create_callback_group(\n+      rclcpp::CallbackGroupType::MutuallyExclusive,\n+      /* automatically_add_to_executor_with_node =*/ false);\n+\n+    auto waitable_interfaces = node->get_node_waitables_interface();\n+    waitable = std::make_shared<TestWaitable>();\n+    waitable_interfaces->add_waitable(waitable, callback_group);\n+\n+    executor = std::make_shared<T>();\n+    executor->add_callback_group(callback_group, node->get_node_base_interface());\n+  }\n+\n+  void TearDown() override\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  void\n+  set_up_and_trigger_waitable(std::function<void()> extra_callback = nullptr)\n+  {\n+    this->has_executed = false;\n+    this->waitable->set_on_execute_callback([this, extra_callback]() {\n+        if (!this->has_executed) {\n+        // trigger once to see if the second trigger is handled or not\n+        // this follow up trigger simulates new entities becoming ready while\n+        // the executor is executing something else, e.g. subscription got data\n+        // or a timer expired, etc.\n+        // spin_some would not handle this second trigger, since it collects\n+        // work only once, whereas spin_all should handle it since it\n+        // collects work multiple times\n+          this->waitable->trigger();\n+          this->has_executed = true;\n+        }\n+        if (nullptr != extra_callback) {\n+          extra_callback();\n+        }\n+    });\n+    this->waitable->trigger();\n+  }\n+\n+  void\n+  check_for_busy_waits(std::chrono::steady_clock::time_point start_time)\n+  {\n+    // rough time based check, since the work to be done was very small it\n+    // should be safe to check that we didn't use more than half the\n+    // max duration, which itself is much larger than necessary\n+    // however, it could still produce a false-positive\n+    EXPECT_LT(\n+      std::chrono::steady_clock::now() - start_time,\n+      max_duration / 2)\n+      << \"executor took a long time to execute when it should have done \"\n+      << \"nothing and should not have blocked either, but this could be a \"\n+      << \"false negative if the computer is really slow\";\n+\n+    // this check is making some assumptions about the implementation of the\n+    // executors, but it should be safe to say that a busy wait may result in\n+    // hundreds or thousands of calls to is_ready(), but \"normal\" executor\n+    // behavior should be within an order of magnitude of the number of\n+    // times that the waitable was executed\n+    ASSERT_LT(waitable->get_is_ready_call_count(), 10u * this->waitable->get_count());\n+  }\n+\n+  static constexpr auto max_duration = 10s;\n+\n+  rclcpp::Node::SharedPtr node;\n+  rclcpp::CallbackGroup::SharedPtr callback_group;\n+  std::shared_ptr<TestWaitable> waitable;\n+  std::chrono::steady_clock::time_point start_time;\n+  std::shared_ptr<T> executor;\n+  bool has_executed;\n+};\n+\n+TYPED_TEST_SUITE(TestBusyWaiting, ExecutorTypes, ExecutorTypeNames);\n+\n+TYPED_TEST(TestBusyWaiting, test_spin_all)\n+{\n+  this->set_up_and_trigger_waitable();\n+\n+  auto start_time = std::chrono::steady_clock::now();\n+  this->executor->spin_all(this->max_duration);\n+  this->check_for_busy_waits(start_time);\n+  // this should get the initial trigger, and the follow up from in the callback\n+  ASSERT_EQ(this->waitable->get_count(), 2u);\n+}\n+\n+TYPED_TEST(TestBusyWaiting, test_spin_some)\n+{\n+  this->set_up_and_trigger_waitable();\n+\n+  auto start_time = std::chrono::steady_clock::now();\n+  this->executor->spin_some(this->max_duration);\n+  this->check_for_busy_waits(start_time);\n+  // this should get the inital trigger, but not the follow up in the callback\n+  ASSERT_EQ(this->waitable->get_count(), 1u);\n+}\n+\n+TYPED_TEST(TestBusyWaiting, test_spin)\n+{\n+  std::condition_variable cv;\n+  std::mutex cv_m;\n+  bool first_check_passed = false;\n+\n+  this->set_up_and_trigger_waitable([&cv, &cv_m, &first_check_passed]() {\n+      cv.notify_one();\n+      if (!first_check_passed) {\n+        std::unique_lock<std::mutex> lk(cv_m);\n+        cv.wait_for(lk, 1s, [&]() {return first_check_passed;});\n+      }\n+  });\n+\n+  auto start_time = std::chrono::steady_clock::now();\n+  std::thread t([this]() {\n+      this->executor->spin();\n+    });\n+\n+  // wait until thread has started (first execute of waitable)\n+  {\n+    std::unique_lock<std::mutex> lk(cv_m);\n+    cv.wait_for(lk, 10s);\n+  }\n+  EXPECT_GT(this->waitable->get_count(), 0u);\n+\n+  first_check_passed = true;\n+  cv.notify_one();\n+\n+  // wait until the executor has finished (second execute of waitable)\n+  {\n+    std::unique_lock<std::mutex> lk(cv_m);\n+    cv.wait_for(lk, 10s);\n+  }\n+  EXPECT_EQ(this->waitable->get_count(), 2u);\n+\n+  this->executor->cancel();\n+  t.join();\n+\n+  this->check_for_busy_waits(start_time);\n+  // this should get the initial trigger, and the follow up from in the callback\n+  ASSERT_EQ(this->waitable->get_count(), 2u);\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+      test/test_rosout_subscription.py"},{"role":"user","content":"+        self.logger_sublogger_namepair = None"},{"role":"user","content":"+    def __del__(self):\n+        if self.logger_sublogger_namepair:\n+            _rclpy.rclpy_logging_rosout_remove_sublogger(\n+                self.logger_sublogger_namepair[0], self.logger_sublogger_namepair[1])\n+            self.logger_sublogger_namepair = None\n+"},{"role":"user","content":"+"},{"role":"user","content":"-            name = self.name + '.' + name\n-        return RcutilsLogger(name=name)\n+            _rclpy.rclpy_logging_rosout_add_sublogger(self.name, name)\n+            fullname = self.name + _rclpy.rclpy_logging_get_separator_string() + name\n+        else:\n+            fullname = name\n+\n+        logger = RcutilsLogger(name=fullname)\n+        if self.name:\n+            logger.logger_sublogger_namepair = (self.name, name)\n+        return logger"},{"role":"user","content":"+#include <rcl/logging_rosout.h>"},{"role":"user","content":"+#include \"logging.hpp\""},{"role":"user","content":"+/// Add a subordinate logger based on a logger\n+void\n+rclpy_logging_rosout_add_sublogger(const char * logger_name, const char * sublogger_name)\n+{\n+  rclpy::LoggingGuard scoped_logging_guard;\n+  rcl_ret_t rcl_ret = rcl_logging_rosout_add_sublogger(logger_name, sublogger_name);\n+  if (RCL_RET_OK != rcl_ret) {\n+    rcutils_reset_error();\n+    throw std::runtime_error(\"Failed to call rcl_logging_rosout_add_sublogger\");\n+  }\n+}\n+\n+/// Remove a subordinate logger and cleans up allocated resources\n+void\n+rclpy_logging_rosout_remove_sublogger(const char * logger_name, const char * sublogger_name)\n+{\n+  rclpy::LoggingGuard scoped_logging_guard;\n+  rcl_ret_t rcl_ret = rcl_logging_rosout_remove_sublogger(logger_name, sublogger_name);\n+\n+  if (RCL_RET_OK != rcl_ret) {\n+    rcutils_reset_error();\n+  }\n+}\n+"},{"role":"user","content":"+  m.def(\"rclpy_logging_get_separator_string\", []() {return RCUTILS_LOGGING_SEPARATOR_STRING;});"},{"role":"user","content":"+  m.def(\"rclpy_logging_rosout_add_sublogger\", &rclpy_logging_rosout_add_sublogger);\n+  m.def(\"rclpy_logging_rosout_remove_sublogger\", &rclpy_logging_rosout_remove_sublogger);"},{"role":"user","content":"+# Copyright 2023 Sony Group Corporation.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+from rcl_interfaces.msg import Log\n+import rclpy\n+from rclpy.executors import SingleThreadedExecutor\n+from rclpy.task import Future\n+\n+\n+class TestRosoutSubscription(unittest.TestCase):\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.context = rclpy.context.Context()\n+        rclpy.init(context=cls.context)\n+        cls.node = rclpy.create_node('test_rosout_subscription', context=cls.context)\n+        cls.executor = SingleThreadedExecutor(context=cls.context)\n+        cls.executor.add_node(cls.node)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.node.destroy_node()\n+        rclpy.shutdown(context=cls.context)\n+\n+    def setUp(self):\n+        # create subscriber of 'rosout' topic\n+        self.sub = self.node.create_subscription(\n+            Log,\n+            '/rosout',\n+            self._rosout_subscription_callback,\n+            1\n+        )\n+        self.fut = Future()\n+        self.rosout_msg_name = None\n+\n+    def _rosout_subscription_callback(self, msg):\n+        if msg.name == self.rosout_msg_name:\n+            self.fut.set_result(None)\n+\n+    def test_parent_log(self):\n+        self.rosout_msg_name = 'test_rosout_subscription'\n+        logger = self.node.get_logger()\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+    def test_child_log(self):\n+        self.rosout_msg_name = 'test_rosout_subscription.child1'\n+        logger = self.node.get_logger()\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertFalse(self.fut.done())\n+\n+        logger = self.node.get_logger().get_child('child1')\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+        self.fut = Future()\n+\n+        logger = self.node.get_logger().get_child('child2')\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertFalse(self.fut.done())\n+\n+        self.rosout_msg_name = 'test_rosout_subscription.child2'\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+    def test_child_hierarchy(self):\n+        self.rosout_msg_name = 'test_rosout_subscription.child.grandchild'\n+        logger = self.node.get_logger().get_child('child').get_child('grandchild')\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+    def test_first_child_removed(self):\n+        self.rosout_msg_name = 'test_rosout_subscription.child'\n+        logger = self.node.get_logger().get_child('child')\n+        logger2 = self.node.get_logger().get_child('child')\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+        logger = None\n+        logger2.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+    def test_logger_parameter(self):\n+        self.rosout_msg_name = 'test_rosout_subscription.child'\n+        logger = self.node.get_logger().get_child('child')\n+\n+        def call_logger(logger):\n+            logger1 = logger\n+            logger1.info('test')\n+        call_logger(logger)\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+        logger.info('test')\n+        self.executor.spin_until_future_complete(self.fut, 3)\n+        self.assertTrue(self.fut.done())\n+\n+    def test_node_logger_not_exist(self):\n+        node = rclpy.create_node('test_extra_node', context=self.context)\n+        logger = node.get_logger()\n+        node = None\n+        with self.assertRaises(RuntimeError):\n+            logger.get_child('child')\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_c\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_c\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_c>\"\n+  \"$<INSTALL_INTERFACE:include>\""},{"role":"user","content":"-    PUBLIC\n+    PRIVATE"},{"role":"user","content":"+  ${rosidl_generate_interfaces_TARGET}__rosidl_generator_cpp"},{"role":"user","content":"+    EXPORT ${rosidl_generate_interfaces_TARGET}"},{"role":"user","content":"-  rosidl_export_typesupport_libraries(${_target_suffix}\n+  rosidl_export_typesupport_targets(${_target_suffix}"},{"role":"user","content":"-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_cpp\n-  ${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/rosidl_typesupport_fastrtps_cpp>\"\n+  \"$<INSTALL_INTERFACE:include>\""},{"role":"user","content":"+    EXPORT ${rosidl_generate_interfaces_TARGET}"},{"role":"user","content":"-  rosidl_export_typesupport_libraries(${_target_suffix}\n+  rosidl_export_typesupport_targets(${_target_suffix}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-include_directories(include)\n-"},{"role":"user","content":"+target_include_directories(rmw_fastrtps_dynamic_cpp PUBLIC\n+  \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n+  \"$<INSTALL_INTERFACE:include/${PROJECT_NAME}>\")"},{"role":"user","content":"+# Export a modern CMake target\n+ament_export_targets(rmw_fastrtps_dynamic_cpp)"},{"role":"user","content":"-  TARGETS rmw_fastrtps_dynamic_cpp\n+  TARGETS rmw_fastrtps_dynamic_cpp EXPORT rmw_fastrtps_dynamic_cpp"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+    std::lock_guard<std::mutex> lock(pending_requests_mutex_);"},{"role":"user","content":"-    {\n-      std::lock_guard<std::mutex> lock(pending_requests_mutex_);\n-      pending_requests_.try_emplace(\n-        sequence_number,\n-        std::make_pair(std::chrono::system_clock::now(), std::move(value)));\n-    }\n+    pending_requests_.try_emplace(\n+      sequence_number,\n+      std::make_pair(std::chrono::system_clock::now(), std::move(value)));"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-      RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Calling dequeue on empty intra-process buffer\");\n-      throw std::runtime_error(\"Calling dequeue on empty intra-process buffer\");\n+      return BufferT();"},{"role":"user","content":"+      if (!shared_msg) {\n+        return nullptr;\n+      }"},{"role":"user","content":"+      if (!unique_msg) {\n+        return nullptr;\n+      }"},{"role":"user","content":"-      throw std::runtime_error(\"'data' is empty\");\n+      return;"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+find_package(rmw_security_common REQUIRED)"},{"role":"user","content":"+ament_export_dependencies(rmw_security_common)"},{"role":"user","content":"+  rmw_security_common::rmw_security_common_library"},{"role":"user","content":"+  <depend>rmw_security_common</depend>"},{"role":"user","content":"-#include \"rmw_dds_common/security.hpp\"\n+\n+#include \"rmw_security_common/security.hpp\""},{"role":"user","content":"-  std::unordered_map<std::string, std::string> security_files;\n+  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n+  rcutils_string_map_t security_files = rcutils_get_zero_initialized_string_map();\n+  rcutils_ret_t ret = rcutils_string_map_init(&security_files, 0, allocator);\n+\n+  if (ret != RMW_RET_OK) {\n+    RMW_SET_ERROR_MSG(\"Failed to initialize string map for security\");\n+    return RMW_RET_ERROR;\n+  }\n+\n+  auto scope_exit_ws = rcpputils::make_scope_exit(\n+    [&security_files]()\n+    {\n+      rcutils_ret_t ret = rcutils_string_map_fini(&security_files);\n+      if (ret != RMW_RET_OK) {\n+        RMW_SET_ERROR_MSG(\"Failed to fini string map for security\");\n+      }\n+    });\n+"},{"role":"user","content":"-  if (!rmw_dds_common::get_security_files(\n-      \"file:\", security_options->security_root_path, security_files))\n+  if (get_security_files(\n+      \"file:\", security_options->security_root_path, &security_files) != RMW_RET_OK)"},{"role":"user","content":"-  dds_qset_prop(qos, \"dds.sec.auth.identity_ca\", security_files[\"IDENTITY_CA\"].c_str());\n-  dds_qset_prop(qos, \"dds.sec.auth.identity_certificate\", security_files[\"CERTIFICATE\"].c_str());\n-  dds_qset_prop(qos, \"dds.sec.auth.private_key\", security_files[\"PRIVATE_KEY\"].c_str());\n-  dds_qset_prop(qos, \"dds.sec.access.permissions_ca\", security_files[\"PERMISSIONS_CA\"].c_str());\n-  dds_qset_prop(qos, \"dds.sec.access.governance\", security_files[\"GOVERNANCE\"].c_str());\n-  dds_qset_prop(qos, \"dds.sec.access.permissions\", security_files[\"PERMISSIONS\"].c_str());\n+  dds_qset_prop(qos, \"dds.sec.auth.identity_ca\",\n+    std::string(rcutils_string_map_get(&security_files, \"IDENTITY_CA\")).c_str());\n+  dds_qset_prop(qos, \"dds.sec.auth.identity_certificate\",\n+    std::string(rcutils_string_map_get(&security_files, \"CERTIFICATE\")).c_str());\n+  dds_qset_prop(qos, \"dds.sec.auth.private_key\",\n+    std::string(rcutils_string_map_get(&security_files, \"PRIVATE_KEY\")).c_str());\n+  dds_qset_prop(qos, \"dds.sec.access.permissions_ca\",\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS_CA\")).c_str());\n+  dds_qset_prop(qos, \"dds.sec.access.governance\",\n+    std::string(rcutils_string_map_get(&security_files, \"GOVERNANCE\")).c_str());\n+  dds_qset_prop(qos, \"dds.sec.access.permissions\",\n+    std::string(rcutils_string_map_get(&security_files, \"PERMISSIONS\")).c_str());"},{"role":"user","content":"-  if (security_files.count(\"CRL\") > 0) {\n-    dds_qset_prop(qos, \"org.eclipse.cyclonedds.sec.auth.crl\", security_files[\"CRL\"].c_str());\n+  if (rcutils_string_map_key_exists(&security_files, \"CRL\")) {\n+    dds_qset_prop(\n+      qos, \"org.eclipse.cyclonedds.sec.auth.crl\",\n+      std::string(rcutils_string_map_get(&security_files, \"CRL\")).c_str());"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 100));"},{"role":"user","content":"-    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 100));"},{"role":"user","content":"-    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_FALSE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 100));"},{"role":"user","content":"-    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+    ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"user","content":"-  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 10, 1000));\n+  ASSERT_TRUE(wait_for_subscription_to_be_ready(&subscription, context_ptr, 100, 100));"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  /// Set the display title format.\n+  /**\n+   * Sets the format of the window title.\n+   * Three replacement tokens are supported:\n+   *  - {NAMESPACE} - replace with the namespace this node is in\n+   *  - {CONFIG_PATH} - replace with the path (but not the filename) of the configuration file in use.\n+   *  - {CONFIG_FILENAME} - replace with the filename (but not the path) of the configuration file in use.\n+   * The default is \"RViz[*]\" if the default configuration file is in use,\n+   * or \"{CONFIG_PATH}/{CONFIG_FILENAME}[*] - RViz\" if a custom configuration file is in use.\n+   */\n+  void\n+  setDisplayTitleFormat(const QString & title_format);\n+"},{"role":"user","content":"+  std::string display_title_format_;"},{"role":"user","content":"+#include <filesystem>"},{"role":"user","content":"+void VisualizationFrame::setDisplayTitleFormat(const QString & title_format)\n+{\n+  display_title_format_ = title_format.toStdString();\n+}\n+"},{"role":"user","content":"-"},{"role":"user","content":"-  if (path == default_display_config_file_) {\n-    title = \"RViz[*]\";\n+\n+  if (display_title_format_.empty()) {\n+    if (path == default_display_config_file_) {\n+      title = \"RViz[*]\";\n+    } else {\n+      title = QDir::toNativeSeparators(QString::fromStdString(path)).toStdString() + \"[*] - RViz\";\n+    }"},{"role":"user","content":"-    title = QDir::toNativeSeparators(QString::fromStdString(path)).toStdString() + \"[*] - RViz\";\n+    auto find_and_replace_token =\n+      [](std::string & title, const std::string & token, const std::string & replacement)\n+      {\n+        std::size_t found = title.find(token);\n+        if (found != std::string::npos) {\n+          title.replace(found, token.length(), replacement);\n+        }\n+      };\n+    title = display_title_format_;\n+    std::filesystem::path full_filename(path.c_str());\n+    find_and_replace_token(\n+      title, \"{NAMESPACE}\",\n+      rviz_ros_node_.lock()->get_raw_node()->get_namespace());\n+    find_and_replace_token(title, \"{CONFIG_PATH}\", full_filename.parent_path().string());\n+    find_and_replace_token(title, \"{CONFIG_FILENAME}\", full_filename.filename().string());\n+    if (title.find(\"[*]\") == std::string::npos) {\n+      title.append(\"[*]\");\n+    }"},{"role":"user","content":"+"},{"role":"user","content":"+  QCommandLineOption display_title_format_option(\n+    QStringList() << \"t\" << \"display-title-format\",\n+      \"A display title format like \",\n+      \"\\\"{NAMESPACE} - {CONFIG_PATH}/{CONFIG_FILENAME} - RViz2\\\" \",\n+      \"display_title_format\");\n+  parser.addOption(display_title_format_option);\n+"},{"role":"user","content":"-  QString display_config, fixed_frame, splash_path, help_path;\n+  QString display_config, fixed_frame, splash_path, help_path, display_title_format;"},{"role":"user","content":"+  if (parser.isSet(display_title_format_option)) {\n+    display_title_format = parser.value(display_title_format_option);\n+  }\n+"},{"role":"user","content":"+\n+  frame_->setDisplayTitleFormat(display_title_format);\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  vis_manager_->stopUpdate();"},{"role":"user","content":"-  vis_manager_->startUpdate();"},{"role":"user","content":"-  vis_manager_->startUpdate();"},{"role":"user","content":"-  manager_->startUpdate();"},{"role":"user","content":"-  manager_->stopUpdate();"},{"role":"user","content":"-  manager_->startUpdate();"},{"role":"user","content":"-  manager_->stopUpdate();"},{"role":"user","content":"-  manager_->startUpdate();"},{"role":"user","content":"-    manager_->stopUpdate();"},{"role":"user","content":"-    manager_->startUpdate();"},{"role":"user","content":"-  manager_->stopUpdate();"},{"role":"user","content":"-  manager_->startUpdate();"},{"role":"user","content":"-    manager_->stopUpdate();"},{"role":"user","content":"-    manager_->startUpdate();"},{"role":"user","content":"-  manager_->stopUpdate();"},{"role":"user","content":"-  manager_->startUpdate();"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);"},{"role":"user","content":"-          // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-          request_header->received_timestamp = 0;\n+          request_header->received_timestamp =\n+            sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+            sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"-          // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-          request_header->received_timestamp = 0;\n+          request_header->received_timestamp =\n+            sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+            sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"+      dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);"},{"role":"user","content":"-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      request_header->received_timestamp = 0;\n+      request_header->received_timestamp =\n+        sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      request_header->received_timestamp = 0;\n+      request_header->received_timestamp =\n+        sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      message_info->received_timestamp = 0;\n+      message_info->received_timestamp =\n+        sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"-      // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-      message_info->received_timestamp = 0;\n+      message_info->received_timestamp =\n+        sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+        sampleinfo_ex->received_timestamp.nanosec;"},{"role":"user","content":"+        dds_SampleInfoEx * sampleinfo_ex = reinterpret_cast<dds_SampleInfoEx *>(sample_info);"},{"role":"user","content":"-        // TODO(clemjh): SampleInfo doesn't contain received_timestamp\n-        message_info->received_timestamp = 0;\n+        message_info->received_timestamp =\n+          sampleinfo_ex->received_timestamp.sec * static_cast<int64_t>(1000000000) +\n+          sampleinfo_ex->received_timestamp.nanosec;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    rclcpp::init(0, nullptr);\n+    if (!rclcpp::ok()) {\n+      rclcpp::init(0, nullptr);\n+    }"},{"role":"user","content":"+\n+bool wait_for_match(\n+  const std::shared_ptr<rclcpp::SubscriptionBase> sub,\n+  const std::shared_ptr<rclcpp::PublisherBase> pub)\n+{\n+  int i = 0;\n+  bool matched = false;\n+  while (!matched && i < g_max_loops) {\n+    matched = sub->get_publisher_count() > 0 && pub->get_subscription_count() > 0;\n+    std::this_thread::sleep_for(g_sleep_per_loop);\n+  }\n+  return matched;\n+}\n+"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"user","content":"+      ASSERT_TRUE(wait_for_match(sub, pub));"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        except ImportError:\n-            doctor_warn(f'Check entry point {check_entry_pt.name} fails to load.')\n+        except ImportError as e:\n+            doctor_warn(f'Check entry point {check_entry_pt.name} fails to load: {e}')"},{"role":"user","content":"-        except ImportError:\n-            doctor_warn(f'Report entry point {report_entry_pt.name} fails to load.')\n+        except ImportError as e:\n+            doctor_warn(f'Report entry point {report_entry_pt.name} fails to load: {e}')"},{"role":"user","content":"+import ifcfg\n+"},{"role":"user","content":"-try:\n-    import ifcfg\n-except ImportError:  # check import error for windows and osx\n-    doctor_warn(\n-        'Unable to import ifcfg. '\n-        'Use `python3 -m pip install ifcfg` to install needed package.')\n-"},{"role":"user","content":"-        try:\n-            ifcfg_ifaces = ifcfg.interfaces()\n-        except NameError:\n-            doctor_error(\n-                '`ifcfg` module is not imported. '\n-                'Unable to run network check.')\n-            result.add_error()\n-            return result\n+        ifcfg_ifaces = ifcfg.interfaces()"},{"role":"user","content":"-                doctor_error(\n-                    'No flags found. '\n-                    'Run `ipconfig` on Windows or '\n-                    'install `ifconfig` on Unix to check network interfaces.')\n-                result.add_error()\n+                doctor_warn(\n+                    'Interface flags are not available on Windows. '\n+                    'Run `ipconfig` to see what interfaces are available.')\n+                result.add_warning()"},{"role":"user","content":"-        try:\n-            ifcfg_ifaces = ifcfg.interfaces()\n-        except NameError:\n-            doctor_error('ifcfg is not imported. Unable to generate network report.')\n-            return Report('')\n+        ifcfg_ifaces = ifcfg.interfaces()"},{"role":"user","content":"-        required_ver_str = distro_packages.get(name, '')\n-        if not required_ver_str:\n+        latest_ver_str = distro_packages.get(name, '')\n+        if not latest_ver_str:"},{"role":"user","content":"-        required_ver = version.parse(required_ver_str).base_version\n-        if local_ver < required_ver:\n+        latest_ver = version.parse(latest_ver_str).base_version\n+        if local_ver < latest_ver:"},{"role":"user","content":"-                f' required: {required_ver}')\n+                f' latest: {latest_ver}')"},{"role":"user","content":"-                'Cannot find required versions of packages: ' +\n+                'Cannot find the latest versions of packages: ' +"},{"role":"user","content":"-                'Cannot find required versions of packages: ' +\n+                'Cannot find the latest versions of packages: ' +"},{"role":"user","content":"-            required_ver_str = distro_package_vers.get(name, '')\n+            latest_ver_str = distro_package_vers.get(name, '')"},{"role":"user","content":"-            required_ver = version.parse(required_ver_str).base_version\n-            report.add_to_report(name, f'required={required_ver}, local={local_ver}')\n+            latest_ver = version.parse(latest_ver_str).base_version\n+            report.add_to_report(name, f'latest={latest_ver}, local={local_ver}')"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-/// Take a raw message from a given subscription (internal- for rclpy_take with raw=True)\n-/**\n- * \\param[in] module_state the module state for the _rclpy module\n- * \\param[in] rcl subscription pointer pointing to the subscription to process the message\n- * \\param[in] message_info struct pointer, may be null. if non-null, will be filled with message info\n- * \\return Python byte array with the raw serialized message contents\n- */\n-static PyObject *\n-rclpy_take_raw_with_info(\n-  rclpy_module_state_t * module_state,\n-  rcl_subscription_t * subscription, rmw_message_info_t * message_info)\n-{\n-  if (!module_state) {\n-    PyErr_Format(PyExc_RuntimeError, \"rclpy_take_raw_with_info got NULL module state\");\n-    return NULL;\n-  }\n-  // Create a serialized message object\n-  rcl_serialized_message_t msg = rmw_get_zero_initialized_serialized_message();\n-  rcutils_allocator_t allocator = rcutils_get_default_allocator();\n-  rcl_ret_t ret = rmw_serialized_message_init(&msg, 0u, &allocator);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError,\n-      \"Failed to initialize message: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    rmw_ret_t r_fini = rmw_serialized_message_fini(&msg);\n-    if (r_fini != RMW_RET_OK) {\n-      PyErr_Format(module_state->RCLError, \"Failed to deallocate message buffer: %d\", r_fini);\n-    }\n-    return NULL;\n-  }\n-\n-  ret = rcl_take_serialized_message(subscription, &msg, message_info, NULL);\n-  if (ret != RCL_RET_OK) {\n-    PyErr_Format(\n-      module_state->RCLError,\n-      \"Failed to take_serialized from a subscription: %s\", rcl_get_error_string().str);\n-    rcl_reset_error();\n-    rmw_ret_t r_fini = rmw_serialized_message_fini(&msg);\n-    if (r_fini != RMW_RET_OK) {\n-      PyErr_Format(module_state->RCLError, \"Failed to deallocate message buffer: %d\", r_fini);\n-    }\n-    return NULL;\n-  }\n-  PyObject * python_bytes = PyBytes_FromStringAndSize((char *)(msg.buffer), msg.buffer_length);\n-  rmw_ret_t r_fini = rmw_serialized_message_fini(&msg);\n-  if (r_fini != RMW_RET_OK) {\n-    PyErr_Format(module_state->RCLError, \"Failed to deallocate message buffer: %d\", r_fini);\n-    if (python_bytes) {\n-      Py_DECREF(python_bytes);\n-    }\n-    return NULL;\n-  }\n-  return python_bytes;\n-}\n-\n-static PyObject *\n-rclpy_message_info_to_dict(rmw_message_info_t * message_info)\n-{\n-  PyObject * dict = Py_BuildValue(\n-    \"{s:L,s:L}\",\n-    \"source_timestamp\", message_info->source_timestamp,\n-    \"received_timestamp\", message_info->received_timestamp);\n-  if (dict == NULL) {\n-    PyErr_Format(PyExc_RuntimeError, \"Failed to create dictionary object for message info\");\n-    return NULL;\n-  }\n-  return dict;\n-}\n-\n-/// Take a message and its message_info from a given subscription\n-/**\n- * \\param[in] pysubscription Capsule pointing to the subscription to process the message\n- * \\param[in] pymsg_type Instance of the message type to take\n- * \\return Tuple of (Python message with all fields populated with received message, message_info),\n- *         or None if there was no message to take.\n- */\n-static PyObject *\n-rclpy_take(PyObject * module, PyObject * args)\n-{\n-  rclpy_module_state_t * module_state = (rclpy_module_state_t *)PyModule_GetState(module);\n-  if (!module_state) {\n-    // exception already raised\n-    return NULL;\n-  }\n-  PyObject * pysubscription;\n-  PyObject * pymsg_type;\n-  PyObject * pyraw;\n-  PyObject * pytaken_msg = NULL;\n-\n-  if (!PyArg_ParseTuple(args, \"OOO\", &pysubscription, &pymsg_type, &pyraw)) {\n-    return NULL;\n-  }\n-  if (!PyCapsule_CheckExact(pysubscription)) {\n-    PyErr_Format(PyExc_TypeError, \"Argument pysubscription is not a valid PyCapsule\");\n-    return NULL;\n-  }\n-\n-  rclpy_subscription_t * sub =\n-    rclpy_handle_get_pointer_from_capsule(pysubscription, \"rclpy_subscription_t\");\n-  if (!sub) {\n-    return NULL;\n-  }\n-\n-  rmw_message_info_t message_info;\n-  if (PyObject_IsTrue(pyraw) == 1) {  // raw=True\n-    pytaken_msg = rclpy_take_raw_with_info(module_state, &(sub->subscription), &message_info);\n-  } else {\n-    destroy_ros_message_signature * destroy_ros_message = NULL;\n-    void * taken_msg = rclpy_create_from_py(pymsg_type, &destroy_ros_message);\n-    if (!taken_msg) {\n-      return NULL;\n-    }\n-\n-    rcl_ret_t ret = rcl_take(&(sub->subscription), taken_msg, &message_info, NULL);\n-\n-    if (ret != RCL_RET_OK && ret != RCL_RET_SUBSCRIPTION_TAKE_FAILED) {\n-      PyErr_Format(\n-        module_state->RCLError,\n-        \"Failed to take from a subscription: %s\", rcl_get_error_string().str);\n-      rcl_reset_error();\n-      destroy_ros_message(taken_msg);\n-      return NULL;\n-    }\n-\n-    if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n-      Py_RETURN_NONE;\n-    }\n-\n-    pytaken_msg = rclpy_convert_to_py(taken_msg, pymsg_type);\n-    destroy_ros_message(taken_msg);\n-  }\n-  if (!pytaken_msg) {\n-    // the function has set the Python error\n-    return NULL;\n-  }\n-\n-  // make result tuple\n-  PyObject * mi_dict = rclpy_message_info_to_dict(&message_info);\n-  if (mi_dict == NULL) {\n-    Py_DECREF(pytaken_msg);\n-    return NULL;\n-  }\n-  PyObject * tuple = PyTuple_Pack(2, pytaken_msg, mi_dict);\n-  Py_DECREF(pytaken_msg);\n-  Py_DECREF(mi_dict);\n-  return tuple;\n-}"},{"role":"user","content":"-  {\n-    \"rclpy_take\", rclpy_take, METH_VARARGS,\n-    \"rclpy_take.\"\n-  },\n-"},{"role":"user","content":"+  m.def(\n+    \"rclpy_take\", &rclpy::subscription_take_message,\n+    \"Take a message and its metadata from a subscription\");"},{"role":"user","content":"-struct SerializedMessage\n+SerializedMessage::SerializedMessage(rcutils_allocator_t allocator)"},{"role":"user","content":"-  explicit SerializedMessage(rcutils_allocator_t allocator)\n-  {\n-    rcl_msg = rmw_get_zero_initialized_serialized_message();\n-    rcutils_ret_t rcutils_ret = rmw_serialized_message_init(&rcl_msg, 0u, &allocator);\n-    if (RCUTILS_RET_OK != rcutils_ret) {\n-      throw RCUtilsError(\"failed to initialize serialized message\");\n-    }\n+  rcl_msg = rmw_get_zero_initialized_serialized_message();\n+  rcutils_ret_t rcutils_ret = rmw_serialized_message_init(&rcl_msg, 0u, &allocator);\n+  if (RCUTILS_RET_OK != rcutils_ret) {\n+    throw RCUtilsError(\"failed to initialize serialized message\");"},{"role":"user","content":"+}"},{"role":"user","content":"-  ~SerializedMessage()\n-  {\n-    rcutils_ret_t ret = rmw_serialized_message_fini(&rcl_msg);\n-    if (RCUTILS_RET_OK != ret) {\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\n-        \"[rclpy|\" RCUTILS_STRINGIFY(__FILE__) \":\" RCUTILS_STRINGIFY(__LINE__) \"]: \"\n-        \"failed to fini rcl_serialized_msg_t in destructor:\");\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n-      rcutils_reset_error();\n-    }\n+SerializedMessage::~SerializedMessage()\n+{\n+  rcutils_ret_t ret = rmw_serialized_message_fini(&rcl_msg);\n+  if (RCUTILS_RET_OK != ret) {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\n+      \"[rclpy|\" RCUTILS_STRINGIFY(__FILE__) \":\" RCUTILS_STRINGIFY(__LINE__) \"]: \"\n+      \"failed to fini rcl_serialized_msg_t in destructor:\");\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    rcutils_reset_error();"},{"role":"user","content":"-\n-  rcl_serialized_message_t rcl_msg;\n-};\n+}"},{"role":"user","content":"+#include <rcl/types.h>\n+#include <rcutils/allocator.h>\n+"},{"role":"user","content":"+/// Helper struct to manage an rcl_serialized_message_t lifetime.\n+struct SerializedMessage\n+{\n+  explicit SerializedMessage(rcutils_allocator_t allocator);\n+\n+  ~SerializedMessage();\n+\n+  rcl_serialized_message_t rcl_msg;\n+};\n+"},{"role":"user","content":"+#include <rcl/rcl.h>\n+#include <rcl/types.h>"},{"role":"user","content":"+#include \"serialization.hpp\""},{"role":"user","content":"+#include \"utils.hpp\"\n+\n+using pybind11::literals::operator\"\"_a;"},{"role":"user","content":"+py::object\n+subscription_take_message(py::capsule pysubscription, py::object pymsg_type, bool raw)\n+{\n+  auto wrapper = static_cast<rclpy_subscription_t *>(\n+    rclpy_handle_get_pointer_from_capsule(pysubscription.ptr(), \"rclpy_subscription_t\"));\n+  if (!wrapper) {\n+    throw py::error_already_set();\n+  }\n+\n+  py::object pytaken_msg;\n+  rmw_message_info_t message_info;\n+  if (raw) {\n+    SerializedMessage taken{rcutils_get_default_allocator()};\n+    rcl_ret_t ret = rcl_take_serialized_message(\n+      &(wrapper->subscription), &taken.rcl_msg, &message_info, NULL);\n+    if (RCL_RET_OK != ret) {\n+      if (RCL_RET_BAD_ALLOC == ret) {\n+        rcl_reset_error();\n+        throw std::bad_alloc();\n+      }\n+      if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n+        return py::none();\n+      }\n+      throw RCLError(\"failed to take raw message from subscription\");\n+    }\n+    pytaken_msg = py::bytes(\n+      reinterpret_cast<const char *>(taken.rcl_msg.buffer),\n+      taken.rcl_msg.buffer_length);\n+  } else {\n+    auto taken_msg = create_from_py(pymsg_type);\n+\n+    rcl_ret_t ret = rcl_take(\n+      &(wrapper->subscription), taken_msg.get(), &message_info, NULL);\n+    if (RCL_RET_OK != ret) {\n+      if (RCL_RET_BAD_ALLOC == ret) {\n+        rcl_reset_error();\n+        throw std::bad_alloc();\n+      }\n+      if (RCL_RET_SUBSCRIPTION_TAKE_FAILED == ret) {\n+        return py::none();\n+      }\n+      throw RCLError(\"failed to take message from subscription\");\n+    }\n+\n+    pytaken_msg = convert_to_py(taken_msg.get(), pymsg_type);\n+  }\n+\n+  return py::make_tuple(\n+    pytaken_msg, py::dict(\n+      \"source_timestamp\"_a = message_info.source_timestamp,\n+      \"received_timestamp\"_a = message_info.received_timestamp));\n+}\n+"},{"role":"user","content":"+/// Take a message and its metadata from a subscription\n+/**\n+ * Raises ValueError if pysubscription is not subscription capsule\n+ * Raises MemoryError if there was error allocating memory\n+ * Raises RCLError if there was an error within rcl\n+ *\n+ * \\param[in] pysubscription Capsule pointing to the subscription.\n+ * \\param[in] pymsg_type Message type to be taken (i.e. a class).\n+ * \\param[in] raw If True, return the message without de-serializing it.\n+ * \\return Tuple of (message, metadata) or None if there was no message to take.\n+ *   Message is a \\p pymsg_type instance if \\p raw is True, otherwise a byte string.\n+ *   Metadata is a plain dictionary.\n+ */\n+py::object\n+subscription_take_message(py::capsule pysubscription, py::object pymsg_type, bool raw);\n+"},{"role":"user","content":"+#include <memory>\n+"},{"role":"user","content":"+std::unique_ptr<void, destroy_ros_message_function *>\n+create_from_py(py::object pymessage)\n+{\n+  typedef void * create_ros_message_function (void);\n+\n+  py::object pymetaclass = pymessage.attr(\"__class__\");\n+\n+  py::object value = pymetaclass.attr(\"_CREATE_ROS_MESSAGE\");\n+  auto capsule_ptr = static_cast<void *>(value.cast<py::capsule>());\n+  auto create_ros_message =\n+    reinterpret_cast<create_ros_message_function *>(capsule_ptr);\n+  if (!create_ros_message) {\n+    throw py::error_already_set();\n+  }\n+\n+  value = pymetaclass.attr(\"_DESTROY_ROS_MESSAGE\");\n+  capsule_ptr = static_cast<void *>(value.cast<py::capsule>());\n+  auto destroy_ros_message =\n+    reinterpret_cast<destroy_ros_message_function *>(capsule_ptr);\n+  if (!destroy_ros_message) {\n+    throw py::error_already_set();\n+  }\n+\n+  void * message = create_ros_message();\n+  if (!message) {\n+    throw std::bad_alloc();\n+  }\n+  return std::unique_ptr<\n+    void, destroy_ros_message_function *>(message, destroy_ros_message);\n+}\n+\n+py::object\n+convert_to_py(void * message, py::object pyclass)\n+{\n+  py::object pymetaclass = pyclass.attr(\"__class__\");\n+\n+  auto capsule_ptr = static_cast<void *>(\n+    pymetaclass.attr(\"_CONVERT_TO_PY\").cast<py::capsule>());\n+\n+  typedef PyObject * convert_to_py_function (void *);\n+  auto convert = reinterpret_cast<convert_to_py_function *>(capsule_ptr);\n+  if (!convert) {\n+    throw py::error_already_set();\n+  }\n+  return py::reinterpret_steal<py::object>(convert(message));\n+}\n+"},{"role":"user","content":"+#include <memory>\n+"},{"role":"user","content":"+typedef void destroy_ros_message_function (void *);\n+"},{"role":"user","content":"+/// Create the equivalent ROS message C type instance for a given Python type.\n+/**\n+* Raises AttributeError if \\p pyclass is missing a required attribute.\n+*\n+* \\param[in] pyclass ROS message Python type to extract typesupport data from.\n+* \\return a ROS message C type instance.\n+*/\n+std::unique_ptr<void, destroy_ros_message_function *>\n+create_from_py(py::object pyclass);\n+\n+/// Convert a ROS message from a C type to a Python type.\n+/**\n+ * Raises AttributeError if \\p pyclass is missing a required attribute.\n+ *\n+ * \\param[in] message ROS message C type instance to be converted.\n+ * \\param[in] pyclass ROS message Python type to convert to.\n+ * \\return an instance of \\p pyclass.\n+ */\n+py::object\n+convert_to_py(void * message, py::object pyclass);\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"user","content":"-# Default to C++14\n+# Default to C++17"},{"role":"user","content":"-  set(CMAKE_CXX_STANDARD 14)\n+  set(CMAKE_CXX_STANDARD 17)\n+  set(CMAKE_CXX_STANDARD_REQUIRED ON)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <rcl_interfaces/srv/set_parameters_atomically.h>"},{"role":"user","content":"+typedef struct rcl_interfaces__srv__SetParametersAtomically_Request SetParametersAtomically_Request;\n+typedef struct rcl_interfaces__srv__SetParametersAtomically_Response\n+  SetParametersAtomically_Response;\n+"},{"role":"user","content":"-#define RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES 5\n+#define RCLC_EXECUTOR_PARAMETER_SERVER_HANDLES 6"},{"role":"user","content":"+  rcl_service_t set_atomically_service;"},{"role":"user","content":"+  SetParametersAtomically_Request set_atomically_request;\n+  SetParametersAtomically_Response set_atomically_response;\n+"},{"role":"user","content":"+void\n+rclc_parameter_server_set_atomically_service_callback(\n+  const void * req,\n+  void * res,\n+  void * parameter_server)\n+{\n+  (void) req;\n+  (void) res;\n+  (void) parameter_server;\n+\n+  return;\n+}\n+"},{"role":"user","content":"+  // Init SetAtomically service msgs\n+  mem_allocs_ok &=\n+    rcl_interfaces__srv__SetParametersAtomically_Request__init(\n+    &parameter_server->set_atomically_request);\n+  mem_allocs_ok &=\n+    rcl_interfaces__srv__SetParametersAtomically_Response__init(\n+    &parameter_server->set_atomically_response);\n+  mem_allocs_ok &= rcl_interfaces__msg__Parameter__Sequence__init(\n+    &parameter_server->set_atomically_request.parameters,\n+    options->max_params);\n+  parameter_server->set_atomically_request.parameters.size = 0;\n+  mem_allocs_ok &= rclc_parameter_descriptor_initialize_string(\n+    &parameter_server->set_atomically_response.result.reason);\n+\n+  // Set response result to unimplemented\n+  rclc_parameter_set_string(\n+    &parameter_server->set_atomically_response.result.reason,\n+    \"Unimplemented service\");\n+  parameter_server->set_atomically_response.result.successful = false;\n+"},{"role":"user","content":"+  // Init SetAtomically service msgs\n+  parameter_server->set_atomically_request.parameters.data = allocator.zero_allocate(\n+    1, sizeof(Parameter),\n+    allocator.state);\n+  parameter_server->set_atomically_request.parameters.size = 0;\n+  parameter_server->set_atomically_request.parameters.capacity = 1;\n+\n+  ret |= rclc_parameter_initialize_empty_string(\n+    &parameter_server->set_atomically_request.parameters.data[0].name,\n+    RCLC_PARAMETER_MAX_STRING_LENGTH);\n+\n+  char * unimplemented_msg = \"Unimplemented service\";\n+  ret |= rclc_parameter_initialize_empty_string(\n+    &parameter_server->set_atomically_response.result.reason,\n+    strlen(unimplemented_msg) + 1);\n+\n+  // Set response result to unimplemented\n+  rclc_parameter_set_string(\n+    &parameter_server->set_atomically_response.result.reason,\n+    unimplemented_msg);\n+  parameter_server->set_atomically_response.result.successful = false;\n+"},{"role":"user","content":"+  const rosidl_service_type_support_t * set_atom_ts = ROSIDL_GET_SRV_TYPE_SUPPORT(\n+    rcl_interfaces,\n+    srv,\n+    SetParametersAtomically);\n+  ret |= rclc_parameter_server_init_service(\n+    &parameter_server->set_atomically_service, node, \"/set_parameters_atomically\",\n+    set_atom_ts);\n+"},{"role":"user","content":"+  // Set atomically request\n+  allocator.deallocate(\n+    parameter_server->set_atomically_request.parameters.data[0].name.data,\n+    allocator.state);\n+  allocator.deallocate(parameter_server->set_atomically_request.parameters.data, allocator.state);\n+  parameter_server->set_atomically_request.parameters.capacity = 0;\n+  parameter_server->set_atomically_request.parameters.size = 0;\n+\n+  // Set atomically response\n+  allocator.deallocate(\n+    parameter_server->set_atomically_response.result.reason.data,\n+    allocator.state);\n+"},{"role":"user","content":"+  // Finish set atomically msgs\n+  for (size_t i = 0; i < parameter_server->set_atomically_request.parameters.capacity; ++i) {\n+    rosidl_runtime_c__String__fini(\n+      &parameter_server->set_atomically_request.parameters.data[i].name);\n+  }\n+\n+  rosidl_runtime_c__String__fini(&parameter_server->set_atomically_response.result.reason);\n+  rcl_interfaces__msg__Parameter__Sequence__fini(\n+    &parameter_server->set_atomically_request.parameters);\n+  rcl_interfaces__srv__SetParametersAtomically_Response__fini(\n+    &parameter_server->set_atomically_response);\n+  rcl_interfaces__srv__SetParametersAtomically_Request__fini(\n+    &parameter_server->set_atomically_request);\n+"},{"role":"user","content":"+  ret |= rcl_service_fini(&parameter_server->set_atomically_service, node);"},{"role":"user","content":"+  ret |= rclc_executor_add_service_with_context(\n+    executor, &parameter_server->set_atomically_service,\n+    &parameter_server->set_atomically_request, &parameter_server->set_atomically_response,\n+    rclc_parameter_server_set_atomically_service_callback,\n+    parameter_server);\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    VCS_URL https://git.savannah.gnu.org/git/freetype/freetype2.git\n+    VCS_URL https://github.com/freetype/freetype.git"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+find_package(Python3 REQUIRED COMPONENTS Interpreter)\n+"},{"role":"user","content":"-  COMMAND ${PYTHON_EXECUTABLE} ${rosidl_typesupport_fastrtps_c_BIN}\n+  COMMAND Python3::Interpreter\n+  ARGS ${rosidl_typesupport_fastrtps_c_BIN}"},{"role":"user","content":"+  <buildtool_export_depend>python3</buildtool_export_depend>"},{"role":"user","content":"+find_package(Python3 REQUIRED COMPONENTS Interpreter)\n+"},{"role":"user","content":"-  COMMAND ${PYTHON_EXECUTABLE} ${rosidl_typesupport_fastrtps_cpp_BIN}\n+  COMMAND Python3::Interpreter\n+  ARGS ${rosidl_typesupport_fastrtps_cpp_BIN}"},{"role":"user","content":"+  <buildtool_export_depend>python3</buildtool_export_depend>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-cmake_minimum_required(VERSION 3.5)\n+cmake_minimum_required(VERSION 3.12)"},{"role":"user","content":"+find_package(Python3 REQUIRED COMPONENTS Interpreter)\n+"},{"role":"user","content":"-  COMMAND ${PYTHON_EXECUTABLE} ARGS -c \"${python_code}\"\n+  COMMAND Python3::Interpreter ARGS -c \"${python_code}\""},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+            raise ROSInterruptException()"},{"role":"user","content":"+def sleep_check_exception(rate):\n+    try:\n+        rate.sleep()\n+    except ROSInterruptException:\n+        # rate.sleep() can raise ROSInterruptException if the context is\n+        # shutdown while it is sleeping.  Just ignore it here.\n+        pass\n+\n+"},{"role":"user","content":"-    _thread = threading.Thread(target=rate.sleep, daemon=True)\n+    _thread = threading.Thread(target=sleep_check_exception, args=rate, daemon=True)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))"},{"role":"user","content":"-#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#if RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP\n+  // UserObjectQosPolicy is an internal, undocumented Connext policy used by the\n+  // implementations of different language bindings to control the memory\n+  // representations of various objects created by user applications. In this\n+  // case, the settings match the requirements of the \"modern C++\" API, and they\n+  // allow the DomainParticipant to be used directly by applications that want\n+  // to create new entities in C++11, even though the participant was created\n+  // using the C API. If these settings are not specified, an application will\n+  // receive a SIGSEGV when trying to create one of these entities.\n+  //\n+  // The customizations are always applied regardless of the QoS override policy\n+  // because UserObjectQosPolicy cannot be modified from XML.\n+  //\n+  dp_qos->user_object.flow_controller_user_object.size = sizeof(void *);\n+  dp_qos->user_object.topic_user_object.size = sizeof(void *);\n+  dp_qos->user_object.content_filtered_topic_user_object.size = sizeof(void *);\n+#endif /* RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP */\n+"},{"role":"user","content":"-#if RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP\n-  // UserObjectQosPolicy is an internal, undocumented Connext policy used by the\n-  // implementations of different language bindings to control the memory\n-  // representations of various objects created by user applications. In this\n-  // case, the settings match the requirements of the \"modern C++\" API, and they\n-  // allow the DomainParticipant to be used directly by applications that want\n-  // to create new entities in C++11, even though the participant was created\n-  // using the C API. If these settings are not specified, an application will\n-  // receive a SIGSEGV when trying to create one of these entities.\n-  dp_qos->user_object.flow_controller_user_object.size = sizeof(void *);\n-  dp_qos->user_object.topic_user_object.size = sizeof(void *);\n-  dp_qos->user_object.content_filtered_topic_user_object.size = sizeof(void *);\n-#endif /* RMW_CONNEXT_SHARE_DDS_ENTITIES_WITH_CPP */\n-"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-if(cpp_typesupport_target)\n+if(TARGET \"${cpp_typesupport_target}\")"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  // We can avoid waiting if there are already the expected number of publishers\n+  // We can avoid waiting if there are already the expected number of entities"},{"role":"user","content":"-check_graph_state(\n+check_entity_count("},{"role":"user","content":"-  const std::chrono::nanoseconds & timeout)\n+  std::chrono::seconds timeout)"},{"role":"user","content":"-    \"Expecting %zu publishers, %zu subscribers, and that the topic is%s in the graph.\",\n+    \"Expecting number of %zu publishers, %zu subscribers, and that the topic is%s in the graph.\","},{"role":"user","content":"-\n-  // Wait for expected number of publishers\n-  bool success = false;\n-  ret = rcl_wait_for_publishers(\n-    node_ptr, &allocator, topic_name.c_str(), expected_publisher_count, timeout.count(), &success);\n-  ASSERT_EQ(ret, RCL_RET_OK);\n-  EXPECT_TRUE(success);\n-  // Wait for expected number of subscribers\n-  success = false;\n-  ret = rcl_wait_for_subscribers(\n-    node_ptr, &allocator, topic_name.c_str(), expected_subscriber_count, timeout.count(), &success);\n-  ASSERT_EQ(ret, RCL_RET_OK);\n-  EXPECT_TRUE(success);\n+  size_t pub_count, sub_count;\n+\n+  // Check number of entities until timeout expires.\n+  auto start_time = std::chrono::system_clock::now();\n+  do {\n+    ret = rcl_count_publishers(node_ptr, topic_name.c_str(), &pub_count);\n+    ASSERT_EQ(ret, RCL_RET_OK);\n+    ret = rcl_count_subscribers(node_ptr, topic_name.c_str(), &sub_count);\n+    ASSERT_EQ(ret, RCL_RET_OK);\n+    if ((expected_publisher_count == pub_count) &&\n+      (expected_subscriber_count == sub_count))\n+    {\n+      break;\n+    }\n+    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+  } while (std::chrono::system_clock::now() - start_time < timeout);\n+  EXPECT_EQ(expected_publisher_count, pub_count);\n+  EXPECT_EQ(expected_subscriber_count, sub_count);"},{"role":"user","content":"-  for (size_t i = 0; RCL_RET_OK == ret && i < tnat.names.size; ++i) {\n+  for (size_t i = 0; i < tnat.names.size; ++i) {"},{"role":"user","content":"-  check_graph_state(\n+  check_entity_count("},{"role":"user","content":"-  check_graph_state(\n+  check_entity_count("},{"role":"user","content":"-  check_graph_state(\n+  check_entity_count("},{"role":"user","content":"-  check_graph_state(\n+  check_entity_count("},{"role":"user","content":"-  check_graph_state(\n+  check_entity_count("},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  <maintainer email=\"scott@openrobotics.org\">Scott K Logan</maintainer>\n-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"scott@openrobotics.org\">Scott K Logan</author>\n+  <author email=\"william@openrobotics.org\">William Woodall</author>"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>\n+"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>\n+"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>"},{"role":"user","content":"-    <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+    <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+    <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+    <author email=\"william@openrobotics.org\">William Woodall</author>\n+"},{"role":"user","content":"-  <maintainer email=\"william@openrobotics.org\">William Woodall</maintainer>\n+  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"michael.jeronimo@openrobotics.org\">Michael Jeronimo</maintainer>"},{"role":"user","content":"+  <author email=\"william@openrobotics.org\">William Woodall</author>"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  node_time_source_(other.node_time_source_),\n+  node_waitables_(other.node_waitables_),"},{"role":"user","content":"+TEST_F(TestServer, construction_and_destruction_sub_node)\n+{\n+  auto parent_node = std::make_shared<rclcpp::Node>(\"construct_node\", \"/rclcpp_action/construct\");\n+  auto sub_node = parent_node->create_sub_node(\"construct_sub_node\");\n+\n+  ASSERT_NO_THROW(\n+  {\n+    using GoalHandle = rclcpp_action::ServerGoalHandle<Fibonacci>;\n+    auto as = rclcpp_action::create_server<Fibonacci>(\n+      sub_node, \"fibonacci\",\n+      [](const GoalUUID &, std::shared_ptr<const Fibonacci::Goal>) {\n+        return rclcpp_action::GoalResponse::REJECT;\n+      },\n+      [](std::shared_ptr<GoalHandle>) {\n+        return rclcpp_action::CancelResponse::REJECT;\n+      },\n+      [](std::shared_ptr<GoalHandle>) {});\n+    (void)as;\n+  });\n+}\n+"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-1. Load ROS into the shell environment, e.g. if you are using Foxy:\n+1. Load ROS into the shell environment (Rolling if using the `master` branch,\n+   see [Support for different ROS 2 Releases](#support-for-different-ros-2-releases))"},{"role":"user","content":"-    source /opt/ros/foxy/setup.bash\n+    source /opt/ros/rolling/setup.bash"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#define RET_EXPECTED(func, expected_ret, error_msg, code) do { \\\n+    if ((expected_ret) != (func)) \\\n+    { \\\n+      RET_ERR_X(error_msg, code); \\\n+    } \\\n+} while (0)"},{"role":"user","content":"+template<typename entityT>\n+static void * init_and_alloc_sample(\n+  entityT & entity, const uint32_t sample_size, const bool alloc_on_heap = false)\n+{\n+  // initialise the data allocator\n+  if (alloc_on_heap) {\n+    RET_EXPECTED(\n+      dds_data_allocator_init_heap(&entity->data_allocator),\n+      DDS_RETCODE_OK,\n+      \"Reader data allocator initialization failed for heap\",\n+      return nullptr);\n+  } else {\n+    RET_EXPECTED(\n+      dds_data_allocator_init(entity->enth, &entity->data_allocator),\n+      DDS_RETCODE_OK,\n+      \"Writer allocator initialisation failed\",\n+      return nullptr);\n+  }\n+  // allocate memory for message + header\n+  auto chunk_ptr = dds_data_allocator_alloc(\n+    &entity->data_allocator,\n+    DETERMINE_ICEORYX_CHUNK_SIZE(sample_size));\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    chunk_ptr,\n+    \"Failed to get loan\",\n+    return nullptr);\n+  auto ice_hdr = static_cast<iceoryx_header_t *>(chunk_ptr);\n+  ice_hdr->data_size = sample_size;\n+  auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n+  // initialize the memory for message\n+  rmw_cyclonedds_cpp::init_message(&entity->type_supports, ptr);\n+  return ptr;\n+}\n+\n+template<typename entityT>\n+static rmw_ret_t fini_and_free_sample(entityT & entity, void * loaned_message)\n+{\n+  // fini the message\n+  rmw_cyclonedds_cpp::fini_message(&entity->type_supports, loaned_message);\n+  // free the message memory\n+  RET_EXPECTED(\n+    dds_data_allocator_free(\n+      &entity->data_allocator,\n+      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message)),\n+    DDS_RETCODE_OK,\n+    \"Failed to free the loaned message\",\n+    return RMW_RET_ERROR);\n+  // fini the allocator\n+  RET_EXPECTED(\n+    dds_data_allocator_fini(&entity->data_allocator),\n+    DDS_RETCODE_OK,\n+    \"Failed to fini data allocator\",\n+    return RMW_RET_ERROR);\n+  return RMW_RET_OK;\n+}\n+"},{"role":"user","content":"-    dds_data_allocator_init(pub->enth, &pub->data_allocator);\n-    auto sample_size = d->type->iox_size;\n-    auto chunk_ptr = dds_data_allocator_alloc(\n-      &pub->data_allocator,\n-      DETERMINE_ICEORYX_CHUNK_SIZE(sample_size));\n-    RMW_CHECK_FOR_NULL_WITH_MSG(\n-      chunk_ptr,\n-      \"Failed to get loan\",\n-      return RMW_RET_ERROR);\n-    auto ice_hdr = static_cast<iceoryx_header_t *>(chunk_ptr);\n-    ice_hdr->data_size = sample_size;\n-    auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-    rmw_cyclonedds_cpp::init_message(&pub->type_supports, ptr);\n-    if (rmw_deserialize(serialized_message, &pub->type_supports, ptr) != RMW_RET_OK) {\n+    auto sample_ptr = init_and_alloc_sample(pub, d->type->iox_size);\n+    RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n+    if (rmw_deserialize(serialized_message, &pub->type_supports, sample_ptr) != RMW_RET_OK) {"},{"role":"user","content":"-    d->iox_chunk = ice_hdr;\n+    d->iox_chunk = SHIFT_BACK_TO_ICEORYX_HEADER(sample_ptr);"},{"role":"user","content":"-    // initialize the data allocator\n-    dds_data_allocator_init(cdds_publisher->enth, &cdds_publisher->data_allocator);\n-    // allocate memory for message + header\n-    auto sample_size = cdds_publisher->sample_size;\n-    auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(sample_size);\n-    auto chunk_ptr = dds_data_allocator_alloc(\n-      &cdds_publisher->data_allocator, chunk_size);\n-    RMW_CHECK_FOR_NULL_WITH_MSG(\n-      chunk_ptr,\n-      \"Failed to get loan\",\n-      return RMW_RET_ERROR);\n-    // initialize the memory for message\n-    auto ice_hdr = static_cast<iceoryx_header_t *>(chunk_ptr);\n-    ice_hdr->data_size = sample_size;\n-    auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-    rmw_cyclonedds_cpp::init_message(type_support, ptr);\n-    *ros_message = ptr;\n+    auto sample_ptr = init_and_alloc_sample(cdds_publisher, cdds_publisher->sample_size);\n+    RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n+    *ros_message = sample_ptr;"},{"role":"user","content":"-    // fini message\n-    rmw_cyclonedds_cpp::fini_message(&cdds_publisher->type_supports, loaned_message);\n-    // free the message memory\n-    dds_data_allocator_free(\n-      &cdds_publisher->data_allocator,\n-      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n-    // fini data collector\n-    dds_data_allocator_fini(&cdds_publisher->data_allocator);\n-    return RMW_RET_OK;\n+    return fini_and_free_sample(cdds_publisher, loaned_message);"},{"role":"user","content":"-        // allocate on the heap\n-        dds_data_allocator_init_heap(&cdds_subscription->data_allocator);\n-        auto chunk_size = DETERMINE_ICEORYX_CHUNK_SIZE(d->type->iox_size);\n-        auto chunk_ptr = dds_data_allocator_alloc(\n-          &cdds_subscription->data_allocator, chunk_size);\n-        RMW_CHECK_FOR_NULL_WITH_MSG(\n-          chunk_ptr,\n-          \"Failed to allocate memory for the received sample\",\n-          return RMW_RET_ERROR);\n-        auto ice_hdr = static_cast<iceoryx_header_t *>(chunk_ptr);\n-        ice_hdr->data_size = d->type->iox_size;\n-        auto ptr = SHIFT_PAST_ICEORYX_HEADER(ice_hdr);\n-        rmw_cyclonedds_cpp::init_message(&cdds_subscription->type_supports, ptr);\n-        ddsi_serdata_to_sample(d, ptr, nullptr, nullptr);\n-        *loaned_message = ptr;\n+        auto sample_ptr = init_and_alloc_sample(cdds_subscription, d->type->iox_size, true);\n+        RET_NULL_X(sample_ptr, return RMW_RET_ERROR);\n+        ddsi_serdata_to_sample(d, sample_ptr, nullptr, nullptr);\n+        *loaned_message = sample_ptr;"},{"role":"user","content":"-    rmw_cyclonedds_cpp::fini_message(&cdds_subscription->type_supports, loaned_message);\n-    dds_data_allocator_free(\n-      &cdds_subscription->data_allocator,\n-      SHIFT_BACK_TO_ICEORYX_HEADER(loaned_message));\n-    dds_data_allocator_fini(&cdds_subscription->data_allocator);\n+    return fini_and_free_sample(cdds_subscription, loaned_message);"},{"role":"user","content":"+    return RMW_RET_ERROR;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  } else if (existing_sub_namespace.empty() && extension.empty()) {\n+    throw rclcpp::exceptions::NameValidationError(\n+            \"sub_namespace\",\n+            extension.c_str(),\n+            \"sub-nodes should not extend nodes by an empty sub-namespace\",\n+            0);"},{"role":"user","content":"-  if (node_namespace.back() == '/') {\n+  // A node may not have a sub_namespace if it is no sub_node. In this case,\n+  // just return the original namespace\n+  if (sub_namespace.empty()) {\n+    return node_namespace;\n+  } else if (node_namespace.back() == '/') {"},{"role":"user","content":"+    EXPECT_STREQ(\"/ns\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+    EXPECT_STREQ(\"/ns\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+    EXPECT_STREQ(\"/\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+    EXPECT_STREQ(\"/\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+    EXPECT_STREQ(\"/my/ns\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+    EXPECT_STREQ(\"/my/ns\", node->get_effective_namespace().c_str());"},{"role":"user","content":"+  {\n+    ASSERT_THROW(\n+    {\n+      auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"/ns\");\n+      auto subnode = node->create_sub_node(\"\");\n+    }, rclcpp::exceptions::NameValidationError);\n+  }"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    auto time = std::chrono::high_resolution_clock::now() - start;\n-    auto time_msec = std::chrono::duration_cast<std::chrono::milliseconds>(time);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    const rclcpp::QoS & qos = rclcpp::RosoutQoS()\n+    const rclcpp::QoS & qos = rclcpp::RosoutQoS(),\n+    bool use_clock_thread = true"},{"role":"user","content":"+   *   - use_clock_thread = true"},{"role":"user","content":"+\n+  /// Return the use_clock_thread flag.\n+  RCLCPP_PUBLIC\n+  bool\n+  use_clock_thread() const;\n+\n+  /// Set the use_clock_thread flag, return this for parameter idiom.\n+  /**\n+   * If true, a dedicated thread will be used to subscribe to \"/clock\" topic.\n+   */\n+  RCLCPP_PUBLIC\n+  NodeOptions &\n+  use_clock_thread(bool use_clock_thread);\n+"},{"role":"user","content":"+  bool use_clock_thread_ {true};\n+"},{"role":"user","content":"+#include \"rclcpp/executors.hpp\""},{"role":"user","content":"-  explicit TimeSource(rclcpp::Node::SharedPtr node, const rclcpp::QoS & qos = rclcpp::ClockQoS());\n+  explicit TimeSource(\n+    rclcpp::Node::SharedPtr node,\n+    const rclcpp::QoS & qos = rclcpp::ClockQoS(),\n+    bool use_clock_thread = true);"},{"role":"user","content":"-  explicit TimeSource(const rclcpp::QoS & qos = rclcpp::ClockQoS());\n+  explicit TimeSource(\n+    const rclcpp::QoS & qos = rclcpp::ClockQoS(),\n+    bool use_clock_thread = true);"},{"role":"user","content":"+protected:\n+  // Dedicated thread for clock subscription.\n+  bool use_clock_thread_;\n+  std::thread clock_executor_thread_;\n+"},{"role":"user","content":"+  rclcpp::CallbackGroup::SharedPtr clock_callback_group_;\n+  rclcpp::executors::SingleThreadedExecutor clock_executor_;\n+  std::promise<void> cancel_clock_executor_promise_;"},{"role":"user","content":"-      options.clock_qos()\n+      options.clock_qos(),\n+      options.use_clock_thread()"},{"role":"user","content":"-  const rclcpp::QoS & qos)\n+  const rclcpp::QoS & qos,\n+  bool use_clock_thread)"},{"role":"user","content":"-  time_source_(qos)\n+  time_source_(qos, use_clock_thread)"},{"role":"user","content":"+    this->use_clock_thread_ = other.use_clock_thread_;"},{"role":"user","content":"+bool\n+NodeOptions::use_clock_thread() const\n+{\n+  return this->use_clock_thread_;\n+}\n+\n+NodeOptions &\n+NodeOptions::use_clock_thread(bool use_clock_thread)\n+{\n+  this->use_clock_thread_ = use_clock_thread;\n+  return *this;\n+}\n+"},{"role":"user","content":"-TimeSource::TimeSource(std::shared_ptr<rclcpp::Node> node, const rclcpp::QoS & qos)\n-: logger_(rclcpp::get_logger(\"rclcpp\")),\n+TimeSource::TimeSource(\n+  std::shared_ptr<rclcpp::Node> node,\n+  const rclcpp::QoS & qos,\n+  bool use_clock_thread)\n+: use_clock_thread_(use_clock_thread),\n+  logger_(rclcpp::get_logger(\"rclcpp\")),"},{"role":"user","content":"-TimeSource::TimeSource(const rclcpp::QoS & qos)\n-: logger_(rclcpp::get_logger(\"rclcpp\")),\n+TimeSource::TimeSource(\n+  const rclcpp::QoS & qos,\n+  bool use_clock_thread)\n+: use_clock_thread_(use_clock_thread),\n+  logger_(rclcpp::get_logger(\"rclcpp\")),"},{"role":"user","content":"+  use_clock_thread_ = node->get_node_options().use_clock_thread();"},{"role":"user","content":"-  clock_subscription_.reset();\n+  destroy_clock_sub();"},{"role":"user","content":"+  if (use_clock_thread_) {\n+    clock_callback_group_ = node_base_->create_callback_group(\n+      rclcpp::CallbackGroupType::MutuallyExclusive,\n+      false\n+    );\n+    options.callback_group = clock_callback_group_;\n+    if (!clock_executor_thread_.joinable()) {\n+      clock_executor_thread_ = std::thread(\n+        [this]() {\n+          cancel_clock_executor_promise_ = std::promise<void>{};\n+          auto future = cancel_clock_executor_promise_.get_future();\n+          clock_executor_.add_callback_group(clock_callback_group_, node_base_);\n+          clock_executor_.spin_until_future_complete(future);\n+        }\n+      );\n+    }\n+  }\n+"},{"role":"user","content":"+  if (clock_executor_thread_.joinable()) {\n+    cancel_clock_executor_promise_.set_value();\n+    clock_executor_.cancel();\n+    clock_executor_thread_.join();\n+    clock_executor_.remove_callback_group(clock_callback_group_);\n+  }"},{"role":"user","content":"+\n+// A TimeSource-inheriting class\n+// that allows access to TimeSource protected attributes\n+// use_clock_thread_ and clock_executor_thread_\n+class ClockThreadTestingTimeSource : public rclcpp::TimeSource\n+{\n+public:\n+  ClockThreadTestingTimeSource()\n+  : rclcpp::TimeSource()\n+  {\n+  }\n+\n+  bool GetUseClockThreadOption()\n+  {\n+    return this->use_clock_thread_;\n+  }\n+\n+  bool IsClockThreadJoinable()\n+  {\n+    return this->clock_executor_thread_.joinable();\n+  }\n+};\n+\n+TEST_F(TestTimeSource, check_use_clock_thread_value) {\n+  // Create three nodes, with use_clock_thread option\n+  // respectively set to default, true, and false\n+\n+  auto default_node_ = std::make_shared<rclcpp::Node>(\n+    \"default_option_node\");\n+\n+  auto clock_thread_node_ = std::make_shared<rclcpp::Node>(\n+    \"clock_thread_node\",\n+    rclcpp::NodeOptions().use_clock_thread(true));\n+\n+  auto no_clock_thread_node_ = std::make_shared<rclcpp::Node>(\n+    \"no_clock_thread_node\",\n+    rclcpp::NodeOptions().use_clock_thread(false));\n+\n+  // Test value of use_clock_thread_ TimeSource attribute\n+  // when the different nodes are attached\n+\n+  ClockThreadTestingTimeSource ts;\n+\n+  ts.attachNode(default_node_);\n+  ASSERT_TRUE(ts.GetUseClockThreadOption());\n+  ts.detachNode();\n+\n+  ts.attachNode(clock_thread_node_);\n+  ASSERT_TRUE(ts.GetUseClockThreadOption());\n+  ts.detachNode();\n+\n+  ts.attachNode(no_clock_thread_node_);\n+  ASSERT_FALSE(ts.GetUseClockThreadOption());\n+  ts.detachNode();\n+}\n+\n+TEST_F(TestTimeSource, check_clock_thread_status) {\n+  // Test if TimeSource clock-dedicated thread is running\n+  // according to the use_sim_time parameter\n+  // and to the options of the attached node\n+  ClockThreadTestingTimeSource ts;\n+\n+  // Tests for default options node\n+  auto default_node_ = std::make_shared<rclcpp::Node>(\n+    \"default_option_node\");\n+\n+  default_node_->set_parameter(rclcpp::Parameter(\"use_sim_time\", true));\n+  ts.attachNode(default_node_);\n+  ASSERT_TRUE(ts.IsClockThreadJoinable());\n+  ts.detachNode();\n+\n+  default_node_->set_parameter(rclcpp::Parameter(\"use_sim_time\", false));\n+  ts.attachNode(default_node_);\n+  ASSERT_FALSE(ts.IsClockThreadJoinable());\n+  ts.detachNode();\n+\n+  // Tests for node with use_clock_thread option forced to false\n+  auto no_clock_thread_node_ = std::make_shared<rclcpp::Node>(\n+    \"no_clock_thread_node\",\n+    rclcpp::NodeOptions().use_clock_thread(false));\n+\n+  no_clock_thread_node_->set_parameter(rclcpp::Parameter(\"use_sim_time\", true));\n+  ts.attachNode(no_clock_thread_node_);\n+  ASSERT_FALSE(ts.IsClockThreadJoinable());\n+  ts.detachNode();\n+\n+  no_clock_thread_node_->set_parameter(rclcpp::Parameter(\"use_sim_time\", false));\n+  ts.attachNode(no_clock_thread_node_);\n+  ASSERT_FALSE(ts.IsClockThreadJoinable());\n+  ts.detachNode();\n+}\n+\n+// A Node-inheriting class\n+// that regularly publishes a incremented Clock msg on topic `/clock'\n+class SimClockPublisherNode : public rclcpp::Node\n+{\n+public:\n+  SimClockPublisherNode()\n+  : rclcpp::Node(\"sim_clock_publisher_node\")\n+  {\n+    // Create a clock publisher\n+    clock_pub_ = this->create_publisher<rosgraph_msgs::msg::Clock>(\n+      \"/clock\",\n+      rclcpp::QoS(1)\n+    );\n+\n+    // Create a 1ms timer\n+    pub_timer_ = this->create_wall_timer(\n+      std::chrono::milliseconds(1),\n+      std::bind(\n+        &SimClockPublisherNode::timer_callback,\n+        this)\n+    );\n+\n+    // Init clock msg to zero\n+    clock_msg_.clock.sec = 0;\n+    clock_msg_.clock.nanosec = 0;\n+  }\n+\n+  ~SimClockPublisherNode()\n+  {\n+    // Cleanly stop executor and thread\n+    node_executor.cancel();\n+    node_thread_.join();\n+  }\n+\n+  void SpinNode()\n+  {\n+    // Spin node in its own dedicated thread\n+    node_thread_ = std::thread(\n+      [this]() {\n+        node_executor.add_node(this->get_node_base_interface());\n+        node_executor.spin();\n+      });\n+  }\n+\n+private:\n+  void timer_callback()\n+  {\n+    // Increment clock msg and publish it\n+    clock_msg_.clock.nanosec += 1000000;\n+    clock_pub_->publish(clock_msg_);\n+  }\n+\n+  rclcpp::Publisher<rosgraph_msgs::msg::Clock>::SharedPtr clock_pub_;\n+  rclcpp::TimerBase::SharedPtr pub_timer_;\n+  rosgraph_msgs::msg::Clock clock_msg_;\n+  std::thread node_thread_;\n+  rclcpp::executors::SingleThreadedExecutor node_executor;\n+};\n+\n+// A Node-inheriting class\n+// that check its clock time within a timer callback\n+class ClockThreadTestingNode : public rclcpp::Node\n+{\n+public:\n+  ClockThreadTestingNode()\n+  : rclcpp::Node(\"clock_thread_testing_node\")\n+  {\n+    // Set use_sim_time parameter to true to subscribe to `/clock` topic\n+    this->set_parameter(rclcpp::Parameter(\"use_sim_time\", true));\n+\n+    // Create a 100ms timer\n+    timer_ = this->create_wall_timer(\n+      std::chrono::milliseconds(100),\n+      std::bind(\n+        &ClockThreadTestingNode::timer_callback,\n+        this)\n+    );\n+  }\n+\n+  bool GetIsCallbackFrozen()\n+  {\n+    return is_callback_frozen_;\n+  }\n+\n+private:\n+  void timer_callback()\n+  {\n+    rclcpp::Time start_time = this->now();\n+    bool is_time_out = false;\n+\n+    // While loop condition tests\n+    // if the node's clock time is incremented\n+    while (rclcpp::ok() &&\n+      !is_time_out)\n+    {\n+      rclcpp::sleep_for(std::chrono::milliseconds(100));\n+      rclcpp::Time time_now = this->now();\n+      rclcpp::Duration time_spent = time_now - start_time;\n+      is_time_out = time_spent.seconds() > 1.0;\n+    }\n+\n+    // If out of while loop, set variable to false\n+    // and cancel timer to avoid to enter the callback again\n+    is_callback_frozen_ = false;\n+    timer_->cancel();\n+  }\n+\n+  rclcpp::TimerBase::SharedPtr timer_;\n+  bool is_callback_frozen_ = true;\n+};\n+\n+TEST_F(TestTimeSource, check_sim_time_updated_in_callback_if_use_clock_thread) {\n+  // Test if clock time of a node with\n+  // parameter use_sim_time = true and option use_clock_thread = true\n+  // is updated while node is not spinning\n+  // (in a timer callback)\n+\n+  // Create a \"sim time\" publisher and spin it\n+  SimClockPublisherNode pub_node;\n+  pub_node.SpinNode();\n+\n+  // Spin node for 2 seconds\n+  ClockThreadTestingNode clock_thread_testing_node;\n+  auto steady_clock = rclcpp::Clock(RCL_STEADY_TIME);\n+  auto start_time = steady_clock.now();\n+  while (rclcpp::ok() &&\n+    (steady_clock.now() - start_time).seconds() < 2.0)\n+  {\n+    rclcpp::spin_some(clock_thread_testing_node.get_node_base_interface());\n+  }\n+\n+  // Node should have get out of timer callback\n+  ASSERT_FALSE(clock_thread_testing_node.GetIsCallbackFrozen());\n+}"},{"role":"user","content":"-      options.clock_qos()\n+      options.clock_qos(),\n+      options.use_clock_thread()"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-if(NOT CycloneDDS_FOUND)\n+if(CycloneDDS_FOUND)\n+  # Support for shared memory in RMW depends on support for shared memory being compiled in\n+  # Cyclone DDS and iceoryx_binding_c being available\n+  get_target_property(cyclonedds_has_shm CycloneDDS::ddsc SHM_SUPPORT_IS_AVAILABLE)\n+  if(cyclonedds_has_shm)\n+    find_package(iceoryx_binding_c REQUIRED)\n+  else()\n+    message(STATUS \"Cyclone DDS is NOT compiled with support for shared memory\")\n+  endif()\n+else()"},{"role":"user","content":"+if(cyclonedds_has_shm)\n+  target_link_libraries(rmw_cyclonedds_cpp PRIVATE iceoryx_binding_c::iceoryx_binding_c)\n+endif()\n+"},{"role":"user","content":"-  auto * d = static_cast<const serdata_rmw *>(dcmn);\n+  auto * d = static_cast<serdata_rmw *>(dcmn);\n+\n+#ifdef DDS_HAS_SHM\n+  if (d->iox_chunk && d->iox_subscriber) {\n+    iox_sub_release_chunk(*static_cast<iox_sub_t *>(d->iox_subscriber), d->iox_chunk);\n+    d->iox_chunk = nullptr;\n+  }\n+#endif"},{"role":"user","content":"+extern \"C\" {\n+#include \"dds/ddsi/shm_sync.h\"\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+typedef struct logging_input_s\n+{\n+  const char * name;\n+  const rcutils_log_location_t * location;\n+  const char * msg;\n+  int severity;\n+  rcutils_time_point_value_t timestamp;\n+} logging_input_t;\n+\n+typedef const char * (* token_handler)(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset);\n+\n+typedef struct log_msg_part_s\n+{\n+  token_handler handler;\n+  size_t start_offset;\n+  size_t end_offset;\n+} log_msg_part_t;\n+\n+static size_t g_num_log_msg_handlers = 0;\n+static log_msg_part_t g_handlers[1024];\n+"},{"role":"user","content":"+static const char * expand_time(\n+  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,\n+  rcutils_ret_t (* time_func)(const rcutils_time_point_value_t *, char *, size_t))\n+{\n+  // Temporary, local storage for integer/float conversion to string\n+  // Note:\n+  //   32 characters enough, because the most it can be is 20 characters\n+  //   for the 19 possible digits in a signed 64-bit number plus the optional\n+  //   decimal point in the floating point seconds version\n+  char numeric_storage[32];\n+\n+  if (time_func(\n+      &logging_input->timestamp, numeric_storage,\n+      sizeof(numeric_storage)) != RCUTILS_RET_OK)\n+  {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    rcutils_reset_error();\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    return NULL;\n+  }\n+\n+  if (rcutils_char_array_strcat(logging_output, numeric_storage) != RCUTILS_RET_OK) {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    rcutils_reset_error();\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    return NULL;\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_time_as_seconds(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_seconds_string);\n+}\n+\n+static const char * expand_time_as_nanoseconds(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_nanoseconds_string);\n+}\n+\n+static const char * expand_line_number(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  if (logging_input->location) {\n+    // Allow 9 digits for the expansion of the line number (otherwise, truncate).\n+    char line_number_expansion[10];\n+\n+    // Even in the case of truncation the result will still be null-terminated.\n+    int written = rcutils_snprintf(\n+      line_number_expansion, sizeof(line_number_expansion), \"%zu\",\n+      logging_input->location->line_number);\n+    if (written < 0) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n+        \"failed to format line number: '%zu'\\n\", logging_input->location->line_number);\n+      return NULL;\n+    }\n+\n+    if (rcutils_char_array_strcat(logging_output, line_number_expansion) != RCUTILS_RET_OK) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+      rcutils_reset_error();\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+      return NULL;\n+    }\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_severity(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  const char * severity_string = g_rcutils_log_severity_names[logging_input->severity];\n+  if (rcutils_char_array_strcat(logging_output, severity_string) != RCUTILS_RET_OK) {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    rcutils_reset_error();\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    return NULL;\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_name(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  if (NULL != logging_input->name) {\n+    if (rcutils_char_array_strcat(logging_output, logging_input->name) != RCUTILS_RET_OK) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+      rcutils_reset_error();\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+      return NULL;\n+    }\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_message(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  if (rcutils_char_array_strcat(logging_output, logging_input->msg) != RCUTILS_RET_OK) {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    rcutils_reset_error();\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    return NULL;\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_function_name(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  if (logging_input->location) {\n+    if (rcutils_char_array_strcat(\n+        logging_output,\n+        logging_input->location->function_name) != RCUTILS_RET_OK)\n+    {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+      rcutils_reset_error();\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+      return NULL;\n+    }\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static const char * expand_file_name(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)start_offset;\n+  (void)end_offset;\n+\n+  if (logging_input->location) {\n+    if (rcutils_char_array_strcat(\n+        logging_output,\n+        logging_input->location->file_name) != RCUTILS_RET_OK)\n+    {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+      rcutils_reset_error();\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+      return NULL;\n+    }\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+typedef struct token_map_entry_s\n+{\n+  const char * token;\n+  token_handler handler;\n+} token_map_entry_t;\n+\n+static const token_map_entry_t tokens[] = {\n+  {.token = \"severity\", .handler = expand_severity},\n+  {.token = \"name\", .handler = expand_name},\n+  {.token = \"message\", .handler = expand_message},\n+  {.token = \"function_name\", .handler = expand_function_name},\n+  {.token = \"file_name\", .handler = expand_file_name},\n+  {.token = \"time\", .handler = expand_time_as_seconds},\n+  {.token = \"time_as_nanoseconds\", .handler = expand_time_as_nanoseconds},\n+  {.token = \"line_number\", .handler = expand_line_number},\n+};\n+\n+static token_handler find_token_handler(const char * token)\n+{\n+  int token_number = sizeof(tokens) / sizeof(tokens[0]);\n+  for (int token_index = 0; token_index < token_number; token_index++) {\n+    if (strcmp(token, tokens[token_index].token) == 0) {\n+      return tokens[token_index].handler;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static const char * copy_from_orig(\n+  const logging_input_t * logging_input,\n+  rcutils_char_array_t * logging_output,\n+  size_t start_offset, size_t end_offset)\n+{\n+  (void)logging_input;\n+\n+  if (rcutils_char_array_strncat(\n+      logging_output,\n+      g_rcutils_logging_output_format_string + start_offset,\n+      end_offset - start_offset) != RCUTILS_RET_OK)\n+  {\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str);\n+    rcutils_reset_error();\n+    RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+    return NULL;\n+  }\n+\n+  return logging_output->buffer;\n+}\n+\n+static void parse_and_create_handlers_list(void)\n+{\n+  // Process the format string looking for known tokens.\n+  const char token_start_delimiter = '{';\n+  const char token_end_delimiter = '}';\n+\n+  const char * str = g_rcutils_logging_output_format_string;\n+  size_t size = strlen(g_rcutils_logging_output_format_string);\n+\n+  g_num_log_msg_handlers = 0;\n+\n+  // Walk through the format string and create callbacks when they're encountered.\n+  size_t i = 0;\n+  while (i < size) {\n+    // Print everything up to the next token start delimiter.\n+    size_t chars_to_start_delim = rcutils_find(str + i, token_start_delimiter);\n+    size_t remaining_chars = size - i;\n+\n+    if (chars_to_start_delim > 0) {  // there is stuff before a token start delimiter\n+      size_t chars_to_copy = chars_to_start_delim >\n+        remaining_chars ? remaining_chars : chars_to_start_delim;\n+      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n+      g_handlers[g_num_log_msg_handlers].start_offset = i;\n+      g_handlers[g_num_log_msg_handlers].end_offset = i + chars_to_copy;\n+      if (g_num_log_msg_handlers >= sizeof(g_handlers) - 1) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\n+          \"Too many substitutions in the logging output format string; truncating\");\n+        rcutils_reset_error();\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+        return;\n+      }\n+      g_num_log_msg_handlers++;\n+\n+      i += chars_to_copy;\n+      if (i >= size) {  // perhaps no start delimiter was found\n+        break;\n+      }\n+\n+      continue;\n+    }\n+\n+    // We are at a token start delimiter: determine if there's a known token or not.\n+    // Potential tokens can't possibly be longer than the format string itself.\n+    char token[RCUTILS_LOGGING_MAX_OUTPUT_FORMAT_LEN];\n+\n+    // Look for a token end delimiter.\n+    size_t chars_to_end_delim = rcutils_find(str + i, token_end_delimiter);\n+    remaining_chars = size - i;\n+\n+    if (chars_to_end_delim > remaining_chars) {\n+      // No end delimiters found in the remainder of the format string;\n+      // there won't be any more tokens so shortcut the rest of the checking.\n+      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n+      g_handlers[g_num_log_msg_handlers].start_offset = i;\n+      g_handlers[g_num_log_msg_handlers].end_offset = i + remaining_chars;\n+      if (g_num_log_msg_handlers >= sizeof(g_handlers) - 1) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\n+          \"Too many substitutions in the logging output format string; truncating\");\n+        rcutils_reset_error();\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+        return;\n+      }\n+      g_num_log_msg_handlers++;\n+      break;\n+    }\n+\n+    // Found what looks like a token; determine if it's recognized.\n+    size_t token_len = chars_to_end_delim - 1;  // Not including delimiters.\n+    memcpy(token, str + i + 1, token_len);  // Skip the start delimiter.\n+    token[token_len] = '\\0';\n+\n+    token_handler expand_token = find_token_handler(token);\n+\n+    if (!expand_token) {\n+      // This wasn't a token; print the start delimiter and continue the search as usual\n+      // (the substring might contain more start delimiters).\n+      g_handlers[g_num_log_msg_handlers].handler = copy_from_orig;\n+      g_handlers[g_num_log_msg_handlers].start_offset = i;\n+      g_handlers[g_num_log_msg_handlers].end_offset = i + 1;\n+      if (g_num_log_msg_handlers >= sizeof(g_handlers) - 1) {\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\n+          \"Too many substitutions in the logging output format string; truncating\");\n+        rcutils_reset_error();\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+        return;\n+      }\n+      g_num_log_msg_handlers++;\n+      i++;\n+      continue;\n+    }\n+\n+    g_handlers[g_num_log_msg_handlers].handler = expand_token;\n+    // These are unused when using a token expander\n+    g_handlers[g_num_log_msg_handlers].start_offset = 0;\n+    g_handlers[g_num_log_msg_handlers].end_offset = 0;\n+    if (g_num_log_msg_handlers >= sizeof(g_handlers) - 1) {\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\n+        \"Too many substitutions in the logging output format string; truncating\");\n+      rcutils_reset_error();\n+      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\");\n+      return;\n+    }\n+    g_num_log_msg_handlers++;\n+\n+    // Skip ahead to avoid re-processing the token characters (including the 2 delimiters).\n+    i += token_len + 2;\n+  }\n+}\n+"},{"role":"user","content":"+  parse_and_create_handlers_list();\n+"},{"role":"user","content":"+"},{"role":"user","content":"+  g_num_log_msg_handlers = 0;"},{"role":"user","content":"-#define SAFE_FWRITE_TO_STDERR_AND(action) \\\n-  RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n-  rcutils_reset_error(); \\\n-  RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\"); \\\n-  action;\n-\n-#define OK_OR_RETURN_NULL(op) \\\n-  if (op != RCUTILS_RET_OK) { \\\n-    SAFE_FWRITE_TO_STDERR_AND(return NULL); \\\n-  }\n-\n-#define OK_OR_RETURN_EARLY(op) \\\n-  if (op != RCUTILS_RET_OK) { \\\n-    return op; \\\n-  }\n-\n-#define APPEND_AND_RETURN_LOG_OUTPUT(s) \\\n-  OK_OR_RETURN_NULL(rcutils_char_array_strcat(logging_output, s)); \\\n-  return logging_output->buffer;\n-"},{"role":"user","content":"-typedef struct logging_input_s\n-{\n-  const char * name;\n-  const rcutils_log_location_t * location;\n-  const char * msg;\n-  int severity;\n-  rcutils_time_point_value_t timestamp;\n-} logging_input_t;\n-\n-typedef const char * (* token_handler)(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output);\n-\n-typedef struct token_map_entry_s\n-{\n-  const char * token;\n-  token_handler handler;\n-} token_map_entry_t;\n-\n-static const char * expand_time(\n-  const logging_input_t * logging_input, rcutils_char_array_t * logging_output,\n-  rcutils_ret_t (* time_func)(const rcutils_time_point_value_t *, char *, size_t))\n-{\n-  // Temporary, local storage for integer/float conversion to string\n-  // Note:\n-  //   32 characters enough, because the most it can be is 20 characters\n-  //   for the 19 possible digits in a signed 64-bit number plus the optional\n-  //   decimal point in the floating point seconds version\n-  char numeric_storage[32];\n-  OK_OR_RETURN_NULL(time_func(&logging_input->timestamp, numeric_storage, sizeof(numeric_storage)));\n-  APPEND_AND_RETURN_LOG_OUTPUT(numeric_storage);\n-}\n-\n-static const char * expand_time_as_seconds(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_seconds_string);\n-}\n-\n-static const char * expand_time_as_nanoseconds(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  return expand_time(logging_input, logging_output, rcutils_time_point_value_as_nanoseconds_string);\n-}\n-\n-static const char * expand_line_number(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  // Allow 9 digits for the expansion of the line number (otherwise, truncate).\n-  char line_number_expansion[10];\n-\n-  const rcutils_log_location_t * location = logging_input->location;\n-\n-  if (!location) {\n-    OK_OR_RETURN_NULL(rcutils_char_array_strcpy(logging_output, \"0\"));\n-    return logging_output->buffer;\n-  }\n-\n-  // Even in the case of truncation the result will still be null-terminated.\n-  int written = rcutils_snprintf(\n-    line_number_expansion, sizeof(line_number_expansion), \"%zu\", location->line_number);\n-  if (written < 0) {\n-    RCUTILS_SAFE_FWRITE_TO_STDERR_WITH_FORMAT_STRING(\n-      \"failed to format line number: '%zu'\\n\", location->line_number);\n-    return NULL;\n-  }\n-\n-  APPEND_AND_RETURN_LOG_OUTPUT(line_number_expansion);\n-}\n-\n-static const char * expand_severity(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  const char * severity_string = g_rcutils_log_severity_names[logging_input->severity];\n-  APPEND_AND_RETURN_LOG_OUTPUT(severity_string);\n-}\n-\n-static const char * expand_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (NULL != logging_input->name) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input->name);\n-  }\n-  return logging_output->buffer;\n-}\n-\n-static const char * expand_message(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  OK_OR_RETURN_NULL(rcutils_char_array_strcat(logging_output, logging_input->msg));\n-  return logging_output->buffer;\n-}\n-\n-static const char * expand_function_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (logging_input->location) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input->location->function_name);\n-  }\n-  return logging_output->buffer;\n-}\n-\n-static const char * expand_file_name(\n-  const logging_input_t * logging_input,\n-  rcutils_char_array_t * logging_output)\n-{\n-  if (logging_input->location) {\n-    APPEND_AND_RETURN_LOG_OUTPUT(logging_input->location->file_name);\n-  }\n-  return logging_output->buffer;\n-}\n-\n-static const token_map_entry_t tokens[] = {\n-  {.token = \"severity\", .handler = expand_severity},\n-  {.token = \"name\", .handler = expand_name},\n-  {.token = \"message\", .handler = expand_message},\n-  {.token = \"function_name\", .handler = expand_function_name},\n-  {.token = \"file_name\", .handler = expand_file_name},\n-  {.token = \"time\", .handler = expand_time_as_seconds},\n-  {.token = \"time_as_nanoseconds\", .handler = expand_time_as_nanoseconds},\n-  {.token = \"line_number\", .handler = expand_line_number},\n-};\n-\n-static token_handler find_token_handler(const char * token)\n-{\n-  int token_number = sizeof(tokens) / sizeof(tokens[0]);\n-  for (int token_index = 0; token_index < token_number; token_index++) {\n-    if (strcmp(token, tokens[token_index].token) == 0) {\n-      return tokens[token_index].handler;\n-    }\n-  }\n-  return NULL;\n-}\n-"},{"role":"user","content":"-  rcutils_ret_t status = RCUTILS_RET_OK;\n-  // Process the format string looking for known tokens.\n-  const char token_start_delimiter = '{';\n-  const char token_end_delimiter = '}';\n-\n-  const char * str = g_rcutils_logging_output_format_string;\n-  size_t size = strlen(g_rcutils_logging_output_format_string);\n-"},{"role":"user","content":"-  // Walk through the format string and expand tokens when they're encountered.\n-  size_t i = 0;\n-  while (i < size) {\n-    // Print everything up to the next token start delimiter.\n-    size_t chars_to_start_delim = rcutils_find(str + i, token_start_delimiter);\n-    size_t remaining_chars = size - i;\n-\n-    if (chars_to_start_delim > 0) {  // there are stuff before a token start delimiter\n-      size_t chars_to_copy = chars_to_start_delim >\n-        remaining_chars ? remaining_chars : chars_to_start_delim;\n-      status = rcutils_char_array_strncat(logging_output, str + i, chars_to_copy);\n-      OK_OR_RETURN_EARLY(status);\n-      i += chars_to_copy;\n-      if (i >= size) {  // perhaps no start delimiter was found\n-        break;\n-      }\n-    }\n-\n-    // We are at a token start delimiter: determine if there's a known token or not.\n-    // Potential tokens can't possibly be longer than the format string itself.\n-    char token[RCUTILS_LOGGING_MAX_OUTPUT_FORMAT_LEN];\n-\n-    // Look for a token end delimiter.\n-    size_t chars_to_end_delim = rcutils_find(str + i, token_end_delimiter);\n-    remaining_chars = size - i;\n-\n-    if (chars_to_end_delim > remaining_chars) {\n-      // No end delimiters found in the remainder of the format string;\n-      // there won't be any more tokens so shortcut the rest of the checking.\n-      status = rcutils_char_array_strncat(logging_output, str + i, remaining_chars);\n-      OK_OR_RETURN_EARLY(status);\n-      break;\n-    }\n-\n-    // Found what looks like a token; determine if it's recognized.\n-    size_t token_len = chars_to_end_delim - 1;  // Not including delimiters.\n-    memcpy(token, str + i + 1, token_len);  // Skip the start delimiter.\n-    token[token_len] = '\\0';\n-\n-    token_handler expand_token = find_token_handler(token);\n-\n-    if (!expand_token) {\n-      // This wasn't a token; print the start delimiter and continue the search as usual\n-      // (the substring might contain more start delimiters).\n-      status = rcutils_char_array_strncat(logging_output, str + i, 1);\n-      OK_OR_RETURN_EARLY(status);\n-      i++;\n-      continue;\n-    }\n-\n-    if (!expand_token(&logging_input, logging_output)) {\n+  for (size_t i = 0; i < g_num_log_msg_handlers; ++i) {\n+    if (g_handlers[i].handler(\n+        &logging_input, logging_output,\n+        g_handlers[i].start_offset, g_handlers[i].end_offset) == NULL)\n+    {"},{"role":"user","content":"-    // Skip ahead to avoid re-processing the token characters (including the 2 delimiters).\n-    i += token_len + 2;"},{"role":"user","content":"-  return status;\n+  return RCUTILS_RET_OK;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+\n+if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n+  target_link_libraries(_rclpy_pybind11 PRIVATE atomic)\n+endif()\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/rclcpp/create_generic_client.cpp"},{"role":"user","content":"+  src/rclcpp/generic_client.cpp"},{"role":"user","content":"+\n+template<typename PendingRequestsT, typename AllocatorT = std::allocator<int64_t>>\n+size_t\n+prune_requests_older_than_impl(\n+  PendingRequestsT & pending_requests,\n+  std::mutex & pending_requests_mutex,\n+  std::chrono::time_point<std::chrono::system_clock> time_point,\n+  std::vector<int64_t, AllocatorT> * pruned_requests = nullptr)\n+{\n+  std::lock_guard guard(pending_requests_mutex);\n+  auto old_size = pending_requests.size();\n+  for (auto it = pending_requests.begin(), last = pending_requests.end(); it != last; ) {\n+    if (it->second.first < time_point) {\n+      if (pruned_requests) {\n+        pruned_requests->push_back(it->first);\n+      }\n+      it = pending_requests.erase(it);\n+    } else {\n+      ++it;\n+    }\n+  }\n+  return old_size - pending_requests.size();\n+}"},{"role":"user","content":"-    std::lock_guard guard(pending_requests_mutex_);\n-    auto old_size = pending_requests_.size();\n-    for (auto it = pending_requests_.begin(), last = pending_requests_.end(); it != last; ) {\n-      if (it->second.first < time_point) {\n-        if (pruned_requests) {\n-          pruned_requests->push_back(it->first);\n-        }\n-        it = pending_requests_.erase(it);\n-      } else {\n-        ++it;\n-      }\n-    }\n-    return old_size - pending_requests_.size();\n+    return detail::prune_requests_older_than_impl(\n+      pending_requests_,\n+      pending_requests_mutex_,\n+      time_point,\n+      pruned_requests);"},{"role":"user","content":"+// Copyright 2023 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__CREATE_GENERIC_CLIENT_HPP_\n+#define RCLCPP__CREATE_GENERIC_CLIENT_HPP_\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rclcpp/generic_client.hpp\"\n+#include \"rclcpp/node_interfaces/get_node_base_interface.hpp\"\n+#include \"rclcpp/node_interfaces/get_node_graph_interface.hpp\"\n+#include \"rclcpp/node_interfaces/get_node_services_interface.hpp\"\n+#include \"rclcpp/node_interfaces/node_base_interface.hpp\"\n+#include \"rclcpp/node_interfaces/node_graph_interface.hpp\"\n+#include \"rclcpp/node_interfaces/node_services_interface.hpp\"\n+#include \"rclcpp/qos.hpp\"\n+\n+namespace rclcpp\n+{\n+/// Create a generic service client with a name of given type.\n+/**\n+ * \\param[in] node_base NodeBaseInterface implementation of the node on which\n+ *  to create the client.\n+ * \\param[in] node_graph NodeGraphInterface implementation of the node on which\n+ *  to create the client.\n+ * \\param[in] node_services NodeServicesInterface implementation of the node on\n+ *  which to create the client.\n+ * \\param[in] service_name The name on which the service is accessible.\n+ * \\param[in] service_type The name of service type, e.g. \"test_msgs/srv/BasicTypes\"\n+ * \\param[in] qos Quality of service profile for client.\n+ * \\param[in] group Callback group to handle the reply to service calls.\n+ * \\return Shared pointer to the created client.\n+ */\n+RCLCPP_PUBLIC\n+rclcpp::GenericClient::SharedPtr\n+create_generic_client(\n+  std::shared_ptr<node_interfaces::NodeBaseInterface> node_base,\n+  std::shared_ptr<node_interfaces::NodeGraphInterface> node_graph,\n+  std::shared_ptr<node_interfaces::NodeServicesInterface> node_services,\n+  const std::string & service_name,\n+  const std::string & service_type,\n+  const rclcpp::QoS & qos = rclcpp::ServicesQoS(),\n+  rclcpp::CallbackGroup::SharedPtr group = nullptr);\n+\n+/// Create a generic service client with a name of given type.\n+/**\n+ * The NodeT type needs to have NodeBaseInterface implementation, NodeGraphInterface implementation\n+ * and NodeServicesInterface implementation of the node which to create the client.\n+ *\n+ * \\param[in] node The node on which to create the client.\n+ * \\param[in] service_name The name on which the service is accessible.\n+ * \\param[in] service_type The name of service type, e.g. \"test_msgs/srv/BasicTypes\"\n+ * \\param[in] qos Quality of service profile for client.\n+ * \\param[in] group Callback group to handle the reply to service calls.\n+ * \\return Shared pointer to the created client.\n+ */\n+template<typename NodeT>\n+rclcpp::GenericClient::SharedPtr\n+create_generic_client(\n+  NodeT node,\n+  const std::string & service_name,\n+  const std::string & service_type,\n+  const rclcpp::QoS & qos = rclcpp::ServicesQoS(),\n+  rclcpp::CallbackGroup::SharedPtr group = nullptr)\n+{\n+  return create_generic_client(\n+    rclcpp::node_interfaces::get_node_base_interface(node),\n+    rclcpp::node_interfaces::get_node_graph_interface(node),\n+    rclcpp::node_interfaces::get_node_services_interface(node),\n+    service_name,\n+    service_type,\n+    qos,\n+    group\n+  );\n+}\n+}  // namespace rclcpp\n+\n+#endif  // RCLCPP__CREATE_GENERIC_CLIENT_HPP_"},{"role":"user","content":"+// Copyright 2023 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef RCLCPP__GENERIC_CLIENT_HPP_\n+#define RCLCPP__GENERIC_CLIENT_HPP_\n+\n+#include <map>\n+#include <memory>\n+#include <future>\n+#include <string>\n+#include <vector>\n+#include <utility>\n+\n+#include \"rcl/client.h\"\n+\n+#include \"rclcpp/client.hpp\"\n+#include \"rclcpp/visibility_control.hpp\"\n+#include \"rcpputils/shared_library.hpp\"\n+\n+#include \"rosidl_typesupport_introspection_cpp/message_introspection.hpp\"\n+\n+namespace rclcpp\n+{\n+class GenericClient : public ClientBase\n+{\n+public:\n+  using Request = void *;   // Serialized data pointer of request message\n+  using Response = void *;  // Serialized data pointer of response message\n+\n+  using SharedResponse = std::shared_ptr<void>;\n+\n+  using Promise = std::promise<SharedResponse>;\n+  using SharedPromise = std::shared_ptr<Promise>;\n+\n+  using Future = std::future<SharedResponse>;\n+  using SharedFuture = std::shared_future<SharedResponse>;\n+\n+  RCLCPP_SMART_PTR_DEFINITIONS(GenericClient)\n+\n+  /// A convenient GenericClient::Future and request id pair.\n+  /**\n+   * Public members:\n+   * - future: a std::future<void *>.\n+   * - request_id: the request id associated with the future.\n+   *\n+   * All the other methods are equivalent to the ones std::future provides.\n+   */\n+  struct FutureAndRequestId\n+    : detail::FutureAndRequestId<Future>\n+  {\n+    using detail::FutureAndRequestId<Future>::FutureAndRequestId;\n+\n+    /// See std::future::share().\n+    SharedFuture share() noexcept {return this->future.share();}\n+\n+    /// Move constructor.\n+    FutureAndRequestId(FutureAndRequestId && other) noexcept = default;\n+    /// Deleted copy constructor, each instance is a unique owner of the future.\n+    FutureAndRequestId(const FutureAndRequestId & other) = delete;\n+    /// Move assignment.\n+    FutureAndRequestId & operator=(FutureAndRequestId && other) noexcept = default;\n+    /// Deleted copy assignment, each instance is a unique owner of the future.\n+    FutureAndRequestId & operator=(const FutureAndRequestId & other) = delete;\n+    /// Destructor.\n+    ~FutureAndRequestId() = default;\n+  };\n+\n+  GenericClient(\n+    rclcpp::node_interfaces::NodeBaseInterface * node_base,\n+    rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,\n+    const std::string & service_name,\n+    const std::string & service_type,\n+    rcl_client_options_t & client_options);\n+\n+  RCLCPP_PUBLIC\n+  SharedResponse\n+  create_response() override;\n+\n+  RCLCPP_PUBLIC\n+  std::shared_ptr<rmw_request_id_t>\n+  create_request_header() override;\n+\n+  RCLCPP_PUBLIC\n+  void\n+  handle_response(\n+    std::shared_ptr<rmw_request_id_t> request_header,\n+    std::shared_ptr<void> response) override;\n+\n+  /// Send a request to the service server.\n+  /**\n+   * This method returns a `FutureAndRequestId` instance\n+   * that can be passed to Executor::spin_until_future_complete() to\n+   * wait until it has been completed.\n+   *\n+   * If the future never completes,\n+   * e.g. the call to Executor::spin_until_future_complete() times out,\n+   * GenericClient::remove_pending_request() must be called to clean the client internal state.\n+   * Not doing so will make the `Client` instance to use more memory each time a response is not\n+   * received from the service server.\n+   *\n+   * ```cpp\n+   * auto future = client->async_send_request(my_request);\n+   * if (\n+   *   rclcpp::FutureReturnCode::TIMEOUT ==\n+   *   executor->spin_until_future_complete(future, timeout))\n+   * {\n+   *   client->remove_pending_request(future);\n+   *   // handle timeout\n+   * } else {\n+   *   handle_response(future.get());\n+   * }\n+   * ```\n+   *\n+   * \\param[in] request request to be send.\n+   * \\return a FutureAndRequestId instance.\n+   */\n+  RCLCPP_PUBLIC\n+  FutureAndRequestId\n+  async_send_request(const Request request);\n+\n+  /// Clean all pending requests older than a time_point.\n+  /**\n+   * \\param[in] time_point Requests that were sent before this point are going to be removed.\n+   * \\param[inout] pruned_requests Removed requests id will be pushed to the vector\n+   *  if a pointer is provided.\n+   * \\return number of pending requests that were removed.\n+   */\n+  template<typename AllocatorT = std::allocator<int64_t>>\n+  size_t\n+  prune_requests_older_than(\n+    std::chrono::time_point<std::chrono::system_clock> time_point,\n+    std::vector<int64_t, AllocatorT> * pruned_requests = nullptr)\n+  {\n+    return detail::prune_requests_older_than_impl(\n+      pending_requests_,\n+      pending_requests_mutex_,\n+      time_point,\n+      pruned_requests);\n+  }\n+\n+  RCLCPP_PUBLIC\n+  size_t\n+  prune_pending_requests();\n+\n+  RCLCPP_PUBLIC\n+  bool\n+  remove_pending_request(\n+    int64_t request_id);\n+\n+  /// Take the next response for this client.\n+  /**\n+   * \\sa ClientBase::take_type_erased_response().\n+   *\n+   * \\param[out] response_out The reference to a Service Response into\n+   *   which the middleware will copy the response being taken.\n+   * \\param[out] request_header_out The request header to be filled by the\n+   *   middleware when taking, and which can be used to associate the response\n+   *   to a specific request.\n+   * \\returns true if the response was taken, otherwise false.\n+   * \\throws rclcpp::exceptions::RCLError based exceptions if the underlying\n+   *   rcl function fail.\n+   */\n+  RCLCPP_PUBLIC\n+  bool\n+  take_response(Response response_out, rmw_request_id_t & request_header_out)\n+  {\n+    return this->take_type_erased_response(response_out, request_header_out);\n+  }\n+\n+protected:\n+  using CallbackInfoVariant = std::variant<\n+    std::promise<SharedResponse>>;  // Use variant for extension\n+\n+  int64_t\n+  async_send_request_impl(\n+    const Request request,\n+    CallbackInfoVariant value);\n+\n+  std::optional<CallbackInfoVariant>\n+  get_and_erase_pending_request(\n+    int64_t request_number);\n+\n+  RCLCPP_DISABLE_COPY(GenericClient)\n+\n+  std::map<int64_t, std::pair<\n+      std::chrono::time_point<std::chrono::system_clock>,\n+      CallbackInfoVariant>> pending_requests_;\n+  std::mutex pending_requests_mutex_;\n+\n+private:\n+  std::shared_ptr<rcpputils::SharedLibrary> ts_lib_;\n+  const rosidl_typesupport_introspection_cpp::MessageMembers * response_members_;\n+};\n+}  // namespace rclcpp\n+\n+#endif  // RCLCPP__GENERIC_CLIENT_HPP_"},{"role":"user","content":"+#include \"rclcpp/generic_client.hpp\""},{"role":"user","content":"+  /// Create and return a GenericClient.\n+  /**\n+   * \\param[in] service_name The name on which the service is accessible.\n+   * \\param[in] service_type The name of service type, e.g. \"std_srvs/srv/SetBool\"\n+   * \\param[in] qos Quality of service profile for client.\n+   * \\param[in] group Callback group to handle the reply to service calls.\n+   * \\return Shared pointer to the created GenericClient.\n+   */\n+  RCLCPP_PUBLIC\n+  rclcpp::GenericClient::SharedPtr\n+  create_generic_client(\n+    const std::string & service_name,\n+    const std::string & service_type,\n+    const rclcpp::QoS & qos = rclcpp::ServicesQoS(),\n+    rclcpp::CallbackGroup::SharedPtr group = nullptr);\n+"},{"role":"user","content":"+// Copyright 2023 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"rclcpp/create_generic_client.hpp\"\n+#include \"rclcpp/generic_client.hpp\"\n+\n+namespace rclcpp\n+{\n+rclcpp::GenericClient::SharedPtr\n+create_generic_client(\n+  std::shared_ptr<node_interfaces::NodeBaseInterface> node_base,\n+  std::shared_ptr<node_interfaces::NodeGraphInterface> node_graph,\n+  std::shared_ptr<node_interfaces::NodeServicesInterface> node_services,\n+  const std::string & service_name,\n+  const std::string & service_type,\n+  const rclcpp::QoS & qos,\n+  rclcpp::CallbackGroup::SharedPtr group)\n+{\n+  rcl_client_options_t options = rcl_client_get_default_options();\n+  options.qos = qos.get_rmw_qos_profile();\n+\n+  auto cli = rclcpp::GenericClient::make_shared(\n+    node_base.get(),\n+    node_graph,\n+    service_name,\n+    service_type,\n+    options);\n+\n+  auto cli_base_ptr = std::dynamic_pointer_cast<rclcpp::ClientBase>(cli);\n+  node_services->add_client(cli_base_ptr, group);\n+  return cli;\n+}\n+}  // namespace rclcpp"},{"role":"user","content":"+// Copyright 2023 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <future>\n+\n+#include \"rclcpp/generic_client.hpp\"\n+#include \"rclcpp/typesupport_helpers.hpp\"\n+\n+#include \"rosidl_runtime_c/service_type_support_struct.h\"\n+#include \"rosidl_typesupport_introspection_cpp/identifier.hpp\"\n+#include \"rosidl_typesupport_introspection_cpp/service_introspection.hpp\"\n+\n+namespace rclcpp\n+{\n+GenericClient::GenericClient(\n+  rclcpp::node_interfaces::NodeBaseInterface * node_base,\n+  rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,\n+  const std::string & service_name,\n+  const std::string & service_type,\n+  rcl_client_options_t & client_options)\n+: ClientBase(node_base, node_graph)\n+{\n+  ts_lib_ = get_typesupport_library(\n+    service_type, \"rosidl_typesupport_cpp\");\n+\n+  auto service_ts_ = get_service_typesupport_handle(\n+    service_type, \"rosidl_typesupport_cpp\", *ts_lib_);\n+\n+  auto response_type_support_intro = get_message_typesupport_handle(\n+    service_ts_->response_typesupport,\n+    rosidl_typesupport_introspection_cpp::typesupport_identifier);\n+  response_members_ = static_cast<const rosidl_typesupport_introspection_cpp::MessageMembers *>(\n+    response_type_support_intro->data);\n+\n+  rcl_ret_t ret = rcl_client_init(\n+    this->get_client_handle().get(),\n+    this->get_rcl_node_handle(),\n+    service_ts_,\n+    service_name.c_str(),\n+    &client_options);\n+  if (ret != RCL_RET_OK) {\n+    if (ret == RCL_RET_SERVICE_NAME_INVALID) {\n+      auto rcl_node_handle = this->get_rcl_node_handle();\n+      // this will throw on any validation problem\n+      rcl_reset_error();\n+      expand_topic_or_service_name(\n+        service_name,\n+        rcl_node_get_name(rcl_node_handle),\n+        rcl_node_get_namespace(rcl_node_handle),\n+        true);\n+    }\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"could not create generic client\");\n+  }\n+}\n+\n+std::shared_ptr<void>\n+GenericClient::create_response()\n+{\n+  void * response = new uint8_t[response_members_->size_of_];\n+  response_members_->init_function(response, rosidl_runtime_cpp::MessageInitialization::ZERO);\n+  return std::shared_ptr<void>(\n+    response,\n+    [this](void * p)\n+    {\n+      response_members_->fini_function(p);\n+      delete[] reinterpret_cast<uint8_t *>(p);\n+    });\n+}\n+\n+std::shared_ptr<rmw_request_id_t>\n+GenericClient::create_request_header()\n+{\n+  // TODO(wjwwood): This should probably use rmw_request_id's allocator.\n+  //                (since it is a C type)\n+  return std::shared_ptr<rmw_request_id_t>(new rmw_request_id_t);\n+}\n+\n+void\n+GenericClient::handle_response(\n+  std::shared_ptr<rmw_request_id_t> request_header,\n+  std::shared_ptr<void> response)\n+{\n+  auto optional_pending_request =\n+    this->get_and_erase_pending_request(request_header->sequence_number);\n+  if (!optional_pending_request) {\n+    return;\n+  }\n+  auto & value = *optional_pending_request;\n+  if (std::holds_alternative<Promise>(value)) {\n+    auto & promise = std::get<Promise>(value);\n+    promise.set_value(std::move(response));\n+  }\n+}\n+\n+size_t\n+GenericClient::prune_pending_requests()\n+{\n+  std::lock_guard guard(pending_requests_mutex_);\n+  auto ret = pending_requests_.size();\n+  pending_requests_.clear();\n+  return ret;\n+}\n+\n+bool\n+GenericClient::remove_pending_request(int64_t request_id)\n+{\n+  std::lock_guard guard(pending_requests_mutex_);\n+  return pending_requests_.erase(request_id) != 0u;\n+}\n+\n+std::optional<GenericClient::CallbackInfoVariant>\n+GenericClient::get_and_erase_pending_request(int64_t request_number)\n+{\n+  std::unique_lock<std::mutex> lock(pending_requests_mutex_);\n+  auto it = pending_requests_.find(request_number);\n+  if (it == pending_requests_.end()) {\n+    RCUTILS_LOG_DEBUG_NAMED(\n+      \"rclcpp\",\n+      \"Received invalid sequence number. Ignoring...\");\n+    return std::nullopt;\n+  }\n+  auto value = std::move(it->second.second);\n+  pending_requests_.erase(request_number);\n+  return value;\n+}\n+\n+GenericClient::FutureAndRequestId\n+GenericClient::async_send_request(const Request request)\n+{\n+  Promise promise;\n+  auto future = promise.get_future();\n+  auto req_id = async_send_request_impl(\n+    request,\n+    std::move(promise));\n+  return FutureAndRequestId(std::move(future), req_id);\n+}\n+\n+int64_t\n+GenericClient::async_send_request_impl(const Request request, CallbackInfoVariant value)\n+{\n+  int64_t sequence_number;\n+  std::lock_guard<std::mutex> lock(pending_requests_mutex_);\n+  rcl_ret_t ret = rcl_send_request(get_client_handle().get(), request, &sequence_number);\n+  if (RCL_RET_OK != ret) {\n+    rclcpp::exceptions::throw_from_rcl_error(ret, \"failed to send request\");\n+  }\n+  pending_requests_.try_emplace(\n+    sequence_number,\n+    std::make_pair(std::chrono::system_clock::now(), std::move(value)));\n+  return sequence_number;\n+}\n+\n+}  // namespace rclcpp"},{"role":"user","content":"+#include \"rclcpp/create_generic_client.hpp\""},{"role":"user","content":"+\n+rclcpp::GenericClient::SharedPtr\n+Node::create_generic_client(\n+  const std::string & service_name,\n+  const std::string & service_type,\n+  const rclcpp::QoS & qos,\n+  rclcpp::CallbackGroup::SharedPtr group)\n+{\n+  return rclcpp::create_generic_client(\n+    node_base_,\n+    node_graph_,\n+    node_services_,\n+    service_name,\n+    service_type,\n+    qos,\n+    group);\n+}"},{"role":"user","content":"+ament_add_gtest(test_generic_client test_generic_client.cpp)\n+if(TARGET test_generic_client)\n+  target_link_libraries(test_generic_client ${PROJECT_NAME}\n+    mimick\n+    ${rcl_interfaces_TARGETS}\n+    rmw::rmw\n+    rosidl_runtime_cpp::rosidl_runtime_cpp\n+    rosidl_typesupport_cpp::rosidl_typesupport_cpp\n+    ${test_msgs_TARGETS}\n+  )\n+endif()\n+ament_add_gtest(test_client_common test_client_common.cpp)\n+if(TARGET test_client_common)\n+  target_link_libraries(test_client_common ${PROJECT_NAME}\n+    mimick\n+    ${rcl_interfaces_TARGETS}\n+    rmw::rmw\n+    rosidl_runtime_cpp::rosidl_runtime_cpp\n+    rosidl_typesupport_cpp::rosidl_typesupport_cpp\n+    ${test_msgs_TARGETS}\n+  )\n+endif()"},{"role":"user","content":"-#include \"../utils/rclcpp_gtest_macros.hpp\""},{"role":"user","content":"-using namespace std::chrono_literals;\n-"},{"role":"user","content":"-\n-class TestClientWithServer : public ::testing::Test\n-{\n-protected:\n-  static void SetUpTestCase()\n-  {\n-    rclcpp::init(0, nullptr);\n-  }\n-\n-  static void TearDownTestCase()\n-  {\n-    rclcpp::shutdown();\n-  }\n-\n-  void SetUp()\n-  {\n-    node = std::make_shared<rclcpp::Node>(\"node\", \"ns\");\n-\n-    auto callback = [](\n-      const test_msgs::srv::Empty::Request::SharedPtr,\n-      test_msgs::srv::Empty::Response::SharedPtr) {};\n-\n-    service = node->create_service<test_msgs::srv::Empty>(service_name, std::move(callback));\n-  }\n-\n-  ::testing::AssertionResult SendEmptyRequestAndWait(\n-    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n-  {\n-    using SharedFuture = rclcpp::Client<test_msgs::srv::Empty>::SharedFuture;\n-\n-    auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-    if (!client->wait_for_service()) {\n-      return ::testing::AssertionFailure() << \"Waiting for service failed\";\n-    }\n-\n-    auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-    bool received_response = false;\n-    ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n-    auto callback = [&received_response, &request_result](SharedFuture future_response) {\n-        if (nullptr == future_response.get()) {\n-          request_result = ::testing::AssertionFailure() << \"Future response was null\";\n-        }\n-        received_response = true;\n-      };\n-\n-    auto req_id = client->async_send_request(request, std::move(callback));\n-\n-    auto start = std::chrono::steady_clock::now();\n-    while (!received_response &&\n-      (std::chrono::steady_clock::now() - start) < timeout)\n-    {\n-      rclcpp::spin_some(node);\n-    }\n-\n-    if (!received_response) {\n-      return ::testing::AssertionFailure() << \"Waiting for response timed out\";\n-    }\n-    if (client->remove_pending_request(req_id)) {\n-      return ::testing::AssertionFailure() << \"Should not be able to remove a finished request\";\n-    }\n-\n-    return request_result;\n-  }\n-\n-  std::shared_ptr<rclcpp::Node> node;\n-  std::shared_ptr<rclcpp::Service<test_msgs::srv::Empty>> service;\n-  const std::string service_name{\"empty_service\"};\n-};\n-\n-TEST_F(TestClientWithServer, async_send_request) {\n-  EXPECT_TRUE(SendEmptyRequestAndWait());\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_callback_with_request) {\n-  using SharedFutureWithRequest =\n-    rclcpp::Client<test_msgs::srv::Empty>::SharedFutureWithRequest;\n-\n-  auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-  ASSERT_TRUE(client->wait_for_service(std::chrono::seconds(1)));\n-\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  bool received_response = false;\n-  auto callback = [&request, &received_response](SharedFutureWithRequest future) {\n-      auto request_response_pair = future.get();\n-      EXPECT_EQ(request, request_response_pair.first);\n-      EXPECT_NE(nullptr, request_response_pair.second);\n-      received_response = true;\n-    };\n-  auto req_id = client->async_send_request(request, std::move(callback));\n-\n-  auto start = std::chrono::steady_clock::now();\n-  while (!received_response &&\n-    (std::chrono::steady_clock::now() - start) < std::chrono::seconds(1))\n-  {\n-    rclcpp::spin_some(node);\n-  }\n-  EXPECT_TRUE(received_response);\n-  EXPECT_FALSE(client->remove_pending_request(req_id));\n-}\n-\n-TEST_F(TestClientWithServer, test_client_remove_pending_request) {\n-  auto client = node->create_client<test_msgs::srv::Empty>(\"no_service_server_available_here\");\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  auto future = client->async_send_request(request);\n-\n-  EXPECT_TRUE(client->remove_pending_request(future));\n-}\n-\n-TEST_F(TestClientWithServer, prune_requests_older_than_no_pruned) {\n-  auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  auto future = client->async_send_request(request);\n-  auto time = std::chrono::system_clock::now() + 1s;\n-\n-  EXPECT_EQ(1u, client->prune_requests_older_than(time));\n-}\n-\n-TEST_F(TestClientWithServer, prune_requests_older_than_with_pruned) {\n-  auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  auto future = client->async_send_request(request);\n-  auto time = std::chrono::system_clock::now() + 1s;\n-\n-  std::vector<int64_t> pruned_requests;\n-  EXPECT_EQ(1u, client->prune_requests_older_than(time, &pruned_requests));\n-  ASSERT_EQ(1u, pruned_requests.size());\n-  EXPECT_EQ(future.request_id, pruned_requests[0]);\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_rcl_send_request_error) {\n-  // Checking rcl_send_request in rclcpp::Client::async_send_request()\n-  auto mock = mocking_utils::patch_and_return(\"lib:rclcpp\", rcl_send_request, RCL_RET_ERROR);\n-  EXPECT_THROW(SendEmptyRequestAndWait(), rclcpp::exceptions::RCLError);\n-}\n-\n-TEST_F(TestClientWithServer, async_send_request_rcl_service_server_is_available_error) {\n-  {\n-    // Checking rcl_service_server_is_available in rclcpp::ClientBase::service_is_ready\n-    auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_NODE_INVALID);\n-    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-  {\n-    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n-    auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_ERROR);\n-    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-  {\n-    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n-    auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_ERROR);\n-    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n-  }\n-}\n-\n-TEST_F(TestClientWithServer, take_response) {\n-  auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n-  ASSERT_TRUE(client->wait_for_service(std::chrono::seconds(1)));\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  auto request_header = client->create_request_header();\n-  test_msgs::srv::Empty::Response response;\n-\n-  client->async_send_request(request);\n-  EXPECT_FALSE(client->take_response(response, *request_header.get()));\n-\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_take_response, RCL_RET_OK);\n-    EXPECT_TRUE(client->take_response(response, *request_header.get()));\n-  }\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_take_response, RCL_RET_CLIENT_TAKE_FAILED);\n-    EXPECT_FALSE(client->take_response(response, *request_header.get()));\n-  }\n-  {\n-    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n-    auto mock = mocking_utils::patch_and_return(\n-      \"lib:rclcpp\", rcl_take_response, RCL_RET_ERROR);\n-    EXPECT_THROW(\n-      client->take_response(response, *request_header.get()),\n-      rclcpp::exceptions::RCLError);\n-  }\n-}\n-\n-/*\n-   Testing on_new_response callbacks.\n- */\n-TEST_F(TestClient, on_new_response_callback) {\n-  auto client_node = std::make_shared<rclcpp::Node>(\"client_node\", \"ns\");\n-  auto server_node = std::make_shared<rclcpp::Node>(\"server_node\", \"ns\");\n-\n-  rclcpp::ServicesQoS client_qos;\n-  client_qos.keep_last(3);\n-  auto client = client_node->create_client<test_msgs::srv::Empty>(\"test_service\", client_qos);\n-  std::atomic<size_t> server_requests_count {0};\n-  auto server_callback = [&server_requests_count](\n-    const test_msgs::srv::Empty::Request::SharedPtr,\n-    test_msgs::srv::Empty::Response::SharedPtr) {server_requests_count++;};\n-  auto server = server_node->create_service<test_msgs::srv::Empty>(\n-    \"test_service\", server_callback, client_qos);\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-\n-  std::atomic<size_t> c1 {0};\n-  auto increase_c1_cb = [&c1](size_t count_msgs) {c1 += count_msgs;};\n-  client->set_on_new_response_callback(increase_c1_cb);\n-\n-  client->async_send_request(request);\n-  auto start = std::chrono::steady_clock::now();\n-  while (server_requests_count == 0 &&\n-    (std::chrono::steady_clock::now() - start) < 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 1u);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c1 == 0 && std::chrono::steady_clock::now() - start < 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-\n-  std::atomic<size_t> c2 {0};\n-  auto increase_c2_cb = [&c2](size_t count_msgs) {c2 += count_msgs;};\n-  client->set_on_new_response_callback(increase_c2_cb);\n-\n-  client->async_send_request(request);\n-  start = std::chrono::steady_clock::now();\n-  while (server_requests_count == 1 &&\n-    (std::chrono::steady_clock::now() - start) < 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 2u);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c1 == 0 && std::chrono::steady_clock::now() - start < 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-  EXPECT_EQ(c2.load(), 1u);\n-\n-  client->clear_on_new_response_callback();\n-\n-  client->async_send_request(request);\n-  client->async_send_request(request);\n-  client->async_send_request(request);\n-  start = std::chrono::steady_clock::now();\n-  while (server_requests_count < 5 &&\n-    (std::chrono::steady_clock::now() - start) < 10s)\n-  {\n-    rclcpp::spin_some(server_node);\n-  }\n-\n-  ASSERT_EQ(server_requests_count, 5u);\n-\n-  std::atomic<size_t> c3 {0};\n-  auto increase_c3_cb = [&c3](size_t count_msgs) {c3 += count_msgs;};\n-  client->set_on_new_response_callback(increase_c3_cb);\n-\n-  start = std::chrono::steady_clock::now();\n-  do {\n-    std::this_thread::sleep_for(100ms);\n-  } while (c3 < 3 && std::chrono::steady_clock::now() - start < 10s);\n-\n-  EXPECT_EQ(c1.load(), 1u);\n-  EXPECT_EQ(c2.load(), 1u);\n-  EXPECT_EQ(c3.load(), 3u);\n-\n-  std::function<void(size_t)> invalid_cb = nullptr;\n-  EXPECT_THROW(client->set_on_new_response_callback(invalid_cb), std::invalid_argument);\n-}\n-\n-TEST_F(TestClient, rcl_client_request_publisher_get_actual_qos_error) {\n-  auto mock = mocking_utils::patch_and_return(\n-    \"lib:rclcpp\", rcl_client_request_publisher_get_actual_qos, nullptr);\n-  auto client = node->create_client<test_msgs::srv::Empty>(\"service\");\n-  RCLCPP_EXPECT_THROW_EQ(\n-    client->get_request_publisher_actual_qos(),\n-    std::runtime_error(\"failed to get client's request publisher qos settings: error not set\"));\n-}\n-\n-TEST_F(TestClient, rcl_client_response_subscription_get_actual_qos_error) {\n-  auto mock = mocking_utils::patch_and_return(\n-    \"lib:rclcpp\", rcl_client_response_subscription_get_actual_qos, nullptr);\n-  auto client = node->create_client<test_msgs::srv::Empty>(\"service\");\n-  RCLCPP_EXPECT_THROW_EQ(\n-    client->get_response_subscription_actual_qos(),\n-    std::runtime_error(\"failed to get client's response subscription qos settings: error not set\"));\n-}\n-\n-TEST_F(TestClient, client_qos) {\n-  rclcpp::ServicesQoS qos_profile;\n-  qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n-  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n-  qos_profile.deadline(duration);\n-  qos_profile.lifespan(duration);\n-  qos_profile.liveliness_lease_duration(duration);\n-\n-  auto client =\n-    node->create_client<test_msgs::srv::Empty>(\"client\", qos_profile);\n-\n-  auto rp_qos = client->get_request_publisher_actual_qos();\n-  auto rs_qos = client->get_response_subscription_actual_qos();\n-\n-  EXPECT_EQ(qos_profile, rp_qos);\n-  // Lifespan has no meaning for subscription/readers\n-  rs_qos.lifespan(qos_profile.lifespan());\n-  EXPECT_EQ(qos_profile, rs_qos);\n-}\n-\n-TEST_F(TestClient, client_qos_depth) {\n-  using namespace std::literals::chrono_literals;\n-\n-  rclcpp::ServicesQoS client_qos_profile;\n-  client_qos_profile.keep_last(2);\n-\n-  auto client = node->create_client<test_msgs::srv::Empty>(\"test_qos_depth\", client_qos_profile);\n-\n-  uint64_t server_cb_count_ = 0;\n-  auto server_callback = [&](\n-    const test_msgs::srv::Empty::Request::SharedPtr,\n-    test_msgs::srv::Empty::Response::SharedPtr) {server_cb_count_++;};\n-\n-  auto server_node = std::make_shared<rclcpp::Node>(\"server_node\", \"/ns\");\n-\n-  rclcpp::QoS server_qos(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));\n-\n-  auto server = server_node->create_service<test_msgs::srv::Empty>(\n-    \"test_qos_depth\", std::move(server_callback), server_qos);\n-\n-  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n-  ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n-\n-  using SharedFuture = rclcpp::Client<test_msgs::srv::Empty>::SharedFuture;\n-  uint64_t client_cb_count_ = 0;\n-  auto client_callback = [&client_cb_count_, &request_result](SharedFuture future_response) {\n-      if (nullptr == future_response.get()) {\n-        request_result = ::testing::AssertionFailure() << \"Future response was null\";\n-      }\n-      client_cb_count_++;\n-    };\n-\n-  uint64_t client_requests = 5;\n-  for (uint64_t i = 0; i < client_requests; i++) {\n-    client->async_send_request(request, client_callback);\n-    std::this_thread::sleep_for(10ms);\n-  }\n-\n-  auto start = std::chrono::steady_clock::now();\n-  while ((server_cb_count_ < client_requests) &&\n-    (std::chrono::steady_clock::now() - start) < 2s)\n-  {\n-    rclcpp::spin_some(server_node);\n-    std::this_thread::sleep_for(2ms);\n-  }\n-\n-  EXPECT_GT(server_cb_count_, client_qos_profile.depth());\n-\n-  start = std::chrono::steady_clock::now();\n-  while ((client_cb_count_ < client_qos_profile.depth()) &&\n-    (std::chrono::steady_clock::now() - start) < 1s)\n-  {\n-    rclcpp::spin_some(node);\n-  }\n-\n-  // Spin an extra time to check if client QoS depth has been ignored,\n-  // so more client callbacks might be called than expected.\n-  rclcpp::spin_some(node);\n-\n-  EXPECT_EQ(client_cb_count_, client_qos_profile.depth());\n-}"},{"role":"user","content":"+// Copyright 2024 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+#include <memory>\n+#include <utility>\n+\n+#include \"../mocking_utils/patch.hpp\"\n+#include \"../utils/rclcpp_gtest_macros.hpp\"\n+\n+#include \"rclcpp/create_generic_client.hpp\"\n+#include \"rclcpp/exceptions.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+\n+#include \"test_msgs/srv/empty.hpp\"\n+\n+template<typename T>\n+class TestAllClientTypesWithServer : public ::testing::Test\n+{\n+protected:\n+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  void SetUp()\n+  {\n+    node = std::make_shared<rclcpp::Node>(\"test_node\", \"ns\");\n+\n+    auto callback = [](\n+      const test_msgs::srv::Empty::Request::SharedPtr,\n+      test_msgs::srv::Empty::Response::SharedPtr) {};\n+\n+    service = node->create_service<test_msgs::srv::Empty>(service_name, std::move(callback));\n+  }\n+\n+  template<typename ClientType>\n+  auto SendEmptyRequestAndWait(\n+    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n+  {\n+    if constexpr (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+      return GenericClientSendEmptyRequestAndWait(timeout);\n+    } else if constexpr (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+      return ClientSendEmptyRequestAndWait(timeout);\n+    } else {\n+      return ::testing::AssertionFailure() << \"No test for this client type\";\n+    }\n+  }\n+\n+  ::testing::AssertionResult GenericClientSendEmptyRequestAndWait(\n+    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n+  {\n+    auto client = node->create_generic_client(service_name, \"test_msgs/srv/Empty\");\n+    if (!client->wait_for_service()) {\n+      return ::testing::AssertionFailure() << \"Service is not available yet\";\n+    }\n+\n+    auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+\n+    auto future_and_req_id = client->async_send_request(request.get());\n+\n+    auto ret = rclcpp::spin_until_future_complete(node, future_and_req_id, timeout);\n+    if (ret != rclcpp::FutureReturnCode::SUCCESS) {\n+      return ::testing::AssertionFailure() << \"Waiting for response timed out\";\n+    }\n+\n+    if (client->remove_pending_request(future_and_req_id.request_id)) {\n+      return ::testing::AssertionFailure() << \"Should not be able to remove a finished request\";\n+    }\n+\n+    return ::testing::AssertionSuccess();\n+  }\n+\n+  ::testing::AssertionResult ClientSendEmptyRequestAndWait(\n+    std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))\n+  {\n+    using SharedFuture = rclcpp::Client<test_msgs::srv::Empty>::SharedFuture;\n+\n+    auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n+    if (!client->wait_for_service()) {\n+      return ::testing::AssertionFailure() << \"Waiting for service failed\";\n+    }\n+\n+    auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+    bool received_response = false;\n+    ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n+    auto callback = [&received_response, &request_result](SharedFuture future_response) {\n+        if (nullptr == future_response.get()) {\n+          request_result = ::testing::AssertionFailure() << \"Future response was null\";\n+        }\n+        received_response = true;\n+      };\n+\n+    auto req_id = client->async_send_request(request, std::move(callback));\n+\n+    auto start = std::chrono::steady_clock::now();\n+    while (!received_response &&\n+      (std::chrono::steady_clock::now() - start) < timeout)\n+    {\n+      rclcpp::spin_some(node);\n+    }\n+\n+    if (!received_response) {\n+      return ::testing::AssertionFailure() << \"Waiting for response timed out\";\n+    }\n+    if (client->remove_pending_request(req_id)) {\n+      return ::testing::AssertionFailure() << \"Should not be able to remove a finished request\";\n+    }\n+\n+    return request_result;\n+  }\n+\n+  template<typename ClientType>\n+  auto create_client(\n+    rclcpp::Node::SharedPtr node,\n+    const std::string service_name = \"empty_service\",\n+    const rclcpp::QoS & qos = rclcpp::ServicesQoS())\n+  {\n+    if constexpr (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+      return node->create_generic_client(service_name, \"test_msgs/srv/Empty\", qos);\n+    } else if constexpr (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+      return node->template create_client<test_msgs::srv::Empty>(service_name, qos);\n+    } else {\n+      ASSERT_TRUE(false) << \"Not know how to create this kind of client\";\n+    }\n+  }\n+\n+  template<typename ClientType, typename RequestType>\n+  auto async_send_request(std::shared_ptr<ClientType> client, std::shared_ptr<RequestType> request)\n+  {\n+    if constexpr (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+      return client->async_send_request(request.get());\n+    } else if constexpr (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+      return client->async_send_request(request);\n+    } else {\n+      ASSERT_TRUE(false) << \"Not know how to send request for this kind of client\";\n+    }\n+  }\n+\n+  template<typename ClientType, typename ResponseType>\n+  auto take_response(\n+    std::shared_ptr<ClientType> client,\n+    ResponseType & response,\n+    std::shared_ptr<rmw_request_id_t> request_header)\n+  {\n+    if constexpr (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+      return client->take_response(static_cast<void *>(&response), *request_header.get());\n+    } else if constexpr (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+      return client->take_response(response, *request_header.get());\n+    } else {\n+      ASSERT_TRUE(false) << \"Not know how to take response for this kind of client\";\n+    }\n+  }\n+\n+  std::shared_ptr<rclcpp::Node> node;\n+  std::shared_ptr<rclcpp::Service<test_msgs::srv::Empty>> service;\n+  const std::string service_name{\"empty_service\"};\n+};\n+\n+using ClientType =\n+  ::testing::Types<\n+  rclcpp::Client<test_msgs::srv::Empty>,\n+  rclcpp::GenericClient>;\n+\n+class ClientTypeNames\n+{\n+public:\n+  template<typename T>\n+  static std::string GetName(int idx)\n+  {\n+    (void)idx;\n+    if (std::is_same_v<T, rclcpp::Client<test_msgs::srv::Empty>>) {\n+      return \"Client\";\n+    }\n+\n+    if (std::is_same_v<T, rclcpp::GenericClient>) {\n+      return \"GenericClient\";\n+    }\n+\n+    return \"\";\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestAllClientTypesWithServer, ClientType, ClientTypeNames);\n+\n+TYPED_TEST(TestAllClientTypesWithServer, async_send_request)\n+{\n+  using ClientType = TypeParam;\n+  EXPECT_TRUE(this->template SendEmptyRequestAndWait<ClientType>());\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, test_client_remove_pending_request)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto client = this->template create_client<ClientType>(this->node);\n+\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+\n+  auto future_and_req_id = this->template async_send_request<\n+    ClientType, test_msgs::srv::Empty::Request>(client, request);\n+\n+  EXPECT_TRUE(client->remove_pending_request(future_and_req_id.request_id));\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, prune_requests_older_than_no_pruned)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto client = this->template create_client<ClientType>(this->node);\n+\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+\n+  auto future = this->template async_send_request<\n+    ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  auto time = std::chrono::system_clock::now() + std::chrono::seconds(1);\n+\n+  EXPECT_EQ(1u, client->prune_requests_older_than(time));\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, prune_requests_older_than_with_pruned)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto client = this->template create_client<ClientType>(this->node);\n+\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+\n+  auto future = this->template async_send_request<\n+    ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  auto time = std::chrono::system_clock::now() + std::chrono::seconds(1);\n+\n+  std::vector<int64_t> pruned_requests;\n+  EXPECT_EQ(1u, client->prune_requests_older_than(time, &pruned_requests));\n+  ASSERT_EQ(1u, pruned_requests.size());\n+  EXPECT_EQ(future.request_id, pruned_requests[0]);\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, async_send_request_rcl_send_request_error)\n+{\n+  using ClientType = TypeParam;\n+\n+  // Checking rcl_send_request in rclcpp::Client::async_send_request() or\n+  // rclcpp::GenericClient::async_send_request()\n+  auto mock = mocking_utils::patch_and_return(\"lib:rclcpp\", rcl_send_request, RCL_RET_ERROR);\n+  EXPECT_THROW(this->template SendEmptyRequestAndWait<ClientType>(), rclcpp::exceptions::RCLError);\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, async_send_request_rcl_service_server_is_available_error)\n+{\n+  using ClientType = TypeParam;\n+\n+  {\n+    // Checking rcl_service_server_is_available in rclcpp::ClientBase::service_is_ready\n+    auto client = this->template create_client<ClientType>(this->node);\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_NODE_INVALID);\n+    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n+  }\n+  {\n+    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n+    auto client = this->template create_client<ClientType>(this->node);\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_ERROR);\n+    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n+  }\n+  {\n+    // Checking rcl_service_server_is_available exception in rclcpp::ClientBase::service_is_ready\n+    auto client = this->template create_client<ClientType>(this->node);\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_service_server_is_available, RCL_RET_ERROR);\n+    EXPECT_THROW(client->service_is_ready(), rclcpp::exceptions::RCLError);\n+  }\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, take_response)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto client = this->template create_client<ClientType>(this->node);\n+  ASSERT_TRUE(client->wait_for_service(std::chrono::seconds(1)));\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+  auto request_header = client->create_request_header();\n+  test_msgs::srv::Empty::Response response;\n+\n+  this->template async_send_request<\n+    ClientType, test_msgs::srv::Empty::Request>(client, request);\n+\n+  EXPECT_FALSE(this->take_response(client, response, request_header));\n+\n+  {\n+    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_take_response, RCL_RET_OK);\n+    EXPECT_TRUE(this->take_response(client, response, request_header));\n+  }\n+  {\n+    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_take_response, RCL_RET_CLIENT_TAKE_FAILED);\n+    EXPECT_FALSE(this->take_response(client, response, request_header));\n+  }\n+  {\n+    // Checking rcl_take_response in rclcpp::ClientBase::take_type_erased_response\n+    auto mock = mocking_utils::patch_and_return(\n+      \"lib:rclcpp\", rcl_take_response, RCL_RET_ERROR);\n+    EXPECT_THROW(\n+      this->take_response(client, response, request_header),\n+      rclcpp::exceptions::RCLError);\n+  }\n+}\n+\n+/*\n+   Testing on_new_response callbacks.\n+ */\n+TYPED_TEST(TestAllClientTypesWithServer, on_new_response_callback)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto client_node = std::make_shared<rclcpp::Node>(\"test_client_node\", \"ns\");\n+  auto server_node = std::make_shared<rclcpp::Node>(\"test_server_node\", \"ns\");\n+\n+  rclcpp::ServicesQoS client_qos;\n+  client_qos.keep_last(3);\n+\n+  auto client = this->template create_client<ClientType>(client_node, \"test_service\", client_qos);\n+\n+  std::atomic<size_t> server_requests_count {0};\n+  auto server_callback = [&server_requests_count](\n+    const test_msgs::srv::Empty::Request::SharedPtr,\n+    test_msgs::srv::Empty::Response::SharedPtr) {server_requests_count++;};\n+  auto server = server_node->create_service<test_msgs::srv::Empty>(\n+    \"test_service\", server_callback, client_qos);\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+\n+  std::atomic<size_t> c1 {0};\n+  auto increase_c1_cb = [&c1](size_t count_msgs) {c1 += count_msgs;};\n+  client->set_on_new_response_callback(increase_c1_cb);\n+\n+  this->template async_send_request<ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  auto start = std::chrono::steady_clock::now();\n+  while (server_requests_count == 0 &&\n+    (std::chrono::steady_clock::now() - start) < std::chrono::seconds(10))\n+  {\n+    rclcpp::spin_some(server_node);\n+  }\n+\n+  ASSERT_EQ(server_requests_count, 1u);\n+\n+  start = std::chrono::steady_clock::now();\n+  do {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+  } while (c1 == 0 && std::chrono::steady_clock::now() - start < std::chrono::seconds(10));\n+\n+  EXPECT_EQ(c1.load(), 1u);\n+\n+  std::atomic<size_t> c2 {0};\n+  auto increase_c2_cb = [&c2](size_t count_msgs) {c2 += count_msgs;};\n+  client->set_on_new_response_callback(increase_c2_cb);\n+\n+  this->template async_send_request<ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  start = std::chrono::steady_clock::now();\n+  while (server_requests_count == 1 &&\n+    (std::chrono::steady_clock::now() - start) < std::chrono::seconds(10))\n+  {\n+    rclcpp::spin_some(server_node);\n+  }\n+\n+  ASSERT_EQ(server_requests_count, 2u);\n+\n+  start = std::chrono::steady_clock::now();\n+  do {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+  } while (c1 == 0 && std::chrono::steady_clock::now() - start < std::chrono::seconds(10));\n+\n+  EXPECT_EQ(c1.load(), 1u);\n+  EXPECT_EQ(c2.load(), 1u);\n+\n+  client->clear_on_new_response_callback();\n+\n+  this->template async_send_request<ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  this->template async_send_request<ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  this->template async_send_request<ClientType, test_msgs::srv::Empty::Request>(client, request);\n+  start = std::chrono::steady_clock::now();\n+  while (server_requests_count < 5 &&\n+    (std::chrono::steady_clock::now() - start) < std::chrono::seconds(10))\n+  {\n+    rclcpp::spin_some(server_node);\n+  }\n+\n+  ASSERT_EQ(server_requests_count, 5u);\n+\n+  std::atomic<size_t> c3 {0};\n+  auto increase_c3_cb = [&c3](size_t count_msgs) {c3 += count_msgs;};\n+  client->set_on_new_response_callback(increase_c3_cb);\n+\n+  start = std::chrono::steady_clock::now();\n+  do {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+  } while (c3 < 3 && std::chrono::steady_clock::now() - start < std::chrono::seconds(10));\n+\n+  EXPECT_EQ(c1.load(), 1u);\n+  EXPECT_EQ(c2.load(), 1u);\n+  EXPECT_EQ(c3.load(), 3u);\n+\n+  std::function<void(size_t)> invalid_cb = nullptr;\n+  EXPECT_THROW(client->set_on_new_response_callback(invalid_cb), std::invalid_argument);\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, client_qos)\n+{\n+  using ClientType = TypeParam;\n+\n+  rclcpp::ServicesQoS qos_profile;\n+  qos_profile.liveliness(rclcpp::LivelinessPolicy::Automatic);\n+  rclcpp::Duration duration(std::chrono::nanoseconds(1));\n+  qos_profile.deadline(duration);\n+  qos_profile.lifespan(duration);\n+  qos_profile.liveliness_lease_duration(duration);\n+\n+  auto client = this->template create_client<ClientType>(\n+    this->node, this->service_name, qos_profile);\n+\n+  auto rp_qos = client->get_request_publisher_actual_qos();\n+  auto rs_qos = client->get_response_subscription_actual_qos();\n+\n+  EXPECT_EQ(qos_profile, rp_qos);\n+  // Lifespan has no meaning for subscription/readers\n+  rs_qos.lifespan(qos_profile.lifespan());\n+  EXPECT_EQ(qos_profile, rs_qos);\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, rcl_client_request_publisher_get_actual_qos_error)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rclcpp\", rcl_client_request_publisher_get_actual_qos, nullptr);\n+  auto client = this->template create_client<ClientType>(this->node, \"service\");\n+  RCLCPP_EXPECT_THROW_EQ(\n+    client->get_request_publisher_actual_qos(),\n+    std::runtime_error(\"failed to get client's request publisher qos settings: error not set\"));\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, rcl_client_response_subscription_get_actual_qos_error)\n+{\n+  using ClientType = TypeParam;\n+\n+  auto mock = mocking_utils::patch_and_return(\n+    \"lib:rclcpp\", rcl_client_response_subscription_get_actual_qos, nullptr);\n+  auto client = this->template create_client<ClientType>(this->node, \"service\");\n+  RCLCPP_EXPECT_THROW_EQ(\n+    client->get_response_subscription_actual_qos(),\n+    std::runtime_error(\"failed to get client's response subscription qos settings: error not set\"));\n+}\n+\n+// The following tests are only for rclcpp::Client\n+void client_async_send_request_callback_with_request(\n+  rclcpp::Node::SharedPtr node, const std::string service_name)\n+{\n+  using SharedFutureWithRequest =\n+    rclcpp::Client<test_msgs::srv::Empty>::SharedFutureWithRequest;\n+\n+  auto client = node->create_client<test_msgs::srv::Empty>(service_name);\n+  ASSERT_TRUE(client->wait_for_service(std::chrono::seconds(1)));\n+\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+  bool received_response = false;\n+  auto callback = [&request, &received_response](SharedFutureWithRequest future) {\n+      auto request_response_pair = future.get();\n+      EXPECT_EQ(request, request_response_pair.first);\n+      EXPECT_NE(nullptr, request_response_pair.second);\n+      received_response = true;\n+    };\n+  auto req_id = client->async_send_request(request, std::move(callback));\n+\n+  auto start = std::chrono::steady_clock::now();\n+  while (!received_response &&\n+    (std::chrono::steady_clock::now() - start) < std::chrono::seconds(1))\n+  {\n+    rclcpp::spin_some(node);\n+  }\n+  EXPECT_TRUE(received_response);\n+  EXPECT_FALSE(client->remove_pending_request(req_id));\n+}\n+TYPED_TEST(TestAllClientTypesWithServer, async_send_request_callback_with_request)\n+{\n+  using ClientType = TypeParam;\n+\n+  if (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+    client_async_send_request_callback_with_request(this->node, this->service_name);\n+  } else if (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+    GTEST_SKIP() << \"Skipping test for GenericClient\";\n+  } else {\n+    GTEST_SKIP() << \"Skipping test\";\n+  }\n+}\n+\n+void client_qos_depth(rclcpp::Node::SharedPtr node)\n+{\n+  using namespace std::literals::chrono_literals;\n+\n+  rclcpp::ServicesQoS client_qos_profile;\n+  client_qos_profile.keep_last(2);\n+\n+  auto client = node->create_client<test_msgs::srv::Empty>(\"test_qos_depth\", client_qos_profile);\n+\n+  uint64_t server_cb_count_ = 0;\n+  auto server_callback = [&](\n+    const test_msgs::srv::Empty::Request::SharedPtr,\n+    test_msgs::srv::Empty::Response::SharedPtr) {server_cb_count_++;};\n+\n+  auto server_node = std::make_shared<rclcpp::Node>(\"server_node\", \"/ns\");\n+\n+  rclcpp::QoS server_qos(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));\n+\n+  auto server = server_node->create_service<test_msgs::srv::Empty>(\n+    \"test_qos_depth\", std::move(server_callback), server_qos);\n+\n+  auto request = std::make_shared<test_msgs::srv::Empty::Request>();\n+  ::testing::AssertionResult request_result = ::testing::AssertionSuccess();\n+\n+  using SharedFuture = rclcpp::Client<test_msgs::srv::Empty>::SharedFuture;\n+  uint64_t client_cb_count_ = 0;\n+  auto client_callback = [&client_cb_count_, &request_result](SharedFuture future_response) {\n+      if (nullptr == future_response.get()) {\n+        request_result = ::testing::AssertionFailure() << \"Future response was null\";\n+      }\n+      client_cb_count_++;\n+    };\n+\n+  uint64_t client_requests = 5;\n+  for (uint64_t i = 0; i < client_requests; i++) {\n+    client->async_send_request(request, client_callback);\n+    std::this_thread::sleep_for(10ms);\n+  }\n+\n+  auto start = std::chrono::steady_clock::now();\n+  while ((server_cb_count_ < client_requests) &&\n+    (std::chrono::steady_clock::now() - start) < 2s)\n+  {\n+    rclcpp::spin_some(server_node);\n+    std::this_thread::sleep_for(2ms);\n+  }\n+\n+  EXPECT_GT(server_cb_count_, client_qos_profile.depth());\n+\n+  start = std::chrono::steady_clock::now();\n+  while ((client_cb_count_ < client_qos_profile.depth()) &&\n+    (std::chrono::steady_clock::now() - start) < 1s)\n+  {\n+    rclcpp::spin_some(node);\n+  }\n+\n+  // Spin an extra time to check if client QoS depth has been ignored,\n+  // so more client callbacks might be called than expected.\n+  rclcpp::spin_some(node);\n+\n+  EXPECT_EQ(client_cb_count_, client_qos_profile.depth());\n+}\n+\n+TYPED_TEST(TestAllClientTypesWithServer, qos_depth)\n+{\n+  using ClientType = TypeParam;\n+\n+  if (std::is_same_v<ClientType, rclcpp::Client<test_msgs::srv::Empty>>) {\n+    client_qos_depth(this->node);\n+  } else if (std::is_same_v<ClientType, rclcpp::GenericClient>) {\n+    GTEST_SKIP() << \"Skipping test for GenericClient\";\n+  } else {\n+    GTEST_SKIP() << \"Skipping test\";\n+  }\n+}"},{"role":"user","content":"+// Copyright 2023 Sony Group Corporation.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <gtest/gtest.h>\n+\n+#include <string>\n+#include <memory>\n+#include <utility>\n+\n+#include \"rclcpp/create_generic_client.hpp\"\n+#include \"rclcpp/exceptions.hpp\"\n+#include \"rclcpp/rclcpp.hpp\"\n+#include \"rclcpp/serialization.hpp\"\n+\n+#include \"rcl_interfaces/srv/list_parameters.hpp\"\n+\n+#include \"../mocking_utils/patch.hpp\"\n+\n+#include \"test_msgs/srv/empty.hpp\"\n+\n+using namespace std::chrono_literals;\n+\n+// All tests are from test_client\n+\n+class TestGenericClient : public ::testing::Test\n+{\n+protected:\n+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  void SetUp()\n+  {\n+    node = std::make_shared<rclcpp::Node>(\"test_node\", \"/ns\");\n+  }\n+\n+  void TearDown()\n+  {\n+    node.reset();\n+  }\n+\n+  rclcpp::Node::SharedPtr node;\n+};\n+\n+class TestGenericClientSub : public ::testing::Test\n+{\n+protected:\n+  static void SetUpTestCase()\n+  {\n+    rclcpp::init(0, nullptr);\n+  }\n+\n+  static void TearDownTestCase()\n+  {\n+    rclcpp::shutdown();\n+  }\n+\n+  void SetUp()\n+  {\n+    node = std::make_shared<rclcpp::Node>(\"test_node\", \"/ns\");\n+    subnode = node->create_sub_node(\"sub_ns\");\n+  }\n+  void TearDown()\n+  {\n+    node.reset();\n+  }\n+\n+  rclcpp::Node::SharedPtr node;\n+  rclcpp::Node::SharedPtr subnode;\n+};\n+\n+/*\n+   Testing client construction and destruction.\n+ */\n+TEST_F(TestGenericClient, construction_and_destruction) {\n+  {\n+    auto client = node->create_generic_client(\"test_service\", \"test_msgs/srv/Empty\");\n+  }\n+\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = node->create_generic_client(\"invalid_test_service?\", \"test_msgs/srv/Empty\");\n+    }, rclcpp::exceptions::InvalidServiceNameError);\n+  }\n+\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = node->create_generic_client(\"test_service\", \"test_msgs/srv/InvalidType\");\n+    }, std::runtime_error);\n+  }\n+}\n+\n+TEST_F(TestGenericClient, construction_with_free_function) {\n+  {\n+    auto client = rclcpp::create_generic_client(\n+      node->get_node_base_interface(),\n+      node->get_node_graph_interface(),\n+      node->get_node_services_interface(),\n+      \"test_service\",\n+      \"test_msgs/srv/Empty\",\n+      rclcpp::ServicesQoS(),\n+      nullptr);\n+  }\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = rclcpp::create_generic_client(\n+        node->get_node_base_interface(),\n+        node->get_node_graph_interface(),\n+        node->get_node_services_interface(),\n+        \"invalid_?test_service\",\n+        \"test_msgs/srv/Empty\",\n+        rclcpp::ServicesQoS(),\n+        nullptr);\n+    }, rclcpp::exceptions::InvalidServiceNameError);\n+  }\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = rclcpp::create_generic_client(\n+        node->get_node_base_interface(),\n+        node->get_node_graph_interface(),\n+        node->get_node_services_interface(),\n+        \"test_service\",\n+        \"test_msgs/srv/InvalidType\",\n+        rclcpp::ServicesQoS(),\n+        nullptr);\n+    }, std::runtime_error);\n+  }\n+  {\n+    auto client = rclcpp::create_generic_client(\n+      node,\n+      \"test_service\",\n+      \"test_msgs/srv/Empty\",\n+      rclcpp::ServicesQoS(),\n+      nullptr);\n+  }\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = rclcpp::create_generic_client(\n+        node,\n+        \"invalid_?test_service\",\n+        \"test_msgs/srv/Empty\",\n+        rclcpp::ServicesQoS(),\n+        nullptr);\n+    }, rclcpp::exceptions::InvalidServiceNameError);\n+  }\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = rclcpp::create_generic_client(\n+        node,\n+        \"invalid_?test_service\",\n+        \"test_msgs/srv/InvalidType\",\n+        rclcpp::ServicesQoS(),\n+        nullptr);\n+    }, std::runtime_error);\n+  }\n+}\n+\n+TEST_F(TestGenericClient, construct_with_rcl_error) {\n+  {\n+    // reset() is not necessary for this exception, but handles unused return value warning\n+    auto mock = mocking_utils::patch_and_return(\"lib:rclcpp\", rcl_client_init, RCL_RET_ERROR);\n+    EXPECT_THROW(\n+      node->create_generic_client(\"test_service\", \"test_msgs/srv/Empty\").reset(),\n+      rclcpp::exceptions::RCLError);\n+  }\n+  {\n+    // reset() is required for this one\n+    auto mock = mocking_utils::patch_and_return(\"lib:rclcpp\", rcl_client_fini, RCL_RET_ERROR);\n+    EXPECT_NO_THROW(\n+      node->create_generic_client(\"test_service\", \"test_msgs/srv/Empty\").reset());\n+  }\n+}\n+\n+TEST_F(TestGenericClient, wait_for_service) {\n+  const std::string service_name = \"test_service\";\n+\n+  auto client = node->create_generic_client(service_name, \"test_msgs/srv/Empty\");\n+  EXPECT_FALSE(client->wait_for_service(std::chrono::nanoseconds(0)));\n+  EXPECT_FALSE(client->wait_for_service(std::chrono::milliseconds(10)));\n+\n+  auto callback = [](\n+    const test_msgs::srv::Empty::Request::SharedPtr,\n+    test_msgs::srv::Empty::Response::SharedPtr) {};\n+\n+  auto service =\n+    node->create_service<test_msgs::srv::Empty>(service_name, std::move(callback));\n+\n+  EXPECT_TRUE(client->wait_for_service(std::chrono::nanoseconds(-1)));\n+  EXPECT_TRUE(client->service_is_ready());\n+}\n+\n+/*\n+   Testing generic client construction and destruction for subnodes.\n+ */\n+TEST_F(TestGenericClientSub, construction_and_destruction) {\n+  {\n+    auto client = subnode->create_generic_client(\"test_service\", \"test_msgs/srv/Empty\");\n+    EXPECT_STREQ(client->get_service_name(), \"/ns/test_service\");\n+  }\n+\n+  {\n+    ASSERT_THROW(\n+    {\n+      auto client = node->create_generic_client(\"invalid_service?\", \"test_msgs/srv/Empty\");\n+    }, rclcpp::exceptions::InvalidServiceNameError);\n+  }\n+}"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    // find the message this request is associated with\n-    typename L_MessageInfo::iterator msg_it = messages_.begin();\n-    typename L_MessageInfo::iterator msg_end = messages_.end();\n-"},{"role":"user","content":"+      // find the message this request is associated with\n+      typename L_MessageInfo::iterator msg_it = messages_.begin();\n+      typename L_MessageInfo::iterator msg_end = messages_.end();\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-                node.count_subscribers\n+                node.count_subscribers,\n+                node.count_clients,\n+                node.count_services"},{"role":"user","content":"+\n+\n+def test_count_clients(daemon_node):\n+    assert 1 == daemon_node.count_clients(TEST_SERVICE_NAME)\n+\n+\n+def test_count_services(daemon_node):\n+    assert 1 == daemon_node.count_services(TEST_SERVICE_NAME)"},{"role":"user","content":"+# Copyright 2022 CLOBOT Co., Ltd.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ros2cli.node.strategy import add_arguments as add_strategy_node_arguments\n+from ros2cli.node.strategy import NodeStrategy\n+from ros2service.api import get_service_names_and_types\n+from ros2service.api import ServiceNameCompleter\n+from ros2topic.verb import VerbExtension\n+\n+\n+class InfoVerb(VerbExtension):\n+    \"\"\"Print information about a service.\"\"\"\n+\n+    def add_arguments(self, parser, cli_name):\n+        add_strategy_node_arguments(parser)\n+        arg = parser.add_argument(\n+            'service_name',\n+            help=\"Name of the ROS service to get info (e.g. '/add_two_ints')\")\n+        arg.completer = ServiceNameCompleter(\n+            include_hidden_services_key='include_hidden_services')\n+\n+    def main(self, *, args):\n+        with NodeStrategy(args) as node:\n+            service_names_and_types = get_service_names_and_types(\n+                node=node,\n+                include_hidden_services=args.include_hidden_services)\n+            service_name = args.service_name\n+\n+            for (s_name, s_types) in service_names_and_types:\n+                if s_name == service_name:\n+                    service_types = s_types\n+                    break\n+            else:\n+                return \"Unknown service '%s'\" % service_name\n+\n+            type_str = service_types[0] if len(service_types) == 1 else service_types\n+            print('Type: %s' % type_str, end='\\n')\n+\n+            print('Clients count: %d' %\n+                  node.count_clients(service_name), end='\\n')\n+\n+            print('Services count: %d' %\n+                  node.count_services(service_name), end='\\n')"},{"role":"user","content":"+            'info = ros2service.verb.info:InfoVerb',"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+/// Action name does not pass validation return code.\n+#define RCL_RET_ACTION_NAME_INVALID 4000"},{"role":"user","content":"-#define RCL_ACTION_RET_NOT_TERMINATED_YET 4001\n+#define RCL_RET_ACTION_NOT_TERMINATED_YET 4001\n+/// Action goal accepted return code.\n+#define RCL_RET_ACTION_GOAL_ACCEPTED 4100\n+/// Action goal rejected return code.\n+#define RCL_RET_ACTION_GOAL_REJECTED 4101\n+/// Action client is invalid return code.\n+#define RCL_RET_ACTION_CLIENT_INVALID 4102\n+/// Action client failed to take response return code.\n+#define RCL_RET_ACTION_CLIENT_TAKE_FAILED 4103\n+/// Action server is invalid return code.\n+#define RCL_RET_ACTION_SERVER_INVALID 4200\n+/// Action server failed to take request return code.\n+#define RCL_RET_ACTION_SERVER_TAKE_FAILED 4201\n+/// Action goal handle invalid return code.\n+#define RCL_RET_ACTION_GOAL_HANDLE_INVALID 4300\n+/// Action invalid event return code.\n+#define RCL_RET_ACTION_GOAL_EVENT_INVALID 4301"},{"role":"user","content":"-// rcl action specific ret codes in 2XXX\n-/// Action name does not pass validation return code.\n-#define RCL_RET_ACTION_NAME_INVALID 2000\n-/// Action goal accepted return code.\n-#define RCL_RET_ACTION_GOAL_ACCEPTED 2100\n-/// Action goal rejected return code.\n-#define RCL_RET_ACTION_GOAL_REJECTED 2101\n-/// Action client is invalid return code.\n-#define RCL_RET_ACTION_CLIENT_INVALID 2102\n-/// Action client failed to take response return code.\n-#define RCL_RET_ACTION_CLIENT_TAKE_FAILED 2103\n-/// Action server is invalid return code.\n-#define RCL_RET_ACTION_SERVER_INVALID 2200\n-/// Action server failed to take request return code.\n-#define RCL_RET_ACTION_SERVER_TAKE_FAILED 2201\n-/// Action goal handle invalid return code.\n-#define RCL_RET_ACTION_GOAL_HANDLE_INVALID 2300\n-/// Action invalid event return code.\n-#define RCL_RET_ACTION_GOAL_EVENT_INVALID 2301\n-"},{"role":"user","content":"-      if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n+      if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {"},{"role":"user","content":"-    if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n+    if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {"},{"role":"user","content":"-      if (RCL_ACTION_RET_NOT_TERMINATED_YET == ret) {\n+      if (RCL_RET_ACTION_NOT_TERMINATED_YET == ret) {"},{"role":"user","content":"-    return RCL_ACTION_RET_NOT_TERMINATED_YET;\n+    return RCL_RET_ACTION_NOT_TERMINATED_YET;"},{"role":"user","content":"-  EXPECT_EQ(ret, RCL_ACTION_RET_NOT_TERMINATED_YET) << rcl_get_error_string().str;\n+  EXPECT_EQ(ret, RCL_RET_ACTION_NOT_TERMINATED_YET) << rcl_get_error_string().str;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#define RET_WRONG_IMPLID_X(var, code) do { \\\n-    if ((var)->implementation_identifier != eclipse_cyclonedds_identifier) { \\\n-      RET_ERR_X(#var \" not from this implementation\", code); \\\n-    } \\\n-} while (0)\n-#define RET_NULL_OR_EMPTYSTR_X(var, code) do { \\\n-    if (!var || strlen(var) == 0) { \\\n-      RET_ERR_X(#var \" is null or empty string\", code); \\\n-    } \\\n-} while (0)\n+"},{"role":"user","content":"-#define RET_WRONG_IMPLID(var) RET_WRONG_IMPLID_X(var, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION)\n-#define RET_NULL_OR_EMPTYSTR(var) RET_NULL_OR_EMPTYSTR_X(var, return RMW_RET_ERROR)\n-#define RET_EXPECTED(func, expected_ret, error_msg, code) do { \\\n-    if ((expected_ret) != (func)) \\\n-    { \\\n-      RET_ERR_X(error_msg, code); \\\n-    } \\\n-} while (0)"},{"role":"user","content":"-    src,\n-    src->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+    init options copy, src->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-    init_options,\n-    init_options->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n-    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+    init options, init_options->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-    RET_EXPECTED(\n-      dds_data_allocator_init_heap(&entity->data_allocator),\n-      DDS_RETCODE_OK,\n-      \"Reader data allocator initialization failed for heap\",\n-      return nullptr);\n+    if (dds_data_allocator_init_heap(&entity->data_allocator) != DDS_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"Reader data allocator initialization failed for heap\");\n+      return nullptr;\n+    }"},{"role":"user","content":"-    RET_EXPECTED(\n-      dds_data_allocator_init(entity->enth, &entity->data_allocator),\n-      DDS_RETCODE_OK,\n-      \"Writer allocator initialisation failed\",\n-      return nullptr);\n+    if (dds_data_allocator_init(entity->enth, &entity->data_allocator) != DDS_RETCODE_OK) {\n+      RMW_SET_ERROR_MSG(\"Writer allocator initialisation failed\");\n+      return nullptr;\n+    }"},{"role":"user","content":"-  RET_EXPECTED(\n-    dds_data_allocator_free(\n-      &entity->data_allocator,\n-      loaned_message),\n-    DDS_RETCODE_OK,\n-    \"Failed to free the loaned message\",\n-    return RMW_RET_ERROR);\n+  if (dds_data_allocator_free(&entity->data_allocator, loaned_message) != DDS_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"Failed to free the loaned message\");\n+    return RMW_RET_ERROR;\n+  }"},{"role":"user","content":"-  RET_EXPECTED(\n-    dds_data_allocator_fini(&entity->data_allocator),\n-    DDS_RETCODE_OK,\n-    \"Failed to fini data allocator\",\n-    return RMW_RET_ERROR);\n+  if (dds_data_allocator_fini(&entity->data_allocator) != DDS_RETCODE_OK) {\n+    RMW_SET_ERROR_MSG(\"Failed to fini data allocator\");\n+    return RMW_RET_ERROR;\n+  }"},{"role":"user","content":"-    options,\n-    options->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    options, options->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    context,\n-    context->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    context, context->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    context,\n-    context->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    context, context->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    context,\n-    context->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    context, context->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_WRONG_IMPLID_X(node, return nullptr);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return nullptr);"},{"role":"user","content":"-  RET_NULL_OR_EMPTYSTR_X(topic_name, return nullptr);\n+  if (!topic_name || topic_name[0] == '\\0') {\n+    RMW_SET_ERROR_MSG(\"topic_name is null or empty string\");\n+    return nullptr;\n+  }\n+"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    client,\n-    client->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    client, client->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    gid1,\n-    gid1->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    gid1, gid1->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    gid2,\n-    gid2->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    gid2, gid2->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_WRONG_IMPLID(publisher);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    publisher,\n-    publisher->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_NULL_OR_EMPTYSTR_X(topic_name, return nullptr);\n+  if (!topic_name || topic_name[0] == '\\0') {\n+    RMW_SET_ERROR_MSG(\"topic_name is null or empty string\");\n+    return nullptr;\n+  }"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription,\n-    subscription->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    subscription, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription,\n-    subscription->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    subscription, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription,\n-    subscription->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    subscription, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription handle,\n-    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    subscription handle, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_WRONG_IMPLID(subscription);"},{"role":"user","content":"-    subscription handle,\n-    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    subscription handle, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription handle,\n-    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    subscription handle, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription handle,\n-    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    subscription handle, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    subscription handle,\n-    subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    subscription handle, subscription->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_WRONG_IMPLID(publisher);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    publisher, publisher->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+"},{"role":"user","content":"-  RET_WRONG_IMPLID(subscription);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    subscription, subscription->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-  RET_WRONG_IMPLID(event_handle);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    event_handle, event_handle->implementation_identifier, eclipse_cyclonedds_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-  RET_WRONG_IMPLID(guard_condition_handle);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    guard_condition_handle, guard_condition_handle->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-  RET_WRONG_IMPLID(wait_set);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    wait_set, wait_set->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-  RET_WRONG_IMPLID(wait_set);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    wait_set, wait_set->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-#define ATTACH(type, var, name, cond) do { \\\n-    ws->var.resize(0); \\\n-    if (var) { \\\n-      ws->var.reserve(var->name ## _count); \\\n-      for (size_t i = 0; i < var->name ## _count; i++) { \\\n-        auto x = static_cast<type *>(var->name ## s[i]); \\\n-        ws->var.push_back(x); \\\n-        dds_waitset_attach(ws->waitseth, x->cond, nelems); \\\n-        nelems++; \\\n-      } \\\n-    } \\\n-} \\\n-  while (0)\n-    ATTACH(CddsSubscription, subs, subscriber, rdcondh);\n-    ATTACH(CddsGuardCondition, gcs, guard_condition, gcondh);\n-    ATTACH(CddsService, srvs, service, service.sub->rdcondh);\n-    ATTACH(CddsClient, cls, client, client.sub->rdcondh);\n-#undef ATTACH"},{"role":"user","content":"+    // Attach subscriptions\n+    ws->subs.resize(0);\n+    if (subs) {\n+      ws->subs.reserve(subs->subscriber_count);\n+      for (size_t i = 0; i < subs->subscriber_count; i++) {\n+        auto x = static_cast<CddsSubscription *>(subs->subscribers[i]);\n+        ws->subs.push_back(x);\n+        dds_waitset_attach(ws->waitseth, x->rdcondh, nelems++);\n+      }\n+    }\n+\n+    // Attach guard conditions\n+    ws->gcs.resize(0);\n+    if (gcs) {\n+      ws->gcs.reserve(gcs->guard_condition_count);\n+      for (size_t i = 0; i < gcs->guard_condition_count; i++) {\n+        auto x = static_cast<CddsGuardCondition *>(gcs->guard_conditions[i]);\n+        ws->gcs.push_back(x);\n+        dds_waitset_attach(ws->waitseth, x->gcondh, nelems++);\n+      }\n+    }\n+\n+    // Attach service servers\n+    ws->srvs.resize(0);\n+    if (srvs) {\n+      ws->srvs.reserve(srvs->service_count);\n+      for (size_t i = 0; i < srvs->service_count; i++) {\n+        auto x = static_cast<CddsService *>(srvs->services[i]);\n+        ws->srvs.push_back(x);\n+        dds_waitset_attach(ws->waitseth, x->service.sub->rdcondh, nelems++);\n+      }\n+    }\n+\n+    // Attach service clients\n+    ws->cls.resize(0);\n+    if (cls) {\n+      ws->cls.reserve(cls->client_count);\n+      for (size_t i = 0; i < cls->client_count; i++) {\n+        auto x = static_cast<CddsClient *>(cls->clients[i]);\n+        ws->cls.push_back(x);\n+        dds_waitset_attach(ws->waitseth, x->client.sub->rdcondh, nelems++);\n+      }\n+    }\n+\n+    // Attach events"},{"role":"user","content":"-    bool dummy;"},{"role":"user","content":"-#define DETACH(type, var, name, cond, on_triggered) do { \\\n-    if (var) { \\\n-      for (size_t i = 0; i < var->name ## _count; i++) { \\\n-        auto x = static_cast<type *>(var->name ## s[i]); \\\n-        if (ws->trigs[trig_idx] == static_cast<dds_attach_t>(nelems)) { \\\n-          on_triggered; \\\n-          trig_idx++; \\\n-        } else { \\\n-          var->name ## s[i] = nullptr; \\\n-        } \\\n-        nelems++; \\\n-      } \\\n-    } \\\n-} while (0)\n-    DETACH(CddsSubscription, subs, subscriber, rdcondh, (void) x);\n-    DETACH(\n-      CddsGuardCondition, gcs, guard_condition, gcondh,\n-      dds_take_guardcondition(x->gcondh, &dummy));\n-    DETACH(CddsService, srvs, service, service.sub->rdcondh, (void) x);\n-    DETACH(CddsClient, cls, client, client.sub->rdcondh, (void) x);\n-#undef DETACH\n+\n+    // Detach subscriptions\n+    if (subs) {\n+      for (size_t i = 0; i < subs->subscriber_count; i++) {\n+        if (ws->trigs[trig_idx] == static_cast<dds_attach_t>(nelems)) {\n+          trig_idx++;\n+        } else {\n+          subs->subscribers[i] = nullptr;\n+        }\n+        nelems++;\n+      }\n+    }\n+\n+    // Detach guard conditions\n+    if (gcs) {\n+      for (size_t i = 0; i < gcs->guard_condition_count; i++) {\n+        auto x = static_cast<CddsGuardCondition *>(gcs->guard_conditions[i]);\n+        if (ws->trigs[trig_idx] == static_cast<dds_attach_t>(nelems)) {\n+          bool dummy;\n+          dds_take_guardcondition(x->gcondh, &dummy);\n+        } else {\n+          gcs->guard_conditions[i] = nullptr;\n+        }\n+        nelems++;\n+      }\n+    }\n+\n+    // Detach service servers\n+    if (srvs) {\n+      for (size_t i = 0; i < srvs->service_count; i++) {\n+        if (ws->trigs[trig_idx] == static_cast<dds_attach_t>(nelems)) {\n+          trig_idx++;\n+        } else {\n+          srvs->services[i] = nullptr;\n+        }\n+        nelems++;\n+      }\n+    }\n+\n+    // Detach service clients\n+    if (cls) {\n+      for (size_t i = 0; i < cls->client_count; i++) {\n+        if (ws->trigs[trig_idx] == static_cast<dds_attach_t>(nelems)) {\n+          trig_idx++;\n+        } else {\n+          cls->clients[i] = nullptr;\n+        }\n+        nelems++;\n+      }\n+    }\n+"},{"role":"user","content":"-    client,\n-    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    client, client->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    service,\n-    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    service, service->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    service,\n-    service->implementation_identifier, eclipse_cyclonedds_identifier,\n+    service, service->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    client,\n-    client->implementation_identifier, eclipse_cyclonedds_identifier,\n+    client, client->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    client,\n-    client->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    client, client->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    service,\n-    service->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    service, service->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-  RET_WRONG_IMPLID(node);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node, node->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-  RET_WRONG_IMPLID(client);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    client, client->implementation_identifier,\n+    eclipse_cyclonedds_identifier, return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"-    node,\n-    node->implementation_identifier,\n-    eclipse_cyclonedds_identifier,\n+    node, node->implementation_identifier, eclipse_cyclonedds_identifier,"},{"role":"user","content":"+  // *INDENT-OFF*"},{"role":"user","content":"-    if (cnt > 0) { \\\n-      align(sizeof(T)); \\\n-      validate_size(cnt, sizeof(T)); \\\n-      if (swap_bytes) { \\\n-        for (size_t i = 0; i < cnt; i++) { \\\n-          x[i] = fn_swap(*reinterpret_cast<const T *>(data + pos)); \\\n-          pos += sizeof(T); \\\n-        } \\\n-      } else { \\\n-        memcpy( \\\n-          reinterpret_cast<void *>(x), reinterpret_cast<const void *>(data + pos), \\\n-          cnt * sizeof(T)); \\\n-        pos += cnt * sizeof(T); \\\n+  if (cnt > 0) { \\\n+    align(sizeof(T)); \\\n+    validate_size(cnt, sizeof(T)); \\\n+    if (swap_bytes) { \\\n+      for (size_t i = 0; i < cnt; i++) { \\\n+        x[i] = fn_swap(*reinterpret_cast<const T *>(data + pos)); \\\n+        pos += sizeof(T); \\"},{"role":"user","content":"+    } else { \\\n+      memcpy( \\\n+        reinterpret_cast<void *>(x), reinterpret_cast<const void *>(data + pos), \\\n+        cnt * sizeof(T)); \\\n+      pos += cnt * sizeof(T); \\"},{"role":"user","content":"+  } \\"},{"role":"user","content":"+  // *INDENT-ON*\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    # TODO(hidmic): investigate why making use of the same rclpy node, executor\n-    #               and context for all tests on a per rmw implementation basis\n-    #               makes them fail on Linux-aarch64 when using 'rmw_opensplice_cpp'.\n-    #               Presumably, interfaces creation/destruction and/or executor spinning\n-    #               on one test is affecting the other."},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        with tmr.handle:\n-            tmr.handle.call_timer()\n-        return ()\n+        try:\n+            with tmr.handle:\n+                tmr.handle.call_timer()\n+\n+                async def _execute():\n+                    await await_or_execute(tmr.callback)\n+                return _execute\n+        except InvalidHandle:\n+            # Timer is a Destroyable, which means that on __enter__ it can throw an\n+            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n+            # by just returning an empty argument, which means we will skip doing any real work\n+            # in _execute_timer below\n+            pass"},{"role":"user","content":"-    async def _execute_timer(self, tmr):\n-        await await_or_execute(tmr.callback)\n+        return None"},{"role":"user","content":"-        with sub.handle:\n-            msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n-            if msg_info is not None:\n+        try:\n+            with sub.handle:\n+                msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n+                if msg_info is None:\n+                    return None\n+"},{"role":"user","content":"-                    return (msg_info[0], )\n+                    msg_tuple = (msg_info[0], )"},{"role":"user","content":"-                    return msg_info\n-        return ()\n+                    msg_tuple = msg_info\n+\n+                async def _execute():\n+                    await await_or_execute(sub.callback, *msg_tuple)\n+\n+                return _execute\n+        except InvalidHandle:\n+            # Subscription is a Destroyable, which means that on __enter__ it can throw an\n+            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n+            # by just returning an empty argument, which means we will skip doing any real work\n+            # in _execute_subscription below\n+            pass"},{"role":"user","content":"-    async def _execute_subscription(self, sub, *args):\n-        if args:\n-            await await_or_execute(sub.callback, *args)\n+        return None"},{"role":"user","content":"-        with client.handle:\n-            return (client.handle.take_response(client.srv_type.Response), )\n+        try:\n+            with client.handle:\n+                header_and_response = client.handle.take_response(client.srv_type.Response)"},{"role":"user","content":"-    async def _execute_client(self, client, seq_and_response):\n-        header, response = seq_and_response\n-        if header is not None:\n-            try:\n-                sequence = header.request_id.sequence_number\n-                future = client.get_pending_request(sequence)\n-            except KeyError:\n-                # The request was cancelled\n-                pass\n-            else:\n-                future._set_executor(self)\n-                future.set_result(response)\n+            async def _execute():\n+                header, response = header_and_response\n+                if header is None:\n+                    return\n+                try:\n+                    sequence = header.request_id.sequence_number\n+                    future = client.get_pending_request(sequence)\n+                except KeyError:\n+                    # The request was cancelled\n+                    pass\n+                else:\n+                    future._set_executor(self)\n+                    future.set_result(response)\n+            return _execute\n+\n+        except InvalidHandle:\n+            # Client is a Destroyable, which means that on __enter__ it can throw an\n+            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n+            # by just returning an empty argument, which means we will skip doing any real work\n+            # in _execute_client below\n+            pass\n+\n+        return None"},{"role":"user","content":"-        with srv.handle:\n-            request_and_header = srv.handle.service_take_request(srv.srv_type.Request)\n-        return (request_and_header, )\n-\n-    async def _execute_service(self, srv, request_and_header):\n-        if request_and_header is None:\n-            return\n-        (request, header) = request_and_header\n-        if request:\n-            response = await await_or_execute(srv.callback, request, srv.srv_type.Response())\n-            srv.send_response(response, header)\n+        try:\n+            with srv.handle:\n+                request_and_header = srv.handle.service_take_request(srv.srv_type.Request)\n+\n+            async def _execute():\n+                (request, header) = request_and_header\n+                if header is None:\n+                    return\n+\n+                response = await await_or_execute(srv.callback, request, srv.srv_type.Response())\n+                srv.send_response(response, header)\n+            return _execute\n+        except InvalidHandle:\n+            # Service is a Destroyable, which means that on __enter__ it can throw an\n+            # InvalidHandle exception if the entity has already been destroyed.  Handle that here\n+            # by just returning an empty argument, which means we will skip doing any real work\n+            # in _execute_service below\n+            pass\n+\n+        return None"},{"role":"user","content":"-        return ()"},{"role":"user","content":"-    async def _execute_guard_condition(self, gc):\n-        await await_or_execute(gc.callback)\n+        async def _execute():\n+            await await_or_execute(gc.callback)\n+        return _execute\n+\n+    def _take_waitable(self, waitable):\n+        data = waitable.take_data()"},{"role":"user","content":"-    async def _execute_waitable(self, waitable, data):\n-        for future in waitable._futures:\n-            future._set_executor(self)\n-        await waitable.execute(data)\n+        async def _execute():\n+            for future in waitable._futures:\n+                future._set_executor(self)\n+            await waitable.execute(data)\n+        return _execute"},{"role":"user","content":"-        call_coroutine: Coroutine"},{"role":"user","content":"-        :param call_coroutine: Does the work the entity is ready for"},{"role":"user","content":"-                arg = take_from_wait_list(entity)\n+                # The take_from_wait_list method here is expected to return either an async def\n+                # method or None if there is no work to do.\n+                call_coroutine = take_from_wait_list(entity)"},{"role":"user","content":"-                    await call_coroutine(entity, *arg)\n+                    if call_coroutine is not None:\n+                        await call_coroutine()"},{"role":"user","content":"-                                handler = self._make_handler(\n-                                    wt, node, lambda e: (e.take_data(), ), self._execute_waitable)\n+                                handler = self._make_handler(wt, node, self._take_waitable)"},{"role":"user","content":"-                                handler = self._make_handler(\n-                                    tmr, node, self._take_timer, self._execute_timer)\n+                                handler = self._make_handler(tmr, node, self._take_timer)"},{"role":"user","content":"-                            handler = self._make_handler(\n-                                sub, node, self._take_subscription, self._execute_subscription)\n+                            handler = self._make_handler(sub, node, self._take_subscription)"},{"role":"user","content":"-                            handler = self._make_handler(\n-                                gc, node, self._take_guard_condition,\n-                                self._execute_guard_condition)\n+                            handler = self._make_handler(gc, node, self._take_guard_condition)"},{"role":"user","content":"-                            handler = self._make_handler(\n-                                client, node, self._take_client, self._execute_client)\n+                            handler = self._make_handler(client, node, self._take_client)"},{"role":"user","content":"-                            handler = self._make_handler(\n-                                srv, node, self._take_service, self._execute_service)\n+                            handler = self._make_handler(srv, node, self._take_service)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  <maintainer email=\"jacob@openrobotics.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"-    maintainer='Jacob Perron',\n-    maintainer_email='jacob@openrobotics.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\t\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"michel@ekumenlabs.com\">Michel Hidalgo</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"michel@ekumenlabs.com\">Michel Hidalgo</author>\t\n+"},{"role":"user","content":"-    maintainer='Michel Hidalgo',\n-    maintainer_email='michel@ekumenlabs.com',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"clairewang@openrobotics.org\">Claire Wang</author>\n+"},{"role":"user","content":"-  <maintainer email=\"jacob@osrfoundation.org\">Jacob Perron</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author>Siddharth Kucheria</author>\n+  <author email=\"jacob@osrfoundation.org\">Jacob Perron</author>\n+"},{"role":"user","content":"-    author='Siddharth Kucheria',\n-    author_email='kucheria@osrfoundation.org',\n-    maintainer='Jacob Perron',\n-    maintainer_email='jacob@osrfoundation.org',\n+    author='Siddharth Kucheria, Jacob Perron',\n+    author_email='kucheria@osrfoundation.org, jacob@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"michel@ekumenlabs.com\">Michel Hidalgo</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"michel@ekumenlabs.com\">Michel Hidalgo</author>\n+"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"william@osrfoundation.org\">William Woodall</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"william@osrfoundation.org\">William Woodall</author>\n+"},{"role":"user","content":"-    maintainer='William Woodall',\n-    maintainer_email='william@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"user","content":"-  <maintainer email=\"dthomas@osrfoundation.org\">Dirk Thomas</maintainer>\n+  <maintainer email=\"clairewang@openrobotics.org\">Claire Wang</maintainer>\n+  <maintainer email=\"mabel@openrobotics.org\">Mabel Zhang</maintainer>"},{"role":"user","content":"+  <author email=\"dthomas@osrfoundation.org\">Dirk Thomas</author>\n+"},{"role":"user","content":"-    maintainer='Dirk Thomas',\n-    maintainer_email='dthomas@osrfoundation.org',\n+    maintainer='Claire Wang, Mabel Zhang',\n+    maintainer_email='clairewang@openrobotics.org, mabel@openrobotics.org',"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#INPUT                  = README.md ../../../install_isolated/rcutils/include\n-#STRIP_FROM_PATH        = /Users/william/ros2_ws/install_isolated/rcutils/include"},{"role":"user","content":"-INPUT                  = README.md ./include\n+INPUT                  = CONTRIBUTING.md README.md QUALITY_DECLARATION.md ./include"},{"role":"user","content":"+PREDEFINED             += DOXYGEN_ONLY"},{"role":"user","content":"-  const rcutils_log_location_t *,  // location\n-  int,  // severity\n-  const char *,  // name\n-  rcutils_time_point_value_t,  // timestamp\n-  const char *,  // format\n-  va_list *  // args\n+  const rcutils_log_location_t * location,\n+  int severity,\n+  const char * name,\n+  rcutils_time_point_value_t timestamp,\n+  const char * format,\n+  va_list * args"},{"role":"user","content":"-/// \\file Provides a simple SHA256 algorithm for hashing.\n-/// This implementation makes no security guarantees, its use case\n-/// is for non-sensitive comparison of message digests\n-/// Implementation originally copied from Brad Conte\n-/// https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c\n-"},{"role":"user","content":"+ *  This implementation makes no security guarantees, its use case if for\n+ *  non-sensitive comparison of message digests."},{"role":"user","content":"+#ifdef DOXYGEN_ONLY\n+// One of the tools used by rosdoc2 misunderstands uint8_t[] as a uint8_t,\n+// so make it a pointer for documentation purposes.\n+RCUTILS_PUBLIC\n+void rcutils_sha256_final(\n+  rcutils_sha256_ctx_t * ctx,\n+  uint8_t * output_hash);\n+#else"},{"role":"user","content":"+#endif"},{"role":"user","content":"-  const void *  // key to hash\n+  const void * key"},{"role":"user","content":"-  const void *,  // val1\n-  const void *  // val2\n+  const void * val1,\n+  const void * val2"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"- * The value of avoid_ros_namespace_conventions field is not resolved\n- * with this function. The rcl function rcl_publisher_get_actual_qos\n- * resolves it.\n+ *\n+ * \\note The value of avoid_ros_namespace_conventions field is not resolved\n+ *   with this function. The rcl function `rcl_publisher_get_actual_qos()`\n+ *   resolves it.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe [1]\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>"},{"role":"user","content":"+ * \\return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher\n+ *   implementation identifier does not match, or"},{"role":"user","content":"- * The value of avoid_ros_namespace_conventions field is not resolved\n- * with this function. The rcl function rcl_subscription_get_actual_qos\n- * resolves it.\n+ *\n+ * \\note The value of avoid_ros_namespace_conventions field is not resolved\n+ *   with this function. The rcl function `rcl_subscription_get_actual_qos()`\n+ *   resolves it.\n+ *\n+ * <hr>\n+ * Attribute          | Adherence\n+ * ------------------ | -------------\n+ * Allocates Memory   | Maybe [1]\n+ * Thread-Safe        | No\n+ * Uses Atomics       | Maybe [1]\n+ * Lock-Free          | Maybe [1]\n+ * <i>[1] rmw implementation defined, check the implementation documentation</i>"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-        'Class': str(vm_dict['Class']),\n+        'Class': str(vm_dict.get('Class', '')),"},{"role":"user","content":"-        'Enabled': bool(vm_dict['Enabled']),\n-        'Name': str(vm_dict['Name']),\n+        'Enabled': bool(vm_dict.get('Enabled', True)),\n+        'Name': str(vm_dict.get('Name', 'root')),"},{"role":"user","content":"-        'Value': bool(vm_dict['Value']),\n+        'Value': bool(vm_dict.get('Value', True)),"},{"role":"user","content":"-            'Background Color': str(vm_dict['Global Options']['Background Color']),\n-            'Fixed Frame': str(vm_dict['Global Options']['Fixed Frame']),\n-            'Frame Rate': int(vm_dict['Global Options']['Frame Rate']),\n+            'Background Color': str(vm_dict.get('Global Options', {}).get('Background Color', '48; 48; 48')),\n+            'Fixed Frame': str(vm_dict.get('Global Options', {}).get('Fixed Frame', 'map')),\n+            'Frame Rate': int(vm_dict.get('Global Options', {}).get('Frame Rate', 30)),"},{"role":"user","content":"-                'Topic': migrate_topic(name = tool_dict['Topic']),\n+                'Topic': migrate_topic(name = tool_dict.get('Topic', '/initialpose')),"},{"role":"user","content":"-                'Topic': migrate_topic(name = tool_dict['Topic']),\n+                'Topic': migrate_topic(name = tool_dict.get('Topic', '/goal_pose')),"},{"role":"user","content":"-                'Single click': bool(tool_dict['Single click']),\n-                'Topic': migrate_topic(name = tool_dict['Topic']),\n+                'Single click': bool(tool_dict.get('Single click', True)),\n+                'Topic': migrate_topic(name = tool_dict.get('Topic', '/clicked_point')),"},{"role":"user","content":"+Panels:\n+- Class: rviz/Displays\n+  Name: Displays\n+  Property Tree Widget:\n+    Expanded:\n+    - /Odometry1/Covariance1/Position1\n+    - /Odometry1/Covariance1/Orientation1\n+  Tree Height: 675\n+- Class: rviz/Selection\n+  Name: Selection\n+- Class: rviz/Tool Properties\n+  Expanded:\n+  - /2D Pose Estimate1\n+  - /2D Nav Goal1\n+  - /Publish Point1\n+  Name: Tool Properties\n+- Class: rviz/Views\n+  Expanded:\n+  - /Current View1\n+  Name: Views\n+- Class: rviz/Time\n+  Name: Time\n+- Class: rviz/Displays\n+  Help Height: 70\n+  Name: Displays\n+  Property Tree Widget:\n+    Expanded: null\n+  Tree Height: 371\n+- Class: rviz/Views\n+  Expanded:\n+  - /Current View1\n+  Name: Views\n+Visualization Manager:\n+  Displays:\n+  - Alpha: 0.5\n+    Cell Size: 1\n+    Class: rviz/Grid\n+    Color: 160; 160; 164\n+    Enabled: true\n+    Line Style:\n+      Line Width: 0.029999999329447746\n+      Value: Lines\n+    Name: Grid\n+    Normal Cell Count: 0\n+    Offset:\n+      X: 0\n+      Y: 0\n+      Z: 0\n+    Plane: XY\n+    Plane Cell Count: 100\n+    Reference Frame: <Fixed Frame>\n+    Value: true\n+  - Angle Tolerance: 0.05000000074505806\n+    Class: rviz/Odometry\n+    Covariance:\n+      Orientation:\n+        Alpha: 0.20000000298023224\n+        Color: 64; 84; 191\n+        Color Style: Unique\n+        Frame: Local\n+        Offset: 1\n+        Scale: 1\n+        Value: true\n+      Position:\n+        Alpha: 0.10000000149011612\n+        Color: 138; 226; 52\n+        Scale: 1\n+        Value: true\n+      Value: false\n+    Enabled: true\n+    Keep: 10000\n+    Name: Odometry\n+    Position Tolerance: 0.10000000149011612\n+    Queue Size: 10\n+    Shape:\n+      Alpha: 1\n+      Axes Length: 1\n+      Axes Radius: 0.10000000149011612\n+      Color: 255; 25; 0\n+      Head Length: 0.07500000298023224\n+      Head Radius: 0.02500000037252903\n+      Shaft Length: 0.25\n+      Shaft Radius: 0.012500000186264515\n+      Value: Arrow\n+    Topic: /odom_filtered\n+    Unreliable: false\n+    Value: true\n+  Global Options:\n+    Fixed Frame: odom\n+  Tools:\n+  - Class: rviz/Interact\n+  - Class: rviz/MoveCamera\n+  - Class: rviz/Select\n+  - Class: rviz/FocusCamera\n+  - Class: rviz/Measure\n+  - Class: rviz/SetInitialPose\n+  - Class: rviz/SetGoal\n+  - Class: rviz/PublishPoint\n+  Views:\n+    Current:\n+      Angle: 0\n+      Class: rviz/TopDownOrtho\n+      Scale: 168.0491180419922\n+      X: 2\n+      Y: 0\n+    Saved: null\n+Window Geometry:\n+  Height: 1201\n+  QMainWindow State: 000000ff00000000fd00000003000000000000015600000413fc020000000afb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005c00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003d0000032e000000c900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000100044006900730070006c006100790073000000031c00000134000000c900fffffffb0000000a005600690065007700730100000371000000df000000a400ffffff000000010000010f00000413fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000000a00560069006500770073010000003d00000413000000a400fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b2000000000000000000000003000007340000003efc0100000002fb0000000800540069006d0065010000000000000734000002eb00fffffffb0000000800540069006d00650100000000000004500000000000000000000004c30000041300000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000\n+  Width: 1844\n+  X: 72\n+  Y: 27"},{"role":"user","content":"+Panels:\n+- Class: rviz/Displays\n+  Help Height: 70\n+  Name: Displays\n+  Property Tree Widget:\n+    Expanded:\n+    - /True Robot Pose1/Shape1\n+    - /Estimated Robot Pose1/Covariance1/Position1\n+    Splitter Ratio: 0.6058823466300964\n+  Tree Height: 757\n+- Class: rviz/Selection\n+  Name: Selection\n+- Class: rviz/Tool Properties\n+  Expanded:\n+  - /2D Pose Estimate1\n+  - /2D Nav Goal1\n+  - /Publish Point1\n+  Name: Tool Properties\n+- Class: rviz/Views\n+  Expanded:\n+  - /Current View1\n+  Name: Views\n+- Class: rviz/Time\n+  Name: Time\n+  SyncSource: True Beacons\n+Visualization Manager:\n+  Displays:\n+  - Alpha: 0.5\n+    Cell Size: 1\n+    Class: rviz/Grid\n+    Color: 160; 160; 164\n+    Enabled: false\n+    Line Style:\n+      Line Width: 0.029999999329447746\n+      Value: Lines\n+    Name: Grid\n+    Normal Cell Count: 0\n+    Offset:\n+      X: 0\n+      Y: 0\n+      Z: 0\n+    Plane: XY\n+    Plane Cell Count: 100\n+    Reference Frame: <Fixed Frame>\n+    Value: false\n+  - Alpha: 1\n+    Autocompute Intensity Bounds: true\n+    Autocompute Value Bounds:\n+      Max Value: 10\n+      Min Value: -10\n+      Value: true\n+    Axis: Z\n+    Channel Name: intensity\n+    Class: rviz/PointCloud2\n+    Color: 255; 25; 0\n+    Color Transformer: FlatColor\n+    Decay Time: 0\n+    Enabled: true\n+    Invert Rainbow: false\n+    Max Color: 239; 41; 41\n+    Min Color: 0; 0; 0\n+    Name: True Beacons\n+    Position Transformer: XYZ\n+    Queue Size: 10\n+    Selectable: true\n+    Size (Pixels): 3\n+    Size (m): 1.5\n+    Style: Spheres\n+    Topic: /true_beacons\n+    Unreliable: false\n+    Use Fixed Frame: true\n+    Use rainbow: true\n+    Value: true\n+  - Angle Tolerance: 0.10000000149011612\n+    Class: rviz/Odometry\n+    Covariance:\n+      Orientation:\n+        Alpha: 0.5\n+        Color: 255; 255; 127\n+        Color Style: Unique\n+        Frame: Local\n+        Offset: 1\n+        Scale: 1\n+        Value: true\n+      Position:\n+        Alpha: 0.30000001192092896\n+        Color: 204; 51; 204\n+        Scale: 1\n+        Value: true\n+      Value: false\n+    Enabled: true\n+    Keep: 1\n+    Name: True Robot Pose\n+    Position Tolerance: 0.10000000149011612\n+    Queue Size: 10\n+    Shape:\n+      Alpha: 1\n+      Axes Length: 1\n+      Axes Radius: 0.10000000149011612\n+      Color: 255; 25; 0\n+      Head Length: 5\n+      Head Radius: 3\n+      Shaft Length: 8\n+      Shaft Radius: 1\n+      Value: Arrow\n+    Topic: /ground_truth\n+    Unreliable: false\n+    Value: true\n+  - Alpha: 1\n+    Autocompute Intensity Bounds: true\n+    Autocompute Value Bounds:\n+      Max Value: 0\n+      Min Value: 0\n+      Value: true\n+    Axis: Z\n+    Channel Name: intensity\n+    Class: rviz/PointCloud2\n+    Color: 138; 226; 52\n+    Color Transformer: FlatColor\n+    Decay Time: 0\n+    Enabled: false\n+    Invert Rainbow: false\n+    Max Color: 255; 255; 255\n+    Min Color: 0; 0; 0\n+    Name: Prior Beacons\n+    Position Transformer: XYZ\n+    Queue Size: 10\n+    Selectable: true\n+    Size (Pixels): 3\n+    Size (m): 2\n+    Style: Spheres\n+    Topic: /prior_beacons\n+    Unreliable: false\n+    Use Fixed Frame: true\n+    Use rainbow: true\n+    Value: false\n+  - Alpha: 1\n+    Autocompute Intensity Bounds: true\n+    Autocompute Value Bounds:\n+      Max Value: 10\n+      Min Value: -10\n+      Value: true\n+    Axis: Z\n+    Channel Name: intensity\n+    Class: rviz/PointCloud2\n+    Color: 237; 212; 0\n+    Color Transformer: FlatColor\n+    Decay Time: 0\n+    Enabled: true\n+    Invert Rainbow: false\n+    Max Color: 255; 255; 255\n+    Min Color: 0; 0; 0\n+    Name: Estimated Beacons\n+    Position Transformer: XYZ\n+    Queue Size: 10\n+    Selectable: true\n+    Size (Pixels): 3\n+    Size (m): 2.5\n+    Style: Spheres\n+    Topic: /state_estimation/beacon_publisher/beacons\n+    Unreliable: false\n+    Use Fixed Frame: true\n+    Use rainbow: true\n+    Value: true\n+  - Angle Tolerance: 0.10000000149011612\n+    Class: rviz/Odometry\n+    Covariance:\n+      Orientation:\n+        Alpha: 0.5\n+        Color: 255; 255; 127\n+        Color Style: Unique\n+        Frame: Local\n+        Offset: 1\n+        Scale: 1\n+        Value: true\n+      Position:\n+        Alpha: 0.5\n+        Color: 237; 212; 0\n+        Scale: 10\n+        Value: true\n+      Value: true\n+    Enabled: true\n+    Keep: 1\n+    Name: Estimated Robot Pose\n+    Position Tolerance: 0.10000000149011612\n+    Queue Size: 10\n+    Shape:\n+      Alpha: 1\n+      Axes Length: 1\n+      Axes Radius: 0.10000000149011612\n+      Color: 237; 212; 0\n+      Head Length: 5\n+      Head Radius: 5\n+      Shaft Length: 8\n+      Shaft Radius: 1.5\n+      Value: Arrow\n+    Topic: /odom_filtered\n+    Unreliable: false\n+    Value: true\n+  Tools:\n+  - Class: rviz/Interact\n+  - Class: rviz/MoveCamera\n+  - Class: rviz/Select\n+  - Class: rviz/FocusCamera\n+  - Class: rviz/Measure\n+  - Class: rviz/SetInitialPose\n+  - Class: rviz/SetGoal\n+  - Class: rviz/PublishPoint\n+  Views:\n+    Current:\n+      Angle: 0\n+      Class: rviz/TopDownOrtho\n+      Scale: 5.1059746742248535\n+      X: 10.475910186767578\n+      Y: -13.87234878540039\n+    Saved: null\n+Window Geometry:\n+  Height: 1376\n+  QMainWindow State: 000000ff00000000fd000000040000000000000156000004befc0200000009fb0000001200530065006c0065006300740069006f006e00000001e10000009b0000005d00fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c006100790073010000003f0000037b000000cc00fffffffb0000000a0056006900650077007301000003c00000013d000000a900fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261000000010000010f000004befc0200000002fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000005000000003efc0100000002fb0000000800540069006d00650100000000000005000000027500fffffffb0000000800540069006d00650100000000000004500000000000000000000003a4000004be00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000\n+  Width: 1280\n+  X: 1280\n+  Y: 27"},{"role":"user","content":"+def test_convert_fuse_simple_tutorial_config():\n+    result = subprocess.run(\n+        [sys.executable, script(), config('fuse_simple_tutorial.rviz'), '-'],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        check=True)\n+\n+    output = result.stdout.decode()\n+    assert len(output) > 0\n+    assert len(result.stderr) == 0\n+\n+    yaml_output = yaml.safe_load(output)\n+    assert 'Background Color' in yaml_output['Visualization Manager']['Global Options'].keys()\n+\n+\n+def test_convert_range_sensor_tutorial_config():\n+    result = subprocess.run(\n+        [sys.executable, script(), config('range_sensor_tutorial.rviz'), '-'],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        check=True)\n+\n+    output = result.stdout.decode()\n+    assert len(output) > 0\n+    assert len(result.stderr) == 0\n+\n+    yaml_output = yaml.safe_load(output)\n+    assert 'Panels' in yaml_output.keys()\n+    assert 'Background Color' in yaml_output['Visualization Manager']['Global Options'].keys()\n+\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-To actually use Shared Memory the talker/listener example needs to be slightly rewritten to use a fixed size data type such as an unsigned integer. Adapting the publisher and subscription to use messages of type `std_msgs::msg::UInt64` instead leads to an example which uses Shared Memory to transport the data. See [Restrictions](#Restrictions) for further information about when Shared Memory transfer will be used.\n+To actually use Shared Memory the talker/listener example needs to be slightly rewritten to use a fixed size data type such as an unsigned integer. Adapting the publisher and subscription to use messages of type `std_msgs::msg::Uint32` instead leads to an example which uses Shared Memory to transport the data. See [Restrictions](#Restrictions) for further information about when Shared Memory transfer will be used."},{"role":"user","content":"-    std::unique_ptr<std_msgs::msg::UInt64> msg_;\n-    rclcpp::Publisher<std_msgs::msg::UInt64>::SharedPtr pub_;\n+    std::unique_ptr<std_msgs::msg::Uint32> msg_;\n+    rclcpp::Publisher<std_msgs::msg::UInt32>::SharedPtr pub_;"},{"role":"user","content":"-    pub_ = this->create_publisher<std_msgs::msg::UInt64>(\"chatter\", qos);\n+    pub_ = this->create_publisher<std_msgs::msg::Uint32>(\"chatter\", qos);"},{"role":"user","content":"-    msg_ = std::make_unique<std_msgs::msg::UInt64>();\n+    msg_ = std::make_unique<std_msgs::msg::Uint32>();"},{"role":"user","content":"-    rclcpp::Subscription<std_msgs::msg::UInt64>::SharedPtr sub_;\n+    rclcpp::Subscription<std_msgs::msg::Uint32>::SharedPtr sub_;"},{"role":"user","content":"-    sub_ = create_subscription<std_msgs::msg::UInt64>(\"chatter\", 10, callback);\n+    sub_ = create_subscription<std_msgs::msg::Uint32>(\"chatter\", 10, callback);"},{"role":"user","content":"-      [this](const std::shared_ptr<std_msgs::msg::UInt64> msg) -> void\n+      [this](const std::shared_ptr<std_msgs::msg::Uint32> msg) -> void"},{"role":"user","content":"-    msg_ = std::make_unique<std_msgs::msg::UInt64>();\n+    msg_ = std::make_unique<std_msgs::msg::Uint32>();"},{"role":"user","content":"-The publish overload here does not need to copy the data to Shared Memory since it already resides there. Hence no copy or serialization is performed and the data is transferred to any subscription in constant time (i.e. independent of the message size).\n+The publish overload here does not need to copy the data to Shared Memory since it already resides there. Hence no copy is performed and the data is transferred to any subscription in constant time (i.e. independent of the message size). Depending on the data type there serialization into the loaned message may still be required and publish will therefore not be independent of message size. This is not the case for [fixed size](#Types) data types.\n+\n+Note that to properly use loaning move semantics are essential, i.e. using `std::move` when publishing is required. This allows efficiently transferring ownership of the internal message data back to the middleware without copy overhead. As a consequence read access of `loaned_msg` after it was published is illegal (undefined behavior)."},{"role":"user","content":"-3. Reliability: Reliable\n-    - may be extended to Best Effort as well, but Shared Memory transfer is always reliable\n+3. Reliability: Reliable or Best Effort"},{"role":"user","content":"-These settings are used by default and applicable to a large class of applications.\n+These settings (with Reliability: Reliable) are used by default and applicable to a wide range of applications."},{"role":"user","content":"+\n+## Verifing Shared Memory Usage\n+\n+It is currently not possible to accurately check whether Shared Memory transfer actually takes place for a specific subscription. If the conditions in [Restrictions](#Restrictions) are met this should be the case. If the data rate or latency are beyond what is achievable using regular network communication this is an indication that at least partially Shared Memory communication via iceoryx is being used.\n+\n+Another way to check whether Shared Memory is used is running the iceoryx introspection client, which allows tracking of various statistics of the iceoryx communication, Shared Memory utilization being one of them.\n+\n+### Building the iceoryx introspection\n+\n+The introspection client is not build by default, so we need to do so manually.\n+The introspection depends on iceoryx_utils and iceoryx_posh and we will build against the libraries already build by the ROS 2 installation.\n+After installing ROS 2 as described in [Installation](#Installation) navigate to the ROS 2 workspace and execute\n+\n+```console\n+cd ros2_rolling\n+. ~/ros2_rolling/install/setup.bash\n+```\n+\n+In the introspection folder of the iceoryx repository (part of the ROS 2 installation) run cmake followed by make to build the introspection.\n+\n+```console\n+cd src/eclipse-iceoryx/iceoryx/tools/introspection\n+cmake -Bbuild\n+cd build\n+make\n+```\n+\n+Afterwards the executable *iox-introspection-client* should appear in the build folder.\n+\n+### Using the iceoryx introspection\n+\n+The introspection requires RouDi to be running since it receives the statistics information directly from the RouDi middleware daemon by subscribing to built-in topics.\n+\n+Start RouDi and any applications of your system, e.g. [talker and listener](#Using-Shared-Memory-in-the-example).\n+\n+The introspection is able to track the processes using iceoryx, the subscriptions using Shared Memory (those using network cannot be found here) and Shared Memory utilization data (i.e. the number and size of allocations in Shared Memory).\n+\n+Executing\n+\n+```console\n+./iox-introspection-client --h\n+```\n+\n+in the folder where the introspection was build provides us with a list of the various options. In the following we will display all statistics by running\n+\n+```console\n+./iox-introspection-client --all\n+```\n+\n+To verify that a particular connection is using Shared Memory we can proceed as follows. In the particular talker and listener example the internal ID of the talker and lister process should appear in the *Processes* section of the introspection. These IDs are unique but unfortunately cannot be easily traced back to the process.\n+\n+From the *Connections* section we can infer whether a specific topic is offered and whether a subscription to this topic exists. Note that AUTOSAR terminology is used for the displayed data but the topic information is available in the Instance and Event columns. Also note that the built-in topics used by the introspection are also listed.\n+\n+If a publisher which uses Shared Memory publishes data, the memory utilization changes. This is visible in the *MemPool Status* section in the part listed in Segment Id: 1. If Shared Memory is used, the number of chunks in use should go up until a specific saturation point where it will stagnate or start to flutuate slightly as chunks are freed by the suscribing party. This is related to the settings in the [configuration](#Configuration-file-options) as these essentially control how much Shared Memory a specific subscribtion can use at most.\n+\n+If we can observe memory chunks being used this is a strong indication that data is transferred by Shared Memory. However, this does not rule out that part of the communication (e.g. other subscriptions) is using the regular network tranfer. This cannot be conclusive in general if multiple subscriptions exist since we do not know which of them transfer data via Shared Memory by observing this statistic in isolation.\n+\n+The Min Free statistic is also important, as it counts the minimum number of chunks of a specific size that were free in a particular system execution (i.e. this can only decrease monotonically). If this is running low it indicates that there may be not enough Shared Memory available. This can be increased by using a different [Shared Memory configuration](#Iceoryx-Shared-Memory-Configuration).\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"- * \\param[in] initial_capacity the amount of initial capacity for the hash_map\n+ * \\param[in] initial_capacity the amount of initial capacity for the hash_map - this must be greater than zero and a power of 2"},{"role":"user","content":"+TEST_F(HashMapBaseTest, init_map_initial_capacity_not_power_of_two_fails) {\n+  rcutils_ret_t ret = rcutils_hash_map_init(\n+    &map, 3, sizeof(uint32_t), sizeof(uint32_t),\n+    test_hash_map_uint32_hash_func, test_uint32_cmp, &allocator);\n+  EXPECT_EQ(RCUTILS_RET_INVALID_ARGUMENT, ret) << rcutils_get_error_string().str;\n+}\n+"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  set(OGRE_CXX_FLAGS \"-Wno-misleading-indentation ${OGRE_CXX_FLAGS}\")\n+  set(OGRE_CXX_FLAGS \"-Wno-implicit-const-int-float-conversion ${OGRE_CXX_FLAGS}\")"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-name: ROS2 CI\n+name: ROS 2 CI"},{"role":"user","content":"-# ROS2 RMW for Eclipse Cyclone DDS\n+# ROS 2 RMW for Eclipse Cyclone DDS"},{"role":"user","content":"-**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS2. Make your **≡ƒÉó run like a ≡ƒÜÇ** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving).\n+**Easy, fast, reliable, small [Eclipse Cyclone DDS](https://github.com/eclipse-cyclonedds/cyclonedds) middleware** for ROS 2. Make your **≡ƒÉó run like a ≡ƒÜÇ** [Eclipse Cyclone DDS has great adopters](https://iot.eclipse.org/adopters/) and contributors in the ROS community and is an [Eclipse Foundation](https://www.eclipse.org) open source project of [Eclipse IoT](https://iot.eclipse.org) and [OpenADx](https://openadx.eclipse.org) (autonomous driving)."},{"role":"user","content":"-This package lets [*ROS2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n-Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS2 experience. Let the Cyclone blow you away!\n+This package lets [*ROS 2*](https://index.ros.org/doc/ros2) use [*Eclipse Cyclone DDS*](https://github.com/eclipse-cyclonedds/cyclonedds) as the underlying DDS implementation.\n+Cyclone DDS is ready to use. It seeks to give the fastest, easiest, and most robust ROS 2 experience. Let the Cyclone blow you away!"},{"role":"user","content":"-2. Set env variable and run ROS2 apps as usual:\n+2. Set env variable and run ROS 2 apps as usual:"},{"role":"user","content":"-If building ROS2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/master/ros2.repos)), you already have this package and Cyclone DDS:\n+If building ROS 2 from source ([ros2.repos](https://github.com/ros2/ros2/blob/master/ros2.repos)), you already have this package and Cyclone DDS:"},{"role":"user","content":"-  /* DDS publisher, subscriber used for ROS2 publishers and subscriptions */\n+  /* DDS publisher, subscriber used for ROS 2 publishers and subscriptions */"},{"role":"user","content":"-      /* ROS2 doesn't do keys, so SDK_KEY is trivial */\n+      /* ROS 2 doesn't do keys, so SDK_KEY is trivial */"},{"role":"user","content":"-      /* ROS2 doesn't do keys in a meaningful way yet */\n+      /* ROS 2 doesn't do keys in a meaningful way yet */"},{"role":"user","content":"-  /* ROS2 doesn't do keys in a meaningful way yet */\n+  /* ROS 2 doesn't do keys in a meaningful way yet */"},{"role":"user","content":"-  /* ROS2 doesn't do keys in a meaningful way yet */\n+  /* ROS 2 doesn't do keys in a meaningful way yet */"},{"role":"user","content":"-      /* ROS2 doesn't do keys in a meaningful way yet */\n+      /* ROS 2 doesn't do keys in a meaningful way yet */"},{"role":"user","content":"-  /* ROS2 doesn't do keys in a meaningful way yet, this is never called for topics without\n+  /* ROS 2 doesn't do keys in a meaningful way yet, this is never called for topics without"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include \"rmw_fastrtps_shared_cpp/rmw_context_impl.hpp\""},{"role":"user","content":"-  RCUTILS_CHECK_ARGUMENT_FOR_NULL(context, NULL);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);"},{"role":"user","content":"+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    context->impl,\n+    \"expected initialized context\",\n+    return nullptr);\n+  if (context->impl->is_shutdown) {\n+    RCUTILS_SET_ERROR_MSG(\"context has been shutdown\");\n+    return nullptr;\n+  }"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);\n+"},{"role":"user","content":"+#include \"rmw_fastrtps_shared_cpp/rmw_context_impl.hpp\""},{"role":"user","content":"-  RCUTILS_CHECK_ARGUMENT_FOR_NULL(context, NULL);\n+  RMW_CHECK_ARGUMENT_FOR_NULL(context, nullptr);"},{"role":"user","content":"-    return NULL);\n+    return nullptr);\n+  RMW_CHECK_FOR_NULL_WITH_MSG(\n+    context->impl,\n+    \"expected initialized context\",\n+    return nullptr);\n+  if (context->impl->is_shutdown) {\n+    RCUTILS_SET_ERROR_MSG(\"context has been shutdown\");\n+    return nullptr;\n+  }"},{"role":"user","content":"+  RMW_CHECK_ARGUMENT_FOR_NULL(node, RMW_RET_INVALID_ARGUMENT);\n+  RMW_CHECK_TYPE_IDENTIFIERS_MATCH(\n+    node,\n+    node->implementation_identifier,\n+    eprosima_fastrtps_identifier,\n+    return RMW_RET_INCORRECT_RMW_IMPLEMENTATION);"},{"role":"user","content":"+#include \"rmw/validate_namespace.h\"\n+#include \"rmw/validate_node_name.h\"\n+\n+#include \"rcpputils/scope_exit.hpp\""},{"role":"user","content":"-  if (!name) {\n-    RMW_SET_ERROR_MSG(\"name is null\");\n+  assert(identifier == context->implementation_identifier);\n+\n+  int validation_result = RMW_NODE_NAME_VALID;\n+  rmw_ret_t ret = rmw_validate_node_name(name, &validation_result, nullptr);\n+  if (RMW_RET_OK != ret) {"},{"role":"user","content":"-\n-  if (!namespace_) {\n-    RMW_SET_ERROR_MSG(\"namespace_ is null\");\n+  if (RMW_NODE_NAME_VALID != validation_result) {\n+    const char * reason = rmw_node_name_validation_result_string(validation_result);\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"invalid node name: %s\", reason);\n+    return nullptr;\n+  }\n+  validation_result = RMW_NAMESPACE_VALID;\n+  ret = rmw_validate_namespace(namespace_, &validation_result, nullptr);\n+  if (RMW_RET_OK != ret) {\n+    return nullptr;\n+  }\n+  if (RMW_NAMESPACE_VALID != validation_result) {\n+    const char * reason = rmw_node_name_validation_result_string(validation_result);\n+    RMW_SET_ERROR_MSG_WITH_FORMAT_STRING(\"invalid node namespace: %s\", reason);"},{"role":"user","content":"-  rmw_node_t * node_handle = nullptr;"},{"role":"user","content":"-\n-  node_handle = rmw_node_allocate();\n-  if (!node_handle) {\n-    RMW_SET_ERROR_MSG(\"failed to allocate rmw_node_t\");\n-    goto fail;\n+  rmw_node_t * node_handle = rmw_node_allocate();\n+  if (nullptr == node_handle) {\n+    RMW_SET_ERROR_MSG(\"failed to allocate node\");\n+    return nullptr;"},{"role":"user","content":"+  auto cleanup_node = rcpputils::make_scope_exit(\n+    [node_handle]() {\n+      rmw_free(const_cast<char *>(node_handle->name));\n+      rmw_free(const_cast<char *>(node_handle->namespace_));\n+      rmw_node_free(node_handle);\n+    });"},{"role":"user","content":"-  if (!node_handle->name) {\n-    RMW_SET_ERROR_MSG(\"failed to allocate memory\");\n-    node_handle->namespace_ = nullptr;  // to avoid free on uninitialized memory\n-    goto fail;\n+  if (nullptr == node_handle->name) {\n+    RMW_SET_ERROR_MSG(\"failed to copy node name\");\n+    return nullptr;"},{"role":"user","content":"-  if (!node_handle->namespace_) {\n-    RMW_SET_ERROR_MSG(\"failed to allocate memory\");\n-    goto fail;\n+  if (nullptr == node_handle->namespace_) {\n+    RMW_SET_ERROR_MSG(\"failed to copy node namespace\");\n+    return nullptr;"},{"role":"user","content":"+"},{"role":"user","content":"-        identifier,\n+        node_handle->implementation_identifier,"},{"role":"user","content":"-      goto fail;\n+      return nullptr;"},{"role":"user","content":"+  cleanup_node.cancel();"},{"role":"user","content":"-fail:\n-  if (node_handle) {\n-    rmw_free(const_cast<char *>(node_handle->namespace_));\n-    node_handle->namespace_ = nullptr;\n-    rmw_free(const_cast<char *>(node_handle->name));\n-    node_handle->name = nullptr;\n-  }\n-  rmw_node_free(node_handle);\n-  return nullptr;"},{"role":"user","content":"-  rmw_ret_t result_ret = RMW_RET_OK;\n-  if (!node) {\n-    RMW_SET_ERROR_MSG(\"node handle is null\");\n-    return RMW_RET_ERROR;\n-  }\n-\n-  if (node->implementation_identifier != identifier) {\n-    RMW_SET_ERROR_MSG(\"node handle not from this implementation\");\n-    return RMW_RET_ERROR;\n-  }\n+  assert(node->implementation_identifier == identifier);"},{"role":"user","content":"-    result_ret = __rmw_publish(\n+    rmw_ret_t ret = __rmw_publish("},{"role":"user","content":"-    if (RMW_RET_OK != result_ret) {\n-      return result_ret;\n+    if (RMW_RET_OK != ret) {\n+      return ret;"},{"role":"user","content":"-  node->name = nullptr;"},{"role":"user","content":"-  node->namespace_ = nullptr;"},{"role":"user","content":"-"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+import argparse"},{"role":"user","content":"-def main(args=None):\n-    rclpy.init(args=args)\n+def main():\n+    rclpy.init(args=sys.argv)\n+\n+    args_without_ros = rclpy.utilities.remove_ros_args(sys.argv)\n+    parser = argparse.ArgumentParser(\n+        description='Create a diagram of the TF frames being broadcast over ROS')\n+    parser.add_argument(\n+        '--wait-time', '-t', type=float, default=5.0,\n+        help='Listen to the /tf topic for this many seconds before rendering the frame tree')\n+    parsed_args = parser.parse_args(args=args_without_ros[1:])"},{"role":"user","content":"-    node.get_logger().info('Listening to tf data for 5 seconds...')\n+    node.get_logger().info(f'Listening to tf data for {parsed_args.wait_time} seconds...')"},{"role":"user","content":"-    while (time.time() - start_time) < 5.0:\n+    while (time.time() - start_time) < parsed_args.wait_time:"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-            cmd=(['ros2', 'topic', 'pub', '-t', '1', '--max-wait-time-secs', '20', topic,\n+            cmd=(['ros2', 'topic', 'pub', '-t', '10', '--max-wait-time-secs', '20', topic,"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+        self.__context = None"},{"role":"user","content":"-            try:\n-                if self.__context is not None:\n-                    raise RuntimeError\n-            except AttributeError:\n-                self.__context = _rclpy.Context(\n-                    args if args is not None else sys.argv,\n-                    domain_id if domain_id is not None else _rclpy.RCL_DEFAULT_DOMAIN_ID)\n-                if initialize_logging and not self._logging_initialized:\n-                    with g_logging_configure_lock:\n-                        g_logging_ref_count += 1\n-                        if g_logging_ref_count == 1:\n-                            _rclpy.rclpy_logging_configure(self.__context)\n-                    self._logging_initialized = True\n+\n+            if self.__context is not None:\n+                raise RuntimeError('Context.init() must only be called once')\n+\n+            self.__context = _rclpy.Context(\n+                args if args is not None else sys.argv,\n+                domain_id if domain_id is not None else _rclpy.RCL_DEFAULT_DOMAIN_ID)\n+            if initialize_logging and not self._logging_initialized:\n+                with g_logging_configure_lock:\n+                    g_logging_ref_count += 1\n+                    if g_logging_ref_count == 1:\n+                        _rclpy.rclpy_logging_configure(self.__context)\n+                self._logging_initialized = True"},{"role":"user","content":"-        # imported locally to avoid loading extensions on module import\n-        try:\n-            with self.__context, self._lock:\n+        with self._lock:\n+            if self.__context is None:\n+                return False\n+            with self.__context:"},{"role":"user","content":"-        except AttributeError:\n-            return False"},{"role":"user","content":"-        # imported locally to avoid loading extensions on module import\n+        if self.__context is None:\n+            raise RuntimeError('Context must be initialized before it can be shutdown')"},{"role":"user","content":"-        # imported locally to avoid loading extensions on module import\n+        if self.__context is None:\n+            return"},{"role":"user","content":"+        if self.__context is None:\n+            raise RuntimeError('Context must be initialized before it can have a domain id')"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-                            'Allowed sequence item types are bool, int, float, str.'\n+                            'Allowed sequence item types are bool, int, float, str. '\n+                            'Got inconsistent input for \"{}\"'.format(evaluated_name)"},{"role":"user","content":"-                        ', Sequence[int], Sequence[float], Sequence[str]. Got {}.'\n+                        ', Sequence[int], Sequence[float], Sequence[str]. Got {} for \"{}\". '"},{"role":"user","content":"-                        '(value, value_type=str)'.format(type(yaml_evaluated_value))\n+                        '(value, value_type=str)'.format(\n+                            type(yaml_evaluated_value),\n+                            evaluated_name\n+                        )"},{"role":"user","content":"-                        'Allowed sequence item types are bool, int, float, str.'\n+                        'Allowed sequence item types are bool, int, float, str. '\n+                        'Got inconsistent input for \"{}\"'.format(evaluated_name)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+# Copyright 2005-2019 NumPy Developers.\n+# Copyright 2022 Open Source Robotics Foundation, Inc.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are met:\n+#\n+#    * Redistributions of source code must retain the above copyright\n+#      notice, this list of conditions and the following disclaimer.\n+#\n+#    * Redistributions in binary form must reproduce the above copyright\n+#      notice, this list of conditions and the following disclaimer in the\n+#      documentation and/or other materials provided with the distribution.\n+#\n+#    * Neither the name of the Willow Garage, Inc. nor the names of its\n+#      contributors may be used to endorse or promote products derived from\n+#      this software without specific prior written permission.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+# This is compatibility code for older versions of numpy that lack these functions.\n+# The original code was copied from:\n+# https://github.com/numpy/numpy/blob/3dec7099ce38cb189880f6f69df318f35ff9a5ea/numpy/lib/recfunctions.py\n+# and then lightly edited for style.\n+\n+import numpy as np\n+\n+\n+def _get_fields_and_offsets(dt, offset=0):\n+    # counts up elements in subarrays, including nested subarrays, and returns\n+    # base dtype and count\n+    def count_elem(dt):\n+        count = 1\n+        while dt.shape != ():\n+            for size in dt.shape:\n+                count *= size\n+            dt = dt.base\n+        return dt, count\n+\n+    fields = []\n+    for name in dt.names:\n+        field = dt.fields[name]\n+        f_dt, f_offset = field[0], field[1]\n+        f_dt, n = count_elem(f_dt)\n+\n+        if f_dt.names is None:\n+            fields.append((np.dtype((f_dt, (n,))), n, f_offset + offset))\n+        else:\n+            subfields = _get_fields_and_offsets(f_dt, f_offset + offset)\n+            size = f_dt.itemsize\n+\n+            for i in range(n):\n+                if i == 0:\n+                    # optimization: avoid list comprehension if no subarray\n+                    fields.extend(subfields)\n+                else:\n+                    fields.extend([(d, c, o + i*size) for d, c, o in subfields])\n+    return fields\n+\n+\n+def structured_to_unstructured(arr, dtype=None, copy=False, casting='unsafe'):\n+    if arr.dtype.names is None:\n+        raise ValueError('arr must be a structured array')\n+\n+    fields = _get_fields_and_offsets(arr.dtype)\n+    n_fields = len(fields)\n+    if n_fields == 0 and dtype is None:\n+        raise ValueError('arr has no fields. Unable to guess dtype')\n+    elif n_fields == 0:\n+        # too many bugs elsewhere for this to work now\n+        raise NotImplementedError('arr with no fields is not supported')\n+\n+    dts, counts, offsets = zip(*fields)\n+    names = ['f{}'.format(n) for n in range(n_fields)]\n+\n+    if dtype is None:\n+        out_dtype = np.result_type(*[dt.base for dt in dts])\n+    else:\n+        out_dtype = dtype\n+\n+    # Use a series of views and casts to convert to an unstructured array:\n+\n+    # first view using flattened fields (doesn't work for object arrays)\n+    # Note: dts may include a shape for subarrays\n+    flattened_fields = np.dtype({'names': names,\n+                                 'formats': dts,\n+                                 'offsets': offsets,\n+                                 'itemsize': arr.dtype.itemsize})\n+    arr = arr.view(flattened_fields)\n+\n+    # next cast to a packed format with all fields converted to new dtype\n+    packed_fields = np.dtype({'names': names,\n+                              'formats': [(out_dtype, dt.shape) for dt in dts]})\n+    arr = arr.astype(packed_fields, copy=copy, casting=casting)\n+\n+    # finally is it safe to view the packed fields as the unstructured type\n+    return arr.view((out_dtype, (sum(counts),)))\n+\n+\n+def unstructured_to_structured(arr, dtype=None, names=None, align=False,\n+                               copy=False, casting='unsafe'):\n+    if arr.shape == ():\n+        raise ValueError('arr must have at least one dimension')\n+    n_elem = arr.shape[-1]\n+    if n_elem == 0:\n+        # too many bugs elsewhere for this to work now\n+        raise NotImplementedError('last axis with size 0 is not supported')\n+\n+    if dtype is None:\n+        if names is None:\n+            names = ['f{}'.format(n) for n in range(n_elem)]\n+        out_dtype = np.dtype([(n, arr.dtype) for n in names], align=align)\n+        fields = _get_fields_and_offsets(out_dtype)\n+        dts, counts, offsets = zip(*fields)\n+    else:\n+        if names is not None:\n+            raise ValueError(\"don't supply both dtype and names\")\n+        # sanity check of the input dtype\n+        fields = _get_fields_and_offsets(dtype)\n+        if len(fields) == 0:\n+            dts, counts, offsets = [], [], []\n+        else:\n+            dts, counts, offsets = zip(*fields)\n+\n+        if n_elem != sum(counts):\n+            raise ValueError('The length of the last dimension of arr must '\n+                             'be equal to the number of fields in dtype')\n+        out_dtype = dtype\n+        if align and not out_dtype.isalignedstruct:\n+            raise ValueError('align was True but dtype is not aligned')\n+\n+    names = ['f{}'.format(n) for n in range(len(fields))]\n+\n+    # Use a series of views and casts to convert to a structured array:\n+\n+    # first view as a packed structured array of one dtype\n+    packed_fields = np.dtype({'names': names,\n+                              'formats': [(arr.dtype, dt.shape) for dt in dts]})\n+    arr = np.ascontiguousarray(arr).view(packed_fields)\n+\n+    # next cast to an unpacked but flattened format with varied dtypes\n+    flattened_fields = np.dtype({'names': names,\n+                                 'formats': dts,\n+                                 'offsets': offsets,\n+                                 'itemsize': out_dtype.itemsize})\n+    arr = arr.astype(flattened_fields, copy=copy, casting=casting)\n+\n+    # finally view as the final nested dtype and remove the last axis\n+    return arr.view(out_dtype)[..., 0]"},{"role":"user","content":"-from numpy.lib.recfunctions import (structured_to_unstructured,\n-                                    unstructured_to_structured)\n+try:\n+    from numpy.lib.recfunctions import (structured_to_unstructured, unstructured_to_structured)\n+except ImportError:\n+    from sensor_msgs_py.numpy_compat import (structured_to_unstructured,\n+                                             unstructured_to_structured)\n+"},{"role":"user","content":"-from numpy.lib.recfunctions import structured_to_unstructured\n+try:\n+    from numpy.lib.recfunctions import structured_to_unstructured\n+except ImportError:\n+    from sensor_msgs_py.numpy_compat import structured_to_unstructured\n+"},{"role":"user","content":"-        print(thispcd)\n-        print(pcd3)"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+ * ```"},{"role":"user","content":"- *\n+ * ```"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-# rmw_dds_common\n-\n-Package with a common implementation of Node discovery for all DDS based `rmw` implementations, including:\n-\n-- A generic [`GraphCache`](rmw_dds_common/include/rmw_dds_common/graph_cache.hpp) to track DDS entities such as participants and data readers and writers, plus ROS nodes as an additional abstraction for any DDS based `rmw` implementation to use\n-- Common messages to communicate [ROS nodes discovery information](https://github.com/ros2/design/pull/250):\n-  - [`rmw_dds_common/msg/Gid`](rmw_dds_common/msg/Gid.msg)\n-  - [`rmw_dds_common/msg/NodeEntitiesInfo`](rmw_dds_common/msg/NodeEntitiesInfo.msg)\n-  - [`rmw_dds_common/msg/ParticipantEntitiesInfo`](rmw_dds_common/msg/ParticipantEntitiesInfo.msg)\n-- Some useful data types and utilities:\n-  - A generic [`Context`](rmw_dds_common/include/rmw_dds_common/context.hpp) type to withhold most state needed to implement [ROS nodes discovery](https://github.com/ros2/design/pull/250)\n-  - [Comparison utilities and some C++ operator overloads](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) for `rmw_gid_t` instances\n-  - [Conversion utilities](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) between `rmw_dds_common/msg/Gid` messages and `rmw_gid_t` instances\n+# rmw_dds_common: ROS 2 C++ utilities for DDS-based RMWs"},{"role":"user","content":"+`rmw_dds_common` is a collection of C++ APIs to support DDS based, C++ RMW implementations. "},{"role":"user","content":"+\n+## API\n+\n+This package contains:\n+\n+- Generic graph cache\n+- Common discovery messages\n+- Data types and utilities\n+\n+See [feature list](rmw_dds_common/docs/FEATURES.md) for further reference."},{"role":"user","content":"-`rmw_dds_common` does not yet have a list of features.\n+`rmw_dds_common` has a documented [feature list](docs/FEATURES.md)."},{"role":"user","content":"-`rmw_dds_common` does not currently track test coverage.\n+`rmw_dds_common` follows the recommendations for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#coverage), and opts to use branch coverage instead of line coverage.\n+\n+This includes:\n+\n+- tracking and reporting line coverage statistics\n+- achieving and maintaining a reasonable branch line coverage (90-100%)\n+- no lines are manually skipped in coverage calculations\n+\n+Changes are required to make a best effort to keep or increase coverage before being accepted, but decreases are allowed if properly justified and accepted by reviewers.\n+\n+Current coverage statistics can be viewed [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_dds_common_rmw_dds_common_include_rmw_dds_common/) and [here](https://ci.ros2.org/job/ci_linux_coverage/lastSuccessfulBuild/cobertura/src_ros2_rmw_dds_common_rmw_dds_common_src/). This package does not yet meet the 95% coverage guideline, but it is currently above 90%.\n+\n+A summary of how these statistics are calculated can be found in the [ROS 2 On-boarding guide](https://index.ros.org/doc/ros2/Contributing/ROS-2-On-boarding-Guide/#note-on-coverage-runs)."},{"role":"user","content":"+# rmw_dds_common Features\n+\n+This package includes:\n+\n+- A generic [`GraphCache`](rmw_dds_common/include/rmw_dds_common/graph_cache.hpp) to track DDS entities such as participants and data readers and writers, plus ROS nodes as an additional abstraction for any DDS based `rmw` implementation to use\n+- Common messages to communicate [ROS nodes discovery information](https://github.com/ros2/design/pull/250):\n+  - [`rmw_dds_common/msg/Gid`](rmw_dds_common/msg/Gid.msg)\n+  - [`rmw_dds_common/msg/NodeEntitiesInfo`](rmw_dds_common/msg/NodeEntitiesInfo.msg)\n+  - [`rmw_dds_common/msg/ParticipantEntitiesInfo`](rmw_dds_common/msg/ParticipantEntitiesInfo.msg)\n+- Some useful data types and utilities:\n+  - A generic [`Context`](rmw_dds_common/include/rmw_dds_common/context.hpp) type to withhold most state needed to implement [ROS nodes discovery](https://github.com/ros2/design/pull/250)\n+  - [Comparison utilities and some C++ operator overloads](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) for `rmw_gid_t` instances\n+  - [Conversion utilities](rmw_dds_common/include/rmw_dds_common/gid_utils.hpp) between `rmw_dds_common/msg/Gid` messages and `rmw_gid_t` instances"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-import argparse\n-"},{"role":"user","content":"+from typing import Optional"},{"role":"user","content":"-    depth: int = -1, history: str = None,\n+    depth: Optional[int] = None, history: str = None,"},{"role":"user","content":"-    if depth >= 0:\n+    if depth and depth >= 0:"},{"role":"user","content":"-"},{"role":"user","content":"-\n-\n-def add_qos_arguments_to_argument_parser(\n-    parser: argparse.ArgumentParser, is_publisher: bool = True, default_preset: str = 'sensor_data'\n-) -> None:\n-    \"\"\"Extend an existing ArgumentParser to allow input of QoS policy overrides.\"\"\"\n-    verb = 'publish' if is_publisher else 'subscribe'\n-    parser.add_argument(\n-        '--qos-profile',\n-        choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n-        default=default_preset,\n-        help='Quality of service preset profile to {} with (default: {})'\n-             .format(verb, default_preset))\n-    default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(\n-        default_preset)\n-    parser.add_argument(\n-        '--qos-depth', metavar='N', type=int, default=-1,\n-        help='Queue size setting to {} with '\n-             '(overrides depth value of --qos-profile option)'\n-             .format(verb))\n-    parser.add_argument(\n-        '--qos-history',\n-        choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n-        help='History of samples setting to {} with '\n-             '(overrides history value of --qos-profile option, default: {})'\n-             .format(verb, default_profile.history.short_key))\n-    parser.add_argument(\n-        '--qos-reliability',\n-        choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n-        help='Quality of service reliability setting to {} with '\n-             '(overrides reliability value of --qos-profile option, default: {})'\n-             .format(verb, default_profile.reliability.short_key))\n-    parser.add_argument(\n-        '--qos-durability',\n-        choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n-        help='Quality of service durability setting to {} with '\n-             '(overrides durability value of --qos-profile option, default: {})'\n-             .format(verb, default_profile.durability.short_key))"},{"role":"user","content":"+from rclpy.qos import QoSDurabilityPolicy\n+from rclpy.qos import QoSPresetProfiles"},{"role":"user","content":"+from rclpy.qos import QoSReliabilityPolicy"},{"role":"user","content":"-from ros2topic.api import add_qos_arguments_to_argument_parser"},{"role":"user","content":"+default_profile_str = 'sensor_data'"},{"role":"user","content":"-        add_qos_arguments_to_argument_parser(\n-            parser, is_publisher=False, default_preset='sensor_data')\n+        parser.add_argument(\n+            '--qos-profile',\n+            choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n+            help='Quality of service preset profile to subscribe with (default: {})'\n+                 .format(default_profile_str))\n+        default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(default_profile_str)\n+        parser.add_argument(\n+            '--qos-depth', metavar='N', type=int,\n+            help='Queue size setting to subscribe with '\n+                 '(overrides depth value of --qos-profile option)')\n+        parser.add_argument(\n+            '--qos-history',\n+            choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n+            help='History of samples setting to subscribe with '\n+                 '(overrides history value of --qos-profile option, default: {})'\n+                 .format(default_profile.history.short_key))\n+        parser.add_argument(\n+            '--qos-reliability',\n+            choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n+            help='Quality of service reliability setting to subscribe with '\n+                 '(overrides reliability value of --qos-profile option, default: '\n+                 'Automatically match existing publishers )')\n+        parser.add_argument(\n+            '--qos-durability',\n+            choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n+            help='Quality of service durability setting to subscribe with '\n+                 '(overrides durability value of --qos-profile option, default: '\n+                 'Automatically match existing publishers )')"},{"role":"user","content":"+    def choose_qos(self, node, args):\n+\n+        if (args.qos_profile is not None or\n+                args.qos_reliability is not None or\n+                args.qos_durability is not None or\n+                args.qos_depth is not None or\n+                args.qos_history is not None):\n+\n+            if args.qos_profile is None:\n+                args.qos_profile = default_profile_str\n+            return qos_profile_from_short_keys(args.qos_profile,\n+                                               reliability=args.qos_reliability,\n+                                               durability=args.qos_durability,\n+                                               depth=args.qos_depth,\n+                                               history=args.qos_history)\n+\n+        qos_profile = QoSPresetProfiles.get_from_short_key(default_profile_str)\n+        reliability_reliable_endpoints_count = 0\n+        durability_transient_local_endpoints_count = 0\n+\n+        pubs_info = node.get_publishers_info_by_topic(args.topic_name)\n+        publishers_count = len(pubs_info)\n+        if publishers_count == 0:\n+            return qos_profile\n+\n+        for info in pubs_info:\n+            if (info.qos_profile.reliability == QoSReliabilityPolicy.RELIABLE):\n+                reliability_reliable_endpoints_count += 1\n+            if (info.qos_profile.durability == QoSDurabilityPolicy.TRANSIENT_LOCAL):\n+                durability_transient_local_endpoints_count += 1\n+\n+        # If all endpoints are reliable, ask for reliable\n+        if reliability_reliable_endpoints_count == publishers_count:\n+            qos_profile.reliability = QoSReliabilityPolicy.RELIABLE\n+        else:\n+            if reliability_reliable_endpoints_count > 0:\n+                print(\n+                    'Some, but not all, publishers are offering '\n+                    'QoSReliabilityPolicy.RELIABLE. Falling back to '\n+                    'QoSReliabilityPolicy.BEST_EFFORT as it will connect '\n+                    'to all publishers'\n+                )\n+            qos_profile.reliability = QoSReliabilityPolicy.BEST_EFFORT\n+\n+        # If all endpoints are transient_local, ask for transient_local\n+        if durability_transient_local_endpoints_count == publishers_count:\n+            qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL\n+        else:\n+            if durability_transient_local_endpoints_count > 0:\n+                print(\n+                    'Some, but not all, publishers are offering '\n+                    'QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to '\n+                    'QoSDurabilityPolicy.VOLATILE as it will connect '\n+                    'to all publishers'\n+                )\n+            qos_profile.durability = QoSDurabilityPolicy.VOLATILE\n+\n+        return qos_profile\n+"},{"role":"user","content":"-        qos_profile = qos_profile_from_short_keys(\n-            args.qos_profile,\n-            reliability=args.qos_reliability,\n-            durability=args.qos_durability,\n-            depth=args.qos_depth,\n-            history=args.qos_history)\n-"},{"role":"user","content":"+\n+            qos_profile = self.choose_qos(node, args)\n+"},{"role":"user","content":"-from ros2topic.api import add_qos_arguments_to_argument_parser"},{"role":"user","content":"+default_profile_str = 'system_default'"},{"role":"user","content":"-        add_qos_arguments_to_argument_parser(\n-            parser, is_publisher=True, default_preset='system_default')\n+        parser.add_argument(\n+            '--qos-profile',\n+            choices=rclpy.qos.QoSPresetProfiles.short_keys(),\n+            default=default_profile_str,\n+            help='Quality of service preset profile to {} with (default: {})'\n+                 .format('publish', default_profile_str))\n+        default_profile = rclpy.qos.QoSPresetProfiles.get_from_short_key(\n+            default_profile_str)\n+        parser.add_argument(\n+            '--qos-depth', metavar='N', type=int, default=-1,\n+            help='Queue size setting to publish with '\n+                 '(overrides depth value of --qos-profile option)')\n+        parser.add_argument(\n+            '--qos-history',\n+            choices=rclpy.qos.QoSHistoryPolicy.short_keys(),\n+            help='History of samples setting to publish with '\n+                 '(overrides history value of --qos-profile option, default: {})'\n+                 .format(default_profile.history.short_key))\n+        parser.add_argument(\n+            '--qos-reliability',\n+            choices=rclpy.qos.QoSReliabilityPolicy.short_keys(),\n+            help='Quality of service reliability setting to publish with '\n+                 '(overrides reliability value of --qos-profile option, default: {})'\n+                 .format(default_profile.reliability.short_key))\n+        parser.add_argument(\n+            '--qos-durability',\n+            choices=rclpy.qos.QoSDurabilityPolicy.short_keys(),\n+            help='Quality of service durability setting to publish with '\n+                 '(overrides durability value of --qos-profile option, default: {})'\n+                 .format(default_profile.durability.short_key))"},{"role":"user","content":"+\n+    qos_profile_name = args.qos_profile\n+    if not qos_profile_name:\n+        qos_profile_name = default_profile_str\n+"},{"role":"user","content":"-        args.qos_profile, reliability=args.qos_reliability, durability=args.qos_durability,\n+        qos_profile_name, reliability=args.qos_reliability, durability=args.qos_durability,"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  if (RCUTILS_UNLIKELY(!g_rcutils_logging_initialized)) { \\\n-    rcutils_ret_t ret = rcutils_logging_initialize(); \\\n-    if (ret != RCUTILS_RET_OK) { \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n-        \"[rcutils|\" __FILE__ \":\" RCUTILS_STRINGIFY(__LINE__) \\\n-        \"] error initializing logging: \"); \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n-      RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\"); \\\n-      rcutils_reset_error(); \\\n+  do { \\\n+    if (RCUTILS_UNLIKELY(!g_rcutils_logging_initialized)) { \\\n+      if (rcutils_logging_initialize() != RCUTILS_RET_OK) { \\\n+        RCUTILS_SAFE_FWRITE_TO_STDERR( \\\n+          \"[rcutils|\" __FILE__ \":\" RCUTILS_STRINGIFY(__LINE__) \\\n+          \"] error initializing logging: \"); \\\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(rcutils_get_error_string().str); \\\n+        RCUTILS_SAFE_FWRITE_TO_STDERR(\"\\n\"); \\\n+        rcutils_reset_error(); \\\n+      } \\"},{"role":"user","content":"-  }\n+  } while (0)"},{"role":"user","content":"-    RCUTILS_LOGGING_AUTOINIT \\\n+    RCUTILS_LOGGING_AUTOINIT; \\"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  // *INDENT-OFF* (prevent uncrustify from making unnecessary indents here)\n-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  // *INDENT-ON*"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  // *INDENT-OFF* (prevent uncrustify from making unnecessary indents here)\n-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  // *INDENT-ON*"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"user","content":"-  RCUTILS_LOGGING_AUTOINIT\n+  RCUTILS_LOGGING_AUTOINIT;"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  src/gid.cpp"},{"role":"user","content":"-  memset(buf, 0, CDR_HEADER_SIZE);\n+  std::memset(buf, 0, CDR_HEADER_SIZE);"},{"role":"user","content":"-    memcpy(buf_ + offset_, src.c_str(), src.size() + 1);\n+    std::memcpy(buf_ + offset_, src.c_str(), src.size() + 1);"},{"role":"user","content":"-    memcpy(buf_ + offset_, src.data(), sizeof(char16_t) * src.size());\n+    std::memcpy(buf_ + offset_, src.data(), sizeof(char16_t) * src.size());"},{"role":"user","content":"-    memcpy(buf_ + offset_, src.data, src.size + 1);\n+    std::memcpy(buf_ + offset_, src.data, src.size + 1);"},{"role":"user","content":"-    memcpy(buf_ + offset_, src.data, sizeof(char16_t) * src.size);\n+    std::memcpy(buf_ + offset_, src.data, sizeof(char16_t) * src.size);"},{"role":"user","content":"-    memcpy(buf_ + offset_, arr, cnt * sizeof(uint8_t));\n+    std::memcpy(buf_ + offset_, arr, cnt * sizeof(uint8_t));"},{"role":"user","content":"-    memcpy(buf_ + offset_, arr, cnt * sizeof(uint16_t));\n+    std::memcpy(buf_ + offset_, arr, cnt * sizeof(uint16_t));"},{"role":"user","content":"-    memcpy(buf_ + offset_, arr, cnt * sizeof(uint32_t));\n+    std::memcpy(buf_ + offset_, arr, cnt * sizeof(uint32_t));"},{"role":"user","content":"-    memcpy(buf_ + offset_, arr, cnt * sizeof(uint64_t));\n+    std::memcpy(buf_ + offset_, arr, cnt * sizeof(uint64_t));"},{"role":"user","content":"-#include <cstring>\n-#include <iostream>\n-#include <map>\n-#include <set>\n-#include <string>\n-#include <vector>\n-"},{"role":"user","content":"+#include \"rmw_dds_common/gid_utils.hpp\"\n+"},{"role":"user","content":"-inline\n-void guid_to_gid(const dds_GUID_t & guid, rmw_gid_t & gid)\n-{\n-  static_assert(\n-    RMW_GID_STORAGE_SIZE >= sizeof(guid),\n-    \"rmw_gid_t type too small for an dds GUID\");\n-  memset(&gid, 0, sizeof(gid));\n-  memcpy(gid.data, reinterpret_cast<const void *>(&guid), sizeof(guid));\n-  gid.implementation_identifier = RMW_GURUMDDS_ID;\n-}\n-\n-inline\n-void entity_get_gid(dds_Entity * const entity, rmw_gid_t & gid)\n+void ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds);\n+\n+void dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros);\n+\n+void guid_to_gid(const dds_GUID_t & guid, rmw_gid_t & gid);\n+\n+void entity_get_gid(dds_Entity * const entity, rmw_gid_t & gid);\n+/**\n+ * Structure to hold GUID information for DDS instances.\n+ */\n+struct Guid_t: public dds_GUID_t"},{"role":"user","content":"-  dds_GUID_t dds_guid;\n-  if (dds_Entity_get_guid(entity, &dds_guid) == dds_RETCODE_OK) {\n-    guid_to_gid(dds_guid, gid);\n-  }\n-}\n+  static constexpr uint32_t ENTITYID_PARTICIPANT = 0x000001C1;\n+\n+  Guid_t();\n+\n+  Guid_t(const dds_GUID_t & other);\n+\n+  Guid_t(const dds_ParticipantBuiltinTopicData& builtin_topic_data);\n+\n+  template<typename TBuiltinTopicData>\n+  Guid_t(const TBuiltinTopicData& builtin_topic_data);\n+\n+  template<typename TBuiltinTopicData>\n+  static Guid_t for_participant(const TBuiltinTopicData& builtin_topic_data);\n+\n+  bool operator==(const dds_GUID_t & other) const;\n+\n+  bool operator!=(const Guid_t & other) const;\n+\n+  bool operator<(const Guid_t & other) const;\n+}; // struct Guid_t"},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.inl\"\n+"},{"role":"user","content":"+#ifndef RMW_GURUMDDS__GID_INL_\n+#define RMW_GURUMDDS__GID_INL_\n+\n+#include <cstring>\n+\n+namespace rmw_gurumdds_cpp\n+{\n+inline void ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds)\n+{\n+  std::memcpy(guid_dds, guid_ros, 12);\n+  std::memcpy(&guid_dds[12], &guid_ros[12], 4);\n+}\n+\n+inline void dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros)\n+{\n+  std::memcpy(guid_ros, guid_dds, 12);\n+  std::memcpy(&guid_ros[12], &guid_dds[12], 4);\n+}\n+\n+inline void guid_to_gid(const dds_GUID_t & guid, rmw_gid_t & gid)\n+{\n+  static_assert(\n+    RMW_GID_STORAGE_SIZE >= sizeof(guid),\n+    \"rmw_gid_t type too small for an dds GUID\");\n+  std::memset(&gid, 0, sizeof(gid));\n+  std::memcpy(gid.data, reinterpret_cast<const void *>(&guid), sizeof(guid));\n+  gid.implementation_identifier = RMW_GURUMDDS_ID;\n+}\n+\n+inline void entity_get_gid(dds_Entity * const entity, rmw_gid_t & gid)\n+{\n+  dds_GUID_t dds_guid;\n+  if (dds_Entity_get_guid(entity, &dds_guid) == dds_RETCODE_OK) {\n+    guid_to_gid(dds_guid, gid);\n+  }\n+}\n+\n+template<typename TBuiltinTopicData>\n+Guid_t::Guid_t(const TBuiltinTopicData& builtin_topic_data) {\n+  static_assert(std::is_same_v<TBuiltinTopicData, dds_PublicationBuiltinTopicData>\n+    || std::is_same_v<TBuiltinTopicData, dds_SubscriptionBuiltinTopicData>);\n+  std::memcpy(prefix, &builtin_topic_data.participant_key, sizeof(prefix));\n+  std::memcpy(&entityId, &builtin_topic_data.key, sizeof(entityId));\n+}\n+\n+template<typename TBuiltinTopicData>\n+Guid_t Guid_t::for_participant(const TBuiltinTopicData& builtin_topic_data) {\n+  static_assert(std::is_same_v<TBuiltinTopicData, dds_PublicationBuiltinTopicData>\n+    || std::is_same_v<TBuiltinTopicData, dds_SubscriptionBuiltinTopicData>);\n+  Guid_t guid;\n+  std::memcpy(guid.prefix, &builtin_topic_data.participant_key, sizeof(guid.prefix));\n+  guid.entityId = ENTITYID_PARTICIPANT;\n+  return guid;\n+}\n+} // namespace rmw_gurumdds_cpp\n+\n+#endif // RMW_GURUMDDS__GID_INL_"},{"role":"user","content":"-// Copyright 2019 GurumNetworks, Inc.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-#ifndef RMW_GURUMDDS__GUID_HPP_\n-#define RMW_GURUMDDS__GUID_HPP_\n-\n-#include <cstring>\n-#include <iostream>\n-#include <map>\n-#include <set>\n-#include <string>\n-#include <vector>\n-\n-#include \"rmw_gurumdds_cpp/dds_include.hpp\"\n-\n-namespace rmw_gurumdds_cpp\n-{\n-typedef uint8_t octet;\n-\n-/**\n- * Structure to hold GUID information for DDS instances.\n- */\n-struct GuidPrefix_t\n-{\n-  static constexpr size_t kSize = 16;\n-  octet value[kSize];\n-\n-  GuidPrefix_t()\n-  {\n-    memset(value, 0, kSize);\n-  }\n-\n-  explicit GuidPrefix_t(octet guid[kSize])\n-  {\n-    memcpy(value, guid, kSize);\n-  }\n-\n-  GuidPrefix_t(const GuidPrefix_t & g)\n-  {\n-    memcpy(value, g.value, kSize);\n-  }\n-\n-  GuidPrefix_t(GuidPrefix_t && g) noexcept\n-  {\n-    memmove(value, g.value, kSize);\n-  }\n-\n-  GuidPrefix_t & operator=(const GuidPrefix_t & guidpre)\n-  {\n-    memcpy(value, guidpre.value, kSize);\n-    return *this;\n-  }\n-\n-  GuidPrefix_t & operator=(GuidPrefix_t && guidpre) noexcept\n-  {\n-    memmove(value, guidpre.value, kSize);\n-    return *this;\n-  }\n-\n-#ifndef DOXYGEN_SHOULD_SKIP_THIS_PUBLIC\n-\n-  bool operator==(const GuidPrefix_t & prefix) const\n-  {\n-    return memcmp(value, prefix.value, kSize) == 0;\n-  }\n-\n-  bool operator!=(const GuidPrefix_t & prefix) const\n-  {\n-    return memcmp(value, prefix.value, kSize) != 0;\n-  }\n-\n-#endif\n-};\n-\n-inline bool operator<(const GuidPrefix_t & g1, const GuidPrefix_t & g2)\n-{\n-  for (uint8_t i = 0; i < GuidPrefix_t::kSize; ++i) {\n-    if (g1.value[i] < g2.value[i]) {\n-      return true;\n-    } else if (g1.value[i] > g2.value[i]) {\n-      return false;\n-    }\n-  }\n-  return false;\n-}\n-\n-inline std::ostream & operator<<(std::ostream & output, const GuidPrefix_t & guiP)\n-{\n-  output << std::hex;\n-  for (uint8_t i = 0; i < GuidPrefix_t::kSize - 1; ++i) {\n-    output << static_cast<int>(guiP.value[i]) << \".\";\n-  }\n-  output << static_cast<int>(guiP.value[GuidPrefix_t::kSize - 1]);\n-  return output << std::dec;\n-}\n-\n-inline void dds_BuiltinTopicKey_to_GUID(\n-  struct GuidPrefix_t * guid,\n-  dds_BuiltinTopicKey_t btk)\n-{\n-  memset(guid->value, 0, GuidPrefix_t::kSize);\n-#if BIG_ENDIAN\n-  memcpy(guid->value, reinterpret_cast<octet *>(btk.value), GuidPrefix_t::kSize - 4);\n-#else\n-  octet const * keyBuffer = reinterpret_cast<octet *>(btk.value);\n-  for (uint8_t i = 0; i < 3; ++i) {\n-    octet * guidElement = &(guid->value[i * 4]);\n-    octet const * keyBufferElement = keyBuffer + (i * 4);\n-    guidElement[0] = keyBufferElement[3];\n-    guidElement[1] = keyBufferElement[2];\n-    guidElement[2] = keyBufferElement[1];\n-    guidElement[3] = keyBufferElement[0];\n-  }\n-#endif\n-}\n-} // namespace rmw_gurumdds_cpp\n-\n-#endif // RMW_GURUMDDS__GUID_HPP_"},{"role":"user","content":"-inline void\n-ros_guid_to_dds_guid(const uint8_t * guid_ros, uint8_t * guid_dds)\n-{\n-  memcpy(guid_dds, guid_ros, 12);\n-  memcpy(&guid_dds[12], &guid_ros[12], 4);\n-}\n-\n-inline void\n-dds_guid_to_ros_guid(const int8_t * guid_dds, int8_t * guid_ros)\n-{\n-  memcpy(guid_ros, guid_dds, 12);\n-  memcpy(&guid_ros[12], &guid_dds[12], 4);\n-}\n-"},{"role":"user","content":"-  memcpy(arr, buf_ + offset_, cnt);\n+  std::memcpy(arr, buf_ + offset_, cnt);"},{"role":"user","content":"-    memcpy(arr, src, cnt * sizeof(uint16_t));\n+    std::memcpy(arr, src, cnt * sizeof(uint16_t));"},{"role":"user","content":"-    memcpy(arr, src, cnt * sizeof(uint32_t));\n+    std::memcpy(arr, src, cnt * sizeof(uint32_t));"},{"role":"user","content":"-    memcpy(arr, src, cnt * sizeof(uint64_t));\n+    std::memcpy(arr, src, cnt * sizeof(uint64_t));"},{"role":"user","content":"+// Copyright 2019 GurumNetworks, Inc.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <cstring>\n+#include <type_traits>\n+\n+#include \"rmw/types.h\"\n+\n+#include \"rmw_gurumdds_cpp/dds_include.hpp\"\n+#include \"rmw_gurumdds_cpp/gid.hpp\"\n+\n+namespace rmw_gurumdds_cpp\n+{\n+Guid_t::Guid_t() : dds_GUID_t{} {}\n+\n+Guid_t::Guid_t(const dds_GUID_t & other) : dds_GUID_t{other} {}\n+\n+Guid_t::Guid_t(const dds_ParticipantBuiltinTopicData& builtin_topic_data) {\n+  std::memcpy(prefix, &builtin_topic_data.key, sizeof(prefix));\n+  entityId = ENTITYID_PARTICIPANT;\n+}\n+\n+bool Guid_t::operator==(const dds_GUID_t & other) const\n+{\n+  return std::memcmp(this, &other, sizeof(dds_GUID_t)) == 0;\n+}\n+\n+bool Guid_t::operator!=(const Guid_t & other) const\n+{\n+  return std::memcmp(this, &other, sizeof(dds_GUID_t)) != 0;\n+}\n+\n+bool Guid_t::operator<(const Guid_t & other) const\n+{\n+  return std::memcmp(this, &other, sizeof(dds_GUID_t)) < 0;\n+}\n+} // namespace rmw_gurumdds_cpp"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/gid.hpp\"\n-#include \"rmw_gurumdds_cpp/qos.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/qos.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-"},{"role":"user","content":"-      if (memcmp(&msg.gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE) == 0) {\n+      if (std::memcmp(&msg.gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE) == 0) {"},{"role":"user","content":"-  if (0 == memcmp(gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n+  if (0 == std::memcmp(gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {"},{"role":"user","content":"-  if (0 == memcmp(gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n+  if (0 == std::memcmp(gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {"},{"role":"user","content":"-  if (0 == memcmp(dp_gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {\n+  if (0 == std::memcmp(dp_gid.data, ctx->common_ctx.gid.data, RMW_GID_STORAGE_SIZE)) {"},{"role":"user","content":"-  if (0 == memcmp(gid.data, ctx->common_ctx.gid.data, 12)) {\n+  if (0 == std::memcmp(gid.data, ctx->common_ctx.gid.data, 12)) {"},{"role":"user","content":"+#include <cstring>"},{"role":"user","content":"-  memcpy(datawriter_qos->user_data.value, user_data_str.data(), user_data_str.size());\n+  std::memcpy(datawriter_qos->user_data.value, user_data_str.data(), user_data_str.size());"},{"role":"user","content":"-  memcpy(datareader_qos->user_data.value, user_data_str.data(), user_data_str.size());\n+  std::memcpy(datareader_qos->user_data.value, user_data_str.data(), user_data_str.size());"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-  memcpy(client_info->writer_guid, client_guid, sizeof(client_guid));\n+  std::memcpy(client_info->writer_guid, client_guid, sizeof(client_guid));"},{"role":"user","content":"-  memset(rmw_client, 0, sizeof(rmw_client_t));\n+  std::memset(rmw_client, 0, sizeof(rmw_client_t));"},{"role":"user","content":"-  memcpy(const_cast<char *>(rmw_client->service_name), service_name, strlen(service_name) + 1);\n+  std::memcpy(const_cast<char *>(rmw_client->service_name), service_name, strlen(service_name) + 1);"},{"role":"user","content":"-    memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n+    std::memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));"},{"role":"user","content":"-        if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+        if (std::memcmp(client_info->writer_guid, client_guid, RMW_GID_STORAGE_SIZE) == 0) {"},{"role":"user","content":"-          memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+          std::memcpy(request_header->request_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-        if (memcmp(client_info->writer_guid, client_guid, 16) == 0) {\n+        if (std::memcmp(client_info->writer_guid, client_guid, RMW_GID_STORAGE_SIZE) == 0) {"},{"role":"user","content":"-          memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+          std::memcpy(request_header->request_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"+#include \"rmw_dds_common/gid_utils.hpp\"\n+"},{"role":"user","content":"-  *result = memcmp(gid1->data, gid2->data, 16) == 0;\n+  *result = gid1 == gid2;"},{"role":"user","content":"+#include <cstring>\n+"},{"role":"user","content":"-  memset(participant_qos.user_data.value, 0, sizeof(participant_qos.user_data.value));\n-  memcpy(participant_qos.user_data.value, node_user_data.c_str(), node_user_data.size());\n+  std::memset(participant_qos.user_data.value, 0, sizeof(participant_qos.user_data.value));\n+  std::memcpy(participant_qos.user_data.value, node_user_data.c_str(), node_user_data.size());"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/guid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+#include <cstring>"},{"role":"user","content":"-  memcpy(const_cast<char *>(node_handle->name), name, strlen(name) + 1);\n+  std::memcpy(const_cast<char *>(node_handle->name), name, strlen(name) + 1);"},{"role":"user","content":"-  memcpy(const_cast<char *>(node_handle->namespace_), namespace_, strlen(namespace_) + 1);\n+  std::memcpy(const_cast<char *>(node_handle->namespace_), namespace_, strlen(namespace_) + 1);"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-  memcpy(\n+  std::memcpy("},{"role":"user","content":"-  memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n+  std::memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));"},{"role":"user","content":"-  ros_guid_to_dds_guid(\n+  rmw_gurumdds_cpp::ros_guid_to_dds_guid("},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-  memset(rmw_service, 0, sizeof(rmw_service_t));\n+  std::memset(rmw_service, 0, sizeof(rmw_service_t));"},{"role":"user","content":"-  memcpy(const_cast<char *>(rmw_service->service_name), service_name, strlen(service_name) + 1);\n+  std::memcpy(const_cast<char *>(rmw_service->service_name), service_name, strlen(service_name) + 1);"},{"role":"user","content":"-      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      std::memcpy(request_header->request_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-      memcpy(request_header->request_id.writer_guid, client_guid, 16);\n+      std::memcpy(request_header->request_id.writer_guid, client_guid, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-    memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));\n+    std::memset(&sampleinfo_ex, 0, sizeof(dds_SampleInfoEx));"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-  memcpy(\n+  std::memcpy("},{"role":"user","content":"-      dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);\n+      rmw_gurumdds_cpp::dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);"},{"role":"user","content":"-      memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+      std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+        std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-    memcpy(serialized_message->buffer, sample, sample_size);\n+    std::memcpy(serialized_message->buffer, sample, sample_size);"},{"role":"user","content":"-      dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);\n+      rmw_gurumdds_cpp::dds_sn_to_ros_sn(sampleinfo_ex->seq, &sequence_number);"},{"role":"user","content":"-      memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+      std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+        std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-        memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+        std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-          memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);\n+          std::memset(sender_gid->data, 0, RMW_GID_STORAGE_SIZE);"},{"role":"user","content":"-#include \"rmw_gurumdds_cpp/guid.hpp\""},{"role":"user","content":"+#include \"rmw_gurumdds_cpp/gid.hpp\""},{"role":"user","content":"-  dds_DomainParticipant * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0));\n-\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );"},{"role":"user","content":"-  dds_GUID_t dp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(&dp_guid_prefix, data->key);\n-  memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-  dp_guid.entityId = ENTITYID_PARTICIPANT;\n-\n+  rmw_gurumdds_cpp::Guid_t dp_guid{*data};"},{"role":"user","content":"-  dds_DomainParticipant * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0));\n-\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );"},{"role":"user","content":"-  dds_GUID_t endp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix, endp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(&dp_guid_prefix, data->participant_key);\n-  memcpy(endp_guid.prefix, dp_guid_prefix.value, sizeof(endp_guid.prefix));\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(&endp_guid_prefix, data->key);\n-  memcpy(&endp_guid.entityId, endp_guid_prefix.value, sizeof(endp_guid.entityId));\n-\n+  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n+  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n+  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n+  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[2],\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],"},{"role":"user","content":"-    dds_GUID_t dp_guid;\n-    memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-    dp_guid.entityId = ENTITYID_PARTICIPANT;\n-"},{"role":"user","content":"-"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[2],\n+      dp_guid_prefix[0],\n+      dp_guid_prefix[1],\n+      dp_guid_prefix[2],"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[2],\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],"},{"role":"user","content":"-  dds_DomainParticipant * participant = const_cast<dds_DomainParticipant *>(a_participant);\n-  rmw_context_impl_t * ctx =\n-    reinterpret_cast<rmw_context_impl_t *>(\n-    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0));\n-\n+  auto * participant = const_cast<dds_DomainParticipant *>(a_participant);\n+  auto * ctx = reinterpret_cast<rmw_context_impl_t *>(\n+    dds_Entity_get_context(reinterpret_cast<dds_Entity *>(participant), 0)\n+  );"},{"role":"user","content":"-  dds_GUID_t endp_guid;\n-  rmw_gurumdds_cpp::GuidPrefix_t dp_guid_prefix, endp_guid_prefix;\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(&dp_guid_prefix, data->participant_key);\n-  memcpy(endp_guid.prefix, dp_guid_prefix.value, sizeof(endp_guid.prefix));\n-  rmw_gurumdds_cpp::dds_BuiltinTopicKey_to_GUID(&endp_guid_prefix, data->key);\n-  memcpy(&endp_guid.entityId, endp_guid_prefix.value, sizeof(endp_guid.entityId));\n-\n+  rmw_gurumdds_cpp::Guid_t dp_guid = rmw_gurumdds_cpp::Guid_t::for_participant(*data);\n+  rmw_gurumdds_cpp::Guid_t endp_guid{*data};\n+  const auto * dp_guid_prefix = reinterpret_cast<const uint32_t *>(dp_guid.prefix);\n+  const auto * endp_guid_prefix = reinterpret_cast<const uint32_t *>(endp_guid.prefix);"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[2],\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],"},{"role":"user","content":"-    dds_GUID_t dp_guid;\n-    memcpy(dp_guid.prefix, dp_guid_prefix.value, sizeof(dp_guid.prefix));\n-    dp_guid.entityId = ENTITYID_PARTICIPANT;\n-"},{"role":"user","content":"-"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(dp_guid.prefix)[2],\n+      dp_guid_prefix[0],\n+      dp_guid_prefix[1],\n+      dp_guid_prefix[2],"},{"role":"user","content":"-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[0],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[1],\n-      reinterpret_cast<const uint32_t *>(endp_guid.prefix)[2],\n+      endp_guid_prefix[0],\n+      endp_guid_prefix[1],\n+      endp_guid_prefix[2],"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-   * can only be resolved after the creation of the publisher, and it\n+   * can only be resolved after the creation of the subscription, and it"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+find_package(rmw REQUIRED)"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-    @staticmethod\n-    def get_parameter_values(node, node_name, params):\n-        response = call_get_parameters(\n-            node=node, node_name=node_name,\n-            parameter_names=params)\n-\n-        # requested parameter not set\n-        if not response.values:\n-            return None\n-\n-        # extract type specific value\n-        return [get_value(parameter_value=i) for i in response.values]\n-"},{"role":"user","content":"-            # retrieve values\n+            # retrieve parameter names"},{"role":"user","content":"-\n-            response = response.result().result.names\n-            response = sorted(response)\n-            parameter_values = self.get_parameter_values(node, absolute_node_name, response)\n-            if parameter_values is None:\n+            parameter_names = sorted(response.result().result.names)\n+\n+            # retrieve parameter values\n+            response = None\n+            try:\n+                response = call_get_parameters(\n+                    node=node, node_name=absolute_node_name, parameter_names=parameter_names)\n+            except RuntimeError as e:"},{"role":"user","content":"-\n-            for param_name, pval in zip(response, parameter_values):\n+            if response.values is None:\n+                # pass through here, no parameters are available with this node.\n+                # since this is not failure, it proceeds to print the yaml as consistent behavior.\n+                pass\n+            parameter_values = [get_value(parameter_value=i) for i in response.values]\n+\n+            # create dictionary with parameter names and values\n+            for param_name, pval in zip(parameter_names, parameter_values):"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-  return feature == RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER ? true : false;\n+  switch(feature) {\n+    case RMW_FEATURE_MESSAGE_INFO_RECEPTION_SEQUENCE_NUMBER:\n+    case RMW_FEATURE_MESSAGE_INFO_PUBLICATION_SEQUENCE_NUMBER:\n+      return true;\n+    default:\n+      return false;\n+  }"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-#include <rcppmath/rolling_mean_accumulator.hpp>\n-\n-#include <gtest/gtest.h>"},{"role":"user","content":"+#include \"gtest/gtest.h\"\n+\n+#include \"rcppmath/rolling_mean_accumulator.hpp\""},{"role":"user","content":"-#include <gtest/gtest.h>\n-\n-#include <rcpputils/env.hpp>\n-"},{"role":"user","content":"+#include \"gtest/gtest.h\"\n+\n+#include \"rcpputils/env.hpp\""},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"-| Camera                | Focus Camera  | XY Orbit              | Help            | \n-| Fluid Pressure        | Measure       | First Person          | Selections      |\n-| Grid                  | Select        | Third Person Follower | Time            |\n-| Grid Cells            | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n-| Illuminance           | Publish Point |                       | Views           |\n-| Image                 | Initial Pose  |\n-| Interactive Marker    | Interact      |\n+| Camera                | Focus Camera  | XY Orbit              | Help            |\n+| Effort                | Measure       | First Person          | Selections      |\n+| Fluid                 | Select        | Third Person Follower | Time            |\n+| Grid                  | 2D Nav Goal   | Top Down Orthographic | Tool Properties |\n+| Grid Cells            | Publish Point |                       | Views           |\n+| Illuminance           | Initial Pose  |\n+| Image                 | Interact      |\n+| Interactive Marker    |"},{"role":"user","content":"-| Effort        |"},{"role":"user","content":"+  include/rviz_default_plugins/displays/effort/effort_display.hpp"},{"role":"user","content":"+  src/rviz_default_plugins/displays/effort/effort_display.cpp"},{"role":"user","content":"+  ament_add_gtest(effort_display_visual_test\n+    test/rviz_default_plugins/displays/effort/effort_display_visual_test.cpp\n+    test/rviz_default_plugins/publishers/effort_publisher.hpp\n+    test/rviz_default_plugins/page_objects/effort_display_page_object.cpp\n+    ${SKIP_VISUAL_TESTS}\n+    TIMEOUT 180)\n+  if(TARGET effort_display_visual_test)\n+    target_include_directories(effort_display_visual_test PRIVATE test)\n+    target_link_libraries(effort_display_visual_test\n+      rviz_visual_testing_framework::rviz_visual_testing_framework\n+      rclcpp::rclcpp\n+      ${sensor_msgs_TARGETS}\n+    )\n+  endif()\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_\n+#define RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_\n+\n+#include <urdf/model.h>\n+\n+#include <deque>\n+#include <map>\n+#include <memory>\n+#include <string>\n+\n+#include <rclcpp/rclcpp.hpp>\n+#include <rviz_common/message_filter_display.hpp>\n+#include <rviz_common/properties/bool_property.hpp>\n+#include <rviz_common/properties/int_property.hpp>\n+#include <rviz_common/properties/float_property.hpp>\n+#include <rviz_common/properties/string_property.hpp>\n+#include <rviz_common/properties/property.hpp>\n+#include <rviz_rendering/objects/effort_visual.hpp>\n+#include <sensor_msgs/msg/joint_state.hpp>\n+#include <std_msgs/msg/string.hpp>\n+\n+#include \"rviz_default_plugins/visibility_control.hpp\"\n+\n+namespace rviz_default_plugins\n+{\n+namespace displays\n+{\n+class JointInfo : public QObject\n+{\n+  Q_OBJECT\n+\n+public:\n+  JointInfo(const std::string & name, rviz_common::properties::Property * parent_category);\n+  ~JointInfo() override;\n+\n+  void setEffort(double e);\n+  inline double getEffort()\n+  {\n+    return effort_;\n+  }\n+  void setMaxEffort(double m);\n+  inline double getMaxEffort()\n+  {\n+    return max_effort_;\n+  }\n+  bool getEnabled() const;\n+\n+  rclcpp::Time last_update_;\n+\n+public Q_SLOTS:\n+  void updateVisibility();\n+\n+private:\n+  std::string name_;\n+  double effort_, max_effort_;\n+\n+  rviz_common::properties::Property * category_;\n+  rviz_common::properties::FloatProperty * effort_property_;\n+  rviz_common::properties::FloatProperty * max_effort_property_;\n+};\n+\n+class RVIZ_DEFAULT_PLUGINS_PUBLIC EffortDisplay\n+  : public rviz_common::MessageFilterDisplay<sensor_msgs::msg::JointState>\n+{\n+  Q_OBJECT\n+\n+public:\n+  EffortDisplay();\n+  ~EffortDisplay() override;\n+\n+  // Overrides of public virtual functions from the Display class.\n+  void onInitialize() override;\n+  void reset() override;\n+\n+  void load(const rviz_common::Config & config) override;\n+\n+  void update(float wall_dt, float ros_dt) override;\n+\n+private Q_SLOTS:\n+  // Helper function to apply color and alpha to all visuals.\n+  void updateColorAndAlpha();\n+  void updateHistoryLength();\n+  void updateRobotDescription();\n+  void updateTfPrefix();\n+\n+private:\n+  std::shared_ptr<JointInfo> getJointInfo(const std::string & joint);\n+  void subscribeToRobotDescription();\n+\n+protected:\n+  // overrides from Display\n+  void onEnable() override;\n+  void onDisable() override;\n+\n+  void load();\n+  void clear();\n+\n+  // The object for urdf model\n+  std::shared_ptr<urdf::Model> robot_model_;\n+\n+  std::string robot_description_;\n+  std::string robot_description_topic_;\n+\n+private:\n+  void processMessage(sensor_msgs::msg::JointState::ConstSharedPtr msg) override;\n+  void topic_callback(const std_msgs::msg::String & msg);\n+\n+  rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;\n+  rclcpp::executors::SingleThreadedExecutor::SharedPtr executor_;\n+\n+  // Storage for the list of visuals.  It is a circular buffer where\n+  // data gets popped from the front (oldest) and pushed to the back (newest)\n+  std::deque<std::shared_ptr<rviz_rendering::EffortVisual>> visuals_;\n+\n+  typedef std::map<std::string, std::shared_ptr<JointInfo>> M_JointInfo;\n+  M_JointInfo joints_;\n+\n+  // Property objects for user-editable properties.\n+  rviz_common::properties::FloatProperty * alpha_property_, * width_property_, * scale_property_;\n+  rviz_common::properties::IntProperty * history_length_property_;\n+\n+  rviz_common::properties::StringProperty * robot_description_property_;\n+  rviz_common::properties::StringProperty * tf_prefix_property_;\n+  rviz_common::properties::Property * joints_category_;\n+  rviz_common::properties::BoolProperty * all_enabled_property_;\n+};\n+\n+}  // namespace displays\n+}  // namespace rviz_default_plugins\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__DISPLAYS__EFFORT__EFFORT_DISPLAY_HPP_"},{"role":"user","content":"+  <class\n+    name=\"rviz_default_plugins/Effort\"\n+    type=\"rviz_default_plugins::displays::EffortDisplay\"\n+    base_class_type=\"rviz_common::Display\"\n+  >\n+    <description>\n+      The Effort display shows a sensor_msgs/JointState/effort message as circled arrows around each revolute joint in the robot.\n+    </description>\n+    <message_type>sensor_msgs/msg/JointState</message_type>\n+  </class>\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include \"rviz_default_plugins/displays/effort/effort_display.hpp\"\n+\n+#include <OgreSceneNode.h>\n+#include <OgreSceneManager.h>\n+#include <urdf/model.h>\n+\n+#include <QString>\n+\n+#include <chrono>\n+#include <cstddef>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <rviz_common/validate_floats.hpp>\n+\n+#include <rviz_common/properties/property.hpp>\n+#include <rviz_rendering/objects/effort_visual.hpp>\n+#include <sensor_msgs/msg/joint_state.hpp>\n+\n+using namespace std::chrono_literals;\n+\n+namespace rviz_default_plugins\n+{\n+namespace displays\n+{\n+JointInfo::JointInfo(const std::string & name, rviz_common::properties::Property * parent_category)\n+{\n+  name_ = name;\n+  effort_ = 0;\n+  max_effort_ = 0;\n+\n+  category_ = new rviz_common::properties::Property(\n+    QString::fromStdString(name_), true, \"\", parent_category,\n+    SLOT(updateVisibility()), this);\n+\n+  effort_property_ = new rviz_common::properties::FloatProperty(\n+    \"Effort\", 0, \"Effort value of this joint.\", category_);\n+  effort_property_->setReadOnly(true);\n+\n+  max_effort_property_ =\n+    new rviz_common::properties::FloatProperty(\n+    \"Max Effort\", 0, \"Max Effort value of this joint.\", category_);\n+  max_effort_property_->setReadOnly(true);\n+}\n+\n+JointInfo::~JointInfo()\n+{\n+}\n+\n+std::shared_ptr<JointInfo> EffortDisplay::getJointInfo(const std::string & joint)\n+{\n+  M_JointInfo::iterator it = joints_.find(joint);\n+  if (it == joints_.end()) {\n+    return nullptr;\n+  }\n+\n+  return it->second;\n+}\n+\n+void JointInfo::updateVisibility()\n+{\n+}\n+\n+void JointInfo::setEffort(double e)\n+{\n+  effort_property_->setFloat(e);\n+  effort_ = e;\n+}\n+\n+void JointInfo::setMaxEffort(double m)\n+{\n+  max_effort_property_->setFloat(m);\n+  max_effort_ = m;\n+}\n+\n+bool JointInfo::getEnabled() const\n+{\n+  return category_->getValue().toBool();\n+}\n+\n+EffortDisplay::EffortDisplay()\n+: rviz_common::MessageFilterDisplay<sensor_msgs::msg::JointState>()\n+{\n+  alpha_property_ = new rviz_common::properties::FloatProperty(\n+    \"Alpha\", 1.0f, \"0 is fully transparent, 1.0 is fully opaque.\",\n+    this, SLOT(updateColorAndAlpha()));\n+\n+  width_property_ = new rviz_common::properties::FloatProperty(\n+    \"Width\", 0.02f, \"Width to drow effort circle\", this,\n+    SLOT(updateColorAndAlpha()));\n+\n+  scale_property_ = new rviz_common::properties::FloatProperty(\n+    \"Scale\", 1.0f, \"Scale to draw effort circle\", this,\n+    SLOT(updateColorAndAlpha()));\n+\n+  history_length_property_ = new rviz_common::properties::IntProperty(\n+    \"History Length\", 1, \"Number of prior measurements to display.\", this,\n+    SLOT(updateHistoryLength()));\n+\n+  history_length_property_->setMin(1);\n+  history_length_property_->setMax(100000);\n+\n+  robot_description_property_ =\n+    new rviz_common::properties::StringProperty(\n+    \"Robot Description\", \"/robot_description\",\n+    \"Name of the topic from which to load the robot \"\n+    \"description.\",\n+    this, SLOT(updateRobotDescription()));\n+\n+  tf_prefix_property_ = new rviz_common::properties::StringProperty(\n+    \"TF Prefix\", \"\",\n+    \"Robot Model normally assumes the link name is the same as the tf frame name. \"\n+    \"This option allows you to set a prefix.  Mainly useful for multi-robot situations.\",\n+    this, SLOT(updateTfPrefix()));\n+\n+  joints_category_ = new rviz_common::properties::Property(\"Joints\", QVariant(), \"\", this);\n+}\n+\n+EffortDisplay::~EffortDisplay()\n+{\n+}\n+\n+void EffortDisplay::onInitialize()\n+{\n+  MFDClass::onInitialize();\n+  updateHistoryLength();\n+}\n+\n+// Set the number of past visuals to show.\n+void EffortDisplay::updateHistoryLength()\n+{\n+  while (visuals_.size() > static_cast<size_t>(history_length_property_->getInt())) {\n+    visuals_.pop_front();\n+  }\n+}\n+\n+// Clear the visuals by deleting their objects.\n+void EffortDisplay::reset()\n+{\n+  MFDClass::reset();\n+  visuals_.clear();\n+}\n+\n+void EffortDisplay::load(const rviz_common::Config & config)\n+{\n+  rviz_common::Display::load(config);\n+}\n+\n+void EffortDisplay::topic_callback(const std_msgs::msg::String & msg)\n+{\n+  robot_description_ = msg.data;\n+  robot_model_ = std::shared_ptr<urdf::Model>(new urdf::Model());\n+  if (!robot_model_->initString(robot_description_)) {\n+    setStatus(\n+      rviz_common::properties::StatusProperty::Error,\n+      \"URDF\", \"Unable to parse robot model description!\");\n+    return;\n+  }\n+  setStatus(rviz_common::properties::StatusProperty::Ok, \"URDF\", \"Robot model parsed Ok\");\n+\n+  for (std::map<std::string, urdf::JointSharedPtr>::iterator it = robot_model_->joints_.begin();\n+    it != robot_model_->joints_.end(); it++)\n+  {\n+    urdf::JointSharedPtr joint = it->second;\n+    if (joint->type == urdf::Joint::REVOLUTE || joint->type == 2) {\n+      std::string joint_name = it->first;\n+      urdf::JointLimitsSharedPtr limit = joint->limits;\n+      joints_[joint_name] = std::make_shared<JointInfo>(joint_name, joints_category_);\n+      joints_[joint_name]->setMaxEffort(limit->effort);\n+    }\n+  }\n+}\n+\n+void EffortDisplay::subscribeToRobotDescription()\n+{\n+  if (this->robot_description_topic_ == robot_description_property_->getStdString()) {\n+    return;\n+  }\n+  this->robot_description_topic_ = robot_description_property_->getStdString();\n+\n+  using std::placeholders::_1;\n+\n+  try {\n+    rclcpp::SubscriptionOptions sub_opts;\n+    sub_opts.event_callbacks.message_lost_callback =\n+      [&](rclcpp::QOSMessageLostInfo & info)\n+      {\n+        std::ostringstream sstm;\n+        sstm << \"Some messages were lost:\\n>\\tNumber of new lost messages: \" <<\n+          info.total_count_change << \" \\n>\\tTotal number of messages lost: \" <<\n+          info.total_count;\n+        setStatus(\n+          rviz_common::properties::StatusLevel::Warn,\n+          \"Topic\",\n+          QString(sstm.str().c_str()));\n+      };\n+\n+    this->subscription_ = context_->getRosNodeAbstraction().lock()->get_raw_node()->\n+      template create_subscription<std_msgs::msg::String>(\n+      robot_description_property_->getStdString(),\n+      rclcpp::QoS(1).transient_local(),\n+      std::bind(&EffortDisplay::topic_callback, this, _1),\n+      sub_opts);\n+    setStatus(rviz_common::properties::StatusLevel::Ok, \"Array Topic\", \"OK\");\n+  } catch (rclcpp::exceptions::InvalidTopicNameError & e) {\n+    setStatus(\n+      rviz_common::properties::StatusLevel::Error,\n+      \"Topic\",\n+      QString(\"Error subscribing: \") + e.what());\n+  }\n+}\n+\n+void EffortDisplay::load()\n+{\n+  this->subscribeToRobotDescription();\n+}\n+\n+void EffortDisplay::update(float wall_dt, float ros_dt)\n+{\n+  (void) wall_dt;\n+  (void) ros_dt;\n+}\n+\n+// Set the current color and alpha values for each visual.\n+void EffortDisplay::updateColorAndAlpha()\n+{\n+  float width = width_property_->getFloat();\n+  float scale = scale_property_->getFloat();\n+\n+  for (size_t i = 0; i < visuals_.size(); i++) {\n+    visuals_[i]->setWidth(width);\n+    visuals_[i]->setScale(scale);\n+  }\n+}\n+\n+std::string concat(const std::string & prefix, const std::string & frame)\n+{\n+  if (prefix.empty()) {\n+    return frame;\n+  }\n+\n+  std::string composite = prefix;\n+  composite.append(\"/\");\n+  composite.append(frame);\n+  return composite;\n+}\n+\n+void EffortDisplay::processMessage(sensor_msgs::msg::JointState::ConstSharedPtr msg)\n+{\n+  // Robot model might not be loaded yet\n+  if (!robot_model_) {\n+    setStatus(\n+      rviz_common::properties::StatusLevel::Error,\n+      \"Process message\",\n+      QString(\"Robot model might not be loaded yet\"));\n+    return;\n+  }\n+  // We are keeping a circular buffer of visual pointers.  This gets\n+  // the next one, or creates and stores it if the buffer is not full\n+  std::shared_ptr<rviz_rendering::EffortVisual> visual;\n+  if (visuals_.size() == static_cast<size_t>(history_length_property_->getInt())) {\n+    visual = visuals_.front();\n+  } else {\n+    visual = std::make_shared<rviz_rendering::EffortVisual>(\n+      context_->getSceneManager(), scene_node_);\n+  }\n+  visual->setWidth(width_property_->getFloat());\n+  visual->setScale(scale_property_->getFloat());\n+\n+  if (visuals_.size() >= static_cast<size_t>(history_length_property_->getInt())) {\n+    visuals_.pop_front();\n+  }\n+\n+  std::vector<std::string> joints;\n+  size_t joint_num = msg->name.size();\n+  if (joint_num != msg->effort.size()) {\n+    setStatus(\n+      rviz_common::properties::StatusProperty::Error, \"Topic\",\n+      \"Received a joint state msg with different joint names and efforts size!\");\n+    return;\n+  }\n+  for (size_t i = 0; i < joint_num; ++i) {\n+    const std::string & joint_name = msg->name[i];\n+    std::shared_ptr<JointInfo> joint_info = getJointInfo(joint_name);\n+    if (!joint_info) {\n+      continue;  // skip joints..\n+    }\n+\n+    // update effort property\n+    joint_info->setEffort(msg->effort[i]);\n+    joint_info->last_update_ = msg->header.stamp;\n+\n+    const urdf::Joint * joint = robot_model_->getJoint(joint_name).get();\n+    int joint_type = joint->type;\n+    if (joint_type == urdf::Joint::REVOLUTE) {\n+      std::string tf_frame_id = concat(\n+        tf_prefix_property_->getStdString(), joint->child_link_name);\n+      Ogre::Quaternion orientation;\n+      Ogre::Vector3 position;\n+\n+      // Call rviz::FrameManager to get the transform from the fixed frame to the joint's frame.\n+      if (!context_->getFrameManager()->getTransform(\n+          tf_frame_id, msg->header.stamp, position, orientation))\n+      {\n+        setStatus(\n+          rviz_common::properties::StatusProperty::Error,\n+          QString::fromStdString(joint_name),\n+          QString(\"Error transforming from frame '%1' to frame '%2'\")\n+          .arg(tf_frame_id.c_str(), qPrintable(fixed_frame_)));\n+        continue;\n+      }\n+      tf2::Vector3 axis_joint(joint->axis.x, joint->axis.y, joint->axis.z);\n+      tf2::Vector3 axis_z(0, 0, 1);\n+      tf2::Quaternion axis_rotation(axis_joint.cross(axis_z), axis_joint.angle(axis_z));\n+      if (std::isnan(axis_rotation.x()) ||\n+        std::isnan(axis_rotation.y()) ||\n+        std::isnan(axis_rotation.z()))\n+      {\n+        axis_rotation = tf2::Quaternion::getIdentity();\n+      }\n+\n+      tf2::Quaternion axis_orientation(orientation.x, orientation.y, orientation.z, orientation.w);\n+      tf2::Quaternion axis_rot = axis_orientation * axis_rotation;\n+      Ogre::Quaternion joint_orientation(Ogre::Real(axis_rot.w()), Ogre::Real(axis_rot.x()),\n+        Ogre::Real(axis_rot.y()), Ogre::Real(axis_rot.z()));\n+      visual->setFramePosition(joint_name, position);\n+      visual->setFrameOrientation(joint_name, joint_orientation);\n+      visual->setFrameEnabled(joint_name, joint_info->getEnabled());\n+\n+      if (!rviz_common::validateFloats(joint_info->getEffort())) {\n+        setStatus(\n+          rviz_common::properties::StatusProperty::Error,\n+          QString::fromStdString(joint_name),\n+          QString(\"Invalid effort: %1\").arg(joint_info->getEffort()));\n+        visual->setFrameEnabled(joint_name, false);\n+      } else {\n+        setStatus(\n+          rviz_common::properties::StatusProperty::Ok,\n+          QString::fromStdString(joint_name),\n+          QString());\n+      }\n+      visual->setEffort(joint_name, joint_info->getEffort(), joint_info->getMaxEffort());\n+    }\n+  }\n+  visuals_.push_back(visual);\n+}\n+\n+void EffortDisplay::updateRobotDescription()\n+{\n+  if (isEnabled()) {\n+    load();\n+    context_->queueRender();\n+  }\n+}\n+\n+void EffortDisplay::onEnable()\n+{\n+  load();\n+}\n+\n+void EffortDisplay::onDisable()\n+{\n+  clear();\n+}\n+\n+void EffortDisplay::clear()\n+{\n+  clearStatuses();\n+  robot_description_.clear();\n+}\n+\n+void EffortDisplay::updateTfPrefix()\n+{\n+  clearStatuses();\n+  context_->queueRender();\n+}\n+\n+}  // namespace displays\n+}  // namespace rviz_default_plugins\n+\n+#include <pluginlib/class_list_macros.hpp>  // NOLINT\n+PLUGINLIB_EXPORT_CLASS(rviz_default_plugins::displays::EffortDisplay, rviz_common::Display)"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"rviz_visual_testing_framework/visual_test_fixture.hpp\"\n+#include \"rviz_visual_testing_framework/visual_test_publisher.hpp\"\n+\n+#include \"../../page_objects/effort_display_page_object.hpp\"\n+#include \"../../publishers/effort_publisher.hpp\"\n+\n+TEST_F(VisualTestFixture, wrenches_are_displayed) {\n+  auto effort_publisher = std::make_shared<nodes::EffortPublisher>();\n+  auto effort_visual_publisher =\n+    std::make_unique<VisualTestPublisher>(effort_publisher, \"effort_frame\");\n+\n+  setCamPose(Ogre::Vector3(10, 10, 16));\n+  setCamLookAt(Ogre::Vector3(0, 0, 0));\n+\n+  auto effort_display = addDisplay<EffortDisplayPageObject>();\n+  effort_display->setTopic(\"/joint_states\");\n+  effort_display->setScale(2);\n+  effort_display->setWidth(4);\n+  effort_display->setRobotDescription(\"robot_description\");\n+\n+  captureMainWindow();\n+\n+  effort_display->setAlpha(0.0f);\n+  captureMainWindow(\"empty_scene\");\n+\n+  assertScreenShotsIdentity();\n+}"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include \"effort_display_page_object.hpp\"\n+\n+#include <memory>\n+#include <vector>\n+\n+EffortDisplayPageObject::EffortDisplayPageObject()\n+: BasePageObject(0, \"Effort\")\n+{}\n+\n+void EffortDisplayPageObject::setTopic(QString topic)\n+{\n+  setComboBox(\"Topic\", topic);\n+  waitForFirstMessage();\n+}\n+\n+void EffortDisplayPageObject::setAlpha(float alpha)\n+{\n+  setFloat(\"Alpha\", alpha);\n+}\n+\n+void EffortDisplayPageObject::setScale(float scale)\n+{\n+  setFloat(\"Scale\", scale);\n+}\n+\n+void EffortDisplayPageObject::setWidth(float width)\n+{\n+  setFloat(\"Width\", width);\n+}\n+\n+void EffortDisplayPageObject::setHistoryLength(int history)\n+{\n+  setInt(\"History Length\", history);\n+}\n+\n+void EffortDisplayPageObject::setRobotDescription(QString topic)\n+{\n+  setString(\"Robot Description\", topic);\n+}"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_\n+#define RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_\n+\n+#include \"rviz_visual_testing_framework/page_objects/base_page_object.hpp\"\n+\n+class EffortDisplayPageObject : public BasePageObject\n+{\n+public:\n+  EffortDisplayPageObject();\n+\n+  void setTopic(QString topic);\n+  void setAlpha(float alpha);\n+  void setScale(float scale);\n+  void setWidth(float width);\n+  void setHistoryLength(int history);\n+  void setRobotDescription(QString topic);\n+};\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__PAGE_OBJECTS__EFFORT_DISPLAY_PAGE_OBJECT_HPP_"},{"role":"user","content":"+/*\n+ * Copyright (c) 2019, Martin Idel\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the copyright holder nor the names of its contributors\n+ *       may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_\n+#define RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_\n+\n+#include <string>\n+#include <chrono>\n+\n+#include <rclcpp/rclcpp.hpp>\n+#include <sensor_msgs/msg/joint_state.hpp>\n+\n+using namespace std::chrono_literals;  // NOLINT\n+\n+namespace nodes\n+{\n+\n+class EffortPublisher : public rclcpp::Node\n+{\n+public:\n+  EffortPublisher();\n+\n+private:\n+  sensor_msgs::msg::JointState createJointStateMessage();\n+\n+  rclcpp::TimerBase::SharedPtr timer_;\n+  rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr publisher_;\n+};\n+\n+EffortPublisher::EffortPublisher()\n+: Node(\"effort_publisher\")\n+{\n+  publisher_ = this->create_publisher<sensor_msgs::msg::JointState>(\"joint_states\", 10);\n+\n+  auto timer_callback =\n+    [this]() -> void {\n+      auto message = createJointStateMessage();\n+      this->publisher_->publish(message);\n+    };\n+  timer_ = this->create_wall_timer(500ms, timer_callback);\n+}\n+\n+sensor_msgs::msg::JointState EffortPublisher::createJointStateMessage()\n+{\n+  sensor_msgs::msg::JointState msg;\n+  msg.name.push_back(\"joint1\");\n+  msg.name.push_back(\"joint2\");\n+  msg.position.push_back(0.0);\n+  msg.position.push_back(0.0);\n+\n+  msg.header.frame_id = \"world\";\n+\n+  msg.effort.push_back(1);\n+  msg.effort.push_back(2);\n+  msg.header.stamp = this->get_clock()->now();\n+\n+  return msg;\n+}\n+\n+}  // namespace nodes\n+\n+#endif  // RVIZ_DEFAULT_PLUGINS__PUBLISHERS__EFFORT_PUBLISHER_HPP_"},{"role":"user","content":"+  src/rviz_rendering/objects/effort_visual.cpp"},{"role":"user","content":"+  ament_add_gmock(effort_visual_test_target\n+    test/rviz_rendering/objects/effort_visual_test.cpp\n+    ${SKIP_DISPLAY_TESTS})\n+  if(TARGET effort_visual_test_target)\n+    target_link_libraries(effort_visual_test_target\n+      rviz_ogre_vendor::OgreMain\n+      rviz_rendering\n+      rviz_rendering_test_utils\n+      Qt5::Widgets  # explicitly do this for include directories (not necessary for external use)\n+    )\n+  endif()\n+"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_\n+#define RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_\n+\n+#include <map>\n+#include <string>\n+\n+#include <OgreSceneNode.h>\n+#include <OgreSceneManager.h>\n+\n+#include \"rviz_rendering/objects/arrow.hpp\"\n+#include \"rviz_rendering/objects/billboard_line.hpp\"\n+\n+#include \"rviz_rendering/visibility_control.hpp\"\n+\n+namespace rviz_rendering\n+{\n+class EffortVisual\n+{\n+public:\n+  RVIZ_RENDERING_PUBLIC\n+  EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node);\n+\n+  // set rainbow color\n+  RVIZ_RENDERING_PUBLIC\n+  void getRainbowColor(float value, Ogre::ColourValue & color);\n+  RVIZ_RENDERING_PUBLIC\n+  void setEffort(const std::string & joint_name, double effort, double max_effort);\n+\n+  // set the pose of coordinates frame the each joint refers to.\n+  RVIZ_RENDERING_PUBLIC\n+  void setFramePosition(const std::string & joint_name, const Ogre::Vector3 & position);\n+  RVIZ_RENDERING_PUBLIC\n+  void setFrameOrientation(const std::string & joint_name, const Ogre::Quaternion & orientation);\n+\n+  RVIZ_RENDERING_PUBLIC\n+  void setFrameEnabled(const std::string & joint_name, const bool e);\n+\n+  RVIZ_RENDERING_PUBLIC\n+  void setWidth(float w);\n+\n+  RVIZ_RENDERING_PUBLIC\n+  void setScale(float s);\n+\n+private:\n+  // The object implementing the effort circle\n+  std::map<std::string, rviz_rendering::BillboardLine *> effort_circle_;\n+  std::map<std::string, rviz_rendering::Arrow *> effort_arrow_;\n+  std::map<std::string, bool> effort_enabled_;\n+\n+  Ogre::SceneManager * scene_manager_;\n+  Ogre::SceneNode * parent_node_;\n+\n+  std::map<std::string, Ogre::Vector3> position_;\n+  std::map<std::string, Ogre::Quaternion> orientation_;\n+\n+  float width_, scale_;\n+};\n+}  // namespace rviz_rendering\n+\n+#endif  // RVIZ_RENDERING__OBJECTS__EFFORT_VISUAL_HPP_"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+ #define _USE_MATH_DEFINES\n+#include \"rviz_rendering/objects/effort_visual.hpp\"\n+\n+#include <algorithm>\n+#include <cmath>\n+\n+namespace rviz_rendering\n+{\n+EffortVisual::EffortVisual(Ogre::SceneManager * scene_manager, Ogre::SceneNode * parent_node)\n+: scene_manager_(scene_manager), parent_node_(parent_node)\n+{\n+}\n+\n+void EffortVisual::getRainbowColor(float value, Ogre::ColourValue & color)\n+{\n+  value = std::min(value, 1.0f);\n+  value = std::max(value, 0.0f);\n+\n+  float h = value * 5.0f + 1.0f;\n+  int i = static_cast<int>(floor(h));\n+  float f = h - static_cast<float>(i);\n+  if (!(i & 1)) {\n+    f = 1 - f;  // if i is even\n+  }\n+  float n = 1 - f;\n+\n+  if (i <= 1) {\n+    color[0] = n, color[1] = 0, color[2] = 1;\n+  } else if (i == 2) {\n+    color[0] = 0, color[1] = n, color[2] = 1;\n+  } else if (i == 3) {\n+    color[0] = 0, color[1] = 1, color[2] = n;\n+  } else if (i == 4) {\n+    color[0] = n, color[1] = 1, color[2] = 0;\n+  } else if (i >= 5) {\n+    color[0] = 1, color[1] = n, color[2] = 0;\n+  }\n+}\n+\n+void EffortVisual::setEffort(const std::string & joint_name, double effort, double max_effort)\n+{\n+  bool enabled = effort_enabled_.insert(std::make_pair(joint_name, true)).first->second;\n+\n+  // enable or disable draw\n+  if (effort_circle_.find(joint_name) != effort_circle_.end() && !enabled) {  // enable->disable\n+    delete (effort_circle_[joint_name]);\n+    delete (effort_arrow_[joint_name]);\n+    effort_circle_.erase(joint_name);\n+    effort_arrow_.erase(joint_name);\n+  }\n+  if (effort_circle_.find(joint_name) == effort_circle_.end() && enabled) {  // disable -> enable\n+    effort_circle_[joint_name] = new rviz_rendering::BillboardLine(scene_manager_, parent_node_);\n+    effort_arrow_[joint_name] = new rviz_rendering::Arrow(scene_manager_, parent_node_);\n+  }\n+\n+  if (!enabled) {\n+    return;\n+  }\n+\n+  float effort_value;\n+\n+  if (max_effort != 0.0) {\n+    effort_value = static_cast<float>(std::fmin(fabs(effort) / max_effort, 1.0f) + 0.05f);\n+  } else {\n+    effort_value = static_cast<float>(fabs(effort) + 0.05f);\n+  }\n+\n+  effort_arrow_[joint_name]->set(0, width_ * 2.0f, width_ * 2.0f * 1.0f, width_ * 2.0f * 2.0f);\n+  if (effort > 0) {\n+    effort_arrow_[joint_name]->setDirection(orientation_[joint_name] * Ogre::Vector3(-1, 0, 0));\n+  } else {\n+    effort_arrow_[joint_name]->setDirection(orientation_[joint_name] * Ogre::Vector3(1, 0, 0));\n+  }\n+  effort_arrow_[joint_name]->setPosition(\n+    orientation_[joint_name] *\n+    Ogre::Vector3(0, 0.05f + effort_value * scale_ * 0.5f, 0) +\n+    position_[joint_name]);\n+  effort_circle_[joint_name]->clear();\n+  effort_circle_[joint_name]->setLineWidth(width_);\n+  for (int i = 0; i < 30; i++) {\n+    Ogre::Vector3 point =\n+      Ogre::Vector3(\n+      static_cast<float>((0.05f + effort_value * scale_ * 0.5f) * sin(i * 2.0f * M_PI / 32.0f)),\n+      static_cast<float>((0.05f + effort_value * scale_ * 0.5f) * cos(i * 2.0f * M_PI / 32.0f)),\n+      static_cast<float>(0));\n+    if (effort < 0) {\n+      point.x = -point.x;\n+    }\n+    effort_circle_[joint_name]->addPoint(orientation_[joint_name] * point + position_[joint_name]);\n+  }\n+  Ogre::ColourValue color;\n+  getRainbowColor(effort_value, color);\n+  effort_arrow_[joint_name]->setColor(color.r, color.g, color.b, color.a);\n+  effort_circle_[joint_name]->setColor(color.r, color.g, color.b, color.a);\n+}\n+\n+void EffortVisual::setFrameEnabled(const std::string & joint_name, const bool e)\n+{\n+  effort_enabled_[joint_name] = e;\n+}\n+\n+// Position and orientation are passed through to the SceneNode.\n+void EffortVisual::setFramePosition(const std::string & joint_name, const Ogre::Vector3 & position)\n+{\n+  position_[joint_name] = position;\n+}\n+\n+void EffortVisual::setFrameOrientation(\n+  const std::string & joint_name, const Ogre::Quaternion & orientation)\n+{\n+  orientation_[joint_name] = orientation;\n+}\n+\n+void EffortVisual::setWidth(float w)\n+{\n+  width_ = w;\n+}\n+\n+void EffortVisual::setScale(float s)\n+{\n+  scale_ = s;\n+}\n+\n+}  // namespace rviz_rendering"},{"role":"user","content":"+/*\n+ * Copyright (c) 2023, Open Source Robotics Foundation, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *     * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *     * Neither the name of the Willow Garage, Inc. nor the names of its\n+ *       contributors may be used to endorse or promote products derived from\n+ *       this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include <gmock/gmock.h>\n+\n+#include <OgreRoot.h>\n+#include <OgreSceneNode.h>\n+\n+#include <memory>\n+\n+#include \"../ogre_testing_environment.hpp\"\n+#include \"../scene_graph_introspection.hpp\"\n+#include \"rviz_rendering/objects/effort_visual.hpp\"\n+\n+using namespace ::testing;  // NOLINT\n+\n+MATCHER_P(ColorEq, expected, \"\") {\n+  return Ogre::Math::Abs(expected.a - arg.a) < 0.0001f &&\n+         Ogre::Math::Abs(expected.r - arg.r) < 0.0001f &&\n+         Ogre::Math::Abs(expected.g - arg.g) < 0.0001f &&\n+         Ogre::Math::Abs(expected.b - arg.b) < 0.0001f;\n+}\n+\n+MATCHER_P(Vector3Eq, expected, \"\") {\n+  return Ogre::Math::Abs(expected.x - arg.x) < 0.0001f &&\n+         Ogre::Math::Abs(expected.y - arg.y) < 0.0001f &&\n+         Ogre::Math::Abs(expected.z - arg.z) < 0.0001f;\n+}\n+\n+MATCHER_P(QuaterionEq, expected, \"\") {\n+  return Ogre::Math::Abs(expected.x - arg.x) < 0.0001f &&\n+         Ogre::Math::Abs(expected.y - arg.y) < 0.0001f &&\n+         Ogre::Math::Abs(expected.z - arg.z) < 0.0001f &&\n+         Ogre::Math::Abs(expected.w - arg.w) < 0.0001f;\n+}\n+\n+\n+class EffortVisualTestFixture : public ::testing::Test\n+{\n+protected:\n+  void SetUp()\n+  {\n+    testing_environment_ = std::make_shared<rviz_rendering::OgreTestingEnvironment>();\n+    testing_environment_->setUpOgreTestEnvironment();\n+  }\n+\n+  std::shared_ptr<rviz_rendering::OgreTestingEnvironment> testing_environment_;\n+};\n+\n+Ogre::SceneNode * findForceArrow(Ogre::SceneNode * scene_node)\n+{\n+  auto arrows = rviz_rendering::findAllArrows(scene_node);\n+  auto billboard_line = rviz_rendering::findOneBillboardChain(scene_node);\n+  for (const auto & arrow : arrows) {\n+    if (billboard_line->getParentSceneNode()->getParent() == arrow->getParent()) {\n+      return arrow;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+\n+TEST_F(EffortVisualTestFixture, setEffort_sets_force_arrow_correctly) {\n+  auto scene_manager = Ogre::Root::getSingletonPtr()->createSceneManager();\n+  auto root_node = scene_manager->getRootSceneNode();\n+\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+\n+  Ogre::ColourValue color;\n+  effort_visual->getRainbowColor(0, color);\n+\n+  EXPECT_THAT(color, ColorEq(Ogre::ColourValue(1, 0, 1, 1)));\n+  effort_visual->getRainbowColor(1, color);\n+  EXPECT_THAT(color, ColorEq(Ogre::ColourValue(1, 0, 0, 1)));\n+\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+\n+  effort_visual->setFramePosition(\"joint1\", Ogre::Vector3());\n+  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  EXPECT_THAT(arrows, SizeIs(1u));\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(0.0f, 0.0f, -0.05f)));\n+\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalOrientation(Ogre::Quaternion()),\n+    QuaterionEq(Ogre::Quaternion(0.5, 0.5, -0.5, -0.5)));\n+\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setFramePosition(\"joint1\", pos1);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+  EXPECT_THAT(\n+    arrows[0]->convertWorldToLocalPosition(Ogre::Vector3(0, 0, 0)),\n+    Vector3Eq(Ogre::Vector3(3.0f, 1.0f, -2.05f)));\n+}\n+\n+TEST_F(EffortVisualTestFixture, setEffort_hides_force_arrow_for_larger_width_than_scale) {\n+  auto scene_manager = Ogre::Root::getSingletonPtr()->createSceneManager();\n+  auto root_node = scene_manager->getRootSceneNode();\n+\n+  auto effort_visual = std::make_shared<rviz_rendering::EffortVisual>(scene_manager, root_node);\n+\n+  Ogre::Vector3 pos1(1, 2, 3);\n+  effort_visual->setEffort(\"joint1\", 1, 10);\n+\n+  effort_visual->setScale(0.7f);\n+  effort_visual->setWidth(5);\n+\n+  auto arrows = rviz_rendering::findAllArrows(root_node);\n+  EXPECT_THAT(arrows, SizeIs(1u));\n+  auto force_arrow = findForceArrow(root_node);\n+  EXPECT_THAT(force_arrow->getScale(), Vector3Eq(Ogre::Vector3(1, 1, 1)));\n+}"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+#include <cstdint>"},{"role":"assistant","content":"Yes"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+/// Match majority of endpoints currently available while maintaining the highest level of service\n+/**\n+ * Reliability, durability, deadline, liveliness, and liveliness lease duration policies will be\n+ * chosen at the time of creating a subscription or publisher.\n+ *\n+ * The actual QoS policy can be retrieved after the endpoint is created with\n+ * `rmw_get_subscriptions_info_by_topic` or `rmw_get_publishers_info_by_topic`.\n+ *\n+ * The middleware is not expected to update policies after creating a subscription or\n+ * publisher, even if one or more policies are incompatible with newly discovered endpoints.\n+ * Therefore, this profile should be used with care since non-deterministic behavior\n+ * can occur due to races with discovery.\n+ */\n+static const rmw_qos_profile_t rmw_qos_profile_best_available =\n+{\n+  RMW_QOS_POLICY_HISTORY_KEEP_LAST,\n+  10,\n+  RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE,\n+  RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE,\n+  RMW_QOS_DEADLINE_BEST_AVAILABLE,\n+  RMW_QOS_LIFESPAN_DEFAULT,\n+  RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE,\n+  RMW_QOS_LIVELINESS_LEASE_DURATION_BEST_AVAILABLE,\n+  false\n+};\n+"},{"role":"user","content":"-  RMW_QOS_POLICY_RELIABILITY_UNKNOWN\n+  RMW_QOS_POLICY_RELIABILITY_UNKNOWN,\n+\n+  /// Will match the majority of endpoints and use a reliable policy if possible\n+  /**\n+   * A policy will be chosen at the time of creating a subscription or publisher.\n+   * A reliable policy will by chosen if it matches with all discovered endpoints,\n+   * otherwise a best effort policy will be chosen.\n+   *\n+   * The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n+   * `rmw_publisher_get_actual_qos` may be best available, reliable, or best effort.\n+   *\n+   * Services and clients are not supported and default to the reliability value in\n+   * `rmw_qos_profile_services_default`.\n+   *\n+   * The middleware is not expected to update the policy after creating a subscription or\n+   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n+   * Therefore, this policy should be used with care since non-deterministic behavior\n+   * can occur due to races with discovery.\n+   */\n+  RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE"},{"role":"user","content":"-  RMW_QOS_POLICY_DURABILITY_UNKNOWN\n+  RMW_QOS_POLICY_DURABILITY_UNKNOWN,\n+\n+  /// Will match the majority of endpoints and use a transient local policy if possible\n+  /**\n+   * A policy will be chosen at the time of creating a subscription or publisher.\n+   * A transient local policy will by chosen if it matches with all discovered endpoints,\n+   * otherwise a volatile policy will be chosen.\n+   *\n+   * In the case that a volatile policy is chosen for a subscription, any messages sent before\n+   * the subscription was created by transient local publishers will not be received.\n+   *\n+   * The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n+   * `rmw_publisher_get_actual_qos` may be best available, transient local, or volatile.\n+   *\n+   * Services and clients are not supported and default to the durability value in\n+   * `rmw_qos_profile_services_default`.\n+   *\n+   * The middleware is not expected to update the policy after creating a subscription or\n+   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n+   * Therefore, this policy should be used with care since non-deterministic behavior\n+   * can occur due to races with discovery.\n+   */\n+  RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE"},{"role":"user","content":"-  RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4\n+  RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4,\n+\n+  /// Will match the majority of endpoints and use a manual by topic policy if possible\n+  /**\n+   * A policy will be chosen at the time of creating a subscription or publisher.\n+   * A manual by topic policy will by chosen if it matches with all discovered endpoints,\n+   * otherwise an automatic policy will be chosen.\n+   *\n+   * The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n+   * `rmw_publisher_get_actual_qos` may be best available, automatic, or manual by topic.\n+   *\n+   * Services and clients are not supported and default to the liveliness value in\n+   * `rmw_qos_profile_services_default`.\n+   *\n+   * The middleware is not expected to update the policy after creating a subscription or\n+   * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n+   * Therefore, this policy should be used with care since non-deterministic behavior\n+   * can occur due to races with discovery.\n+   */\n+  RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE = 5"},{"role":"user","content":"+/// Will match the majority of endpoints while maintaining as strict a policy as possible\n+/**\n+ * Value is RMW_DURATION_INFINITE - 1.\n+ *\n+ * A policy will be chosen at the time of creating a subscription or publisher.\n+ * For a subscription, the deadline will be the maximum value of all discovered publisher\n+ * deadlines.\n+ * For a publisher, the deadline will be the minimum value of all discovered subscription\n+ * deadlines.\n+ *\n+ * The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n+ * `rmw_publisher_get_actual_qos` may be best available or the actual deadline value.\n+ *\n+ * Services and clients are not supported and default to the deadline value in\n+ * `rmw_qos_profile_services_default`.\n+ *\n+ * The middleware is not expected to update the policy after creating a subscription or\n+ * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n+ * Therefore, this policy should be used with care since non-deterministic behavior\n+ * can occur due to races with discovery.\n+ */\n+#define RMW_QOS_DEADLINE_BEST_AVAILABLE {9223372036LL, 854775806LL}"},{"role":"user","content":"+/// Will match the majority of endpoints while maintaining as strict a policy as possible\n+/**\n+ * Value is RMW_DURATION_INFINITE - 1.\n+ *\n+ * A policy will be chosen at the time of creating a subscription or publisher.\n+ * For a subscription, the lease duration will be the maximum value of all discovered publisher\n+ * lease durations.\n+ * For a publisher, the lease duration will be the minimum value of all discovered subscription\n+ * lease durations.\n+ *\n+ * The QoS policy reported by functions like `rmw_subscription_get_actual_qos` or\n+ * `rmw_publisher_get_actual_qos` may be best available or the actual lease duration value.\n+ *\n+ * Services and clients are not supported and default to the lease duration value in\n+ * `rmw_qos_profile_services_default`.\n+ *\n+ * The middleware is not expected to update the policy after creating a subscription or\n+ * publisher, even if the chosen policy is incompatible with newly discovered endpoints.\n+ * Therefore, this policy should be used with care since non-deterministic behavior\n+ * can occur due to races with discovery.\n+ */\n+#define RMW_QOS_LIVELINESS_LEASE_DURATION_BEST_AVAILABLE {9223372036LL, 854775806LL}"},{"role":"user","content":"+    case RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE:\n+      return \"best_available\";"},{"role":"user","content":"+    case RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE:\n+      return \"best_available\";"},{"role":"user","content":"+    case RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE:\n+      return \"best_available\";"},{"role":"user","content":"+  if (RMW_QOS_STREQ_WITH_LITERAL(\"best_available\", str)) {\n+    return RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE;\n+  }"},{"role":"user","content":"+  if (RMW_QOS_STREQ_WITH_LITERAL(\"best_available\", str)) {\n+    return RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE;\n+  }"},{"role":"user","content":"+  if (RMW_QOS_STREQ_WITH_LITERAL(\"best_available\", str)) {\n+    return RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE;\n+  }"},{"role":"user","content":"+  TEST_QOS_POLICY_VALUE_STRINGIFY(durability, RMW_QOS_POLICY_DURABILITY_BEST_AVAILABLE);"},{"role":"user","content":"+  TEST_QOS_POLICY_VALUE_STRINGIFY(liveliness, RMW_QOS_POLICY_LIVELINESS_BEST_AVAILABLE);"},{"role":"user","content":"+  TEST_QOS_POLICY_VALUE_STRINGIFY(reliability, RMW_QOS_POLICY_RELIABILITY_BEST_AVAILABLE);"},{"role":"assistant","content":"No"}]}
{"messages":[{"role":"system","content":"You are a commit classifier that decides if a code commit is important enough to be backported. ‘+’ marks added lines, ‘–’ marks removed lines. Only the changed lines of code are given. Reply only with 'Yes' or 'No'."},{"role":"user","content":"+  if (ret != RMW_RET_OK) {\n+    allocator.deallocate(tmp.enclave, allocator.state);\n+    rmw_security_options_fini(&tmp.security_options, &allocator);\n+    // Error already set\n+    return ret;\n+  }"},{"role":"assistant","content":"No"}]}
